From cb20441572eae98734ec2b59673b7cdbadf7fc75 Mon Sep 17 00:00:00 2001
From: Jan Hentschel <jan.hentschel@ultratendency.com>
Date: Wed, 28 Dec 2016 18:52:51 +0100
Subject: [PATCH] HBASE-17382 Renamed RegionLocateType to RegionLocationType

---
 .../hbase/client/AsyncBatchRpcRetryingCaller.java  |  2 +-
 .../hadoop/hbase/client/AsyncClientScanner.java    |  6 ++--
 .../hbase/client/AsyncNonMetaRegionLocator.java    | 28 +++++++++---------
 .../hadoop/hbase/client/AsyncRegionLocator.java    |  2 +-
 .../client/AsyncRpcRetryingCallerFactory.java      |  6 ++--
 .../AsyncScanSingleRegionRpcRetryingCaller.java    |  8 +++---
 .../AsyncSingleRequestRpcRetryingCaller.java       |  8 +++---
 .../client/AsyncSmallScanRpcRetryingCaller.java    | 12 ++++----
 .../hbase/client/AsyncTableRegionLocatorImpl.java  |  2 +-
 .../hadoop/hbase/client/RegionLocateType.java      | 33 ----------------------
 .../hadoop/hbase/client/RegionLocationType.java    | 33 ++++++++++++++++++++++
 .../client/TestAsyncNonMetaRegionLocator.java      | 28 +++++++++---------
 ...stAsyncNonMetaRegionLocatorConcurrenyLimit.java |  2 +-
 .../client/TestAsyncRegionLocatorTimeout.java      |  4 +--
 .../TestAsyncSingleRequestRpcRetryingCaller.java   |  2 +-
 15 files changed, 88 insertions(+), 88 deletions(-)
 delete mode 100644 hbase-client/src/main/java/org/apache/hadoop/hbase/client/RegionLocateType.java
 create mode 100644 hbase-client/src/main/java/org/apache/hadoop/hbase/client/RegionLocationType.java

diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncBatchRpcRetryingCaller.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncBatchRpcRetryingCaller.java
index 6f0b8e9..5137795 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncBatchRpcRetryingCaller.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncBatchRpcRetryingCaller.java
@@ -444,7 +444,7 @@ class AsyncBatchRpcRetryingCaller<T> {
     }
     CompletableFuture.allOf(actions
         .map(action -> conn.getLocator().getRegionLocation(tableName, action.getAction().getRow(),
-          RegionLocateType.CURRENT, locateTimeoutNs).whenComplete((loc, error) -> {
+          RegionLocationType.CURRENT, locateTimeoutNs).whenComplete((loc, error) -> {
             if (error != null) {
               error = translateException(error);
               if (error instanceof DoNotRetryIOException) {
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncClientScanner.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncClientScanner.java
index dfffd39..e12eb9e 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncClientScanner.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncClientScanner.java
@@ -131,7 +131,7 @@ class AsyncClientScanner {
         });
   }
 
-  private void openScanner(RegionLocateType locateType) {
+  private void openScanner(RegionLocationType locateType) {
     conn.callerFactory.<OpenScannerResponse> single().table(tableName).row(scan.getStartRow())
         .locateType(locateType).rpcTimeout(rpcTimeoutNs, TimeUnit.NANOSECONDS)
         .operationTimeout(scanTimeoutNs, TimeUnit.NANOSECONDS).action(this::callOpenScanner).call()
@@ -145,7 +145,7 @@ class AsyncClientScanner {
   }
 
   public void start() {
-    openScanner(scan.isReversed() && isEmptyStartRow(scan.getStartRow()) ? RegionLocateType.BEFORE
-        : RegionLocateType.CURRENT);
+    openScanner(scan.isReversed() && isEmptyStartRow(scan.getStartRow()) ? RegionLocationType.BEFORE
+        : RegionLocationType.CURRENT);
   }
 }
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaRegionLocator.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaRegionLocator.java
index ae79b65..6182b58 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaRegionLocator.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaRegionLocator.java
@@ -78,9 +78,9 @@ class AsyncNonMetaRegionLocator {
 
     public final byte[] row;
 
-    public final RegionLocateType locateType;
+    public final RegionLocationType locateType;
 
-    public LocateRequest(byte[] row, RegionLocateType locateType) {
+    public LocateRequest(byte[] row, RegionLocationType locateType) {
       this.row = row;
       this.locateType = locateType;
     }
@@ -193,7 +193,7 @@ class AsyncNonMetaRegionLocator {
       return true;
     }
     boolean completed;
-    if (req.locateType.equals(RegionLocateType.BEFORE)) {
+    if (req.locateType.equals(RegionLocationType.BEFORE)) {
       // for locating the row before current row, the common case is to find the previous region in
       // reverse scan, so we check the endKey first. In general, the condition should be startKey <
       // req.row and endKey >= req.row. Here we split it to endKey == req.row || (endKey > req.row
@@ -331,7 +331,7 @@ class AsyncNonMetaRegionLocator {
     if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {
       if (LOG.isTraceEnabled()) {
         LOG.trace("Found " + loc + " in cache for '" + tableName + "', row='"
-            + Bytes.toStringBinary(row) + "', locateType=" + RegionLocateType.CURRENT);
+            + Bytes.toStringBinary(row) + "', locateType=" + RegionLocationType.CURRENT);
       }
       return loc;
     } else {
@@ -351,7 +351,7 @@ class AsyncNonMetaRegionLocator {
         || Bytes.compareTo(loc.getRegionInfo().getEndKey(), row) >= 0) {
       if (LOG.isTraceEnabled()) {
         LOG.trace("Found " + loc + " in cache for '" + tableName + "', row='"
-            + Bytes.toStringBinary(row) + "', locateType=" + RegionLocateType.BEFORE);
+            + Bytes.toStringBinary(row) + "', locateType=" + RegionLocationType.BEFORE);
       }
       return loc;
     } else {
@@ -365,7 +365,7 @@ class AsyncNonMetaRegionLocator {
           + "', locateType=" + req.locateType + " in meta");
     }
     byte[] metaKey;
-    if (req.locateType.equals(RegionLocateType.BEFORE)) {
+    if (req.locateType.equals(RegionLocationType.BEFORE)) {
       if (isEmptyStopRow(req.row)) {
         byte[] binaryTableName = tableName.getName();
         metaKey = Arrays.copyOf(binaryTableName, binaryTableName.length + 1);
@@ -381,8 +381,8 @@ class AsyncNonMetaRegionLocator {
   }
 
   private HRegionLocation locateInCache(TableCache tableCache, TableName tableName, byte[] row,
-      RegionLocateType locateType) {
-    return locateType.equals(RegionLocateType.BEFORE)
+      RegionLocationType locateType) {
+    return locateType.equals(RegionLocationType.BEFORE)
         ? locateRowBeforeInCache(tableCache, tableName, row)
         : locateRowInCache(tableCache, tableName, row);
   }
@@ -391,9 +391,9 @@ class AsyncNonMetaRegionLocator {
   // placed before it. Used for reverse scan. See the comment of
   // AsyncRegionLocator.getPreviousRegionLocation.
   private CompletableFuture<HRegionLocation> getRegionLocationInternal(TableName tableName,
-      byte[] row, RegionLocateType locateType) {
+      byte[] row, RegionLocationType locateType) {
     // AFTER should be convert to CURRENT before calling this method
-    assert !locateType.equals(RegionLocateType.AFTER);
+    assert !locateType.equals(RegionLocationType.AFTER);
     TableCache tableCache = getTableCache(tableName);
     HRegionLocation loc = locateInCache(tableCache, tableName, row, locateType);
     if (loc != null) {
@@ -426,16 +426,16 @@ class AsyncNonMetaRegionLocator {
   }
 
   CompletableFuture<HRegionLocation> getRegionLocation(TableName tableName, byte[] row,
-      RegionLocateType locateType) {
-    if (locateType.equals(RegionLocateType.BEFORE)) {
+      RegionLocationType locateType) {
+    if (locateType.equals(RegionLocationType.BEFORE)) {
       return getRegionLocationInternal(tableName, row, locateType);
     } else {
       // as we know the exact row after us, so we can just create the new row, and use the same
       // algorithm to locate it.
-      if (locateType.equals(RegionLocateType.AFTER)) {
+      if (locateType.equals(RegionLocationType.AFTER)) {
         row = createClosestRowAfter(row);
       }
-      return getRegionLocationInternal(tableName, row, RegionLocateType.CURRENT);
+      return getRegionLocationInternal(tableName, row, RegionLocationType.CURRENT);
     }
   }
 
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java
index 7a45ae3..9b2dcea 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java
@@ -79,7 +79,7 @@ class AsyncRegionLocator {
   }
 
   CompletableFuture<HRegionLocation> getRegionLocation(TableName tableName, byte[] row,
-      RegionLocateType type, long timeoutNs) {
+                                                       RegionLocationType type, long timeoutNs) {
     // meta region can not be split right now so we always call the same method.
     // Change it later if the meta table can have more than one regions.
     CompletableFuture<HRegionLocation> future =
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRpcRetryingCallerFactory.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRpcRetryingCallerFactory.java
index c90bee2..e943b67 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRpcRetryingCallerFactory.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRpcRetryingCallerFactory.java
@@ -58,7 +58,7 @@ class AsyncRpcRetryingCallerFactory {
 
     private long rpcTimeoutNs = -1L;
 
-    private RegionLocateType locateType = RegionLocateType.CURRENT;
+    private RegionLocationType locateType = RegionLocationType.CURRENT;
 
     public SingleRequestCallerBuilder<T> table(TableName tableName) {
       this.tableName = tableName;
@@ -86,7 +86,7 @@ class AsyncRpcRetryingCallerFactory {
       return this;
     }
 
-    public SingleRequestCallerBuilder<T> locateType(RegionLocateType locateType) {
+    public SingleRequestCallerBuilder<T> locateType(RegionLocationType locateType) {
       this.locateType = locateType;
       return this;
     }
@@ -246,7 +246,7 @@ class AsyncRpcRetryingCallerFactory {
     /**
      * Short cut for {@code build().start()}.
      */
-    public CompletableFuture<RegionLocateType> start() {
+    public CompletableFuture<RegionLocationType> start() {
       return build().start();
     }
   }
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncScanSingleRegionRpcRetryingCaller.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncScanSingleRegionRpcRetryingCaller.java
index 5bf6195..0d64104 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncScanSingleRegionRpcRetryingCaller.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncScanSingleRegionRpcRetryingCaller.java
@@ -95,7 +95,7 @@ class AsyncScanSingleRegionRpcRetryingCaller {
 
   private final Runnable completeWhenNoMoreResultsInRegion;
 
-  private final CompletableFuture<RegionLocateType> future;
+  private final CompletableFuture<RegionLocationType> future;
 
   private final HBaseRpcController controller;
 
@@ -172,7 +172,7 @@ class AsyncScanSingleRegionRpcRetryingCaller {
 
   private void completeWithNextStartRow(byte[] nextStartRow) {
     scan.setStartRow(nextStartRow);
-    future.complete(scan.isReversed() ? RegionLocateType.BEFORE : RegionLocateType.CURRENT);
+    future.complete(scan.isReversed() ? RegionLocationType.BEFORE : RegionLocationType.CURRENT);
   }
 
   private byte[] createNextStartRowWhenError() {
@@ -194,7 +194,7 @@ class AsyncScanSingleRegionRpcRetryingCaller {
     }
     future.complete(
       scan.isReversed() && Bytes.equals(scan.getStartRow(), loc.getRegionInfo().getEndKey())
-          ? RegionLocateType.BEFORE : RegionLocateType.CURRENT);
+          ? RegionLocationType.BEFORE : RegionLocationType.CURRENT);
   }
 
   private void onError(Throwable error) {
@@ -345,7 +345,7 @@ class AsyncScanSingleRegionRpcRetryingCaller {
   /**
    * @return return locate direction for next open scanner call, or null if we should stop.
    */
-  public CompletableFuture<RegionLocateType> start() {
+  public CompletableFuture<RegionLocationType> start() {
     next();
     return future;
   }
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncSingleRequestRpcRetryingCaller.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncSingleRequestRpcRetryingCaller.java
index 04e69af..9f48f9d 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncSingleRequestRpcRetryingCaller.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncSingleRequestRpcRetryingCaller.java
@@ -66,7 +66,7 @@ class AsyncSingleRequestRpcRetryingCaller<T> {
 
   private final byte[] row;
 
-  private final RegionLocateType locateType;
+  private final RegionLocationType locateType;
 
   private final Callable<T> callable;
 
@@ -89,9 +89,9 @@ class AsyncSingleRequestRpcRetryingCaller<T> {
   private final long startNs;
 
   public AsyncSingleRequestRpcRetryingCaller(HashedWheelTimer retryTimer, AsyncConnectionImpl conn,
-      TableName tableName, byte[] row, RegionLocateType locateType, Callable<T> callable,
-      long pauseNs, int maxRetries, long operationTimeoutNs, long rpcTimeoutNs,
-      int startLogErrorsCnt) {
+                                             TableName tableName, byte[] row, RegionLocationType locateType, Callable<T> callable,
+                                             long pauseNs, int maxRetries, long operationTimeoutNs, long rpcTimeoutNs,
+                                             int startLogErrorsCnt) {
     this.retryTimer = retryTimer;
     this.conn = conn;
     this.tableName = tableName;
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncSmallScanRpcRetryingCaller.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncSmallScanRpcRetryingCaller.java
index c4c2074..5eeb8fc 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncSmallScanRpcRetryingCaller.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncSmallScanRpcRetryingCaller.java
@@ -144,7 +144,7 @@ class AsyncSmallScanRpcRetryingCaller {
         scan.setStartRow(
           createClosestNextRow.apply(resp.results[resp.results.length - 1].getRow()));
       }
-      scan(RegionLocateType.CURRENT);
+      scan(RegionLocationType.CURRENT);
       return;
     }
     if (!nextScan.apply(resp.currentRegion)) {
@@ -152,7 +152,7 @@ class AsyncSmallScanRpcRetryingCaller {
     }
   }
 
-  private void scan(RegionLocateType locateType) {
+  private void scan(RegionLocationType locateType) {
     conn.callerFactory.<SmallScanResponse> single().table(tableName).row(scan.getStartRow())
         .rpcTimeout(rpcTimeoutNs, TimeUnit.NANOSECONDS)
         .operationTimeout(scanTimeoutNs, TimeUnit.NANOSECONDS).locateType(locateType)
@@ -171,11 +171,11 @@ class AsyncSmallScanRpcRetryingCaller {
   }
 
   private void firstScan() {
-    scan(RegionLocateType.CURRENT);
+    scan(RegionLocationType.CURRENT);
   }
 
   private void reversedFirstScan() {
-    scan(isEmptyStartRow(scan.getStartRow()) ? RegionLocateType.BEFORE : RegionLocateType.CURRENT);
+    scan(isEmptyStartRow(scan.getStartRow()) ? RegionLocationType.BEFORE : RegionLocationType.CURRENT);
   }
 
   private boolean nextScan(HRegionInfo region) {
@@ -189,7 +189,7 @@ class AsyncSmallScanRpcRetryingCaller {
       }
     }
     scan.setStartRow(region.getEndKey());
-    scan(RegionLocateType.CURRENT);
+    scan(RegionLocationType.CURRENT);
     return true;
   }
 
@@ -204,7 +204,7 @@ class AsyncSmallScanRpcRetryingCaller {
       }
     }
     scan.setStartRow(region.getStartKey());
-    scan(RegionLocateType.BEFORE);
+    scan(RegionLocationType.BEFORE);
     return true;
   }
 }
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncTableRegionLocatorImpl.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncTableRegionLocatorImpl.java
index 1986962..c6f7515 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncTableRegionLocatorImpl.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncTableRegionLocatorImpl.java
@@ -45,6 +45,6 @@ class AsyncTableRegionLocatorImpl implements AsyncTableRegionLocator {
 
   @Override
   public CompletableFuture<HRegionLocation> getRegionLocation(byte[] row, boolean reload) {
-    return locator.getRegionLocation(tableName, row, RegionLocateType.CURRENT, -1L);
+    return locator.getRegionLocation(tableName, row, RegionLocationType.CURRENT, -1L);
   }
 }
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/RegionLocateType.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/RegionLocateType.java
deleted file mode 100644
index 57f9498..0000000
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/RegionLocateType.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.hadoop.hbase.client;
-
-import org.apache.hadoop.hbase.classification.InterfaceAudience;
-
-/**
- * Indicate which row you want to locate.
- * <ul>
- * <li>{@link #BEFORE} locate the region which contains the row before the given row.</li>
- * <li>{@link #CURRENT} locate the region which contains the given row.</li>
- * <li>{@link #AFTER} locate the region which contains the row after the given row.</li>
- * </ul>
- */
-@InterfaceAudience.Private
-enum RegionLocateType {
-  BEFORE, CURRENT, AFTER
-}
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/RegionLocationType.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/RegionLocationType.java
new file mode 100644
index 0000000..6f08f34
--- /dev/null
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/RegionLocationType.java
@@ -0,0 +1,33 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.client;
+
+import org.apache.hadoop.hbase.classification.InterfaceAudience;
+
+/**
+ * Indicate which row you want to locate.
+ * <ul>
+ * <li>{@link #BEFORE} locate the region which contains the row before the given row.</li>
+ * <li>{@link #CURRENT} locate the region which contains the given row.</li>
+ * <li>{@link #AFTER} locate the region which contains the row after the given row.</li>
+ * </ul>
+ */
+@InterfaceAudience.Private
+enum RegionLocationType {
+  BEFORE, CURRENT, AFTER
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncNonMetaRegionLocator.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncNonMetaRegionLocator.java
index 40fca72..cb98f0c 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncNonMetaRegionLocator.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncNonMetaRegionLocator.java
@@ -101,7 +101,7 @@ public class TestAsyncNonMetaRegionLocator {
 
   @Test
   public void testNoTable() throws InterruptedException {
-    for (RegionLocateType locateType : RegionLocateType.values()) {
+    for (RegionLocationType locateType : RegionLocationType.values()) {
       try {
         LOCATOR.getRegionLocation(TABLE_NAME, EMPTY_START_ROW, locateType).get();
       } catch (ExecutionException e) {
@@ -114,7 +114,7 @@ public class TestAsyncNonMetaRegionLocator {
   public void testDisableTable() throws IOException, InterruptedException {
     createSingleRegionTable();
     TEST_UTIL.getAdmin().disableTable(TABLE_NAME);
-    for (RegionLocateType locateType : RegionLocateType.values()) {
+    for (RegionLocationType locateType : RegionLocationType.values()) {
       try {
         LOCATOR.getRegionLocation(TABLE_NAME, EMPTY_START_ROW, locateType).get();
       } catch (ExecutionException e) {
@@ -136,13 +136,13 @@ public class TestAsyncNonMetaRegionLocator {
   public void testSingleRegionTable() throws IOException, InterruptedException, ExecutionException {
     createSingleRegionTable();
     ServerName serverName = TEST_UTIL.getRSForFirstRegionInTable(TABLE_NAME).getServerName();
-    for (RegionLocateType locateType : RegionLocateType.values()) {
+    for (RegionLocationType locateType : RegionLocationType.values()) {
       assertLocEquals(EMPTY_START_ROW, EMPTY_END_ROW, serverName,
         LOCATOR.getRegionLocation(TABLE_NAME, EMPTY_START_ROW, locateType).get());
     }
     byte[] randKey = new byte[ThreadLocalRandom.current().nextInt(128)];
     ThreadLocalRandom.current().nextBytes(randKey);
-    for (RegionLocateType locateType : RegionLocateType.values()) {
+    for (RegionLocationType locateType : RegionLocationType.values()) {
       assertLocEquals(EMPTY_START_ROW, EMPTY_END_ROW, serverName,
         LOCATOR.getRegionLocation(TABLE_NAME, randKey, locateType).get());
     }
@@ -182,7 +182,7 @@ public class TestAsyncNonMetaRegionLocator {
       try {
         assertLocEquals(startKeys[i], i == startKeys.length - 1 ? EMPTY_END_ROW : startKeys[i + 1],
           serverNames[i],
-          LOCATOR.getRegionLocation(TABLE_NAME, startKeys[i], RegionLocateType.CURRENT).get());
+          LOCATOR.getRegionLocation(TABLE_NAME, startKeys[i], RegionLocationType.CURRENT).get());
       } catch (InterruptedException | ExecutionException e) {
         throw new RuntimeException(e);
       }
@@ -193,7 +193,7 @@ public class TestAsyncNonMetaRegionLocator {
       try {
         assertLocEquals(startKeys[i], i == startKeys.length - 1 ? EMPTY_END_ROW : startKeys[i + 1],
           serverNames[i],
-          LOCATOR.getRegionLocation(TABLE_NAME, startKeys[i], RegionLocateType.AFTER).get());
+          LOCATOR.getRegionLocation(TABLE_NAME, startKeys[i], RegionLocationType.AFTER).get());
       } catch (InterruptedException | ExecutionException e) {
         throw new RuntimeException(e);
       }
@@ -204,7 +204,7 @@ public class TestAsyncNonMetaRegionLocator {
       n -> IntStream.range(0, endKeys.length).map(i -> endKeys.length - 1 - i).forEach(i -> {
         try {
           assertLocEquals(i == 0 ? EMPTY_START_ROW : endKeys[i - 1], endKeys[i], serverNames[i],
-            LOCATOR.getRegionLocation(TABLE_NAME, endKeys[i], RegionLocateType.BEFORE).get());
+            LOCATOR.getRegionLocation(TABLE_NAME, endKeys[i], RegionLocationType.BEFORE).get());
         } catch (InterruptedException | ExecutionException e) {
           throw new RuntimeException(e);
         }
@@ -216,7 +216,7 @@ public class TestAsyncNonMetaRegionLocator {
     createSingleRegionTable();
     ServerName serverName = TEST_UTIL.getRSForFirstRegionInTable(TABLE_NAME).getServerName();
     HRegionLocation loc =
-        LOCATOR.getRegionLocation(TABLE_NAME, EMPTY_START_ROW, RegionLocateType.CURRENT).get();
+        LOCATOR.getRegionLocation(TABLE_NAME, EMPTY_START_ROW, RegionLocationType.CURRENT).get();
     assertLocEquals(EMPTY_START_ROW, EMPTY_END_ROW, serverName, loc);
     ServerName newServerName = TEST_UTIL.getHBaseCluster().getRegionServerThreads().stream()
         .map(t -> t.getRegionServer().getServerName()).filter(sn -> !sn.equals(serverName))
@@ -230,14 +230,14 @@ public class TestAsyncNonMetaRegionLocator {
     }
     // Should be same as it is in cache
     assertSame(loc,
-      LOCATOR.getRegionLocation(TABLE_NAME, EMPTY_START_ROW, RegionLocateType.CURRENT).get());
+      LOCATOR.getRegionLocation(TABLE_NAME, EMPTY_START_ROW, RegionLocationType.CURRENT).get());
     LOCATOR.updateCachedLocation(loc, null);
     // null error will not trigger a cache cleanup
     assertSame(loc,
-      LOCATOR.getRegionLocation(TABLE_NAME, EMPTY_START_ROW, RegionLocateType.CURRENT).get());
+      LOCATOR.getRegionLocation(TABLE_NAME, EMPTY_START_ROW, RegionLocationType.CURRENT).get());
     LOCATOR.updateCachedLocation(loc, new NotServingRegionException());
     assertLocEquals(EMPTY_START_ROW, EMPTY_END_ROW, newServerName,
-      LOCATOR.getRegionLocation(TABLE_NAME, EMPTY_START_ROW, RegionLocateType.CURRENT).get());
+      LOCATOR.getRegionLocation(TABLE_NAME, EMPTY_START_ROW, RegionLocationType.CURRENT).get());
   }
 
   // usually locate after will return the same result, so we add a test to make it return different
@@ -249,12 +249,12 @@ public class TestAsyncNonMetaRegionLocator {
     TEST_UTIL.createTable(TABLE_NAME, FAMILY, new byte[][] { splitKey });
     TEST_UTIL.waitTableAvailable(TABLE_NAME);
     HRegionLocation currentLoc =
-        LOCATOR.getRegionLocation(TABLE_NAME, row, RegionLocateType.CURRENT).get();
+        LOCATOR.getRegionLocation(TABLE_NAME, row, RegionLocationType.CURRENT).get();
     ServerName currentServerName = TEST_UTIL.getRSForFirstRegionInTable(TABLE_NAME).getServerName();
     assertLocEquals(EMPTY_START_ROW, splitKey, currentServerName, currentLoc);
 
     HRegionLocation afterLoc =
-        LOCATOR.getRegionLocation(TABLE_NAME, row, RegionLocateType.AFTER).get();
+        LOCATOR.getRegionLocation(TABLE_NAME, row, RegionLocationType.AFTER).get();
     ServerName afterServerName =
         TEST_UTIL.getHBaseCluster().getRegionServerThreads().stream().map(t -> t.getRegionServer())
             .filter(rs -> rs.getOnlineRegions(TABLE_NAME).stream()
@@ -262,6 +262,6 @@ public class TestAsyncNonMetaRegionLocator {
             .findAny().get().getServerName();
     assertLocEquals(splitKey, EMPTY_END_ROW, afterServerName, afterLoc);
 
-    assertSame(afterLoc, LOCATOR.getRegionLocation(TABLE_NAME, row, RegionLocateType.AFTER).get());
+    assertSame(afterLoc, LOCATOR.getRegionLocation(TABLE_NAME, row, RegionLocationType.AFTER).get());
   }
 }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncNonMetaRegionLocatorConcurrenyLimit.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncNonMetaRegionLocatorConcurrenyLimit.java
index 3918dc9..a81adb6 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncNonMetaRegionLocatorConcurrenyLimit.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncNonMetaRegionLocatorConcurrenyLimit.java
@@ -146,7 +146,7 @@ public class TestAsyncNonMetaRegionLocatorConcurrenyLimit {
   public void test() throws InterruptedException, ExecutionException {
     List<CompletableFuture<HRegionLocation>> futures =
         IntStream.range(0, 256).mapToObj(i -> Bytes.toBytes(String.format("%02x", i)))
-            .map(r -> LOCATOR.getRegionLocation(TABLE_NAME, r, RegionLocateType.CURRENT))
+            .map(r -> LOCATOR.getRegionLocation(TABLE_NAME, r, RegionLocationType.CURRENT))
             .collect(toList());
     assertLocs(futures);
     assertTrue(MAX_CONCURRENCY.get() <= MAX_ALLOWED);
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncRegionLocatorTimeout.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncRegionLocatorTimeout.java
index dfefcc7..42642be 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncRegionLocatorTimeout.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncRegionLocatorTimeout.java
@@ -100,7 +100,7 @@ public class TestAsyncRegionLocatorTimeout {
     SLEEP_MS = 1000;
     long startNs = System.nanoTime();
     try {
-      LOCATOR.getRegionLocation(TABLE_NAME, EMPTY_START_ROW, RegionLocateType.CURRENT,
+      LOCATOR.getRegionLocation(TABLE_NAME, EMPTY_START_ROW, RegionLocationType.CURRENT,
         TimeUnit.MILLISECONDS.toNanos(500)).get();
       fail();
     } catch (ExecutionException e) {
@@ -114,7 +114,7 @@ public class TestAsyncRegionLocatorTimeout {
     Thread.sleep(2000);
     // Now the location should be in cache, so we will not visit meta again.
     HRegionLocation loc = LOCATOR.getRegionLocation(TABLE_NAME, EMPTY_START_ROW,
-      RegionLocateType.CURRENT, TimeUnit.MILLISECONDS.toNanos(500)).get();
+      RegionLocationType.CURRENT, TimeUnit.MILLISECONDS.toNanos(500)).get();
     assertEquals(loc.getServerName(),
       TEST_UTIL.getHBaseCluster().getRegionServer(0).getServerName());
   }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncSingleRequestRpcRetryingCaller.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncSingleRequestRpcRetryingCaller.java
index 4a391e0..f6ed8da 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncSingleRequestRpcRetryingCaller.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncSingleRequestRpcRetryingCaller.java
@@ -154,7 +154,7 @@ public class TestAsyncSingleRequestRpcRetryingCaller {
         new AsyncRegionLocator(asyncConn, AsyncConnectionImpl.RETRY_TIMER) {
           @Override
           CompletableFuture<HRegionLocation> getRegionLocation(TableName tableName, byte[] row,
-              RegionLocateType locateType, long timeoutNs) {
+                                                               RegionLocationType locateType, long timeoutNs) {
             if (tableName.equals(TABLE_NAME)) {
               CompletableFuture<HRegionLocation> future = new CompletableFuture<>();
               if (count.getAndIncrement() == 0) {
-- 
2.6.3
