diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/CompactingMemStore.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/CompactingMemStore.java
index ed7d274..97adeb3 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/CompactingMemStore.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/CompactingMemStore.java
@@ -415,15 +415,16 @@ public class CompactingMemStore extends AbstractMemStore {
       pushToSnapshot(segments.getStoreSegments());
       // swap can return false in case the pipeline was updated by ongoing compaction
       // and the version increase, the chance of it happenning is very low
-      done = pipeline.swap(segments, null, false); // don't close segments; they are in snapshot now
-      if (iterationsCnt>2) {
+      if (iterationsCnt <= 2) {
+        done = pipeline.swap(segments, null, false);//don't close segments; they are in snapshot now
+      } else {
         // practically it is impossible that this loop iterates more than two times
         // (because the compaction is stopped and none restarts it while in snapshot request),
         // however stopping here for the case of the infinite loop causing by any error
-        LOG.warn("Multiple unsuccessful attempts to push the compaction pipeline to snapshot," +
+        LOG.error("Multiple unsuccessful attempts to push the compaction pipeline to snapshot," +
             " while flushing to disk.");
-        this.snapshot = SegmentFactory.instance().createImmutableSegment(getComparator());
-        break;
+        throw new IllegalStateException("Unexpected call to pipeline.swap() in region" +
+            regionServices.getRegionInfo().getRegionNameAsString());
       }
     }
   }
