diff --git hbase-client/src/main/java/org/apache/hadoop/hbase/filter/FuzzyRowFilter.java hbase-client/src/main/java/org/apache/hadoop/hbase/filter/FuzzyRowFilter.java
index 9b234de..eb2ca89 100644
--- hbase-client/src/main/java/org/apache/hadoop/hbase/filter/FuzzyRowFilter.java
+++ hbase-client/src/main/java/org/apache/hadoop/hbase/filter/FuzzyRowFilter.java
@@ -17,9 +17,10 @@
  */
 package org.apache.hadoop.hbase.filter;
 
-import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
 import java.util.List;
 
 import org.apache.hadoop.hbase.Cell;
@@ -32,11 +33,14 @@ import org.apache.hadoop.hbase.protobuf.generated.HBaseProtos.BytesBytesPair;
 import org.apache.hadoop.hbase.util.ByteStringer;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.hbase.util.Pair;
+import org.apache.hadoop.hbase.util.UnsafeAccess;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.protobuf.InvalidProtocolBufferException;
 
 /**
+ * This is optimized version of a standard FuzzyRowFilter
+ * 
  * Filters data based on fuzzy row key. Performs fast-forwards during scanning.
  * It takes pairs (row key, fuzzy info) to match row keys. Where fuzzy info is
  * a byte array with 0 or 1 as its values:
@@ -69,6 +73,26 @@ import com.google.protobuf.InvalidProtocolBufferException;
 public class FuzzyRowFilter extends FilterBase {
   private List<Pair<byte[], byte[]>> fuzzyKeysData;
   private boolean done = false;
+  
+  /*
+   *  If last call to filterKeyValue returned 
+   *  ReturnCode.INCLUDE (found fuzzy match).
+   */
+  private boolean lastFound = false;
+  /*
+   *  The index of a last successfully found 
+   *  matching fuzzy string (in fuzzyKeysData).
+   *  We will start matching next KV with this one.
+   *  If won't match than we will return to the 
+   *  one-by-one iteration.
+   */
+  private int lastFoundIndex = -1;
+  
+  /*
+   *  Row tracker (keeps all next rows after
+   *  SEEK_NEXT_USING_HINT was returned)
+   */
+  private RowTracker tracker;
 
   public FuzzyRowFilter(List<Pair<byte[], byte[]>> fuzzyKeysData) {
     Pair<byte[], byte[]> p;
@@ -78,75 +102,161 @@ public class FuzzyRowFilter extends FilterBase {
         Pair<String, String> readable = new Pair<String, String>(
           Bytes.toStringBinary(p.getFirst()),
           Bytes.toStringBinary(p.getSecond()));
-        throw new IllegalArgumentException("Fuzzy pair lengths do not match: " + readable);
+        throw new IllegalArgumentException(
+        		"Fuzzy pair lengths do not match: " + readable);
       }
+      // update mask ( 0 -> -1 (0xff), 1 -> 0)
+      p.setSecond(preprocessMask(p.getSecond()));
+      preprocessSearchKey(p);
     }
     this.fuzzyKeysData = fuzzyKeysData;
+    this.tracker = new RowTracker();
   }
 
-  @Override
-  public boolean filterRowKey(Cell cell) throws IOException {
-    // Impl in FilterBase might do unnecessary copy for Off heap backed Cells.
-    return false;
+  private void preprocessSearchKey(Pair<byte[], byte[]> p) {
+	  byte[] key = p.getFirst();
+	  byte[] mask = p.getSecond();
+	  for(int i=0; i < mask.length; i++){
+		  // set non-fixed part of a search key to 0.
+		  if(mask[i] == 0) key[i] = 0;
+	  }
+  }
+
+/**
+   *  We need to preprocess mask array, as since we treat 0's as unfixed 
+   *  positions and -1 (0xff) as fixed positions
+   * @param mask
+   * @return mask array
+   */
+  private byte[] preprocessMask(byte[] mask) {
+    if (isPreprocessedMask(mask)) return mask;
+    for (int i = 0; i < mask.length; i++) {
+      if (mask[i] == 0) {
+        mask[i] = -1; // 0 -> -1
+      } else if (mask[i] == 1) {
+        mask[i] = 0;// 1 -> 0
+      }
+    }
+    return mask;
+  }
+
+  private boolean isPreprocessedMask(byte[] mask) {
+    for (int i = 0; i < mask.length; i++) {
+      if (mask[i] != -1 && mask[i] != 0) {
+        return false;
+      }
+    }
+    return true;
   }
 
-  // TODO: possible improvement: save which fuzzy row key to use when providing a hint
-  @Override
   public ReturnCode filterKeyValue(Cell c) {
     // assigning "worst" result first and looking for better options
-    SatisfiesCode bestOption = SatisfiesCode.NO_NEXT;
-    for (Pair<byte[], byte[]> fuzzyData : fuzzyKeysData) {
-      SatisfiesCode satisfiesCode = satisfies(isReversed(), c.getRowArray(), c.getRowOffset(),
-        c.getRowLength(), fuzzyData.getFirst(), fuzzyData.getSecond());
+    // SatisfiesCode bestOption = SatisfiesCode.NO_NEXT;
+    final int startIndex = lastFound ? lastFoundIndex : 0;
+    final int size = fuzzyKeysData.size();
+    for (int i = startIndex; i < size + startIndex; i++) {
+      final int index = i % size;
+      Pair<byte[], byte[]> fuzzyData = fuzzyKeysData.get(index);
+      SatisfiesCode satisfiesCode =
+          satisfies(isReversed(), c.getRowArray(), c.getRowOffset(), c.getRowLength(),
+            fuzzyData.getFirst(), fuzzyData.getSecond());
       if (satisfiesCode == SatisfiesCode.YES) {
+        lastFound = true;
+        lastFoundIndex = index;
         return ReturnCode.INCLUDE;
       }
+    }
+    // NOT FOUND -> seek next using hint
+    lastFound = false;
+    return ReturnCode.SEEK_NEXT_USING_HINT;
 
-      if (satisfiesCode == SatisfiesCode.NEXT_EXISTS) {
-        bestOption = SatisfiesCode.NEXT_EXISTS;
+  }
+  
+  @Override
+  public Cell getNextCellHint(Cell currentCell) {
+    boolean result = true;
+    if (tracker.needsUpdate()) {
+      result = tracker.updateTracker(currentCell);
+    }
+    if (result == false) {
+      done = true;
+      return null;
+    }
+    byte[] nextRowKey = tracker.nextRow();
+    // We need to compare nextRowKey with currentCell
+    int compareResult =
+        Bytes.compareTo(nextRowKey, 0, nextRowKey.length, currentCell.getRowArray(),
+          currentCell.getRowOffset(), currentCell.getRowLength());
+    if ((reversed && compareResult > 0) || (!reversed && compareResult < 0)) {
+      // This can happen when we have multilpe filters and some other filter
+      // returns next row with hint which is larger (smaller for reverse)
+      // than the current (really?)
+      result = tracker.updateTracker(currentCell);
+      if (result == false) {
+        done = true;
+        return null;
+      } else {
+        nextRowKey = tracker.nextRow();
       }
     }
+    return KeyValueUtil.createFirstOnRow(nextRowKey);
+  }
 
-    if (bestOption == SatisfiesCode.NEXT_EXISTS) {
-      return ReturnCode.SEEK_NEXT_USING_HINT;
+  /**
+   * If we have multiple fuzzy keys, row tracker should improve overall performance
+   * It calculates ALL next rows (one per every fuzzy key),
+   * sort them accordingly (ascending for regular and descending for reverse).
+   * Next time  getNextCellHint is called we check row tracker first and return
+   * next row from the tracker if it exists, if there are no rows in the tracker
+   * we update tracker with current cell and return first row.
+   *
+   */
+  class RowTracker {
+    final List<byte[]> nextRows;
+    int next = -1;
+
+    RowTracker() {
+      nextRows = new ArrayList<byte[]>();
     }
 
-    // the only unhandled SatisfiesCode is NO_NEXT, i.e. we are done
-    done = true;
-    return ReturnCode.NEXT_ROW;
-  }
+    boolean needsUpdate() {
+      return next == -1 || next == nextRows.size();
+    }
 
-  @Override
-  public Cell getNextCellHint(Cell currentCell) {
-    byte[] nextRowKey = null;
-    // Searching for the "smallest" row key that satisfies at least one fuzzy row key
-    for (Pair<byte[], byte[]> fuzzyData : fuzzyKeysData) {
-      byte[] nextRowKeyCandidate = getNextForFuzzyRule(isReversed(), currentCell.getRowArray(),
-          currentCell.getRowOffset(), currentCell.getRowLength(), fuzzyData.getFirst(),
-        fuzzyData.getSecond());
-      if (nextRowKeyCandidate == null) {
-        continue;
-      }
-      if (nextRowKey == null ||
-        (reversed && Bytes.compareTo(nextRowKeyCandidate, nextRowKey) > 0) ||
-        (!reversed && Bytes.compareTo(nextRowKeyCandidate, nextRowKey) < 0)) {
-        nextRowKey = nextRowKeyCandidate;
-      }
+    byte[] nextRow() {
+      if (next < 0 || next == nextRows.size()) return null;
+      return nextRows.get(next++);
     }
 
-    if (!reversed && nextRowKey == null) {
-      // Should never happen for forward scanners; logic in filterKeyValue should return NO_NEXT.
-      // Can happen in reversed scanner when currentKV is just before the next possible match; in
-      // this case, fall back on scanner simply calling KeyValueHeap.next()
-      // TODO: is there a better way than throw exception? (stop the scanner?)
-      throw new IllegalStateException("No next row key that satisfies fuzzy exists when"
-          + " getNextKeyHint() is invoked." + " Filter: " + this.toString() + " currentKV: "
-          + currentCell);
+    boolean updateTracker(Cell currentCell) {
+      nextRows.clear();
+      for (Pair<byte[], byte[]> fuzzyData : fuzzyKeysData) {
+        byte[] nextRowKeyCandidate =
+            getNextForFuzzyRule(isReversed(), currentCell.getRowArray(),
+              currentCell.getRowOffset(), currentCell.getRowLength(), fuzzyData.getFirst(),
+              fuzzyData.getSecond());
+        if (nextRowKeyCandidate == null) {
+          continue;
+        }
+        nextRows.add(nextRowKeyCandidate);
+      }
+      // Sort all next row candidates
+      Collections.sort(nextRows, new Comparator<byte[]>() {
+        @Override
+        public int compare(byte[] o1, byte[] o2) {
+          if (reversed) {
+            return -Bytes.compareTo(o1, o2);
+          } else {
+            return Bytes.compareTo(o1, o2);
+          }
+        }
+      });
+      next = 0;
+      return nextRows.size() > 0;
     }
 
-    return nextRowKey == null ? null : KeyValueUtil.createFirstOnRow(nextRowKey);
   }
-
+  
   @Override
   public boolean filterAllRemaining() {
     return done;
@@ -227,53 +337,80 @@ public class FuzzyRowFilter extends FilterBase {
     return satisfies(reverse, row, 0, row.length, fuzzyKeyBytes, fuzzyKeyMeta);
   }
 
-  private static SatisfiesCode satisfies(boolean reverse, byte[] row, int offset, int length,
-                                         byte[] fuzzyKeyBytes, byte[] fuzzyKeyMeta) {
+
+  public static SatisfiesCode satisfies(boolean reverse, byte[] row, int offset, int length,
+      byte[] fuzzyKeyBytes, byte[] fuzzyKeyMeta) {
     if (row == null) {
       // do nothing, let scan to proceed
       return SatisfiesCode.YES;
     }
+    length = Math.min(length, fuzzyKeyBytes.length);
+    int numWords = length / Bytes.SIZEOF_LONG;
+    int offsetAdj = offset + UnsafeAccess.BYTE_ARRAY_BASE_OFFSET;
+
+    int j = numWords << 3; // numWords * SIZEOF_LONG;
+
+    for (int i = 0; i < j; i += Bytes.SIZEOF_LONG) {
+
+      long fuzzyBytes =
+          UnsafeAccess.theUnsafe.getLong(fuzzyKeyBytes, UnsafeAccess.BYTE_ARRAY_BASE_OFFSET
+              + (long) i);
+      long fuzzyMeta =
+          UnsafeAccess.theUnsafe.getLong(fuzzyKeyMeta, UnsafeAccess.BYTE_ARRAY_BASE_OFFSET
+              + (long) i);
+      long rowValue = UnsafeAccess.theUnsafe.getLong(row, offsetAdj + (long) i);
+      if ((rowValue & fuzzyMeta) != (fuzzyBytes)) {
+        // We always return NEXT_EXISTS
+        return SatisfiesCode.NEXT_EXISTS;
+      }
+    }
 
-    Order order = Order.orderFor(reverse);
-    boolean nextRowKeyCandidateExists = false;
-
-    for (int i = 0; i < fuzzyKeyMeta.length && i < length; i++) {
-      // First, checking if this position is fixed and not equals the given one
-      boolean byteAtPositionFixed = fuzzyKeyMeta[i] == 0;
-      boolean fixedByteIncorrect = byteAtPositionFixed && fuzzyKeyBytes[i] != row[i + offset];
-      if (fixedByteIncorrect) {
-        // in this case there's another row that satisfies fuzzy rule and bigger than this row
-        if (nextRowKeyCandidateExists) {
-          return SatisfiesCode.NEXT_EXISTS;
-        }
-
-        // If this row byte is less than fixed then there's a byte array bigger than
-        // this row and which satisfies the fuzzy rule. Otherwise there's no such byte array:
-        // this row is simply bigger than any byte array that satisfies the fuzzy rule
-        boolean rowByteLessThanFixed = (row[i + offset] & 0xFF) < (fuzzyKeyBytes[i] & 0xFF);
-        if (rowByteLessThanFixed && !reverse) {
-          return SatisfiesCode.NEXT_EXISTS;
-        } else if (!rowByteLessThanFixed && reverse) {
-          return SatisfiesCode.NEXT_EXISTS;
-        } else {
-          return SatisfiesCode.NO_NEXT;
-        }
+    int off = j;
+
+    if (length - off >= Bytes.SIZEOF_INT) {
+      int fuzzyBytes =
+          UnsafeAccess.theUnsafe.getInt(fuzzyKeyBytes, UnsafeAccess.BYTE_ARRAY_BASE_OFFSET
+              + (long) off);
+      int fuzzyMeta =
+          UnsafeAccess.theUnsafe.getInt(fuzzyKeyMeta, UnsafeAccess.BYTE_ARRAY_BASE_OFFSET
+              + (long) off);
+      int rowValue = UnsafeAccess.theUnsafe.getInt(row, offsetAdj + (long) off);
+      if ((rowValue & fuzzyMeta) != (fuzzyBytes)) {
+        // We always return NEXT_EXISTS
+        return SatisfiesCode.NEXT_EXISTS;
       }
+      off += Bytes.SIZEOF_INT;
+    }
 
-      // Second, checking if this position is not fixed and byte value is not the biggest. In this
-      // case there's a byte array bigger than this row and which satisfies the fuzzy rule. To get
-      // bigger byte array that satisfies the rule we need to just increase this byte
-      // (see the code of getNextForFuzzyRule below) by one.
-      // Note: if non-fixed byte is already at biggest value, this doesn't allow us to say there's
-      //       bigger one that satisfies the rule as it can't be increased.
-      if (fuzzyKeyMeta[i] == 1 && !order.isMax(fuzzyKeyBytes[i])) {
-        nextRowKeyCandidateExists = true;
+    if (length - off >= Bytes.SIZEOF_SHORT) {
+      short fuzzyBytes =
+          UnsafeAccess.theUnsafe.getShort(fuzzyKeyBytes, UnsafeAccess.BYTE_ARRAY_BASE_OFFSET
+              + (long) off);
+      short fuzzyMeta =
+          UnsafeAccess.theUnsafe.getShort(fuzzyKeyMeta, UnsafeAccess.BYTE_ARRAY_BASE_OFFSET
+              + (long) off);
+      short rowValue = UnsafeAccess.theUnsafe.getShort(row, offsetAdj + (long) off);
+      if ((rowValue & fuzzyMeta) != (fuzzyBytes)) {
+        // We always return NEXT_EXISTS
+        // even if it does not (in this case getNextForFuzzyRule
+        // will return null)
+        return SatisfiesCode.NEXT_EXISTS;
       }
+      off += Bytes.SIZEOF_SHORT;
     }
 
+    if (length - off >= Bytes.SIZEOF_BYTE) {
+      int fuzzyBytes = fuzzyKeyBytes[off] & 0xff;
+      int fuzzyMeta = fuzzyKeyMeta[off] & 0xff;
+      int rowValue = row[offset + off] & 0xff;
+      if ((rowValue & fuzzyMeta) != (fuzzyBytes)) {
+        // We always return NEXT_EXISTS
+        return SatisfiesCode.NEXT_EXISTS;
+      }
+    }
     return SatisfiesCode.YES;
   }
-
+  
   @VisibleForTesting
   static byte[] getNextForFuzzyRule(byte[] row, byte[] fuzzyKeyBytes, byte[] fuzzyKeyMeta) {
     return getNextForFuzzyRule(false, row, 0, row.length, fuzzyKeyBytes, fuzzyKeyMeta);
@@ -368,13 +505,13 @@ public class FuzzyRowFilter extends FilterBase {
 
     boolean increased = false;
     for (int i = 0; i < result.length; i++) {
-      if (i >= fuzzyKeyMeta.length || fuzzyKeyMeta[i] == 1) {
+      if (i >= fuzzyKeyMeta.length || fuzzyKeyMeta[i] == 0 /* non-fixed*/) {
         result[i] = row[offset + i];
         if (!order.isMax(row[offset + i])) {
           // this is "non-fixed" position and is not at max value, hence we can increase it
           toInc = i;
         }
-      } else if (i < fuzzyKeyMeta.length && fuzzyKeyMeta[i] == 0) {
+      } else if (i < fuzzyKeyMeta.length && fuzzyKeyMeta[i] == -1 /* fixed */) {
         if (order.lt((row[i + offset] & 0xFF), (fuzzyKeyBytes[i] & 0xFF))) {
           // if setting value for any fixed position increased the original array,
           // we are OK
@@ -400,7 +537,7 @@ public class FuzzyRowFilter extends FilterBase {
       // Setting all "non-fixed" positions to zeroes to the right of the one we increased so
       // that found "next" row key is the smallest possible
       for (int i = toInc + 1; i < result.length; i++) {
-        if (i >= fuzzyKeyMeta.length || fuzzyKeyMeta[i] == 1) {
+        if (i >= fuzzyKeyMeta.length || fuzzyKeyMeta[i] == 0 /* non-fixed */) {
           result[i] = order.min();
         }
       }
@@ -408,7 +545,7 @@ public class FuzzyRowFilter extends FilterBase {
 
     return result;
   }
-
+  
   /**
    * @return true if and only if the fields of the filter that are serialized
    * are equal to the corresponding fields in other.  Used for testing.
diff --git hbase-common/src/main/java/org/apache/hadoop/hbase/util/UnsafeAccess.java hbase-common/src/main/java/org/apache/hadoop/hbase/util/UnsafeAccess.java
new file mode 100644
index 0000000..c995930
--- /dev/null
+++ hbase-common/src/main/java/org/apache/hadoop/hbase/util/UnsafeAccess.java
@@ -0,0 +1,45 @@
+package org.apache.hadoop.hbase.util;
+
+import java.lang.reflect.Field;
+import java.nio.ByteOrder;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+
+import sun.misc.Unsafe;
+
+public class UnsafeAccess {
+
+  public static final Unsafe theUnsafe;
+
+  /** The offset to the first element in a byte array. */
+  public static final int BYTE_ARRAY_BASE_OFFSET;
+
+  static {
+    theUnsafe = (Unsafe) AccessController.doPrivileged(new PrivilegedAction<Object>() {
+      @Override
+      public Object run() {
+        try {
+          Field f = Unsafe.class.getDeclaredField("theUnsafe");
+          f.setAccessible(true);
+          return f.get(null);
+        } catch (NoSuchFieldException e) {
+          // It doesn't matter what we throw;
+          // it's swallowed in getBestComparer().
+          throw new Error();
+        } catch (IllegalAccessException e) {
+          throw new Error();
+        }
+      }
+    });
+
+    BYTE_ARRAY_BASE_OFFSET = theUnsafe.arrayBaseOffset(byte[].class);
+
+    // sanity check - this should never fail
+    if (theUnsafe.arrayIndexScale(byte[].class) != 1) {
+      throw new AssertionError();
+    }
+  }
+
+  public static final boolean littleEndian = ByteOrder.nativeOrder()
+      .equals(ByteOrder.LITTLE_ENDIAN);
+}
diff --git hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFuzzyRowFilter.java hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFuzzyRowFilter.java
index f21fba5..039cc55 100644
--- hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFuzzyRowFilter.java
+++ hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFuzzyRowFilter.java
@@ -30,231 +30,185 @@ import org.junit.experimental.categories.Category;
 public class TestFuzzyRowFilter {
   @Test
   public void testSatisfiesForward() {
-    Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NEXT_EXISTS,
-            FuzzyRowFilter.satisfies(false,
-                                     new byte[]{1, (byte) -128, 0, 0, 1}, // row to check
-                                     new byte[]{1, 0, 1}, // fuzzy row
-                                     new byte[]{0, 1, 0})); // mask
 
     Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.YES,
             FuzzyRowFilter.satisfies(false,
                                      new byte[]{1, (byte) -128, 1, 0, 1},
                                      new byte[]{1, 0, 1},
-                                     new byte[]{0, 1, 0}));
+                                     new byte[]{-1, 0, -1}));
 
     Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NEXT_EXISTS,
             FuzzyRowFilter.satisfies(false,
                                      new byte[]{1, (byte) -128, 2, 0, 1},
                                      new byte[]{1, 0, 1},
-                                     new byte[]{0, 1, 0}));
+                                     new byte[]{-1, 0, -1}));
 
-    Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NO_NEXT,
-            FuzzyRowFilter.satisfies(false,
-                                     new byte[]{2, 3, 1, 1, 1},
-                                     new byte[]{1, 0, 1},
-                                     new byte[]{0, 1, 0}));
 
     Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.YES,
             FuzzyRowFilter.satisfies(false,
                                      new byte[]{1, 2, 1, 3, 3},
                                      new byte[]{1, 2, 0, 3},
-                                     new byte[]{0, 0, 1, 0}));
+                                     new byte[]{-1, -1, 0, -1}));
 
     Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NEXT_EXISTS,
             FuzzyRowFilter.satisfies(false,
                                      new byte[]{1, 1, 1, 3, 0}, // row to check
                                      new byte[]{1, 2, 0, 3}, // fuzzy row
-                                     new byte[]{0, 0, 1, 0})); // mask
+                                     new byte[]{-1, -1, 0, -1})); // mask
 
     Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NEXT_EXISTS,
             FuzzyRowFilter.satisfies(false,
                                      new byte[]{1, 1, 1, 3, 0},
                                      new byte[]{1, (byte) 245, 0, 3},
-                                     new byte[]{0, 0, 1, 0}));
-
-    Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NO_NEXT,
-            FuzzyRowFilter.satisfies(false,
-                                     new byte[]{1, (byte) 245, 1, 3, 0},
-                                     new byte[]{1, 1, 0, 3},
-                                     new byte[]{0, 0, 1, 0}));
-
-    Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NO_NEXT,
-            FuzzyRowFilter.satisfies(false,
-                                     new byte[]{1, 3, 1, 3, 0},
-                                     new byte[]{1, 2, 0, 3},
-                                     new byte[]{0, 0, 1, 0}));
-
-    Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NO_NEXT,
-            FuzzyRowFilter.satisfies(false,
-                                     new byte[]{2, 1, 1, 1, 0},
-                                     new byte[]{1, 2, 0, 3},
-                                     new byte[]{0, 0, 1, 0}));
+                                     new byte[]{-1, -1, 0, -1}));
 
     Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NEXT_EXISTS,
             FuzzyRowFilter.satisfies(false,
                                      new byte[]{1, 2, 1, 0, 1},
                                      new byte[]{0, 1, 2},
-                                     new byte[]{1, 0, 0}));
+                                     new byte[]{0, -1, -1}));
   }
 
   @Test
   public void testSatisfiesReverse() {
-    Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NO_NEXT,
-      FuzzyRowFilter.satisfies(true,
-        new byte[]{1, (byte) -128, 0, 0, 1}, // row to check
-        new byte[]{1, 0, 1}, // fuzzy row
-        new byte[]{0, 1, 0})); // mask
-
     Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.YES,
       FuzzyRowFilter.satisfies(true,
         new byte[]{1, (byte) -128, 1, 0, 1},
         new byte[]{1, 0, 1},
-        new byte[]{0, 1, 0}));
+        new byte[]{-1, 0, -1}));
 
     Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NEXT_EXISTS,
       FuzzyRowFilter.satisfies(true,
         new byte[]{1, (byte) -128, 2, 0, 1},
         new byte[]{1, 0, 1},
-        new byte[]{0, 1, 0}));
+        new byte[]{-1, 0, -1}));
 
     Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NEXT_EXISTS,
       FuzzyRowFilter.satisfies(true,
         new byte[]{2, 3, 1, 1, 1},
         new byte[]{1, 0, 1},
-        new byte[]{0, 1, 0}));
+        new byte[]{-1, 0, -1}));
 
     Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.YES,
       FuzzyRowFilter.satisfies(true,
         new byte[]{1, 2, 1, 3, 3},
         new byte[]{1, 2, 0, 3},
-        new byte[]{0, 0, 1, 0}));
-
-    Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NO_NEXT,
-      FuzzyRowFilter.satisfies(true,
-        new byte[]{1, 1, 1, 3, 0}, // row to check
-        new byte[]{1, 2, 0, 3}, // fuzzy row
-        new byte[]{0, 0, 1, 0})); // mask
-
-    Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NO_NEXT,
-      FuzzyRowFilter.satisfies(true,
-        new byte[]{1, 1, 1, 3, 0},
-        new byte[]{1, (byte) 245, 0, 3},
-        new byte[]{0, 0, 1, 0}));
+        new byte[]{-1, -1, 0, -1}));
 
     Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NEXT_EXISTS,
       FuzzyRowFilter.satisfies(true,
         new byte[]{1, (byte) 245, 1, 3, 0},
         new byte[]{1, 1, 0, 3},
-        new byte[]{0, 0, 1, 0}));
+        new byte[]{-1, -1, 0, -1}));
 
     Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NEXT_EXISTS,
       FuzzyRowFilter.satisfies(true,
         new byte[]{1, 3, 1, 3, 0},
         new byte[]{1, 2, 0, 3},
-        new byte[]{0, 0, 1, 0}));
+        new byte[]{-1, -1, 0, -1}));
 
     Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NEXT_EXISTS,
       FuzzyRowFilter.satisfies(true,
         new byte[]{2, 1, 1, 1, 0},
         new byte[]{1, 2, 0, 3},
-        new byte[]{0, 0, 1, 0}));
+        new byte[]{-1, -1, 0, -1}));
 
     Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.NEXT_EXISTS,
       FuzzyRowFilter.satisfies(true,
         new byte[]{1, 2, 1, 0, 1},
         new byte[]{0, 1, 2},
-        new byte[]{1, 0, 0}));
+        new byte[]{0, -1, -1}));
   }
 
   @Test
   public void testGetNextForFuzzyRuleForward() {
     assertNext(false,
             new byte[]{0, 1, 2}, // fuzzy row
-            new byte[]{1, 0, 0}, // mask
+            new byte[]{0, -1, -1}, // mask
             new byte[]{1, 2, 1, 0, 1}, // current
             new byte[]{2, 1, 2, 0, 0}); // expected next
 
     assertNext(false,
             new byte[]{0, 1, 2}, // fuzzy row
-            new byte[]{1, 0, 0}, // mask
+            new byte[]{0, -1, -1}, // mask
             new byte[]{1, 1, 2, 0, 1}, // current
             new byte[]{1, 1, 2, 0, 2}); // expected next
 
     assertNext(false,
             new byte[]{0, 1, 0, 2, 0}, // fuzzy row
-            new byte[]{1, 0, 1, 0, 1}, // mask
+            new byte[]{0, -1, 0, -1, 0}, // mask
             new byte[]{1, 0, 2, 0, 1}, // current
             new byte[]{1, 1, 0, 2, 0}); // expected next
 
     assertNext(false,
             new byte[]{1, 0, 1},
-            new byte[]{0, 1, 0},
+            new byte[]{-1, 0, -1},
             new byte[]{1, (byte) 128, 2, 0, 1},
             new byte[]{1, (byte) 129, 1, 0, 0});
 
     assertNext(false,
             new byte[]{0, 1, 0, 1},
-            new byte[]{1, 0, 1, 0},
+            new byte[]{0, -1, 0, -1},
             new byte[]{5, 1, 0, 1},
             new byte[]{5, 1, 1, 1});
 
     assertNext(false,
             new byte[]{0, 1, 0, 1},
-            new byte[]{1, 0, 1, 0},
+            new byte[]{0, -1, 0, -1},
             new byte[]{5, 1, 0, 1, 1},
             new byte[]{5, 1, 0, 1, 2});
 
     assertNext(false,
             new byte[]{0, 1, 0, 0}, // fuzzy row
-            new byte[]{1, 0, 1, 1}, // mask
+            new byte[]{0, -1, 0, 0}, // mask
             new byte[]{5, 1, (byte) 255, 1}, // current
             new byte[]{5, 1, (byte) 255, 2}); // expected next
 
     assertNext(false,
             new byte[]{0, 1, 0, 1}, // fuzzy row
-            new byte[]{1, 0, 1, 0}, // mask
+            new byte[]{0, -1, 0, -1}, // mask
             new byte[]{5, 1, (byte) 255, 1}, // current
             new byte[]{6, 1, 0, 1}); // expected next
 
     assertNext(false,
             new byte[]{0, 1, 0, 1}, // fuzzy row
-            new byte[]{1, 0, 1, 0}, // mask
+            new byte[]{0, -1, 0, -1}, // mask
             new byte[]{5, 1, (byte) 255, 0}, // current
             new byte[]{5, 1, (byte) 255, 1}); // expected next
 
     assertNext(false,
             new byte[]{5, 1, 1, 0},
-            new byte[]{0, 0, 1, 1},
+            new byte[]{-1, -1, 0, 0},
             new byte[]{5, 1, (byte) 255, 1},
             new byte[]{5, 1, (byte) 255, 2});
 
     assertNext(false,
             new byte[]{1, 1, 1, 1},
-            new byte[]{0, 0, 1, 1},
+            new byte[]{-1, -1, 0, 0},
             new byte[]{1, 1, 2, 2},
             new byte[]{1, 1, 2, 3});
 
     assertNext(false,
             new byte[]{1, 1, 1, 1},
-            new byte[]{0, 0, 1, 1},
+            new byte[]{-1, -1, 0, 0},
             new byte[]{1, 1, 3, 2},
             new byte[]{1, 1, 3, 3});
 
     assertNext(false,
             new byte[]{1, 1, 1, 1},
-            new byte[]{1, 1, 1, 1},
+            new byte[]{0, 0, 0, 0},
             new byte[]{1, 1, 2, 3},
             new byte[]{1, 1, 2, 4});
 
     assertNext(false,
             new byte[]{1, 1, 1, 1},
-            new byte[]{1, 1, 1, 1},
+            new byte[]{0, 0, 0, 0},
             new byte[]{1, 1, 3, 2},
             new byte[]{1, 1, 3, 3});
 
     assertNext(false,
             new byte[]{1, 1, 0, 0},
-            new byte[]{0, 0, 1, 1},
+            new byte[]{-1, -1, 0, 0},
             new byte[]{0, 1, 3, 2},
             new byte[]{1, 1, 0, 0});
 
@@ -262,100 +216,100 @@ public class TestFuzzyRowFilter {
     Assert.assertNull(FuzzyRowFilter.getNextForFuzzyRule(
             new byte[]{2, 3, 1, 1, 1}, // row to check
             new byte[]{1, 0, 1}, // fuzzy row
-            new byte[]{0, 1, 0})); // mask
+            new byte[]{-1, 0, -1})); // mask
     Assert.assertNull(FuzzyRowFilter.getNextForFuzzyRule(
             new byte[]{1, (byte) 245, 1, 3, 0},
             new byte[]{1, 1, 0, 3},
-            new byte[]{0, 0, 1, 0}));
+            new byte[]{-1, -1, 0, -1}));
     Assert.assertNull(FuzzyRowFilter.getNextForFuzzyRule(
             new byte[]{1, 3, 1, 3, 0},
             new byte[]{1, 2, 0, 3},
-            new byte[]{0, 0, 1, 0}));
+            new byte[]{-1, -1, 0, -1}));
     Assert.assertNull(FuzzyRowFilter.getNextForFuzzyRule(
             new byte[]{2, 1, 1, 1, 0},
             new byte[]{1, 2, 0, 3},
-            new byte[]{0, 0, 1, 0}));
+            new byte[]{-1, -1, 0, -1}));
   }
 
   @Test
   public void testGetNextForFuzzyRuleReverse() {
     assertNext(true,
       new byte[]{0, 1, 2}, // fuzzy row
-      new byte[]{1, 0, 0}, // mask
+      new byte[]{0, -1, -1}, // mask
       new byte[]{1, 2, 1, 0, 1}, // current
       // TODO: should be {1, 1, 3} ?
       new byte[]{1, 1, 2, (byte) 0xFF, (byte) 0xFF}); // expected next
 
     assertNext(true,
       new byte[]{0, 1, 0, 2, 0}, // fuzzy row
-      new byte[]{1, 0, 1, 0, 1}, // mask
+      new byte[]{0, -1, 0, -1, 0}, // mask
       new byte[]{1, 2, 1, 3, 1}, // current
       // TODO: should be {1, 1, 1, 3} ?
       new byte[]{1, 1, 0, 2, 0}); // expected next
 
     assertNext(true,
       new byte[]{1, 0, 1},
-      new byte[]{0, 1, 0},
+      new byte[]{-1, 0, -1},
       new byte[]{1, (byte) 128, 2, 0, 1},
       // TODO: should be {1, (byte) 128, 2} ?
       new byte[]{1, (byte) 128, 1, (byte) 0xFF, (byte) 0xFF});
 
     assertNext(true,
       new byte[]{0, 1, 0, 1},
-      new byte[]{1, 0, 1, 0},
+      new byte[]{0, -1, 0, -1},
       new byte[]{5, 1, 0, 2, 1},
       // TODO: should be {5, 1, 0, 2} ?
       new byte[]{5, 1, 0, 1, (byte) 0xFF});
 
     assertNext(true,
       new byte[]{0, 1, 0, 0}, // fuzzy row
-      new byte[]{1, 0, 1, 1}, // mask
+      new byte[]{0, -1, 0, 0}, // mask
       new byte[]{5, 1, (byte) 255, 1}, // current
       new byte[]{5, 1, (byte) 255, 0}); // expected next
 
     assertNext(true,
       new byte[]{0, 1, 0, 1}, // fuzzy row
-      new byte[]{1, 0, 1, 0}, // mask
+      new byte[]{0, -1, 0, -1}, // mask
       new byte[]{5, 1, 0, 1}, // current
       new byte[]{4, 1, (byte) 255, 1}); // expected next
 
     assertNext(true,
       new byte[]{0, 1, 0, 1}, // fuzzy row
-      new byte[]{1, 0, 1, 0}, // mask
+      new byte[]{0, -1, 0, -1}, // mask
       new byte[]{5, 1, (byte) 255, 0}, // current
       new byte[]{5, 1, (byte) 254, 1}); // expected next
 
     assertNext(true,
       new byte[]{1, 1, 0, 0},
-      new byte[]{0, 0, 1, 1},
+      new byte[]{-1, -1, 0, 0},
       new byte[]{2, 1, 3, 2},
       // TODO: should be {1, 0} ?
       new byte[]{1, 1, 0, 0});
 
     assertNext(true,
       new byte[]{1, 0, 1}, // fuzzy row
-      new byte[]{0, 1, 0}, // mask
+      new byte[]{-1, 0, -1}, // mask
       new byte[]{2, 3, 1, 1, 1}, // row to check
       // TODO: should be {1, (byte) 0xFF, 2} ?
       new byte[]{1, 0, 1, (byte) 0xFF, (byte) 0xFF});
 
     assertNext(true,
       new byte[]{1, 1, 0, 3},
-      new byte[]{0, 0, 1, 0},
+      new byte[]{-1, -1, 0, -1},
       new byte[]{1, (byte) 245, 1, 3, 0},
       // TODO: should be {1, 1, (byte) 255, 4} ?
       new byte[]{1, 1, 0, 3, (byte) 0xFF});
 
     assertNext(true,
       new byte[]{1, 2, 0, 3},
-      new byte[]{0, 0, 1, 0},
+      new byte[]{-1, -1, 0, -1},
       new byte[]{1, 3, 1, 3, 0},
       // TODO: should be 1, 2, (byte) 255, 4 ?
       new byte[]{1, 2, 0, 3, (byte) 0xFF});
 
     assertNext(true,
       new byte[]{1, 2, 0, 3},
-      new byte[]{0, 0, 1, 0},
+      new byte[]{-1, -1, 0, -1},
       new byte[]{2, 1, 1, 1, 0},
       // TODO: should be {1, 2, (byte) 255, 4} ?
       new byte[]{1, 2, 0, 3, (byte) 0xFF});
@@ -363,42 +317,42 @@ public class TestFuzzyRowFilter {
     assertNext(true,
       // TODO: should be null?
       new byte[]{1, 0, 1},
-      new byte[]{0, 1, 0},
+      new byte[]{-1, 0, -1},
       new byte[]{1, (byte) 128, 2},
       new byte[]{1, (byte) 128, 1});
 
     assertNext(true,
       // TODO: should be null?
       new byte[]{0, 1, 0, 1},
-      new byte[]{1, 0, 1, 0},
+      new byte[]{0, -1, 0, -1},
       new byte[]{5, 1, 0, 2},
       new byte[]{5, 1, 0, 1});
 
     assertNext(true,
       // TODO: should be null?
       new byte[]{5, 1, 1, 0},
-      new byte[]{0, 0, 1, 1},
+      new byte[]{-1, -1, 0, 0},
       new byte[]{5, 1, (byte) 0xFF, 1},
       new byte[]{5, 1, (byte) 0xFF, 0});
 
     assertNext(true,
       // TODO: should be null?
       new byte[]{1, 1, 1, 1},
-      new byte[]{0, 0, 1, 1},
+      new byte[]{-1, -1, 0, 0},
       new byte[]{1, 1, 2, 2},
       new byte[]{1, 1, 2, 1});
 
     assertNext(true,
       // TODO: should be null?
       new byte[]{1, 1, 1, 1},
-      new byte[]{1, 1, 1, 1},
+      new byte[]{0, 0, 0, 0},
       new byte[]{1, 1, 2, 3},
       new byte[]{1, 1, 2, 2});
 
     Assert.assertNull(FuzzyRowFilter.getNextForFuzzyRule(true,
       new byte[]{1, 1, 1, 3, 0},
       new byte[]{1, 2, 0, 3},
-      new byte[]{0, 0, 1, 0}));
+      new byte[]{-1, -1, 0, -1}));
   }
 
   private static void assertNext(boolean reverse, byte[] fuzzyRow, byte[] mask, byte[] current,
diff --git hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFuzzyRowFilterIT.java hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFuzzyRowFilterIT.java
new file mode 100644
index 0000000..7ece2be
--- /dev/null
+++ hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFuzzyRowFilterIT.java
@@ -0,0 +1,196 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in
+ * writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License. under the License.
+ */
+package org.apache.hadoop.hbase.filter;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.Durability;
+import org.apache.hadoop.hbase.client.Put;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.client.Table;
+import org.apache.hadoop.hbase.regionserver.ConstantSizeRegionSplitPolicy;
+import org.apache.hadoop.hbase.regionserver.HRegion;
+import org.apache.hadoop.hbase.regionserver.RegionScanner;
+import org.apache.hadoop.hbase.testclassification.FilterTests;
+import org.apache.hadoop.hbase.testclassification.MediumTests;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.Pair;
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+/**
+ */
+@Category({ FilterTests.class, MediumTests.class })
+public class TestFuzzyRowFilterIT {
+  private final static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();
+  private static final Log LOG = LogFactory.getLog(TestFuzzyRowFilterIT.class);
+
+  private static int firstPartCardinality = 50;
+  private static int secondPartCardinality = 40;
+  private static int colQualifiersTotal = 50;
+  private static int totalFuzzyKeys = secondPartCardinality / 2;
+
+  private static String table = "TestFuzzyRowFilterIT";
+
+  /**
+   * @throws java.lang.Exception
+   */
+  @BeforeClass
+  public static void setUpBeforeClass() throws Exception {
+    Configuration conf = TEST_UTIL.getConfiguration();
+    conf.setInt("hbase.client.scanner.caching", 1000);
+    conf.set(HConstants.HBASE_REGION_SPLIT_POLICY_KEY,
+      ConstantSizeRegionSplitPolicy.class.getName());
+    // set no splits
+    conf.setLong(HConstants.HREGION_MAX_FILESIZE, ((long) 1024) * 1024 * 1024 * 10);
+
+    TEST_UTIL.startMiniCluster();
+  }
+
+  /**
+   * @throws java.lang.Exception
+   */
+  @AfterClass
+  public static void tearDownAfterClass() throws Exception {
+    TEST_UTIL.shutdownMiniCluster();
+  }
+
+  /**
+   * @throws java.lang.Exception
+   */
+  @Before
+  public void setUp() throws Exception {
+    // Nothing to do.
+  }
+
+  /**
+   * @throws java.lang.Exception
+   */
+  @After
+  public void tearDown() throws Exception {
+    // Nothing to do.
+  }
+
+  @Test
+  public void testMain() throws Exception {
+    String cf = "f";
+
+    Table ht =
+        TEST_UTIL.createTable(TableName.valueOf(table), Bytes.toBytes(cf), Integer.MAX_VALUE);
+
+    // 10 byte row key - (2 bytes 4 bytes 4 bytes)
+    // 4 byte qualifier
+    // 4 byte value
+
+    for (int i1 = 0; i1 < firstPartCardinality; i1++) {
+      if ((i1 % 1000) == 0) LOG.info("put " + i1);
+
+      for (int i2 = 0; i2 < secondPartCardinality; i2++) {
+        byte[] rk = new byte[10];
+
+        ByteBuffer buf = ByteBuffer.wrap(rk);
+        buf.clear();
+        buf.putShort((short) 2);
+        buf.putInt(i1);
+        buf.putInt(i2);
+        for (int c = 0; c < colQualifiersTotal; c++) {
+          byte[] cq = new byte[4];
+          Bytes.putBytes(cq, 0, Bytes.toBytes(c), 0, 4);
+
+          Put p = new Put(rk);
+          p.setDurability(Durability.SKIP_WAL);
+          p.add(cf.getBytes(), cq, Bytes.toBytes(c));
+          ht.put(p);
+        }
+      }
+    }
+
+    TEST_UTIL.flush();
+
+    // test passes
+    runTest(ht);
+
+  }
+
+  private void runTest(Table hTable) throws IOException {
+    // [0, 2, ?, ?, ?, ?, 0, 0, 0, 1]
+
+    byte[] mask = new byte[] { 0, 0, 1, 1, 1, 1, 0, 0, 0, 0 };
+
+    List<Pair<byte[], byte[]>> list = new ArrayList<Pair<byte[], byte[]>>();
+    for (int i = 0; i < totalFuzzyKeys; i++) {
+      byte[] fuzzyKey = new byte[10];
+      ByteBuffer buf = ByteBuffer.wrap(fuzzyKey);
+      buf.clear();
+      buf.putShort((short) 2);
+      for (int j = 0; j < 4; j++) {
+        buf.put((byte) 63);
+      }
+      buf.putInt(i);
+
+      Pair<byte[], byte[]> pair = new Pair<byte[], byte[]>(fuzzyKey, mask);
+      list.add(pair);
+    }
+
+    int expectedSize = firstPartCardinality * totalFuzzyKeys * colQualifiersTotal;
+    FuzzyRowFilter fuzzyRowFilter0 = new FuzzyRowFilter(list);
+    // Filters are not stateless - we can't reuse them
+    FuzzyRowFilter fuzzyRowFilter1 = new FuzzyRowFilter(list);
+
+    // regular test
+    runScanner(hTable, expectedSize, fuzzyRowFilter0);
+    // optimized from block cache
+    runScanner(hTable, expectedSize, fuzzyRowFilter1);
+
+  }
+
+  private void runScanner(Table hTable, int expectedSize, Filter filter) throws IOException {
+
+    String cf = "f";
+    Scan scan = new Scan();
+    scan.addFamily(cf.getBytes());
+    scan.setFilter(filter);
+    List<HRegion> regions = TEST_UTIL.getHBaseCluster().getRegions(table.getBytes());
+    HRegion first = regions.get(0);
+    first.getScanner(scan);
+    RegionScanner scanner = first.getScanner(scan);
+    List<Cell> results = new ArrayList<Cell>();
+    // Result result;
+    long timeBeforeScan = System.currentTimeMillis();
+    int found = 0;
+    while (scanner.next(results)) {
+      found += results.size();
+      results.clear();
+    }
+    found += results.size();
+    long scanTime = System.currentTimeMillis() - timeBeforeScan;
+    scanner.close();
+
+    LOG.info("\nscan time = " + scanTime + "ms");
+    LOG.info("found " + found + " results\n");
+
+    assertEquals(expectedSize, found);
+  }
+}
