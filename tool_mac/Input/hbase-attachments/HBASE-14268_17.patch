import java.util.Random;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.locks.ReentrantLock;

import org.apache.hadoop.hbase.util.KeyLocker;

public class KeyLockerPerformance {
  private static final int THREAD_COUNT = 100;
  private static final int LOOP_COUNT = 100000;
  private static final int KEY_COUNT = 100;

  public static void main(String[] args) throws Exception {
    final KeyLocker<String> locker = new KeyLocker<String>();

    final String[] keys = new String[KEY_COUNT];
    for(int i=0; i<keys.length; i++) {
      keys[i] = UUID.randomUUID().toString();
    }

    final CountDownLatch prepareLatch = new CountDownLatch(THREAD_COUNT);
    final CountDownLatch startLatch = new CountDownLatch(1);
    final CountDownLatch endLatch = new CountDownLatch(THREAD_COUNT);

    for (int i=0; i<THREAD_COUNT; i++) {
      new Thread() {
        final Random rnd = new Random();

        @Override
        public void run() {
          try {
            prepareLatch.countDown();
            startLatch.await();
            for (int j=0; j<LOOP_COUNT; j++) {
              String key = keys[rnd.nextInt(KEY_COUNT)];
              ReentrantLock lock = locker.acquireLock(key);
              try {
                // ...
              } finally {
                lock.unlock();
              }
            }
            endLatch.countDown();

          } catch (InterruptedException e) {
            throw new AssertionError();
          }
        }
      }.start();
    }

    prepareLatch.await();
    long startNanos = System.nanoTime();
    startLatch.countDown();
    endLatch.await();
    long endNanos = System.nanoTime();

    System.out.println(endNanos - startNanos);
  }
}
