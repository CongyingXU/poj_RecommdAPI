commit 940f4107b0ac02592f6536cae8601132bb760e72
Author: tedyu <yuzhihong@gmail.com>
Date:   Wed Jun 21 18:23:30 2017 -0700

    HBASE-18226 Disable reverse DNS lookup at HMaster and use the hostname provided by RegionServer (Duo Xu)

diff --git a/hbase-common/src/main/resources/hbase-default.xml b/hbase-common/src/main/resources/hbase-default.xml
index e9fe34f..84c5be3 100644
--- a/hbase-common/src/main/resources/hbase-default.xml
+++ b/hbase-common/src/main/resources/hbase-default.xml
@@ -931,6 +931,15 @@ possible configurations would overwhelm and obscure the important.
     When set to a non-empty value, this represents the (external facing) hostname for the underlying server.
     See https://issues.apache.org/jira/browse/HBASE-12954 for details.</description>
   </property>
+  <property>
+    <name>hbase.regionserver.hostname.disable.master.reversedns</name>
+    <value>false</value>
+    <description>This config is for experts: don't set its value unless you really know what you are doing.
+    When set to true, regionserver will use the current node hostname for the servername and HMaster will
+    skip reverse DNS lookup and use the hostname sent by regionserver instead. Note that this config and
+    hbase.regionserver.hostname are mutually exclusive. See https://issues.apache.org/jira/browse/HBASE-18226
+    for more details.</description>
+  </property>
   <!-- The following properties configure authentication information for
        HBase processes when using Kerberos security.  There are no default
        values, included here for documentation purposes -->
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java
index 340b23b..849eba4 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java
@@ -430,6 +430,11 @@ public class HRegionServer extends HasThread implements
   @InterfaceAudience.LimitedPrivate(HBaseInterfaceAudience.CONFIG)
   protected final static String MASTER_HOSTNAME_KEY = "hbase.master.hostname";
 
+  // HBASE-18226: This config and hbase.regionserver.hostname are mutually exclusive.
+  // Exception will be thrown if both are used.
+  final static String RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY =
+    "hbase.regionserver.hostname.disable.master.reversedns";
+
   /**
    * This servers startcode.
    */
@@ -556,6 +561,16 @@ public class HRegionServer extends HasThread implements
       useThisHostnameInstead = conf.get(MASTER_HOSTNAME_KEY);
     } else {
       useThisHostnameInstead = conf.get(RS_HOSTNAME_KEY);
+      if (conf.getBoolean(RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY, false)) {
+        if (shouldUseThisHostnameInstead()) {
+          String msg = RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY + " and " + RS_HOSTNAME_KEY +
+            " are mutually exclusive. Do not set " + RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY +
+            " to true while " + RS_HOSTNAME_KEY + " is used";
+          throw new IOException(msg);
+        } else {
+          useThisHostnameInstead = rpcServices.isa.getHostName();
+        }
+      }
     }
     String hostName = shouldUseThisHostnameInstead() ? useThisHostnameInstead :
       rpcServices.isa.getHostName();
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionServerHostname.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionServerHostname.java
index ab1f253..6c43b10 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionServerHostname.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionServerHostname.java
@@ -27,6 +27,8 @@ import java.util.List;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hbase.HBaseConfiguration;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.testclassification.MediumTests;
 import org.apache.hadoop.hbase.util.Threads;
@@ -41,13 +43,14 @@ import org.junit.experimental.categories.Category;
 @Category({MediumTests.class})
 public class TestRegionServerHostname {
   private static final Log LOG = LogFactory.getLog(TestRegionServerHostname.class);
-  private static final HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();
 
   @Test (timeout=30000)
   public void testInvalidRegionServerHostnameAbortsServer() throws Exception {
     final int NUM_MASTERS = 1;
     final int NUM_RS = 1;
     String invalidHostname = "hostAddr.invalid";
+    Configuration conf = HBaseConfiguration.create();
+    HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility(conf);
     TEST_UTIL.getConfiguration().set(HRegionServer.RS_HOSTNAME_KEY, invalidHostname);
     try {
       TEST_UTIL.startMiniCluster(NUM_MASTERS, NUM_RS);
@@ -69,7 +72,8 @@ public class TestRegionServerHostname {
     final int NUM_MASTERS = 1;
     final int NUM_RS = 1;
     Enumeration<NetworkInterface> netInterfaceList = NetworkInterface.getNetworkInterfaces();
-
+    Configuration conf = HBaseConfiguration.create();
+    HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility(conf);
     while (netInterfaceList.hasMoreElements()) {
       NetworkInterface ni = netInterfaceList.nextElement();
       Enumeration<InetAddress> addrList = ni.getInetAddresses();
@@ -101,4 +105,64 @@ public class TestRegionServerHostname {
       }
     }
   }
+
+  @Test(timeout=30000)
+  public void testConflictRegionServerHostnameConfigurationsAbortServer() throws Exception {
+    final int NUM_MASTERS = 1;
+    final int NUM_RS = 1;
+    Enumeration<NetworkInterface> netInterfaceList = NetworkInterface.getNetworkInterfaces();
+    Configuration conf = HBaseConfiguration.create();
+    HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility(conf);
+    while (netInterfaceList.hasMoreElements()) {
+      NetworkInterface ni = netInterfaceList.nextElement();
+      Enumeration<InetAddress> addrList = ni.getInetAddresses();
+      // iterate through host addresses and use each as hostname
+      while (addrList.hasMoreElements()) {
+        InetAddress addr = addrList.nextElement();
+        if (addr.isLoopbackAddress() || addr.isLinkLocalAddress() || addr.isMulticastAddress()) {
+          continue;
+        }
+        String hostName = addr.getHostName();
+        LOG.info("Found " + hostName + " on " + ni);
+
+        TEST_UTIL.getConfiguration().set(HRegionServer.MASTER_HOSTNAME_KEY, hostName);
+        // "hbase.regionserver.hostname" and "hbase.regionserver.hostname.disable.master.reversedns"
+        // are mutually exclusive. Exception should be thrown if both are used.
+        TEST_UTIL.getConfiguration().set(HRegionServer.RS_HOSTNAME_KEY, hostName);
+        TEST_UTIL.getConfiguration().setBoolean(HRegionServer.RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY, true);
+        try {
+          TEST_UTIL.startMiniCluster(NUM_MASTERS, NUM_RS);
+        } catch (Exception e) {
+          Throwable t1 = e.getCause();
+          Throwable t2 = t1.getCause();
+          assertTrue(t1.getMessage()+" - "+t2.getMessage(), t2.getMessage().contains(
+            HRegionServer.RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY + " and " + HRegionServer.RS_HOSTNAME_KEY +
+            " are mutually exclusive"));
+          return;
+        } finally {
+          TEST_UTIL.shutdownMiniCluster();
+        }
+        assertTrue("Failed to validate against conflict hostname configurations", false);
+      }
+    }
+  }
+
+  @Test(timeout=30000)
+  public void testRegionServerHostnameReportedToMaster() throws Exception {
+    final int NUM_MASTERS = 1;
+    final int NUM_RS = 1;
+    Configuration conf = HBaseConfiguration.create();
+    HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility(conf);
+    TEST_UTIL.getConfiguration().setBoolean(HRegionServer.RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY, true);
+    TEST_UTIL.startMiniCluster(NUM_MASTERS, NUM_RS);
+    try {
+      ZooKeeperWatcher zkw = TEST_UTIL.getZooKeeperWatcher();
+      List<String> servers = ZKUtil.listChildrenNoWatch(zkw, zkw.rsZNode);
+      // there would be NUM_RS+1 children - one for the master
+      assertTrue(servers.size() == NUM_RS);
+      zkw.close();
+    } finally {
+      TEST_UTIL.shutdownMiniCluster();
+    }
+  }
 }
