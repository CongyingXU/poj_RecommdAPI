From dcbf442756684fa00e175219a7cf9a575ba78c85 Mon Sep 17 00:00:00 2001
From: Apekshit Sharma <appy@apache.org>
Date: Tue, 24 Jan 2017 14:31:28 -0800
Subject: [PATCH] HBASE-17605 Changes - Moved locks out of
 MasterProcedureScheduler#Queue. One Queue object is used for each
 namespace/table, which aren't more than 100. So we don't complexity arising
 from all functionalities being in one place. MasterProcedureLocking#Lock is
 the new locking class. - Removed NamespaceQueue because it wasn't being used
 as Queue (add,peek,poll,etc functions threw UnsupportedOperationException).
 It's was only used for locks on namespaces. Now that locks have been moved
 out of Queue class, it's not needed anymore. - Remoed RegionEvent which was
 there only for locking on regions. Tables/namespaces used locking from Queue
 class and regions couldn't (there are no separate proc queue at region
 level), hence the redundance. Now that locking is separate, we can use the
 same for regions too. - Removed QueueInterface class. No declarations, except
 one implementaion, which makes the point of having an interface moot. -
 Removed QueueImpl, which was the only concrete implementation of abstract
 Queue class. Moved functions to Queue class itself to avoid unnecessary level
 in inheritance hierarchy. - Removed ProcedureEventQueue class which was just
 a wrapper around ArrayDeque class. - Encapsulated table priority related
 stuff in a single class. - Removed some unused functions. Change-Id:
 I6a60424cb41e280bc111703053aa179d9071ba17

---
 .../procedure2/AbstractProcedureScheduler.java     |  39 +-
 .../hadoop/hbase/procedure2/ProcedureEvent.java    |   9 +-
 .../hbase/procedure2/ProcedureEventQueue.java      |  85 ---
 .../hadoop/hbase/master/locking/LockProcedure.java |   8 +
 .../master/procedure/MasterProcedureLocking.java   | 147 +++++
 .../master/procedure/MasterProcedureScheduler.java | 631 +++++++--------------
 6 files changed, 374 insertions(+), 545 deletions(-)
 delete mode 100644 hbase-procedure/src/main/java/org/apache/hadoop/hbase/procedure2/ProcedureEventQueue.java
 create mode 100644 hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/MasterProcedureLocking.java

diff --git a/hbase-procedure/src/main/java/org/apache/hadoop/hbase/procedure2/AbstractProcedureScheduler.java b/hbase-procedure/src/main/java/org/apache/hadoop/hbase/procedure2/AbstractProcedureScheduler.java
index ff8d978..cafebe0 100644
--- a/hbase-procedure/src/main/java/org/apache/hadoop/hbase/procedure2/AbstractProcedureScheduler.java
+++ b/hbase-procedure/src/main/java/org/apache/hadoop/hbase/procedure2/AbstractProcedureScheduler.java
@@ -18,6 +18,7 @@
 
 package org.apache.hadoop.hbase.procedure2;
 
+import java.util.ArrayDeque;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.concurrent.TimeUnit;
@@ -232,7 +233,7 @@ public abstract class AbstractProcedureScheduler implements ProcedureScheduler {
       if (event.isReady()) {
         return false;
       }
-      suspendProcedure(event, procedure);
+      waitProcedure(event, procedure);
       return true;
     }
   }
@@ -266,7 +267,7 @@ public abstract class AbstractProcedureScheduler implements ProcedureScheduler {
           if (isTraceEnabled) {
             LOG.trace("Wake event " + event);
           }
-          waitingCount += popEventWaitingObjects(event);
+          waitingCount += wakeWaitingProcedures(event);
         }
       }
       wakePollIfNeeded(waitingCount);
@@ -275,21 +276,24 @@ public abstract class AbstractProcedureScheduler implements ProcedureScheduler {
     }
   }
 
-  protected int popEventWaitingObjects(final ProcedureEvent event) {
-    return popEventWaitingProcedures(event);
-  }
-
-  protected int popEventWaitingProcedures(final ProcedureEventQueue event) {
-    int count = 0;
-    while (event.hasWaitingProcedures()) {
-      wakeProcedure(event.popWaitingProcedure(false));
-      count++;
+  /**
+   * Wakes up given waiting procedures by pushing them back into scheduler queues.
+   * @return size of given {@code waitingProcedures}.
+   */
+  public int wakeWaitingProcedures(final ArrayDeque<Procedure> waitingProcedures) {
+    int count = waitingProcedures.size();
+    // wakeProcedure adds to the front of queue, so we start from last in the
+    // waitingProcedures' queue, so that the procedure which was added first goes in the front for
+    // the scheduler queue.
+    while (!waitingProcedures.isEmpty()) {
+      wakeProcedure(waitingProcedures.removeLast());
     }
     return count;
   }
 
-  protected void suspendProcedure(final ProcedureEventQueue event, final Procedure procedure) {
-    event.suspendProcedure(procedure);
+  protected void waitProcedure(final ArrayDeque<Procedure> procedureWaitQueue,
+      final Procedure proc) {
+    procedureWaitQueue.addLast(proc);
   }
 
   protected void wakeProcedure(final Procedure procedure) {
@@ -307,11 +311,12 @@ public abstract class AbstractProcedureScheduler implements ProcedureScheduler {
     schedLock.unlock();
   }
 
-  protected void wakePollIfNeeded(final int waitingCount) {
-    if (waitingCount > 1) {
-      schedWaitCond.signalAll();
-    } else if (waitingCount > 0) {
+  public void wakePollIfNeeded(final int waitingCount) {
+    if (waitingCount <= 0) return;
+    if (waitingCount == 1) {
       schedWaitCond.signal();
+    } else {
+      schedWaitCond.signalAll();
     }
   }
 }
diff --git a/hbase-procedure/src/main/java/org/apache/hadoop/hbase/procedure2/ProcedureEvent.java b/hbase-procedure/src/main/java/org/apache/hadoop/hbase/procedure2/ProcedureEvent.java
index 6335832..7c390d4 100644
--- a/hbase-procedure/src/main/java/org/apache/hadoop/hbase/procedure2/ProcedureEvent.java
+++ b/hbase-procedure/src/main/java/org/apache/hadoop/hbase/procedure2/ProcedureEvent.java
@@ -21,6 +21,8 @@ package org.apache.hadoop.hbase.procedure2;
 import org.apache.hadoop.hbase.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.classification.InterfaceStability;
 
+import java.util.ArrayDeque;
+
 /**
  * Basic ProcedureEvent that contains an "object", which can be a
  * description or a reference to the resource to wait on, and a
@@ -28,19 +30,14 @@ import org.apache.hadoop.hbase.classification.InterfaceStability;
  */
 @InterfaceAudience.Private
 @InterfaceStability.Evolving
-public class ProcedureEvent<T> extends ProcedureEventQueue {
+public class ProcedureEvent<T> extends ArrayDeque<Procedure> {
   private final T object;
-
   private boolean ready = false;
 
   public ProcedureEvent(final T object) {
     this.object = object;
   }
 
-  public T getObject() {
-    return object;
-  }
-
   public synchronized boolean isReady() {
     return ready;
   }
diff --git a/hbase-procedure/src/main/java/org/apache/hadoop/hbase/procedure2/ProcedureEventQueue.java b/hbase-procedure/src/main/java/org/apache/hadoop/hbase/procedure2/ProcedureEventQueue.java
deleted file mode 100644
index a109e9e..0000000
--- a/hbase-procedure/src/main/java/org/apache/hadoop/hbase/procedure2/ProcedureEventQueue.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.hadoop.hbase.procedure2;
-
-import com.google.common.annotations.VisibleForTesting;
-
-import java.util.ArrayDeque;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.hbase.classification.InterfaceAudience;
-import org.apache.hadoop.hbase.classification.InterfaceStability;
-
-/**
- * Basic queue to store suspended procedures.
- */
-@InterfaceAudience.Private
-@InterfaceStability.Evolving
-public class ProcedureEventQueue {
-  private static final Log LOG = LogFactory.getLog(ProcedureEventQueue.class);
-
-  private ArrayDeque<Procedure> waitingProcedures = null;
-
-  public ProcedureEventQueue() {
-  }
-
-  @InterfaceAudience.Private
-  public synchronized void suspendProcedure(final Procedure proc) {
-    if (waitingProcedures == null) {
-      waitingProcedures = new ArrayDeque<Procedure>();
-    }
-    waitingProcedures.addLast(proc);
-  }
-
-  @InterfaceAudience.Private
-  public synchronized void removeProcedure(final Procedure proc) {
-    if (waitingProcedures != null) {
-      waitingProcedures.remove(proc);
-    }
-  }
-
-  @InterfaceAudience.Private
-  public synchronized boolean hasWaitingProcedures() {
-    return waitingProcedures != null;
-  }
-
-  @InterfaceAudience.Private
-  public synchronized Procedure popWaitingProcedure(final boolean popFront) {
-    // it will be nice to use IterableList on a procedure and avoid allocations...
-    Procedure proc = popFront ? waitingProcedures.removeFirst() : waitingProcedures.removeLast();
-    if (waitingProcedures.isEmpty()) {
-      waitingProcedures = null;
-    }
-    return proc;
-  }
-
-  @VisibleForTesting
-  public synchronized void clear() {
-    waitingProcedures = null;
-  }
-
-  @VisibleForTesting
-  public synchronized int size() {
-    if (waitingProcedures != null) {
-      return waitingProcedures.size();
-    }
-    return 0;
-  }
-}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/master/locking/LockProcedure.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/master/locking/LockProcedure.java
index 20fc492..239c167 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/master/locking/LockProcedure.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/master/locking/LockProcedure.java
@@ -42,6 +42,14 @@ import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 
+/**
+ * Procedure to allow clients and master chores like MOB cleaner, MOB compaction, etc to take
+ * locks on table/namespace/regions.
+ * This procedure when scheduled, acquires specified locks, suspends itself and waits for :
+ * - call to unlock: if lock request came from the process itself, say master chore.
+ * - Timeout : if lock request came from RPC. On timeout, evaluates if it should continue holding
+ * the lock or not based on last heartbeat timestamp.
+ */
 @InterfaceAudience.Private
 public final class LockProcedure extends Procedure<MasterProcedureEnv>
     implements TableProcedureInterface {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/MasterProcedureLocking.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/MasterProcedureLocking.java
new file mode 100644
index 0000000..52e2466
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/MasterProcedureLocking.java
@@ -0,0 +1,147 @@
+/*
+ * *
+ *  * Licensed to the Apache Software Foundation (ASF) under one
+ *  * or more contributor license agreements.  See the NOTICE file
+ *  * distributed with this work for additional information
+ *  * regarding copyright ownership.  The ASF licenses this file
+ *  * to you under the Apache License, Version 2.0 (the
+ *  * "License"); you may not use this file except in compliance
+ *  * with the License.  You may obtain a copy of the License at
+ *  *
+ *  *     http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  * Unless required by applicable law or agreed to in writing, software
+ *  * distributed under the License is distributed on an "AS IS" BASIS,
+ *  * WITHOUTKey WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  * See the License for the specific language governing permissions and
+ *  * limitations under the License.
+ *
+ */
+
+package org.apache.hadoop.hbase.master.procedure;
+
+import org.apache.hadoop.hbase.ServerName;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.procedure2.Procedure;
+
+import java.util.ArrayDeque;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Locking for mutual exclusion between procedures at namespace/table/region levels. These locks
+ * are used only by procedure framework internally.
+ * {@link Lock} has two purposes:
+ * 1. Acquire/release exclusive/shared locks
+ * 2. Maintain a list of procedures waiting for this lock
+ *      To do so, {@link Lock} extends {@link ArrayDeque} class. Using inheritance over composition
+ *      for this need is unusual, but the choice is motivated by million regions assignment
+ *      case as it will reduce memory footprint and number of objects to be GCed.
+ *
+ * There is no need of 'synchronized' since MasterProcedureScheduler's schedLock() guards all
+ * function calls, so exclusion on members variables is guaranteed by it.
+ * There is no need of 'volatile' keyword for member variables because of memory synchronization
+ * guarantees of locks (see 'Memory Synchronization',
+ * http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html)
+ */
+public class MasterProcedureLocking {
+  class Lock extends ArrayDeque<Procedure> {
+    private long exclusiveLockProcIdOwner = Long.MIN_VALUE;
+    private int sharedLock = 0;
+
+    public long getExclusiveLockProcIdOwner() {
+      return exclusiveLockProcIdOwner;
+    }
+
+    public int getSharedLockCount() {
+      return sharedLock;
+    }
+
+    // ======================================================================
+    //  Read/Write Locking helpers
+    // ======================================================================
+    public boolean isLocked() {
+      return hasExclusiveLock() || sharedLock > 0;
+    }
+
+    public boolean hasExclusiveLock() {
+      return this.exclusiveLockProcIdOwner != Long.MIN_VALUE;
+    }
+
+    public boolean trySharedLock() {
+      if (hasExclusiveLock()) return false;
+      sharedLock++;
+      return true;
+    }
+
+    public boolean releaseSharedLock() {
+      return --sharedLock == 0;
+    }
+
+    public boolean isLockOwner(long procId) {
+      return exclusiveLockProcIdOwner == procId;
+    }
+
+    public boolean hasParentLock(final Procedure proc) {
+      return proc.hasParent() && (isLockOwner(proc.getParentProcId())
+          || isLockOwner(proc.getRootProcId()));
+    }
+
+    public boolean hasLockAccess(final Procedure proc) {
+      return isLockOwner(proc.getProcId()) || hasParentLock(proc);
+    }
+
+    public boolean tryExclusiveLock(final Procedure proc) {
+      if (isLocked()) return hasLockAccess(proc);
+      exclusiveLockProcIdOwner = proc.getProcId();
+      return true;
+    }
+
+    public boolean releaseExclusiveLock(final Procedure proc) {
+      if (isLockOwner(proc.getProcId())) {
+        exclusiveLockProcIdOwner = Long.MIN_VALUE;
+        return true;
+      }
+      return false;
+    }
+  }
+
+  private <T> Lock getLock(Map<T, Lock> map, T key) {
+    Lock lock = map.get(key);
+    if (lock == null) {
+      lock = new Lock();
+      map.put(key, lock);
+    }
+    return lock;
+  }
+
+  public Lock getTableLock(TableName tableName) {
+    return getLock(tableLocks, tableName);
+  }
+
+  public Lock removeTableLock(TableName tableName) {
+    return tableLocks.remove(tableName);
+  }
+
+  public Lock getNamespaceLock(String namespace) {
+    return getLock(namespaceLocks, namespace);
+  }
+
+  public Lock getRegionLock(String encodedRegionName) {
+    return getLock(regionLocks, encodedRegionName);
+  }
+
+  public Lock removeRegionLock(String encodedRegionName) {
+    return regionLocks.remove(encodedRegionName);
+  }
+
+  public Lock getServerLock(ServerName serverName) {
+    return getLock(serverLocks, serverName);
+  }
+
+  final Map<ServerName, Lock> serverLocks = new HashMap<>();
+  final Map<String, Lock> namespaceLocks = new HashMap<>();
+  final Map<TableName, Lock> tableLocks = new HashMap<>();
+  // Single map for all regions irrespective of tables. Key is encoded region name.
+  final Map<String, Lock> regionLocks = new HashMap<>();
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/MasterProcedureScheduler.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/MasterProcedureScheduler.java
index 8ec53a8..f71771f 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/MasterProcedureScheduler.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/MasterProcedureScheduler.java
@@ -22,7 +22,6 @@ import com.google.common.annotations.VisibleForTesting;
 
 import java.util.ArrayDeque;
 import java.util.Arrays;
-import java.util.HashMap;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -37,7 +36,6 @@ import org.apache.hadoop.hbase.classification.InterfaceStability;
 import org.apache.hadoop.hbase.master.procedure.TableProcedureInterface.TableOperationType;
 import org.apache.hadoop.hbase.procedure2.AbstractProcedureScheduler;
 import org.apache.hadoop.hbase.procedure2.Procedure;
-import org.apache.hadoop.hbase.procedure2.ProcedureEventQueue;
 import org.apache.hadoop.hbase.util.AvlUtil.AvlKeyComparator;
 import org.apache.hadoop.hbase.util.AvlUtil.AvlIterableList;
 import org.apache.hadoop.hbase.util.AvlUtil.AvlLinkedNode;
@@ -64,29 +62,47 @@ import org.apache.hadoop.hbase.util.AvlUtil.AvlTreeIterator;
 public class MasterProcedureScheduler extends AbstractProcedureScheduler {
   private static final Log LOG = LogFactory.getLog(MasterProcedureScheduler.class);
 
-  private final static NamespaceQueueKeyComparator NAMESPACE_QUEUE_KEY_COMPARATOR =
-      new NamespaceQueueKeyComparator();
   private final static ServerQueueKeyComparator SERVER_QUEUE_KEY_COMPARATOR =
       new ServerQueueKeyComparator();
   private final static TableQueueKeyComparator TABLE_QUEUE_KEY_COMPARATOR =
       new TableQueueKeyComparator();
 
-  private final FairQueue<ServerName> serverRunQueue = new FairQueue<ServerName>();
-  private final FairQueue<TableName> tableRunQueue = new FairQueue<TableName>();
+  private final FairQueue<ServerName> serverRunQueue = new FairQueue<>();
+  private final FairQueue<TableName> tableRunQueue = new FairQueue<>();
 
   private final ServerQueue[] serverBuckets = new ServerQueue[128];
-  private NamespaceQueue namespaceMap = null;
   private TableQueue tableMap = null;
+  private final MasterProcedureLocking locking = new MasterProcedureLocking();
 
-  private final int metaTablePriority;
-  private final int userTablePriority;
-  private final int sysTablePriority;
+  /**
+   * Table priority is used when scheduling procedures from {@link #tableRunQueue}. A TableQueue
+   * with priority 2 will get its procedures scheduled at twice the rate as compared to
+   * TableQueue with priority 1.
+   */
+  private static class TablePriorities {
+    TablePriorities(Configuration conf) {
+      metaTablePriority = conf.getInt("hbase.master.procedure.queue.meta.table.priority", 3);
+      sysTablePriority = conf.getInt("hbase.master.procedure.queue.system.table.priority", 2);
+      userTablePriority = conf.getInt("hbase.master.procedure.queue.user.table.priority", 1);
+    }
+
+    final int metaTablePriority;
+    final int userTablePriority;
+    final int sysTablePriority;
+
+    int getPriority(TableName tableName) {
+      if (tableName.equals(TableName.META_TABLE_NAME)) {
+        return metaTablePriority;
+      } else if (tableName.isSystemTable()) {
+        return sysTablePriority;
+      }
+      return userTablePriority;
+    }
+  }
+  private final TablePriorities tablePriorities;
 
   public MasterProcedureScheduler(final Configuration conf) {
-    // TODO: should this be part of the HTD?
-    metaTablePriority = conf.getInt("hbase.master.procedure.queue.meta.table.priority", 3);
-    sysTablePriority = conf.getInt("hbase.master.procedure.queue.system.table.priority", 2);
-    userTablePriority = conf.getInt("hbase.master.procedure.queue.user.table.priority", 1);
+    tablePriorities = new TablePriorities(conf);
   }
 
   @Override
@@ -113,11 +129,11 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
   private <T extends Comparable<T>> void doAdd(final FairQueue<T> fairq,
       final Queue<T> queue, final Procedure proc, final boolean addFront) {
     queue.add(proc, addFront);
-    if (!queue.hasExclusiveLock() || queue.isLockOwner(proc.getProcId())) {
+    if (!queue.getLock().hasExclusiveLock() || queue.getLock().isLockOwner(proc.getProcId())) {
       // if the queue was not remove for an xlock execution
       // or the proc is the lock owner, put the queue back into execution
       addToRunQueue(fairq, queue);
-    } else if (queue.hasParentLock(proc)) {
+    } else if (queue.getLock().hasParentLock(proc)) {
       assert addFront : "expected to add a child in the front";
       // our (proc) parent has the xlock,
       // so the queue is not in the fairq (run-queue)
@@ -151,7 +167,7 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
 
     final Procedure pollResult = rq.peek();
     final boolean xlockReq = rq.requireExclusiveLock(pollResult);
-    if (xlockReq && rq.isLocked() && !rq.hasLockAccess(pollResult)) {
+    if (xlockReq && rq.getLock().isLocked() && !rq.getLock().hasLockAccess(pollResult)) {
       // someone is already holding the lock (e.g. shared lock). avoid a yield
       removeFromRunQueue(fairq, rq);
       return null;
@@ -160,7 +176,7 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
     rq.poll();
     if (rq.isEmpty() || xlockReq) {
       removeFromRunQueue(fairq, rq);
-    } else if (rq.hasParentLock(pollResult)) {
+    } else if (rq.getLock().hasParentLock(pollResult)) {
       // if the rq is in the fairq because of runnable child
       // check if the next procedure is still a child.
       // if not, remove the rq from the fairq and go back to the xlock state
@@ -181,10 +197,6 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
       serverBuckets[i] = null;
     }
 
-    // Remove Namespaces
-    clear(namespaceMap, null, NAMESPACE_QUEUE_KEY_COMPARATOR);
-    namespaceMap = null;
-
     // Remove Tables
     clear(tableMap, tableRunQueue, TABLE_QUEUE_KEY_COMPARATOR);
     tableMap = null;
@@ -206,7 +218,7 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
     int count = 0;
 
     // Server queues
-    final AvlTreeIterator<ServerQueue> serverIter = new AvlTreeIterator<ServerQueue>();
+    final AvlTreeIterator<ServerQueue> serverIter = new AvlTreeIterator<>();
     for (int i = 0; i < serverBuckets.length; ++i) {
       serverIter.seekFirst(serverBuckets[i]);
       while (serverIter.hasNext()) {
@@ -215,7 +227,7 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
     }
 
     // Table queues
-    final AvlTreeIterator<TableQueue> tableIter = new AvlTreeIterator<TableQueue>(tableMap);
+    final AvlTreeIterator<TableQueue> tableIter = new AvlTreeIterator<>(tableMap);
     while (tableIter.hasNext()) {
       count += tableIter.next().size();
     }
@@ -250,13 +262,14 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
     }
   }
 
-  private <T extends Comparable<T>> void addToRunQueue(FairQueue<T> fairq, Queue<T> queue) {
+  private static <T extends Comparable<T>> void addToRunQueue(FairQueue<T> fairq, Queue<T> queue) {
     if (!AvlIterableList.isLinked(queue) && !queue.isEmpty()) {
       fairq.add(queue);
     }
   }
 
-  private <T extends Comparable<T>> void removeFromRunQueue(FairQueue<T> fairq, Queue<T> queue) {
+  private static <T extends Comparable<T>> void removeFromRunQueue(
+      FairQueue<T> fairq, Queue<T> queue) {
     if (AvlIterableList.isLinked(queue)) {
       fairq.remove(queue);
     }
@@ -265,37 +278,21 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
   // ============================================================================
   //  Table Queue Lookup Helpers
   // ============================================================================
-  private TableQueue getTableQueueWithLock(TableName tableName) {
-    schedLock();
-    try {
-      return getTableQueue(tableName);
-    } finally {
-      schedUnlock();
-    }
-  }
-
   private TableQueue getTableQueue(TableName tableName) {
     TableQueue node = AvlTree.get(tableMap, tableName, TABLE_QUEUE_KEY_COMPARATOR);
     if (node != null) return node;
 
-    NamespaceQueue nsQueue = getNamespaceQueue(tableName.getNamespaceAsString());
-    node = new TableQueue(tableName, nsQueue, getTablePriority(tableName));
+    node = new TableQueue(tableName, tablePriorities.getPriority(tableName),
+        locking.getTableLock(tableName), locking.getNamespaceLock(tableName.getNamespaceAsString()));
     tableMap = AvlTree.insert(tableMap, node);
     return node;
   }
 
   private void removeTableQueue(TableName tableName) {
     tableMap = AvlTree.remove(tableMap, tableName, TABLE_QUEUE_KEY_COMPARATOR);
+    locking.removeTableLock(tableName);
   }
 
-  private int getTablePriority(TableName tableName) {
-    if (tableName.equals(TableName.META_TABLE_NAME)) {
-      return metaTablePriority;
-    } else if (tableName.isSystemTable()) {
-      return sysTablePriority;
-    }
-    return userTablePriority;
-  }
 
   private static boolean isTableProcedure(Procedure proc) {
     return proc instanceof TableProcedureInterface;
@@ -306,43 +303,16 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
   }
 
   // ============================================================================
-  //  Namespace Queue Lookup Helpers
-  // ============================================================================
-  private NamespaceQueue getNamespaceQueue(String namespace) {
-    NamespaceQueue node = AvlTree.get(namespaceMap, namespace, NAMESPACE_QUEUE_KEY_COMPARATOR);
-    if (node != null) return (NamespaceQueue)node;
-
-    node = new NamespaceQueue(namespace);
-    namespaceMap = AvlTree.insert(namespaceMap, node);
-    return node;
-  }
-
-  // ============================================================================
   //  Server Queue Lookup Helpers
   // ============================================================================
-  private ServerQueue getServerQueueWithLock(ServerName serverName) {
-    schedLock();
-    try {
-      return getServerQueue(serverName);
-    } finally {
-      schedUnlock();
-    }
-  }
-
   private ServerQueue getServerQueue(ServerName serverName) {
     final int index = getBucketIndex(serverBuckets, serverName.hashCode());
     ServerQueue node = AvlTree.get(serverBuckets[index], serverName, SERVER_QUEUE_KEY_COMPARATOR);
     if (node != null) return node;
 
-    node = new ServerQueue(serverName);
+    node = new ServerQueue(serverName, locking.getServerLock(serverName));
     serverBuckets[index] = AvlTree.insert(serverBuckets[index], node);
-    return (ServerQueue)node;
-  }
-
-  private void removeServerQueue(ServerName serverName) {
-    final int index = getBucketIndex(serverBuckets, serverName.hashCode());
-    final ServerQueue root = serverBuckets[index];
-    serverBuckets[index] = AvlTree.remove(root, serverName, SERVER_QUEUE_KEY_COMPARATOR);
+    return node;
   }
 
   private static int getBucketIndex(Object[] buckets, int hashCode) {
@@ -367,9 +337,9 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
     }
   }
 
-  public static class ServerQueue extends QueueImpl<ServerName> {
-    public ServerQueue(ServerName serverName) {
-      super(serverName);
+  public static class ServerQueue extends Queue<ServerName> {
+    public ServerQueue(ServerName serverName, MasterProcedureLocking.Lock serverLock) {
+      super(serverName, serverLock);
     }
 
     public boolean requireExclusiveLock(Procedure proc) {
@@ -384,55 +354,6 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
     }
   }
 
-  private static class RegionEvent extends ProcedureEventQueue {
-    private final HRegionInfo regionInfo;
-    private long exclusiveLockProcIdOwner = Long.MIN_VALUE;
-
-    public RegionEvent(HRegionInfo regionInfo) {
-      this.regionInfo = regionInfo;
-    }
-
-    public boolean hasExclusiveLock() {
-      return exclusiveLockProcIdOwner != Long.MIN_VALUE;
-    }
-
-    public boolean isLockOwner(long procId) {
-      return exclusiveLockProcIdOwner == procId;
-    }
-
-    public boolean hasParentLock(final Procedure proc) {
-      return proc.hasParent() &&
-        (isLockOwner(proc.getParentProcId()) || isLockOwner(proc.getRootProcId()));
-    }
-
-    public boolean hasLockAccess(final Procedure proc) {
-      return isLockOwner(proc.getProcId()) || hasParentLock(proc);
-    }
-
-    public boolean tryExclusiveLock(final Procedure proc) {
-      if (hasExclusiveLock()) return hasLockAccess(proc);
-      exclusiveLockProcIdOwner = proc.getProcId();
-      return true;
-    }
-
-    public boolean releaseExclusiveLock(final Procedure proc) {
-      if (isLockOwner(proc.getProcId())) {
-        exclusiveLockProcIdOwner = Long.MIN_VALUE;
-        return true;
-      }
-      return false;
-    }
-
-    public HRegionInfo getRegionInfo() {
-      return regionInfo;
-    }
-
-    @Override
-    public String toString() {
-      return "RegionEvent(" + regionInfo.getRegionNameAsString() + ")";
-    }
-  }
-
   private static class TableQueueKeyComparator implements AvlKeyComparator<TableQueue> {
     @Override
     public int compareKey(TableQueue node, Object key) {
@@ -440,124 +361,39 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
     }
   }
 
-  public static class TableQueue extends QueueImpl<TableName> {
-    private final NamespaceQueue namespaceQueue;
-
-    private HashMap<String, RegionEvent> regionEventMap;
-
-    public TableQueue(TableName tableName, NamespaceQueue namespaceQueue, int priority) {
-      super(tableName, priority);
-      this.namespaceQueue = namespaceQueue;
-    }
+  public static class TableQueue extends Queue<TableName> {
+    private final MasterProcedureLocking.Lock namespaceLock;
 
-    public NamespaceQueue getNamespaceQueue() {
-      return namespaceQueue;
+    public TableQueue(TableName tableName, int priority,
+        MasterProcedureLocking.Lock tableLock, MasterProcedureLocking.Lock namespaceLock) {
+      super(tableName, priority, tableLock);
+      this.namespaceLock = namespaceLock;
     }
 
     @Override
     public boolean isAvailable() {
       // if there are no items in the queue, or the namespace is locked.
       // we can't execute operation on this table
-      if (isEmpty() || namespaceQueue.hasExclusiveLock()) {
+      if (isEmpty() || namespaceLock.hasExclusiveLock()) {
         return false;
       }
 
-      if (hasExclusiveLock()) {
+      if (getLock().hasExclusiveLock()) {
         // if we have an exclusive lock already taken
         // only child of the lock owner can be executed
         final Procedure nextProc = peek();
-        return nextProc != null && hasLockAccess(nextProc);
+        return nextProc != null && getLock().hasLockAccess(nextProc);
       }
 
       // no xlock
       return true;
     }
 
-    public RegionEvent getRegionEvent(final HRegionInfo regionInfo) {
-      if (regionEventMap == null) {
-        regionEventMap = new HashMap<String, RegionEvent>();
-      }
-      RegionEvent event = regionEventMap.get(regionInfo.getEncodedName());
-      if (event == null) {
-        event = new RegionEvent(regionInfo);
-        regionEventMap.put(regionInfo.getEncodedName(), event);
-      }
-      return event;
-    }
-
-    public void removeRegionEvent(final RegionEvent event) {
-      regionEventMap.remove(event.getRegionInfo().getEncodedName());
-      if (regionEventMap.isEmpty()) {
-        regionEventMap = null;
-      }
-    }
-
-    // TODO: We can abort pending/in-progress operation if the new call is
-    //       something like drop table. We can Override addBack(),
-    //       check the type and abort all the in-flight procedurs.
-    private boolean canAbortPendingOperations(Procedure proc) {
-      TableProcedureInterface tpi = (TableProcedureInterface)proc;
-      switch (tpi.getTableOperationType()) {
-        case DELETE:
-          return true;
-        default:
-          return false;
-      }
-    }
-
     public boolean requireExclusiveLock(Procedure proc) {
       return requireTableExclusiveLock((TableProcedureInterface)proc);
     }
   }
 
-  private static class NamespaceQueueKeyComparator implements AvlKeyComparator<NamespaceQueue> {
-    @Override
-    public int compareKey(NamespaceQueue node, Object key) {
-      return node.compareKey((String)key);
-    }
-  }
-
-  /**
-   * the namespace is currently used just as a rwlock, not as a queue.
-   * because ns operation are not frequent enough. so we want to avoid
-   * having to move table queues around for suspend/resume.
-   */
-  private static class NamespaceQueue extends Queue<String> {
-    public NamespaceQueue(String namespace) {
-      super(namespace);
-    }
-
-    @Override
-    public boolean requireExclusiveLock(Procedure proc) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void add(final Procedure proc, final boolean addToFront) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public Procedure peek() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public Procedure poll() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean isEmpty() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public int size() {
-      throw new UnsupportedOperationException();
-    }
-  }
-
   // ============================================================================
   //  Table Locking Helpers
   // ============================================================================
@@ -598,18 +434,19 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
   public boolean waitTableExclusiveLock(final Procedure procedure, final TableName table) {
     schedLock();
     try {
-      final TableQueue tableQueue = getTableQueue(table);
-      final NamespaceQueue nsQueue = tableQueue.getNamespaceQueue();
-      if (!nsQueue.trySharedLock()) {
-        suspendProcedure(nsQueue.getEvent(), procedure);
+      final MasterProcedureLocking.Lock namespaceLock = locking.getNamespaceLock(
+          table.getNamespaceAsString());
+      final MasterProcedureLocking.Lock tableLock = locking.getTableLock(table);
+      if (!namespaceLock.trySharedLock()) {
+        waitProcedure(namespaceLock, procedure);
         return true;
       }
-      if (!tableQueue.tryExclusiveLock(procedure)) {
-        nsQueue.releaseSharedLock();
-        suspendProcedure(tableQueue.getEvent(), procedure);
+      if (!tableLock.tryExclusiveLock(procedure)) {
+        namespaceLock.releaseSharedLock();
+        waitProcedure(tableLock, procedure);
         return true;
       }
-      removeFromRunQueue(tableRunQueue, tableQueue);
+      removeFromRunQueue(tableRunQueue, getTableQueue(table));
       return false;
     } finally {
       schedUnlock();
@@ -624,18 +461,19 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
   public void wakeTableExclusiveLock(final Procedure procedure, final TableName table) {
     schedLock();
     try {
-      final TableQueue tableQueue = getTableQueue(table);
+      final MasterProcedureLocking.Lock namespaceLock = locking.getNamespaceLock(
+          table.getNamespaceAsString());
+      final MasterProcedureLocking.Lock tableLock = locking.getTableLock(table);
       int waitingCount = 0;
 
-      if (!tableQueue.hasParentLock(procedure)) {
-        tableQueue.releaseExclusiveLock(procedure);
-        waitingCount += popEventWaitingProcedures(tableQueue.getEvent());
+      if (!tableLock.hasParentLock(procedure)) {
+        tableLock.releaseExclusiveLock(procedure);
+        waitingCount += wakeWaitingProcedures(tableLock);
       }
-      final NamespaceQueue nsQueue = tableQueue.getNamespaceQueue();
-      if (nsQueue.releaseSharedLock()) {
-        waitingCount += popEventWaitingProcedures(nsQueue.getEvent());
+      if (namespaceLock.releaseSharedLock()) {
+        waitingCount += wakeWaitingProcedures(namespaceLock);
       }
-      addToRunQueue(tableRunQueue, tableQueue);
+      addToRunQueue(tableRunQueue, getTableQueue(table));
       wakePollIfNeeded(waitingCount);
     } finally {
       schedUnlock();
@@ -656,20 +494,21 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
   private TableQueue waitTableQueueSharedLock(final Procedure procedure, final TableName table) {
     schedLock();
     try {
-      final TableQueue tableQueue = getTableQueue(table);
-      final NamespaceQueue nsQueue = tableQueue.getNamespaceQueue();
-      if (!nsQueue.trySharedLock()) {
-        suspendProcedure(nsQueue.getEvent(), procedure);
+      final MasterProcedureLocking.Lock namespaceLock = locking.getNamespaceLock(
+          table.getNamespaceAsString());
+      final MasterProcedureLocking.Lock tableLock = locking.getTableLock(table);
+      if (!namespaceLock.trySharedLock()) {
+        waitProcedure(namespaceLock, procedure);
         return null;
       }
 
-      if (!tableQueue.trySharedLock()) {
-        tableQueue.getNamespaceQueue().releaseSharedLock();
-        suspendProcedure(tableQueue.getEvent(), procedure);
+      if (!tableLock.trySharedLock()) {
+        namespaceLock.releaseSharedLock();
+        waitProcedure(tableLock, procedure);
         return null;
       }
 
-      return tableQueue;
+      return getTableQueue(table);
     } finally {
       schedUnlock();
     }
@@ -683,15 +522,16 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
   public void wakeTableSharedLock(final Procedure procedure, final TableName table) {
     schedLock();
     try {
-      final TableQueue tableQueue = getTableQueue(table);
-      final NamespaceQueue nsQueue = tableQueue.getNamespaceQueue();
+      final MasterProcedureLocking.Lock namespaceLock = locking.getNamespaceLock(
+          table.getNamespaceAsString());
+      final MasterProcedureLocking.Lock tableLock = locking.getTableLock(table);
       int waitingCount = 0;
-      if (tableQueue.releaseSharedLock()) {
-        addToRunQueue(tableRunQueue, tableQueue);
-        waitingCount += popEventWaitingProcedures(tableQueue.getEvent());
+      if (tableLock.releaseSharedLock()) {
+        addToRunQueue(tableRunQueue, getTableQueue(table));
+        waitingCount += wakeWaitingProcedures(tableLock);
       }
-      if (nsQueue.releaseSharedLock()) {
-        waitingCount += popEventWaitingProcedures(nsQueue.getEvent());
+      if (namespaceLock.releaseSharedLock()) {
+        waitingCount += wakeWaitingProcedures(namespaceLock);
       }
       wakePollIfNeeded(waitingCount);
     } finally {
@@ -712,10 +552,10 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
   protected boolean markTableAsDeleted(final TableName table, final Procedure procedure) {
     schedLock();
     try {
-      TableQueue queue = getTableQueue(table);
+      final TableQueue queue = getTableQueue(table);
       if (queue == null) return true;
 
-      if (queue.isEmpty() && queue.tryExclusiveLock(procedure)) {
+      if (queue.isEmpty() && queue.getLock().tryExclusiveLock(procedure)) {
         // remove the table from the run-queue and the map
         if (AvlIterableList.isLinked(queue)) {
           tableRunQueue.remove(queue);
@@ -754,41 +594,41 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
   public boolean waitRegions(final Procedure procedure, final TableName table,
       final HRegionInfo... regionInfo) {
     Arrays.sort(regionInfo);
+    schedLock();
+    try {
+      // If there is parent procedure, it would have already taken xlock, so no need to take
+      // shared lock here. Otherwise, take shared lock.
+      if (!procedure.hasParent()
+          && waitTableQueueSharedLock(procedure, table) == null) {
+          return true;
+      }
 
-    final TableQueue queue;
-    if (procedure.hasParent()) {
-      // the assumption is that the parent procedure have already the table xlock
-      queue = getTableQueueWithLock(table);
-    } else {
-      // acquire the table shared-lock
-      queue = waitTableQueueSharedLock(procedure, table);
-      if (queue == null) return true;
-    }
-
-    // acquire region xlocks or wait
-    boolean hasLock = true;
-    final RegionEvent[] event = new RegionEvent[regionInfo.length];
-    synchronized (queue) {
+      // acquire region xlocks or wait
+      boolean hasLock = true;
+      final MasterProcedureLocking.Lock[] regionLocks =
+          new MasterProcedureLocking.Lock[regionInfo.length];
       for (int i = 0; i < regionInfo.length; ++i) {
         assert regionInfo[i].getTable().equals(table);
-        assert i == 0 || regionInfo[i] != regionInfo[i-1] : "duplicate region: " + regionInfo[i];
+        assert i == 0 || regionInfo[i] != regionInfo[i - 1] : "duplicate region: " + regionInfo[i];
 
-        event[i] = queue.getRegionEvent(regionInfo[i]);
-        if (!event[i].tryExclusiveLock(procedure)) {
-          suspendProcedure(event[i], procedure);
+        regionLocks[i] = locking.getRegionLock(regionInfo[i].getEncodedName());
+        if (!regionLocks[i].tryExclusiveLock(procedure)) {
+          waitProcedure(regionLocks[i], procedure);
           hasLock = false;
           while (i-- > 0) {
-            event[i].releaseExclusiveLock(procedure);
+            regionLocks[i].releaseExclusiveLock(procedure);
           }
           break;
         }
       }
-    }
 
-    if (!hasLock && !procedure.hasParent()) {
-      wakeTableSharedLock(procedure, table);
+      if (!hasLock && !procedure.hasParent()) {
+        wakeTableSharedLock(procedure, table);
+      }
+      return !hasLock;
+    } finally {
+      schedUnlock();
     }
-    return !hasLock;
   }
 
   /**
@@ -808,32 +648,26 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
   public void wakeRegions(final Procedure procedure,final TableName table,
       final HRegionInfo... regionInfo) {
     Arrays.sort(regionInfo);
-
-    final TableQueue queue = getTableQueueWithLock(table);
-
-    int numProcs = 0;
-    final Procedure[] nextProcs = new Procedure[regionInfo.length];
-    synchronized (queue) {
-      HRegionInfo prevRegion = null;
+    schedLock();
+    try {
+      int numProcs = 0;
+      final Procedure[] nextProcs = new Procedure[regionInfo.length];
       for (int i = 0; i < regionInfo.length; ++i) {
         assert regionInfo[i].getTable().equals(table);
-        assert i == 0 || regionInfo[i] != regionInfo[i-1] : "duplicate region: " + regionInfo[i];
+        assert i == 0 || regionInfo[i] != regionInfo[i - 1] : "duplicate region: " + regionInfo[i];
 
-        RegionEvent event = queue.getRegionEvent(regionInfo[i]);
-        if (event.releaseExclusiveLock(procedure)) {
-          if (event.hasWaitingProcedures()) {
+        MasterProcedureLocking.Lock regionLock = locking.getRegionLock(regionInfo[i].getEncodedName());
+        if (regionLock.releaseExclusiveLock(procedure)) {
+          if (!regionLock.isEmpty()) {
             // release one procedure at the time since regions has an xlock
-            nextProcs[numProcs++] = event.popWaitingProcedure(true);
+            nextProcs[numProcs++] = regionLock.removeFirst();
           } else {
-            queue.removeRegionEvent(event);
+            locking.removeRegionLock(regionInfo[i].getEncodedName());
           }
         }
       }
-    }
 
-    // awake procedures if any
-    schedLock();
-    try {
+      // awake procedures if any
       for (int i = numProcs - 1; i >= 0; --i) {
         wakeProcedure(nextProcs[i]);
       }
@@ -855,22 +689,24 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
    * Suspend the procedure if the specified namespace is already locked.
    * @see #wakeNamespaceExclusiveLock(Procedure,String)
    * @param procedure the procedure trying to acquire the lock
-   * @param nsName Namespace to lock
+   * @param namespace Namespace to lock
    * @return true if the procedure has to wait for the namespace to be available
    */
-  public boolean waitNamespaceExclusiveLock(final Procedure procedure, final String nsName) {
+  public boolean waitNamespaceExclusiveLock(final Procedure procedure, final String namespace) {
     schedLock();
     try {
-      final TableQueue tableQueue = getTableQueue(TableName.NAMESPACE_TABLE_NAME);
-      if (!tableQueue.trySharedLock()) {
-        suspendProcedure(tableQueue.getEvent(), procedure);
+      final MasterProcedureLocking.Lock systemNamespaceTableLock =
+          locking.getTableLock(TableName.NAMESPACE_TABLE_NAME);
+      if (!systemNamespaceTableLock.trySharedLock()) {
+        waitProcedure(systemNamespaceTableLock, procedure);
         return true;
       }
 
-      final NamespaceQueue nsQueue = getNamespaceQueue(nsName);
-      if (!nsQueue.tryExclusiveLock(procedure)) {
-        tableQueue.releaseSharedLock();
-        suspendProcedure(nsQueue.getEvent(), procedure);
+      final MasterProcedureLocking.Lock namespaceLock =
+          locking.getNamespaceLock(namespace);
+      if (!namespaceLock.tryExclusiveLock(procedure)) {
+        systemNamespaceTableLock.releaseSharedLock();
+        waitProcedure(namespaceLock, procedure);
         return true;
       }
       return false;
@@ -883,20 +719,22 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
    * Wake the procedures waiting for the specified namespace
    * @see #waitNamespaceExclusiveLock(Procedure,String)
    * @param procedure the procedure releasing the lock
-   * @param nsName the namespace that has the exclusive lock
+   * @param namespace the namespace that has the exclusive lock
    */
-  public void wakeNamespaceExclusiveLock(final Procedure procedure, final String nsName) {
+  public void wakeNamespaceExclusiveLock(final Procedure procedure, final String namespace) {
     schedLock();
     try {
-      final TableQueue tableQueue = getTableQueue(TableName.NAMESPACE_TABLE_NAME);
-      final NamespaceQueue nsQueue = getNamespaceQueue(nsName);
+      final MasterProcedureLocking.Lock namespaceLock =
+          locking.getNamespaceLock(namespace);
+      final MasterProcedureLocking.Lock systemNamespaceTableLock =
+          locking.getTableLock(TableName.NAMESPACE_TABLE_NAME);
+      namespaceLock.releaseExclusiveLock(procedure);
       int waitingCount = 0;
-      nsQueue.releaseExclusiveLock(procedure);
-      if (tableQueue.releaseSharedLock()) {
-        addToRunQueue(tableRunQueue, tableQueue);
-        waitingCount += popEventWaitingProcedures(tableQueue.getEvent());
+      if(systemNamespaceTableLock.releaseSharedLock()) {
+        addToRunQueue(tableRunQueue, getTableQueue(TableName.NAMESPACE_TABLE_NAME));
+        waitingCount += wakeWaitingProcedures(systemNamespaceTableLock);
       }
-      waitingCount += popEventWaitingProcedures(nsQueue.getEvent());
+      waitingCount += wakeWaitingProcedures(namespaceLock);
       wakePollIfNeeded(waitingCount);
     } finally {
       schedUnlock();
@@ -916,12 +754,12 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
   public boolean waitServerExclusiveLock(final Procedure procedure, final ServerName serverName) {
     schedLock();
     try {
-      ServerQueue queue = getServerQueue(serverName);
-      if (queue.tryExclusiveLock(procedure)) {
-        removeFromRunQueue(serverRunQueue, queue);
+      final MasterProcedureLocking.Lock lock = locking.getServerLock(serverName);
+      if (lock.tryExclusiveLock(procedure)) {
+        removeFromRunQueue(serverRunQueue, getServerQueue(serverName));
         return false;
       }
-      suspendProcedure(queue.getEvent(), procedure);
+      waitProcedure(lock, procedure);
       return true;
     } finally {
       schedUnlock();
@@ -937,10 +775,10 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
   public void wakeServerExclusiveLock(final Procedure procedure, final ServerName serverName) {
     schedLock();
     try {
-      final ServerQueue queue = getServerQueue(serverName);
-      queue.releaseExclusiveLock(procedure);
-      addToRunQueue(serverRunQueue, queue);
-      int waitingCount = popEventWaitingProcedures(queue.getEvent());
+      final MasterProcedureLocking.Lock lock = locking.getServerLock(serverName);
+      lock.releaseExclusiveLock(procedure);
+      addToRunQueue(serverRunQueue, getServerQueue(serverName));
+      int waitingCount = wakeWaitingProcedures(lock);
       wakePollIfNeeded(waitingCount);
     } finally {
       schedUnlock();
@@ -950,38 +788,27 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
   // ============================================================================
   //  Generic Helpers
   // ============================================================================
-  private static interface QueueInterface {
-    boolean isAvailable();
-    boolean isEmpty();
-    int size();
-
-    void add(Procedure proc, boolean addFront);
-    boolean requireExclusiveLock(Procedure proc);
-    Procedure peek();
-    Procedure poll();
-  }
-
-  // TODO Why OK not having synchronized access and/or volatiles and
-  // sharedLock-- and sharedLock++? Is this accessed by one thread only?
-  // Write up the concurrency expectations. St.Ack 01/19/2017
   private static abstract class Queue<TKey extends Comparable<TKey>>
-      extends AvlLinkedNode<Queue<TKey>> implements QueueInterface {
-    private final ProcedureEventQueue event;
-
-    private long exclusiveLockProcIdOwner = Long.MIN_VALUE;
-    private int sharedLock = 0;
+      extends AvlLinkedNode<Queue<TKey>> {
+    abstract boolean requireExclusiveLock(Procedure proc);
 
     private final TKey key;
     private final int priority;
+    private final ArrayDeque<Procedure> runnables = new ArrayDeque<Procedure>();
+    /**
+     * Reference to the lock on entity this queue represents. All locks are owned by
+     * {@link MasterProcedureLocking}.
+     */
+    private final MasterProcedureLocking.Lock lock;
 
-    public Queue(TKey key) {
-      this(key, 1);
+    public Queue(TKey key, MasterProcedureLocking.Lock lock) {
+      this(key, 1, lock);
     }
 
-    public Queue(TKey key, int priority) {
+    public Queue(TKey key, int priority, MasterProcedureLocking.Lock lock) {
       this.key = key;
       this.priority = priority;
-      this.event = new ProcedureEventQueue();
+      this.lock = lock;
     }
 
     protected TKey getKey() {
@@ -992,66 +819,41 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
       return priority;
     }
 
-    public ProcedureEventQueue getEvent() {
-      return event;
+    protected MasterProcedureLocking.Lock getLock() {
+      return lock;
     }
 
-    // ======================================================================
-    //  Read/Write Locking helpers
-    // ======================================================================
-    public boolean isLocked() {
-      return hasExclusiveLock() || sharedLock > 0;
-    }
-
-    public boolean hasExclusiveLock() {
-      return this.exclusiveLockProcIdOwner != Long.MIN_VALUE;
-    }
-
-    public boolean trySharedLock() {
-      if (hasExclusiveLock()) return false;
-      sharedLock++;
-      return true;
-    }
-
-    public boolean releaseSharedLock() {
-      return --sharedLock == 0;
-    }
-
-    protected boolean isSingleSharedLock() {
-      return sharedLock == 1;
-    }
-
-    public boolean isLockOwner(long procId) {
-      return exclusiveLockProcIdOwner == procId;
+    // This should go away when we have the new AM and its events
+    // and we move xlock to the lock-event-queue.
+    public boolean isAvailable() {
+      return !lock.hasExclusiveLock() && !isEmpty();
     }
 
-    public boolean hasParentLock(final Procedure proc) {
-      return proc.hasParent() &&
-        (isLockOwner(proc.getParentProcId()) || isLockOwner(proc.getRootProcId()));
+    // ======================================================================
+    //  Functions to handle procedure queue
+    // ======================================================================
+    public void add(final Procedure proc, final boolean addToFront) {
+      if (addToFront) {
+        runnables.addFirst(proc);
+      } else {
+        runnables.addLast(proc);
+      }
     }
 
-    public boolean hasLockAccess(final Procedure proc) {
-      return isLockOwner(proc.getProcId()) || hasParentLock(proc);
+    public Procedure peek() {
+      return runnables.peek();
     }
 
-    public boolean tryExclusiveLock(final Procedure proc) {
-      if (isLocked()) return hasLockAccess(proc);
-      exclusiveLockProcIdOwner = proc.getProcId();
-      return true;
+    public Procedure poll() {
+      return runnables.poll();
     }
 
-    public boolean releaseExclusiveLock(final Procedure proc) {
-      if (isLockOwner(proc.getProcId())) {
-        exclusiveLockProcIdOwner = Long.MIN_VALUE;
-        return true;
-      }
-      return false;
+    public boolean isEmpty() {
+      return runnables.isEmpty();
     }
 
-    // This should go away when we have the new AM and its events
-    // and we move xlock to the lock-event-queue.
-    public boolean isAvailable() {
-      return !hasExclusiveLock() && !isEmpty();
+    public int size() {
+      return runnables.size();
     }
 
     // ======================================================================
@@ -1070,59 +872,14 @@ public class MasterProcedureScheduler extends AbstractProcedureScheduler {
     public String toString() {
       return String.format("%s(%s, xlock=%s sharedLock=%s size=%s)",
           getClass().getSimpleName(), key,
-          hasExclusiveLock() ? "true (" + exclusiveLockProcIdOwner + ")" : "false",
-          sharedLock, size());
+          lock.hasExclusiveLock() ? "true (" + lock.getExclusiveLockProcIdOwner() + ")" : "false",
+          lock.getSharedLockCount(), size());
     }
   }
 
   // ======================================================================
   //  Helper Data Structures
   // ======================================================================
-  private static abstract class QueueImpl<TKey extends Comparable<TKey>> extends Queue<TKey> {
-    private final ArrayDeque<Procedure> runnables = new ArrayDeque<Procedure>();
-
-    public QueueImpl(TKey key) {
-      super(key);
-    }
-
-    public QueueImpl(TKey key, int priority) {
-      super(key, priority);
-    }
-
-    public void add(final Procedure proc, final boolean addToFront) {
-      if (addToFront) {
-        addFront(proc);
-      } else {
-        addBack(proc);
-      }
-    }
-
-    protected void addFront(final Procedure proc) {
-      runnables.addFirst(proc);
-    }
-
-    protected void addBack(final Procedure proc) {
-      runnables.addLast(proc);
-    }
-
-    public Procedure peek() {
-      return runnables.peek();
-    }
-
-    @Override
-    public Procedure poll() {
-      return runnables.poll();
-    }
-
-    @Override
-    public boolean isEmpty() {
-      return runnables.isEmpty();
-    }
-
-    public int size() {
-      return runnables.size();
-    }
-  }
 
   private static class FairQueue<T extends Comparable<T>> {
     private final int quantum;
-- 
2.3.2 (Apple Git-55)
