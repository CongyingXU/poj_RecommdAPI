From 98c981b6b6ae21dfaf68d006303a9e0c3991dfcc Mon Sep 17 00:00:00 2001
From: Josh Elser <elserj@apache.org>
Date: Sun, 13 Dec 2015 21:05:38 -0500
Subject: [PATCH] HBASE-14800 Expose checkAndMutate API for thrift2

---
 .../hbase/thrift/generated/AlreadyExists.java      |    2 +-
 .../hbase/thrift/generated/BatchMutation.java      |    2 +-
 .../hbase/thrift/generated/ColumnDescriptor.java   |    2 +-
 .../hadoop/hbase/thrift/generated/Hbase.java       |    2 +-
 .../hadoop/hbase/thrift/generated/IOError.java     |    2 +-
 .../hbase/thrift/generated/IllegalArgument.java    |    2 +-
 .../hadoop/hbase/thrift/generated/Mutation.java    |    2 +-
 .../hadoop/hbase/thrift/generated/TAppend.java     |    2 +-
 .../hadoop/hbase/thrift/generated/TCell.java       |    2 +-
 .../hadoop/hbase/thrift/generated/TColumn.java     |    2 +-
 .../hadoop/hbase/thrift/generated/TIncrement.java  |    2 +-
 .../hadoop/hbase/thrift/generated/TRegionInfo.java |    2 +-
 .../hadoop/hbase/thrift/generated/TRowResult.java  |    2 +-
 .../hadoop/hbase/thrift/generated/TScan.java       |    2 +-
 .../hbase/thrift2/ThriftHBaseServiceHandler.java   |   15 +
 .../hadoop/hbase/thrift2/ThriftUtilities.java      |   15 +
 .../hadoop/hbase/thrift2/generated/TAppend.java    |    2 +-
 .../hbase/thrift2/generated/TAuthorization.java    |    2 +-
 .../hbase/thrift2/generated/TCellVisibility.java   |    2 +-
 .../hadoop/hbase/thrift2/generated/TColumn.java    |    2 +-
 .../hbase/thrift2/generated/TColumnIncrement.java  |    2 +-
 .../hbase/thrift2/generated/TColumnValue.java      |    2 +-
 .../hadoop/hbase/thrift2/generated/TCompareOp.java |   64 +
 .../hadoop/hbase/thrift2/generated/TDelete.java    |    2 +-
 .../hadoop/hbase/thrift2/generated/TGet.java       |    2 +-
 .../hbase/thrift2/generated/THBaseService.java     | 1780 +++++++++++++++++++-
 .../hbase/thrift2/generated/THRegionInfo.java      |    2 +-
 .../hbase/thrift2/generated/THRegionLocation.java  |    2 +-
 .../hadoop/hbase/thrift2/generated/TIOError.java   |    2 +-
 .../hbase/thrift2/generated/TIllegalArgument.java  |    2 +-
 .../hadoop/hbase/thrift2/generated/TIncrement.java |    2 +-
 .../hadoop/hbase/thrift2/generated/TPut.java       |    2 +-
 .../hadoop/hbase/thrift2/generated/TResult.java    |    2 +-
 .../hbase/thrift2/generated/TRowMutations.java     |    2 +-
 .../hadoop/hbase/thrift2/generated/TScan.java      |    2 +-
 .../hbase/thrift2/generated/TServerName.java       |    2 +-
 .../hadoop/hbase/thrift2/generated/TTimeRange.java |    2 +-
 .../org/apache/hadoop/hbase/thrift2/hbase.thrift   |   45 +
 .../thrift2/TestThriftHBaseServiceHandler.java     |   63 +-
 39 files changed, 2011 insertions(+), 37 deletions(-)
 create mode 100644 hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TCompareOp.java

diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/AlreadyExists.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/AlreadyExists.java
index ba5952e..b25b59a 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/AlreadyExists.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/AlreadyExists.java
@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;
  * An AlreadyExists exceptions signals that a table with the specified
  * name already exists
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class AlreadyExists extends TException implements org.apache.thrift.TBase<AlreadyExists, AlreadyExists._Fields>, java.io.Serializable, Cloneable, Comparable<AlreadyExists> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("AlreadyExists");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/BatchMutation.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/BatchMutation.java
index 718b694..44700a6 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/BatchMutation.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/BatchMutation.java
@@ -37,7 +37,7 @@ import org.slf4j.LoggerFactory;
 /**
  * A BatchMutation object is used to apply a number of Mutations to a single row.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class BatchMutation implements org.apache.thrift.TBase<BatchMutation, BatchMutation._Fields>, java.io.Serializable, Cloneable, Comparable<BatchMutation> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("BatchMutation");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/ColumnDescriptor.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/ColumnDescriptor.java
index 4790625..86433d3 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/ColumnDescriptor.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/ColumnDescriptor.java
@@ -39,7 +39,7 @@ import org.slf4j.LoggerFactory;
  * such as the number of versions, compression settings, etc. It is
  * used as input when creating a table or adding a column.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class ColumnDescriptor implements org.apache.thrift.TBase<ColumnDescriptor, ColumnDescriptor._Fields>, java.io.Serializable, Cloneable, Comparable<ColumnDescriptor> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("ColumnDescriptor");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/Hbase.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/Hbase.java
index 5e2a25d..744933a 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/Hbase.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/Hbase.java
@@ -34,7 +34,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 @SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class Hbase {
 
   public interface Iface {
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/IOError.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/IOError.java
index fe60ab5..c9cd85e 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/IOError.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/IOError.java
@@ -39,7 +39,7 @@ import org.slf4j.LoggerFactory;
  * to the Hbase master or an Hbase region server.  Also used to return
  * more general Hbase error conditions.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class IOError extends TException implements org.apache.thrift.TBase<IOError, IOError._Fields>, java.io.Serializable, Cloneable, Comparable<IOError> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("IOError");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/IllegalArgument.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/IllegalArgument.java
index a0eeb96..b78fc7b 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/IllegalArgument.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/IllegalArgument.java
@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;
  * An IllegalArgument exception indicates an illegal or invalid
  * argument was passed into a procedure.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class IllegalArgument extends TException implements org.apache.thrift.TBase<IllegalArgument, IllegalArgument._Fields>, java.io.Serializable, Cloneable, Comparable<IllegalArgument> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("IllegalArgument");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/Mutation.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/Mutation.java
index 7401f3d..d453c5d 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/Mutation.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/Mutation.java
@@ -37,7 +37,7 @@ import org.slf4j.LoggerFactory;
 /**
  * A Mutation object is used to either update or delete a column-value.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class Mutation implements org.apache.thrift.TBase<Mutation, Mutation._Fields>, java.io.Serializable, Cloneable, Comparable<Mutation> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("Mutation");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TAppend.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TAppend.java
index 586b9e3..6101ce2 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TAppend.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TAppend.java
@@ -37,7 +37,7 @@ import org.slf4j.LoggerFactory;
 /**
  * An Append object is used to specify the parameters for performing the append operation.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TAppend implements org.apache.thrift.TBase<TAppend, TAppend._Fields>, java.io.Serializable, Cloneable, Comparable<TAppend> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TAppend");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TCell.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TCell.java
index 29961e4..42033a2 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TCell.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TCell.java
@@ -40,7 +40,7 @@ import org.slf4j.LoggerFactory;
  * the timestamp of a cell to a first-class value, making it easy to take
  * note of temporal data. Cell is used all the way from HStore up to HTable.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TCell implements org.apache.thrift.TBase<TCell, TCell._Fields>, java.io.Serializable, Cloneable, Comparable<TCell> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TCell");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TColumn.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TColumn.java
index 8573c88..016338f 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TColumn.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TColumn.java
@@ -37,7 +37,7 @@ import org.slf4j.LoggerFactory;
 /**
  * Holds column name and the cell.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TColumn implements org.apache.thrift.TBase<TColumn, TColumn._Fields>, java.io.Serializable, Cloneable, Comparable<TColumn> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TColumn");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TIncrement.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TIncrement.java
index 7d40b75..574db00 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TIncrement.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TIncrement.java
@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;
  * For increments that are not incrementColumnValue
  * equivalents.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TIncrement implements org.apache.thrift.TBase<TIncrement, TIncrement._Fields>, java.io.Serializable, Cloneable, Comparable<TIncrement> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TIncrement");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TRegionInfo.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TRegionInfo.java
index bd358cb..3e7bc9f 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TRegionInfo.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TRegionInfo.java
@@ -37,7 +37,7 @@ import org.slf4j.LoggerFactory;
 /**
  * A TRegionInfo contains information about an HTable region.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TRegionInfo implements org.apache.thrift.TBase<TRegionInfo, TRegionInfo._Fields>, java.io.Serializable, Cloneable, Comparable<TRegionInfo> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TRegionInfo");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TRowResult.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TRowResult.java
index e862f3b..5ad1b74 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TRowResult.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TRowResult.java
@@ -37,7 +37,7 @@ import org.slf4j.LoggerFactory;
 /**
  * Holds row name and then a map of columns to cells.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TRowResult implements org.apache.thrift.TBase<TRowResult, TRowResult._Fields>, java.io.Serializable, Cloneable, Comparable<TRowResult> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TRowResult");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TScan.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TScan.java
index 7a4b51f..bbeee92 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TScan.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift/generated/TScan.java
@@ -37,7 +37,7 @@ import org.slf4j.LoggerFactory;
 /**
  * A Scan object is used to specify scanner parameters when opening a scanner.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TScan implements org.apache.thrift.TBase<TScan, TScan._Fields>, java.io.Serializable, Cloneable, Comparable<TScan> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TScan");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftHBaseServiceHandler.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftHBaseServiceHandler.java
index 3058bf3..c59576e 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftHBaseServiceHandler.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftHBaseServiceHandler.java
@@ -19,6 +19,7 @@
 package org.apache.hadoop.hbase.thrift2;
 
 import static org.apache.hadoop.hbase.thrift2.ThriftUtilities.appendFromThrift;
+import static org.apache.hadoop.hbase.thrift2.ThriftUtilities.compareOpFromThrift;
 import static org.apache.hadoop.hbase.thrift2.ThriftUtilities.deleteFromThrift;
 import static org.apache.hadoop.hbase.thrift2.ThriftUtilities.deletesFromThrift;
 import static org.apache.hadoop.hbase.thrift2.ThriftUtilities.getFromThrift;
@@ -55,6 +56,7 @@ import org.apache.hadoop.hbase.client.Table;
 import org.apache.hadoop.hbase.security.UserProvider;
 import org.apache.hadoop.hbase.thrift.ThriftMetrics;
 import org.apache.hadoop.hbase.thrift2.generated.TAppend;
+import org.apache.hadoop.hbase.thrift2.generated.TCompareOp;
 import org.apache.hadoop.hbase.thrift2.generated.TDelete;
 import org.apache.hadoop.hbase.thrift2.generated.TGet;
 import org.apache.hadoop.hbase.thrift2.generated.THBaseService;
@@ -298,6 +300,19 @@ public class ThriftHBaseServiceHandler implements THBaseService.Iface {
     }
     return Collections.emptyList();
   }
+  
+  @Override
+  public boolean checkAndMutate(ByteBuffer table, ByteBuffer row, ByteBuffer family,
+      ByteBuffer qualifier, TCompareOp compareOp, ByteBuffer value, TRowMutations rowMutations)
+          throws TIOError, TException {
+    try (final Table htable = getTable(table)) {
+      return htable.checkAndMutate(byteBufferToByteArray(row), byteBufferToByteArray(family),
+          byteBufferToByteArray(qualifier), compareOpFromThrift(compareOp),
+          byteBufferToByteArray(value), rowMutationsFromThrift(rowMutations));
+    } catch (IOException e) {
+      throw getTIOError(e);
+    }
+  }
 
   @Override
   public boolean checkAndDelete(ByteBuffer table, ByteBuffer row, ByteBuffer family,
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftUtilities.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftUtilities.java
index 3251d13..d513d66 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftUtilities.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftUtilities.java
@@ -44,6 +44,7 @@ import org.apache.hadoop.hbase.client.Put;
 import org.apache.hadoop.hbase.client.Result;
 import org.apache.hadoop.hbase.client.RowMutations;
 import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.filter.CompareFilter.CompareOp;
 import org.apache.hadoop.hbase.filter.ParseFilter;
 import org.apache.hadoop.hbase.security.visibility.Authorizations;
 import org.apache.hadoop.hbase.security.visibility.CellVisibility;
@@ -51,6 +52,7 @@ import org.apache.hadoop.hbase.thrift2.generated.TAppend;
 import org.apache.hadoop.hbase.thrift2.generated.TColumn;
 import org.apache.hadoop.hbase.thrift2.generated.TColumnIncrement;
 import org.apache.hadoop.hbase.thrift2.generated.TColumnValue;
+import org.apache.hadoop.hbase.thrift2.generated.TCompareOp;
 import org.apache.hadoop.hbase.thrift2.generated.TDelete;
 import org.apache.hadoop.hbase.thrift2.generated.TDeleteType;
 import org.apache.hadoop.hbase.thrift2.generated.TDurability;
@@ -531,4 +533,17 @@ public class ThriftUtilities {
       default: return null;
     }
   }
+
+  public static CompareOp compareOpFromThrift(TCompareOp tCompareOp) {
+    switch (tCompareOp.getValue()) {
+      case 0: return CompareOp.LESS;
+      case 1: return CompareOp.LESS_OR_EQUAL;
+      case 2: return CompareOp.EQUAL;
+      case 3: return CompareOp.NOT_EQUAL;
+      case 4: return CompareOp.GREATER_OR_EQUAL;
+      case 5: return CompareOp.GREATER;
+      case 6: return CompareOp.NO_OP;
+      default: return null;
+    }
+  }
 }
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TAppend.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TAppend.java
index ab5b295..65def3c 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TAppend.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TAppend.java
@@ -34,7 +34,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 @SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TAppend implements org.apache.thrift.TBase<TAppend, TAppend._Fields>, java.io.Serializable, Cloneable, Comparable<TAppend> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TAppend");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TAuthorization.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TAuthorization.java
index a7eedd0..269ef7d 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TAuthorization.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TAuthorization.java
@@ -34,7 +34,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 @SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TAuthorization implements org.apache.thrift.TBase<TAuthorization, TAuthorization._Fields>, java.io.Serializable, Cloneable, Comparable<TAuthorization> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TAuthorization");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TCellVisibility.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TCellVisibility.java
index 5812b94..70f4136 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TCellVisibility.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TCellVisibility.java
@@ -34,7 +34,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 @SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TCellVisibility implements org.apache.thrift.TBase<TCellVisibility, TCellVisibility._Fields>, java.io.Serializable, Cloneable, Comparable<TCellVisibility> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TCellVisibility");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TColumn.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TColumn.java
index 05d50ec..b6a5db8 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TColumn.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TColumn.java
@@ -39,7 +39,7 @@ import org.slf4j.LoggerFactory;
  * in a HBase table by column family and optionally
  * a column qualifier and timestamp
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TColumn implements org.apache.thrift.TBase<TColumn, TColumn._Fields>, java.io.Serializable, Cloneable, Comparable<TColumn> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TColumn");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TColumnIncrement.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TColumnIncrement.java
index 4436b8f..aaae0cc 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TColumnIncrement.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TColumnIncrement.java
@@ -37,7 +37,7 @@ import org.slf4j.LoggerFactory;
 /**
  * Represents a single cell and the amount to increment it by
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TColumnIncrement implements org.apache.thrift.TBase<TColumnIncrement, TColumnIncrement._Fields>, java.io.Serializable, Cloneable, Comparable<TColumnIncrement> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TColumnIncrement");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TColumnValue.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TColumnValue.java
index 763c5a1..81be1c1 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TColumnValue.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TColumnValue.java
@@ -37,7 +37,7 @@ import org.slf4j.LoggerFactory;
 /**
  * Represents a single cell and its value.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TColumnValue implements org.apache.thrift.TBase<TColumnValue, TColumnValue._Fields>, java.io.Serializable, Cloneable, Comparable<TColumnValue> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TColumnValue");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TCompareOp.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TCompareOp.java
new file mode 100644
index 0000000..efbba09
--- /dev/null
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TCompareOp.java
@@ -0,0 +1,64 @@
+/**
+ * Autogenerated by Thrift Compiler (0.9.3)
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ *  @generated
+ */
+package org.apache.hadoop.hbase.thrift2.generated;
+
+
+import java.util.Map;
+import java.util.HashMap;
+import org.apache.thrift.TEnum;
+
+/**
+ * Thrift wrapper around
+ * org.apache.hadoop.hbase.filter.CompareFilter$CompareOp.
+ */
+public enum TCompareOp implements org.apache.thrift.TEnum {
+  LESS(0),
+  LESS_OR_EQUAL(1),
+  EQUAL(2),
+  NOT_EQUAL(3),
+  GREATER_OR_EQUAL(4),
+  GREATER(5),
+  NO_OP(6);
+
+  private final int value;
+
+  private TCompareOp(int value) {
+    this.value = value;
+  }
+
+  /**
+   * Get the integer value of this enum value, as defined in the Thrift IDL.
+   */
+  public int getValue() {
+    return value;
+  }
+
+  /**
+   * Find a the enum type by its integer value, as defined in the Thrift IDL.
+   * @return null if the value is not found.
+   */
+  public static TCompareOp findByValue(int value) { 
+    switch (value) {
+      case 0:
+        return LESS;
+      case 1:
+        return LESS_OR_EQUAL;
+      case 2:
+        return EQUAL;
+      case 3:
+        return NOT_EQUAL;
+      case 4:
+        return GREATER_OR_EQUAL;
+      case 5:
+        return GREATER;
+      case 6:
+        return NO_OP;
+      default:
+        return null;
+    }
+  }
+}
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TDelete.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TDelete.java
index a57afde..6a3cce2 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TDelete.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TDelete.java
@@ -60,7 +60,7 @@ import org.slf4j.LoggerFactory;
  * by changing the durability. If you don't provide durability, it defaults to
  * column family's default setting for durability.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TDelete implements org.apache.thrift.TBase<TDelete, TDelete._Fields>, java.io.Serializable, Cloneable, Comparable<TDelete> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TDelete");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TGet.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TGet.java
index 9ed1799..d498aa6 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TGet.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TGet.java
@@ -47,7 +47,7 @@ import org.slf4j.LoggerFactory;
  * If you specify a time range and a timestamp the range is ignored.
  * Timestamps on TColumns are ignored.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TGet implements org.apache.thrift.TBase<TGet, TGet._Fields>, java.io.Serializable, Cloneable, Comparable<TGet> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TGet");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/THBaseService.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/THBaseService.java
index cbb54fd..a2e5f90 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/THBaseService.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/THBaseService.java
@@ -34,7 +34,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 @SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class THBaseService {
 
   public interface Iface {
@@ -247,6 +247,29 @@ public class THBaseService {
      */
     public List<THRegionLocation> getAllRegionLocations(ByteBuffer table) throws TIOError, org.apache.thrift.TException;
 
+    /**
+     * Atomically checks if a row/family/qualifier value matches the expected
+     * value. If it does, it mutates the row.
+     * 
+     * @return true if the row was mutated, false otherwise
+     * 
+     * @param table to check in and delete from
+     * 
+     * @param row row to check
+     * 
+     * @param family column family to check
+     * 
+     * @param qualifier column qualifier to check
+     * 
+     * @param compareOp comparison to make on the value
+     * 
+     * @param value the expected value to be compared against, if not provided the
+     * check is for the non-existence of the column in question
+     * 
+     * @param rowMutations row mutations to execute if the value matches
+     */
+    public boolean checkAndMutate(ByteBuffer table, ByteBuffer row, ByteBuffer family, ByteBuffer qualifier, TCompareOp compareOp, ByteBuffer value, TRowMutations rowMutations) throws TIOError, org.apache.thrift.TException;
+
   }
 
   public interface AsyncIface {
@@ -287,6 +310,8 @@ public class THBaseService {
 
     public void getAllRegionLocations(ByteBuffer table, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;
 
+    public void checkAndMutate(ByteBuffer table, ByteBuffer row, ByteBuffer family, ByteBuffer qualifier, TCompareOp compareOp, ByteBuffer value, TRowMutations rowMutations, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;
+
   }
 
   public static class Client extends org.apache.thrift.TServiceClient implements Iface {
@@ -794,6 +819,38 @@ public class THBaseService {
       throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "getAllRegionLocations failed: unknown result");
     }
 
+    public boolean checkAndMutate(ByteBuffer table, ByteBuffer row, ByteBuffer family, ByteBuffer qualifier, TCompareOp compareOp, ByteBuffer value, TRowMutations rowMutations) throws TIOError, org.apache.thrift.TException
+    {
+      send_checkAndMutate(table, row, family, qualifier, compareOp, value, rowMutations);
+      return recv_checkAndMutate();
+    }
+
+    public void send_checkAndMutate(ByteBuffer table, ByteBuffer row, ByteBuffer family, ByteBuffer qualifier, TCompareOp compareOp, ByteBuffer value, TRowMutations rowMutations) throws org.apache.thrift.TException
+    {
+      checkAndMutate_args args = new checkAndMutate_args();
+      args.setTable(table);
+      args.setRow(row);
+      args.setFamily(family);
+      args.setQualifier(qualifier);
+      args.setCompareOp(compareOp);
+      args.setValue(value);
+      args.setRowMutations(rowMutations);
+      sendBase("checkAndMutate", args);
+    }
+
+    public boolean recv_checkAndMutate() throws TIOError, org.apache.thrift.TException
+    {
+      checkAndMutate_result result = new checkAndMutate_result();
+      receiveBase(result, "checkAndMutate");
+      if (result.isSetSuccess()) {
+        return result.success;
+      }
+      if (result.io != null) {
+        throw result.io;
+      }
+      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "checkAndMutate failed: unknown result");
+    }
+
   }
   public static class AsyncClient extends org.apache.thrift.async.TAsyncClient implements AsyncIface {
     public static class Factory implements org.apache.thrift.async.TAsyncClientFactory<AsyncClient> {
@@ -1466,6 +1523,56 @@ public class THBaseService {
       }
     }
 
+    public void checkAndMutate(ByteBuffer table, ByteBuffer row, ByteBuffer family, ByteBuffer qualifier, TCompareOp compareOp, ByteBuffer value, TRowMutations rowMutations, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
+      checkReady();
+      checkAndMutate_call method_call = new checkAndMutate_call(table, row, family, qualifier, compareOp, value, rowMutations, resultHandler, this, ___protocolFactory, ___transport);
+      this.___currentMethod = method_call;
+      ___manager.call(method_call);
+    }
+
+    public static class checkAndMutate_call extends org.apache.thrift.async.TAsyncMethodCall {
+      private ByteBuffer table;
+      private ByteBuffer row;
+      private ByteBuffer family;
+      private ByteBuffer qualifier;
+      private TCompareOp compareOp;
+      private ByteBuffer value;
+      private TRowMutations rowMutations;
+      public checkAndMutate_call(ByteBuffer table, ByteBuffer row, ByteBuffer family, ByteBuffer qualifier, TCompareOp compareOp, ByteBuffer value, TRowMutations rowMutations, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
+        super(client, protocolFactory, transport, resultHandler, false);
+        this.table = table;
+        this.row = row;
+        this.family = family;
+        this.qualifier = qualifier;
+        this.compareOp = compareOp;
+        this.value = value;
+        this.rowMutations = rowMutations;
+      }
+
+      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
+        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("checkAndMutate", org.apache.thrift.protocol.TMessageType.CALL, 0));
+        checkAndMutate_args args = new checkAndMutate_args();
+        args.setTable(table);
+        args.setRow(row);
+        args.setFamily(family);
+        args.setQualifier(qualifier);
+        args.setCompareOp(compareOp);
+        args.setValue(value);
+        args.setRowMutations(rowMutations);
+        args.write(prot);
+        prot.writeMessageEnd();
+      }
+
+      public boolean getResult() throws TIOError, org.apache.thrift.TException {
+        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
+          throw new IllegalStateException("Method call not finished!");
+        }
+        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
+        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
+        return (new Client(prot)).recv_checkAndMutate();
+      }
+    }
+
   }
 
   public static class Processor<I extends Iface> extends org.apache.thrift.TBaseProcessor<I> implements org.apache.thrift.TProcessor {
@@ -1497,6 +1604,7 @@ public class THBaseService {
       processMap.put("getScannerResults", new getScannerResults());
       processMap.put("getRegionLocation", new getRegionLocation());
       processMap.put("getAllRegionLocations", new getAllRegionLocations());
+      processMap.put("checkAndMutate", new checkAndMutate());
       return processMap;
     }
 
@@ -1940,6 +2048,31 @@ public class THBaseService {
       }
     }
 
+    public static class checkAndMutate<I extends Iface> extends org.apache.thrift.ProcessFunction<I, checkAndMutate_args> {
+      public checkAndMutate() {
+        super("checkAndMutate");
+      }
+
+      public checkAndMutate_args getEmptyArgsInstance() {
+        return new checkAndMutate_args();
+      }
+
+      protected boolean isOneway() {
+        return false;
+      }
+
+      public checkAndMutate_result getResult(I iface, checkAndMutate_args args) throws org.apache.thrift.TException {
+        checkAndMutate_result result = new checkAndMutate_result();
+        try {
+          result.success = iface.checkAndMutate(args.table, args.row, args.family, args.qualifier, args.compareOp, args.value, args.rowMutations);
+          result.setSuccessIsSet(true);
+        } catch (TIOError io) {
+          result.io = io;
+        }
+        return result;
+      }
+    }
+
   }
 
   public static class AsyncProcessor<I extends AsyncIface> extends org.apache.thrift.TBaseAsyncProcessor<I> {
@@ -1971,6 +2104,7 @@ public class THBaseService {
       processMap.put("getScannerResults", new getScannerResults());
       processMap.put("getRegionLocation", new getRegionLocation());
       processMap.put("getAllRegionLocations", new getAllRegionLocations());
+      processMap.put("checkAndMutate", new checkAndMutate());
       return processMap;
     }
 
@@ -3009,6 +3143,64 @@ public class THBaseService {
       }
     }
 
+    public static class checkAndMutate<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, checkAndMutate_args, Boolean> {
+      public checkAndMutate() {
+        super("checkAndMutate");
+      }
+
+      public checkAndMutate_args getEmptyArgsInstance() {
+        return new checkAndMutate_args();
+      }
+
+      public AsyncMethodCallback<Boolean> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
+        final org.apache.thrift.AsyncProcessFunction fcall = this;
+        return new AsyncMethodCallback<Boolean>() { 
+          public void onComplete(Boolean o) {
+            checkAndMutate_result result = new checkAndMutate_result();
+            result.success = o;
+            result.setSuccessIsSet(true);
+            try {
+              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
+              return;
+            } catch (Exception e) {
+              LOGGER.error("Exception writing to internal frame buffer", e);
+            }
+            fb.close();
+          }
+          public void onError(Exception e) {
+            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
+            org.apache.thrift.TBase msg;
+            checkAndMutate_result result = new checkAndMutate_result();
+            if (e instanceof TIOError) {
+                        result.io = (TIOError) e;
+                        result.setIoIsSet(true);
+                        msg = result;
+            }
+             else 
+            {
+              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
+              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
+            }
+            try {
+              fcall.sendResponse(fb,msg,msgType,seqid);
+              return;
+            } catch (Exception ex) {
+              LOGGER.error("Exception writing to internal frame buffer", ex);
+            }
+            fb.close();
+          }
+        };
+      }
+
+      protected boolean isOneway() {
+        return false;
+      }
+
+      public void start(I iface, checkAndMutate_args args, org.apache.thrift.async.AsyncMethodCallback<Boolean> resultHandler) throws TException {
+        iface.checkAndMutate(args.table, args.row, args.family, args.qualifier, args.compareOp, args.value, args.rowMutations,resultHandler);
+      }
+    }
+
   }
 
   public static class exists_args implements org.apache.thrift.TBase<exists_args, exists_args._Fields>, java.io.Serializable, Cloneable, Comparable<exists_args>   {
@@ -21434,4 +21626,1590 @@ public class THBaseService {
 
   }
 
+  public static class checkAndMutate_args implements org.apache.thrift.TBase<checkAndMutate_args, checkAndMutate_args._Fields>, java.io.Serializable, Cloneable, Comparable<checkAndMutate_args>   {
+    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("checkAndMutate_args");
+
+    private static final org.apache.thrift.protocol.TField TABLE_FIELD_DESC = new org.apache.thrift.protocol.TField("table", org.apache.thrift.protocol.TType.STRING, (short)1);
+    private static final org.apache.thrift.protocol.TField ROW_FIELD_DESC = new org.apache.thrift.protocol.TField("row", org.apache.thrift.protocol.TType.STRING, (short)2);
+    private static final org.apache.thrift.protocol.TField FAMILY_FIELD_DESC = new org.apache.thrift.protocol.TField("family", org.apache.thrift.protocol.TType.STRING, (short)3);
+    private static final org.apache.thrift.protocol.TField QUALIFIER_FIELD_DESC = new org.apache.thrift.protocol.TField("qualifier", org.apache.thrift.protocol.TType.STRING, (short)4);
+    private static final org.apache.thrift.protocol.TField COMPARE_OP_FIELD_DESC = new org.apache.thrift.protocol.TField("compareOp", org.apache.thrift.protocol.TType.I32, (short)5);
+    private static final org.apache.thrift.protocol.TField VALUE_FIELD_DESC = new org.apache.thrift.protocol.TField("value", org.apache.thrift.protocol.TType.STRING, (short)6);
+    private static final org.apache.thrift.protocol.TField ROW_MUTATIONS_FIELD_DESC = new org.apache.thrift.protocol.TField("rowMutations", org.apache.thrift.protocol.TType.STRUCT, (short)7);
+
+    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
+    static {
+      schemes.put(StandardScheme.class, new checkAndMutate_argsStandardSchemeFactory());
+      schemes.put(TupleScheme.class, new checkAndMutate_argsTupleSchemeFactory());
+    }
+
+    /**
+     * to check in and delete from
+     */
+    public ByteBuffer table; // required
+    /**
+     * row to check
+     */
+    public ByteBuffer row; // required
+    /**
+     * column family to check
+     */
+    public ByteBuffer family; // required
+    /**
+     * column qualifier to check
+     */
+    public ByteBuffer qualifier; // required
+    /**
+     * comparison to make on the value
+     * 
+     * @see TCompareOp
+     */
+    public TCompareOp compareOp; // required
+    /**
+     * the expected value to be compared against, if not provided the
+     * check is for the non-existence of the column in question
+     */
+    public ByteBuffer value; // required
+    /**
+     * row mutations to execute if the value matches
+     */
+    public TRowMutations rowMutations; // required
+
+    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
+      /**
+       * to check in and delete from
+       */
+      TABLE((short)1, "table"),
+      /**
+       * row to check
+       */
+      ROW((short)2, "row"),
+      /**
+       * column family to check
+       */
+      FAMILY((short)3, "family"),
+      /**
+       * column qualifier to check
+       */
+      QUALIFIER((short)4, "qualifier"),
+      /**
+       * comparison to make on the value
+       * 
+       * @see TCompareOp
+       */
+      COMPARE_OP((short)5, "compareOp"),
+      /**
+       * the expected value to be compared against, if not provided the
+       * check is for the non-existence of the column in question
+       */
+      VALUE((short)6, "value"),
+      /**
+       * row mutations to execute if the value matches
+       */
+      ROW_MUTATIONS((short)7, "rowMutations");
+
+      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+      static {
+        for (_Fields field : EnumSet.allOf(_Fields.class)) {
+          byName.put(field.getFieldName(), field);
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, or null if its not found.
+       */
+      public static _Fields findByThriftId(int fieldId) {
+        switch(fieldId) {
+          case 1: // TABLE
+            return TABLE;
+          case 2: // ROW
+            return ROW;
+          case 3: // FAMILY
+            return FAMILY;
+          case 4: // QUALIFIER
+            return QUALIFIER;
+          case 5: // COMPARE_OP
+            return COMPARE_OP;
+          case 6: // VALUE
+            return VALUE;
+          case 7: // ROW_MUTATIONS
+            return ROW_MUTATIONS;
+          default:
+            return null;
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, throwing an exception
+       * if it is not found.
+       */
+      public static _Fields findByThriftIdOrThrow(int fieldId) {
+        _Fields fields = findByThriftId(fieldId);
+        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+        return fields;
+      }
+
+      /**
+       * Find the _Fields constant that matches name, or null if its not found.
+       */
+      public static _Fields findByName(String name) {
+        return byName.get(name);
+      }
+
+      private final short _thriftId;
+      private final String _fieldName;
+
+      _Fields(short thriftId, String fieldName) {
+        _thriftId = thriftId;
+        _fieldName = fieldName;
+      }
+
+      public short getThriftFieldId() {
+        return _thriftId;
+      }
+
+      public String getFieldName() {
+        return _fieldName;
+      }
+    }
+
+    // isset id assignments
+    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
+    static {
+      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
+      tmpMap.put(_Fields.TABLE, new org.apache.thrift.meta_data.FieldMetaData("table", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING          , true)));
+      tmpMap.put(_Fields.ROW, new org.apache.thrift.meta_data.FieldMetaData("row", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING          , true)));
+      tmpMap.put(_Fields.FAMILY, new org.apache.thrift.meta_data.FieldMetaData("family", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING          , true)));
+      tmpMap.put(_Fields.QUALIFIER, new org.apache.thrift.meta_data.FieldMetaData("qualifier", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING          , true)));
+      tmpMap.put(_Fields.COMPARE_OP, new org.apache.thrift.meta_data.FieldMetaData("compareOp", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+          new org.apache.thrift.meta_data.EnumMetaData(org.apache.thrift.protocol.TType.ENUM, TCompareOp.class)));
+      tmpMap.put(_Fields.VALUE, new org.apache.thrift.meta_data.FieldMetaData("value", org.apache.thrift.TFieldRequirementType.DEFAULT, 
+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING          , true)));
+      tmpMap.put(_Fields.ROW_MUTATIONS, new org.apache.thrift.meta_data.FieldMetaData("rowMutations", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, TRowMutations.class)));
+      metaDataMap = Collections.unmodifiableMap(tmpMap);
+      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(checkAndMutate_args.class, metaDataMap);
+    }
+
+    public checkAndMutate_args() {
+    }
+
+    public checkAndMutate_args(
+      ByteBuffer table,
+      ByteBuffer row,
+      ByteBuffer family,
+      ByteBuffer qualifier,
+      TCompareOp compareOp,
+      ByteBuffer value,
+      TRowMutations rowMutations)
+    {
+      this();
+      this.table = org.apache.thrift.TBaseHelper.copyBinary(table);
+      this.row = org.apache.thrift.TBaseHelper.copyBinary(row);
+      this.family = org.apache.thrift.TBaseHelper.copyBinary(family);
+      this.qualifier = org.apache.thrift.TBaseHelper.copyBinary(qualifier);
+      this.compareOp = compareOp;
+      this.value = org.apache.thrift.TBaseHelper.copyBinary(value);
+      this.rowMutations = rowMutations;
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public checkAndMutate_args(checkAndMutate_args other) {
+      if (other.isSetTable()) {
+        this.table = org.apache.thrift.TBaseHelper.copyBinary(other.table);
+      }
+      if (other.isSetRow()) {
+        this.row = org.apache.thrift.TBaseHelper.copyBinary(other.row);
+      }
+      if (other.isSetFamily()) {
+        this.family = org.apache.thrift.TBaseHelper.copyBinary(other.family);
+      }
+      if (other.isSetQualifier()) {
+        this.qualifier = org.apache.thrift.TBaseHelper.copyBinary(other.qualifier);
+      }
+      if (other.isSetCompareOp()) {
+        this.compareOp = other.compareOp;
+      }
+      if (other.isSetValue()) {
+        this.value = org.apache.thrift.TBaseHelper.copyBinary(other.value);
+      }
+      if (other.isSetRowMutations()) {
+        this.rowMutations = new TRowMutations(other.rowMutations);
+      }
+    }
+
+    public checkAndMutate_args deepCopy() {
+      return new checkAndMutate_args(this);
+    }
+
+    @Override
+    public void clear() {
+      this.table = null;
+      this.row = null;
+      this.family = null;
+      this.qualifier = null;
+      this.compareOp = null;
+      this.value = null;
+      this.rowMutations = null;
+    }
+
+    /**
+     * to check in and delete from
+     */
+    public byte[] getTable() {
+      setTable(org.apache.thrift.TBaseHelper.rightSize(table));
+      return table == null ? null : table.array();
+    }
+
+    public ByteBuffer bufferForTable() {
+      return org.apache.thrift.TBaseHelper.copyBinary(table);
+    }
+
+    /**
+     * to check in and delete from
+     */
+    public checkAndMutate_args setTable(byte[] table) {
+      this.table = table == null ? (ByteBuffer)null : ByteBuffer.wrap(Arrays.copyOf(table, table.length));
+      return this;
+    }
+
+    public checkAndMutate_args setTable(ByteBuffer table) {
+      this.table = org.apache.thrift.TBaseHelper.copyBinary(table);
+      return this;
+    }
+
+    public void unsetTable() {
+      this.table = null;
+    }
+
+    /** Returns true if field table is set (has been assigned a value) and false otherwise */
+    public boolean isSetTable() {
+      return this.table != null;
+    }
+
+    public void setTableIsSet(boolean value) {
+      if (!value) {
+        this.table = null;
+      }
+    }
+
+    /**
+     * row to check
+     */
+    public byte[] getRow() {
+      setRow(org.apache.thrift.TBaseHelper.rightSize(row));
+      return row == null ? null : row.array();
+    }
+
+    public ByteBuffer bufferForRow() {
+      return org.apache.thrift.TBaseHelper.copyBinary(row);
+    }
+
+    /**
+     * row to check
+     */
+    public checkAndMutate_args setRow(byte[] row) {
+      this.row = row == null ? (ByteBuffer)null : ByteBuffer.wrap(Arrays.copyOf(row, row.length));
+      return this;
+    }
+
+    public checkAndMutate_args setRow(ByteBuffer row) {
+      this.row = org.apache.thrift.TBaseHelper.copyBinary(row);
+      return this;
+    }
+
+    public void unsetRow() {
+      this.row = null;
+    }
+
+    /** Returns true if field row is set (has been assigned a value) and false otherwise */
+    public boolean isSetRow() {
+      return this.row != null;
+    }
+
+    public void setRowIsSet(boolean value) {
+      if (!value) {
+        this.row = null;
+      }
+    }
+
+    /**
+     * column family to check
+     */
+    public byte[] getFamily() {
+      setFamily(org.apache.thrift.TBaseHelper.rightSize(family));
+      return family == null ? null : family.array();
+    }
+
+    public ByteBuffer bufferForFamily() {
+      return org.apache.thrift.TBaseHelper.copyBinary(family);
+    }
+
+    /**
+     * column family to check
+     */
+    public checkAndMutate_args setFamily(byte[] family) {
+      this.family = family == null ? (ByteBuffer)null : ByteBuffer.wrap(Arrays.copyOf(family, family.length));
+      return this;
+    }
+
+    public checkAndMutate_args setFamily(ByteBuffer family) {
+      this.family = org.apache.thrift.TBaseHelper.copyBinary(family);
+      return this;
+    }
+
+    public void unsetFamily() {
+      this.family = null;
+    }
+
+    /** Returns true if field family is set (has been assigned a value) and false otherwise */
+    public boolean isSetFamily() {
+      return this.family != null;
+    }
+
+    public void setFamilyIsSet(boolean value) {
+      if (!value) {
+        this.family = null;
+      }
+    }
+
+    /**
+     * column qualifier to check
+     */
+    public byte[] getQualifier() {
+      setQualifier(org.apache.thrift.TBaseHelper.rightSize(qualifier));
+      return qualifier == null ? null : qualifier.array();
+    }
+
+    public ByteBuffer bufferForQualifier() {
+      return org.apache.thrift.TBaseHelper.copyBinary(qualifier);
+    }
+
+    /**
+     * column qualifier to check
+     */
+    public checkAndMutate_args setQualifier(byte[] qualifier) {
+      this.qualifier = qualifier == null ? (ByteBuffer)null : ByteBuffer.wrap(Arrays.copyOf(qualifier, qualifier.length));
+      return this;
+    }
+
+    public checkAndMutate_args setQualifier(ByteBuffer qualifier) {
+      this.qualifier = org.apache.thrift.TBaseHelper.copyBinary(qualifier);
+      return this;
+    }
+
+    public void unsetQualifier() {
+      this.qualifier = null;
+    }
+
+    /** Returns true if field qualifier is set (has been assigned a value) and false otherwise */
+    public boolean isSetQualifier() {
+      return this.qualifier != null;
+    }
+
+    public void setQualifierIsSet(boolean value) {
+      if (!value) {
+        this.qualifier = null;
+      }
+    }
+
+    /**
+     * comparison to make on the value
+     * 
+     * @see TCompareOp
+     */
+    public TCompareOp getCompareOp() {
+      return this.compareOp;
+    }
+
+    /**
+     * comparison to make on the value
+     * 
+     * @see TCompareOp
+     */
+    public checkAndMutate_args setCompareOp(TCompareOp compareOp) {
+      this.compareOp = compareOp;
+      return this;
+    }
+
+    public void unsetCompareOp() {
+      this.compareOp = null;
+    }
+
+    /** Returns true if field compareOp is set (has been assigned a value) and false otherwise */
+    public boolean isSetCompareOp() {
+      return this.compareOp != null;
+    }
+
+    public void setCompareOpIsSet(boolean value) {
+      if (!value) {
+        this.compareOp = null;
+      }
+    }
+
+    /**
+     * the expected value to be compared against, if not provided the
+     * check is for the non-existence of the column in question
+     */
+    public byte[] getValue() {
+      setValue(org.apache.thrift.TBaseHelper.rightSize(value));
+      return value == null ? null : value.array();
+    }
+
+    public ByteBuffer bufferForValue() {
+      return org.apache.thrift.TBaseHelper.copyBinary(value);
+    }
+
+    /**
+     * the expected value to be compared against, if not provided the
+     * check is for the non-existence of the column in question
+     */
+    public checkAndMutate_args setValue(byte[] value) {
+      this.value = value == null ? (ByteBuffer)null : ByteBuffer.wrap(Arrays.copyOf(value, value.length));
+      return this;
+    }
+
+    public checkAndMutate_args setValue(ByteBuffer value) {
+      this.value = org.apache.thrift.TBaseHelper.copyBinary(value);
+      return this;
+    }
+
+    public void unsetValue() {
+      this.value = null;
+    }
+
+    /** Returns true if field value is set (has been assigned a value) and false otherwise */
+    public boolean isSetValue() {
+      return this.value != null;
+    }
+
+    public void setValueIsSet(boolean value) {
+      if (!value) {
+        this.value = null;
+      }
+    }
+
+    /**
+     * row mutations to execute if the value matches
+     */
+    public TRowMutations getRowMutations() {
+      return this.rowMutations;
+    }
+
+    /**
+     * row mutations to execute if the value matches
+     */
+    public checkAndMutate_args setRowMutations(TRowMutations rowMutations) {
+      this.rowMutations = rowMutations;
+      return this;
+    }
+
+    public void unsetRowMutations() {
+      this.rowMutations = null;
+    }
+
+    /** Returns true if field rowMutations is set (has been assigned a value) and false otherwise */
+    public boolean isSetRowMutations() {
+      return this.rowMutations != null;
+    }
+
+    public void setRowMutationsIsSet(boolean value) {
+      if (!value) {
+        this.rowMutations = null;
+      }
+    }
+
+    public void setFieldValue(_Fields field, Object value) {
+      switch (field) {
+      case TABLE:
+        if (value == null) {
+          unsetTable();
+        } else {
+          setTable((ByteBuffer)value);
+        }
+        break;
+
+      case ROW:
+        if (value == null) {
+          unsetRow();
+        } else {
+          setRow((ByteBuffer)value);
+        }
+        break;
+
+      case FAMILY:
+        if (value == null) {
+          unsetFamily();
+        } else {
+          setFamily((ByteBuffer)value);
+        }
+        break;
+
+      case QUALIFIER:
+        if (value == null) {
+          unsetQualifier();
+        } else {
+          setQualifier((ByteBuffer)value);
+        }
+        break;
+
+      case COMPARE_OP:
+        if (value == null) {
+          unsetCompareOp();
+        } else {
+          setCompareOp((TCompareOp)value);
+        }
+        break;
+
+      case VALUE:
+        if (value == null) {
+          unsetValue();
+        } else {
+          setValue((ByteBuffer)value);
+        }
+        break;
+
+      case ROW_MUTATIONS:
+        if (value == null) {
+          unsetRowMutations();
+        } else {
+          setRowMutations((TRowMutations)value);
+        }
+        break;
+
+      }
+    }
+
+    public Object getFieldValue(_Fields field) {
+      switch (field) {
+      case TABLE:
+        return getTable();
+
+      case ROW:
+        return getRow();
+
+      case FAMILY:
+        return getFamily();
+
+      case QUALIFIER:
+        return getQualifier();
+
+      case COMPARE_OP:
+        return getCompareOp();
+
+      case VALUE:
+        return getValue();
+
+      case ROW_MUTATIONS:
+        return getRowMutations();
+
+      }
+      throw new IllegalStateException();
+    }
+
+    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
+    public boolean isSet(_Fields field) {
+      if (field == null) {
+        throw new IllegalArgumentException();
+      }
+
+      switch (field) {
+      case TABLE:
+        return isSetTable();
+      case ROW:
+        return isSetRow();
+      case FAMILY:
+        return isSetFamily();
+      case QUALIFIER:
+        return isSetQualifier();
+      case COMPARE_OP:
+        return isSetCompareOp();
+      case VALUE:
+        return isSetValue();
+      case ROW_MUTATIONS:
+        return isSetRowMutations();
+      }
+      throw new IllegalStateException();
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof checkAndMutate_args)
+        return this.equals((checkAndMutate_args)that);
+      return false;
+    }
+
+    public boolean equals(checkAndMutate_args that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_table = true && this.isSetTable();
+      boolean that_present_table = true && that.isSetTable();
+      if (this_present_table || that_present_table) {
+        if (!(this_present_table && that_present_table))
+          return false;
+        if (!this.table.equals(that.table))
+          return false;
+      }
+
+      boolean this_present_row = true && this.isSetRow();
+      boolean that_present_row = true && that.isSetRow();
+      if (this_present_row || that_present_row) {
+        if (!(this_present_row && that_present_row))
+          return false;
+        if (!this.row.equals(that.row))
+          return false;
+      }
+
+      boolean this_present_family = true && this.isSetFamily();
+      boolean that_present_family = true && that.isSetFamily();
+      if (this_present_family || that_present_family) {
+        if (!(this_present_family && that_present_family))
+          return false;
+        if (!this.family.equals(that.family))
+          return false;
+      }
+
+      boolean this_present_qualifier = true && this.isSetQualifier();
+      boolean that_present_qualifier = true && that.isSetQualifier();
+      if (this_present_qualifier || that_present_qualifier) {
+        if (!(this_present_qualifier && that_present_qualifier))
+          return false;
+        if (!this.qualifier.equals(that.qualifier))
+          return false;
+      }
+
+      boolean this_present_compareOp = true && this.isSetCompareOp();
+      boolean that_present_compareOp = true && that.isSetCompareOp();
+      if (this_present_compareOp || that_present_compareOp) {
+        if (!(this_present_compareOp && that_present_compareOp))
+          return false;
+        if (!this.compareOp.equals(that.compareOp))
+          return false;
+      }
+
+      boolean this_present_value = true && this.isSetValue();
+      boolean that_present_value = true && that.isSetValue();
+      if (this_present_value || that_present_value) {
+        if (!(this_present_value && that_present_value))
+          return false;
+        if (!this.value.equals(that.value))
+          return false;
+      }
+
+      boolean this_present_rowMutations = true && this.isSetRowMutations();
+      boolean that_present_rowMutations = true && that.isSetRowMutations();
+      if (this_present_rowMutations || that_present_rowMutations) {
+        if (!(this_present_rowMutations && that_present_rowMutations))
+          return false;
+        if (!this.rowMutations.equals(that.rowMutations))
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      List<Object> list = new ArrayList<Object>();
+
+      boolean present_table = true && (isSetTable());
+      list.add(present_table);
+      if (present_table)
+        list.add(table);
+
+      boolean present_row = true && (isSetRow());
+      list.add(present_row);
+      if (present_row)
+        list.add(row);
+
+      boolean present_family = true && (isSetFamily());
+      list.add(present_family);
+      if (present_family)
+        list.add(family);
+
+      boolean present_qualifier = true && (isSetQualifier());
+      list.add(present_qualifier);
+      if (present_qualifier)
+        list.add(qualifier);
+
+      boolean present_compareOp = true && (isSetCompareOp());
+      list.add(present_compareOp);
+      if (present_compareOp)
+        list.add(compareOp.getValue());
+
+      boolean present_value = true && (isSetValue());
+      list.add(present_value);
+      if (present_value)
+        list.add(value);
+
+      boolean present_rowMutations = true && (isSetRowMutations());
+      list.add(present_rowMutations);
+      if (present_rowMutations)
+        list.add(rowMutations);
+
+      return list.hashCode();
+    }
+
+    @Override
+    public int compareTo(checkAndMutate_args other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+
+      lastComparison = Boolean.valueOf(isSetTable()).compareTo(other.isSetTable());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetTable()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.table, other.table);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetRow()).compareTo(other.isSetRow());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetRow()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.row, other.row);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetFamily()).compareTo(other.isSetFamily());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetFamily()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.family, other.family);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetQualifier()).compareTo(other.isSetQualifier());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetQualifier()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.qualifier, other.qualifier);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetCompareOp()).compareTo(other.isSetCompareOp());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetCompareOp()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.compareOp, other.compareOp);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetValue()).compareTo(other.isSetValue());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetValue()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.value, other.value);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetRowMutations()).compareTo(other.isSetRowMutations());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetRowMutations()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.rowMutations, other.rowMutations);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      return 0;
+    }
+
+    public _Fields fieldForId(int fieldId) {
+      return _Fields.findByThriftId(fieldId);
+    }
+
+    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
+      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
+    }
+
+    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
+      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("checkAndMutate_args(");
+      boolean first = true;
+
+      sb.append("table:");
+      if (this.table == null) {
+        sb.append("null");
+      } else {
+        org.apache.thrift.TBaseHelper.toString(this.table, sb);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("row:");
+      if (this.row == null) {
+        sb.append("null");
+      } else {
+        org.apache.thrift.TBaseHelper.toString(this.row, sb);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("family:");
+      if (this.family == null) {
+        sb.append("null");
+      } else {
+        org.apache.thrift.TBaseHelper.toString(this.family, sb);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("qualifier:");
+      if (this.qualifier == null) {
+        sb.append("null");
+      } else {
+        org.apache.thrift.TBaseHelper.toString(this.qualifier, sb);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("compareOp:");
+      if (this.compareOp == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.compareOp);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("value:");
+      if (this.value == null) {
+        sb.append("null");
+      } else {
+        org.apache.thrift.TBaseHelper.toString(this.value, sb);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("rowMutations:");
+      if (this.rowMutations == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.rowMutations);
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws org.apache.thrift.TException {
+      // check for required fields
+      if (table == null) {
+        throw new org.apache.thrift.protocol.TProtocolException("Required field 'table' was not present! Struct: " + toString());
+      }
+      if (row == null) {
+        throw new org.apache.thrift.protocol.TProtocolException("Required field 'row' was not present! Struct: " + toString());
+      }
+      if (family == null) {
+        throw new org.apache.thrift.protocol.TProtocolException("Required field 'family' was not present! Struct: " + toString());
+      }
+      if (qualifier == null) {
+        throw new org.apache.thrift.protocol.TProtocolException("Required field 'qualifier' was not present! Struct: " + toString());
+      }
+      if (compareOp == null) {
+        throw new org.apache.thrift.protocol.TProtocolException("Required field 'compareOp' was not present! Struct: " + toString());
+      }
+      if (rowMutations == null) {
+        throw new org.apache.thrift.protocol.TProtocolException("Required field 'rowMutations' was not present! Struct: " + toString());
+      }
+      // check for sub-struct validity
+      if (rowMutations != null) {
+        rowMutations.validate();
+      }
+    }
+
+    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
+      try {
+        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
+      } catch (org.apache.thrift.TException te) {
+        throw new java.io.IOException(te);
+      }
+    }
+
+    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
+      try {
+        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
+      } catch (org.apache.thrift.TException te) {
+        throw new java.io.IOException(te);
+      }
+    }
+
+    private static class checkAndMutate_argsStandardSchemeFactory implements SchemeFactory {
+      public checkAndMutate_argsStandardScheme getScheme() {
+        return new checkAndMutate_argsStandardScheme();
+      }
+    }
+
+    private static class checkAndMutate_argsStandardScheme extends StandardScheme<checkAndMutate_args> {
+
+      public void read(org.apache.thrift.protocol.TProtocol iprot, checkAndMutate_args struct) throws org.apache.thrift.TException {
+        org.apache.thrift.protocol.TField schemeField;
+        iprot.readStructBegin();
+        while (true)
+        {
+          schemeField = iprot.readFieldBegin();
+          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
+            break;
+          }
+          switch (schemeField.id) {
+            case 1: // TABLE
+              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
+                struct.table = iprot.readBinary();
+                struct.setTableIsSet(true);
+              } else { 
+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+              }
+              break;
+            case 2: // ROW
+              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
+                struct.row = iprot.readBinary();
+                struct.setRowIsSet(true);
+              } else { 
+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+              }
+              break;
+            case 3: // FAMILY
+              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
+                struct.family = iprot.readBinary();
+                struct.setFamilyIsSet(true);
+              } else { 
+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+              }
+              break;
+            case 4: // QUALIFIER
+              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
+                struct.qualifier = iprot.readBinary();
+                struct.setQualifierIsSet(true);
+              } else { 
+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+              }
+              break;
+            case 5: // COMPARE_OP
+              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
+                struct.compareOp = org.apache.hadoop.hbase.thrift2.generated.TCompareOp.findByValue(iprot.readI32());
+                struct.setCompareOpIsSet(true);
+              } else { 
+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+              }
+              break;
+            case 6: // VALUE
+              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
+                struct.value = iprot.readBinary();
+                struct.setValueIsSet(true);
+              } else { 
+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+              }
+              break;
+            case 7: // ROW_MUTATIONS
+              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
+                struct.rowMutations = new TRowMutations();
+                struct.rowMutations.read(iprot);
+                struct.setRowMutationsIsSet(true);
+              } else { 
+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+              }
+              break;
+            default:
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+          }
+          iprot.readFieldEnd();
+        }
+        iprot.readStructEnd();
+
+        // check for required fields of primitive type, which can't be checked in the validate method
+        struct.validate();
+      }
+
+      public void write(org.apache.thrift.protocol.TProtocol oprot, checkAndMutate_args struct) throws org.apache.thrift.TException {
+        struct.validate();
+
+        oprot.writeStructBegin(STRUCT_DESC);
+        if (struct.table != null) {
+          oprot.writeFieldBegin(TABLE_FIELD_DESC);
+          oprot.writeBinary(struct.table);
+          oprot.writeFieldEnd();
+        }
+        if (struct.row != null) {
+          oprot.writeFieldBegin(ROW_FIELD_DESC);
+          oprot.writeBinary(struct.row);
+          oprot.writeFieldEnd();
+        }
+        if (struct.family != null) {
+          oprot.writeFieldBegin(FAMILY_FIELD_DESC);
+          oprot.writeBinary(struct.family);
+          oprot.writeFieldEnd();
+        }
+        if (struct.qualifier != null) {
+          oprot.writeFieldBegin(QUALIFIER_FIELD_DESC);
+          oprot.writeBinary(struct.qualifier);
+          oprot.writeFieldEnd();
+        }
+        if (struct.compareOp != null) {
+          oprot.writeFieldBegin(COMPARE_OP_FIELD_DESC);
+          oprot.writeI32(struct.compareOp.getValue());
+          oprot.writeFieldEnd();
+        }
+        if (struct.value != null) {
+          oprot.writeFieldBegin(VALUE_FIELD_DESC);
+          oprot.writeBinary(struct.value);
+          oprot.writeFieldEnd();
+        }
+        if (struct.rowMutations != null) {
+          oprot.writeFieldBegin(ROW_MUTATIONS_FIELD_DESC);
+          struct.rowMutations.write(oprot);
+          oprot.writeFieldEnd();
+        }
+        oprot.writeFieldStop();
+        oprot.writeStructEnd();
+      }
+
+    }
+
+    private static class checkAndMutate_argsTupleSchemeFactory implements SchemeFactory {
+      public checkAndMutate_argsTupleScheme getScheme() {
+        return new checkAndMutate_argsTupleScheme();
+      }
+    }
+
+    private static class checkAndMutate_argsTupleScheme extends TupleScheme<checkAndMutate_args> {
+
+      @Override
+      public void write(org.apache.thrift.protocol.TProtocol prot, checkAndMutate_args struct) throws org.apache.thrift.TException {
+        TTupleProtocol oprot = (TTupleProtocol) prot;
+        oprot.writeBinary(struct.table);
+        oprot.writeBinary(struct.row);
+        oprot.writeBinary(struct.family);
+        oprot.writeBinary(struct.qualifier);
+        oprot.writeI32(struct.compareOp.getValue());
+        struct.rowMutations.write(oprot);
+        BitSet optionals = new BitSet();
+        if (struct.isSetValue()) {
+          optionals.set(0);
+        }
+        oprot.writeBitSet(optionals, 1);
+        if (struct.isSetValue()) {
+          oprot.writeBinary(struct.value);
+        }
+      }
+
+      @Override
+      public void read(org.apache.thrift.protocol.TProtocol prot, checkAndMutate_args struct) throws org.apache.thrift.TException {
+        TTupleProtocol iprot = (TTupleProtocol) prot;
+        struct.table = iprot.readBinary();
+        struct.setTableIsSet(true);
+        struct.row = iprot.readBinary();
+        struct.setRowIsSet(true);
+        struct.family = iprot.readBinary();
+        struct.setFamilyIsSet(true);
+        struct.qualifier = iprot.readBinary();
+        struct.setQualifierIsSet(true);
+        struct.compareOp = org.apache.hadoop.hbase.thrift2.generated.TCompareOp.findByValue(iprot.readI32());
+        struct.setCompareOpIsSet(true);
+        struct.rowMutations = new TRowMutations();
+        struct.rowMutations.read(iprot);
+        struct.setRowMutationsIsSet(true);
+        BitSet incoming = iprot.readBitSet(1);
+        if (incoming.get(0)) {
+          struct.value = iprot.readBinary();
+          struct.setValueIsSet(true);
+        }
+      }
+    }
+
+  }
+
+  public static class checkAndMutate_result implements org.apache.thrift.TBase<checkAndMutate_result, checkAndMutate_result._Fields>, java.io.Serializable, Cloneable, Comparable<checkAndMutate_result>   {
+    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("checkAndMutate_result");
+
+    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.BOOL, (short)0);
+    private static final org.apache.thrift.protocol.TField IO_FIELD_DESC = new org.apache.thrift.protocol.TField("io", org.apache.thrift.protocol.TType.STRUCT, (short)1);
+
+    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
+    static {
+      schemes.put(StandardScheme.class, new checkAndMutate_resultStandardSchemeFactory());
+      schemes.put(TupleScheme.class, new checkAndMutate_resultTupleSchemeFactory());
+    }
+
+    public boolean success; // required
+    public TIOError io; // required
+
+    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
+      SUCCESS((short)0, "success"),
+      IO((short)1, "io");
+
+      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+      static {
+        for (_Fields field : EnumSet.allOf(_Fields.class)) {
+          byName.put(field.getFieldName(), field);
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, or null if its not found.
+       */
+      public static _Fields findByThriftId(int fieldId) {
+        switch(fieldId) {
+          case 0: // SUCCESS
+            return SUCCESS;
+          case 1: // IO
+            return IO;
+          default:
+            return null;
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, throwing an exception
+       * if it is not found.
+       */
+      public static _Fields findByThriftIdOrThrow(int fieldId) {
+        _Fields fields = findByThriftId(fieldId);
+        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+        return fields;
+      }
+
+      /**
+       * Find the _Fields constant that matches name, or null if its not found.
+       */
+      public static _Fields findByName(String name) {
+        return byName.get(name);
+      }
+
+      private final short _thriftId;
+      private final String _fieldName;
+
+      _Fields(short thriftId, String fieldName) {
+        _thriftId = thriftId;
+        _fieldName = fieldName;
+      }
+
+      public short getThriftFieldId() {
+        return _thriftId;
+      }
+
+      public String getFieldName() {
+        return _fieldName;
+      }
+    }
+
+    // isset id assignments
+    private static final int __SUCCESS_ISSET_ID = 0;
+    private byte __isset_bitfield = 0;
+    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
+    static {
+      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
+      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
+      tmpMap.put(_Fields.IO, new org.apache.thrift.meta_data.FieldMetaData("io", org.apache.thrift.TFieldRequirementType.DEFAULT, 
+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
+      metaDataMap = Collections.unmodifiableMap(tmpMap);
+      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(checkAndMutate_result.class, metaDataMap);
+    }
+
+    public checkAndMutate_result() {
+    }
+
+    public checkAndMutate_result(
+      boolean success,
+      TIOError io)
+    {
+      this();
+      this.success = success;
+      setSuccessIsSet(true);
+      this.io = io;
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public checkAndMutate_result(checkAndMutate_result other) {
+      __isset_bitfield = other.__isset_bitfield;
+      this.success = other.success;
+      if (other.isSetIo()) {
+        this.io = new TIOError(other.io);
+      }
+    }
+
+    public checkAndMutate_result deepCopy() {
+      return new checkAndMutate_result(this);
+    }
+
+    @Override
+    public void clear() {
+      setSuccessIsSet(false);
+      this.success = false;
+      this.io = null;
+    }
+
+    public boolean isSuccess() {
+      return this.success;
+    }
+
+    public checkAndMutate_result setSuccess(boolean success) {
+      this.success = success;
+      setSuccessIsSet(true);
+      return this;
+    }
+
+    public void unsetSuccess() {
+      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
+    }
+
+    /** Returns true if field success is set (has been assigned a value) and false otherwise */
+    public boolean isSetSuccess() {
+      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
+    }
+
+    public void setSuccessIsSet(boolean value) {
+      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
+    }
+
+    public TIOError getIo() {
+      return this.io;
+    }
+
+    public checkAndMutate_result setIo(TIOError io) {
+      this.io = io;
+      return this;
+    }
+
+    public void unsetIo() {
+      this.io = null;
+    }
+
+    /** Returns true if field io is set (has been assigned a value) and false otherwise */
+    public boolean isSetIo() {
+      return this.io != null;
+    }
+
+    public void setIoIsSet(boolean value) {
+      if (!value) {
+        this.io = null;
+      }
+    }
+
+    public void setFieldValue(_Fields field, Object value) {
+      switch (field) {
+      case SUCCESS:
+        if (value == null) {
+          unsetSuccess();
+        } else {
+          setSuccess((Boolean)value);
+        }
+        break;
+
+      case IO:
+        if (value == null) {
+          unsetIo();
+        } else {
+          setIo((TIOError)value);
+        }
+        break;
+
+      }
+    }
+
+    public Object getFieldValue(_Fields field) {
+      switch (field) {
+      case SUCCESS:
+        return isSuccess();
+
+      case IO:
+        return getIo();
+
+      }
+      throw new IllegalStateException();
+    }
+
+    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
+    public boolean isSet(_Fields field) {
+      if (field == null) {
+        throw new IllegalArgumentException();
+      }
+
+      switch (field) {
+      case SUCCESS:
+        return isSetSuccess();
+      case IO:
+        return isSetIo();
+      }
+      throw new IllegalStateException();
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof checkAndMutate_result)
+        return this.equals((checkAndMutate_result)that);
+      return false;
+    }
+
+    public boolean equals(checkAndMutate_result that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_success = true;
+      boolean that_present_success = true;
+      if (this_present_success || that_present_success) {
+        if (!(this_present_success && that_present_success))
+          return false;
+        if (this.success != that.success)
+          return false;
+      }
+
+      boolean this_present_io = true && this.isSetIo();
+      boolean that_present_io = true && that.isSetIo();
+      if (this_present_io || that_present_io) {
+        if (!(this_present_io && that_present_io))
+          return false;
+        if (!this.io.equals(that.io))
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      List<Object> list = new ArrayList<Object>();
+
+      boolean present_success = true;
+      list.add(present_success);
+      if (present_success)
+        list.add(success);
+
+      boolean present_io = true && (isSetIo());
+      list.add(present_io);
+      if (present_io)
+        list.add(io);
+
+      return list.hashCode();
+    }
+
+    @Override
+    public int compareTo(checkAndMutate_result other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+
+      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetSuccess()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetIo()).compareTo(other.isSetIo());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetIo()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.io, other.io);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      return 0;
+    }
+
+    public _Fields fieldForId(int fieldId) {
+      return _Fields.findByThriftId(fieldId);
+    }
+
+    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
+      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
+    }
+
+    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
+      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
+      }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("checkAndMutate_result(");
+      boolean first = true;
+
+      sb.append("success:");
+      sb.append(this.success);
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("io:");
+      if (this.io == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.io);
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws org.apache.thrift.TException {
+      // check for required fields
+      // check for sub-struct validity
+    }
+
+    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
+      try {
+        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
+      } catch (org.apache.thrift.TException te) {
+        throw new java.io.IOException(te);
+      }
+    }
+
+    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
+      try {
+        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
+        __isset_bitfield = 0;
+        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
+      } catch (org.apache.thrift.TException te) {
+        throw new java.io.IOException(te);
+      }
+    }
+
+    private static class checkAndMutate_resultStandardSchemeFactory implements SchemeFactory {
+      public checkAndMutate_resultStandardScheme getScheme() {
+        return new checkAndMutate_resultStandardScheme();
+      }
+    }
+
+    private static class checkAndMutate_resultStandardScheme extends StandardScheme<checkAndMutate_result> {
+
+      public void read(org.apache.thrift.protocol.TProtocol iprot, checkAndMutate_result struct) throws org.apache.thrift.TException {
+        org.apache.thrift.protocol.TField schemeField;
+        iprot.readStructBegin();
+        while (true)
+        {
+          schemeField = iprot.readFieldBegin();
+          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
+            break;
+          }
+          switch (schemeField.id) {
+            case 0: // SUCCESS
+              if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
+                struct.success = iprot.readBool();
+                struct.setSuccessIsSet(true);
+              } else { 
+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+              }
+              break;
+            case 1: // IO
+              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
+                struct.io = new TIOError();
+                struct.io.read(iprot);
+                struct.setIoIsSet(true);
+              } else { 
+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+              }
+              break;
+            default:
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+          }
+          iprot.readFieldEnd();
+        }
+        iprot.readStructEnd();
+
+        // check for required fields of primitive type, which can't be checked in the validate method
+        struct.validate();
+      }
+
+      public void write(org.apache.thrift.protocol.TProtocol oprot, checkAndMutate_result struct) throws org.apache.thrift.TException {
+        struct.validate();
+
+        oprot.writeStructBegin(STRUCT_DESC);
+        if (struct.isSetSuccess()) {
+          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
+          oprot.writeBool(struct.success);
+          oprot.writeFieldEnd();
+        }
+        if (struct.io != null) {
+          oprot.writeFieldBegin(IO_FIELD_DESC);
+          struct.io.write(oprot);
+          oprot.writeFieldEnd();
+        }
+        oprot.writeFieldStop();
+        oprot.writeStructEnd();
+      }
+
+    }
+
+    private static class checkAndMutate_resultTupleSchemeFactory implements SchemeFactory {
+      public checkAndMutate_resultTupleScheme getScheme() {
+        return new checkAndMutate_resultTupleScheme();
+      }
+    }
+
+    private static class checkAndMutate_resultTupleScheme extends TupleScheme<checkAndMutate_result> {
+
+      @Override
+      public void write(org.apache.thrift.protocol.TProtocol prot, checkAndMutate_result struct) throws org.apache.thrift.TException {
+        TTupleProtocol oprot = (TTupleProtocol) prot;
+        BitSet optionals = new BitSet();
+        if (struct.isSetSuccess()) {
+          optionals.set(0);
+        }
+        if (struct.isSetIo()) {
+          optionals.set(1);
+        }
+        oprot.writeBitSet(optionals, 2);
+        if (struct.isSetSuccess()) {
+          oprot.writeBool(struct.success);
+        }
+        if (struct.isSetIo()) {
+          struct.io.write(oprot);
+        }
+      }
+
+      @Override
+      public void read(org.apache.thrift.protocol.TProtocol prot, checkAndMutate_result struct) throws org.apache.thrift.TException {
+        TTupleProtocol iprot = (TTupleProtocol) prot;
+        BitSet incoming = iprot.readBitSet(2);
+        if (incoming.get(0)) {
+          struct.success = iprot.readBool();
+          struct.setSuccessIsSet(true);
+        }
+        if (incoming.get(1)) {
+          struct.io = new TIOError();
+          struct.io.read(iprot);
+          struct.setIoIsSet(true);
+        }
+      }
+    }
+
+  }
+
 }
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/THRegionInfo.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/THRegionInfo.java
index 16f7116..2055c2e 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/THRegionInfo.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/THRegionInfo.java
@@ -34,7 +34,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 @SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class THRegionInfo implements org.apache.thrift.TBase<THRegionInfo, THRegionInfo._Fields>, java.io.Serializable, Cloneable, Comparable<THRegionInfo> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("THRegionInfo");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/THRegionLocation.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/THRegionLocation.java
index 43a3c76..8e46499 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/THRegionLocation.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/THRegionLocation.java
@@ -34,7 +34,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 @SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class THRegionLocation implements org.apache.thrift.TBase<THRegionLocation, THRegionLocation._Fields>, java.io.Serializable, Cloneable, Comparable<THRegionLocation> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("THRegionLocation");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TIOError.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TIOError.java
index 6fbacf9..fa68dbf 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TIOError.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TIOError.java
@@ -39,7 +39,7 @@ import org.slf4j.LoggerFactory;
  * to the HBase master or a HBase region server. Also used to return
  * more general HBase error conditions.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TIOError extends TException implements org.apache.thrift.TBase<TIOError, TIOError._Fields>, java.io.Serializable, Cloneable, Comparable<TIOError> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TIOError");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TIllegalArgument.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TIllegalArgument.java
index f843641..c2927df 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TIllegalArgument.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TIllegalArgument.java
@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;
  * A TIllegalArgument exception indicates an illegal or invalid
  * argument was passed into a procedure.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TIllegalArgument extends TException implements org.apache.thrift.TBase<TIllegalArgument, TIllegalArgument._Fields>, java.io.Serializable, Cloneable, Comparable<TIllegalArgument> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TIllegalArgument");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TIncrement.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TIncrement.java
index f932db4..881626f 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TIncrement.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TIncrement.java
@@ -41,7 +41,7 @@ import org.slf4j.LoggerFactory;
  * by changing the durability. If you don't provide durability, it defaults to
  * column family's default setting for durability.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TIncrement implements org.apache.thrift.TBase<TIncrement, TIncrement._Fields>, java.io.Serializable, Cloneable, Comparable<TIncrement> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TIncrement");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TPut.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TPut.java
index 0e96ded..91172da 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TPut.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TPut.java
@@ -46,7 +46,7 @@ import org.slf4j.LoggerFactory;
  * by changing the durability. If you don't provide durability, it defaults to
  * column family's default setting for durability.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TPut implements org.apache.thrift.TBase<TPut, TPut._Fields>, java.io.Serializable, Cloneable, Comparable<TPut> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TPut");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TResult.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TResult.java
index bac6f5e..8c03b22 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TResult.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TResult.java
@@ -37,7 +37,7 @@ import org.slf4j.LoggerFactory;
 /**
  * if no Result is found, row and columnValues will not be set.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TResult implements org.apache.thrift.TBase<TResult, TResult._Fields>, java.io.Serializable, Cloneable, Comparable<TResult> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TResult");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TRowMutations.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TRowMutations.java
index 7246974..aae0e54 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TRowMutations.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TRowMutations.java
@@ -37,7 +37,7 @@ import org.slf4j.LoggerFactory;
 /**
  * A TRowMutations object is used to apply a number of Mutations to a single row.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TRowMutations implements org.apache.thrift.TBase<TRowMutations, TRowMutations._Fields>, java.io.Serializable, Cloneable, Comparable<TRowMutations> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TRowMutations");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TScan.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TScan.java
index a552168..c4a2bb9 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TScan.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TScan.java
@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;
  * Any timestamps in the columns are ignored, use timeRange to select by timestamp.
  * Max versions defaults to 1.
  */
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TScan implements org.apache.thrift.TBase<TScan, TScan._Fields>, java.io.Serializable, Cloneable, Comparable<TScan> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TScan");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TServerName.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TServerName.java
index 0813faa..b870eef 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TServerName.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TServerName.java
@@ -34,7 +34,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 @SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TServerName implements org.apache.thrift.TBase<TServerName, TServerName._Fields>, java.io.Serializable, Cloneable, Comparable<TServerName> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TServerName");
 
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TTimeRange.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TTimeRange.java
index e3ef0b7..03b47e6 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TTimeRange.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TTimeRange.java
@@ -34,7 +34,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 @SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
-@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-11-22")
+@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2015-12-25")
 public class TTimeRange implements org.apache.thrift.TBase<TTimeRange, TTimeRange._Fields>, java.io.Serializable, Cloneable, Comparable<TTimeRange> {
   private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TTimeRange");
 
diff --git a/hbase-thrift/src/main/resources/org/apache/hadoop/hbase/thrift2/hbase.thrift b/hbase-thrift/src/main/resources/org/apache/hadoop/hbase/thrift2/hbase.thrift
index 4ad4cdd..8afeef1 100644
--- a/hbase-thrift/src/main/resources/org/apache/hadoop/hbase/thrift2/hbase.thrift
+++ b/hbase-thrift/src/main/resources/org/apache/hadoop/hbase/thrift2/hbase.thrift
@@ -263,6 +263,21 @@ struct THRegionLocation {
   2: required THRegionInfo regionInfo
 }
 
+/**
+ * Thrift wrapper around
+ * org.apache.hadoop.hbase.filter.CompareFilter$CompareOp.
+ */
+enum TCompareOp {
+  LESS = 0,
+  LESS_OR_EQUAL = 1,
+  EQUAL = 2,
+  NOT_EQUAL = 3,
+  GREATER_OR_EQUAL = 4,
+  GREATER = 5,
+  NO_OP = 6
+}
+
+
 //
 // Exceptions
 //
@@ -556,4 +571,34 @@ service THBaseService {
   ) throws (
     1: TIOError io
   )
+
+  /**
+   * Atomically checks if a row/family/qualifier value matches the expected
+   * value. If it does, it mutates the row.
+   *
+   * @return true if the row was mutated, false otherwise
+   */
+  bool checkAndMutate(
+    /** to check in and delete from */
+    1: required binary table,
+
+    /** row to check */
+    2: required binary row,
+
+    /** column family to check */
+    3: required binary family,
+
+    /** column qualifier to check */
+    4: required binary qualifier,
+
+    /** comparison to make on the value */
+    5: required TCompareOp compareOp,
+
+    /** the expected value to be compared against, if not provided the
+        check is for the non-existence of the column in question */
+    6: binary value,
+
+    /** row mutations to execute if the value matches */
+    7: required TRowMutations rowMutations
+  ) throws (1: TIOError io)
 }
diff --git a/hbase-thrift/src/test/java/org/apache/hadoop/hbase/thrift2/TestThriftHBaseServiceHandler.java b/hbase-thrift/src/test/java/org/apache/hadoop/hbase/thrift2/TestThriftHBaseServiceHandler.java
index 1575429..568ab0f 100644
--- a/hbase-thrift/src/test/java/org/apache/hadoop/hbase/thrift2/TestThriftHBaseServiceHandler.java
+++ b/hbase-thrift/src/test/java/org/apache/hadoop/hbase/thrift2/TestThriftHBaseServiceHandler.java
@@ -43,6 +43,7 @@ import org.apache.hadoop.hbase.thrift2.generated.TAppend;
 import org.apache.hadoop.hbase.thrift2.generated.TColumn;
 import org.apache.hadoop.hbase.thrift2.generated.TColumnIncrement;
 import org.apache.hadoop.hbase.thrift2.generated.TColumnValue;
+import org.apache.hadoop.hbase.thrift2.generated.TCompareOp;
 import org.apache.hadoop.hbase.thrift2.generated.TDelete;
 import org.apache.hadoop.hbase.thrift2.generated.TDeleteType;
 import org.apache.hadoop.hbase.thrift2.generated.TGet;
@@ -67,6 +68,7 @@ import org.junit.experimental.categories.Category;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
@@ -125,12 +127,16 @@ public class TestThriftHBaseServiceHandler {
     for (int i = 0; i < columnValuesA.size(); i++) {
       TColumnValue a = columnValuesA.get(i);
       TColumnValue b = columnValuesB.get(i);
-      assertArrayEquals(a.getFamily(), b.getFamily());
-      assertArrayEquals(a.getQualifier(), b.getQualifier());
-      assertArrayEquals(a.getValue(), b.getValue());
+      assertTColumnValueEqual(a, b);
     }
   }
 
+  public void assertTColumnValueEqual(TColumnValue a, TColumnValue b) {
+    assertArrayEquals(a.getFamily(), b.getFamily());
+    assertArrayEquals(a.getQualifier(), b.getQualifier());
+    assertArrayEquals(a.getValue(), b.getValue());
+  }
+
   @BeforeClass
   public static void beforeClass() throws Exception {
     UTIL.startMiniCluster();
@@ -1087,5 +1093,56 @@ public class TestThriftHBaseServiceHandler {
     increment = incrementFromThrift(tIncrement);
     assertEquals(increment.getDurability(), Durability.FSYNC_WAL);
   }
+
+  @Test
+  public void testCheckAndMutate() throws Exception {
+    ThriftHBaseServiceHandler handler = createHandler();
+    ByteBuffer table = wrap(tableAname);
+    ByteBuffer row = wrap("row".getBytes());
+    ByteBuffer family = wrap(familyAname);
+    ByteBuffer qualifier = wrap(qualifierAname);
+    ByteBuffer value = wrap(valueAname);
+
+    // Create a mutation to write to 'B', our "mutate" of "checkAndMutate"
+    List<TColumnValue> columnValuesB = new ArrayList<TColumnValue>();
+    TColumnValue columnValueB = new TColumnValue(family, wrap(qualifierBname), wrap(valueBname));
+    columnValuesB.add(columnValueB);
+    TPut putB = new TPut(row, columnValuesB);
+    putB.setColumnValues(columnValuesB);
+
+    TRowMutations tRowMutations = new TRowMutations(row,
+        Arrays.<TMutation> asList(TMutation.put(putB)));
+
+    // Empty table when we begin
+    TResult result = handler.get(table, new TGet(row));
+    assertEquals(0, result.getColumnValuesSize());
+
+    // checkAndMutate -- condition should fail because the value doesn't exist.
+    assertFalse("Expected condition to not pass",
+        handler.checkAndMutate(table, row, family, qualifier, TCompareOp.EQUAL, value,
+            tRowMutations));
+
+    List<TColumnValue> columnValuesA = new ArrayList<TColumnValue>();
+    TColumnValue columnValueA = new TColumnValue(family, qualifier, value);
+    columnValuesA.add(columnValueA);
+
+    // Put an update 'A'
+    handler.put(table, new TPut(row, columnValuesA));
+
+    // Verify that the update is there
+    result = handler.get(table, new TGet(row));
+    assertEquals(1, result.getColumnValuesSize());
+    assertTColumnValueEqual(columnValueA, result.getColumnValues().get(0));
+
+    // checkAndMutate -- condition should pass since we added the value
+    assertTrue("Expected condition to pass",
+        handler.checkAndMutate(table, row, family, qualifier, TCompareOp.EQUAL, value,
+            tRowMutations));
+
+    result = handler.get(table, new TGet(row));
+    assertEquals(2, result.getColumnValuesSize());
+    assertTColumnValueEqual(columnValueA, result.getColumnValues().get(0));
+    assertTColumnValueEqual(columnValueB, result.getColumnValues().get(1));
+  }
 }
 
-- 
2.1.2

