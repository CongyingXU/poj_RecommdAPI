diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/LegacyScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/LegacyScanQueryMatcher.java
index ea4bd97..848bfa7 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/LegacyScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/LegacyScanQueryMatcher.java
@@ -17,8 +17,6 @@
  */
 package org.apache.hadoop.hbase.regionserver.querymatcher;
 
-import com.google.common.base.Preconditions;
-
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.NavigableSet;
@@ -39,6 +37,8 @@ import org.apache.hadoop.hbase.regionserver.ScanType;
 import org.apache.hadoop.hbase.regionserver.querymatcher.DeleteTracker.DeleteResult;
 import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;
 
+import com.google.common.base.Preconditions;
+
 /**
  * The old query matcher implementation. Used to keep compatibility for coprocessor that could
  * overwrite the StoreScanner before compaction. Should be removed once we find a better way to do
@@ -171,7 +171,7 @@ public class LegacyScanQueryMatcher extends ScanQueryMatcher {
     long timestamp = cell.getTimestamp();
     byte typeByte = cell.getTypeByte();
     long mvccVersion = cell.getSequenceId();
-    if (CellUtil.isDelete(cell)) {
+    if (CellUtil.isDelete(typeByte)) {
       if (keepDeletedCells == KeepDeletedCells.FALSE
           || (keepDeletedCells == KeepDeletedCells.TTL && timestamp < oldestUnexpiredTS)) {
         // first ignore delete markers if the scanner can do so, and the
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MajorCompactionScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MajorCompactionScanQueryMatcher.java
index 6a2ed40..67e40ed 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MajorCompactionScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MajorCompactionScanQueryMatcher.java
@@ -43,6 +43,7 @@ public class MajorCompactionScanQueryMatcher extends DropDeletesCompactionScanQu
     }
     long timestamp = cell.getTimestamp();
     long mvccVersion = cell.getSequenceId();
+    byte typeByte = cell.getTypeByte();
 
     // The delete logic is pretty complicated now.
     // This is corroborated by the following:
@@ -56,7 +57,7 @@ public class MajorCompactionScanQueryMatcher extends DropDeletesCompactionScanQu
     // 7. Delete marker need to be version counted together with puts
     // they affect
     //
-    if (CellUtil.isDelete(cell)) {
+    if (CellUtil.isDelete(typeByte)) {
       if (mvccVersion > maxReadPointToTrackVersions) {
         // We can not drop this delete marker yet, and also we should not use this delete marker to
         // mask any cell yet.
@@ -74,7 +75,7 @@ public class MajorCompactionScanQueryMatcher extends DropDeletesCompactionScanQu
       }
     }
     // Skip checking column since we do not remove column during compaction.
-    return columns.checkVersions(cell, timestamp, cell.getTypeByte(),
+    return columns.checkVersions(cell, timestamp, typeByte,
       mvccVersion > maxReadPointToTrackVersions);
   }
 }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MinorCompactionScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MinorCompactionScanQueryMatcher.java
index 3b6acde..cf36366 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MinorCompactionScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MinorCompactionScanQueryMatcher.java
@@ -42,7 +42,8 @@ public class MinorCompactionScanQueryMatcher extends CompactionScanQueryMatcher
       return returnCode;
     }
     long mvccVersion = cell.getSequenceId();
-    if (CellUtil.isDelete(cell)) {
+    byte typeByte = cell.getTypeByte();
+    if (CellUtil.isDelete(typeByte)) {
       if (mvccVersion > maxReadPointToTrackVersions) {
         // we should not use this delete marker to mask any cell yet.
         return MatchCode.INCLUDE;
@@ -55,7 +56,7 @@ public class MinorCompactionScanQueryMatcher extends CompactionScanQueryMatcher
       return returnCode;
     }
     // Skip checking column since we do not remove column during compaction.
-    return columns.checkVersions(cell, cell.getTimestamp(), cell.getTypeByte(),
+    return columns.checkVersions(cell, cell.getTimestamp(), typeByte,
       mvccVersion > maxReadPointToTrackVersions);
   }
 }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NormalUserScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NormalUserScanQueryMatcher.java
index 3942f04..894bbec 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NormalUserScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NormalUserScanQueryMatcher.java
@@ -60,7 +60,8 @@ public class NormalUserScanQueryMatcher extends UserScanQueryMatcher {
       return returnCode;
     }
     long timestamp = cell.getTimestamp();
-    if (CellUtil.isDelete(cell)) {
+    byte typeByte = cell.getTypeByte();
+    if (CellUtil.isDelete(typeByte)) {
       boolean includeDeleteMarker = seePastDeleteMarkers ? tr.withinTimeRange(timestamp)
           : tr.withinOrAfterTimeRange(timestamp);
       if (includeDeleteMarker) {
@@ -72,7 +73,7 @@ public class NormalUserScanQueryMatcher extends UserScanQueryMatcher {
     if (returnCode != null) {
       return returnCode;
     }
-    return matchColumn(cell);
+    return matchColumn(cell, timestamp, typeByte);
   }
 
   @Override
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/RawScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/RawScanQueryMatcher.java
index acdae90..84484ed 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/RawScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/RawScanQueryMatcher.java
@@ -44,9 +44,11 @@ public class RawScanQueryMatcher extends UserScanQueryMatcher {
     if (returnCode != null) {
       return returnCode;
     }
+    long timestamp = cell.getTimestamp();
+    byte typeByte = cell.getTypeByte();
     // For a raw scan, we do not filter out any cells by delete marker, and delete marker is also
     // returned, so we do not need to track delete.
-    return matchColumn(cell);
+    return matchColumn(cell, timestamp, typeByte);
   }
 
   @Override
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/StripeCompactionScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/StripeCompactionScanQueryMatcher.java
index c1e63b4..1ba08f7 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/StripeCompactionScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/StripeCompactionScanQueryMatcher.java
@@ -55,7 +55,8 @@ public class StripeCompactionScanQueryMatcher extends DropDeletesCompactionScanQ
       return returnCode;
     }
     long mvccVersion = cell.getSequenceId();
-    if (CellUtil.isDelete(cell)) {
+    byte typeByte = cell.getTypeByte();
+    if (CellUtil.isDelete(typeByte)) {
       if (mvccVersion > maxReadPointToTrackVersions) {
         return MatchCode.INCLUDE;
       }
@@ -77,7 +78,7 @@ public class StripeCompactionScanQueryMatcher extends DropDeletesCompactionScanQ
       }
     }
     // Skip checking column since we do not remove column during compaction.
-    return columns.checkVersions(cell, cell.getTimestamp(), cell.getTypeByte(),
+    return columns.checkVersions(cell, cell.getTimestamp(), typeByte,
       mvccVersion > maxReadPointToTrackVersions);
   }
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/UserScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/UserScanQueryMatcher.java
index ec7fc11..db85d0f 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/UserScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/UserScanQueryMatcher.java
@@ -88,8 +88,8 @@ public abstract class UserScanQueryMatcher extends ScanQueryMatcher {
     }
   }
 
-  protected final MatchCode matchColumn(Cell cell) throws IOException {
-    long timestamp = cell.getTimestamp();
+  protected final MatchCode matchColumn(Cell cell, long timestamp, byte typeByte)
+      throws IOException {
     int tsCmp = tr.compare(timestamp);
     if (tsCmp > 0) {
       return MatchCode.SKIP;
@@ -97,7 +97,6 @@ public abstract class UserScanQueryMatcher extends ScanQueryMatcher {
     if (tsCmp < 0) {
       return columns.getNextRowOrNextColumn(cell);
     }
-    byte typeByte = cell.getTypeByte();
     // STEP 1: Check if the column is part of the requested columns
     MatchCode colChecker = columns.checkColumn(cell, typeByte);
     if (colChecker != MatchCode.INCLUDE) {
