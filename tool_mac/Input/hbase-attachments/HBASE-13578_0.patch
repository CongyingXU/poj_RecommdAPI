import java.util.*;
import java.util.concurrent.*;

public class ArrayTest {
  static class SyncFuture { }

  private BlockingQueue<SyncFuture> syncFutures;

  public ArrayTest(final int maxHandlersCount) {
    syncFutures = new LinkedBlockingQueue<SyncFuture>(maxHandlersCount * 3);
  }

  void drain() {
    syncFutures.clear();
  }

  void offerSubList(final SyncFuture[] syncFutures, final int syncFutureCount) {
    this.syncFutures.addAll(Arrays.asList(syncFutures).subList(0, syncFutureCount));
  }

  void offerSubList2(final SyncFuture[] syncFutures, final int syncFutureCount) {
    for (int i = 0; i < syncFutureCount; ++i) {
      this.syncFutures.add(syncFutures[i]);
    }
  }

  public static void main(String[] args) {
    String[] caseName = new String[] { "subList", "directAdd" };
    long[] caseTimes = new long[caseName.length];
    long[] caseRuns = new long[caseName.length];

    final int MAX_HANDLERS = 50;
    SyncFuture[] syncFutures = new SyncFuture[MAX_HANDLERS];
    for (int j = 0; j < syncFutures.length; ++j) {
      syncFutures[j] = new SyncFuture();
    }

    Random rand = new Random();
    for (int maxHandlersCount = 4; maxHandlersCount <= MAX_HANDLERS; maxHandlersCount += 1) {
      int opt = 0;
      ArrayTest test = new ArrayTest(maxHandlersCount);
      for (int i = 0; i < 100; ++i) {
        long st = System.currentTimeMillis();
        final int NRUNS = 10000;
        for (int j = 0; j < NRUNS; ++j) {
          test.drain();
          switch (opt) {
            case 0: test.offerSubList(syncFutures, maxHandlersCount); break;
            case 1: test.offerSubList2(syncFutures, maxHandlersCount); break;
          }
        }
        caseTimes[opt] += System.currentTimeMillis() - st;
        caseRuns[opt] += NRUNS * maxHandlersCount;
        opt = (opt + 1) % caseName.length;
      }
    }

    for (int i = 0; i < caseName.length; ++i) {
      System.out.printf("%-9s runs=%d time=%-5d ops=%.3f/ms improv=%.3f%% %n",
                        caseName[i], caseRuns[i], caseTimes[i],
                        ((float)caseRuns[i] / caseTimes[i]),
                        i > 0 ? (1.0 - ((float)caseTimes[i] / caseTimes[i-1])) * 100 : 0);
    }
  }
}
