Index: src/org/apache/axis2/transport/http/HTTPWorkerFactory.java
===================================================================
--- src/org/apache/axis2/transport/http/HTTPWorkerFactory.java	(revision 0)
+++ src/org/apache/axis2/transport/http/HTTPWorkerFactory.java	(revision 0)
@@ -0,0 +1,52 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http;
+
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.transport.http.server.Worker;
+import org.apache.axis2.transport.http.server.WorkerFactory;
+
+public class HTTPWorkerFactory implements WorkerFactory {
+
+    final ConfigurationContext configurationContext;
+    
+    public HTTPWorkerFactory(final ConfigurationContext configurationContext) {
+        super();
+        if (configurationContext == null) {
+            throw new IllegalArgumentException("Configuration context may not be null");
+        }
+        this.configurationContext = configurationContext;
+    }
+    
+    public Worker newWorker() {
+        return new HTTPWorker(this.configurationContext);
+    }
+    
+}

Property changes on: src/org/apache/axis2/transport/http/HTTPWorkerFactory.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL
Name: svn:eol-style
   + native

Index: src/org/apache/axis2/transport/http/HTTPWorker.java
===================================================================
--- src/org/apache/axis2/transport/http/HTTPWorker.java	(revision 408643)
+++ src/org/apache/axis2/transport/http/HTTPWorker.java	(working copy)
@@ -14,182 +14,188 @@
 * limitations under the License.
 */
 
-
 package org.apache.axis2.transport.http;
 
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.SocketException;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Iterator;
+
+import javax.xml.namespace.QName;
+
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
-import org.apache.axis2.context.*;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.OperationContext;
+import org.apache.axis2.context.ServiceContext;
+import org.apache.axis2.context.ServiceGroupContext;
+import org.apache.axis2.context.SessionContext;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.Parameter;
+import org.apache.axis2.description.TransportInDescription;
 import org.apache.axis2.description.TransportOutDescription;
-import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.axis2.engine.AxisEngine;
 import org.apache.axis2.engine.DependencyManager;
 import org.apache.axis2.i18n.Messages;
-import org.apache.axis2.transport.http.server.HttpRequestHandler;
-import org.apache.axis2.transport.http.server.SimpleHttpServerConnection;
-import org.apache.axis2.transport.http.server.SimpleRequest;
-import org.apache.axis2.transport.http.server.SimpleResponse;
+import org.apache.axis2.transport.http.HTTPConstants;
+import org.apache.axis2.transport.http.HTTPTransportReceiver;
+import org.apache.axis2.transport.http.HTTPTransportUtils;
+import org.apache.axis2.transport.http.server.OutputBuffer;
+import org.apache.axis2.transport.http.server.HttpUtils;
+import org.apache.axis2.transport.http.server.Worker;
 import org.apache.axis2.util.UUIDGenerator;
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HttpVersion;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpEntityEnclosingRequest;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpVersion;
+import org.apache.http.MethodNotSupportedException;
+import org.apache.http.StatusLine;
+import org.apache.http.entity.ContentProducer;
+import org.apache.http.entity.EntityTemplate;
+import org.apache.http.entity.StringEntity;
 import org.apache.ws.commons.schema.XmlSchema;
 
-import javax.xml.namespace.QName;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.SocketException;
-import java.util.*;
+public class HTTPWorker implements Worker {
 
-public class HTTPWorker implements HttpRequestHandler {
-
-	private static final Log log = LogFactory.getLog(HTTPWorker.class);
+    private static final Log log = LogFactory.getLog(HTTPWorker.class);
+    
     private ConfigurationContext configurationContext;
     // to store session object
-    private Hashtable sessionContextTable = new Hashtable();
+    private static Hashtable sessionContextTable = new Hashtable();
 
     public HTTPWorker(ConfigurationContext configurationContext) {
         this.configurationContext = configurationContext;
     }
 
-    public boolean processRequest(final SimpleHttpServerConnection conn,
-                                  final SimpleRequest request)
-            throws IOException {
-        MessageContext msgContext = null;
-        SimpleResponse response = new SimpleResponse();
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-
+    public void service(final HttpRequest request, final HttpResponse response) 
+            throws HttpException, IOException {    
+        MessageContext msgContext = new MessageContext();
+        msgContext.setIncomingTransportName(Constants.TRANSPORT_HTTP);
         try {
             if (configurationContext == null) {
                 throw new AxisFault(Messages.getMessage("cannotBeNullConfigurationContext"));
             }
-            InputStream inStream = request.getBody();
-            TransportOutDescription transportOut =
-                    configurationContext.getAxisConfiguration().getTransportOut(
-                            new QName(Constants.TRANSPORT_HTTP));
-            String cookieID = request.getCookieID();
+            // Get relevant request parameters
+            HttpVersion ver = request.getRequestLine().getHttpVersion();
+            String uri = request.getRequestLine().getUri();
+            String method = request.getRequestLine().getMethod();
+
+            String soapAction = HttpUtils.getSoapAction(request);
+            String cookieID = HttpUtils.getCookieID(request);
             SessionContext sessionContext = getSessionContext(cookieID);
+            
+            boolean chunked = false;
 
-            msgContext = new MessageContext();
-            msgContext.setIncomingTransportName(Constants.TRANSPORT_HTTP);
+            TransportOutDescription transportOut = configurationContext.getAxisConfiguration()
+                .getTransportOut(new QName(Constants.TRANSPORT_HTTP));
+            TransportInDescription transportIn = configurationContext.getAxisConfiguration()
+                .getTransportIn(new QName(Constants.TRANSPORT_HTTP));            
+        
+            // Configure message context
             msgContext.setConfigurationContext(configurationContext);
             msgContext.setSessionContext(sessionContext);
-            msgContext.setTransportIn(configurationContext.getAxisConfiguration().getTransportIn(
-                    new QName(Constants.TRANSPORT_HTTP)));
+            msgContext.setTransportIn(transportIn);
             msgContext.setTransportOut(transportOut);
+            msgContext.setServiceGroupContextId(UUIDGenerator.getUUID());
             msgContext.setServerSide(true);
+            msgContext.setProperty(Constants.Configuration.TRANSPORT_IN_URL, uri);
 
-            HttpVersion ver = request.getRequestLine().getHttpVersion();
-
-            if (ver == null) {
-                throw new AxisFault("HTTP version can not be Null");
+            // set the transport Headers
+            HashMap headerMap = new HashMap();
+            Header[] headers = request.getAllHeaders();
+            for (int i = 0; i < headers.length; i++) {
+                headerMap.put(headers[i].getName(), headers[i].getValue());
             }
+            msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, headerMap);
 
-
-            if (HttpVersion.HTTP_1_0.equals(ver)) {
-//                httpVersion = HTTPConstants.HEADER_PROTOCOL_10;
-            } else if (HttpVersion.HTTP_1_1.equals(ver)) {
-//                httpVersion = HTTPConstants.HEADER_PROTOCOL_11;
-
-                /**
-                 * Transport Sender configuration via axis2.xml
-                 */
-                this.transportOutConfiguration(configurationContext, response);
-            } else {
-                throw new AxisFault("Unknown supported protocol version " + ver);
+            // Adjust version and content chunking based on the config
+            if (transportOut != null) {
+                Parameter p = transportOut.getParameter(HTTPConstants.PROTOCOL_VERSION);
+                if (p != null) {
+                    if (HTTPConstants.HEADER_PROTOCOL_10.equals(p.getValue())) {
+                        ver = HttpVersion.HTTP_1_0;
+                    }
+                }
+                if (ver.greaterEquals(HttpVersion.HTTP_1_1)) {
+                    p = transportOut.getParameter(HTTPConstants.HEADER_TRANSFER_ENCODING);
+                    if (p != null) {
+                        if (HTTPConstants.HEADER_TRANSFER_ENCODING_CHUNKED.equals(p.getValue())) {
+                            chunked = true;
+                        }
+                    }
+                }
             }
 
-            msgContext.setProperty(MessageContext.TRANSPORT_OUT, baos);
-
-            // set the transport Headers
-            msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, getHeaders(request));
-            msgContext.setServiceGroupContextId(UUIDGenerator.getUUID());
-
-            // This is way to provide access to the transport information to the transport Sender
-            msgContext.setProperty(Constants.OUT_TRANSPORT_INFO,
-                    new SimpleHTTPOutTransportInfo(response));
-            msgContext.setProperty(Constants.Configuration.TRANSPORT_IN_URL, request.getRequestLine().getUri());
-
-
-            String soapAction = null;
-
-            if (request.getFirstHeader(HTTPConstants.HEADER_SOAP_ACTION) != null) {
-                soapAction = request.getFirstHeader(HTTPConstants.HEADER_SOAP_ACTION).getValue();
-            }
-
-            if (HTTPConstants.HEADER_GET.equals(request.getRequestLine().getMethod())) {
-                String uri = request.getRequestLine().getUri();
-                log.debug("HTTP GET:" + uri);
+            if (method.equals(HTTPConstants.HEADER_GET)) {
                 if (uri.equals("/favicon.ico")) {
-                    response.setStatusLine(request.getRequestLine().getHttpVersion(), 301, "Redirect");
+                    response.setStatusLine(new StatusLine(ver, 301, "Redirect"));
                     response.addHeader(new Header("Location", "http://ws.apache.org/favicon.ico"));
-                    conn.writeResponse(response);
-                    return true;
+                    return;
                 }
                 if (!uri.startsWith("/axis2/services/")) {
-                    response.setStatusLine(request.getRequestLine().getHttpVersion(), 301, "Redirect");
+                    response.setStatusLine(new StatusLine(ver, 301, "Redirect"));
                     response.addHeader(new Header("Location", "/axis2/services/"));
-                    conn.writeResponse(response);
-                    return true;
+                    return;
                 }
-
                 if (uri.indexOf("?") < 0) {
                     if (!(uri.endsWith("/axis2/services/") || uri.endsWith("/axis2/services"))) {
                         String serviceName = uri.replaceAll("/axis2/services/", "");
                         if (serviceName.indexOf("/") < 0) {
-                            response.addHeader(new Header("Content-Type", "text/html"));
                             String res = HTTPTransportReceiver.printServiceHTML(serviceName, configurationContext);
-                            byte[] buf = res.getBytes();
-                            response.setBody(new ByteArrayInputStream(buf));
-                            conn.writeResponse(response);
-                            return true;
+                            StringEntity entity = new StringEntity(res);
+                            entity.setContentType("text/html");
+                            entity.setChunked(chunked);
+                            response.setEntity(entity);
+                            return;
                         }
                     }
                 }
-
                 if (uri.endsWith("?wsdl")) {
                     String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.length() - 5);
                     HashMap services = configurationContext.getAxisConfiguration().getServices();
-                    AxisService service = (AxisService) services.get(serviceName);
+                    final AxisService service = (AxisService) services.get(serviceName);
                     if (service != null) {
-                        response.addHeader(new Header("Content-Type", "text/xml"));
-//                        String url = conn.getURL(uri.substring(1, uri.length() - 5));
-                        String url = conn.getURL("");
-                        int ipindex = url.indexOf("//");
-                        String ip = null;
-                        if (ipindex >= 0) {
-                            ip = url.substring(ipindex + 2, url.length());
-                            int seperatorIndex = ip.indexOf(":");
-                            if (seperatorIndex > 0) {
-                                ip = ip.substring(0, seperatorIndex);
+                        final String ip = HttpUtils.getIpAddress();
+                        EntityTemplate entity = new EntityTemplate(new ContentProducer() {
+
+                            public void writeTo(final OutputStream outstream) throws IOException {
+                                service.printWSDL(outstream, ip);
                             }
-                        }
-                        service.printWSDL(baos, ip);
-                        byte[] buf = baos.toByteArray();
-                        response.setBody(new ByteArrayInputStream(buf));
-                        conn.writeResponse(response);
-                        return true;
+                            
+                        });
+                        entity.setContentType("text/xml");
+                        entity.setChunked(chunked);
+                        response.setEntity(entity);
+                        return;
                     }
                 }
                 if (uri.endsWith("?xsd")) {
                     String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.length() - 4);
                     HashMap services = configurationContext.getAxisConfiguration().getServices();
-                    AxisService service = (AxisService) services.get(serviceName);
+                    final AxisService service = (AxisService) services.get(serviceName);
                     if (service != null) {
-                        response.addHeader(new Header("Content-Type", "text/xml"));
-                        service.printSchema(baos);
-                        byte[] buf = baos.toByteArray();
-                        response.setBody(new ByteArrayInputStream(buf));
-                        conn.writeResponse(response);
-                        return true;
+                        EntityTemplate entity = new EntityTemplate(new ContentProducer() {
+
+                            public void writeTo(final OutputStream outstream) throws IOException {
+                                service.printSchema(outstream);
+                            }
+                            
+                        });
+                        entity.setContentType("text/xml");
+                        entity.setChunked(chunked);
+                        response.setEntity(entity);
+                        return;
                     }
                 }
-
                 //cater for named xsds - check for the xsd name
                 if (uri.indexOf("?xsd=")>0) {
                     String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.lastIndexOf("?xsd="));
@@ -202,189 +208,124 @@
                         service.populateSchemaMappings();
                         //write out the correct schema
                         Hashtable schemaTable = service.getSchemaMappingTable();
-                        XmlSchema schema = (XmlSchema)schemaTable.get(schemaName);
+                        final XmlSchema schema = (XmlSchema)schemaTable.get(schemaName);
                         //schema found - write it to the stream
-                        if (schema!=null){
-                            response.addHeader(new Header("Content-Type", "text/xml"));
-                            schema.write(baos);
-                            byte[] buf = baos.toByteArray();
-                            response.setBody(new ByteArrayInputStream(buf));
-                            conn.writeResponse(response);
+                        if (schema != null) {
+                            EntityTemplate entity = new EntityTemplate(new ContentProducer() {
 
-                        }else{
-                          // no schema available by that name  - send 404
-                          response.setStatusLine(
-                                  request.getRequestLine().getHttpVersion(),
-                                  404, "Schema Not Found!");
+                                public void writeTo(final OutputStream outstream) throws IOException {
+                                    schema.write(outstream);
+                                }
+                                
+                            });
+                            entity.setContentType("text/xml");
+                            entity.setChunked(chunked);
+                            response.setEntity(entity);
+                            return;
+                        } else {
+                            // no schema available by that name  - send 404
+                            response.setStatusLine(new StatusLine(ver, 404, "Schema Not Found!"));
+                            return;
                         }
-
-                         return true;
-
                     }
                 }
-                // It is GET handle the Get request
+
+                OutputBuffer outbuffer = new OutputBuffer(); 
+                msgContext.setProperty(MessageContext.TRANSPORT_OUT, outbuffer);
+                msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outbuffer);
+
+                // deal with GET request
                 boolean processed = HTTPTransportUtils.processHTTPGetRequest(
-                        msgContext, baos,
-                        soapAction, request.getRequestLine().getUri(),
+                        msgContext, 
+                        outbuffer.getOutputStream(), 
+                        soapAction, 
+                        uri,
                         configurationContext,
-                        HTTPTransportReceiver.getGetRequestParameters(
-                                request.getRequestLine().getUri()));
+                        HTTPTransportReceiver.getGetRequestParameters(uri));
+                
+                if (processed) {
+                    outbuffer.setChunked(chunked);
+                    response.setEntity(outbuffer);
+                } else {
+                    response.setStatusLine(new StatusLine(ver, 200, "OK"));
+                    String s = HTTPTransportReceiver.getServicesHTML(configurationContext);
+                    StringEntity entity = new StringEntity(s);
+                    entity.setContentType("text/html");
+                    entity.setChunked(chunked);
+                    response.setEntity(entity);
+                }
+                
+            } else if (method.equals(HTTPConstants.HEADER_POST)) {
+                // deal with POST request
 
-                if (!processed) {
-                    response.setStatusLine(request.getRequestLine().getHttpVersion(), 200, "OK");
-                    response.addHeader(new Header("Content-Type", "text/html"));
-                    response.setBodyString(
-                            HTTPTransportReceiver.getServicesHTML(configurationContext));
-                    setResponseHeaders(conn, request, response, 0, msgContext);
-                    conn.writeResponse(response);
+                OutputBuffer outbuffer = new OutputBuffer(); 
+                msgContext.setProperty(MessageContext.TRANSPORT_OUT, outbuffer);
+                msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outbuffer);
 
-                    return true;
+                HttpEntity inentity = ((HttpEntityEnclosingRequest) request).getEntity();
+                String contenttype = null;
+                if (inentity.getContentType() != null) {
+                    contenttype = inentity.getContentType().getValue();
                 }
+                HTTPTransportUtils.processHTTPPostRequest(
+                        msgContext, 
+                        inentity.getContent(), 
+                        outbuffer.getOutputStream(),
+                        contenttype, 
+                        soapAction, 
+                        uri);
+                
+                outbuffer.setChunked(chunked);
+                response.setEntity(outbuffer);
+                
             } else {
-                ByteArrayOutputStream baosIn = new ByteArrayOutputStream();
-                byte[]                bytes = new byte[8192];
-                int size;
-
-                while ((size = inStream.read(bytes)) > 0) {
-                    baosIn.write(bytes, 0, size);
-                }
-
-                inStream = new ByteArrayInputStream(baosIn.toByteArray());
-
-                // It is POST, handle it
-                HTTPTransportUtils.processHTTPPostRequest(msgContext, inStream, baos,
-                        request.getContentType(), soapAction, request.getRequestLine().getUri());
+                throw new MethodNotSupportedException(method + " method not supported");
             }
-
+            
+            // Finalize response
             OperationContext operationContext = msgContext.getOperationContext();
             Object contextWritten = null;
-
             if (operationContext != null) {
                 contextWritten = operationContext.getProperty(Constants.RESPONSE_WRITTEN);
             }
-
             if ((contextWritten != null) && Constants.VALUE_TRUE.equals(contextWritten)) {
-                response.setStatusLine(request.getRequestLine().getHttpVersion(), 200, "OK");
+                response.setStatusLine(new StatusLine(ver, 200, "OK"));
             } else {
-                response.setStatusLine(request.getRequestLine().getHttpVersion(), 202, "OK");
+                response.setStatusLine(new StatusLine(ver, 202, "OK"));
             }
-
-            byte[] buf = baos.toByteArray();
-            response.setBody(new ByteArrayInputStream(buf));
-            setResponseHeaders(conn, request, response, buf.length, msgContext);
-
-            conn.writeResponse(response);
+            setCookie(response, msgContext);
+            
+        } catch (SocketException ex) {
+            // Socket is unreliable. 
+            throw ex;
+        } catch (HttpException ex) {
+            // HTTP protocol violation. Transport is unrelaible
+            throw ex;
         } catch (Throwable e) {
-            if (!(e instanceof java.net.SocketException)) {
-                log.debug(e.getMessage(), e);
-            }
-
+            HttpVersion ver = request.getRequestLine().getHttpVersion();
             try {
                 AxisEngine engine = new AxisEngine(configurationContext);
+                
+                OutputBuffer outbuffer = new OutputBuffer(); 
+                msgContext.setProperty(MessageContext.TRANSPORT_OUT, outbuffer.getOutputStream());
+                msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outbuffer);
 
-                if (msgContext != null) {
-                    msgContext.setProperty(MessageContext.TRANSPORT_OUT, baos);
+                MessageContext faultContext = engine.createFaultMessageContext(msgContext, e);
 
-                    MessageContext faultContext = engine.createFaultMessageContext(msgContext, e);
-
-                    response.setStatusLine(request.getRequestLine().getHttpVersion(), 500,
-                            "Internal server error");
-                    engine.sendFault(faultContext);
-                    byte[] buf = baos.toByteArray();
-                    response.setBody(new ByteArrayInputStream(buf));
-                    setResponseHeaders(conn, request, response, buf.length, msgContext);
-                    conn.writeResponse(response);
-                }
-            } catch (SocketException e1) {
-                log.debug(e1.getMessage(), e1);
-            } catch (Exception e1) {
-                log.warn(e1.getMessage(), e1);
+                response.setStatusLine(new StatusLine(ver, 500, "Internal server error"));
+                engine.sendFault(faultContext);
+                response.setEntity(outbuffer);
+                setCookie(response, msgContext);
+            } catch (Exception ex) {
+                response.setStatusLine(new StatusLine(ver, 500, "Internal server error"));
+                StringEntity entity = new StringEntity(ex.getMessage());
+                entity.setContentType("text/plain");
+                response.setEntity(entity);
             }
         }
-
-        return true;
     }
 
-    /**
-     * Simple Axis Transport Selection via deployment
-     *
-     * @param configContext
-     * @param response
-     */
-    private void transportOutConfiguration(ConfigurationContext configContext,
-                                           SimpleResponse response) {
-        AxisConfiguration axisConf = configContext.getAxisConfiguration();
-        HashMap transportOuts = axisConf.getTransportsOut();
-        Iterator values = transportOuts.values().iterator();
-
-        while (values.hasNext()) {
-            TransportOutDescription transportOut = (TransportOutDescription) values.next();
-
-            // reading axis2.xml for transport senders..
-            Parameter version = transportOut.getParameter(HTTPConstants.PROTOCOL_VERSION);
-
-            if (version != null) {
-                if (HTTPConstants.HEADER_PROTOCOL_11.equals(version.getValue())) {
-
-                    Parameter transferEncoding =
-                            transportOut.getParameter(HTTPConstants.HEADER_TRANSFER_ENCODING);
-
-                    if (transferEncoding != null) {
-                        if (HTTPConstants.HEADER_TRANSFER_ENCODING_CHUNKED.equals(
-                                transferEncoding.getValue())) {
-                            response.setHeader(
-                                    new Header(
-                                            HTTPConstants.HEADER_TRANSFER_ENCODING,
-                                            HTTPConstants.HEADER_TRANSFER_ENCODING_CHUNKED));
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    private Map getHeaders(SimpleRequest request) {
-        HashMap headerMap = new HashMap();
-        Header[] headers = request.getHeaders();
-
-        for (int i = 0; i < headers.length; i++) {
-            headerMap.put(headers[i].getName(), headers[i].getValue());
-        }
-
-        return headerMap;
-    }
-
-    private void setResponseHeaders(final SimpleHttpServerConnection conn, SimpleRequest request,
-                                    SimpleResponse response, long contentLength, MessageContext msgContext) {
-        if (!response.containsHeader("Connection")) {
-
-            // See if the the client explicitly handles connection persistence
-            Header connheader = request.getFirstHeader("Connection");
-
-            if (connheader != null) {
-                if (connheader.getValue().equalsIgnoreCase("keep-alive")) {
-                    Header header = new Header("Connection", "keep-alive");
-
-                    response.addHeader(header);
-                    conn.setKeepAlive(true);
-                }
-
-                if (connheader.getValue().equalsIgnoreCase("close")) {
-                    Header header = new Header("Connection", "close");
-
-                    response.addHeader(header);
-                    conn.setKeepAlive(false);
-                }
-            } else {
-
-                // Use protocol default connection policy
-                if (response.getHttpVersion().greaterEquals(HttpVersion.HTTP_1_1)) {
-                    conn.setKeepAlive(true);
-                } else {
-                    conn.setKeepAlive(false);
-                }
-            }
-        }
+    private static void setCookie(final HttpResponse response, MessageContext msgContext) {
         //TODO : provide a way to enable and diable cookies
         //setting the coolie in the out path
         Object cookieString = msgContext.getProperty(Constants.COOKIE_STRING);
@@ -392,14 +333,6 @@
             response.addHeader(new Header(HTTPConstants.HEADER_SET_COOKIE, (String) cookieString));
             response.addHeader(new Header(HTTPConstants.HEADER_SET_COOKIE2, (String) cookieString));
         }
-
-        if (!response.containsHeader("Transfer-Encoding")) {
-            if (contentLength != 0) {
-                Header header = new Header("Content-Length", String.valueOf(contentLength));
-
-                response.addHeader(header);
-            }
-        }
     }
 
     /**
Index: src/org/apache/axis2/transport/http/SimpleHTTPOutTransportInfo.java
===================================================================
--- src/org/apache/axis2/transport/http/SimpleHTTPOutTransportInfo.java	(revision 408643)
+++ src/org/apache/axis2/transport/http/SimpleHTTPOutTransportInfo.java	(working copy)
@@ -1,43 +0,0 @@
-/*
-* Copyright 2004,2005 The Apache Software Foundation.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-
-package org.apache.axis2.transport.http;
-
-import org.apache.axis2.transport.OutTransportInfo;
-import org.apache.axis2.transport.http.server.SimpleResponse;
-import org.apache.commons.httpclient.Header;
-
-public class SimpleHTTPOutTransportInfo implements OutTransportInfo {
-    private String encoding;
-    private SimpleResponse outInfo;
-
-    public SimpleHTTPOutTransportInfo(SimpleResponse outInfo) {
-        this.outInfo = outInfo;
-    }
-
-    public void setCharacterEncoding(String encoding) {
-        this.encoding = encoding;
-    }
-
-    public void setContentType(String contentType) {
-        if (encoding != null) {
-            contentType = contentType + ";charset=" + encoding;
-        }
-
-        outInfo.setHeader(new Header(HTTPConstants.HEADER_CONTENT_TYPE, contentType));
-    }
-}
Index: src/org/apache/axis2/transport/http/SimpleHTTPServer.java
===================================================================
--- src/org/apache/axis2/transport/http/SimpleHTTPServer.java	(revision 408643)
+++ src/org/apache/axis2/transport/http/SimpleHTTPServer.java	(working copy)
@@ -26,8 +26,8 @@
 import org.apache.axis2.description.TransportInDescription;
 import org.apache.axis2.engine.ListenerManager;
 import org.apache.axis2.transport.TransportListener;
+import org.apache.axis2.transport.http.server.HttpUtils;
 import org.apache.axis2.transport.http.server.SimpleHttpServer;
-import org.apache.axis2.transport.http.server.SimpleHttpServerConnection;
 import org.apache.axis2.util.OptionsParser;
 import org.apache.axis2.util.threadpool.ThreadFactory;
 import org.apache.commons.logging.Log;
@@ -59,7 +59,6 @@
      */
     SimpleHttpServer embedded = null;
     int port = -1;
-    private ThreadFactory threadPool = null;
 
     public static int DEFAULT_PORT = 8080;
     private String hostAddress = null;
@@ -72,30 +71,20 @@
     public SimpleHTTPServer() {
     }
 
-    public SimpleHTTPServer(ConfigurationContext systemContext, int port) throws AxisFault {
-        this(systemContext, port, null);
-    }
-
     /**
      * Constructor SimpleHTTPServer
      *
      * @param systemContext
      * @param pool
      */
-    public SimpleHTTPServer(ConfigurationContext systemContext, int port, ThreadFactory pool) throws AxisFault {
+    public SimpleHTTPServer(ConfigurationContext systemContext, int port) throws AxisFault {
         // If a threadPool is not passed-in the threadpool
         // from the ConfigurationContext
         // is used. This is a bit tricky, and might cause a
         // thread lock. So use with
         // caution
         this.configurationContext = systemContext;
-        if (pool == null) {
-            pool = this.configurationContext.getThreadPool();
-        } else {
-            this.configurationContext.setThreadPool(pool);
-        }
         this.port = port;
-        this.threadPool = pool;
         ListenerManager listenerManager = configurationContext.getListenerManager();
         TransportInDescription trsIn = new TransportInDescription(
                 new QName(Constants.TRANSPORT_HTTP));
@@ -162,7 +151,7 @@
         try {
             SimpleHTTPServer receiver = new SimpleHTTPServer(
                     ConfigurationContextFactory.createConfigurationContextFromFileSystem(
-                            args[0], null), port, null);
+                            args[0], null), port);
             Runtime.getRuntime().addShutdownHook(new ShutdownThread(receiver));
             receiver.start();
             System.out.println("[SimpleHTTPServer] Started");
@@ -186,8 +175,9 @@
      */
     public void start() throws AxisFault {
         try {
-            embedded = new SimpleHttpServer(port, this.threadPool);
-            embedded.setRequestHandler(new HTTPWorker(configurationContext));
+            embedded = new SimpleHttpServer(new HTTPWorkerFactory(configurationContext), port);
+            embedded.init();
+            embedded.start();
         } catch (IOException e) {
             log.error(e);
             throw new AxisFault(e);
@@ -202,7 +192,11 @@
     public void stop() {
         System.out.println("[SimpleHTTPServer] Stop called");
         if (embedded != null) {
-            embedded.destroy();
+            try {
+                embedded.destroy();
+            } catch (Exception e) {
+                log.error(e);
+            }
         }
     }
 
@@ -241,14 +235,14 @@
             localAddress = ip;
         } else {
             try {
-                localAddress = SimpleHttpServerConnection.getIpAddress();
+                localAddress = HttpUtils.getIpAddress();
             } catch (SocketException e) {
                 throw AxisFault.makeFault(e);
             }
         }
         if (embedded != null) {
             return new EndpointReference("http://" + localAddress + ":" +
-                    (embedded.getLocalPort())
+                    (embedded.getPort())
                     + "/axis2/services/" + serviceName);
         } else {
             throw new AxisFault("Unable to generate EPR for the transport : http");
Index: src/org/apache/axis2/transport/http/server/WorkerFactory.java
===================================================================
--- src/org/apache/axis2/transport/http/server/WorkerFactory.java	(revision 0)
+++ src/org/apache/axis2/transport/http/server/WorkerFactory.java	(revision 0)
@@ -0,0 +1,34 @@
+/*
+* $HeadURL$
+* $Revision$
+* $Date$
+*
+* ====================================================================
+*
+*  Copyright 1999-2004 The Apache Software Foundation
+*
+*  Licensed under the Apache License, Version 2.0 (the "License");
+*  you may not use this file except in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing, software
+*  distributed under the License is distributed on an "AS IS" BASIS,
+*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+*  See the License for the specific language governing permissions and
+*  limitations under the License.
+* ====================================================================
+*
+* This software consists of voluntary contributions made by many
+* individuals on behalf of the Apache Software Foundation.  For more
+* information on the Apache Software Foundation, please see
+* <http://www.apache.org/>.
+*/
+package org.apache.axis2.transport.http.server;
+
+public interface WorkerFactory {
+
+    Worker newWorker();    
+    
+}

Property changes on: src/org/apache/axis2/transport/http/server/WorkerFactory.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL
Name: svn:eol-style
   + native

Index: src/org/apache/axis2/transport/http/server/DefaultThreadFactory.java
===================================================================
--- src/org/apache/axis2/transport/http/server/DefaultThreadFactory.java	(revision 0)
+++ src/org/apache/axis2/transport/http/server/DefaultThreadFactory.java	(revision 0)
@@ -0,0 +1,58 @@
+/*
+* $HeadURL$
+* $Revision$
+* $Date$
+*
+* ====================================================================
+*
+*  Copyright 1999-2004 The Apache Software Foundation
+*
+*  Licensed under the Apache License, Version 2.0 (the "License");
+*  you may not use this file except in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing, software
+*  distributed under the License is distributed on an "AS IS" BASIS,
+*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+*  See the License for the specific language governing permissions and
+*  limitations under the License.
+* ====================================================================
+*
+* This software consists of voluntary contributions made by many
+* individuals on behalf of the Apache Software Foundation.  For more
+* information on the Apache Software Foundation, please see
+* <http://www.apache.org/>.
+*/
+
+package org.apache.axis2.transport.http.server;
+
+import edu.emory.mathcs.backport.java.util.concurrent.ThreadFactory;
+import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicInteger;
+
+public class DefaultThreadFactory implements ThreadFactory {
+
+    final ThreadGroup group;
+    final AtomicInteger count;
+    final String namePrefix;
+	
+    public DefaultThreadFactory(final ThreadGroup group, final String namePrefix) {
+        super();
+        this.count = new AtomicInteger(1);
+        this.group = group;
+        this.namePrefix = namePrefix;
+    }
+
+    public Thread newThread(final Runnable runnable) {
+    	StringBuffer buffer = new StringBuffer();
+    	buffer.append(this.namePrefix);
+    	buffer.append('-');
+    	buffer.append(this.count.getAndIncrement());
+        Thread t = new Thread(group, runnable, buffer.toString(), 0);
+        t.setDaemon(false);
+        t.setPriority(Thread.NORM_PRIORITY);
+        return t;
+    }
+        
+}

Property changes on: src/org/apache/axis2/transport/http/server/DefaultThreadFactory.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL
Name: svn:eol-style
   + native

Index: src/org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java
===================================================================
--- src/org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java	(revision 0)
+++ src/org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java	(revision 0)
@@ -0,0 +1,145 @@
+/*
+* $HeadURL$
+* $Revision$
+* $Date$
+*
+* ====================================================================
+*
+*  Copyright 1999-2004 The Apache Software Foundation
+*
+*  Licensed under the Apache License, Version 2.0 (the "License");
+*  you may not use this file except in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing, software
+*  distributed under the License is distributed on an "AS IS" BASIS,
+*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+*  See the License for the specific language governing permissions and
+*  limitations under the License.
+* ====================================================================
+*
+* This software consists of voluntary contributions made by many
+* individuals on behalf of the Apache Software Foundation.  For more
+* information on the Apache Software Foundation, please see
+* <http://www.apache.org/>.
+*/
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.Header;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpServerConnection;
+import org.apache.http.HttpVersion;
+import org.apache.http.RequestLine;
+import org.apache.http.UnsupportedHttpVersionException;
+import org.apache.http.protocol.HttpContext;
+import org.apache.http.protocol.HttpService;
+
+public class DefaultHttpServiceProcessor extends HttpService implements IOProcessor {
+
+    private static final Log LOG = LogFactory.getLog(DefaultHttpServiceProcessor.class);
+    private static final Log HEADERLOG = LogFactory.getLog("org.apache.axis2.transport.http.server.wire");
+    
+    private final Worker worker;
+    private final IOProcessorCallback callback;
+    
+    public DefaultHttpServiceProcessor(
+            final HttpServerConnection conn, 
+            final Worker worker,
+            final IOProcessorCallback callback) {
+        super(conn);
+        if (worker == null) {
+            throw new IllegalArgumentException("Worker may not be null");
+        }
+        this.worker = worker;
+        this.callback = callback;
+    }
+    
+    protected void postprocessResponse(final HttpResponse response, final HttpContext context) 
+            throws IOException, HttpException {
+        super.postprocessResponse(response, context);
+        if (HEADERLOG.isDebugEnabled()) {
+            HEADERLOG.debug("<< " + response.getStatusLine().toString());
+            Header[] headers = response.getAllHeaders();
+            for (int i = 0; i < headers.length; i++) {
+                HEADERLOG.debug("<< " + headers[i].toString());
+            }
+        }
+    }
+
+    protected void preprocessRequest(final HttpRequest request, final HttpContext context) 
+            throws IOException, HttpException {
+        super.preprocessRequest(request, context);
+        if (HEADERLOG.isDebugEnabled()) {
+            HEADERLOG.debug(">> " + request.getRequestLine().toString());
+            Header[] headers = request.getAllHeaders();
+            for (int i = 0; i < headers.length; i++) {
+                HEADERLOG.debug(">> " + headers[i].toString());
+            }
+        }
+    }
+
+    protected void doService(final HttpRequest request, final HttpResponse response) 
+            throws HttpException, IOException {
+        RequestLine reqline = request.getRequestLine();
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Request method: " + reqline.getMethod());
+            LOG.debug("Target URI: " + reqline.getUri());
+        }
+        
+        HttpVersion ver = reqline.getHttpVersion();
+        if (!ver.lessEquals(HttpVersion.HTTP_1_1)) {
+            throw new UnsupportedHttpVersionException("Unsupported HTTP version: " + ver); 
+        }
+        this.worker.service(request, response);
+    }
+    
+    protected void logIOException(final IOException ex) {
+        if (ex instanceof SocketTimeoutException) {
+            LOG.debug(ex.getMessage());
+        } else if (ex instanceof SocketException) {
+            LOG.debug(ex.getMessage());
+        }
+        else {
+            LOG.warn(ex.getMessage(), ex);
+        }
+    }
+
+    protected void logMessage(final String s) {
+        LOG.debug(s);
+    }
+
+    protected void logProtocolException(final HttpException ex) {
+        if (LOG.isWarnEnabled()) {
+            LOG.warn("HTTP protocol error: " + ex.getMessage());
+        }
+    }
+
+    public void close() throws IOException {
+        closeConnection();
+    }
+
+    public void run() {
+        LOG.debug("New connection thread");
+        try {
+            while (!Thread.interrupted() && !isDestroyed() && isActive()) {
+                handleRequest();
+            }
+        } finally {
+            destroy();
+            if (this.callback != null) {
+                this.callback.completed(this);
+            }
+        }
+    }
+                   
+}

Property changes on: src/org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL
Name: svn:eol-style
   + native

Index: src/org/apache/axis2/transport/http/server/Worker.java
===================================================================
--- src/org/apache/axis2/transport/http/server/Worker.java	(revision 0)
+++ src/org/apache/axis2/transport/http/server/Worker.java	(revision 0)
@@ -0,0 +1,41 @@
+/*
+* $HeadURL$
+* $Revision$
+* $Date$
+*
+* ====================================================================
+*
+*  Copyright 1999-2004 The Apache Software Foundation
+*
+*  Licensed under the Apache License, Version 2.0 (the "License");
+*  you may not use this file except in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing, software
+*  distributed under the License is distributed on an "AS IS" BASIS,
+*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+*  See the License for the specific language governing permissions and
+*  limitations under the License.
+* ====================================================================
+*
+* This software consists of voluntary contributions made by many
+* individuals on behalf of the Apache Software Foundation.  For more
+* information on the Apache Software Foundation, please see
+* <http://www.apache.org/>.
+*/
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+
+public interface Worker {
+
+    void service(HttpRequest request, HttpResponse response) 
+        throws HttpException, IOException;    
+    
+}

Property changes on: src/org/apache/axis2/transport/http/server/Worker.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL
Name: svn:eol-style
   + native

Index: src/org/apache/axis2/transport/http/server/DefaultConnectionListener.java
===================================================================
--- src/org/apache/axis2/transport/http/server/DefaultConnectionListener.java	(revision 0)
+++ src/org/apache/axis2/transport/http/server/DefaultConnectionListener.java	(revision 0)
@@ -0,0 +1,125 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketException;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.HttpServerConnection;
+
+public class DefaultConnectionListener implements IOProcessor {
+
+    private static Log LOG = LogFactory.getLog(DefaultConnectionListener.class);
+	
+    private volatile boolean destroyed = false;
+    
+    private final HttpConnectionFactory connfactory;
+    private final HttpConnectionManager connmanager;
+    private final ServerSocket serversocket;
+        
+    public DefaultConnectionListener(
+    		int port,
+            final HttpConnectionFactory connfactory,
+            final HttpConnectionManager connmanager) throws IOException {
+    	super();
+        if (connfactory == null) {
+            throw new IllegalArgumentException("Connection factory may not be null");
+        }
+        if (connmanager == null) {
+            throw new IllegalArgumentException("Connection manager may not be null");
+        }
+        this.connmanager = connmanager;
+        this.connfactory = connfactory;
+        this.serversocket = new ServerSocket(port);
+    }
+
+    public void run() {
+    	if (LOG.isInfoEnabled()) {
+            LOG.info("Listening on port " + this.serversocket.getLocalPort());
+    	}
+        try {
+            while (!this.serversocket.isClosed() && !Thread.interrupted()) {
+                try {
+                    LOG.debug("Waiting for incoming HTTP connection");
+                    Socket socket = this.serversocket.accept();
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug("Incoming HTTP connection from " + 
+                        		socket.getRemoteSocketAddress());
+                    }
+                    HttpServerConnection conn = this.connfactory.newConnection(socket);
+                    this.connmanager.process(conn);
+                } catch (IOException ex) {
+                    if (ex instanceof SocketException) {
+                        if (LOG.isDebugEnabled() 
+                                && !this.destroyed && !Thread.interrupted()) {
+                            LOG.debug("Connection listener terminated due to an I/O error: " + 
+                                    ex.getMessage());
+                        }
+                    } else {
+                        if (LOG.isWarnEnabled()) {
+                            LOG.warn("Connection listener terminated due to an I/O error: " + 
+                                    ex.getMessage(), ex);
+                        }
+                    }
+                    break;
+                } catch (Throwable ex) {
+                    LOG.error("Connection listener terminated due to a runtime error", ex);
+                    break;
+                }
+            }
+        } finally {
+            destroy();
+        }
+    }
+    
+	public void close() throws IOException {
+        this.serversocket.close();
+	}
+    
+    public void destroy() {
+        this.destroyed = true;
+        try {
+            close();
+        } catch (IOException ex) {
+            if (LOG.isWarnEnabled()) {
+                LOG.warn("I/O error closing listener", ex);
+            }
+        }
+    }
+
+    public boolean isDestroyed() {
+        return this.destroyed;
+    }
+    
+}

Property changes on: src/org/apache/axis2/transport/http/server/DefaultConnectionListener.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL
Name: svn:eol-style
   + native

Index: src/org/apache/axis2/transport/http/server/IOProcessorCallback.java
===================================================================
--- src/org/apache/axis2/transport/http/server/IOProcessorCallback.java	(revision 0)
+++ src/org/apache/axis2/transport/http/server/IOProcessorCallback.java	(revision 0)
@@ -0,0 +1,36 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+public interface IOProcessorCallback {
+
+    void completed(IOProcessor processor);
+    
+}

Property changes on: src/org/apache/axis2/transport/http/server/IOProcessorCallback.java
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL
Name: svn:eol-style
   + native

Index: src/org/apache/axis2/transport/http/server/HttpConnectionFactory.java
===================================================================
--- src/org/apache/axis2/transport/http/server/HttpConnectionFactory.java	(revision 0)
+++ src/org/apache/axis2/transport/http/server/HttpConnectionFactory.java	(revision 0)
@@ -0,0 +1,41 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+import java.net.Socket;
+
+import org.apache.http.HttpServerConnection;
+
+public interface HttpConnectionFactory {
+
+    HttpServerConnection newConnection(Socket socket) throws IOException;
+    
+}

Property changes on: src/org/apache/axis2/transport/http/server/HttpConnectionFactory.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL
Name: svn:eol-style
   + native

Index: src/org/apache/axis2/transport/http/server/HttpConnectionManager.java
===================================================================
--- src/org/apache/axis2/transport/http/server/HttpConnectionManager.java	(revision 0)
+++ src/org/apache/axis2/transport/http/server/HttpConnectionManager.java	(revision 0)
@@ -0,0 +1,40 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import org.apache.http.HttpServerConnection;
+
+public interface HttpConnectionManager {
+
+    void process(HttpServerConnection incoming);
+    
+    void shutdown();
+    
+}

Property changes on: src/org/apache/axis2/transport/http/server/HttpConnectionManager.java
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL
Name: svn:eol-style
   + native

Index: src/org/apache/axis2/transport/http/server/DefaultHttpConnectionFactory.java
===================================================================
--- src/org/apache/axis2/transport/http/server/DefaultHttpConnectionFactory.java	(revision 0)
+++ src/org/apache/axis2/transport/http/server/DefaultHttpConnectionFactory.java	(revision 0)
@@ -0,0 +1,58 @@
+/*
+ * $HeadURL:https://svn.apache.org/repos/asf/jakarta/httpcomponents/trunk/coyote-httpconnector/src/java/org/apache/http/tcconnector/impl/DefaultHttpConnectionFactory.java $
+ * $Revision:379772 $
+ * $Date:2006-02-22 14:52:29 +0100 (Wed, 22 Feb 2006) $
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+import java.net.Socket;
+
+import org.apache.http.HttpServerConnection;
+import org.apache.http.impl.DefaultHttpServerConnection;
+import org.apache.http.params.HttpParams;
+
+public class DefaultHttpConnectionFactory implements HttpConnectionFactory {
+
+	final HttpParams params;
+	
+    public DefaultHttpConnectionFactory(final HttpParams params) {
+        super();
+        if (params == null) {
+            throw new IllegalArgumentException("HTTP parameters may not be null");
+        }
+        this.params = params;
+    }
+    
+    public HttpServerConnection newConnection(final Socket socket)
+            throws IOException {
+        DefaultHttpServerConnection conn = new DefaultHttpServerConnection();
+        conn.bind(socket, this.params);
+        return conn;
+    }
+    
+}

Property changes on: src/org/apache/axis2/transport/http/server/DefaultHttpConnectionFactory.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL
Name: svn:eol-style
   + native

Index: src/org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java
===================================================================
--- src/org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java	(revision 0)
+++ src/org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java	(revision 0)
@@ -0,0 +1,138 @@
+/*
+ * $HeadURL:https://svn.apache.org/repos/asf/jakarta/httpcomponents/trunk/coyote-httpconnector/src/java/org/apache/http/tcconnector/impl/DefaultHttpConnectionManager.java $
+ * $Revision:379772 $
+ * $Date:2006-02-22 14:52:29 +0100 (Wed, 22 Feb 2006) $
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.HttpServerConnection;
+import org.apache.http.params.HttpParams;
+import org.apache.http.protocol.ResponseConnControl;
+import org.apache.http.protocol.ResponseContent;
+import org.apache.http.protocol.ResponseDate;
+import org.apache.http.protocol.ResponseServer;
+
+import edu.emory.mathcs.backport.java.util.concurrent.Executor;
+
+public class DefaultHttpConnectionManager implements HttpConnectionManager {
+
+    private static Log LOG = LogFactory.getLog(DefaultHttpConnectionManager.class);
+    
+    private final Executor executor;
+    private final WorkerFactory workerfactory;
+    private final HttpParams params;
+    private final List processors;
+    
+    public DefaultHttpConnectionManager(
+    		final Executor executor,
+            final WorkerFactory workerfactory,
+    		final HttpParams params) {
+        super();
+        if (executor == null) {
+            throw new IllegalArgumentException("Executor may not be null");
+        }
+        if (workerfactory == null) {
+            throw new IllegalArgumentException("Worker factory may not be null");
+        }
+        if (params == null) {
+            throw new IllegalArgumentException("HTTP parameters may not be null");
+        }
+        this.executor = executor;
+        this.workerfactory = workerfactory;
+        this.params = params;
+        this.processors = new LinkedList();
+    }
+
+    private synchronized void cleanup() {
+        for (Iterator i = this.processors.iterator(); i.hasNext(); ) {
+            IOProcessor processor = (IOProcessor) i.next();
+            if (processor.isDestroyed()) {
+                i.remove();
+            }
+        }
+    }
+    
+    private synchronized void addProcessor(final IOProcessor processor) {
+        if (processor == null) {
+            return;
+        }
+        this.processors.add(processor);
+    }
+    
+    private synchronized void removeProcessor(final IOProcessor processor) {
+        if (processor == null) {
+            return;
+        }
+        this.processors.remove(processor);
+    }
+    
+    public void process(final HttpServerConnection conn) {
+        if (conn == null) {
+            throw new IllegalArgumentException("HTTP connection may not be null");
+        }
+        // Evict destroyed processors
+        cleanup();
+        
+        IOProcessorCallback callback = new IOProcessorCallback() {
+          
+            public void completed(final IOProcessor processor) {
+                removeProcessor(processor);
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(processor + " terminated");
+                }
+            }
+            
+        };
+        DefaultHttpServiceProcessor processor = new DefaultHttpServiceProcessor(
+                conn, this.workerfactory.newWorker(), callback);
+
+        processor.setParams(this.params);
+        // Add required protocol interceptors
+        processor.addInterceptor(new ResponseDate());
+        processor.addInterceptor(new ResponseServer());                    
+        processor.addInterceptor(new ResponseContent());
+        processor.addInterceptor(new ResponseConnControl());
+        
+        addProcessor(processor);
+        this.executor.execute(processor);
+    }
+    
+    public synchronized void shutdown() {
+        for (int i = 0; i < this.processors.size(); i++) {
+            IOProcessor processor = (IOProcessor) this.processors.get(i);
+            processor.destroy();
+        }
+        this.processors.clear();
+    }
+	
+}

Property changes on: src/org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL
Name: svn:eol-style
   + native

Index: src/org/apache/axis2/transport/http/server/HttpUtils.java
===================================================================
--- src/org/apache/axis2/transport/http/server/HttpUtils.java	(revision 0)
+++ src/org/apache/axis2/transport/http/server/HttpUtils.java	(revision 0)
@@ -0,0 +1,109 @@
+/*
+* $HeadURL$
+* $Revision$
+* $Date$
+*
+* ====================================================================
+*
+*  Copyright 1999-2004 The Apache Software Foundation
+*
+*  Licensed under the Apache License, Version 2.0 (the "License");
+*  you may not use this file except in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing, software
+*  distributed under the License is distributed on an "AS IS" BASIS,
+*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+*  See the License for the specific language governing permissions and
+*  limitations under the License.
+* ====================================================================
+*
+* This software consists of voluntary contributions made by many
+* individuals on behalf of the Apache Software Foundation.  For more
+* information on the Apache Software Foundation, please see
+* <http://www.apache.org/>.
+*/
+package org.apache.axis2.transport.http.server;
+
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.util.Enumeration;
+
+import org.apache.axis2.transport.http.HTTPConstants;
+import org.apache.http.Header;
+import org.apache.http.HttpRequest;
+
+public class HttpUtils {
+    
+    private HttpUtils() {
+    }
+
+    public static String getCookieID(final HttpRequest request) {
+        if (request == null) {
+            return null;
+        }
+        Header header = request.getFirstHeader(HTTPConstants.HEADER_COOKIE);
+        if (header == null) {
+            header = request.getFirstHeader(HTTPConstants.HEADER_COOKIE2);
+        }
+        if (header == null) {
+            return null;
+        } else {
+            return header.getValue();
+        }
+    }
+    
+    public static String getSoapAction(final HttpRequest request) {
+        if (request == null) {
+            return null;
+        }
+        Header header = request.getFirstHeader(HTTPConstants.HEADER_SOAP_ACTION);
+        if (header != null) {
+            return header.getValue();
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the ip address to be used for the replyto epr
+     * CAUTION:
+     * This will go through all the available network interfaces and will try to return an ip address.
+     * First this will try to get the first IP which is not loopback address (127.0.0.1). If none is found
+     * then this will return this will return 127.0.0.1.
+     * This will <b>not<b> consider IPv6 addresses.
+     * <p/>
+     * TODO:
+     * - Improve this logic to genaralize it a bit more
+     * - Obtain the ip to be used here from the Call API
+     *
+     * @return Returns String.
+     * @throws SocketException
+     */
+    public static String getIpAddress() throws SocketException {
+        Enumeration e = NetworkInterface.getNetworkInterfaces();
+        String address = "127.0.0.1";
+
+        while (e.hasMoreElements()) {
+            NetworkInterface netface = (NetworkInterface) e.nextElement();
+            Enumeration addresses = netface.getInetAddresses();
+
+            while (addresses.hasMoreElements()) {
+                InetAddress ip = (InetAddress) addresses.nextElement();
+                if (!ip.isLoopbackAddress() && isIP(ip.getHostAddress())) {
+                    return ip.getHostAddress();
+                }
+            }
+        }
+
+        return address;
+    }
+
+    private static boolean isIP(String hostAddress) {
+        return hostAddress.split("[.]").length == 4;
+    }
+    
+}

Property changes on: src/org/apache/axis2/transport/http/server/HttpUtils.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL
Name: svn:eol-style
   + native

Index: src/org/apache/axis2/transport/http/server/IOProcessor.java
===================================================================
--- src/org/apache/axis2/transport/http/server/IOProcessor.java	(revision 0)
+++ src/org/apache/axis2/transport/http/server/IOProcessor.java	(revision 0)
@@ -0,0 +1,42 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+
+public interface IOProcessor extends Runnable {
+
+    void close() throws IOException;
+    
+    boolean isDestroyed();
+    
+    void destroy();
+    
+}

Property changes on: src/org/apache/axis2/transport/http/server/IOProcessor.java
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL
Name: svn:eol-style
   + native

Index: src/org/apache/axis2/transport/http/server/SimpleHttpServer.java
===================================================================
--- src/org/apache/axis2/transport/http/server/SimpleHttpServer.java	(revision 408643)
+++ src/org/apache/axis2/transport/http/server/SimpleHttpServer.java	(working copy)
@@ -1,5 +1,5 @@
 /*
-* $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//httpclient/src/test/org/apache/commons/httpclient/server/SimpleHttpServer.java,v 1.15 2004/12/11 22:35:26 olegk Exp $
+* $HeadURL$
 * $Revision: 155418 $
 * $Date: 2005-02-26 08:01:52 -0500 (Sat, 26 Feb 2005) $
 *
@@ -30,232 +30,126 @@
 
 package org.apache.axis2.transport.http.server;
 
-import org.apache.axis2.util.threadpool.ThreadFactory;
-import org.apache.axis2.util.threadpool.ThreadPool;
+import java.io.IOException;
+
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.http.impl.DefaultHttpParams;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.params.HttpProtocolParams;
 
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
+import edu.emory.mathcs.backport.java.util.concurrent.ExecutorService;
+import edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingQueue;
+import edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor;
+import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
 
 /**
- * A simple, but extensible HTTP server, mostly for testing purposes.
+ * A simple, but extensible HTTP server.
  */
-public class SimpleHttpServer implements Runnable {
-	private static final Log log = LogFactory.getLog(SimpleHttpServer.class);
-    private String testname = "Simple test";
-    private ServerSocket listener = null;
-    private long count = 0;
-    private ThreadFactory threadPool = null;
-    private boolean stopped = false;
-    private HttpRequestHandler requestHandler = null;
-    private SimpleConnSet connectionsPool = new SimpleConnSet();
-    private Thread t;
+public class SimpleHttpServer {
 
-    /**
-     * Creates a new HTTP server instance, using an arbitrary free TCP port
-     *
-     * @throws IOException if anything goes wrong during initialization
-     */
-    public SimpleHttpServer() throws IOException {
-        this(null, 0, null);
-    }
+    private static Log LOG = LogFactory.getLog(SimpleHttpServer.class);
+    
+    private static final String ORIGIN_SERVER = "Simple-Server/1.1";
+    private static final int SHUTDOWN_GRACE_PERIOD = 3000; // ms
+    
+    private final int port;
+    private final HttpParams params;
+    private final WorkerFactory workerfactory;
 
-    /**
-     * Creates a new HTTP server instance, using the specified TCP port
-     *
-     * @param port Desired TCP port
-     * @throws IOException if anything goes wrong during initialization
-     */
-    public SimpleHttpServer(int port) throws IOException {
-        this(null, port, null);
-    }
+    private int minThreads = 25;
+    private int maxThreads = 150;
+    
+    private IOProcessor listener = null;
+    private ExecutorService listenerExecutor = null;
+    private ThreadGroup listenertg = null;
+    private HttpConnectionManager connmanager = null;
+    private ExecutorService requestExecutor = null;
+    private ThreadGroup conntg = null;
 
-    /**
-     * Creates a new HTTP server instance, using the specified TCP port
-     *
-     * @param port       Desired TCP port
-     * @param threadPool ThreadPool to be used.
-     * @throws IOException if anything goes wrong during initialization
-     */
-    public SimpleHttpServer(int port, ThreadFactory threadPool) throws IOException {
-        this(null, port, threadPool);
-    }
-
-    /**
-     * Creates a new HTTP server instance, using the specified socket
-     * factory and the TCP port
-     *
-     * @param port Desired TCP port
-     * @throws IOException if anything goes wrong during initialization
-     */
-    public SimpleHttpServer(SimpleSocketFactory socketfactory, int port) throws IOException {
-        this(socketfactory, port, null);
-    }
-
-    /**
-     * Creates a new HTTP server instance, using the specified socket
-     * factory and the TCP port that uses the given ThreadPool. If a
-     * ThreadPool is not given then a new default axis2 ThreadPool will be
-     * used.
-     *
-     * @param port       Desired TCP port
-     * @param threadPool ThreadPool to be used inside the SimpleHttpServer. The
-     *                   threadPool object that is provided needs to implement
-     *                   tp.execute(Runnable r)
-     * @throws IOException if anything goes wrong during initialization
-     */
-    public SimpleHttpServer(SimpleSocketFactory socketfactory, int port, ThreadFactory threadPool)
-            throws IOException {
-        if (socketfactory == null) {
-            socketfactory = new SimplePlainSocketFactory();
+    public SimpleHttpServer(final WorkerFactory workerfactory, int port) throws IOException {
+        super();
+        if (workerfactory == null) {
+            throw new IllegalArgumentException("Worker factory may not be null");
         }
-
-        if (threadPool == null) {
-            threadPool = new ThreadPool();
-        }
-
-        this.threadPool = threadPool;
-        listener = socketfactory.createServerSocket(port);
-
-        if (log.isDebugEnabled()) {
-            log.debug("Starting test HTTP server on port " + getLocalPort());
-        }
-
-        t = new Thread(this);
-        t.start();
+        this.params = new DefaultHttpParams(); 
+        this.params
+            .setIntParameter(HttpConnectionParams.SO_TIMEOUT, 20000)
+            .setBooleanParameter(HttpConnectionParams.TCP_NODELAY, true) 
+            .setParameter(HttpProtocolParams.ORIGIN_SERVER, ORIGIN_SERVER);
+        this.workerfactory = workerfactory;
+        this.port = port;
     }
 
-    /**
-     * Stops this HTTP server instance.
-     */
-    public synchronized void destroy() {
-        if (stopped) {
-            return;
-        }
+    public void init() throws IOException {
+        this.conntg = new ThreadGroup("Connection thread group");
+        
+        this.requestExecutor = new ThreadPoolExecutor(
+                this.minThreads, this.maxThreads,
+                180L, TimeUnit.SECONDS,
+                new LinkedBlockingQueue(),
+                new DefaultThreadFactory(this.conntg, "HttpConnection-" + this.port));
+        
+        this.connmanager = new DefaultHttpConnectionManager( 
+                this.requestExecutor,
+                this.workerfactory, 
+                this.params);
 
-        this.stopped = true;
-
-        if (log.isDebugEnabled()) {
-            log.debug("Stopping test HTTP server on port " + getLocalPort());
-        }
-
-        t.interrupt();
-
-        if (listener != null) {
-            try {
-                listener.close();
-            } catch (IOException e) {
-            }
-        }
-
-        this.connectionsPool.shutdown();
+        this.listenertg = new ThreadGroup("Listener thread group");
+        
+        this.listenerExecutor = new ThreadPoolExecutor(
+                1, 1,
+                0L, TimeUnit.MILLISECONDS,
+                new LinkedBlockingQueue(),
+                new DefaultThreadFactory(this.listenertg, "HttpListener-" + this.port));
+        
+        HttpConnectionFactory connfactory = new DefaultHttpConnectionFactory(
+                this.params);
+        
+        this.listener = new DefaultConnectionListener(
+                this.port,
+                connfactory, 
+                this.connmanager);
     }
-
-    public void run() {
-        try {
-            while (!this.stopped && !Thread.interrupted()) {
-                Socket socket = listener.accept();
-
-                try {
-                    if (this.requestHandler == null) {
-                        socket.close();
-
-                        break;
-                    }
-
-                    SimpleHttpServerConnection conn = new SimpleHttpServerConnection(socket);
-
-                    this.connectionsPool.addConnection(conn);
-                    this.threadPool.execute(new SimpleConnectionThread(this.testname + " thread "
-                            + this.count, conn, this.connectionsPool, this.requestHandler));
-                } catch (IOException e) {
-                    log.debug("I/O error: " + e.getMessage());
-                }
-
-                this.count++;
-                Thread.sleep(100);
-            }
-        } catch (InterruptedException accept) {
+    
+    public void destroy() throws IOException, InterruptedException {
+        // Attempt to terminate the listener nicely
+        LOG.info("Shut down connection listener");
+        this.listenerExecutor.shutdownNow();
+        this.listener.destroy();
+        this.listenerExecutor.awaitTermination(SHUTDOWN_GRACE_PERIOD, TimeUnit.MILLISECONDS);
+        if (!this.listenerExecutor.isTerminated()) {
+            // Terminate the listener forcibly
+            LOG.info("Force shut down connection listener");
+            this.listener.destroy();
+            // Leave it up to the garbage collector to clean up the mess
+            this.listener = null;
         }
-        catch (IOException e) {
-            if (!stopped) {
-                log.debug("I/O error: " + e.getMessage());
-            }
-        } finally {
-            destroy();
+        // Attempt to terminate the active processors nicely
+        LOG.info("Shut down HTTP processors");
+        this.requestExecutor.shutdownNow();
+        this.requestExecutor.awaitTermination(SHUTDOWN_GRACE_PERIOD, TimeUnit.MILLISECONDS);
+        if (!this.requestExecutor.isTerminated()) {
+            // Terminate the active processors forcibly
+            LOG.info("Force shut down HTTP processors");
+            this.connmanager.shutdown();
+            // Leave it up to the garbage collector to clean up the mess
+            this.connmanager = null;
         }
+        LOG.info("HTTP protocol handler shut down");
     }
-
-    /**
-     * Returns the IP address that this HTTP server instance is bound to.
-     *
-     * @return String representation of the IP address or <code>null</code> if not running
-     */
-    public String getLocalAddress() {
-        InetAddress address = listener.getInetAddress();
-
-        // Ugly work-around for older JDKs
-        byte[] octets = address.getAddress();
-
-        if ((octets[0] == 0) && (octets[1] == 0) && (octets[2] == 0) && (octets[3] == 0)) {
-            return "localhost";
-        } else {
-            return address.getHostAddress();
-        }
+    
+    public void start() {
+        this.listenerExecutor.execute(this.listener);
     }
-
-    /**
-     * Returns the TCP port that this HTTP server instance is bound to.
-     *
-     * @return TCP port, or -1 if not running
-     */
-    public int getLocalPort() {
-        return listener.getLocalPort();
-    }
-
-    /**
-     * Returns the currently used HttpRequestHandler by this SimpleHttpServer
-     *
-     * @return The used HttpRequestHandler, or null.
-     */
-    public HttpRequestHandler getRequestHandler() {
-        return requestHandler;
-    }
-
-    public String getTestname() {
-        return this.testname;
-    }
-
-    /**
-     * Checks if this HTTP server instance is running.
-     *
-     * @return true/false
-     */
+    
     public boolean isRunning() {
-        if (t == null) {
-            return false;
-        }
-
-        return t.isAlive();
+        return this.listenerExecutor != null && !this.listenerExecutor.isShutdown();
     }
 
-    public void setHttpService(HttpService service) {
-        setRequestHandler(new HttpServiceHandler(service));
+    public int getPort() {
+        return this.port;
     }
-
-    /**
-     * Sets the HttpRequestHandler to be used for this SimpleHttpServer.
-     *
-     * @param rh Request handler to be used, or null to disable.
-     */
-    public void setRequestHandler(HttpRequestHandler rh) {
-        this.requestHandler = rh;
-    }
-
-    public void setTestname(final String testname) {
-        this.testname = testname;
-    }
+    
 }
Index: src/org/apache/axis2/transport/http/server/OutputBuffer.java
===================================================================
--- src/org/apache/axis2/transport/http/server/OutputBuffer.java	(revision 0)
+++ src/org/apache/axis2/transport/http/server/OutputBuffer.java	(revision 0)
@@ -0,0 +1,151 @@
+/*
+* $HeadURL$
+* $Revision$
+* $Date$
+*
+* ====================================================================
+*
+*  Copyright 1999-2004 The Apache Software Foundation
+*
+*  Licensed under the Apache License, Version 2.0 (the "License");
+*  you may not use this file except in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing, software
+*  distributed under the License is distributed on an "AS IS" BASIS,
+*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+*  See the License for the specific language governing permissions and
+*  limitations under the License.
+* ====================================================================
+*
+* This software consists of voluntary contributions made by many
+* individuals on behalf of the Apache Software Foundation.  For more
+* information on the Apache Software Foundation, please see
+* <http://www.apache.org/>.
+*/
+package org.apache.axis2.transport.http.server;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import org.apache.axis2.transport.OutTransportInfo;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.io.ByteArrayBuffer;
+import org.apache.http.protocol.HTTP;
+
+public class OutputBuffer implements OutTransportInfo, HttpEntity {
+
+    private final ByteArrayBuffer buffer;
+    private String contentType;
+    private boolean chunked;
+    
+    public OutputBuffer(int initialCapacity) {
+        super();
+        this.buffer = new ByteArrayBuffer(initialCapacity);
+        this.contentType = "text/xml";
+    }
+    
+    public OutputBuffer() {
+        this(1024);
+    }
+
+    public OutputStream getOutputStream() {
+        return new BufferOutputStream(this.buffer);
+    }
+
+    public InputStream getContent() throws IOException, IllegalStateException {
+        return new ByteArrayInputStream(this.buffer.toByteArray());
+    }
+
+    public void setContentType(final String contentType) {
+        this.contentType = contentType;
+    }
+
+    public Header getContentType() {
+        return new Header(HTTP.CONTENT_TYPE, this.contentType);
+    }
+
+    public void consumeContent() throws IOException {
+    }
+
+    public Header getContentEncoding() {
+        return null;
+    }
+
+    public long getContentLength() {
+        return this.buffer.length();
+    }
+
+    public boolean isChunked() {
+        return this.chunked;
+    }
+
+    public void setChunked(boolean b) {
+        this.chunked = b;
+    }
+
+    public boolean isRepeatable() {
+        return true;
+    }
+
+    public boolean isStreaming() {
+        return false;
+    }
+
+    public void writeTo(final OutputStream outstream) throws IOException {
+        outstream.write(this.buffer.buffer(), 0, this.buffer.length());
+    }
+
+    public String toString() {
+        return new String(this.buffer.buffer(), 0, this.buffer.length());
+    }
+    
+    private static class BufferOutputStream extends OutputStream {
+
+        private final ByteArrayBuffer buffer;
+        private boolean closed = false;
+
+        public BufferOutputStream(final ByteArrayBuffer buffer) {
+            super();
+            this.buffer = buffer;
+        }
+        
+        public void close() throws IOException {
+            this.closed = true;
+        }
+
+        private void ensureNotClosed() {
+            if (this.closed) {
+                throw new IllegalStateException("Stream closed");
+            }
+        }
+        
+        public void write(byte[] b, int off, int len) throws IOException {
+            ensureNotClosed();
+            if (b == null) {
+                return;
+            }
+            this.buffer.append(b, off, len);
+        }
+
+        public void write(byte[] b) throws IOException {
+            ensureNotClosed();
+            if (b == null) {
+                return;
+            }
+            this.buffer.append(b, 0, b.length);
+        }
+
+        public void write(int b) throws IOException {
+            ensureNotClosed();
+            this.buffer.append(b);
+        }
+                
+    }
+    
+}

Property changes on: src/org/apache/axis2/transport/http/server/OutputBuffer.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL
Name: svn:eol-style
   + native

Index: src/org/apache/axis2/engine/AxisEngine.java
===================================================================
--- src/org/apache/axis2/engine/AxisEngine.java	(revision 408643)
+++ src/org/apache/axis2/engine/AxisEngine.java	(working copy)
@@ -202,10 +202,11 @@
         }
 
         EndpointReference faultTo = processingContext.getFaultTo();
+        SOAPEnvelope env = processingContext.getEnvelope();
         if (faultTo != null && !doNotSendFaultUsingFaultTo) {
             faultContext.setTo(processingContext.getFaultTo());
-        } else if (!doNotSendFaultUsingFaultTo && processingContext.isHeaderPresent() && processingContext.getEnvelope().getHeader().getFirstChildWithName(new QName("FaultTo")) != null) {
-            OMElement faultToElement = processingContext.getEnvelope().getHeader().getFirstChildWithName(new QName("FaultTo"));
+        } else if (env != null && !doNotSendFaultUsingFaultTo && processingContext.isHeaderPresent() && env.getHeader().getFirstChildWithName(new QName("FaultTo")) != null) {
+            OMElement faultToElement = env.getHeader().getFirstChildWithName(new QName("FaultTo"));
             faultTo = new EndpointReference("");
             faultTo.fromOM(faultToElement);
             faultContext.setTo(faultTo);
@@ -339,7 +340,7 @@
         }
 
         // defaulting to fault code Sender, if no message is available
-        if (faultCode == null) {
+        if (faultCode == null && context.getEnvelope() != null) {
             soapFaultCode = ("".equals(soapFaultCode) || (soapFaultCode == null))
                     ? getSenderFaultCode(context.getEnvelope().getNamespace())
                     : soapFaultCode;
