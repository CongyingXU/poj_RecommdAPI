Index: C:/workspace/live/axis2/modules/jaxws/test/server/EchoServiceSkeleton.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/server/EchoServiceSkeleton.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/server/EchoServiceSkeleton.java	(working copy)
@@ -27,4 +27,4 @@
         return output;
     }
 }
-    
+    
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/test/server/EchoStringResponse.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/server/EchoStringResponse.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/server/EchoStringResponse.java	(working copy)
@@ -106,4 +106,4 @@
 
 }
            
-          
+          
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/test/server/EchoString.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/server/EchoString.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/server/EchoString.java	(working copy)
@@ -130,4 +130,4 @@
         
         }
            
-          
+          
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/test/server/EchoServiceMessageReceiverInOut.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/server/EchoServiceMessageReceiverInOut.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/server/EchoServiceMessageReceiverInOut.java	(working copy)
@@ -160,4 +160,4 @@
         
 
         }
-    
+    
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/META-INF/services.xml
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/META-INF/services.xml	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/META-INF/services.xml	(working copy)
@@ -1,12 +1,12 @@
-<serviceGroup>
- <service name="EchoService">
-  <messageReceivers>
-   <messageReceiver mep="http://www.w3.org/2004/08/wsdl/in-out" class="server.EchoServiceMessageReceiverInOut"/>
-  </messageReceivers>
-  <parameter locked="false" name="ServiceClass">server.EchoServiceSkeleton</parameter>
-  <operation name="echoString" mep="http://www.w3.org/2004/08/wsdl/in-out">
-    <actionMapping/>
-  </operation>
- </service>
-</serviceGroup>
-
+<serviceGroup>
+ <service name="EchoService">
+  <messageReceivers>
+   <messageReceiver mep="http://www.w3.org/2004/08/wsdl/in-out" class="server.EchoServiceMessageReceiverInOut"/>
+  </messageReceivers>
+  <parameter locked="false" name="ServiceClass">server.EchoServiceSkeleton</parameter>
+  <operation name="echoString" mep="http://www.w3.org/2004/08/wsdl/in-out">
+    <actionMapping/>
+  </operation>
+ </service>
+</serviceGroup>
+
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/JAXBCallbackHandler.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/JAXBCallbackHandler.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/JAXBCallbackHandler.java	(working copy)
@@ -1,18 +1,34 @@
-package org.apache.axis2.jaxws;
-
-import javax.xml.ws.AsyncHandler;
-import javax.xml.ws.Response;
-
-import client.EchoStringResponse;
-
-public class JAXBCallbackHandler<T> implements AsyncHandler<T> {
-
-    public void handleResponse(Response response) {
-        try {
-            EchoStringResponse esr = (EchoStringResponse) response.get();
-            System.out.println(">> Async response received: " + esr.getEchoStringReturn());
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-}
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws;
+
+import javax.xml.ws.AsyncHandler;
+import javax.xml.ws.Response;
+
+import client.EchoStringResponse;
+
+public class JAXBCallbackHandler<T> implements AsyncHandler<T> {
+
+    public void handleResponse(Response response) {
+        try {
+            EchoStringResponse esr = (EchoStringResponse) response.get();
+            System.out.println(">> Async response received: " + esr.getEchoStringReturn());
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/description/WSDLDescriptionTests.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/description/WSDLDescriptionTests.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/description/WSDLDescriptionTests.java	(revision 0)
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.axis2.jaxws.description;
+
+import java.lang.reflect.Field;
+import java.net.URL;
+
+import javax.xml.namespace.QName;
+import javax.xml.ws.Service;
+
+import org.apache.axis2.jaxws.spi.ServiceDelegate;
+
+import junit.framework.TestCase;
+
+/**
+ * Directly test the Description classes built with a WSDL file.
+ */
+public class WSDLDescriptionTests extends TestCase {
+    
+    private static boolean setupDone = false;
+    private static Service service;
+    private static ServiceDelegate serviceDelegate;
+    private static ServiceDescription serviceDescription;
+
+
+    
+    protected void setUp() {
+        if (!setupDone) {
+            setupDone = true;
+            String namespaceURI= "http://ws.apache.org/axis2/tests";
+            String localPart = "EchoService";
+            service = Service.create(getWSDLURL(), new QName(namespaceURI, localPart));
+            serviceDelegate = getServiceDelegate(service);
+            serviceDescription = serviceDelegate.getServiceDescription();
+        }
+    }
+    
+    /* 
+     * ========================================================================
+     * ServiceDescription Tests
+     * ========================================================================
+     */
+    public void testValidServiceGetEndpoint() {
+        QName validPortQname = new QName("http://ws.apache.org/axis2/tests", "EchoPort");
+        EndpointDescription endpointDescription = serviceDescription.getEndpointDescription(validPortQname);
+        assertNotNull("EndpointDescription should be found", endpointDescription);
+    }
+
+    public void testInvalidLocalpartServiceGetEndpoint() {
+        QName validPortQname = new QName("http://ws.apache.org/axis2/tests", "InvalidEchoPort");
+        EndpointDescription endpointDescription = serviceDescription.getEndpointDescription(validPortQname);
+        assertNull("EndpointDescription should not be found", endpointDescription);
+    }
+
+    public void testInvalidNamespaceServiceGetEndpoint() {
+        QName validPortQname = new QName("http://ws.apache.org/axis2/tests/INVALID", "EchoPort");
+        EndpointDescription endpointDescription = serviceDescription.getEndpointDescription(validPortQname);
+        assertNull("EndpointDescription should not be found", endpointDescription);
+    }
+    
+    /*
+     * ========================================================================
+     * Test utility methods
+     * ========================================================================
+     */
+
+    private URL getWSDLURL() {
+        URL wsdlURL = null;
+        // Get the URL to the WSDL file.  Note that 'basedir' is setup by Maven
+        String basedir = System.getProperty("basedir");
+        String urlString = "file://localhost/" + basedir + "/test-resources/wsdl/WSDLTests.wsdl";
+        try {
+            wsdlURL = new URL(urlString);
+        } catch (Exception e) {
+            fail("Caught exception creating WSDL URL :" + urlString + "; exception: " + e.toString());
+        }
+        return wsdlURL;
+    }
+
+    private ServiceDelegate getServiceDelegate(Service service) {
+        // Need to get to the private Service._delegate field in order to get to the ServiceDescription to test
+        ServiceDelegate returnServiceDelegate = null;
+        try {
+            Field serviceDelgateField = service.getClass().getDeclaredField("_delegate");
+            serviceDelgateField.setAccessible(true);
+            returnServiceDelegate = (ServiceDelegate) serviceDelgateField.get(service);
+        } catch (SecurityException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        } catch (NoSuchFieldException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        return returnServiceDelegate;
+    }
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/description/ServiceDescriptionTests.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/description/ServiceDescriptionTests.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/description/ServiceDescriptionTests.java	(revision 0)
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.axis2.jaxws.description;
+
+import java.net.URL;
+
+import javax.xml.namespace.QName;
+import javax.xml.ws.WebServiceException;
+
+import junit.framework.TestCase;
+
+/**
+ * This test validates the error checking and internal functioning of the
+ * ServiceDescription class.  These tests are the construction of a
+ * a ServiceDescription.  Direct tests of the functionality of a ServiceDescription
+ * and other Description classes is done in WSDLDescriptionTests.
+ */
+public class ServiceDescriptionTests extends TestCase {
+    private static final String namespaceURI= "http://ws.apache.org/axis2/tests";
+    private static final String localPart = "EchoService";
+    private static final QName serviceQName = new QName(namespaceURI, localPart);
+    
+    public void testNullWSDL() {
+
+        ServiceDescription serviceDescription = new ServiceDescription(null, serviceQName, javax.xml.ws.Service.class);
+        assertNotNull("Service description not created with null WSDL", serviceDescription);
+    }
+    
+    public void testNullServiceName() {
+
+        try {
+            ServiceDescription serviceDescription = new ServiceDescription(null, null, javax.xml.ws.Service.class);
+            fail("Exception for null Service Name not thrown.");
+        }
+        catch (WebServiceException e) {
+            // Expected path
+            assertEquals("Did not receive correct exception", "Invalid Service QName; cannot be null", e.getMessage());
+        }
+    }
+    
+    public void testInvalidServiceClass() {
+        try {
+            ServiceDescription serviceDescription = new ServiceDescription(null, serviceQName, Object.class);
+            fail("Exception for invalid Service class not thrown.");
+        }
+        catch (WebServiceException e) {
+            // Expected path
+            assertEquals("Did not receive correct exception", "Invalid Service Class; must be assignable to javax.xml.ws.Service", e.getMessage());
+        }
+    }
+    
+    public void testNullServiceClass() {
+        try {
+            ServiceDescription serviceDescription = new ServiceDescription(null, serviceQName, null);
+            fail("Exception for invalid Service class not thrown.");
+        }
+        catch (WebServiceException e) {
+            // Expected path
+            assertEquals("Did not receive correct exception", "Invalid Service Class; cannot be null", e.getMessage());
+        }
+        
+    }
+    
+    public void testValidServiceSubclass() {
+        ServiceDescription serviceDescription = new ServiceDescription(null, serviceQName, ServiceSubclass.class);
+        assertNotNull("Service description not created with valid Service subclass", serviceDescription);
+    }
+}
+
+class ServiceSubclass extends javax.xml.ws.Service {
+
+    protected ServiceSubclass(URL wsdlDocumentLocation, QName serviceName) {
+        super(wsdlDocumentLocation, serviceName);
+    }
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/description/WSDLTests.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/description/WSDLTests.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/description/WSDLTests.java	(revision 0)
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.axis2.jaxws.description;
+
+import java.lang.reflect.Field;
+import java.net.URL;
+
+import javax.xml.namespace.QName;
+import javax.xml.ws.Service;
+import javax.xml.ws.WebServiceException;
+
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.jaxws.spi.ServiceDelegate;
+
+import junit.framework.TestCase;
+
+/**
+ * Tests building a ServiceDescription using WSDL and the JAXWS Service API.  
+ * Note that a ServiceDescription is built when a javax.xml.ws.Service is created.  Since that is the actual API 
+ * that should be used, this test will create Service objects and then use introspection
+ * to check the underlying ServiceDelegate which contains the ServiceDescription.
+ */
+public class WSDLTests extends TestCase {
+    
+    public void testValidWSDLService() {
+        Service service = null;
+        ServiceDelegate serviceDelegate = null;
+ 
+        String namespaceURI= "http://ws.apache.org/axis2/tests";
+        String localPart = "EchoService";
+        service = Service.create(getWSDLURL(), new QName(namespaceURI, localPart));
+        assertNotNull("Service not created", service);
+
+        serviceDelegate = getServiceDelegate(service);
+        assertNotNull("ServiceDelegate not created", serviceDelegate);
+        
+        ServiceDescription serviceDescription = serviceDelegate.getServiceDescription();
+        assertNotNull("ServiceDescription not created", serviceDescription);
+        
+        AxisService axisService = serviceDescription.getAxisService();
+        assertNotNull("AxisService not created", axisService);
+    }
+    
+    public void testInvalidServiceLocalName() {
+        Service service = null;
+ 
+        String namespaceURI= "http://ws.apache.org/axis2/tests";
+        String localPart = "BADEchoService";
+        try {
+            service = Service.create(getWSDLURL(), new QName(namespaceURI, localPart));
+            fail("Exception should have been thrown for invalid Service name");
+        }
+        catch (WebServiceException e) {
+            // This is the expected flow; it is really more a test of ServiceDelegate that ServiceDescription
+        }
+    }
+
+    public void testNullWSDLLocation() {
+        Service service = null;
+
+        String namespaceURI= "http://ws.apache.org/axis2/tests";
+        String localPart = "EchoService";
+        service = Service.create(new QName(namespaceURI, localPart));
+        assertNotNull("Service not created", service);
+        
+    }
+    
+    public void testNullServiceName() {
+        Service service = null;
+        
+        try {
+            service = Service.create(null);
+            fail("Exception should have been thrown for null Service name");
+        }
+        catch (WebServiceException e) {
+            // This is the expected flow; it is really more a test of ServiceDelegate that ServiceDescription
+            // but we are verifying expected behavior.
+        }
+        
+    }
+    
+    private URL getWSDLURL() {
+        URL wsdlURL = null;
+        // Get the URL to the WSDL file.  Note that 'basedir' is setup by Maven
+        String basedir = System.getProperty("basedir");
+        String urlString = "file://localhost/" + basedir + "/test-resources/wsdl/WSDLTests.wsdl";
+        try {
+            wsdlURL = new URL(urlString);
+        } catch (Exception e) {
+            fail("Caught exception creating WSDL URL :" + urlString + "; exception: " + e.toString());
+        }
+        return wsdlURL;
+    }
+
+    private ServiceDelegate getServiceDelegate(Service service) {
+        // Need to get to the private Service._delegate field in order to get to the ServiceDescription to test
+        ServiceDelegate returnServiceDelegate = null;
+        try {
+            Field serviceDelgateField = service.getClass().getDeclaredField("_delegate");
+            serviceDelgateField.setAccessible(true);
+            returnServiceDelegate = (ServiceDelegate) serviceDelgateField.get(service);
+        } catch (SecurityException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        } catch (NoSuchFieldException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        return returnServiceDelegate;
+    }
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/JAXBDispatch.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/JAXBDispatch.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/JAXBDispatch.java	(working copy)
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.axis2.jaxws;
 
 import java.util.concurrent.Future;
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/MessageTests.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/MessageTests.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/MessageTests.java	(revision 0)
@@ -0,0 +1,242 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.message;
+
+import java.io.StringReader;
+
+import javax.xml.namespace.QName;
+import javax.xml.soap.SOAPEnvelope;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLStreamReader;
+
+import junit.framework.TestCase;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.soap.impl.builder.StAXSOAPModelBuilder;
+import org.apache.axis2.jaxws.message.factory.MessageFactory;
+import org.apache.axis2.jaxws.message.factory.XMLStringBlockFactory;
+import org.apache.axis2.jaxws.message.util.Reader2Writer;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
+
+/**
+ * MessageTests
+ * Tests to create and validate Message processing
+ * These are not client/server tests.
+ */
+public class MessageTests extends TestCase {
+
+	// String test variables
+	private static final String sampleText =
+		"<pre:a xmlns:pre=\"urn://sample\">" +
+		"<b>Hello</b>" +
+		"<c>World</c>" +
+		"</pre:a>";
+	
+	private static final String sampleEnvelope = 
+		"<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">" +
+		"<soapenv:Header /><soapenv:Body>" +
+		sampleText +
+		"</soapenv:Body></soapenv:Envelope>";
+
+	private static final QName sampleQName = new QName("urn://sample", "a");
+	
+	private static XMLInputFactory inputFactory = XMLInputFactory.newInstance();
+	
+	public MessageTests() {
+		super();
+	}
+
+	public MessageTests(String arg0) {
+		super(arg0);
+	}
+	
+	/**
+	 * Create a Block representing an XMLString and simulate a 
+	 * normal Dispatch<String> flow
+	 * @throws Exception
+	 */
+	public void testStringOutflow() throws Exception {
+		
+		// Create a SOAP 1.1 Message
+		MessageFactory mf = (MessageFactory)
+			FactoryRegistry.getFactory(MessageFactory.class);
+		Message m = mf.create(Protocol.soap11);
+		
+		// Get the BlockFactory
+		XMLStringBlockFactory f = (XMLStringBlockFactory)
+			FactoryRegistry.getFactory(XMLStringBlockFactory.class);
+		
+		// Create a Block using the sample string as the content.  This simulates
+		// what occurs on the outbound JAX-WS dispatch<String> client
+		Block block = f.createFrom(sampleText, null, null);
+		
+		// Add the block to the message as normal body content.
+		m.setBodyBlock(0, block);
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is a XMLStreamReader will be requested...to go to OM.   At this point the
+		// block should be consumed.
+		OMElement om = m.getAsOMElement();
+		
+		// The block should not be consumed yet...because the message has not been read
+		assertTrue(!block.isConsumed());
+		
+		// To check that the output is correct, get the String contents of the 
+		// reader
+		Reader2Writer r2w = new Reader2Writer(om.getXMLStreamReaderWithoutCaching());
+		String newText = r2w.getAsString();
+		System.out.println(newText);
+		assertTrue(newText.contains(sampleText));
+		assertTrue(newText.contains("soap"));
+		assertTrue(newText.contains("Envelope"));
+		assertTrue(newText.contains("Body"));
+		
+		// The block should be consumed at this point
+		assertTrue(block.isConsumed());
+	}
+
+	/**
+	 * Create a Block representing an XMLString and simulate a 
+	 * normal Dispatch<String> flow with an application handler
+	 * @throws Exception
+	 */
+	public void testStringOutflow2() throws Exception {
+		
+		// Create a SOAP 1.1 Message
+		MessageFactory mf = (MessageFactory)
+			FactoryRegistry.getFactory(MessageFactory.class);
+		Message m = mf.create(Protocol.soap11);
+		
+		// Get the BlockFactory
+		XMLStringBlockFactory f = (XMLStringBlockFactory)
+			FactoryRegistry.getFactory(XMLStringBlockFactory.class);
+		
+		// Create a Block using the sample string as the content.  This simulates
+		// what occurs on the outbound JAX-WS dispatch<String> client
+		Block block = f.createFrom(sampleText, null, null);
+		
+		// Add the block to the message as normal body content.
+		m.setBodyBlock(0, block);
+		
+		// If there is a JAX-WS handler, the Message is converted into a SOAPEnvelope
+		SOAPEnvelope soapEnvelope = m.getAsSOAPEnvelope();
+		
+		// Normally the handler would not touch the body...but for our scenario, assume that it does.
+		String name = soapEnvelope.getBody().getFirstChild().getLocalName();
+		assertTrue("a".equals(name));
+		
+		// The block should be consumed at this point
+		assertTrue(block.isConsumed());
+		
+		// After the handler processing the message is obtained as an OM
+		OMElement om = m.getAsOMElement();
+		
+		// To check that the output is correct, get the String contents of the 
+		// reader
+		Reader2Writer r2w = new Reader2Writer(om.getXMLStreamReaderWithoutCaching());
+		String newText = r2w.getAsString();
+		System.out.println(newText);
+		assertTrue(newText.contains(sampleText));
+		assertTrue(newText.contains("soap"));
+		assertTrue(newText.contains("Envelope"));
+		assertTrue(newText.contains("Body"));
+		
+		
+	}
+	
+	
+	/**
+	 * Create a Block representing an XMLString and simulate a 
+	 * normal Dispatch<String> input flow
+	 * @throws Exception
+	 */
+
+	public void testStringInflow() throws Exception {
+		
+		// On inbound, there will already be an OM
+		// which represents the message.  The following code simulates the input
+		// OM
+		StringReader sr = new StringReader(sampleEnvelope);
+		XMLStreamReader inflow = inputFactory.createXMLStreamReader(sr);
+		StAXSOAPModelBuilder builder = new StAXSOAPModelBuilder(inflow, null);
+		OMElement omElement = builder.getSOAPEnvelope();
+		
+		// The JAX-WS layer creates a Message from the OM
+		MessageFactory mf = (MessageFactory)
+			FactoryRegistry.getFactory(MessageFactory.class);
+		Message m = mf.createFrom(omElement);
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is the proxy code will ask for the business object (String).
+		XMLStringBlockFactory blockFactory = 
+			(XMLStringBlockFactory) FactoryRegistry.getFactory(XMLStringBlockFactory.class);
+		Block block = m.getBodyBlock(0, null, blockFactory);
+		Object bo = block.getBusinessObject(true);
+		assertTrue(bo instanceof String);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// Check the String for accuracy
+		assertTrue(sampleText.equals(bo.toString()));
+		
+	}
+	
+	/**
+	 * Create a Block representing an XMLString and simulate a 
+	 * normal Dispatch<String> input flow with a JAX-WS Handler
+	 * @throws Exception
+	 */
+	public void testStringInflow2() throws Exception {
+		
+		// On inbound, there will already be an OM
+		// which represents the message.  The following code simulates the input
+		// OM
+		StringReader sr = new StringReader(sampleEnvelope);
+		XMLStreamReader inflow = inputFactory.createXMLStreamReader(sr);
+		StAXSOAPModelBuilder builder = new StAXSOAPModelBuilder(inflow, null);
+		OMElement omElement = builder.getSOAPEnvelope();
+		
+		// The JAX-WS layer creates a Message from the OM
+		MessageFactory mf = (MessageFactory)
+			FactoryRegistry.getFactory(MessageFactory.class);
+		Message m = mf.createFrom(omElement);
+		
+		// If there is a JAX-WS handler, the Message is converted into a SOAPEnvelope
+		SOAPEnvelope soapEnvelope = m.getAsSOAPEnvelope();
+		
+		// Normally the handler would not touch the body...but for our scenario, assume that it does.
+		String name = soapEnvelope.getBody().getFirstChild().getLocalName();
+		assertTrue("a".equals(name));
+		
+		// The next thing that will happen
+		// is the proxy code will ask for the business object (String).
+		XMLStringBlockFactory blockFactory = 
+			(XMLStringBlockFactory) FactoryRegistry.getFactory(XMLStringBlockFactory.class);
+		Block block = m.getBodyBlock(0, null, blockFactory);
+		Object bo = block.getBusinessObject(true);
+		assertTrue(bo instanceof String);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// Check the String for accuracy
+		assertTrue(sampleText.equals(bo.toString()));
+		
+	}
+	
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/SAAJConverterTests.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/SAAJConverterTests.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/SAAJConverterTests.java	(revision 0)
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.message;
+
+import java.io.StringReader;
+
+import javax.xml.soap.MessageFactory;
+import javax.xml.soap.SOAPBody;
+import javax.xml.soap.SOAPBodyElement;
+import javax.xml.soap.SOAPElement;
+import javax.xml.soap.SOAPEnvelope;
+import javax.xml.soap.SOAPMessage;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLStreamReader;
+
+import junit.framework.TestCase;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.soap.impl.builder.StAXSOAPModelBuilder;
+import org.apache.axis2.jaxws.message.factory.SAAJConverterFactory;
+import org.apache.axis2.jaxws.message.util.SAAJConverter;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
+
+/**
+ * SAAJConverterTests
+ * 
+ * Test the basic functionality of the SAAJConverter.
+ * You can also use these tests to as sample code on how to use
+ * the converter.
+ *
+ */
+public class SAAJConverterTests extends TestCase {
+
+	private static final String sampleText =
+		"<pre:a xmlns:pre=\"urn://sample\">" +
+		"<b>Hello</b>" +
+		"<c>World</c>" +
+		"</pre:a>";
+	
+	private static final String sampleEnvelope = 
+		"<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">" +
+		"<soapenv:Header /><soapenv:Body>" +
+		sampleText +
+		"</soapenv:Body></soapenv:Envelope>";
+	
+	private static XMLInputFactory inputFactory = XMLInputFactory.newInstance();
+	
+	public SAAJConverterTests() {
+		super();
+	}
+
+	public SAAJConverterTests(String arg0) {
+		super(arg0);
+	}
+
+	/**
+	 * @testStrategy Tests conversions between SAAJ and OM SOAPEnvelopes
+	 */
+	public void test1() throws Exception {
+		
+		// Bootstrap: Create an OM SOAPEnvelope from the sample text
+		StringReader sr = new StringReader(sampleEnvelope);
+		XMLStreamReader inflow = inputFactory.createXMLStreamReader(sr);
+		StAXSOAPModelBuilder builder = new StAXSOAPModelBuilder(inflow, null);
+		org.apache.axiom.soap.SOAPEnvelope omEnvelope = builder.getSOAPEnvelope();
+		
+		// Step 1: Get the SAAJConverter object from the Factory
+		SAAJConverterFactory f = (SAAJConverterFactory) 
+			FactoryRegistry.getFactory(SAAJConverterFactory.class);
+		SAAJConverter converter = f.getSAAJConverter();
+		
+		// Step 2: Convert the OM SOAPEnvelope to an SAAJ SOAPEnvelope
+		SOAPEnvelope saajEnvelope = converter.toSAAJ(omEnvelope);
+		
+		// Step 2a: Simple assertion check to ensure correctness.
+		String name = saajEnvelope.getBody().getFirstChild().getLocalName();
+		assertTrue("a".equals(name));
+		
+		// Step 3: Convert the SAAJ SOAPEnvelope to an OM SOAPEnvelope
+		omEnvelope = converter.toOM(saajEnvelope);
+		
+		// Step 3a: Simple assertion check to ensure correctness
+		name = omEnvelope.getBody().getFirstElement().getLocalName();
+		assertTrue("a".equals(name));
+		
+		// Step 4: Rinse and repeat
+		saajEnvelope = converter.toSAAJ(omEnvelope);
+		name = saajEnvelope.getBody().getFirstChild().getLocalName();
+		assertTrue("a".equals(name));
+		omEnvelope = converter.toOM(saajEnvelope);
+		name = omEnvelope.getBody().getFirstElement().getLocalName();
+		assertTrue("a".equals(name));
+	}
+	
+	/**
+	 * @testStrategy Tests conversions between SAAJ and OM for normal element
+	 */
+	public void test2() throws Exception {
+		
+		// Bootstrap: Create an OM SOAPEnvelope from the sample text.
+		StringReader sr = new StringReader(sampleEnvelope);
+		XMLStreamReader inflow = inputFactory.createXMLStreamReader(sr);
+		StAXSOAPModelBuilder builder = new StAXSOAPModelBuilder(inflow, null);
+		org.apache.axiom.soap.SOAPEnvelope omEnvelope = builder.getSOAPEnvelope();
+		
+		// Bootstrap: Get an OMElement from the body
+		OMElement om = omEnvelope.getBody().getFirstElement();
+		
+		// Bootstrap: Get an SAAJ Body to hold the target SOAPElement
+		MessageFactory msgFactory = MessageFactory.newInstance();
+		SOAPMessage message = msgFactory.createMessage();
+		SOAPBody body = message.getSOAPBody();
+		
+		// Step 1: Get the SAAJConverter object from the Factory
+		SAAJConverterFactory f = (SAAJConverterFactory) 
+			FactoryRegistry.getFactory(SAAJConverterFactory.class);
+		SAAJConverter converter = f.getSAAJConverter();
+		
+		// Step 2: Convert OM to SAAJ
+		SOAPElement se = converter.toSAAJ(om, body);
+		
+		// Step 2a: Verify
+		assertTrue(se instanceof SOAPBodyElement);
+		assertTrue(se.getLocalName().equals("a"));
+		
+		// Step 3: Convert SAAJ to OM
+		om = converter.toOM(se);
+		
+		// Step 3a: Verify
+		assertTrue(om.getLocalName().equals("a"));
+		
+		// Step 4: Rinse and Repeat
+		se = converter.toSAAJ(om, body);
+		assertTrue(se instanceof SOAPBodyElement);
+		assertTrue(se.getLocalName().equals("a"));
+		om = converter.toOM(se);
+		assertTrue(om.getLocalName().equals("a"));
+	}
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/XMLStreamReaderSplitterTests.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/XMLStreamReaderSplitterTests.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/XMLStreamReaderSplitterTests.java	(revision 0)
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.message;
+
+import java.io.StringReader;
+import java.io.StringWriter;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBIntrospector;
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLOutputFactory;
+import javax.xml.stream.XMLStreamReader;
+import javax.xml.stream.XMLStreamWriter;
+
+import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
+import org.apache.axis2.jaxws.message.factory.XMLStringBlockFactory;
+import org.apache.axis2.jaxws.message.util.Reader2Writer;
+import org.apache.axis2.jaxws.message.util.XMLStreamReaderSplitter;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
+
+import client.EchoString;
+import client.ObjectFactory;
+
+import junit.framework.TestCase;
+
+/**
+ * Tests XMLStreamReaderSplitter
+ */
+public class XMLStreamReaderSplitterTests extends TestCase {
+
+	// String test variables
+	private static final String sampleText =
+		"<body>" + 
+		"spurious text" +
+		"<pre:a1 xmlns:pre=\"urn://sample\">" +
+		"<b1>Hello</b1>" +
+		"<c1>World</c1>" +
+		"</pre:a1>" +
+		"<!-- Spurious Comment -->" +
+		"<pre:a2 xmlns:pre=\"urn://sample2\">" +
+		"<b2>Hello</b2>" +
+		"<c2>World</c2>" +
+		"</pre:a2>" +
+		"</body>";
+	
+	
+	private static XMLInputFactory inputFactory = XMLInputFactory.newInstance();
+	private static XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
+	
+	
+	
+	public XMLStreamReaderSplitterTests() {
+		super();
+	}
+
+	public XMLStreamReaderSplitterTests(String arg0) {
+		super(arg0);
+	}
+	
+	/**
+	 * Test XMLStreamReaderSplitter 
+	 * @throws Exception
+	 */
+	public void test() throws Exception {
+		// Create a full XMLStreamReader for the message
+		StringReader sr = new StringReader(sampleText);
+		XMLStreamReader fullReader = inputFactory.createXMLStreamReader(sr);
+		
+		// Advance past the first element (body)
+		fullReader.next();
+		fullReader.next();
+		
+		// Create a Splitter
+		XMLStreamReaderSplitter splitter = new XMLStreamReaderSplitter(fullReader);
+		
+		// Pipe the splitter to the writer.  This should generated only the 
+		// first element tree.
+		StringWriter sw = new StringWriter();
+		XMLStreamWriter writer = outputFactory.createXMLStreamWriter(sw);
+		Reader2Writer r2w = new Reader2Writer(splitter);
+		r2w.outputTo(writer);
+		writer.flush();
+		sw.flush();
+		String tree1 = sw.toString();
+		
+		// Now get the next Stream
+		XMLStreamReader stream2 = splitter.getNextReader();
+		r2w = new Reader2Writer(stream2);
+		sw = new StringWriter();
+		writer = outputFactory.createXMLStreamWriter(sw);
+		r2w.outputTo(writer);
+		writer.flush();
+		sw.flush();
+		String tree2 = sw.toString();
+		
+		// Do assertion checks
+		assertTrue(!tree1.contains("text"));
+		assertTrue(!tree1.contains("Comment"));
+		assertTrue( tree1.contains("a1"));
+		assertTrue(!tree1.contains("a2"));
+		
+		assertTrue(!tree2.contains("text"));
+		assertTrue(!tree2.contains("Comment"));
+		assertTrue(!tree2.contains("a1"));
+		assertTrue( tree2.contains("a2"));
+	}
+}
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/BlockTests.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/BlockTests.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/BlockTests.java	(revision 0)
@@ -0,0 +1,890 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.message;
+
+import java.io.StringReader;
+import java.io.StringWriter;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBIntrospector;
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLOutputFactory;
+import javax.xml.stream.XMLStreamReader;
+import javax.xml.stream.XMLStreamWriter;
+import javax.xml.transform.Source;
+import javax.xml.transform.stream.StreamSource;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.impl.builder.StAXOMBuilder;
+import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
+import org.apache.axis2.jaxws.message.factory.OMBlockFactory;
+import org.apache.axis2.jaxws.message.factory.SourceBlockFactory;
+import org.apache.axis2.jaxws.message.factory.XMLStringBlockFactory;
+import org.apache.axis2.jaxws.message.util.Reader2Writer;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
+
+import client.EchoString;
+import client.ObjectFactory;
+
+import junit.framework.TestCase;
+
+/**
+ * BlockTests
+ * Tests to create and validate blocks.
+ * These are not client/server tests.
+ */
+public class BlockTests extends TestCase {
+
+	// String test variables
+	private static final String sampleText =
+		"<pre:a xmlns:pre=\"urn://sample\">" +
+		"<b>Hello</b>" +
+		"<c>World</c>" +
+		"</pre:a>";
+	private static final QName sampleQName = new QName("urn://sample", "a");
+	
+	
+	private static XMLInputFactory inputFactory = XMLInputFactory.newInstance();
+	private static XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
+	
+	
+	
+	public BlockTests() {
+		super();
+	}
+
+	public BlockTests(String arg0) {
+		super(arg0);
+	}
+	
+	/**
+	 * Create a Block representing an XMLString and simulate a 
+	 * normal Dispatch<String> flow
+	 * @throws Exception
+	 */
+	public void testStringOutflow() throws Exception {
+		// Get the BlockFactory
+		XMLStringBlockFactory f = (XMLStringBlockFactory)
+			FactoryRegistry.getFactory(XMLStringBlockFactory.class);
+		
+		// Create a Block using the sample string as the content.  This simulates
+		// what occurs on the outbound JAX-WS dispatch<String> client
+		Block block = f.createFrom(sampleText, null, null);
+		
+		// We didn't pass in a qname, so the following should return false
+		assertTrue(!block.isQNameAvailable());
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is a XMLStreamReader will be requested...to go to OM.   At this point the
+		// block should be consumed.
+		XMLStreamReader reader = block.getXMLStreamReader(true);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// To check that the output is correct, get the String contents of the 
+		// reader
+		Reader2Writer r2w = new Reader2Writer(reader);
+		String newText = r2w.getAsString();
+		assertTrue(sampleText.equals(newText));
+		
+	}
+
+	/**
+	 * Create a Block representing an XMLString and
+	 * simulate a different Dispatch<String> flow
+	 * @throws Exception
+	 */
+	public void testStringOutflow2() throws Exception {
+		// Get the BlockFactory
+		XMLStringBlockFactory f = (XMLStringBlockFactory)
+			FactoryRegistry.getFactory(XMLStringBlockFactory.class);
+		
+		// Create a Block using the sample string as the content.  This simulates
+		// what occurs on the outbound JAX-WS dispatch<String> client
+		Block block = f.createFrom(sampleText, null, null);
+		
+		// We didn't pass in a qname, so the following should return false
+		assertTrue(!block.isQNameAvailable());
+		
+		// Assume that we need to find the QName (perhaps to identify the operation and 
+		// determine if handlers are installed).   This is not very perfomant since 
+		// it causes an underlying parse of the String...but we need to support this.
+		QName qName = block.getQName();
+		assertTrue("Expected: " + sampleQName + " but found: " + qName, sampleQName.equals(qName));
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is a XMLStreamReader will be requested...to go to OM.   At this point the
+		// block should be consumed.
+		XMLStreamReader reader = block.getXMLStreamReader(true);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// To check that the output is correct, get the String contents of the 
+		// reader
+		Reader2Writer r2w = new Reader2Writer(reader);
+		String newText = r2w.getAsString();
+		assertTrue(sampleText.equals(newText));
+		
+	}
+	
+	/**
+	 * Create a Block representing an XMLString and
+	 * simulate a different String parameter flow
+	 * @throws Exception
+	 */
+	public void testStringOutflow3() throws Exception {
+		// Get the BlockFactory
+		XMLStringBlockFactory f = (XMLStringBlockFactory)
+			FactoryRegistry.getFactory(XMLStringBlockFactory.class);
+		
+		// Create a Block using the sample string as the content.  This simulates
+		// what occurs on the outbound JAX-WS String parameter on the client.
+		// In this case, we know the QName prior to creating the Block...so let's pass it in.
+		Block block = f.createFrom(sampleText, null, sampleQName);
+		
+		// We passed in a qname, so it should be immediately available
+		assertTrue(block.isQNameAvailable());
+		
+		// Make sure the QName is correct.
+		QName qName = block.getQName();
+		assertTrue(sampleQName.equals(qName));
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is a XMLStreamReader will be requested...to go to OM.   At this point the
+		// block should be consumed.
+		XMLStreamReader reader = block.getXMLStreamReader(true);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// To check that the output is correct, get the String contents of the 
+		// reader
+		Reader2Writer r2w = new Reader2Writer(reader);
+		String newText = r2w.getAsString();
+		assertTrue(sampleText.equals(newText));
+	}
+	
+	/**
+	 * Create a Block representing an XMLString and simulate a 
+	 * normal Dispatch<String> input flow
+	 * @throws Exception
+	 */
+	public void testStringInflow() throws Exception {
+		// Get the BlockFactory
+		XMLStringBlockFactory f = (XMLStringBlockFactory)
+			FactoryRegistry.getFactory(XMLStringBlockFactory.class);
+		
+		// On inbound, there will already be a XMLStreamReader (probably from OM)
+		// which represents the message.  We will simulate this with inflow.
+		StringReader sr = new StringReader(sampleText);
+		XMLStreamReader inflow = inputFactory.createXMLStreamReader(sr);
+		
+		// Create a Block from the inflow.  
+		Block block = f.createFrom(inflow, null, null);
+		
+		// We didn't pass in a qname, so the following should return false
+		assertTrue(!block.isQNameAvailable());
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is the proxy code will ask for the business object (String).
+		Object bo = block.getBusinessObject(true);
+		assertTrue(bo instanceof String);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// Check the String for accuracy
+		assertTrue(sampleText.equals(bo.toString()));
+		
+	}
+	
+	/**
+	 * Create a Block representing an XMLString and simulate a 
+	 * slightly more complicated Dispatch<String> inflow
+	 * @throws Exception
+	 */
+	public void testStringInflow2() throws Exception {
+		// Get the BlockFactory
+		XMLStringBlockFactory f = (XMLStringBlockFactory)
+			FactoryRegistry.getFactory(XMLStringBlockFactory.class);
+		
+		// On inbound, there will already be a XMLStreamReader (probably from OM)
+		// which represents the message.  We will simulate this with inflow.
+		StringReader sr = new StringReader(sampleText);
+		XMLStreamReader inflow = inputFactory.createXMLStreamReader(sr);
+		
+		// Create a Block from the inflow.  
+		Block block = f.createFrom(inflow, null, null);
+		
+		// We didn't pass in a qname, so the following should return false
+		assertTrue(!block.isQNameAvailable());
+		
+		// Let's assume we need to get the QName to find the operation name.
+		// This will cause an underlying parse
+		QName qName = block.getQName();
+		assertTrue(sampleQName.equals(qName));
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is the proxy code will ask for the business object (String).
+		Object bo = block.getBusinessObject(true);
+		assertTrue(bo instanceof String);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// Check the String for accuracy
+		assertTrue(sampleText.equals(bo.toString()));
+		
+	}
+	
+	/**
+	 * Create a Block representing an XMLString and simulate a 
+	 * slightly more complicated String  inflow
+	 * @throws Exception
+	 */
+	public void testStringInflow3() throws Exception {
+		// Get the BlockFactory
+		XMLStringBlockFactory f = (XMLStringBlockFactory)
+			FactoryRegistry.getFactory(XMLStringBlockFactory.class);
+		
+		// On inbound, there will already be a XMLStreamReader (probably from OM)
+		// which represents the message.  We will simulate this with inflow.
+		StringReader sr = new StringReader(sampleText);
+		XMLStreamReader inflow = inputFactory.createXMLStreamReader(sr);
+		
+		// Create a Block from the inflow.  Assume that we know the QName already
+		Block block = f.createFrom(inflow, null, sampleQName);
+		
+		// We passed in a qname, so the following should return false
+		assertTrue(block.isQNameAvailable());
+		
+		// Let's assume we need to get the QName to find the operation name.
+		QName qName = block.getQName();
+		assertTrue(sampleQName.equals(qName));
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is the proxy code will ask for the business object (String).
+		Object bo = block.getBusinessObject(true);
+		assertTrue(bo instanceof String);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// Check the String for accuracy
+		assertTrue(sampleText.equals(bo.toString()));
+		
+	}
+	
+	/**
+	 * Create a Block representing an JAXB and simulate a 
+	 * normal Dispatch<JAXB> flow
+	 * @throws Exception
+	 */
+	public void testJAXBOutflow() throws Exception {
+		// Get the BlockFactory
+		JAXBBlockFactory f = (JAXBBlockFactory)
+			FactoryRegistry.getFactory(JAXBBlockFactory.class);
+		
+        // Create a jaxb object
+        ObjectFactory factory = new ObjectFactory();
+        EchoString jaxb = factory.createEchoString(); 
+        jaxb.setInput("Hello World");
+        JAXBContext jbc = JAXBContext.newInstance("client");
+        JAXBIntrospector jbi = jbc.createJAXBIntrospector();
+        QName expectedQName = jbi.getElementName(jaxb);
+        
+		// Create a Block using the sample string as the content.  This simulates
+		// what occurs on the outbound JAX-WS dispatch<JAXB> client
+		Block block = f.createFrom(jaxb, jbc, null);
+		
+		// JAXB objects set the qname from their internal data
+		assertTrue(block.isQNameAvailable());
+		
+		// Assume that we need to find the QName (perhaps to identify the operation and 
+		// determine if handlers are installed).   This is not very perfomant since 
+		// it causes an underlying parse of the String...but we need to support this.
+		QName qName = block.getQName();
+		assertTrue("Expected: " + expectedQName + " but found: " + qName, expectedQName.equals(qName));
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is a XMLStreamReader will be requested...to go to OM.   At this point the
+		// block should be consumed.
+		XMLStreamReader reader = block.getXMLStreamReader(true);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// To check that the output is correct, get the String contents of the 
+		// reader
+		Reader2Writer r2w = new Reader2Writer(reader);
+		String newText = r2w.getAsString();
+		assertTrue(newText.contains("Hello World"));
+		assertTrue(newText.contains("echoString"));
+		
+	}
+	
+	/**
+	 * Create a Block representing an JAXB and simulate a 
+	 * slightly more complicated Dispatch<JAXB> flow
+	 * @throws Exception
+	 */
+	public void testJAXBOutflow2() throws Exception {
+		// Get the BlockFactory
+		JAXBBlockFactory f = (JAXBBlockFactory)
+			FactoryRegistry.getFactory(JAXBBlockFactory.class);
+		
+        // Create a jaxb object
+        ObjectFactory factory = new ObjectFactory();
+        EchoString jaxb = factory.createEchoString(); 
+        jaxb.setInput("Hello World");
+        JAXBContext jbc = JAXBContext.newInstance("client");
+        JAXBIntrospector jbi = jbc.createJAXBIntrospector();
+        QName expectedQName = jbi.getElementName(jaxb);
+        
+		// Create a Block using the sample string as the content.  This simulates
+		// what occurs with an outbound JAX-WS JAXB parameter
+		Block block = f.createFrom(jaxb, jbc, expectedQName);
+		
+		// We did pass in a qname, so the following should return false
+		assertTrue(block.isQNameAvailable());
+		
+		// Assume that we need to find the QName (perhaps to identify the operation and 
+		// determine if handlers are installed).   This is not very perfomant since 
+		// it causes an underlying parse of the String...but we need to support this.
+		QName qName = block.getQName();
+		assertTrue("Expected: " + expectedQName + " but found: " + qName, expectedQName.equals(qName));
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is a XMLStreamReader will be requested...to go to OM.   At this point the
+		// block should be consumed.
+		XMLStreamReader reader = block.getXMLStreamReader(true);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// To check that the output is correct, get the String contents of the 
+		// reader
+		Reader2Writer r2w = new Reader2Writer(reader);
+		String newText = r2w.getAsString();
+		assertTrue(newText.contains("Hello World"));
+		assertTrue(newText.contains("echoString"));
+		
+	}
+	
+	/**
+	 * Create a Block representing an JAXB and simulate a 
+	 * normal Dispatch<JAXB> input flow
+	 * @throws Exception
+	 */
+	public void testJAXBInflow() throws Exception {
+		// Get the BlockFactory
+		JAXBBlockFactory f = (JAXBBlockFactory)
+			FactoryRegistry.getFactory(JAXBBlockFactory.class);
+		
+        // Create a jaxb object
+        ObjectFactory factory = new ObjectFactory();
+        EchoString jaxb = factory.createEchoString(); 
+        jaxb.setInput("Hello World");
+        JAXBContext jbc = JAXBContext.newInstance("client");
+		
+		// On inbound, there will already be a XMLStreamReader (probably from OM)
+		// which represents the message.  We will simulate this with inflow.
+        StringWriter sw = new StringWriter();
+        XMLStreamWriter writer = outputFactory.createXMLStreamWriter(sw);
+        jbc.createMarshaller().marshal(jaxb, writer);
+        writer.flush();
+        sw.flush();
+		StringReader sr = new StringReader(sw.toString());
+		XMLStreamReader inflow = inputFactory.createXMLStreamReader(sr);
+		
+		// Create a Block from the inflow.  
+		Block block = f.createFrom(inflow, jbc, null);
+		
+		// We didn't pass in a qname, so the following should return false
+		assertTrue(!block.isQNameAvailable());
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is the proxy code will ask for the business object.
+		Object bo = block.getBusinessObject(true);
+		assertTrue(bo instanceof EchoString);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// Check for accuracy
+		assertTrue("Unexpected:" + ((EchoString)bo).getInput(), ((EchoString)bo).getInput().equals(jaxb.getInput()));
+		
+	}
+	
+	/**
+	 * Create a Block representing an JAXB and simulate a 
+	 * normal Dispatch<JAXB> input flow
+	 * @throws Exception
+	 */
+	public void testJAXBInflow2() throws Exception {
+		// Get the BlockFactory
+		JAXBBlockFactory f = (JAXBBlockFactory)
+			FactoryRegistry.getFactory(JAXBBlockFactory.class);
+		
+        // Create a jaxb object
+        ObjectFactory factory = new ObjectFactory();
+        EchoString jaxb = factory.createEchoString(); 
+        jaxb.setInput("Hello World");
+        JAXBContext jbc = JAXBContext.newInstance("client");
+        JAXBIntrospector jbi = jbc.createJAXBIntrospector();
+        QName expectedQName = jbi.getElementName(jaxb);
+		
+		// On inbound, there will already be a XMLStreamReader (probably from OM)
+		// which represents the message.  We will simulate this with inflow.
+        StringWriter sw = new StringWriter();
+        XMLStreamWriter writer = outputFactory.createXMLStreamWriter(sw);
+        jbc.createMarshaller().marshal(jaxb, writer);
+        writer.flush();
+        sw.flush();
+		StringReader sr = new StringReader(sw.toString());
+		XMLStreamReader inflow = inputFactory.createXMLStreamReader(sr);
+		
+		// Create a Block from the inflow.  
+		Block block = f.createFrom(inflow, jbc, null);
+		
+		// We didn't pass in a qname, so the following should return false
+		assertTrue(!block.isQNameAvailable());
+		
+		// Assume that we need to find the QName (perhaps to identify the operation and 
+		// determine if handlers are installed).   This is not very perfomant since 
+		// it causes an underlying parse of the String...but we need to support this.
+		QName qName = block.getQName();
+		assertTrue("Expected: " + expectedQName + " but found: " + qName, expectedQName.equals(qName));
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is the proxy code will ask for the business object.
+		Object bo = block.getBusinessObject(true);
+		assertTrue(bo instanceof EchoString);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// Check for accuracy
+		assertTrue("Unexpected:" + ((EchoString)bo).getInput(), ((EchoString)bo).getInput().equals(jaxb.getInput()));
+		
+	}
+	
+	/**
+	 * Create a Block representing an JAXB and simulate a 
+	 * normal Dispatch<JAXB> input flow
+	 * @throws Exception
+	 */
+	public void testJAXBInflow3() throws Exception {
+		// Get the BlockFactory
+		JAXBBlockFactory f = (JAXBBlockFactory)
+			FactoryRegistry.getFactory(JAXBBlockFactory.class);
+		
+        // Create a jaxb object
+        ObjectFactory factory = new ObjectFactory();
+        EchoString jaxb = factory.createEchoString(); 
+        jaxb.setInput("Hello World");
+        JAXBContext jbc = JAXBContext.newInstance("client");
+        JAXBIntrospector jbi = jbc.createJAXBIntrospector();
+        QName expectedQName = jbi.getElementName(jaxb);
+		
+		// On inbound, there will already be a XMLStreamReader (probably from OM)
+		// which represents the message.  We will simulate this with inflow.
+        StringWriter sw = new StringWriter();
+        XMLStreamWriter writer = outputFactory.createXMLStreamWriter(sw);
+        jbc.createMarshaller().marshal(jaxb, writer);
+        writer.flush();
+        sw.flush();
+		StringReader sr = new StringReader(sw.toString());
+		XMLStreamReader inflow = inputFactory.createXMLStreamReader(sr);
+		
+		// Create a Block from the inflow.  
+		Block block = f.createFrom(inflow, jbc, expectedQName);
+		
+		// We passed in a qname, so the following should return false
+		assertTrue(block.isQNameAvailable());
+		
+		// Assume that we need to find the QName (perhaps to identify the operation and 
+		// determine if handlers are installed).   This is not very perfomant since 
+		// it causes an underlying parse of the String...but we need to support this.
+		QName qName = block.getQName();
+		assertTrue("Expected: " + expectedQName + " but found: " + qName, expectedQName.equals(qName));
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is the proxy code will ask for the business object.
+		Object bo = block.getBusinessObject(true);
+		assertTrue(bo instanceof EchoString);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// Check for accuracy
+		assertTrue("Unexpected:" + ((EchoString)bo).getInput(), ((EchoString)bo).getInput().equals(jaxb.getInput()));
+		
+	}
+	
+	/**
+	 * Create a Block representing an OM and simulate a 
+	 * normal Dispatch<OMElement> flow
+	 * @throws Exception
+	 */
+	public void testOMOutflow() throws Exception {
+		// Get the BlockFactory
+		OMBlockFactory f = (OMBlockFactory)
+			FactoryRegistry.getFactory(OMBlockFactory.class);
+		
+		// Create a Block using the sample string as the content.  This simulates
+		// what occurs on the outbound JAX-WS dispatch<OMElement> client
+		StringReader sr = new StringReader(sampleText);
+		XMLStreamReader inputReader = inputFactory.createXMLStreamReader(sr);
+		StAXOMBuilder builder = new StAXOMBuilder(inputReader);  
+		OMElement om = builder.getDocumentElement();
+		Block block = f.createFrom(om, null, null);
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is a XMLStreamReader will be requested...to go to OM.   At this point the
+		// block should be consumed.
+		XMLStreamReader reader = block.getXMLStreamReader(true);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// To check that the output is correct, get the String contents of the 
+		// reader
+		Reader2Writer r2w = new Reader2Writer(reader);
+		String newText = r2w.getAsString();
+		assertTrue(sampleText.equals(newText));
+		
+	}
+	
+
+	/**
+	 * Create a Block representing an OM and simulate a 
+	 * different Dispatch<OMElement> flow
+	 * @throws Exception
+	 */
+	public void testOMOutflow2() throws Exception {
+		// Get the BlockFactory
+		OMBlockFactory f = (OMBlockFactory)
+			FactoryRegistry.getFactory(OMBlockFactory.class);
+		
+		// Create a Block using the sample string as the content.  This simulates
+		// what occurs on the outbound JAX-WS dispatch<OMElement> client
+		StringReader sr = new StringReader(sampleText);
+		XMLStreamReader inputReader = inputFactory.createXMLStreamReader(sr);
+		StAXOMBuilder builder = new StAXOMBuilder(inputReader);  
+		OMElement om = builder.getDocumentElement();
+		Block block = f.createFrom(om, null, null);
+		
+		// Assume that we need to find the QName (perhaps to identify the operation and 
+		// determine if handlers are installed).   This is not very perfomant since 
+		// it causes an underlying parse of the String...but we need to support this.
+		QName qName = block.getQName();
+		assertTrue("Expected: " + sampleQName + " but found: " + qName, sampleQName.equals(qName));
+		
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is a XMLStreamReader will be requested...to go to OM.   At this point the
+		// block should be consumed.
+		XMLStreamReader reader = block.getXMLStreamReader(true);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// To check that the output is correct, get the String contents of the 
+		// reader
+		Reader2Writer r2w = new Reader2Writer(reader);
+		String newText = r2w.getAsString();
+		assertTrue(sampleText.equals(newText));
+		
+	}
+	
+	/**
+	 * Create a Block representing an XMLString and simulate a 
+	 *  Dispatch<OMElement> inflow
+	 * @throws Exception
+	 */
+	public void testOMInflow() throws Exception {
+		// Get the BlockFactory
+		OMBlockFactory f = (OMBlockFactory)
+			FactoryRegistry.getFactory(OMBlockFactory.class);
+		
+		// On inbound, there will already be a XMLStreamReader (probably from OM)
+		// which represents the message.  We will simulate this with inflow.
+		StringReader sr = new StringReader(sampleText);
+		XMLStreamReader inflow = inputFactory.createXMLStreamReader(sr);
+		
+		// Create a Block from the inflow.  
+		Block block = f.createFrom(inflow, null, null);
+		
+		// Let's assume we need to get the QName to find the operation name.
+		// This will cause an underlying parse
+		QName qName = block.getQName();
+		assertTrue(sampleQName.equals(qName));
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is the proxy code will ask for the business object (String).
+		Object bo = block.getBusinessObject(true);
+		assertTrue(bo instanceof OMElement);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// Check the String for accuracy
+		assertTrue(sampleText.equals(bo.toString()));
+		
+	}
+	
+	/**
+	 * Create a Block representing a Source and simulate a 
+	 * normal Dispatch<Source> flow
+	 * @throws Exception
+	 */
+	public void testStreamSourceOutflow() throws Exception {
+		// Get the BlockFactory
+		SourceBlockFactory f = (SourceBlockFactory)
+			FactoryRegistry.getFactory(SourceBlockFactory.class);
+		
+		StreamSource ss = new StreamSource(new StringReader(sampleText));
+		
+		// Create a Block using the sample string as the content.  This simulates
+		// what occurs on the outbound JAX-WS dispatch<Source> client
+		Block block = f.createFrom(ss, null, null);
+		
+		// We didn't pass in a qname, so the following should return false
+		assertTrue(!block.isQNameAvailable());
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is a XMLStreamReader will be requested...to go to OM.   At this point the
+		// block should be consumed.
+		XMLStreamReader reader = block.getXMLStreamReader(true);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// To check that the output is correct, get the String contents of the 
+		// reader
+		Reader2Writer r2w = new Reader2Writer(reader);
+		String newText = r2w.getAsString();
+		assertTrue(sampleText.equals(newText));
+		
+	}
+
+	/**
+	 * Create a Block representing a Source and
+	 * simulate a different Dispatch<Source> flow
+	 * @throws Exception
+	 */
+	public void testStreamSourceOutflow2() throws Exception {
+		// Get the BlockFactory
+		SourceBlockFactory f = (SourceBlockFactory)
+			FactoryRegistry.getFactory(SourceBlockFactory.class);
+		
+		StreamSource ss = new StreamSource(new StringReader(sampleText));
+		
+		// Create a Block using the sample string as the content.  This simulates
+		// what occurs on the outbound JAX-WS dispatch<Source> client
+		Block block = f.createFrom(ss, null, null);
+		
+		// We didn't pass in a qname, so the following should return false
+		assertTrue(!block.isQNameAvailable());
+		
+		// Assume that we need to find the QName (perhaps to identify the operation and 
+		// determine if handlers are installed).   This is not very perfomant since 
+		// it causes an underlying parse of the String...but we need to support this.
+		QName qName = block.getQName();
+		assertTrue("Expected: " + sampleQName + " but found: " + qName, sampleQName.equals(qName));
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is a XMLStreamReader will be requested...to go to OM.   At this point the
+		// block should be consumed.
+		XMLStreamReader reader = block.getXMLStreamReader(true);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// To check that the output is correct, get the String contents of the 
+		// reader
+		Reader2Writer r2w = new Reader2Writer(reader);
+		String newText = r2w.getAsString();
+		assertTrue(sampleText.equals(newText));
+		
+	}
+	
+	/**
+	 * Create a Block representing a Source and
+	 * simulate a different Source parameter flow
+	 * @throws Exception
+	 */
+	public void testStreamSourceOutflow3() throws Exception {
+		// Get the BlockFactory
+		SourceBlockFactory f = (SourceBlockFactory)
+			FactoryRegistry.getFactory(SourceBlockFactory.class);
+		
+		StreamSource ss = new StreamSource(new StringReader(sampleText));
+		
+		// Create a Block using the sample string as the content.  This simulates
+		// what occurs on the outbound JAX-WS String parameter on the client.
+		// In this case, we know the QName prior to creating the Block...so let's pass it in.
+		Block block = f.createFrom(ss, null, sampleQName);
+		
+		// We passed in a qname, so it should be immediately available
+		assertTrue(block.isQNameAvailable());
+		
+		// Make sure the QName is correct.
+		QName qName = block.getQName();
+		assertTrue(sampleQName.equals(qName));
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is a XMLStreamReader will be requested...to go to OM.   At this point the
+		// block should be consumed.
+		XMLStreamReader reader = block.getXMLStreamReader(true);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// To check that the output is correct, get the String contents of the 
+		// reader
+		Reader2Writer r2w = new Reader2Writer(reader);
+		String newText = r2w.getAsString();
+		assertTrue(sampleText.equals(newText));
+	}
+	
+	/**
+	 * Create a Block representing an XMLString and simulate a 
+	 * normal Dispatch<Source> input flow
+	 * @throws Exception
+	 */
+	public void testStreamSourceInflow() throws Exception {
+		// Get the BlockFactory
+		SourceBlockFactory f = (SourceBlockFactory)
+			FactoryRegistry.getFactory(SourceBlockFactory.class);
+		
+		// On inbound, there will already be a XMLStreamReader (probably from OM)
+		// which represents the message.  We will simulate this with inflow.
+		StringReader sr = new StringReader(sampleText);
+		XMLStreamReader inflow = inputFactory.createXMLStreamReader(sr);
+		
+		// Create a Block from the inflow.  
+		Block block = f.createFrom(inflow, null, null);
+		
+		// We didn't pass in a qname, so the following should return false
+		assertTrue(!block.isQNameAvailable());
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is the proxy code will ask for the business object (String).
+		Object bo = block.getBusinessObject(true);
+		assertTrue(bo instanceof Source);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+		
+		// Check the String for accuracy
+		XMLStreamReader reader = inputFactory.createXMLStreamReader((Source) bo);
+		Reader2Writer r2w = new Reader2Writer(reader);
+		String newText = r2w.getAsString();
+		assertTrue(sampleText.equals(newText));
+		
+	}
+	
+	/**
+	 * Create a Block representing an XMLString and simulate a 
+	 * slightly more complicated Dispatch<Source> inflow
+	 * @throws Exception
+	 */
+	public void testStreamSourceInflow2() throws Exception {
+
+		// Get the BlockFactory
+		SourceBlockFactory f = (SourceBlockFactory)
+			FactoryRegistry.getFactory(SourceBlockFactory.class);
+		
+		// On inbound, there will already be a XMLStreamReader (probably from OM)
+		// which represents the message.  We will simulate this with inflow.
+		StringReader sr = new StringReader(sampleText);
+		XMLStreamReader inflow = inputFactory.createXMLStreamReader(sr);
+		
+		// Create a Block from the inflow.  
+		Block block = f.createFrom(inflow, null, null);
+		
+		// We didn't pass in a qname, so the following should return false
+		assertTrue(!block.isQNameAvailable());
+		
+		// Let's assume we need to get the QName to find the operation name.
+		// This will cause an underlying parse
+		QName qName = block.getQName();
+		assertTrue(sampleQName.equals(qName));
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is the proxy code will ask for the business object (String).
+		Object bo = block.getBusinessObject(true);
+		assertTrue(bo instanceof Source);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+
+		// Check the String for accuracy
+		XMLStreamReader reader = inputFactory.createXMLStreamReader((Source) bo);
+		Reader2Writer r2w = new Reader2Writer(reader);
+		String newText = r2w.getAsString();
+		assertTrue(sampleText.equals(newText));
+		
+	}
+	
+	/**
+	 * Create a Block representing an Source and simulate a 
+	 * slightly more complicated Source inflow
+	 * @throws Exception
+	 */
+	public void testStreamSourceInflow3() throws Exception {
+
+		// Get the BlockFactory
+		SourceBlockFactory f = (SourceBlockFactory)
+			FactoryRegistry.getFactory(SourceBlockFactory.class);
+		
+		// On inbound, there will already be a XMLStreamReader (probably from OM)
+		// which represents the message.  We will simulate this with inflow.
+		StringReader sr = new StringReader(sampleText);
+		XMLStreamReader inflow = inputFactory.createXMLStreamReader(sr);
+		
+		// Create a Block from the inflow.  Assume that we know the QName already
+		Block block = f.createFrom(inflow, null, sampleQName);
+		
+		// We passed in a qname, so the following should return false
+		assertTrue(block.isQNameAvailable());
+		
+		// Let's assume we need to get the QName to find the operation name.
+		QName qName = block.getQName();
+		assertTrue(sampleQName.equals(qName));
+		
+		// Assuming no handlers are installed, the next thing that will happen
+		// is the proxy code will ask for the business object (String).
+		Object bo = block.getBusinessObject(true);
+		assertTrue(bo instanceof Source);
+		
+		// The block should be consumed
+		assertTrue(block.isConsumed());
+
+		// Check the String for accuracy
+		XMLStreamReader reader = inputFactory.createXMLStreamReader((Source) bo);
+		Reader2Writer r2w = new Reader2Writer(reader);
+		String newText = r2w.getAsString();
+		assertTrue(sampleText.equals(newText));
+		
+	}
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/StockQuoteIF.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/StockQuoteIF.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/StockQuoteIF.java	(revision 0)
@@ -0,0 +1,42 @@
+
+package org.apache.axis2.jaxws.jaxb.mfquote;
+
+import javax.jws.WebMethod;
+import javax.jws.WebParam;
+import javax.jws.WebResult;
+import javax.jws.WebService;
+import javax.xml.ws.RequestWrapper;
+import javax.xml.ws.ResponseWrapper;
+
+
+/**
+ * This class was generated by the JAXWS SI.
+ * JAX-WS RI 2.0_01-b15-fcs
+ * Generated source version: 2.0
+ * 
+ */
+@WebService(name = "StockQuoteIF", targetNamespace = "http://org/apache/axis2/jaxws/test")
+public interface StockQuoteIF {
+
+
+    /**
+     * 
+     * @param  10Holdings
+     * @param fund
+     * @param nav
+     * @return
+     *     returns java.lang.String
+     */
+    @WebMethod(action = "http://tempuri.org/StockQuote/getPrice")
+    @WebResult(name = "price", targetNamespace = "")
+    @RequestWrapper(localName = "getPrice", targetNamespace = "http://org/apache/axis2/jaxws/test", className = "org.apache.axis2.jaxws.jaxb.mfquote.GetPrice")
+    @ResponseWrapper(localName = "getPriceResponse", targetNamespace = "http://org/apache/axis2/jaxws/test", className = "org.apache.axis2.jaxws.jaxb.mfquote.StockPrice")
+    public String getPrice(
+        @WebParam(name = "fund", targetNamespace = "")
+        String fund,
+        @WebParam(name = "_10holdings", targetNamespace = "")
+        String _10Holdings,
+        @WebParam(name = "nav", targetNamespace = "")
+        String nav);
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/StockQuote.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/StockQuote.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/StockQuote.java	(revision 0)
@@ -0,0 +1,53 @@
+
+package org.apache.axis2.jaxws.jaxb.mfquote;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import javax.xml.namespace.QName;
+import javax.xml.ws.Service;
+import javax.xml.ws.WebEndpoint;
+import javax.xml.ws.WebServiceClient;
+
+
+/**
+ * This class was generated by the JAXWS SI.
+ * JAX-WS RI 2.0_01-b15-fcs
+ * Generated source version: 2.0
+ * 
+ */
+@WebServiceClient(name = "StockQuote", targetNamespace = "http://org/apache/axis2/jaxws/test", wsdlLocation = "StockQuote.wsdl")
+public class StockQuote
+    extends Service
+{
+
+    private final static URL STOCKQUOTE_WSDL_LOCATION;
+
+    static {
+        URL url = null;
+        try {
+            url = new URL("file:/C:/temp/StockQuote.wsdl");
+        } catch (MalformedURLException e) {
+            e.printStackTrace();
+        }
+        STOCKQUOTE_WSDL_LOCATION = url;
+    }
+
+    public StockQuote(URL wsdlLocation, QName serviceName) {
+        super(wsdlLocation, serviceName);
+    }
+
+    public StockQuote() {
+        super(STOCKQUOTE_WSDL_LOCATION, new QName("http://org/apache/axis2/jaxws/test", "StockQuote"));
+    }
+
+    /**
+     * 
+     * @return
+     *     returns StockQuoteIF
+     */
+    @WebEndpoint(name = "StockQuotePort")
+    public StockQuoteIF getStockQuotePort() {
+        return (StockQuoteIF)super.getPort(new QName("http://org/apache/axis2/jaxws/test", "StockQuotePort"), StockQuoteIF.class);
+    }
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/GetPrice.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/GetPrice.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/GetPrice.java	(revision 0)
@@ -0,0 +1,118 @@
+
+package org.apache.axis2.jaxws.jaxb.mfquote;
+
+import javax.xml.bind.annotation.AccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+
+/**
+ * <p>Java class for getPrice complex type.
+ * 
+ * <p>The following schema fragment specifies the expected content contained within this class.
+ * 
+ * <pre>
+ * &lt;complexType name="getPrice">
+ *   &lt;complexContent>
+ *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
+ *       &lt;sequence>
+ *         &lt;element name="fund" type="{http://www.w3.org/2001/XMLSchema}string"/>
+ *         &lt;element name="10holdings" type="{http://www.w3.org/2001/XMLSchema}string"/>
+ *         &lt;element name="nav" type="{http://www.w3.org/2001/XMLSchema}string"/>
+ *       &lt;/sequence>
+ *     &lt;/restriction>
+ *   &lt;/complexContent>
+ * &lt;/complexType>
+ * </pre>
+ * 
+ * 
+ */
+@XmlAccessorType(AccessType.FIELD)
+@XmlType(name = "getPrice", propOrder = {
+    "fund",
+    "_10Holdings",
+    "nav"
+})
+public class GetPrice {
+
+    @XmlElement()
+    protected String fund;
+    @XmlElement(name = "10holdings")
+    protected String _10Holdings;
+    @XmlElement()
+    protected String nav;
+
+    /**
+     * Gets the value of the fund property.
+     * 
+     * @return
+     *     possible object is
+     *     {@link String }
+     *     
+     */
+    public String getFund() {
+        return fund;
+    }
+
+    /**
+     * Sets the value of the fund property.
+     * 
+     * @param value
+     *     allowed object is
+     *     {@link String }
+     *     
+     */
+    public void setFund(String value) {
+        this.fund = value;
+    }
+
+    /**
+     * Gets the value of the 10Holdings property.
+     * 
+     * @return
+     *     possible object is
+     *     {@link String }
+     *     
+     */
+    public String get10Holdings() {
+        return _10Holdings;
+    }
+
+    /**
+     * Sets the value of the 10Holdings property.
+     * 
+     * @param value
+     *     allowed object is
+     *     {@link String }
+     *     
+     */
+    public void set10Holdings(String value) {
+        this._10Holdings = value;
+    }
+
+    /**
+     * Gets the value of the nav property.
+     * 
+     * @return
+     *     possible object is
+     *     {@link String }
+     *     
+     */
+    public String getNav() {
+        return nav;
+    }
+
+    /**
+     * Sets the value of the nav property.
+     * 
+     * @param value
+     *     allowed object is
+     *     {@link String }
+     *     
+     */
+    public void setNav(String value) {
+        this.nav = value;
+    }
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/package-info.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/package-info.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/package-info.java	(revision 0)
@@ -0,0 +1,2 @@
+@javax.xml.bind.annotation.XmlSchema(namespace = "http://com/ibm/webservices/jaxws/test")
+package org.apache.axis2.jaxws.jaxb.mfquote;
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/StockPrice.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/StockPrice.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/StockPrice.java	(revision 0)
@@ -0,0 +1,63 @@
+
+package org.apache.axis2.jaxws.jaxb.mfquote;
+
+import javax.xml.bind.annotation.AccessType;
+
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+
+/**
+ * <p>Java class for StockPrice complex type.
+ * 
+ * <p>The following schema fragment specifies the expected content contained within this class.
+ * 
+ * <pre>
+ * &lt;complexType name="StockPrice">
+ *   &lt;complexContent>
+ *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
+ *       &lt;sequence>
+ *         &lt;element name="price" type="{http://www.w3.org/2001/XMLSchema}string"/>
+ *       &lt;/sequence>
+ *     &lt;/restriction>
+ *   &lt;/complexContent>
+ * &lt;/complexType>
+ * </pre>
+ * 
+ * 
+ */
+@XmlAccessorType(AccessType.FIELD)
+@XmlType(name = "StockPrice", propOrder = {
+    "price"
+})
+public class StockPrice {
+
+    @XmlElement()
+    protected String price;
+
+    /**
+     * Gets the value of the price property.
+     * 
+     * @return
+     *     possible object is
+     *     {@link String }
+     *     
+     */
+    public String getPrice() {
+        return price;
+    }
+
+    /**
+     * Sets the value of the price property.
+     * 
+     * @param value
+     *     allowed object is
+     *     {@link String }
+     *     
+     */
+    public void setPrice(String value) {
+        this.price = value;
+    }
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/ObjectFactory.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/ObjectFactory.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/mfquote/ObjectFactory.java	(revision 0)
@@ -0,0 +1,71 @@
+
+package org.apache.axis2.jaxws.jaxb.mfquote;
+
+import javax.xml.bind.JAXBElement;
+import javax.xml.bind.annotation.XmlElementDecl;
+import javax.xml.bind.annotation.XmlRegistry;
+import javax.xml.namespace.QName;
+
+
+/**
+ * This object contains factory methods for each 
+ * Java content interface and Java element interface 
+ * generated in the org.apache.axis2.jaxws.jaxb.mfquote package. 
+ * <p>An ObjectFactory allows you to programatically 
+ * construct new instances of the Java representation 
+ * for XML content. The Java representation of XML 
+ * content can consist of schema derived interfaces 
+ * and classes representing the binding of schema 
+ * type definitions, element declarations and model 
+ * groups.  Factory methods for each of these are 
+ * provided in this class.
+ * 
+ */
+@XmlRegistry
+public class ObjectFactory {
+
+    private final static QName _GetPriceResponse_QNAME = new QName("http://com/ibm/webservices/jaxws/test", "getPriceResponse");
+    private final static QName _GetPrice_QNAME = new QName("http://com/ibm/webservices/jaxws/test", "getPrice");
+
+    /**
+     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: org.apache.axis2.jaxws.jaxb.mfquote
+     * 
+     */
+    public ObjectFactory() {
+    }
+
+    /**
+     * Create an instance of {@link StockPrice }
+     * 
+     */
+    public StockPrice createStockPrice() {
+        return new StockPrice();
+    }
+
+    /**
+     * Create an instance of {@link GetPrice }
+     * 
+     */
+    public GetPrice createGetPrice() {
+        return new GetPrice();
+    }
+
+    /**
+     * Create an instance of {@link JAXBElement }{@code <}{@link StockPrice }{@code >}}
+     * 
+     */
+    @XmlElementDecl(namespace = "http://com/ibm/webservices/jaxws/test", name = "getPriceResponse")
+    public JAXBElement<StockPrice> createGetPriceResponse(StockPrice value) {
+        return new JAXBElement<StockPrice>(_GetPriceResponse_QNAME, StockPrice.class, null, value);
+    }
+
+    /**
+     * Create an instance of {@link JAXBElement }{@code <}{@link GetPrice }{@code >}}
+     * 
+     */
+    @XmlElementDecl(namespace = "http://com/ibm/webservices/jaxws/test", name = "getPrice")
+    public JAXBElement<GetPrice> createGetPrice(GetPrice value) {
+        return new JAXBElement<GetPrice>(_GetPrice_QNAME, GetPrice.class, null, value);
+    }
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/wrapper/WrapperToolTest.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/wrapper/WrapperToolTest.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/wrapper/WrapperToolTest.java	(revision 0)
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.jaxws.jaxb.wrapper;
+
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+import org.apache.axis2.jaxws.jaxb.stockquote.GetPrice;
+import org.apache.axis2.jaxws.wrapper.JAXBWrapperTool;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperToolImpl;
+
+import junit.framework.TestCase;
+
+
+public class WrapperToolTest extends TestCase {
+	public void testWrapStockQuote(){
+		try{
+			JAXBWrapperTool wrapper = new JAXBWrapperToolImpl();
+			
+			String jaxbClassName = "org.apache.axis2.jaxws.jaxb.stockquote.GetPrice";
+			Class jaxbClass = Class.forName(jaxbClassName, false, ClassLoader.getSystemClassLoader());
+			ArrayList<String> childNames = new ArrayList<String>();
+			String childName = "symbol";
+			childNames.add(childName);
+			String symbolObj = new String("IBM");
+			Map<String, Object> childObjects= new WeakHashMap<String, Object>();
+			childObjects.put(childName, symbolObj);
+			Object jaxbObject = wrapper.wrap(jaxbClass, jaxbClassName,childNames, childObjects);
+			GetPrice getPrice = (GetPrice)jaxbObject;
+			
+		}catch(JAXBWrapperException e){
+			e.printStackTrace();
+		}catch(ClassNotFoundException e){
+			e.printStackTrace();
+		}
+	}
+	
+	public void testUnwrapStockQuote(){
+		try{
+			JAXBWrapperTool wrapper = new JAXBWrapperToolImpl();
+			GetPrice price = new GetPrice();
+			price.setSymbol("IBM");
+			
+			ArrayList<String> childNames = new ArrayList<String>();
+			String childName = "symbol";
+			childNames.add(childName);
+			
+			Object[] jaxbObjects = wrapper.unWrap(price, childNames);
+		
+		}catch(JAXBWrapperException e){
+			e.printStackTrace();
+		}
+	}
+	
+	public void testWrapMFQuote(){
+		try{
+			JAXBWrapperTool wrapper = new JAXBWrapperToolImpl();
+			
+			String jaxbClassName = "org.apache.axis2.jaxws.jaxb.mfquote.GetPrice";
+			Class jaxbClass = Class.forName(jaxbClassName, false, ClassLoader.getSystemClassLoader());
+			ArrayList<String> childNames = new ArrayList<String>();
+			String fund ="fund";
+			String fundName = new String("PRGFX");
+			String holding = "_10Holdings";
+			String topHolding = new String("GE");
+			String nav ="nav";
+			String navInMillion = new String("700");
+			
+			childNames.add(fund);
+			childNames.add(holding);
+			childNames.add(nav);
+			
+			Map<String, Object> childObjects= new WeakHashMap<String, Object>();
+			
+			childObjects.put(fund, fundName);
+			childObjects.put(holding, topHolding);
+			childObjects.put(nav, navInMillion);
+			
+			Object jaxbObject = wrapper.wrap(jaxbClass, jaxbClassName,childNames, childObjects);
+			org.apache.axis2.jaxws.jaxb.mfquote.GetPrice getPrice = (org.apache.axis2.jaxws.jaxb.mfquote.GetPrice)jaxbObject;
+			
+		}catch(JAXBWrapperException e){
+			e.printStackTrace();
+		}catch(ClassNotFoundException e){
+			e.printStackTrace();
+		}
+	}
+	
+	public void testUnwrapMFQuote(){
+		try{
+			JAXBWrapperTool wrapper = new JAXBWrapperToolImpl();
+			org.apache.axis2.jaxws.jaxb.mfquote.GetPrice price = new org.apache.axis2.jaxws.jaxb.mfquote.GetPrice();
+			price.setFund("PRGFX");
+			price.set10Holdings("GE");
+			price.setNav("700");
+			
+			ArrayList<String> childNames = new ArrayList<String>();
+			String fund ="fund";
+			childNames.add(fund);
+			String holding = "_10Holdings";
+			childNames.add(holding);
+			String nav ="nav";
+			childNames.add(nav);
+			
+			Object[] jaxbObjects = wrapper.unWrap(price, childNames);
+			System.out.println();
+		}catch(JAXBWrapperException e){
+			e.printStackTrace();
+		}
+	}
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/StockQuoteIF.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/StockQuoteIF.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/StockQuoteIF.java	(revision 0)
@@ -0,0 +1,36 @@
+
+package org.apache.axis2.jaxws.jaxb.stockquote;
+
+import javax.jws.WebMethod;
+import javax.jws.WebParam;
+import javax.jws.WebResult;
+import javax.jws.WebService;
+import javax.xml.ws.RequestWrapper;
+import javax.xml.ws.ResponseWrapper;
+
+
+/**
+ * This class was generated by the JAXWS SI.
+ * JAX-WS RI 2.0_01-b15-fcs
+ * Generated source version: 2.0
+ * 
+ */
+@WebService(name = "StockQuoteIF", targetNamespace = "http://org/apache/axis2/jaxws/test")
+public interface StockQuoteIF {
+
+
+    /**
+     * 
+     * @param symbol
+     * @return
+     *     returns java.lang.String
+     */
+    @WebMethod(action = "http://tempuri.org/StockQuote/getPrice")
+    @WebResult(name = "price", targetNamespace = "")
+    @RequestWrapper(localName = "getPrice", targetNamespace = "http://org/apache/axis2/jaxws/test", className = "org.apache.axis2.jaxws.jaxb.stockquote.GetPrice")
+    @ResponseWrapper(localName = "getPriceResponse", targetNamespace = "http://org/apache/axis2/jaxws/test", className = "org.apache.axis2.jaxws.jaxb.stockquote.StockPrice")
+    public String getPrice(
+        @WebParam(name = "symbol", targetNamespace = "")
+        String symbol);
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/StockQuote.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/StockQuote.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/StockQuote.java	(revision 0)
@@ -0,0 +1,53 @@
+
+package org.apache.axis2.jaxws.jaxb.stockquote;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import javax.xml.namespace.QName;
+import javax.xml.ws.Service;
+import javax.xml.ws.WebEndpoint;
+import javax.xml.ws.WebServiceClient;
+
+
+/**
+ * This class was generated by the JAXWS SI.
+ * JAX-WS RI 2.0_01-b15-fcs
+ * Generated source version: 2.0
+ * 
+ */
+@WebServiceClient(name = "StockQuote", targetNamespace = "http://org/apache/axis2/jaxws/test", wsdlLocation = "StockQuote.wsdl")
+public class StockQuote
+    extends Service
+{
+
+    private final static URL STOCKQUOTE_WSDL_LOCATION;
+
+    static {
+        URL url = null;
+        try {
+            url = new URL("http://org/apache/axis2/jaxws/test/StockQuote.wsdl");
+        } catch (MalformedURLException e) {
+            e.printStackTrace();
+        }
+        STOCKQUOTE_WSDL_LOCATION = url;
+    }
+
+    public StockQuote(URL wsdlLocation, QName serviceName) {
+        super(wsdlLocation, serviceName);
+    }
+
+    public StockQuote() {
+        super(STOCKQUOTE_WSDL_LOCATION, new QName("http://org/apache/axis2/jaxws/test", "StockQuote"));
+    }
+
+    /**
+     * 
+     * @return
+     *     returns StockQuoteIF
+     */
+    @WebEndpoint(name = "StockQuotePort")
+    public StockQuoteIF getStockQuotePort() {
+        return (StockQuoteIF)super.getPort(new QName("http://org/apache/axis2/jaxws/test", "StockQuotePort"), StockQuoteIF.class);
+    }
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/GetPrice.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/GetPrice.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/GetPrice.java	(revision 0)
@@ -0,0 +1,63 @@
+
+package org.apache.axis2.jaxws.jaxb.stockquote;
+
+import javax.xml.bind.annotation.AccessType;
+
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+
+/**
+ * <p>Java class for getPrice complex type.
+ * 
+ * <p>The following schema fragment specifies the expected content contained within this class.
+ * 
+ * <pre>
+ * &lt;complexType name="getPrice">
+ *   &lt;complexContent>
+ *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
+ *       &lt;sequence>
+ *         &lt;element name="symbol" type="{http://www.w3.org/2001/XMLSchema}string"/>
+ *       &lt;/sequence>
+ *     &lt;/restriction>
+ *   &lt;/complexContent>
+ * &lt;/complexType>
+ * </pre>
+ * 
+ * 
+ */
+@XmlAccessorType(AccessType.FIELD)
+@XmlType(name = "getPrice", propOrder = {
+    "symbol"
+})
+public class GetPrice {
+
+    @XmlElement()
+    protected String symbol;
+
+    /**
+     * Gets the value of the symbol property.
+     * 
+     * @return
+     *     possible object is
+     *     {@link String }
+     *     
+     */
+    public String getSymbol() {
+        return symbol;
+    }
+
+    /**
+     * Sets the value of the symbol property.
+     * 
+     * @param value
+     *     allowed object is
+     *     {@link String }
+     *     
+     */
+    public void setSymbol(String value) {
+        this.symbol = value;
+    }
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/package-info.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/package-info.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/package-info.java	(revision 0)
@@ -0,0 +1,2 @@
+@javax.xml.bind.annotation.XmlSchema(namespace = "http://com/ibm/webservices/jaxws/test")
+package org.apache.axis2.jaxws.jaxb.stockquote;
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/StockPrice.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/StockPrice.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/StockPrice.java	(revision 0)
@@ -0,0 +1,63 @@
+
+package org.apache.axis2.jaxws.jaxb.stockquote;
+
+import javax.xml.bind.annotation.AccessType;
+
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+
+/**
+ * <p>Java class for StockPrice complex type.
+ * 
+ * <p>The following schema fragment specifies the expected content contained within this class.
+ * 
+ * <pre>
+ * &lt;complexType name="StockPrice">
+ *   &lt;complexContent>
+ *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
+ *       &lt;sequence>
+ *         &lt;element name="price" type="{http://www.w3.org/2001/XMLSchema}string"/>
+ *       &lt;/sequence>
+ *     &lt;/restriction>
+ *   &lt;/complexContent>
+ * &lt;/complexType>
+ * </pre>
+ * 
+ * 
+ */
+@XmlAccessorType(AccessType.FIELD)
+@XmlType(name = "StockPrice", propOrder = {
+    "price"
+})
+public class StockPrice {
+
+    @XmlElement()
+    protected String price;
+
+    /**
+     * Gets the value of the price property.
+     * 
+     * @return
+     *     possible object is
+     *     {@link String }
+     *     
+     */
+    public String getPrice() {
+        return price;
+    }
+
+    /**
+     * Sets the value of the price property.
+     * 
+     * @param value
+     *     allowed object is
+     *     {@link String }
+     *     
+     */
+    public void setPrice(String value) {
+        this.price = value;
+    }
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/ObjectFactory.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/ObjectFactory.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/jaxb/stockquote/ObjectFactory.java	(revision 0)
@@ -0,0 +1,71 @@
+
+package org.apache.axis2.jaxws.jaxb.stockquote;
+
+import javax.xml.bind.JAXBElement;
+import javax.xml.bind.annotation.XmlElementDecl;
+import javax.xml.bind.annotation.XmlRegistry;
+import javax.xml.namespace.QName;
+
+
+/**
+ * This object contains factory methods for each 
+ * Java content interface and Java element interface 
+ * generated in the org.apache.axis2.jaxws.jaxb package. 
+ * <p>An ObjectFactory allows you to programatically 
+ * construct new instances of the Java representation 
+ * for XML content. The Java representation of XML 
+ * content can consist of schema derived interfaces 
+ * and classes representing the binding of schema 
+ * type definitions, element declarations and model 
+ * groups.  Factory methods for each of these are 
+ * provided in this class.
+ * 
+ */
+@XmlRegistry
+public class ObjectFactory {
+
+    private final static QName _GetPriceResponse_QNAME = new QName("http://com/ibm/webservices/jaxws/test", "getPriceResponse");
+    private final static QName _GetPrice_QNAME = new QName("http://com/ibm/webservices/jaxws/test", "getPrice");
+
+    /**
+     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: org.apache.axis2.jaxws.jaxb
+     * 
+     */
+    public ObjectFactory() {
+    }
+
+    /**
+     * Create an instance of {@link GetPrice }
+     * 
+     */
+    public GetPrice createGetPrice() {
+        return new GetPrice();
+    }
+
+    /**
+     * Create an instance of {@link StockPrice }
+     * 
+     */
+    public StockPrice createStockPrice() {
+        return new StockPrice();
+    }
+
+    /**
+     * Create an instance of {@link JAXBElement }{@code <}{@link StockPrice }{@code >}}
+     * 
+     */
+    @XmlElementDecl(namespace = "http://com/ibm/webservices/jaxws/test", name = "getPriceResponse")
+    public JAXBElement<StockPrice> createGetPriceResponse(StockPrice value) {
+        return new JAXBElement<StockPrice>(_GetPriceResponse_QNAME, StockPrice.class, null, value);
+    }
+
+    /**
+     * Create an instance of {@link JAXBElement }{@code <}{@link GetPrice }{@code >}}
+     * 
+     */
+    @XmlElementDecl(namespace = "http://com/ibm/webservices/jaxws/test", name = "getPrice")
+    public JAXBElement<GetPrice> createGetPrice(GetPrice value) {
+        return new JAXBElement<GetPrice>(_GetPrice_QNAME, GetPrice.class, null, value);
+    }
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/DispatchTestSuite.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/DispatchTestSuite.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/DispatchTestSuite.java	(working copy)
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.axis2.jaxws;
 
 import junit.framework.TestSuite;
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/source/META-INF/services.xml
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/source/META-INF/services.xml	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/source/META-INF/services.xml	(revision 0)
@@ -0,0 +1,12 @@
+<serviceGroup>
+ <service name="SourceProviderService">
+  <messageReceivers>
+   <messageReceiver mep="http://www.w3.org/2004/08/wsdl/in-out" class="org.apache.axis2.jaxws.server.JAXWSMessageReceiver"/>
+  </messageReceivers>
+  <parameter locked="false" name="ServiceClass">org.apache.axis2.jaxws.provider.source.SourceProvider</parameter>
+  <operation name="invoke" mep="http://www.w3.org/2004/08/wsdl/in-out">
+    <actionMapping/>
+  </operation>
+ </service>
+</serviceGroup>
+
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/source/META-INF/MANIFEST.MF
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/source/META-INF/MANIFEST.MF	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/source/META-INF/MANIFEST.MF	(revision 0)
@@ -0,0 +1 @@
+Manifest-Version: 1.0
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/source/SourceProvider.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/source/SourceProvider.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/source/SourceProvider.java	(revision 0)
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.provider.source;
+
+import javax.xml.ws.Provider;
+import javax.xml.transform.Source;
+
+public class SourceProvider implements Provider<Source> {
+    
+    public Source invoke(Source source) {
+    	System.out.println(">> SourceProvider: Request received.\n");
+    	System.out.println(">> Source toString: \n"+source.toString());
+        return source;
+    }
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/StringProviderTests.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/StringProviderTests.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/StringProviderTests.java	(revision 0)
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.provider;
+
+import java.util.Map;
+
+import javax.xml.namespace.QName;
+import javax.xml.ws.BindingProvider;
+import javax.xml.ws.Dispatch;
+import javax.xml.ws.Service;
+
+public class StringProviderTests extends ProviderTestCase {
+
+    String endpointUrl = "http://localhost:8080/axis2/services/StringProviderService";
+    String xmlString = "<invoke>test input</invoke>";
+    private QName serviceName = new QName("http://ws.apache.org/axis2", "StringProviderService");
+
+    protected void setUp() throws Exception {
+            super.setUp();
+    }
+
+    protected void tearDown() throws Exception {
+            super.tearDown();
+    }
+
+    public StringProviderTests(String name) {
+        super(name);
+    }
+    
+    public void testProviderString() {
+        System.out.println("---------------------------------------");
+        Service svc = Service.create(serviceName);
+        svc.addPort(portName,null, endpointUrl);
+        Dispatch<String> dispatch = svc
+                .createDispatch(portName, String.class, null);
+        Map<String, Object> requestContext = dispatch.getRequestContext();
+        requestContext.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,
+                endpointUrl);
+        System.out.println(">> Invoking SimpleProvider");
+        String retVal = dispatch.invoke(xmlString);
+        System.out.println(">> Response [" + retVal + "]");
+    }
+}
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/string/META-INF/services.xml
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/string/META-INF/services.xml	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/string/META-INF/services.xml	(revision 0)
@@ -0,0 +1,12 @@
+<serviceGroup>
+ <service name="StringProviderService">
+  <messageReceivers>
+   <messageReceiver mep="http://www.w3.org/2004/08/wsdl/in-out" class="org.apache.axis2.jaxws.server.JAXWSMessageReceiver"/>
+  </messageReceivers>
+  <parameter locked="false" name="ServiceClass">org.apache.axis2.jaxws.provider.string.StringProvider</parameter>
+  <operation name="invoke" mep="http://www.w3.org/2004/08/wsdl/in-out">
+    <actionMapping/>
+  </operation>
+ </service>
+</serviceGroup>
+
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/string/META-INF/MANIFEST.MF
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/string/META-INF/MANIFEST.MF	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/string/META-INF/MANIFEST.MF	(revision 0)
@@ -0,0 +1 @@
+Manifest-Version: 1.0
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/string/StringProvider.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/string/StringProvider.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/string/StringProvider.java	(revision 0)
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.provider.string;
+
+import javax.xml.ws.Provider;
+
+public class StringProvider implements Provider<String> {
+
+    private static String responseGood = "<provider><message>request processed</message></provider>";
+    private static String responseBad  = "<provider><message>ERROR:null request received</message><provider>";
+    
+    public String invoke(String obj) {
+        if (obj != null) {
+            String str = (String) obj;
+            System.out.println(">> StringProvider received a new request");
+            System.out.println(">> request [" + str + "]");
+            
+            return responseGood;
+        }
+        System.out.println(">> ERROR:null request received");
+        return responseBad;
+    }
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/ProviderTestCase.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/ProviderTestCase.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/ProviderTestCase.java	(revision 0)
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.provider;
+
+import java.io.File;
+import javax.xml.namespace.QName;
+import junit.framework.TestCase;
+
+public abstract class ProviderTestCase extends TestCase {
+
+    public QName portName = new QName("http://ws.apache.org/axis2", "SimpleProviderServiceSOAP11port0");
+    public String providerResourceDir = "test-resources"+File.separator+"provider";
+    public String basedir = null;
+    
+	protected void setUp() throws Exception {
+		super.setUp();
+		//StartServer startServer = new StartServer("server1");
+		//startServer.testStartServer();
+	}
+
+	protected void tearDown() throws Exception {
+		super.tearDown();
+		//StopServer stopServer = new StopServer("server1");
+		//stopServer.testStopServer();
+	}
+	
+    public ProviderTestCase(String name) {
+        super(name);
+        if(basedir == null){
+            basedir = new File(".").getAbsolutePath();
+        }
+        providerResourceDir = new File(basedir, providerResourceDir).getAbsolutePath();
+    }
+    
+}
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/SourceProviderTests.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/SourceProviderTests.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/provider/SourceProviderTests.java	(revision 0)
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.provider;
+
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.util.Map;
+import javax.xml.namespace.QName;
+import javax.xml.ws.BindingProvider;
+import javax.xml.ws.Dispatch;
+import javax.xml.ws.Service;
+import javax.xml.transform.Source;
+import javax.xml.transform.stream.StreamSource;
+
+public class SourceProviderTests extends ProviderTestCase {
+
+    private String endpointUrl = "http://localhost:8080/axis2/services/SourceProviderService";
+    private QName serviceName = new QName("http://ws.apache.org/axis2", "SourceProviderService");
+    private String xmlDir = "xml";
+
+
+    protected void setUp() throws Exception {
+            super.setUp();
+    }
+
+    protected void tearDown() throws Exception {
+            super.tearDown();
+    }
+
+    public SourceProviderTests(String name) {
+        super(name);
+    }
+    
+    public void testProviderSource(){
+        try{
+        	String resourceDir = new File(providerResourceDir, xmlDir).getAbsolutePath();
+        	String fileName = resourceDir+File.separator+"web.xml";
+        	
+        	File file = new File(fileName);
+        	InputStream inputStream = new FileInputStream(file);
+        	StreamSource xmlStreamSource = new StreamSource(inputStream);
+        	
+        	Service svc = Service.create(serviceName);
+        	svc.addPort(portName,null, null);
+        	Dispatch<Source> dispatch = svc.createDispatch(portName, Source.class, null);
+        	Map<String, Object> requestContext = dispatch.getRequestContext();
+        	requestContext.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, endpointUrl);
+        	System.out.println(">> Invoking Source Provider Dispatch");
+        	Source response = dispatch.invoke(xmlStreamSource);
+
+        	System.out.println(">> Response [" + response.toString() + "]");
+        	
+        }catch(Exception e){
+        	e.printStackTrace();
+        }
+        
+    }
+}
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/framework/StartServer.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/framework/StartServer.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/framework/StartServer.java	(working copy)
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.axis2.jaxws.framework;
 
 import org.apache.axis2.jaxws.util.SimpleServer;
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java	(working copy)
@@ -1,12 +1,37 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.axis2.jaxws.framework;
 
-import org.apache.axis2.jaxws.DispatchTestSuite;
-
 import junit.extensions.TestSetup;
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
 
+import org.apache.axis2.jaxws.DispatchTestSuite;
+import org.apache.axis2.jaxws.description.ServiceDescriptionTests;
+import org.apache.axis2.jaxws.description.WSDLDescriptionTests;
+import org.apache.axis2.jaxws.description.WSDLTests;
+import org.apache.axis2.jaxws.handler.HandlerChainProcessorTests;
+import org.apache.axis2.jaxws.message.BlockTests;
+import org.apache.axis2.jaxws.message.MessageTests;
+import org.apache.axis2.jaxws.message.SAAJConverterTests;
+import org.apache.axis2.jaxws.message.XMLStreamReaderSplitterTests;
+import org.apache.axis2.jaxws.provider.*;
+
 public class JAXWSTest extends TestCase {
     /**
      * suite
@@ -18,8 +43,20 @@
         // Add each of the test suites
         suite = DispatchTestSuite.addTestSuites(suite);
         
-        // Add individual test classes
-        // TODO: suite.addTestSuite(SimpleProvider.class);
+        
+        suite.addTestSuite(BlockTests.class);
+        suite.addTestSuite(MessageTests.class);
+        suite.addTestSuite(SAAJConverterTests.class);
+        suite.addTestSuite(XMLStreamReaderSplitterTests.class);
+        
+        suite.addTestSuite(WSDLTests.class);
+        suite.addTestSuite(ServiceDescriptionTests.class);
+        suite.addTestSuite(WSDLDescriptionTests.class);
+        
+        suite.addTestSuite(HandlerChainProcessorTests.class);
+        
+        suite.addTestSuite(StringProviderTests.class);
+        suite.addTestSuite(SourceProviderTests.class);
 
         // Start (and stop) the server only once for all the tests
         TestSetup testSetup = new TestSetup(suite) {
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/framework/StopServer.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/framework/StopServer.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/framework/StopServer.java	(working copy)
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.axis2.jaxws.framework;
 
 import org.apache.axis2.jaxws.util.SimpleServer;
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/DOMSourceDispatch.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/DOMSourceDispatch.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/DOMSourceDispatch.java	(working copy)
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.axis2.jaxws;
 
 import java.io.ByteArrayInputStream;
@@ -38,7 +54,7 @@
 		try {
 			System.out.println("---------------------------------------");
 			Service svc = Service.create(serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					null);
 			ByteArrayInputStream stream = new ByteArrayInputStream(xmlString
@@ -75,7 +91,7 @@
 		try {
 			System.out.println("---------------------------------------");
 			Service svc = Service.create(serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					Mode.MESSAGE);
 			ByteArrayInputStream stream = new ByteArrayInputStream(soapMessage.getBytes());
@@ -107,7 +123,7 @@
 			System.out.println("---------------------------------------");
 	        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
 	        Service svc = Service.create(serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					Mode.MESSAGE);
 			ByteArrayInputStream stream = new ByteArrayInputStream(soapMessage
@@ -141,7 +157,7 @@
 			System.out.println("---------------------------------------");
 			 URL wsdlUrl = new URL(endpointUrl + "?wsdl");
 			Service svc = Service.create(wsdlUrl,serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					Mode.PAYLOAD);
 			ByteArrayInputStream stream = new ByteArrayInputStream(xmlString
@@ -174,7 +190,7 @@
 			System.out.println("---------------------------------------");
 	        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
 	        Service svc = Service.create(serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					null);
 			ByteArrayInputStream stream = new ByteArrayInputStream(xmlString
@@ -206,7 +222,7 @@
 		try {
 			System.out.println("---------------------------------------");
 			Service svc = Service.create(serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					null);
 			ByteArrayInputStream stream = new ByteArrayInputStream(xmlString
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/SourceDispatch.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/SourceDispatch.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/SourceDispatch.java	(working copy)
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.axis2.jaxws;
 
 import java.io.ByteArrayInputStream;
@@ -31,7 +47,7 @@
 		try {
 			System.out.println("---------------------------------------");
 			Service svc = Service.create(serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					null);
 			ByteArrayInputStream stream = new ByteArrayInputStream(xmlString
@@ -66,7 +82,7 @@
 		try {
 			System.out.println("---------------------------------------");
 			Service svc = Service.create(serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					Mode.MESSAGE);
 			
@@ -97,7 +113,7 @@
 			System.out.println("---------------------------------------");
 	        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
 	        Service svc = Service.create(serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					Mode.MESSAGE);
 			ByteArrayInputStream stream = new ByteArrayInputStream(soapMessage
@@ -128,7 +144,7 @@
 			System.out.println("---------------------------------------");
 			 URL wsdlUrl = new URL(endpointUrl + "?wsdl");
 			Service svc = Service.create(wsdlUrl,serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					Mode.PAYLOAD);
 			ByteArrayInputStream stream = new ByteArrayInputStream(xmlString
@@ -163,7 +179,7 @@
 		System.out.println("---------------------------------------");
         CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
         Service svc = Service.create(serviceQname);
-		svc.addPort(portQname, null, null);
+		svc.addPort(portQname, null, endpointUrl);
 		Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 				null);
 		ByteArrayInputStream stream = new ByteArrayInputStream(xmlString
@@ -193,7 +209,7 @@
 		try {
 			System.out.println("---------------------------------------");
 			Service svc = Service.create(serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					null);
 			ByteArrayInputStream stream = new ByteArrayInputStream(xmlString
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/StringDispatch.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/StringDispatch.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/StringDispatch.java	(working copy)
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.axis2.jaxws;
 
 import java.util.Map;
@@ -31,7 +47,7 @@
     public void testSync() {
         System.out.println("---------------------------------------");
         Service svc = Service.create(serviceQname);
-        svc.addPort(portQname,null,null);
+        svc.addPort(portQname,null,endpointUrl);
         try{
 			Dispatch<String> dispatch = svc
 					.createDispatch(portQname, String.class, null);
@@ -136,7 +152,7 @@
         try{
 	        CallbackHandler<String> callbackHandler = new CallbackHandler<String>();
 			    Service svc = Service.create(serviceQname);
-			    svc.addPort(portQname, null, null);
+			    svc.addPort(portQname, null, endpointUrl);
 			    Dispatch<String> dispatch = svc
 					  .createDispatch(portQname, String.class, null);
 			    Map<String, Object> requestContext = dispatch.getRequestContext();
@@ -167,7 +183,7 @@
     	 try{
 	        CallbackHandler<String> callbackHandler = new CallbackHandler<String>();
 	 		Service svc = Service.create(serviceQname);
-	 		svc.addPort(portQname, null, null);
+	 		svc.addPort(portQname, null, endpointUrl);
 	 		Dispatch<String> dispatch = svc
 	 				.createDispatch(portQname, String.class, Mode.MESSAGE);
 	 		Map<String, Object> requestContext = dispatch.getRequestContext();
@@ -197,7 +213,7 @@
         System.out.println("---------------------------------------");
         try{
 	        Service svc = Service.create(serviceQname);
-	        svc.addPort(portQname, null, null);
+	        svc.addPort(portQname, null, endpointUrl);
 	        Dispatch<String> dispatch = svc
 					.createDispatch(portQname, String.class, null);
 			Map<String, Object> requestContext = dispatch.getRequestContext();
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/CallbackHandler.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/CallbackHandler.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/CallbackHandler.java	(working copy)
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.axis2.jaxws;
 
 import java.io.StringWriter;
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/DispatchTestConstants.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/DispatchTestConstants.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/DispatchTestConstants.java	(working copy)
@@ -1,10 +1,26 @@
-package org.apache.axis2.jaxws;
-
-import javax.xml.namespace.QName;
-
-public class DispatchTestConstants {
-
-    public static String URL = "http://localhost:8080/axis2/services/EchoService";
-    public static QName QNAME_SERVICE = new QName("http://ws.apache.org/axis2", "EchoService");
-    public static QName QNAME_PORT = new QName("http://ws.apache.org/axis2", "EchoServiceSOAP11port0");
-}
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws;
+
+import javax.xml.namespace.QName;
+
+public class DispatchTestConstants {
+
+    public static String URL = "http://localhost:8080/axis2/services/EchoService";
+    public static QName QNAME_SERVICE = new QName("http://ws.apache.org/axis2", "EchoService");
+    public static QName QNAME_PORT = new QName("http://ws.apache.org/axis2", "EchoServiceSOAP11port0");
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/SAXSourceDispatch.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/SAXSourceDispatch.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/SAXSourceDispatch.java	(working copy)
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.axis2.jaxws;
 
 import java.io.ByteArrayInputStream;
@@ -31,7 +47,7 @@
 		try {
 			System.out.println("---------------------------------------");
 			Service svc = Service.create(serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					null);
 			ByteArrayInputStream stream = new ByteArrayInputStream(xmlString
@@ -62,7 +78,7 @@
 		try {
 			System.out.println("---------------------------------------");
 			Service svc = Service.create(serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					Mode.MESSAGE);
 			ByteArrayInputStream stream = new ByteArrayInputStream(soapMessage.getBytes());
@@ -94,7 +110,7 @@
 			System.out.println("---------------------------------------");
 	        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
 	        Service svc = Service.create(serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					Mode.MESSAGE);
 			ByteArrayInputStream stream = new ByteArrayInputStream(soapMessage
@@ -126,7 +142,7 @@
 			System.out.println("---------------------------------------");
 			 URL wsdlUrl = new URL(endpointUrl + "?wsdl");
 			Service svc = Service.create(wsdlUrl,serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					Mode.PAYLOAD);
 			ByteArrayInputStream stream = new ByteArrayInputStream(xmlString
@@ -161,7 +177,7 @@
 		System.out.println("---------------------------------------");
         CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
         Service svc = Service.create(serviceQname);
-		svc.addPort(portQname, null, null);
+		svc.addPort(portQname, null, endpointUrl);
 		Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 				null);
 		ByteArrayInputStream stream = new ByteArrayInputStream(xmlString
@@ -189,7 +205,7 @@
 		try {
 			System.out.println("---------------------------------------");
 			Service svc = Service.create(serviceQname);
-			svc.addPort(portQname, null, null);
+			svc.addPort(portQname, null, endpointUrl);
 			Dispatch<Source> dispatch = svc.createDispatch(portQname, Source.class,
 					null);
 			ByteArrayInputStream stream = new ByteArrayInputStream(xmlString
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/handler/HandlerChainProcessorTests.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/handler/HandlerChainProcessorTests.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/handler/HandlerChainProcessorTests.java	(revision 0)
@@ -0,0 +1,908 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.handler;
+
+import java.util.ArrayList;
+import java.util.Set;
+
+import javax.xml.ws.ProtocolException;
+import javax.xml.ws.handler.Handler;
+import javax.xml.ws.handler.LogicalHandler;
+import javax.xml.ws.handler.soap.SOAPHandler;
+
+import junit.framework.TestCase;
+
+import org.apache.axis2.jaxws.core.MessageContext;
+
+/*
+ * There are myriad scenarios to test here:
+ * Handler implementations can implement two classes:  SOAPHandler or LogicalHandler (2)
+ * They implement two critical methods:  handleMessage and handleFault (2)
+ * These methods have four possible results:  true, false, ProtocolException, other exception
+ * 
+ * Besides the possible behaviors of the Handler implementations, we also
+ * have to consider whether the message is incoming or outgoing, whether
+ * it's a response or a request, and if a response is expected.
+ * 
+ * Do our best to cover all scenarios.
+ * 
+ * The testHandleMessage_* methods test the HandlerChainProcessor.processChain() method
+ * The testHandleFault_* methods test the HandlerChainProcessor.processFault() method
+ * 
+ */
+public class HandlerChainProcessorTests extends TestCase {
+
+	// String result is how we'll verify the right methods from
+	// the Handler implementations were called
+	private String result = new String();
+
+	private enum ResultDesired { TRUE, FALSE, PROTOCOL_EXCEPTION, OTHER_EXCEPTION };
+	
+	// use the following to dictate how the Handler methods behave
+	private ResultDesired soaphandler1_MessageResultDesired;
+	private ResultDesired soaphandler1_FaultResultDesired;
+	private ResultDesired soaphandler2_MessageResultDesired;
+	private ResultDesired soaphandler2_FaultResultDesired;
+	private ResultDesired logicalhandler1_MessageResultDesired;
+	private ResultDesired logicalhandler1_FaultResultDesired;
+	private ResultDesired logicalhandler2_MessageResultDesired;
+	private ResultDesired logicalhandler2_FaultResultDesired;
+
+	ArrayList<Handler> handlers = new ArrayList<Handler>();
+	
+	@Override
+	protected void setUp() throws Exception {
+		// HandlerChainProcessor expects a sorted chain
+		handlers.add(new LogicalHandler2());
+		handlers.add(new LogicalHandler1());
+		handlers.add(new SOAPHandler1());
+		handlers.add(new SOAPHandler2());
+	}
+	
+	/*
+	 * empty list
+	 */
+	public void testHandleMessage_empty1() {
+		
+		Exception local_exception = null;
+		
+		HandlerChainProcessor processor1 = new HandlerChainProcessor(null);
+		HandlerChainProcessor processor2 = new HandlerChainProcessor(new ArrayList<Handler>());
+		try {
+			processor1.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+			processor2.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+		} catch (Exception e) {
+			local_exception = e;
+		}
+		
+		// no exceptions!
+		assertNull(local_exception);
+	}
+	
+	/*
+	 * one protocol handler
+	 * processing expected:  Logical and SOAP, reverse order, close
+	 */
+	public void testHandleMessage_oneproto1() {
+		
+		// reset result
+		result = "";
+		
+		// use a local list
+		ArrayList<Handler> local_list = new ArrayList<Handler>();
+		local_list.add(new SOAPHandler1());
+		
+		// we want all good responses:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+	
+		HandlerChainProcessor processor = new HandlerChainProcessor(local_list);
+		
+		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
+
+		assertEquals("S1m:S1c:", result);
+		
+	}
+	
+	/*
+	 * one protocol handler in a logical context
+	 * no handlers will be processed
+	 */
+	public void testHandleMessage_oneproto2() {
+		
+		// reset result
+		result = "";
+		
+		// use a local list
+		ArrayList<Handler> local_list = new ArrayList<Handler>();
+		local_list.add(new SOAPHandler1());
+		
+		// we want all good responses:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+	
+		HandlerChainProcessor processor = new HandlerChainProcessor(local_list);
+		
+		processor.processChain(new LogicalMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
+
+		assertEquals("", result);
+	}
+	
+	/*
+	 * one logical handler
+	 * processing expected:  Logical and SOAP, reverse order, close
+	 */
+	public void testHandleMessage_onelogical() {
+		
+		// reset result
+		result = "";
+		
+		// use a local list
+		ArrayList<Handler> local_list = new ArrayList<Handler>();
+		local_list.add(new LogicalHandler1());
+		
+		// we want all good responses:
+		logicalhandler1_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+	
+		HandlerChainProcessor processor = new HandlerChainProcessor(local_list);
+		
+		processor.processChain(new LogicalMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
+
+		assertEquals("L1m:L1c:", result);
+	}
+
+	/*
+	 * incoming request (we must be on the server), response expected
+	 * processing expected:  Logical and SOAP, reverse order, no closing
+	 */
+	public void testHandleMessage_true1() {
+
+		// reset result
+		result = "";
+		
+		// we want all good responses:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		
+		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+
+		assertEquals("S2m:S1m:L1m:L2m:", result);
+		
+	}
+		
+	/*
+	 * incoming request (we must be on the server), response NOT expected
+	 * processing expected:  Logical and SOAP, reverse order, close
+	 */
+	public void testHandleMessage_true2() {
+		
+		// reset result
+		result = "";
+		
+		// we want all good responses:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		
+		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
+
+		assertEquals("S2m:S1m:L1m:L2m:L2c:L1c:S1c:S2c:", result);
+		
+	}
+	
+	/*
+	 * incoming response (we must be on the client), response expected (ignored)
+	 * processing expected:  Logical and SOAP, reverse order, close
+	 */
+	public void testHandleMessage_true3() {
+		
+		// reset result
+		result = "";
+		
+		// we want all good responses:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		
+		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.RESPONSE, true);
+
+		assertEquals("S2m:S1m:L1m:L2m:L2c:L1c:S1c:S2c:", result);
+
+	}
+	
+	/*
+	 * outgoing request (we must be on the client), response expected
+	 * processing expected:  Logical and SOAP, normal order, no closing
+	 */
+	public void testHandleMessage_true4() {
+		
+		// reset result
+		result = "";
+		
+		// we want all good responses:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		
+		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.REQUEST, true);
+
+		assertEquals("L2m:L1m:S1m:S2m:", result);
+	}
+	
+	/*
+	 * outgoing request (we must be on the client), response NOT expected
+	 * processing expected:  Logical and SOAP, normal order, close
+	 */
+	public void testHandleMessage_true5() {
+		
+		// reset result
+		result = "";
+		
+		// we want all good responses:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		
+		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.REQUEST, false);
+
+		assertEquals("L2m:L1m:S1m:S2m:S2c:S1c:L1c:L2c:", result);
+	}
+	
+	/*
+	 * outgoing response (we must be on the server), response expected (ignored)
+	 * processing expected:  Logical and SOAP, normal order, close
+	 */
+	public void testHandleMessage_true6() {
+
+		// reset result
+		result = "";
+		
+		// we want all good responses:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		
+		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.RESPONSE, true);
+
+		assertEquals("L2m:L1m:S1m:S2m:S2c:S1c:L1c:L2c:", result);
+	}
+	
+	/*
+	 * At this point we know the sorting and closing logic is all good,
+	 * all that's left is to make sure the SOAP handlers are excluded when
+	 * we're in a LogicalMessageContext.
+	 * 
+	 * outgoing response (we must be on the server), response expected (ignored)
+	 * processing expected:  Logical only, normal order, close
+	 */
+	public void testHandleMessage_true7() {
+		
+		// reset result
+		result = "";
+		
+		// we want all good responses:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		
+		processor.processChain(new LogicalMessageContext(new MessageContext()), HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.RESPONSE, true);
+		assertEquals("L2m:L1m:L1c:L2c:", result);
+	}
+	
+	/*
+	 * incoming request (we must be on the server), response expected
+	 * a middle Handler.handleMessage returns false
+	 * processing expected:  Logical and SOAP, reverse order, message reversed, close
+	 */
+	public void testHandleMessage_false1() {
+		
+		// reset result
+		result = "";
+		
+		// we want one false response:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.FALSE;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		SoapMessageContext context = new SoapMessageContext(new MessageContext());
+		processor.processChain(context, HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+
+		assertEquals("S2m:S1m:L1m:S1m:S2m:L1c:S1c:S2c:", result);
+		assertTrue((Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
+	}
+	
+	/*
+	 * outgoing request (we must be on the client), response expected
+	 * a middle Handler.handleMessage returns false
+	 * processing expected:  Logical and SOAP, normal order, message reversed, close
+	 */
+	public void testHandleMessage_false2() {
+		
+		// reset result
+		result = "";
+		
+		// we want one false response:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.FALSE;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		SoapMessageContext context = new SoapMessageContext(new MessageContext());
+		processor.processChain(context, HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.REQUEST, true);
+
+		assertEquals("L2m:L1m:L2m:L1c:L2c:", result);
+		assertTrue(!(Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
+	}
+	
+	/*
+	 * outgoing request (we must be on the client), response NOT expected
+	 * a middle Handler.handleMessage returns false
+	 * processing expected:  Logical and SOAP, normal order, message NOT reversed, close
+	 */
+	public void testHandleMessage_false3() {
+		
+		// reset result
+		result = "";
+		
+		// we want one false response:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.FALSE;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		SoapMessageContext context = new SoapMessageContext(new MessageContext());
+		processor.processChain(context, HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.REQUEST, false);
+
+		assertEquals("L2m:L1m:L1c:L2c:", result);
+		assertTrue((Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
+	}
+	
+	/*
+	 * incoming request (we must be on the server), response expected
+	 * a middle Handler.handleMessage throws ProtocolException
+	 * processing expected:  Logical and SOAP, reverse order, message reversed, handleFault, close
+	 */
+	public void testHandleMessage_protocolex_true1() {
+		
+		// reset result
+		result = "";
+		
+		// we want one false response:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.PROTOCOL_EXCEPTION;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		SoapMessageContext context = new SoapMessageContext(new MessageContext());
+		processor.processChain(context, HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+
+		// handleFault processing
+		assertEquals("S2m:S1m:L1m:S1f:S2f:L1c:S1c:S2c:", result);
+		assertTrue((Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
+	}
+	
+	/*
+	 * incoming request (we must be on the server), response NOT expected
+	 * a middle Handler.handleMessage throws ProtocolException
+	 * processing expected:  Logical and SOAP, reverse order, message NOT reversed, close
+	 */
+	public void testHandleMessage_protocolex_true2() {
+		
+		// reset result
+		result = "";
+		
+		// we want one false response:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.PROTOCOL_EXCEPTION;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		SoapMessageContext context = new SoapMessageContext(new MessageContext());
+		processor.processChain(context, HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
+
+		// no handleFault calls
+		assertEquals("S2m:S1m:L1m:L1c:S1c:S2c:", result);
+		assertTrue(!(Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
+	}
+	
+	/*
+	 * incoming request (we must be on the server), response expected
+	 * a middle Handler.handleMessage throws RuntimeException
+	 * processing expected:  Logical and SOAP, reverse order, message reversed, (no handleFault), close
+	 */
+	public void testHandleMessage_runtimeex_true() {
+		
+		// reset result
+		result = "";
+		
+		// we want one false response:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.OTHER_EXCEPTION;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		SoapMessageContext context = new SoapMessageContext(new MessageContext());
+		Exception e = null;
+		try {
+			processor.processChain(context, HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+		} catch (RuntimeException re) {
+			e = re;
+		}
+
+		assertNotNull(e);
+		// no handleFault calls
+		assertEquals("S2m:S1m:L1m:L1c:S1c:S2c:", result);
+		assertTrue((Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
+	}
+	
+	/*
+	 * incoming request (we must be on the server), response expected
+	 * a middle Handler.handleMessage throws ProtocolException, later a Handler.handleFault returns false
+	 * processing expected:  Logical and SOAP, reverse order, message reversed, handleFault, close
+	 */
+	public void testHandleMessage_protocolex_false() {
+		
+		// reset result
+		result = "";
+		
+		// we want one false response:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.FALSE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.PROTOCOL_EXCEPTION;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		SoapMessageContext context = new SoapMessageContext(new MessageContext());
+		processor.processChain(context, HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+
+		// handleFault processing, but notice S2f does not get called
+		assertEquals("S2m:S1m:L1m:S1f:L1c:S1c:S2c:", result);
+		assertTrue((Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
+	}
+	
+	/*
+	 * incoming request (we must be on the server), response expected
+	 * a middle Handler.handleMessage throws ProtocolException, later a Handler.handleFault throws ProtocolException
+	 * processing expected:  Logical and SOAP, reverse order, message reversed, handleFault, close
+	 */
+	public void testHandleMessage_protocolex_protocolex() {
+		
+		// reset result
+		result = "";
+		
+		// we want one false response:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.PROTOCOL_EXCEPTION;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.PROTOCOL_EXCEPTION;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		SoapMessageContext context = new SoapMessageContext(new MessageContext());
+		Exception e = null;
+		try {
+			// handleFault processing, but notice S2f does not get called, and we get an exception
+			processor.processChain(context, HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+		} catch (ProtocolException pe) {
+			e = pe;
+		}
+
+		assertNotNull(e);
+		assertEquals("S2m:S1m:L1m:S1f:L1c:S1c:S2c:", result);
+		assertTrue((Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
+	}
+	
+	/*
+	 * incoming request (we must be on the server), response expected
+	 * a middle Handler.handleMessage throws ProtocolException, later a Handler.handleFault throws ProtocolException
+	 * processing expected:  Logical and SOAP, reverse order, handleFault, close
+	 */
+	public void testHandleMessage_protocolex_runtimeex() {
+		
+		// reset result
+		result = "";
+		
+		// we want one false response:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.OTHER_EXCEPTION;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.PROTOCOL_EXCEPTION;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		SoapMessageContext context = new SoapMessageContext(new MessageContext());
+		Exception e = null;
+		try {
+			// same results as testHandlers_protocolex_protocolex
+			processor.processChain(context, HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+		} catch (RuntimeException pe) {
+			e = pe;
+		}
+
+		assertNotNull(e);
+		assertEquals("S2m:S1m:L1m:S1f:L1c:S1c:S2c:", result);
+		assertTrue((Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
+	}
+
+	
+	/*
+	 * empty list
+	 */
+	public void testHandleFault_empty1() {
+		
+		Exception local_exception = null;
+		
+		HandlerChainProcessor processor1 = new HandlerChainProcessor(null);
+		HandlerChainProcessor processor2 = new HandlerChainProcessor(new ArrayList<Handler>());
+		try {
+			processor1.processFault(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN);
+			processor2.processFault(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN);
+		} catch (Exception e) {
+			local_exception = e;
+		}
+		
+		// no exceptions!
+		assertNull(local_exception);
+	}
+	
+	
+	/*
+	 * outgoing response (we must be on the server), response expected (ignored)
+	 * processing expected:  Logical and SOAP, normal order, handleFault, close
+	 */
+	public void testHandleFault_true1() {
+		
+		// reset result
+		result = "";
+		
+		// we want one false response:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler1_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		
+		processor.processFault(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.OUT);
+
+		assertEquals("L2f:L1f:S1f:S2f:S2c:S1c:L1c:L2c:", result);
+	}
+	
+	/*
+	 * outgoing response (we must be on the server)
+	 * a middle Handler.handleFault returns false
+	 * processing expected:  Logical and SOAP, normal order, handleFault, close (all)
+	 */
+	public void testHandleFault_false1() {
+		
+		// reset result
+		result = "";
+		
+		// we want one false response:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler1_FaultResultDesired = ResultDesired.FALSE;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		
+		processor.processFault(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.OUT);
+
+		// notice all handlers are closed in this scenario
+		assertEquals("L2f:L1f:S2c:S1c:L1c:L2c:", result);
+	}
+	
+	/*
+	 * incoming response (we must be on the client)
+	 * a middle Handler.handleFault throws ProtocolException
+	 * processing expected:  Logical and SOAP, reverse order, handleFault, close (all)
+	 */
+	public void testHandleFault_protocolex() {
+		
+		// reset result
+		result = "";
+		
+		// we want one false response:
+		soaphandler1_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler1_FaultResultDesired = ResultDesired.TRUE;
+		soaphandler2_MessageResultDesired = ResultDesired.TRUE;
+		soaphandler2_FaultResultDesired = ResultDesired.TRUE;
+		logicalhandler1_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler1_FaultResultDesired = ResultDesired.PROTOCOL_EXCEPTION;
+		logicalhandler2_MessageResultDesired = ResultDesired.TRUE;
+		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
+		
+		HandlerChainProcessor processor = new HandlerChainProcessor(handlers);
+		
+		Exception e = null;
+		try {
+			// notice all handlers are closed in this scenario, and we get an exception
+			processor.processFault(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN);
+		} catch (ProtocolException pe) {
+			e = pe;
+		}
+		
+		assertNotNull(e);
+		assertEquals("S2f:S1f:L1f:L2c:L1c:S1c:S2c:", result);
+	}
+	
+	
+	
+	private class SOAPHandler1 implements SOAPHandler {
+		
+		public Set getHeaders() {
+			return null;
+		}
+
+		public void close(javax.xml.ws.handler.MessageContext messagecontext) {
+			result = result.concat("S1c:");
+		}
+
+		public boolean handleFault(javax.xml.ws.handler.MessageContext messagecontext) {
+			result = result.concat("S1f:");
+			if (soaphandler1_FaultResultDesired == ResultDesired.TRUE)
+				return true;
+			else if (soaphandler1_FaultResultDesired == ResultDesired.FALSE)
+				return false;
+			else if (soaphandler1_FaultResultDesired == ResultDesired.PROTOCOL_EXCEPTION)
+				throw new ProtocolException();
+			else if (soaphandler1_FaultResultDesired == ResultDesired.OTHER_EXCEPTION)
+				throw new RuntimeException();
+			
+			// default
+			return true;
+		}
+
+		public boolean handleMessage(javax.xml.ws.handler.MessageContext messagecontext) {
+			result = result.concat("S1m:");
+			if (soaphandler1_MessageResultDesired == ResultDesired.TRUE)
+				return true;
+			else if (soaphandler1_MessageResultDesired == ResultDesired.FALSE)
+				return false;
+			else if (soaphandler1_MessageResultDesired == ResultDesired.PROTOCOL_EXCEPTION)
+				throw new ProtocolException();
+			else if (soaphandler1_MessageResultDesired == ResultDesired.OTHER_EXCEPTION)
+				throw new RuntimeException();
+			
+			// default
+			return true;
+		}
+		
+	}
+	
+
+	private class SOAPHandler2 implements SOAPHandler {
+
+		public Set getHeaders() {
+			return null;
+		}
+
+		public void close(javax.xml.ws.handler.MessageContext messagecontext) {
+			result = result.concat("S2c:");
+		}
+
+		public boolean handleFault(javax.xml.ws.handler.MessageContext messagecontext) {
+			result = result.concat("S2f:");
+			if (soaphandler2_FaultResultDesired == ResultDesired.TRUE)
+				return true;
+			else if (soaphandler2_FaultResultDesired == ResultDesired.FALSE)
+				return false;
+			else if (soaphandler2_FaultResultDesired == ResultDesired.PROTOCOL_EXCEPTION)
+				throw new ProtocolException();
+			else if (soaphandler2_FaultResultDesired == ResultDesired.OTHER_EXCEPTION)
+				throw new RuntimeException();
+			
+			// default
+			return true;
+		}
+
+		public boolean handleMessage(javax.xml.ws.handler.MessageContext messagecontext) {
+			result = result.concat("S2m:");
+			if (soaphandler2_MessageResultDesired == ResultDesired.TRUE)
+				return true;
+			else if (soaphandler2_MessageResultDesired == ResultDesired.FALSE)
+				return false;
+			else if (soaphandler2_MessageResultDesired == ResultDesired.PROTOCOL_EXCEPTION)
+				throw new ProtocolException();
+			else if (soaphandler2_MessageResultDesired == ResultDesired.OTHER_EXCEPTION)
+				throw new RuntimeException();
+			
+			// default
+			return true;
+		}
+		
+	}
+	
+
+	private class LogicalHandler1 implements LogicalHandler {
+
+		public void close(javax.xml.ws.handler.MessageContext messagecontext) {
+			result = result.concat("L1c:");
+		}
+
+		public boolean handleFault(javax.xml.ws.handler.MessageContext messagecontext) {
+			result = result.concat("L1f:");
+			if (logicalhandler1_FaultResultDesired == ResultDesired.TRUE)
+				return true;
+			else if (logicalhandler1_FaultResultDesired == ResultDesired.FALSE)
+				return false;
+			else if (logicalhandler1_FaultResultDesired == ResultDesired.PROTOCOL_EXCEPTION)
+				throw new ProtocolException();
+			else if (logicalhandler1_FaultResultDesired == ResultDesired.OTHER_EXCEPTION)
+				throw new RuntimeException();
+			
+			// default
+			return true;
+		}
+
+		public boolean handleMessage(javax.xml.ws.handler.MessageContext messagecontext) {
+			result = result.concat("L1m:");
+			if (logicalhandler1_MessageResultDesired == ResultDesired.TRUE)
+				return true;
+			else if (logicalhandler1_MessageResultDesired == ResultDesired.FALSE)
+				return false;
+			else if (logicalhandler1_MessageResultDesired == ResultDesired.PROTOCOL_EXCEPTION)
+				throw new ProtocolException();
+			else if (logicalhandler1_MessageResultDesired == ResultDesired.OTHER_EXCEPTION)
+				throw new RuntimeException();
+			
+			// default
+			return true;
+		}
+		
+	}
+	
+
+	private class LogicalHandler2 implements LogicalHandler {
+
+		public void close(javax.xml.ws.handler.MessageContext messagecontext) {
+			result = result.concat("L2c:");
+		}
+
+		public boolean handleFault(javax.xml.ws.handler.MessageContext messagecontext) {
+			result = result.concat("L2f:");
+			if (logicalhandler2_FaultResultDesired == ResultDesired.TRUE)
+				return true;
+			else if (logicalhandler2_FaultResultDesired == ResultDesired.FALSE)
+				return false;
+			else if (logicalhandler2_FaultResultDesired == ResultDesired.PROTOCOL_EXCEPTION)
+				throw new ProtocolException();
+			else if (logicalhandler2_FaultResultDesired == ResultDesired.OTHER_EXCEPTION)
+				throw new RuntimeException();
+			
+			// default
+			return true;
+		}
+
+		public boolean handleMessage(javax.xml.ws.handler.MessageContext messagecontext) {
+			result = result.concat("L2m:");
+			if (logicalhandler2_MessageResultDesired == ResultDesired.TRUE)
+				return true;
+			else if (logicalhandler2_MessageResultDesired == ResultDesired.FALSE)
+				return false;
+			else if (logicalhandler2_MessageResultDesired == ResultDesired.PROTOCOL_EXCEPTION)
+				throw new ProtocolException();
+			else if (logicalhandler2_MessageResultDesired == ResultDesired.OTHER_EXCEPTION)
+				throw new RuntimeException();
+			
+			// default
+			return true;
+		}
+		
+	}
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/client/EchoStringResponse.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/client/EchoStringResponse.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/client/EchoStringResponse.java	(working copy)
@@ -1,73 +1,73 @@
-//
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.0-b26-ea3 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2006.06.04 at 11:10:38 PM CDT 
-//
-
-
-package client;
-
-import javax.xml.bind.annotation.AccessType;
-import javax.xml.bind.annotation.XmlAccessorType;
-import javax.xml.bind.annotation.XmlElement;
-import javax.xml.bind.annotation.XmlRootElement;
-import javax.xml.bind.annotation.XmlType;
-
-
-/**
- * <p>Java class for echoStringResponse element declaration.
- * 
- * <p>The following schema fragment specifies the expected content contained within this class.
- * 
- * <pre>
- * &lt;element name="echoStringResponse">
- *   &lt;complexType>
- *     &lt;complexContent>
- *       &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
- *         &lt;sequence>
- *           &lt;element name="echoStringReturn" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
- *         &lt;/sequence>
- *       &lt;/restriction>
- *     &lt;/complexContent>
- *   &lt;/complexType>
- * &lt;/element>
- * </pre>
- * 
- * 
- */
-@XmlAccessorType(AccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "echoStringReturn"
-})
-@XmlRootElement(name = "echoStringResponse")
-public class EchoStringResponse {
-
-    @XmlElement(namespace = "http://test")
-    protected String echoStringReturn;
-
-    /**
-     * Gets the value of the echoStringReturn property.
-     * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
-     */
-    public String getEchoStringReturn() {
-        return echoStringReturn;
-    }
-
-    /**
-     * Sets the value of the echoStringReturn property.
-     * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
-     */
-    public void setEchoStringReturn(String value) {
-        this.echoStringReturn = value;
-    }
-
-}
+//
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.0-b26-ea3 
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
+// Any modifications to this file will be lost upon recompilation of the source schema. 
+// Generated on: 2006.06.04 at 11:10:38 PM CDT 
+//
+
+
+package client;
+
+import javax.xml.bind.annotation.AccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlRootElement;
+import javax.xml.bind.annotation.XmlType;
+
+
+/**
+ * <p>Java class for echoStringResponse element declaration.
+ * 
+ * <p>The following schema fragment specifies the expected content contained within this class.
+ * 
+ * <pre>
+ * &lt;element name="echoStringResponse">
+ *   &lt;complexType>
+ *     &lt;complexContent>
+ *       &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
+ *         &lt;sequence>
+ *           &lt;element name="echoStringReturn" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
+ *         &lt;/sequence>
+ *       &lt;/restriction>
+ *     &lt;/complexContent>
+ *   &lt;/complexType>
+ * &lt;/element>
+ * </pre>
+ * 
+ * 
+ */
+@XmlAccessorType(AccessType.FIELD)
+@XmlType(name = "", propOrder = {
+    "echoStringReturn"
+})
+@XmlRootElement(name = "echoStringResponse")
+public class EchoStringResponse {
+
+    @XmlElement(namespace = "http://test")
+    protected String echoStringReturn;
+
+    /**
+     * Gets the value of the echoStringReturn property.
+     * 
+     * @return
+     *     possible object is
+     *     {@link String }
+     *     
+     */
+    public String getEchoStringReturn() {
+        return echoStringReturn;
+    }
+
+    /**
+     * Sets the value of the echoStringReturn property.
+     * 
+     * @param value
+     *     allowed object is
+     *     {@link String }
+     *     
+     */
+    public void setEchoStringReturn(String value) {
+        this.echoStringReturn = value;
+    }
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/client/package-info.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/client/package-info.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/client/package-info.java	(working copy)
@@ -1,9 +1,9 @@
-//
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.0-b26-ea3 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2006.06.04 at 11:10:38 PM CDT 
-//
-
-@javax.xml.bind.annotation.XmlSchema(namespace = "http://test")
-package client;
+//
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.0-b26-ea3 
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
+// Any modifications to this file will be lost upon recompilation of the source schema. 
+// Generated on: 2006.06.04 at 11:10:38 PM CDT 
+//
+
+@javax.xml.bind.annotation.XmlSchema(namespace = "http://test")
+package client;
Index: C:/workspace/live/axis2/modules/jaxws/test/client/EchoString.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/client/EchoString.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/client/EchoString.java	(working copy)
@@ -1,73 +1,73 @@
-//
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.0-b26-ea3 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2006.06.04 at 11:10:38 PM CDT 
-//
-
-
-package client;
-
-import javax.xml.bind.annotation.AccessType;
-import javax.xml.bind.annotation.XmlAccessorType;
-import javax.xml.bind.annotation.XmlElement;
-import javax.xml.bind.annotation.XmlRootElement;
-import javax.xml.bind.annotation.XmlType;
-
-
-/**
- * <p>Java class for echoString element declaration.
- * 
- * <p>The following schema fragment specifies the expected content contained within this class.
- * 
- * <pre>
- * &lt;element name="echoString">
- *   &lt;complexType>
- *     &lt;complexContent>
- *       &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
- *         &lt;sequence>
- *           &lt;element name="input" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
- *         &lt;/sequence>
- *       &lt;/restriction>
- *     &lt;/complexContent>
- *   &lt;/complexType>
- * &lt;/element>
- * </pre>
- * 
- * 
- */
-@XmlAccessorType(AccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "input"
-})
-@XmlRootElement(name = "echoString")
-public class EchoString {
-
-    @XmlElement(namespace = "http://test")
-    protected String input;
-
-    /**
-     * Gets the value of the input property.
-     * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
-     */
-    public String getInput() {
-        return input;
-    }
-
-    /**
-     * Sets the value of the input property.
-     * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
-     */
-    public void setInput(String value) {
-        this.input = value;
-    }
-
-}
+//
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.0-b26-ea3 
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
+// Any modifications to this file will be lost upon recompilation of the source schema. 
+// Generated on: 2006.06.04 at 11:10:38 PM CDT 
+//
+
+
+package client;
+
+import javax.xml.bind.annotation.AccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlRootElement;
+import javax.xml.bind.annotation.XmlType;
+
+
+/**
+ * <p>Java class for echoString element declaration.
+ * 
+ * <p>The following schema fragment specifies the expected content contained within this class.
+ * 
+ * <pre>
+ * &lt;element name="echoString">
+ *   &lt;complexType>
+ *     &lt;complexContent>
+ *       &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
+ *         &lt;sequence>
+ *           &lt;element name="input" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
+ *         &lt;/sequence>
+ *       &lt;/restriction>
+ *     &lt;/complexContent>
+ *   &lt;/complexType>
+ * &lt;/element>
+ * </pre>
+ * 
+ * 
+ */
+@XmlAccessorType(AccessType.FIELD)
+@XmlType(name = "", propOrder = {
+    "input"
+})
+@XmlRootElement(name = "echoString")
+public class EchoString {
+
+    @XmlElement(namespace = "http://test")
+    protected String input;
+
+    /**
+     * Gets the value of the input property.
+     * 
+     * @return
+     *     possible object is
+     *     {@link String }
+     *     
+     */
+    public String getInput() {
+        return input;
+    }
+
+    /**
+     * Sets the value of the input property.
+     * 
+     * @param value
+     *     allowed object is
+     *     {@link String }
+     *     
+     */
+    public void setInput(String value) {
+        this.input = value;
+    }
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/test/client/ObjectFactory.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/client/ObjectFactory.java	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/test/client/ObjectFactory.java	(working copy)
@@ -1,57 +1,57 @@
-//
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.0-b26-ea3 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2006.06.04 at 11:10:38 PM CDT 
-//
-
-
-package client;
-
-import javax.xml.bind.annotation.XmlRegistry;
-
-import client.EchoStringResponse;
-
-
-/**
- * This object contains factory methods for each 
- * Java content interface and Java element interface 
- * generated in the test package. 
- * <p>An ObjectFactory allows you to programatically 
- * construct new instances of the Java representation 
- * for XML content. The Java representation of XML 
- * content can consist of schema derived interfaces 
- * and classes representing the binding of schema 
- * type definitions, element declarations and model 
- * groups.  Factory methods for each of these are 
- * provided in this class.
- * 
- */
-@XmlRegistry
-public class ObjectFactory {
-
-
-    /**
-     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: test
-     * 
-     */
-    public ObjectFactory() {
-    }
-
-    /**
-     * Create an instance of {@link EchoStringResponse }
-     * 
-     */
-    public EchoStringResponse createEchoStringResponse() {
-        return new EchoStringResponse();
-    }
-
-    /**
-     * Create an instance of {@link EchoString }
-     * 
-     */
-    public EchoString createEchoString() {
-        return new EchoString();
-    }
-
-}
+//
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.0-b26-ea3 
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
+// Any modifications to this file will be lost upon recompilation of the source schema. 
+// Generated on: 2006.06.04 at 11:10:38 PM CDT 
+//
+
+
+package client;
+
+import javax.xml.bind.annotation.XmlRegistry;
+
+import client.EchoStringResponse;
+
+
+/**
+ * This object contains factory methods for each 
+ * Java content interface and Java element interface 
+ * generated in the test package. 
+ * <p>An ObjectFactory allows you to programatically 
+ * construct new instances of the Java representation 
+ * for XML content. The Java representation of XML 
+ * content can consist of schema derived interfaces 
+ * and classes representing the binding of schema 
+ * type definitions, element declarations and model 
+ * groups.  Factory methods for each of these are 
+ * provided in this class.
+ * 
+ */
+@XmlRegistry
+public class ObjectFactory {
+
+
+    /**
+     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: test
+     * 
+     */
+    public ObjectFactory() {
+    }
+
+    /**
+     * Create an instance of {@link EchoStringResponse }
+     * 
+     */
+    public EchoStringResponse createEchoStringResponse() {
+        return new EchoStringResponse();
+    }
+
+    /**
+     * Create an instance of {@link EchoString }
+     * 
+     */
+    public EchoString createEchoString() {
+        return new EchoString();
+    }
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/maven.xml
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/maven.xml	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/maven.xml	(working copy)
@@ -1,197 +1,222 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<!-- $Revision: 1.21 $ $Date: 2004-10-27 20:54:09 +0600 (Wed, 27 Oct 2004) $ -->
-
-<project default="jar"
-         xmlns:j="jelly:core" 
-         xmlns:u="jelly:util"
-         xmlns:maven="jelly:maven"
-         xmlns:util="jelly:util"
-         xmlns:deploy="deploy"
-         xmlns:ant="jelly:ant">
-
-    <preGoal name="itest:compile">
-        <u:file var="file" name="${maven.itest.src}"/>
-        <j:if test="${!file.exists()}">
-            <j:expr value="${context.setVariable('maven.itest.skip', 'true')}"/>
-        </j:if>
-    </preGoal>
-	
-	<preGoal name="test:test">
-		<ant:copy toDir="target/test-classes/services/EchoService/">
-			<ant:fileset dir="target/test-classes">
-				<ant:include name="server/**"/>
-			</ant:fileset>
-			<ant:fileset dir="test/server">
-				<ant:exclude name="**/*.java"/>
-			</ant:fileset>
-		</ant:copy>
-	</preGoal>
-
-    <!-- Create the API and Impl jars --> 
-    <postGoal name="jar">
-        <jar destfile="target/jaxws-api-${jaxws.version}.jar">
-            <ant:fileset dir="target/classes">
-            	<ant:exclude name="com/ibm/webservices/**"/>
-            </ant:fileset>
-        </jar>
-    	<jar destfile="target/jaxws-impl-${jaxws.version}.jar">
-    	    <ant:fileset dir="target/classes">
-                <ant:exclude name="javax/**"/>
-            </ant:fileset>
-    	</jar>
-        <ant:copy toDir="${maven.repo.local}/jaxws/jars">
-            <ant:fileset file="target/jaxws-impl-${jaxws.version}.jar"/>
-        	<ant:fileset file="target/jaxws-api-${jaxws.version}.jar"/>
-        </ant:copy>
-    </postGoal>
-
-    <goal name="jar">
-        <attainGoal name="jar:install"/>
-
-    </goal>
-
-    <goal name="release" prereqs="dist-bin,dist-src">
-
-
-    </goal>
-
-    <goal name="dist-bin" prereqs="jar">
-
-        <ant:echo>+----------------------------------------------</ant:echo>
-        <ant:echo>| Creating: JAXWS Binary Distribution</ant:echo>
-        <ant:echo>+----------------------------------------------</ant:echo>
-
-
-        <property name="dist" value="target/dist/temp"/>
-
-        <mkdir dir="${dist}"/>
-        <mkdir dir="${dist}/apidocs"/>
-        <mkdir dir="${dist}/build"/>
-        <!--<mkdir dir="${dist}/docs"/>-->
-        <mkdir dir="${dist}/lib"/>
-
-        <!--copy dependent jars-->
-        <maven:reactor basedir="${basedir}"
-                       postProcessing="true"
-                       includes="project.xml"
-                       banner="Executing (${goals}):"
-                       ignoreFailures="false"/>
-        <j:forEach var="x" items="${reactorProjects}">
-            <ant:echo message="Copying ${x} to ${dist}"/>
-            <deploy:copy-deps todir="${dist}/lib"
-                              projectDescriptor="${x.getFile()}"/>
-        </j:forEach>
-        <ant:delete file="${dist}/lib/xmlunit-${xmlunit.version}.jar"/>
-
-        <!--Add the licenses of jars-->
-        <ant:copy toDir="${dist}/lib">
-            <ant:fileset dir="legal"/>
-        </ant:copy>
-
-        <!--add api docs-->
-
-        <ant:javadoc packagenames="org.apache.jaxws.*"
-                     defaultexcludes="yes"
-                     destdir="${dist}/apidocs"
-                     author="true"
-                     breakiterator="true"
-                     version="true"
-                     use="true"
-                     windowtitle="JAXWS API">
-            <ant:arg
-                    line="-J-Dhttp.proxy.port=${maven.proxy.port} -J-Dhttp.proxy.host=${maven.proxy.host}"/>
-            <ant:sourcepath>
-                <ant:pathelement location="src"/>
-            </ant:sourcepath>
-            <ant:classpath>
-                <ant:fileset dir="${dist}/lib">
-                    <ant:include name="*.jar"/>
-                </ant:fileset>
-            </ant:classpath>
-        </ant:javadoc>
-
-        <!--add jars-->
-        <ant:copy toDir="${dist}/build">
-            <ant:fileset file="target/jaxws-api-${jaxws.version}.jar"/>
-            <ant:fileset file="target/jaxws-impl-${jaxws.version}.jar"/>
-        </ant:copy>
-
-        <!--add documents-->
-        <ant:copy toDir="${dist}/docs">
-            <ant:fileset dir="xdocs">
-                <ant:exclude name="**/.svn/**"/>
-            </ant:fileset>
-        </ant:copy>
-
-        <!--copy release notes, etc-->
-        <ant:copy toDir="${dist}">
-            <ant:fileset file="RELEASE-NOTE.txt"/>
-            <ant:fileset file="README.txt"/>
-            <ant:fileset file="NOTICE.txt"/>
-            <ant:fileset file="LICENSE.txt"/>
-        </ant:copy>
-
-
-        <!--create the zip-->
-        <ant:zip file="target/dist/jaxws-${jaxws.version}-bin.zip">
-            <ant:fileset dir="${dist}/"/>
-        </ant:zip>
-
-        <ant:delete dir="${dist}"/>
-
-    </goal>
-
-    <goal name="dist-src" prereqs="jar">
-
-        <ant:echo>+----------------------------------------------</ant:echo>
-        <ant:echo>| Creating: JAXWS Source Distribution</ant:echo>
-        <ant:echo>+----------------------------------------------</ant:echo>
-
-        <ant:property name="${dist}" value="target/dist/temp"/>
-
-        <ant:copy toDir="${dist}">
-            <ant:fileset dir=".">
-                <ant:exclude name="**/.svn/**"/>
-                <ant:include name="**/src/**"/>
-                <ant:include name="**/test/**"/>
-            </ant:fileset>
-        </ant:copy>
-
-        <!-- Copy the master maven files for the standard src distro -->
-        <ant:copy toDir="${dist}">
-            <ant:fileset file="maven.xml"/>
-            <ant:fileset file="project.xml"/>
-            <ant:fileset file="project.properties"/>
-            <ant:fileset file="RELEASE-NOTE.txt"/>
-            <ant:fileset file="NOTICE.txt"/>
-            <ant:fileset file="LICENSE.txt"/>
-        </ant:copy>
-
-        <ant:zip file="target/dist/jaxws-${jaxws.version}-src.zip">
-            <ant:fileset dir="${dist}/"/>
-        </ant:zip>
-        <ant:delete dir="${dist}"/>
-    </goal>
-
-    <goal name="javadocs">
-
-        <mkdir dir="target/apidocs"/>
-
-        <ant:javadoc packagenames="org.apache.jaxws.*"
-                     defaultexcludes="yes"
-                     destdir="target/apidocs"
-                     author="true"
-                     breakiterator="true"
-                     version="true"
-                     use="true"
-                     windowtitle="JAXWS API">
-            <ant:arg
-                    line="-J-Dhttp.proxy.port=${maven.proxy.port} -J-Dhttp.proxy.host=${maven.proxy.host}"/>
-            <ant:sourcepath>
-                <ant:pathelement location="src"/>
-            </ant:sourcepath>
-        </ant:javadoc>
-    </goal>
-
-</project>
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!-- $Revision: 1.21 $ $Date: 2004-10-27 20:54:09 +0600 (Wed, 27 Oct 2004) $ -->
+
+<project default="jar"
+         xmlns:j="jelly:core" 
+         xmlns:u="jelly:util"
+         xmlns:maven="jelly:maven"
+         xmlns:util="jelly:util"
+         xmlns:deploy="deploy"
+         xmlns:ant="jelly:ant">
+
+    <preGoal name="itest:compile">
+        <u:file var="file" name="${maven.itest.src}"/>
+        <j:if test="${!file.exists()}">
+            <j:expr value="${context.setVariable('maven.itest.skip', 'true')}"/>
+        </j:if>
+    </preGoal>
+	
+	<preGoal name="test:test">
+		<ant:copy toDir="target/test-classes/services/EchoService/">
+			<ant:fileset dir="target/test-classes">
+				<ant:include name="server/**"/>
+			</ant:fileset>
+			<ant:fileset dir="test/server">
+				<ant:exclude name="**/*.java"/>
+			</ant:fileset>
+		</ant:copy>
+        <!-- ================================================================ -->
+        <!--- Provider endpoint Service Samples -->
+        <!-- ================================================================ -->
+		<ant:copy toDir="target/test-classes/services/StringProviderService/">
+			<ant:fileset dir="target/test-classes">
+				<ant:include name="org/apache/axis2/jaxws/provider/string/**"/>
+			</ant:fileset>
+			<ant:fileset dir="test/org/apache/axis2/jaxws/provider/string">
+                <ant:include name="META-INF/**"/>
+			</ant:fileset>
+			<ant:fileset dir="target/classes">
+                <ant:include name="org/apache/axis2/jaxws/server/**"/>
+			</ant:fileset>
+		</ant:copy>
+		<ant:copy toDir="target/test-classes/services/SourceProviderService/">
+			<ant:fileset dir="target/test-classes">
+				<ant:include name="org/apache/axis2/jaxws/provider/source/**"/>
+			</ant:fileset>
+			<ant:fileset dir="test/org/apache/axis2/jaxws/provider/source">
+                <ant:include name="META-INF/**"/>
+			</ant:fileset>
+			<ant:fileset dir="target/classes">
+                <ant:include name="org/apache/axis2/jaxws/server/**"/>
+			</ant:fileset>
+		</ant:copy>
+	</preGoal>
+
+    <!-- Create the API and Impl jars --> 
+    <postGoal name="jar">
+        <jar destfile="target/jaxws-api-${jaxws.version}.jar">
+            <ant:fileset dir="target/classes">
+            	<ant:exclude name="com/ibm/webservices/**"/>
+            </ant:fileset>
+        </jar>
+    	<jar destfile="target/jaxws-impl-${jaxws.version}.jar">
+    	    <ant:fileset dir="target/classes">
+                <ant:exclude name="javax/**"/>
+            </ant:fileset>
+    	</jar>
+        <ant:copy toDir="${maven.repo.local}/jaxws/jars">
+            <ant:fileset file="target/jaxws-impl-${jaxws.version}.jar"/>
+        	<ant:fileset file="target/jaxws-api-${jaxws.version}.jar"/>
+        </ant:copy>
+    </postGoal>
+
+    <goal name="jar">
+        <attainGoal name="jar:install"/>
+
+    </goal>
+
+    <goal name="release" prereqs="dist-bin,dist-src">
+
+
+    </goal>
+
+    <goal name="dist-bin" prereqs="jar">
+
+        <ant:echo>+----------------------------------------------</ant:echo>
+        <ant:echo>| Creating: JAXWS Binary Distribution</ant:echo>
+        <ant:echo>+----------------------------------------------</ant:echo>
+
+
+        <property name="dist" value="target/dist/temp"/>
+
+        <mkdir dir="${dist}"/>
+        <mkdir dir="${dist}/apidocs"/>
+        <mkdir dir="${dist}/build"/>
+        <!--<mkdir dir="${dist}/docs"/>-->
+        <mkdir dir="${dist}/lib"/>
+
+        <!--copy dependent jars-->
+        <maven:reactor basedir="${basedir}"
+                       postProcessing="true"
+                       includes="project.xml"
+                       banner="Executing (${goals}):"
+                       ignoreFailures="false"/>
+        <j:forEach var="x" items="${reactorProjects}">
+            <ant:echo message="Copying ${x} to ${dist}"/>
+            <deploy:copy-deps todir="${dist}/lib"
+                              projectDescriptor="${x.getFile()}"/>
+        </j:forEach>
+        <ant:delete file="${dist}/lib/xmlunit-${xmlunit.version}.jar"/>
+
+        <!--Add the licenses of jars-->
+        <ant:copy toDir="${dist}/lib">
+            <ant:fileset dir="legal"/>
+        </ant:copy>
+
+        <!--add api docs-->
+
+        <ant:javadoc packagenames="org.apache.jaxws.*"
+                     defaultexcludes="yes"
+                     destdir="${dist}/apidocs"
+                     author="true"
+                     breakiterator="true"
+                     version="true"
+                     use="true"
+                     windowtitle="JAXWS API">
+            <ant:arg
+                    line="-J-Dhttp.proxy.port=${maven.proxy.port} -J-Dhttp.proxy.host=${maven.proxy.host}"/>
+            <ant:sourcepath>
+                <ant:pathelement location="src"/>
+            </ant:sourcepath>
+            <ant:classpath>
+                <ant:fileset dir="${dist}/lib">
+                    <ant:include name="*.jar"/>
+                </ant:fileset>
+            </ant:classpath>
+        </ant:javadoc>
+
+        <!--add jars-->
+        <ant:copy toDir="${dist}/build">
+            <ant:fileset file="target/jaxws-api-${jaxws.version}.jar"/>
+            <ant:fileset file="target/jaxws-impl-${jaxws.version}.jar"/>
+        </ant:copy>
+
+        <!--add documents-->
+        <ant:copy toDir="${dist}/docs">
+            <ant:fileset dir="xdocs">
+                <ant:exclude name="**/.svn/**"/>
+            </ant:fileset>
+        </ant:copy>
+
+        <!--copy release notes, etc-->
+        <ant:copy toDir="${dist}">
+            <ant:fileset file="RELEASE-NOTE.txt"/>
+            <ant:fileset file="README.txt"/>
+            <ant:fileset file="NOTICE.txt"/>
+            <ant:fileset file="LICENSE.txt"/>
+        </ant:copy>
+
+
+        <!--create the zip-->
+        <ant:zip file="target/dist/jaxws-${jaxws.version}-bin.zip">
+            <ant:fileset dir="${dist}/"/>
+        </ant:zip>
+
+        <ant:delete dir="${dist}"/>
+
+    </goal>
+
+    <goal name="dist-src" prereqs="jar">
+
+        <ant:echo>+----------------------------------------------</ant:echo>
+        <ant:echo>| Creating: JAXWS Source Distribution</ant:echo>
+        <ant:echo>+----------------------------------------------</ant:echo>
+
+        <ant:property name="${dist}" value="target/dist/temp"/>
+
+        <ant:copy toDir="${dist}">
+            <ant:fileset dir=".">
+                <ant:exclude name="**/.svn/**"/>
+                <ant:include name="**/src/**"/>
+                <ant:include name="**/test/**"/>
+            </ant:fileset>
+        </ant:copy>
+
+        <!-- Copy the master maven files for the standard src distro -->
+        <ant:copy toDir="${dist}">
+            <ant:fileset file="maven.xml"/>
+            <ant:fileset file="project.xml"/>
+            <ant:fileset file="project.properties"/>
+            <ant:fileset file="RELEASE-NOTE.txt"/>
+            <ant:fileset file="NOTICE.txt"/>
+            <ant:fileset file="LICENSE.txt"/>
+        </ant:copy>
+
+        <ant:zip file="target/dist/jaxws-${jaxws.version}-src.zip">
+            <ant:fileset dir="${dist}/"/>
+        </ant:zip>
+        <ant:delete dir="${dist}"/>
+    </goal>
+
+    <goal name="javadocs">
+
+        <mkdir dir="target/apidocs"/>
+
+        <ant:javadoc packagenames="org.apache.jaxws.*"
+                     defaultexcludes="yes"
+                     destdir="target/apidocs"
+                     author="true"
+                     breakiterator="true"
+                     version="true"
+                     use="true"
+                     windowtitle="JAXWS API">
+            <ant:arg
+                    line="-J-Dhttp.proxy.port=${maven.proxy.port} -J-Dhttp.proxy.host=${maven.proxy.host}"/>
+            <ant:sourcepath>
+                <ant:pathelement location="src"/>
+            </ant:sourcepath>
+        </ant:javadoc>
+    </goal>
+
+</project>
Index: C:/workspace/live/axis2/modules/jaxws/project.xml
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/project.xml	(revision 420934)
+++ C:/workspace/live/axis2/modules/jaxws/project.xml	(working copy)
@@ -58,7 +58,7 @@
             <organization>IBM</organization>
         </contributor>
         <contributor>
-            <name>Daniel Sedov</name>
+            <name>Dan Sedov</name>
             <organization>IBM</organization>
         </contributor>
         <contributor>
@@ -135,6 +135,11 @@
             <version>${axiom.version}</version>
         </dependency>
         <dependency>
+            <groupId>ws-commons</groupId>
+            <artifactId>axiom-dom</artifactId>
+            <version>${axiom.version}</version>
+        </dependency>
+        <dependency>
             <groupId>axis2</groupId>
             <artifactId>axis2</artifactId>
             <version>${pom.currentVersion}</version>
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/Dispatch.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/Dispatch.java	(revision 420936)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/Dispatch.java	(working copy)
@@ -14,59 +14,161 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.axis2.jaxws;
 
 import java.util.concurrent.Future;
 
+import javax.xml.bind.JAXBContext;
+import javax.xml.namespace.QName;
 import javax.xml.ws.AsyncHandler;
 import javax.xml.ws.Response;
 import javax.xml.ws.WebServiceException;
+import javax.xml.ws.Service.Mode;
 
-
-import javax.xml.namespace.QName;
-
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.soap.SOAPBody;
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axis2.jaxws.core.InvocationContext;
+import org.apache.axis2.jaxws.core.InvocationContextFactory;
+import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.core.controller.AxisInvocationController;
+import org.apache.axis2.jaxws.core.controller.InvocationController;
+import org.apache.axis2.jaxws.param.JAXBParameter;
 import org.apache.axis2.jaxws.param.Parameter;
 import org.apache.axis2.jaxws.param.ParameterFactory;
+import org.apache.axis2.jaxws.param.ParameterUtils;
+import org.apache.axis2.jaxws.spi.ServiceDelegate;
 import org.apache.axis2.jaxws.util.Constants;
 import org.apache.axis2.jaxws.util.WSDLWrapper;
 
+/**
+ * Dispatch is an implementation of the {@link javax.xml.ws.Dispatch} interface.
+ * 
+ * The Dispatch is a client that can be used to invoke remote services that
+ * requires the programmer to operate at the raw XML level.  The XML payloads
+ * can be in two different formats, or Modes ({@link javax.xml.ws.Service.Mode}).
+ * 
+ * @param <T>
+ */
 public class Dispatch<T> extends BindingProvider implements javax.xml.ws.Dispatch {
-	
-    AxisController axisController = null;
+    
+    //FIXME: Remove the AxisController completely and replace with InvocationController
+    private AxisController axisController = null;
+    
+    private InvocationController ic;
+    private ServiceDelegate serviceDelegate;
+    private Mode mode;
+    private JAXBContext jaxbContext;
    
     public Dispatch() {
         super();
     }
     
     public Dispatch(AxisController axisController){
-    	super();
-    	this.axisController = axisController;
-    	setRequestContext();
+        super();
+        
+        //FIXME: Remove this when we remove the AxisController
+        this.axisController = axisController;
+        
+        ic = new AxisInvocationController();
+        setRequestContext();
     }
-  
+    
+    /**
+     * Sets the back pointer to the ServiceDelegate instance that created
+     * this Dispatch.
+     * 
+     * @param svcDlg
+     */
+    public void setServiceDelegate(ServiceDelegate svcDlg) {
+        serviceDelegate = svcDlg;
+    }
+    
+    /**
+     * Returns the back pointer to the Service Delegate instance that created
+     * this Dispatch.
+     * 
+     * @return
+     */
+    public ServiceDelegate getServiceDescription() {
+        return serviceDelegate;
+    }
+    
+    public Mode getMode() {
+        return mode;
+    }
+    
+    public void setMode(Mode m) {
+        mode = m;
+    }
+    
+    public JAXBContext getJAXBContext() {
+        return jaxbContext;
+    }
+    
+    public void setJAXBContext(JAXBContext jbc) {
+        jaxbContext = jbc;
+    }
+    
     public Object invoke(Object obj) throws WebServiceException {
-    	try{
-    		if(obj == null){
-    			throw new WebServiceException("Dispatch Cannot Invoke SEI with null object");
-    		}
-    		Parameter param = ParameterFactory.createParameter(obj);
-    		return axisController.invoke(param,requestContext);
-    	}catch(Exception e){
-    		throw new WebServiceException(e);
-    	}
-   }
+        // Create the InvocationContext instance for this request/response flow.
+        InvocationContext invocationContext = InvocationContextFactory.createInvocationContext(null);
+        invocationContext.setServiceClient(axisController.getServiceClient());
+        
+        // Create the MessageContext to hold the actual request message and its
+        // associated properties
+        MessageContext requestMsgCtx = new MessageContext();
+        invocationContext.setRequestMessageContext(requestMsgCtx);
+        
+        // FIXME: This is where the Message Model will be integrated instead of 
+        // the ParameterFactory/Parameter APIs.
+        Parameter param = ParameterFactory.createParameter(obj);
+        if (param instanceof JAXBParameter) {
+            JAXBParameter p = (JAXBParameter) param;
+            p.setJAXBContext(jaxbContext);
+        }
+        
+        OMElement reqEnvelope = toOM(param, axisController.getServiceClient().getOptions().getSoapVersionURI());
+        requestMsgCtx.setMessageAsOM(reqEnvelope);
+        
+        // Copy the properties from the request context into the MessageContext
+        requestMsgCtx.getProperties().putAll(requestContext);
+        
+        // Send the request using the InvocationController
+        ic.invoke(invocationContext);
+        
+        MessageContext responseMsgCtx = invocationContext.getResponseMessageContext();
+        
+        //FIXME: This is temporary until more of the Message model is available
+        OMElement rspEnvelope = responseMsgCtx.getMessageAsOM();
+        Parameter rspParam;
+        // Create a new Parameter class for the output based on in the 
+        // input Parameter type.
+        try {
+            rspParam = param.getClass().newInstance();
+            if (rspParam instanceof JAXBParameter) {
+                JAXBParameter p = (JAXBParameter) rspParam;
+                p.setJAXBContext(jaxbContext);
+            }
+        } catch (Exception e) {
+            throw new WebServiceException(e);
+        }
+        
+        rspParam = fromOM(rspEnvelope, rspParam, axisController.getServiceClient().getOptions().getSoapVersionURI());
+        
+        return rspParam.getValue();
+    }
     
    public void invokeOneWay(Object obj) throws WebServiceException{
        if(obj == null){
-			throw new WebServiceException("Dispatch Cannot Invoke SEI with null object");
-		}
-    	try{
-    		Parameter param = ParameterFactory.createParameter(obj);
+            throw new WebServiceException("Dispatch Cannot Invoke SEI with null object");
+        }
+        try{
+            Parameter param = ParameterFactory.createParameter(obj);
             axisController.invokeOneWay(param, requestContext);
-    	}catch(Exception e){
-    		throw new WebServiceException(e);
-    	}
+        }catch(Exception e){
+            throw new WebServiceException(e);
+        }
     }
    
     public Future<?> invokeAsync(Object obj, AsyncHandler asynchandler) throws WebServiceException {
@@ -82,35 +184,62 @@
     }
   
     public Response invokeAsync(Object obj)throws WebServiceException{
-    	if(obj == null){
-			throw new WebServiceException("Dispatch Cannot Invoke SEI with null object");
-		}
-    	try{
-    		Parameter param = ParameterFactory.createParameter(obj);
-    		return axisController.invokeAsync(param, requestContext);
-    	}catch(Exception e){
-    		throw new WebServiceException(e);
-    	}
+        if(obj == null){
+            throw new WebServiceException("Dispatch Cannot Invoke SEI with null object");
+        }
+        try{
+            Parameter param = ParameterFactory.createParameter(obj);
+            return axisController.invokeAsync(param, requestContext);
+        }catch(Exception e){
+            throw new WebServiceException(e);
+        }
     }    
 
     protected void setRequestContext(){
-    	String endPointAddress = axisController.getEndpointAddress();
-    	WSDLWrapper wsdl =  axisController.getWSDLContext();
-    	QName serviceName = axisController.getServiceName();
-    	QName portName = axisController.getPortName();
-    	if(endPointAddress != null && !"".equals(endPointAddress)){
-        	getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, endPointAddress);
+        String endPointAddress = axisController.getEndpointAddress();
+        WSDLWrapper wsdl =  axisController.getWSDLContext();
+        QName serviceName = axisController.getServiceName();
+        QName portName = axisController.getPortName();
+        if(endPointAddress != null && !"".equals(endPointAddress)){
+            getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, endPointAddress);
         }else if(wsdl != null){
-        	String soapAddress = wsdl.getSOAPAddress(serviceName, portName);
-        	getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, soapAddress);
+            String soapAddress = wsdl.getSOAPAddress(serviceName, portName);
+            getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, soapAddress);
         }
         
         if(wsdl != null){
-        	String soapAction = wsdl.getSOAPAction(serviceName, portName);
-    		getRequestContext().put(BindingProvider.SOAPACTION_URI_PROPERTY, soapAction);
+            String soapAction = wsdl.getSOAPAction(serviceName, portName);
+            getRequestContext().put(BindingProvider.SOAPACTION_URI_PROPERTY, soapAction);
         }
         
         getRequestContext().put(Constants.QOS_WSADDRESSING_ENABLE, Boolean.FALSE);
         getRequestContext().put(Constants.QOS_WSRM_ENABLE, Boolean.FALSE);
     }
+    
+    /* 
+     * FIXME: This is temporary until more of the Message Model is available.
+     */
+    private OMElement toOM(Parameter param, String soapVersion){
+        SOAPEnvelope env = ParameterUtils.toEnvelope(mode, soapVersion, param);
+        System.out.println(">> Generated envelope [" + env.toString() + "]");
+        
+        SOAPBody body = env.getBody();
+        //SOAPHeader soapHeader = env.getHeader();
+        //addHeadersToServiceClient(soapHeader);
+        return body.getFirstElement();
+    }
+    
+    /*
+     * FIXME: This is temporary until more of the Message Model is available. 
+     */
+    private Parameter fromOM(OMElement element, Parameter response, String soapVersion){
+        response.fromOM(element);
+
+        // Convert param toEnvelope since ServiceClient always send xml string.
+        // toEnvelope() in Parameter is coded just to handle this.
+        SOAPEnvelope env = response.toEnvelope(null, soapVersion);
+        
+        response.fromEnvelope(mode, env);
+        return response;
+    }
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/PropertyInfo.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/PropertyInfo.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/PropertyInfo.java	(revision 0)
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.jaxws.wrapper.impl;
+
+import java.beans.PropertyDescriptor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+
+public class PropertyInfo {
+	String propertyName;
+	PropertyDescriptor descriptor;
+	
+	/**
+	 * @param propertyName
+	 * @param descriptor
+	 */
+	public PropertyInfo(String propertyName, PropertyDescriptor descriptor) {
+		super();
+		
+		this.propertyName = propertyName;
+		this.descriptor = descriptor;
+	}
+	
+	public String getPropertyName(){
+		return this.propertyName;
+	}
+	
+	public Object get(Object targetBean)throws InvocationTargetException, IllegalAccessException{
+		Method method = descriptor.getReadMethod();
+		return method.invoke(targetBean, null);
+	}
+	
+	public void set(Object targetBean, Object propValue)throws InvocationTargetException, IllegalAccessException{
+		Method method = descriptor.getWriteMethod();
+		method.invoke(targetBean, propValue);
+	}
+	
+}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperException.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperException.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperException.java	(revision 0)
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.jaxws.wrapper.impl;
+
+
+public class JAXBWrapperException extends Exception {
+
+	/**
+	 * 
+	 */
+	public JAXBWrapperException() {
+		super();
+		
+	}
+
+	/**
+	 * @param message
+	 * @param cause
+	 */
+	public JAXBWrapperException(String message, Throwable cause) {
+		super(message, cause);
+		
+	}
+
+	/**
+	 * @param message
+	 */
+	public JAXBWrapperException(String message) {
+		super(message);
+		
+	}
+
+	/**
+	 * @param cause
+	 */
+	public JAXBWrapperException(Throwable cause) {
+		super(cause);
+		
+	}
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperToolImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperToolImpl.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperToolImpl.java	(revision 0)
@@ -0,0 +1,210 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.jaxws.wrapper.impl;
+
+import java.beans.IntrospectionException;
+import java.beans.Introspector;
+import java.beans.PropertyDescriptor;
+import java.beans.PropertyEditor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.TypeVariable;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBElement;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.namespace.QName;
+
+import org.apache.axis2.jaxws.wrapper.JAXBWrapperTool;
+
+
+public class JAXBWrapperToolImpl implements JAXBWrapperTool {
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.wrapped.JAXBWrapperTool#unWrap(java.lang.Object, javax.xml.bind.JAXBContext, java.util.ArrayList)
+	 */
+	
+	/*
+	 * create property descriptor using jaxbObject and child Names,
+	 * getReader and read the object, form the object array and return them.
+	 */
+	
+	public Object[] unWrap(Object jaxbObject, 
+			ArrayList<String> childNames) throws JAXBWrapperException{
+		try{
+			if(jaxbObject == null){
+				throw new JAXBWrapperException("input JAXB Object cannot be null");
+			}
+			if(childNames == null){
+				throw new JAXBWrapperException("Input childNames cannot be null");
+			}
+			ArrayList<Object> objList = new ArrayList<Object>();
+			if(jaxbObject == null){
+				
+				throw new JAXBWrapperException(new NullPointerException("UnWrap cannot continue, input parameter jaxbObject is null "));
+			}
+			Map<String , PropertyInfo> pdTable = createPropertyDescriptors(jaxbObject.getClass(), childNames);
+			for(String childName:childNames){
+				PropertyInfo propInfo = pdTable.get(childName);
+				Object object = propInfo.get(jaxbObject);
+				objList.add(object);
+			}
+			Object[] jaxbObjects = objList.toArray();
+			objList = null;
+			return jaxbObjects;
+		}catch(IntrospectionException e){
+			throw new JAXBWrapperException(e);
+		}catch(IllegalAccessException e){
+			throw new JAXBWrapperException(e);
+		}catch(InvocationTargetException e){
+			throw new JAXBWrapperException(e);
+		}catch(NoSuchFieldException e){
+			throw new JAXBWrapperException(e);
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.wrapped.JAXBWrapperTool#wrap(java.lang.Class, java.lang.String, java.util.ArrayList, java.util.ArrayList)
+	 */
+	public Object wrap(Class jaxbClass, String jaxbClassName,
+			ArrayList<String> childNames, Map<String, Object> childObjects)
+			throws JAXBWrapperException {
+		
+		try{
+			if(childNames == null|| childObjects == null){
+				throw new JAXBWrapperException("Input Child Name or Child Object values cannot be null");
+			}
+			if(childNames.size() != childObjects.size()){
+				throw new JAXBWrapperException("Input ChildNames should be same as input childObjects ");
+			}
+			Map<String, PropertyInfo> pdTable = createPropertyDescriptors(jaxbClass, childNames);
+			Object jaxbObject = jaxbClass.newInstance();
+			for(String childName:childNames){
+				PropertyInfo propInfo = pdTable.get(childName);
+				propInfo.set(jaxbObject, childObjects.get(childName));
+			}
+			return jaxbObject;
+		}catch(IntrospectionException e){
+			throw new JAXBWrapperException(e);
+		}catch(InstantiationException e){
+			throw new JAXBWrapperException(e);
+		}catch(IllegalAccessException e){
+			throw new JAXBWrapperException(e);
+		}catch(InvocationTargetException e){
+			throw new JAXBWrapperException(e);
+		}catch(NoSuchFieldException e){
+			throw new JAXBWrapperException(e);
+		}
+	}
+	
+	public JAXBElement wrapAsJAXBElement(Class jaxbClass, String jaxbClassName,
+			ArrayList<String> childNames, Map<String, Object> childObjects) throws JAXBWrapperException{
+		
+		Object obj = wrap( jaxbClass, jaxbClassName, childNames, childObjects);
+		JAXBElement<Object> element = new JAXBElement<Object>(new QName(jaxbClassName), jaxbClass, obj);
+		return element;
+	}
+	
+	/** creates propertyDescriptor for the childNames using the jaxbClass.  
+	 * use Introspector.getBeanInfo().getPropertyDescriptors() to get all the property descriptors. Assert if # of childNames and propertyDescriptor array
+	 * length do not match. if they match then get the xmlElement name from jaxbClass using propertyDescriptor's display name. See if the xmlElementName matches the 
+	 * childName if not use xmlElement annotation name and create PropertyInfo add childName or xmlElement name there, set propertyDescriptor 
+	 * and return Map<ChileName, PropertyInfo>.
+	 * @param jaxbClass - Class jaxbClass name
+	 * @param childNames - ArrayList<String> of childNames 
+	 * @return Map<String, PropertyInfo> - map of ChildNames that map to PropertyInfo that hold the propertyName and PropertyDescriptor.
+	 * @throws IntrospectionException, NoSuchFieldException
+	 */
+	private Map<String, PropertyInfo> createPropertyDescriptors(Class jaxbClass, ArrayList<String> childNames) throws IntrospectionException, NoSuchFieldException, JAXBWrapperException{
+		Map<String, PropertyInfo> map = new WeakHashMap<String, PropertyInfo>();
+		PropertyDescriptor[] pds = Introspector.getBeanInfo(jaxbClass).getPropertyDescriptors();
+		
+		Map<String, PropertyDescriptor>  jaxbClassPds = filterDescriptors(pds, jaxbClass);
+		Field field[] = jaxbClass.getDeclaredFields();
+		if(field.length != childNames.size()){
+			throw new JAXBWrapperException("Number of field defined in JAXBClass ["+jaxbClass+"] is not equal to the input ChildNames and Child Objects provided to map");
+		}
+		pds=null;
+		
+		for(int i=0; i<field.length ;i++){
+			PropertyInfo propInfo= null;
+			String fieldName = field[i].getName();
+			String childName = childNames.get(i);
+			PropertyDescriptor pd = jaxbClassPds.get(childName);
+			if(pd == null){
+				pd = jaxbClassPds.get(fieldName);
+				if(pd == null){
+					throw new JAXBWrapperException("No Such Field [ChildName: "+childName+ "]");
+				}	
+			}
+			propInfo = new PropertyInfo(fieldName, pd);
+			map.put(childName, propInfo);
+		}
+		jaxbClassPds = null;
+		field = null;
+		return map;
+	}
+	
+	
+	/** Filter PropertyDescriptors that belong to super class, return only the ones that belong to JABXClass
+	 * create map of java fieldName and propertyDescriptor, if propertyName different than java fieldName then
+	 * check the xmlElementName ensure they are same if not do conver both xmlName and propertyName to lowercase and
+	 * ensure they are same if they match then add the corrosponding javaFieldName and PropertyDescriptor in map. If they dont 
+	 * match the propertyName belongs to super class and we ignore it.
+	 * @param allPds 
+	 * @param jaxbClass
+	 * @return
+	 */
+	private Map<String, PropertyDescriptor> filterDescriptors(PropertyDescriptor[] allPds, Class jaxbClass) throws NoSuchFieldException{
+		Map<String, PropertyDescriptor> filteredPds = new WeakHashMap<String, PropertyDescriptor>();
+		Field[] fields = jaxbClass.getDeclaredFields();
+		for(PropertyDescriptor pd:allPds){
+			for(Field field:fields){
+				if(field.getName().equals(pd.getDisplayName())){
+					filteredPds.put(pd.getDisplayName(), pd);
+					break;
+				}else{
+					String xmlName =getXmlElementName(jaxbClass, field.getName());
+					if(xmlName.equals(pd.getDisplayName())){
+						filteredPds.put(field.getName(), pd);
+						break;
+					}
+					if(xmlName.toLowerCase().equals(pd.getDisplayName().toLowerCase())){
+						filteredPds.put(field.getName(), pd);
+						break;
+					}
+				}
+			}
+		}
+		allPds=null;
+		return filteredPds;
+	}
+	
+	private String getXmlElementName(Class jaxbClass, String fieldName)throws NoSuchFieldException{
+		Field field = jaxbClass.getDeclaredField(fieldName);
+		XmlElement xmlElement =field.getAnnotation(XmlElement.class);
+		return xmlElement.name();
+		
+	}
+}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/JAXBWrapperTool.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/JAXBWrapperTool.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/JAXBWrapperTool.java	(revision 0)
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.jaxws.wrapper;
+
+import java.util.ArrayList;
+import java.util.Map;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBElement;
+
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
+
+
+public interface JAXBWrapperTool {
+	/**
+     * unwrap
+     * Returns the list of child elements of the jaxb object
+     * @param javab Object that is the wrapper element
+     * @param jaxbContext JAXBContext
+     * @param childNames list of xml child names as String
+     * @return list of Objects in the same order as the element names.
+     */
+   public Object[] unWrap(Object jaxbObject, ArrayList<String> childNames) throws JAXBWrapperException;
+
+
+    /**
+     * wrap
+     * Creates a jaxb object that is initialized with the child objects
+     * @param javabClass Class of the JAXB object to return
+     * @param jaxbContext JAXBContext
+     * @param childObjects, component objects
+     * @param childNames list of xml child names as String
+     * @return list of Objects in the same order as the element names.
+     */ 
+    public Object wrap(Class jaxbClass, String jaxbClassName, ArrayList<String> childNames, Map<String, Object> childObjects) throws JAXBWrapperException;
+    
+    /**
+     * wrapAsJAXBElement
+     * Creates a JAXBElement that is initialized with the child objects and can be serialsed to xml later.
+     * @param javabClass Class of the JAXB object to return
+     * @param jaxbContext JAXBContext
+     * @param childObjects, component objects
+     * @param childNames list of xml child names as String
+     * @return JAXBElement;
+     */
+    public JAXBElement wrapAsJAXBElement(Class jaxbClass, String jaxbClassName,
+			ArrayList<String> childNames, Map<String, Object> childObjects) throws JAXBWrapperException;
+		
+}
+
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/JAXWSClientContext.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/JAXWSClientContext.java	(revision 420936)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/JAXWSClientContext.java	(working copy)
@@ -24,6 +24,7 @@
 import javax.xml.bind.JAXBContext;
 import javax.xml.ws.Service.Mode;
 
+import org.apache.axis2.jaxws.description.ServiceDescription;
 import org.apache.axis2.jaxws.handler.PortData;
 import org.apache.axis2.jaxws.util.WSDLWrapper;
 
@@ -32,7 +33,7 @@
 	private PortData port = null;
 	private Mode serviceMode = null;
 	private ExecutorService executor = null;
-	private WSDLWrapper wsdlContext = null;
+    private ServiceDescription serviceDescription;
 	private Class<T> clazz = null; //SEI class for Proxy or Implementation type for Dispatch
 	private JAXBContext jaxbContext = null;
     
@@ -54,15 +55,18 @@
 	public void setServiceMode(Mode serviceMode) {
 		this.serviceMode = serviceMode;
 	}
-	public WSDLWrapper getWsdlContext() {
-		return wsdlContext;
+	public ServiceDescription getServiceDescription() {
+        return serviceDescription;
+    }
+    public void setServiceDescription(ServiceDescription serviceDescription) {
+        this.serviceDescription = serviceDescription;
+    }
+    public WSDLWrapper getWsdlContext() {
+		return (serviceDescription != null) ? serviceDescription.getWSDLWrapper() : null;
 	}
-	public void setWsdlContext(WSDLWrapper wsdlContext) {
-		this.wsdlContext = wsdlContext;
+    public URL getWSDLLocation(){
+		return (serviceDescription != null) ? serviceDescription.getWSDLLocation() : null; 	
 	}
-	public URL getWSDLLocation(){
-		return (wsdlContext != null)? wsdlContext.getWSLDLocation(): null; 	
-	}
 	public Class<T> getClazz() {
 		return clazz;
 	}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/mdq/input/README.txt
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/mdq/input/README.txt	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/mdq/input/README.txt	(revision 0)
@@ -0,0 +1,4 @@
+This package will represent the wrapper around a collection of WSMService objects. The wrapper 
+class will possibly contain some type of information that signifies how the WSMService objects 
+were created. This will allow the user to determine if the data was created from wsdl or class 
+file annotations.
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/mdq/output/README.txt
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/mdq/output/README.txt	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/mdq/output/README.txt	(revision 0)
@@ -0,0 +1,5 @@
+This package will be used to represent the data that is output as a result of MetaDataQuery 
+functionality. The output should be similar to the input, a collection of WSMService objects. 
+The WSMService objects will represent the merged data from both wsdl and annotations, if both 
+were present. The user will then write generators, similar to the WSM convention, that make use 
+of the data in the appropriate fashion.
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/mdq/README.txt
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/mdq/README.txt	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/mdq/README.txt	(revision 0)
@@ -0,0 +1,6 @@
+This package will contain functionality to validate, process, and merge information provided 
+by annotation metadata and wsdl. The idea will be that the MDQ works off of collections of 
+WSMService objects as defined by the WSM project. Users will need to supply their own
+functionality that converts varying data into WSMService objects. For instance, users may 
+need a WSDL to WSMSerivce converter. Ideally, the MDQ will have knowledge of a single data 
+structure which will be a WSMService.
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/mdq/annotations/collector/README.txt
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/mdq/annotations/collector/README.txt	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/mdq/annotations/collector/README.txt	(revision 0)
@@ -0,0 +1,4 @@
+This package will allow for independence of annotation collection techniques. There will be an 
+interface, AnnotationCollector, that defines a method which will return an array of WSMService 
+objects. These objects will be created by the collector after it has located all of the 
+annotations in the relevant class files.
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/ClientMediator.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/ClientMediator.java	(revision 420936)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/ClientMediator.java	(working copy)
@@ -17,11 +17,7 @@
 package org.apache.axis2.jaxws;
 
 import java.lang.reflect.Proxy;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.Iterator;
 
-import javax.wsdl.Definition;
 import javax.xml.namespace.QName;
 import javax.xml.ws.WebServiceException;
 
@@ -33,9 +29,9 @@
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.AxisServiceGroup;
-import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.axis2.jaxws.client.JAXBDispatch;
+import org.apache.axis2.jaxws.client.XMLDispatch;
 import org.apache.axis2.jaxws.handler.PortData;
-import org.apache.axis2.jaxws.util.Constants;
 import org.apache.axis2.jaxws.util.WSDLWrapper;
 /*
  * This class acts as a mediator to creating Proxy or Dispatch implementation when Client makes a call to Service.
@@ -49,8 +45,33 @@
 		super();
 	}
 
-	public <T> Dispatch<T> createDispatch(JAXWSClientContext<T> clientContext){
+    public <T> JAXBDispatch<T> createJAXBDispatch(JAXWSClientContext<T> clientContext){
 
+        if (clientContext == null) {
+            throw new WebServiceException(
+                    "Internal Error ... JAXWSClientContext not found");
+        }
+        this.clientContext = clientContext;
+        /*
+         * create Axis Controller, this will route all the calls from Dispatch to
+         * Axis Engine eiter using ServiceClient or instantiating
+         * AxisEngine.
+         */
+        try{
+            AxisController axisController = buildAxisController();
+            axisController.setClientContext(clientContext);
+            
+            JAXBDispatch<T> dispatch = new JAXBDispatch<T>(axisController);
+            dispatch.setMode(clientContext.getServiceMode());
+            dispatch.setJAXBContext(clientContext.getJAXBContext());
+            return dispatch;
+        }catch(AxisFault e){
+            throw new WebServiceException(e.getMessage());
+        }
+    }
+    
+    public <T> XMLDispatch<T> createXMLDispatch(JAXWSClientContext<T> clientContext){
+
 		if (clientContext == null) {
 			throw new WebServiceException(
 					"Internal Error ... JAXWSClientContext not found");
@@ -64,7 +85,8 @@
 		try{
 			AxisController axisController = buildAxisController();
 			axisController.setClientContext(clientContext);
-			Dispatch<T> dispatch = new Dispatch<T>(axisController);
+			XMLDispatch<T> dispatch = new XMLDispatch<T>(axisController);
+            dispatch.setMode(clientContext.getServiceMode());
 			return dispatch;
 		}catch(AxisFault e){
 			throw new WebServiceException(e.getMessage());
@@ -143,18 +165,9 @@
 
 	private ServiceClient getServiceClient(ConfigurationContext axisConfig)
 			throws AxisFault {
-		
-		URL wsdlLocation = clientContext.getWSDLLocation();
-		if (wsdlLocation != null) {
-			Definition definition = clientContext.getWsdlContext().getDefinition();
-			if(definition!=null){
-				return new ServiceClient(axisConfig, definition,
-						getServiceName(), getPortName().getLocalPart());
-			}
-			return new ServiceClient(axisConfig, wsdlLocation,
-					getServiceName(), getPortName().getLocalPart());
-		}
-		return new ServiceClient(axisConfig, null);
+	
+		return new ServiceClient(axisConfig, 
+                clientContext.getServiceDescription().getAxisService());
 
 	}
 
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/FaultDescription.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/FaultDescription.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/FaultDescription.java	(revision 0)
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.axis2.jaxws.description;
+
+/**
+ * 
+ */
+/*
+Workign-design information.
+
+Java Name: Exception class name
+
+Exception Holder Type
+Exception Holder Held Type
+
+Axis2 Delegate: TBD
+
+JSR-181 Annotations: TBD
+
+WSDL Elements: TBD
+
+JAX-WS Annotations:
+@WebFault(name, targetNamespace, faultBean)
+
+Properties available to JAXWS runtime: TBD
+
+ */
+public class FaultDescription {
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ParameterDescription.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ParameterDescription.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ParameterDescription.java	(revision 0)
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.axis2.jaxws.description;
+
+/**
+ * 
+ */
+/*
+Java Name: Parameter Name
+
+Java Signature Parameter Type:  Could be a holder class
+Java Signature ParameterHeldType if the Signature Parameter  Type is a holder class, then this is the held type
+
+Axis2 Delegate: TBD
+
+JSR-181 Annotations: 
+@WebParam(name, targetNamespace, mode, header, partName) [Input, Output]
+@WebResult(name, targetNamespace, header, partName) [Output only?]
+TBD
+
+WSDL Elements: TBD
+
+JAX-WS Annotations: TBD
+
+Properties available to JAXWS runtime: TBD
+
+ */
+public class ParameterDescription {
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ServiceDescription.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ServiceDescription.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ServiceDescription.java	(revision 0)
@@ -0,0 +1,234 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.description;
+
+import java.net.URL;
+import java.util.Hashtable;
+import java.util.Iterator;
+import java.util.Map;
+
+import javax.xml.namespace.QName;
+import javax.xml.ws.WebServiceException;
+import javax.wsdl.Definition;
+import javax.wsdl.Port;
+import javax.wsdl.Service;
+import javax.wsdl.WSDLException;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.client.ServiceClient;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.OutInAxisOperation;
+import org.apache.axis2.description.OutOnlyAxisOperation;
+import org.apache.axis2.description.RobustOutOnlyAxisOperation;
+import org.apache.axis2.description.WSDL11ToAxisServiceBuilder;
+import org.apache.axis2.engine.AbstractDispatcher;
+import org.apache.axis2.jaxws.util.WSDL4JWrapper;
+import org.apache.axis2.jaxws.util.WSDLWrapper;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * The JAX-WS Service metadata and root of the JAX-WS Descritpion hierachy.
+ */
+
+/*
+Working-design information.
+
+Description hierachy
+    ServiceDescription
+        EndpointDescription[]
+            EndpointInterfaceDescription
+                OperationDescription[]
+                    ParameterDescription Input[]
+                    ParameterDescription Output[]
+                    FaultDescription
+
+ServiceDescription:
+Corresponds to the generated Service class [client]; TBD [server]
+
+Java Name: Generated service class or null if dynamically configured service [client]; null [server]
+
+Axis2 Delegate: AxisService
+
+JSR-181 Annotations: 
+@HandlerChain(file, name) [per JAXWS p. 105] Affects all proxies and dispatches created using any port on this service
+TBD
+
+WSDL Elements: 
+<service
+
+JAX-WS Annotations: 
+@WebServiceClient(name, targetNamespace, wsdlLocation)
+@WebEndpoint(name) This is specified on the getPortName() methods on the service
+TBD
+
+Properties available to JAXWS runtime:
+getJAXInterface(QName port) Needed by HandlerResolver
+TBD
+
+ */
+
+public class ServiceDescription {
+    private AxisService axisService;
+
+    private URL wsdlURL;
+    private QName serviceQName;
+    private Class serviceClass;
+    
+    // TODO: Possibly remove Definition and delegate to the Defn on the AxisSerivce set as a paramater by WSDLtoAxisServicBuilder?
+    private WSDLWrapper wsdlWrapper; 
+    
+    private Hashtable<QName, EndpointDescription> endpointDescriptions = new Hashtable<QName, EndpointDescription>();
+    
+    private static final Log log = LogFactory.getLog(AbstractDispatcher.class);
+    
+    /**
+     * ServiceDescription contains the metadata (e.g. WSDL, annotations) relating to a Service.
+     * 
+     * @param wsdlURL  The WSDL file (this may be null).
+     * @param serviceQName  The name of the service in the WSDL.  This can not be null since a 
+     *   javax.xml.ws.Service can not be created with a null service QName.
+     * @param serviceClass  The JAX-WS service class.  This could be an instance of
+     *   javax.xml.ws.Service or a generated service subclass thereof.
+     */
+    public ServiceDescription(URL wsdlURL, QName serviceQName, Class serviceClass) {
+        if (serviceQName == null) {
+            throw new WebServiceException("Invalid Service QName; cannot be null");
+        }
+        if (serviceClass == null) {
+            throw new WebServiceException("Invalid Service Class; cannot be null");
+        }
+        if (!javax.xml.ws.Service.class.isAssignableFrom(serviceClass)) {
+            throw new WebServiceException("Invalid Service Class; must be assignable to javax.xml.ws.Service");
+        }
+        
+        this.wsdlURL = wsdlURL;
+        this.serviceQName = serviceQName;
+        this.serviceClass = serviceClass;
+        
+        setupWsdlDefinition();
+        setupAxisService();
+        buildDescriptionHierachy();
+    }
+    
+    /*=======================================================================*/
+    /*=======================================================================*/
+    // START of public accessor methods
+    
+    public EndpointDescription getEndpointDescription(QName portQName) {
+        return endpointDescriptions.get(portQName);
+    }
+    
+    public AxisService getAxisService() {
+        return axisService;
+    }
+    
+    // END of public accessor methods
+    /*=======================================================================*/
+    /*=======================================================================*/
+    
+    private void setupWsdlDefinition() {
+        // Note that there may be no WSDL provided, for example when called from 
+        // Service.create(QName serviceName).
+        if (wsdlURL != null) {
+            try {
+                wsdlWrapper = new WSDL4JWrapper(this.wsdlURL);
+            } catch (WSDLException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+                throw new WebServiceException("caught WSDL Exception" + e.getMessage());
+            }
+        }
+    }
+
+    private void setupAxisService() {
+        // TODO: Need to use MetaDataQuery validator to merge WSDL (if any) and annotations (if any)
+        
+        if (wsdlWrapper != null) {
+            buildAxisServiceFromWSDL();
+        }
+        else {
+            buildAxisServiceFromNoWSDL();
+        }
+    }
+
+    private void buildAxisServiceFromWSDL() {
+        // TODO: Change this to use WSDLToAxisServiceBuilder superclass
+        WSDL11ToAxisServiceBuilder serviceBuilder = new WSDL11ToAxisServiceBuilder(wsdlWrapper.getDefinition(), serviceQName, null);
+        try {
+            axisService = serviceBuilder.populateService();
+        } catch (AxisFault e) {
+            // TODO Auto-generated catch block
+            log.warn("ServiceDescription: Caught exception creating AxisService", e);
+        }
+    }
+    
+    private void buildAxisServiceFromNoWSDL() {
+        // Patterned after ServiceClient.createAnonymousService()
+        String serviceName = null;
+        if (serviceQName != null) {
+            serviceName = serviceQName.getLocalPart();
+        }
+        else {
+            serviceName = ServiceClient.ANON_SERVICE;
+        }
+        // Make this service name unique.  The Axis2 engine assumes that a service it can not find is a client-side service.
+        // See org.apache.axis2.client.ServiceClient.configureServiceClient()
+        axisService = new AxisService(serviceName + this.hashCode());
+        axisService.addOperation(new RobustOutOnlyAxisOperation(ServiceClient.ANON_ROBUST_OUT_ONLY_OP));
+        axisService.addOperation(new OutOnlyAxisOperation(ServiceClient.ANON_OUT_ONLY_OP));
+        axisService.addOperation(new OutInAxisOperation(ServiceClient.ANON_OUT_IN_OP));
+    }
+    
+    private void buildDescriptionHierachy() {
+        // Create the EndpointDescription corresponding to the WSDL <port> tags
+        if (wsdlWrapper != null) {
+            buildEndpointDescriptionsFromWSDL();
+        }
+        // TODO: Need to create from Annotations (if no WSDL) and modify created ones based on annotations (if WSDL)
+        
+    }
+    
+    private void buildEndpointDescriptionsFromWSDL() {
+        // TODO: Currently Axis2 only supports 1 service and 1 port; that fix will likely affect this code
+        //       Until then, build the EndpointDescriptions directly from the WSDL.
+        Definition definition = wsdlWrapper.getDefinition();
+        Service service = definition.getService(serviceQName);
+        if (service == null) {
+            throw new WebServiceException("Service QName not found in WSDL");
+        }
+        
+        Map ports = service.getPorts();
+        if (ports != null && ports.size() > 0) {
+            Iterator portIterator = ports.values().iterator();
+            while (portIterator.hasNext()) {
+                Port wsdlPort = (Port) portIterator.next();
+                EndpointDescription endpointDescription = new EndpointDescription(wsdlPort, definition);
+                QName portQName = endpointDescription.getPortQName();
+                endpointDescriptions.put(portQName, endpointDescription); 
+            }
+        }
+    }
+    
+    // TODO: Remove these and replace with appropraite get* methods for WSDL information
+    public WSDLWrapper getWSDLWrapper() {
+        return wsdlWrapper;
+    }
+    public URL getWSDLLocation() {
+        return wsdlURL;
+    }
+}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/OperationDescription.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/OperationDescription.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/OperationDescription.java	(revision 0)
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.axis2.jaxws.description;
+
+/**
+ * 
+ */
+/*
+Java Name: Method name from SEI
+
+Axis2 Delegate: AxisOperation
+
+JSR-181 Annotations: 
+@WebMethod
+- operationName
+- action
+- exclude
+@Oneway So basically even if an operation has a return parameter it could be one way and in this case should we set the AxisOperatio mep to oneway?[NT]
+TBD
+
+WSDL Elements
+<portType  <operation
+
+JAX-WS Annotations
+@RequestWrapper
+- localName
+- targetNamespace
+- className
+@ResponseWrapper
+- localName
+- targetNamespace
+- className
+TBD
+
+Properties available to JAXWS runtime: 
+isWrapper()
+String getRequestWrapper JAXB Class
+String getResponseWrapper JAXB Class
+TBD
+
+ */
+public class OperationDescription {
+
+}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointDescription.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointDescription.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointDescription.java	(revision 0)
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.axis2.jaxws.description;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.wsdl.Definition;
+import javax.wsdl.Port;
+import javax.xml.namespace.QName;
+
+
+/**
+ * 
+ */
+/*
+Working-design information.
+
+Java Name: none [client]; Endpoint implementation class [server]
+
+Axis2 Delegate: none; Axis2 put this information into AxisService
+
+JSR-181 Annotations: TBD
+
+WSDL Elements
+<port
+
+JAX-WS Annotations: 
+@ServiceMode (value) [Server, jaxws.Provider?]
+@WebServiceProvider(wsdllocation, serviceName, portName, targetNamespace) [Server, jaxws.Provider]
+@BindingType(value) [Server, endpoint impl]
+TBD
+
+Properties available to JAXWS runtime: TBD
+
+ */
+/*
+ * TODO: EndpointDescription should be created AxisService objects and not directly from WSDL
+ * IMPORTANT NOTE: Axis2 currently only supports 1 service and 1 port under that service.  When that is
+ * fixed, that will probably have an impact on this class.  In particular, I think this should be created 
+ * somehow from an AxisService/AxisPort combination, and not directly from the WSDL.
+ */
+public class EndpointDescription {
+    private QName portQName;
+    // TODO: This needs to be a collection of handler descriptions; use JAX-WS Appendix B Handler Chain Configuration File Schema as a starting point
+    private ArrayList<String> handlerList = new ArrayList<String>();
+    
+    /**
+     * Create an EndpointDescription based on the WSDL port.  Note that per the JAX-WS Spec (Final Release, 4/19/2006
+     * Section 4.2.3 Proxies, page 55)the "namespace component of the port is the target namespace of the WSDL 
+     * definition document".
+     * 
+     * @param wsdlPort The WSDL Port tag for this EndpointDescription.
+     * @param definition The WSDL Definition target namespace used to create the port QName
+     */
+    EndpointDescription(Port wsdlPort, Definition definition) {
+        String localPart = wsdlPort.getName();
+        String namespace = definition.getTargetNamespace();
+        portQName = new QName(namespace, localPart);
+    }
+    public QName getPortQName() {
+        return portQName;
+    }
+    
+    /**
+     * Returns a live list describing the handlers on this port.
+     * TODO: This is currently returning List<String>, but it should return a HandlerDescritpion
+     * object that can represent a handler description from various Metadata (annotation, deployment descriptors, etc);
+     * use JAX-WS Appendix B Handler Chain Configuration File Schema as a starting point for HandlerDescription.
+     *  
+     * @return A List of handlers for this port.  The actual list is returned, and therefore can be modified.
+     */
+    public List<String> getHandlerList() {
+        return handlerList;
+    }
+}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointInterfaceDescription.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointInterfaceDescription.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointInterfaceDescription.java	(revision 0)
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations un