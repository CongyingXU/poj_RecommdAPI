Index: modules/kernel/test/org/apache/axis2/json/TestJSONDataSource.java
===================================================================
--- modules/kernel/test/org/apache/axis2/json/TestJSONDataSource.java	(revision 0)
+++ modules/kernel/test/org/apache/axis2/json/TestJSONDataSource.java	(revision 0)
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.json;
+
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamWriter;
+import java.io.*;
+
+import org.apache.axiom.om.util.StAXUtils;
+import org.json.JSONException;
+import junit.framework.TestCase;
+
+
+public class TestJSONDataSource extends TestCase {
+
+    public void testSerialize1() throws XMLStreamException {
+        String jsonString = "{\"p\":{\"name\":{\"kamal\":{\"$\":\"yes\"},\"$\":\"innername\"},\"@pp\":\"value\"}}";
+        InputStream jsonInputStream = new ByteArrayInputStream(jsonString.getBytes());
+        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
+        JSONDataSource source = new JSONDataSource(readLocalName(jsonInputStream), "p");
+        source.serialize(outStream, null);
+        assertEquals(jsonString, new String(outStream.toByteArray()));
+    }
+
+    public void testSerialize2() throws XMLStreamException, IOException {
+        String jsonString = "{\"p\":{\"name\":{\"kamal\":[{\"$\":\"yes\"},{\"$\":\"second\"}],\"$\":\"innername\"},\"@pp\":\"value\"}}";
+        InputStream jsonInputStream = new ByteArrayInputStream(jsonString.getBytes());
+        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
+        OutputStreamWriter writer = new OutputStreamWriter(outStream);
+        JSONDataSource source = new JSONDataSource(readLocalName(jsonInputStream), "p");
+        source.serialize(writer, null);
+        writer.flush();
+        assertEquals(jsonString, new String(outStream.toByteArray()));
+    }
+
+    public void testSerialize3() throws XMLStreamException, JSONException {
+        String jsonString = "{\"p\":{\"@xmlns\":{\"bb\":\"http://other.nsb\",\"aa\":\"http://other.ns\",\"$\":\"http://def.ns\"},\"sam\":{\"$\":\"555\", \"@att\":\"lets\"}}}";
+        InputStream jsonInputStream = new ByteArrayInputStream(jsonString.getBytes());
+        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
+        XMLStreamWriter writer = StAXUtils.createXMLStreamWriter(outStream);
+        JSONDataSource source = new JSONDataSource(readLocalName(jsonInputStream), "p");
+        source.serialize(writer);
+        writer.flush();
+        assertEquals("<?xml version='1.0' encoding='UTF-8'?><p xmlns=\"http://def.ns\" xmlns:bb=\"http://other.nsb\" xmlns:aa=\"http://other.ns\"><sam att=\"lets\">555</sam></p>", new String(outStream.toByteArray()));
+    }
+
+    private InputStream readLocalName(InputStream in) {
+        try {
+            while ((char) in.read() != ':') {
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return in;
+    }
+
+}

Property changes on: modules/kernel/test/org/apache/axis2/json/TestJSONDataSource.java
___________________________________________________________________
Name: svn:executable
   + *

Index: modules/kernel/src/org/apache/axis2/description/OutInAxisOperation.java
===================================================================
--- modules/kernel/src/org/apache/axis2/description/OutInAxisOperation.java	(revision 489364)
+++ modules/kernel/src/org/apache/axis2/description/OutInAxisOperation.java	(working copy)
@@ -255,6 +255,9 @@
         engine.send(msgctx);
         responseMessageContext.setDoingREST(msgctx.isDoingREST());
 
+        //setting json
+        responseMessageContext.setDoingJSON(msgctx.isDoingJSON());
+
         responseMessageContext.setProperty(MessageContext.TRANSPORT_IN, msgctx
                 .getProperty(MessageContext.TRANSPORT_IN));
         responseMessageContext.setTransportIn(msgctx.getTransportIn());
Index: modules/kernel/src/org/apache/axis2/description/RobustOutOnlyAxisOperation.java
===================================================================
--- modules/kernel/src/org/apache/axis2/description/RobustOutOnlyAxisOperation.java	(revision 489364)
+++ modules/kernel/src/org/apache/axis2/description/RobustOutOnlyAxisOperation.java	(working copy)
@@ -72,6 +72,9 @@
             engine.send(msgctx);
             responseMessageContext.setDoingREST(msgctx.isDoingREST());
 
+            //setting json
+            responseMessageContext.setDoingJSON(msgctx.isDoingJSON());
+
             responseMessageContext.setProperty(MessageContext.TRANSPORT_IN, msgctx
                     .getProperty(MessageContext.TRANSPORT_IN));
             responseMessageContext.setTransportIn(msgctx.getTransportIn());
Index: modules/kernel/src/org/apache/axis2/context/MessageContext.java
===================================================================
--- modules/kernel/src/org/apache/axis2/context/MessageContext.java	(revision 489364)
+++ modules/kernel/src/org/apache/axis2/context/MessageContext.java	(working copy)
@@ -157,6 +157,8 @@
     // Are we doing REST now?
     private boolean doingREST;
 
+    private boolean doingJSON;
+
     // Are we doing MTOM now?
     private boolean doingMTOM;
 
@@ -739,6 +741,10 @@
         return doingREST;
     }
 
+    public boolean isDoingJSON() {
+        return doingJSON;
+    }
+
     /**
      * @return Returns boolean.
      */
@@ -848,6 +854,10 @@
         doingREST = b;
     }
 
+    public void setDoingJSON(boolean b) {
+        doingJSON = b;
+    }
+
     /**
      * @param b
      */
Index: modules/kernel/src/org/apache/axis2/transport/http/AxisServlet.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/AxisServlet.java	(revision 489364)
+++ modules/kernel/src/org/apache/axis2/transport/http/AxisServlet.java	(working copy)
@@ -230,7 +230,7 @@
         OutputStream out = res.getOutputStream();
 
         if (!disableREST && enableRESTInAxis2MainServlet && isRESTRequest(req)) {
-            msgContext = createMessageContext(req, res);
+            msgContext = createMessageContext(req, res);            
             try {
                 new RESTUtil(configContext).processPostRequest(msgContext,
                         req,
Index: modules/kernel/src/org/apache/axis2/transport/http/JSONSender.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/JSONSender.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/transport/http/JSONSender.java	(revision 0)
@@ -0,0 +1,241 @@
+/*
+* Copyright 2004,2005 The Apache Software Foundation.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.apache.axis2.transport.http;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.OMNamespace;
+import org.apache.axiom.om.impl.llom.OMElementImpl;
+import org.apache.axiom.soap.SOAP11Constants;
+import org.apache.axiom.soap.SOAP12Constants;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.i18n.Messages;
+import org.apache.commons.httpclient.Header;
+import org.apache.commons.httpclient.HttpClient;
+import org.apache.commons.httpclient.HttpStatus;
+import org.apache.commons.httpclient.HttpVersion;
+import org.apache.commons.httpclient.methods.PostMethod;
+import org.apache.commons.httpclient.methods.RequestEntity;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.codehaus.jettison.badgerfish.BadgerFishXMLStreamWriter;
+
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.FactoryConfigurationError;
+import java.io.*;
+import java.net.URL;
+import java.util.Iterator;
+
+
+public class JSONSender extends AbstractHTTPSender {
+    private static final Log log = LogFactory.getLog(JSONSender.class);
+
+    public void send(MessageContext msgContext, OMElement dataout, URL url,
+                     String soapActionString) {
+
+        HttpClient httpClient = getHttpClient(msgContext);
+
+        PostMethod postMethod = new PostMethod(url.toString());
+        if (isAuthenticationEnabled(msgContext)) {
+            postMethod.setDoAuthentication(true);
+        }
+
+        String charEncoding =
+                (String) msgContext.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
+
+        if (charEncoding == null) {
+            charEncoding = MessageContext.DEFAULT_CHAR_SET_ENCODING;
+        }
+
+        int x = soapActionString.indexOf(":");
+        String operation = soapActionString.substring(x + 1, soapActionString.length());
+
+        postMethod.setPath(url.getPath() + "/" + operation);
+        postMethod.setRequestEntity(new AxisRequestEntity(dataout, chunked, msgContext, charEncoding));
+
+        if (!httpVersion.equals(HTTPConstants.HEADER_PROTOCOL_10) && chunked) {
+            postMethod.setContentChunked(true);
+        }
+
+        postMethod.setRequestHeader(HTTPConstants.HEADER_HOST, url.getHost());
+
+        if (httpVersion != null) {
+            if (httpVersion.equals(HTTPConstants.HEADER_PROTOCOL_10)) {
+                httpClient.getParams().setVersion(HttpVersion.HTTP_1_0);
+                postMethod.setRequestHeader(HTTPConstants.HEADER_CONNECTION,
+                        HTTPConstants.HEADER_CONNECTION_KEEPALIVE);
+            } else {
+
+                // allowing keep-alive for 1.1
+                postMethod.setRequestHeader(HTTPConstants.HEADER_CONNECTION,
+                        HTTPConstants.HEADER_CONNECTION_KEEPALIVE);
+                postMethod.setRequestHeader(HTTPConstants.HEADER_EXPECT,
+                        HTTPConstants.HEADER_EXPECT_100_Continue);
+            }
+        }
+
+        /**
+         * main excecution takes place..
+         */
+
+
+        try {
+            executeMethod(httpClient, msgContext, url, postMethod);
+
+            if (postMethod.getStatusCode() == HttpStatus.SC_OK) {
+                processResponse(postMethod, msgContext);
+                return;
+            } else if (postMethod.getStatusCode() == HttpStatus.SC_ACCEPTED) {
+                return;
+            } else if (postMethod.getStatusCode() == HttpStatus.SC_INTERNAL_SERVER_ERROR) {
+                Header contenttypeHheader =
+                        postMethod.getResponseHeader(HTTPConstants.HEADER_CONTENT_TYPE);
+
+                if (contenttypeHheader != null) {
+                    String value = contenttypeHheader.getValue();
+
+                    if ((value.indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0)
+                            || (value.indexOf(SOAP12Constants.SOAP_12_CONTENT_TYPE) >= 0)) {
+                        processResponse(postMethod, msgContext);
+
+                        return;
+                    }
+                }
+            }
+            throw new AxisFault(Messages.getMessage("transportError",
+                    String.valueOf(postMethod.getStatusCode()),
+                    postMethod.getResponseBodyAsString()));
+        } catch (Exception e) {
+            log.error("Error in processing POST request", e);
+        }
+
+    }
+
+    public class AxisRequestEntity implements RequestEntity {
+        private byte[] bytes;
+        private String charSetEnc;
+        private boolean chunked;
+        private OMElement element;
+        private MessageContext msgCtxt;
+
+        public AxisRequestEntity(OMElement element, boolean chunked,
+                                 MessageContext msgCtxt,
+                                 String charSetEncoding) {
+
+            this.element = element;
+            this.chunked = chunked;
+            this.msgCtxt = msgCtxt;
+            this.charSetEnc = charSetEncoding;
+        }
+
+//        private OMElement removeNamespaces(OMElement elementWithNamespace) {
+//            OMElement elementWithoutNamespace = new OMElementImpl(elementWithNamespace.getLocalName(), null, null);
+//            elementWithoutNamespace.setText(elementWithNamespace.getText());
+//            Iterator iterator = elementWithoutNamespace.getChildElements();
+//            while (iterator.hasNext()) {
+//                OMElement ele = (OMElement) iterator.next();
+//                removeNamespaces(ele);
+//                elementWithoutNamespace.addChild(ele);
+//            }
+//             return elementWithoutNamespace;
+//        }
+
+        private void handleOMOutput(OutputStream out) throws XMLStreamException {
+            BadgerFishXMLStreamWriter jsonWriter = new BadgerFishXMLStreamWriter(new OutputStreamWriter(out));
+            element.serializeAndConsume(jsonWriter);
+            jsonWriter.writeEndDocument();
+        }
+
+        public byte[] writeBytes() throws AxisFault {
+            try {
+                ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
+                BadgerFishXMLStreamWriter jsonWriter = new BadgerFishXMLStreamWriter(new OutputStreamWriter(bytesOut));
+                format.setCharSetEncoding(charSetEnc);
+                element.serializeAndConsume(jsonWriter);
+                jsonWriter.writeEndDocument();
+
+                return bytesOut.toByteArray();
+
+            } catch (XMLStreamException e) {
+                throw new AxisFault(e);
+            } catch (FactoryConfigurationError e) {
+                throw new AxisFault(e);
+            }
+        }
+
+        public void writeRequest(OutputStream out) throws IOException {
+            try {
+                {
+                    if (chunked) {
+                        this.handleOMOutput(out);
+                    } else {
+                        if (bytes == null) {
+                            bytes = writeBytes();
+                        }
+                        out.write(bytes);
+                    }
+                }
+
+                out.flush();
+            } catch (XMLStreamException e) {
+                throw new AxisFault(e);
+            } catch (FactoryConfigurationError e) {
+                throw new AxisFault(e);
+            } catch (IOException e) {
+                throw new AxisFault(e);
+            }
+        }
+
+        public long getContentLength() {
+            try {
+                {
+                    if (chunked) {
+                        return -1;
+                    } else {
+                        if (bytes == null) {
+                            bytes = writeBytes();
+                        }
+                        return bytes.length;
+                    }
+                }
+            } catch (AxisFault e) {
+                return -1;
+            }
+        }
+
+        public String getContentType() {
+            String encoding = format.getCharSetEncoding();
+            String contentType;
+            if (msgCtxt.getProperty(Constants.Configuration.CONTENT_TYPE) != null) {
+                contentType = (String) msgCtxt.getProperty(Constants.Configuration.CONTENT_TYPE);
+            } else {
+                contentType = HTTPConstants.MEDIA_TYPE_APPLICATION_JSON;
+            }
+
+            if (encoding != null) {
+                contentType += "; charset=" + encoding;
+            }
+            return contentType;
+        }
+
+        public boolean isRepeatable() {
+            return true;
+        }
+    }
+
+}
Index: modules/kernel/src/org/apache/axis2/transport/http/HTTPConstants.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/HTTPConstants.java	(revision 489364)
+++ modules/kernel/src/org/apache/axis2/transport/http/HTTPConstants.java	(working copy)
@@ -31,6 +31,7 @@
     public static final String MEDIA_TYPE_TEXT_XML = "text/xml";
     public static final String MEDIA_TYPE_MULTIPART_RELATED = "multipart/related";
     public static final String MEDIA_TYPE_APPLICATION_XML = "application/xml";
+    public static final String MEDIA_TYPE_APPLICATION_JSON = "application/json";
     public static final String MEDIA_TYPE_APPLICATION_SOAP_XML = "application/soap+xml";
 
     /**
Index: modules/kernel/src/org/apache/axis2/transport/http/HTTPTransportUtils.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/HTTPTransportUtils.java	(revision 489364)
+++ modules/kernel/src/org/apache/axis2/transport/http/HTTPTransportUtils.java	(working copy)
@@ -55,10 +55,10 @@
 
 
     public static SOAPEnvelope createEnvelopeFromGetRequest(String requestUrl,
-                                   Map map,ConfigurationContext configCtx) throws AxisFault {
+                                                            Map map, ConfigurationContext configCtx) throws AxisFault {
         String[] values =
                 Utils.parseRequestURLForServiceAndOperation(requestUrl,
-                                                        configCtx.getServiceContextPath());
+                        configCtx.getServiceContextPath());
         if (values == null) {
             return new SOAP11Factory().getDefaultEnvelope();
         }
@@ -74,10 +74,10 @@
             SOAPEnvelope envelope = soapFactory.getDefaultEnvelope();
 //            OMNamespace omNs = soapFactory.createOMNamespace(values[0], "services");
             OMNamespace omNs = soapFactory.createOMNamespace(service.getSchematargetNamespace(),
-                                                             service.getSchematargetNamespacePrefix());
+                    service.getSchematargetNamespacePrefix());
             //OMNamespace defualtNs = new OMNamespaceImpl("", null, soapFactory);
             soapFactory.createOMNamespace(service.getSchematargetNamespace(),
-                                          service.getSchematargetNamespacePrefix());
+                    service.getSchematargetNamespacePrefix());
             OMElement opElement = soapFactory.createOMElement(operation, omNs);
             Iterator it = map.keySet().iterator();
 
@@ -112,7 +112,7 @@
         }
         return enableMTOM;
     }
-    
+
     public static boolean doWriteSwA(MessageContext msgContext) {
         boolean enableSwA = false;
 
@@ -141,7 +141,7 @@
         msgContext.setProperty(MessageContext.TRANSPORT_OUT, out);
         msgContext.setServerSide(true);
         SOAPEnvelope envelope = HTTPTransportUtils.createEnvelopeFromGetRequest(requestURI,
-                                                                                requestParameters, configurationContext);
+                requestParameters, configurationContext);
 
         if (envelope == null) {
             return false;
@@ -159,19 +159,19 @@
     private static final int VERSION_SOAP12 = 2;
 
     public static InvocationResponse processHTTPPostRequest(MessageContext msgContext, InputStream in,
-                                              OutputStream out, String contentType, String soapActionHeader, String requestURI)
+                                                            OutputStream out, String contentType, String soapActionHeader, String requestURI)
             throws AxisFault {
 
         int soapVersion = VERSION_UNKNOWN;
 
         InvocationResponse pi = InvocationResponse.CONTINUE;
-        
+
         try {
 
             Map headers = (Map) msgContext.getProperty(MessageContext.TRANSPORT_HEADERS);
             if (headers != null) {
                 if (HTTPConstants.COMPRESSION_GZIP.equals(headers.get(HTTPConstants.HEADER_CONTENT_ENCODING)) ||
-                    HTTPConstants.COMPRESSION_GZIP.equals(headers.get(HTTPConstants.HEADER_CONTENT_ENCODING.toLowerCase())))
+                        HTTPConstants.COMPRESSION_GZIP.equals(headers.get(HTTPConstants.HEADER_CONTENT_ENCODING.toLowerCase())))
                 {
                     in = new GZIPInputStream(in);
                 }
@@ -179,7 +179,7 @@
 
             // remove the starting and trailing " from the SOAP Action
             if ((soapActionHeader != null) && soapActionHeader.charAt(0) == '\"'
-                && soapActionHeader.endsWith("\"")) {
+                    && soapActionHeader.endsWith("\"")) {
                 soapActionHeader = soapActionHeader.substring(1, soapActionHeader.length() - 1);
             }
 
@@ -190,11 +190,11 @@
             msgContext.setServerSide(true);
 
             SOAPEnvelope envelope = null;
-            boolean isMIME=false;
+            boolean isMIME = false;
 
             // get the type of char encoding
             String charSetEnc = Builder.getCharSetEncoding(contentType);
-            if(charSetEnc == null){
+            if (charSetEnc == null) {
                 charSetEnc = MessageContext.DEFAULT_CHAR_SET_ENCODING;
             }
             // Setting the value in msgCtx
@@ -202,34 +202,34 @@
 
             String soapNS = SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI;
             if (contentType != null) {
-				if (contentType.indexOf(SOAP12Constants.SOAP_12_CONTENT_TYPE) > -1) {
-					soapVersion = VERSION_SOAP12;
-					soapNS = SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI;
-					processContentTypeForAction(contentType, msgContext);
-				} else if (contentType
-						.indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) > -1) {
-					soapVersion = VERSION_SOAP11;
-					soapNS = SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI;
-				}
-				if (JavaUtils.indexOfIgnoreCase(contentType,
-						HTTPConstants.HEADER_ACCEPT_MULTIPART_RELATED) > -1) {
-					// It is MIME (MTOM or SwA)
-					isMIME = true;
-				} else if (soapVersion == VERSION_SOAP11) {
-					// Deployment configuration parameter
-					Parameter enableREST = msgContext
-							.getParameter(Constants.Configuration.ENABLE_REST);
-					if ((soapActionHeader == null) && (enableREST != null)) {
-						if (Constants.VALUE_TRUE.equals(enableREST.getValue())) {
-							// If the content Type is text/xml (BTW which is the
-							// SOAP 1.1 Content type ) and the SOAP Action is
-							// absent it is rest !!
-							msgContext.setDoingREST(true);
-						}
-					}
-				}
-			}
-            envelope = TransportUtils.createSOAPMessage(msgContext,in,soapNS,isMIME,contentType,charSetEnc);
+                if (contentType.indexOf(SOAP12Constants.SOAP_12_CONTENT_TYPE) > -1) {
+                    soapVersion = VERSION_SOAP12;
+                    soapNS = SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI;
+                    processContentTypeForAction(contentType, msgContext);
+                } else if (contentType
+                        .indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) > -1) {
+                    soapVersion = VERSION_SOAP11;
+                    soapNS = SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI;
+                }
+                if (JavaUtils.indexOfIgnoreCase(contentType,
+                        HTTPConstants.HEADER_ACCEPT_MULTIPART_RELATED) > -1) {
+                    // It is MIME (MTOM or SwA)
+                    isMIME = true;
+                } else if (soapVersion == VERSION_SOAP11) {
+                    // Deployment configuration parameter
+                    Parameter enableREST = msgContext
+                            .getParameter(Constants.Configuration.ENABLE_REST);
+                    if ((soapActionHeader == null) && (enableREST != null)) {
+                        if (Constants.VALUE_TRUE.equals(enableREST.getValue())) {
+                            // If the content Type is text/xml (BTW which is the
+                            // SOAP 1.1 Content type ) and the SOAP Action is
+                            // absent it is rest !!
+                            msgContext.setDoingREST(true);
+                        }
+                    }
+                }
+            }
+            envelope = TransportUtils.createSOAPMessage(msgContext, in, soapNS, isMIME, contentType, charSetEnc);
             msgContext.setEnvelope(envelope);
             AxisEngine engine = new AxisEngine(msgContext.getConfigurationContext());
 
@@ -238,7 +238,7 @@
             } else {
                 pi = engine.receive(msgContext);
             }
-            
+
             return pi;
         } catch (SOAPProcessingException e) {
             throw new AxisFault(e);
@@ -273,7 +273,7 @@
                 soapAction = transientString.substring(equal + 1, transientString.length());
             }
             if ((soapAction != null) && soapAction.startsWith("\"")
-                && soapAction.endsWith("\"")) {
+                    && soapAction.endsWith("\"")) {
                 soapAction = soapAction
                         .substring(1, soapAction.length() - 1);
             }
@@ -298,4 +298,22 @@
 
         return enableREST;
     }
+
+    public static boolean isDoingJSON(MessageContext msgContext) {
+        boolean enableJSON = false;
+
+        // check whether isDoingRest is already true in the message context
+        if (msgContext.isDoingJSON()) {
+            return true;
+        }
+
+        Object enableJSONProperty = msgContext.getProperty(Constants.Configuration.ENABLE_JSON);
+        if (enableJSONProperty != null) {
+            enableJSON = JavaUtils.isTrueExplicitly(enableJSONProperty);
+        }
+
+        msgContext.setDoingJSON(enableJSON);
+
+        return enableJSON;
+    }
 }
Index: modules/kernel/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java	(revision 489364)
+++ modules/kernel/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java	(working copy)
@@ -36,12 +36,14 @@
 import org.apache.commons.httpclient.HttpMethod;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.codehaus.jettison.badgerfish.BadgerFishXMLStreamWriter;
 
 import javax.xml.stream.FactoryConfigurationError;
 import javax.xml.stream.XMLStreamException;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.StringWriter;
+import java.io.OutputStreamWriter;
 import java.net.MalformedURLException;
 import java.net.URL;
 
@@ -163,6 +165,9 @@
             msgContext.setDoingMTOM(HTTPTransportUtils.doWriteMTOM(msgContext));
             msgContext.setDoingSwA(HTTPTransportUtils.doWriteSwA(msgContext));
             msgContext.setDoingREST(HTTPTransportUtils.isDoingREST(msgContext));
+
+            msgContext.setDoingJSON(HTTPTransportUtils.isDoingJSON(msgContext));
+
             format.setSOAP11(msgContext.isSOAP11());
             format.setDoOptimize(msgContext.isDoingMTOM());
             format.setDoingSWA(msgContext.isDoingSwA());
@@ -193,7 +198,7 @@
             /**
              * Figuringout the REST properties/parameters
              */
-            if (msgContext.isDoingREST()) {
+            if (msgContext.isDoingREST() || msgContext.isDoingJSON()) {
                 dataOut = msgContext.getEnvelope().getBody().getFirstElement();
             } else {
                 dataOut = msgContext.getEnvelope();
@@ -249,12 +254,13 @@
                     contentType = (String) contentTypeObject;
                 } else if (msgContext.isDoingREST() && !(format.isOptimized())) {
                     contentType = HTTPConstants.MEDIA_TYPE_APPLICATION_XML;
+                } else if (msgContext.isDoingJSON()) {
+                    contentType = HTTPConstants.MEDIA_TYPE_APPLICATION_JSON;
                 } else {
                     contentType = format.getContentType();
                     format.setSOAP11(msgContext.isSOAP11());
                 }
 
-
                 String encoding = contentType + "; charset="
                         + format.getCharSetEncoding();
 
@@ -272,6 +278,10 @@
             dataOut.serializeAndConsume(bufferedSOAPBody, format);
             MIMEOutputUtils.writeSOAPWithAttachmentsMessage(bufferedSOAPBody,
                     out, msgContext.getAttachmentMap(), format);
+        } else if (msgContext.isDoingJSON()) {
+            BadgerFishXMLStreamWriter jsonWriter = new BadgerFishXMLStreamWriter(new OutputStreamWriter(out));
+            dataOut.serializeAndConsume(jsonWriter);
+            jsonWriter.writeEndDocument();
         } else {
             dataOut.serializeAndConsume(out, format);
         }
@@ -282,6 +292,7 @@
                                         OMElement dataout,
                                         OMOutputFormat format)
             throws AxisFault {
+        
         try {
             URL url = new URL(toEPR.getAddress());
 
@@ -296,7 +307,8 @@
                 if ((soapActionString == null) || (soapActionString.length() == 0)) {
                     // now let's try to get WSA action
                     soapActionString = messageContext.getWSAAction();
-                    if (messageContext.getAxisOperation() != null && ((soapActionString == null) || (soapActionString.length() == 0))) {
+                    if (messageContext.getAxisOperation() != null && ((soapActionString == null) || (soapActionString.length() == 0)))
+                    {
                         // last option is to get it from the axis operation
                         soapActionString = messageContext.getAxisOperation().getSoapAction();
                     }
@@ -312,10 +324,12 @@
             // select the Message Sender depending on the REST status
             AbstractHTTPSender sender;
 
-            if (!messageContext.isDoingREST()) {
+            if (messageContext.isDoingREST()) {
+                sender = new RESTSender();
+            } else if (messageContext.isDoingJSON()) {
+                sender = new JSONSender();
+            } else {
                 sender = new SOAPOverHTTPSender();
-            } else {
-                sender = new RESTSender();
             }
             if (messageContext.getProperty(HTTPConstants.CHUNKED) != null) {
                 chunked = JavaUtils.isTrueExplicitly(messageContext.getProperty(
Index: modules/kernel/src/org/apache/axis2/transport/http/util/SOAPUtil.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/util/SOAPUtil.java	(revision 489364)
+++ modules/kernel/src/org/apache/axis2/transport/http/util/SOAPUtil.java	(working copy)
@@ -58,7 +58,7 @@
             if(server(msgContext) != null){
                 response.setHeader("Server",server(msgContext));
             }
-            String soapAction = request.getHeader(HTTPConstants.HEADER_SOAP_ACTION);
+            String soapAction = request.getHeader(HTTPConstants.HEADER_SOAP_ACTION);             
             HTTPTransportUtils.processHTTPPostRequest(msgContext,
                                                       request.getInputStream(),
                                                       response.getOutputStream(),
Index: modules/kernel/src/org/apache/axis2/transport/AbstractTransportSender.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/AbstractTransportSender.java	(revision 489364)
+++ modules/kernel/src/org/apache/axis2/transport/AbstractTransportSender.java	(working copy)
@@ -134,7 +134,7 @@
         SOAPEnvelope envelope = msgContext.getEnvelope();
         OMElement outputMessage = envelope;
 
-        if ((envelope != null) && msgContext.isDoingREST()) {
+        if ((envelope != null) && (msgContext.isDoingREST() || msgContext.isDoingJSON())) {
             outputMessage = envelope.getBody().getFirstElement();
         }
 
Index: modules/kernel/src/org/apache/axis2/transport/TransportUtils.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/TransportUtils.java	(revision 489364)
+++ modules/kernel/src/org/apache/axis2/transport/TransportUtils.java	(working copy)
@@ -43,122 +43,129 @@
 public class TransportUtils {
 
     public static SOAPEnvelope createSOAPMessage(MessageContext msgContext,
-			String soapNamespaceURI) throws AxisFault {
-		try {
-			InputStream inStream = (InputStream) msgContext
-					.getProperty(MessageContext.TRANSPORT_IN);
+                                                 String soapNamespaceURI) throws AxisFault {
+        try {
+            InputStream inStream = (InputStream) msgContext
+                    .getProperty(MessageContext.TRANSPORT_IN);
 
-			msgContext.setProperty(MessageContext.TRANSPORT_IN, null);
+            msgContext.setProperty(MessageContext.TRANSPORT_IN, null);
 
-			// this inputstram is set by the TransportSender represents a two
-			// way transport or by a Transport Recevier
-			if (inStream == null) {
-				throw new AxisFault(Messages.getMessage("inputstreamNull"));
-			}
-			Object contentType;
-			boolean isMIME = false;
-			OperationContext opContext = msgContext.getOperationContext();
+            // this inputstram is set by the TransportSender represents a two
+            // way transport or by a Transport Recevier
+            if (inStream == null) {
+                throw new AxisFault(Messages.getMessage("inputstreamNull"));
+            }
+            Object contentType;
+            boolean isMIME = false;
+            OperationContext opContext = msgContext.getOperationContext();
 
-			if (opContext != null) {
-				contentType = opContext
-						.getProperty(HTTPConstants.MTOM_RECEIVED_CONTENT_TYPE);
-			} else {
-				throw new AxisFault(Messages
-						.getMessage("cannotBeNullOperationContext"));
-			}
-			//TODO: we can improve this logic
-			if (contentType!=null){
-				isMIME=true;
-			}
-			
-			String charSetEnc = (String) msgContext
-					.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
-			if (charSetEnc == null) {
-				charSetEnc = (String) opContext
-						.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
-			}
-			if (charSetEnc == null) {
-				charSetEnc = MessageContext.DEFAULT_CHAR_SET_ENCODING;
-			}
-			return createSOAPMessage(msgContext, inStream, soapNamespaceURI,
-					isMIME, (String) contentType, charSetEnc);
-		} catch (AxisFault e) {
-			throw e;
-		} catch (OMException e) {
-			throw new AxisFault(e);
-		} catch (XMLStreamException e) {
-			throw new AxisFault(e);
-		} catch (FactoryConfigurationError e) {
-			throw new AxisFault(e);
-		}
-	}
+            if (opContext != null) {
 
+                contentType = opContext
+                        .getProperty(HTTPConstants.MTOM_RECEIVED_CONTENT_TYPE);
+            } else {
+                throw new AxisFault(Messages
+                        .getMessage("cannotBeNullOperationContext"));
+            }
+            //TODO: we can improve this logic
+            if (contentType != null) {
+                isMIME = true;
+            }
+
+            String charSetEnc = (String) msgContext
+                    .getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
+            if (charSetEnc == null) {
+                charSetEnc = (String) opContext
+                        .getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
+            }
+            if (charSetEnc == null) {
+                charSetEnc = MessageContext.DEFAULT_CHAR_SET_ENCODING;
+            }
+            return createSOAPMessage(msgContext, inStream, soapNamespaceURI,
+                    isMIME, (String) contentType, charSetEnc);
+        } catch (AxisFault e) {
+            throw e;
+        } catch (OMException e) {
+            throw new AxisFault(e);
+        } catch (XMLStreamException e) {
+            throw new AxisFault(e);
+        } catch (FactoryConfigurationError e) {
+            throw new AxisFault(e);
+        }
+    }
+
     /**
-	 * Objective of this method is to capture the SOAPEnvelope creation logic
-	 * and make it a common for all the transports and to in/out flows.
-	 * 
-	 * @param msgContext
-	 * @param inStream
-	 * @param soapNamespaceURI
-	 * @param isMIME
-	 * @param contentType
-	 * @param charSetEnc
-	 * @return the SOAPEnvelope
-	 * @throws AxisFault
-	 * @throws OMException
-	 * @throws XMLStreamException
-	 * @throws FactoryConfigurationError
-	 */
+     * Objective of this method is to capture the SOAPEnvelope creation logic
+     * and make it a common for all the transports and to in/out flows.
+     *
+     * @param msgContext
+     * @param inStream
+     * @param soapNamespaceURI
+     * @param isMIME
+     * @param contentType
+     * @param charSetEnc
+     * @return the SOAPEnvelope
+     * @throws AxisFault
+     * @throws OMException
+     * @throws XMLStreamException
+     * @throws FactoryConfigurationError
+     */
     public static SOAPEnvelope createSOAPMessage(MessageContext msgContext,
-			InputStream inStream, String soapNamespaceURI, boolean isMIME,
-			String contentType, String charSetEnc) throws AxisFault,
-			OMException, XMLStreamException, FactoryConfigurationError {
-    	StAXBuilder builder;
-		OMElement documentElement;
-		if (isMIME) {
-			msgContext.setDoingMTOM(true);
-			builder = Builder.getAttachmentsBuilder(
-					msgContext, inStream, (String) contentType, !(msgContext
-							.isDoingREST()));
-		} else if (msgContext.isDoingREST()) {
-			builder = Builder.getPOXBuilder(inStream,
-					charSetEnc, soapNamespaceURI);
-		} else {
-			builder = Builder.getBuilderFromSelector(contentType, msgContext);
-			if (builder == null) {
-				builder = Builder.getBuilder(inStream, charSetEnc,
-						soapNamespaceURI);
-			}
-		}
-		
-		documentElement = builder.getDocumentElement();
-		SOAPEnvelope envelope;
-		//Check whether we have received a SOAPEnvelope or not
-		if (documentElement instanceof SOAPEnvelope) {
-			envelope = (SOAPEnvelope) documentElement;
-		} else {
-			//If it is not a SOAPEnvelope we wrap that with a fake SOAPEnvelope.
-			SOAPFactory soapFactory = new SOAP11Factory();
-			SOAPEnvelope intermediateEnvelope = soapFactory
-					.getDefaultEnvelope();
-			intermediateEnvelope.getBody().addChild(
-					builder.getDocumentElement());
+                                                 InputStream inStream, String soapNamespaceURI, boolean isMIME,
+                                                 String contentType, String charSetEnc) throws AxisFault,
+            OMException, XMLStreamException, FactoryConfigurationError {
+        StAXBuilder builder;
+        OMElement documentElement;
+        if (isMIME) {
+            msgContext.setDoingMTOM(true);
+            builder = Builder.getAttachmentsBuilder(
+                    msgContext, inStream, (String) contentType, !(msgContext
+                    .isDoingREST()));
+        } else if (msgContext.isDoingREST()) {
+            builder = Builder.getPOXBuilder(inStream,
+                    charSetEnc, soapNamespaceURI);
+        } else {
 
-			// We now have the message inside an envelope. However, this is
-			// only an OM; We need to build a SOAP model from it.
-			builder = new StAXSOAPModelBuilder(intermediateEnvelope
-					.getXMLStreamReader(), soapNamespaceURI);
-			envelope = (SOAPEnvelope) builder.getDocumentElement();
-		}
+            //TODO - this is not the correct way. check why content type get null
 
-		String charsetEncoding = builder.getDocument().getCharsetEncoding();
-		if ((charsetEncoding != null)
-				&& !"".equals(charsetEncoding)
-				&& (msgContext.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING) != null)
-				&& !charsetEncoding.equalsIgnoreCase((String) msgContext
-								.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING))) {
-			String faultCode;
+            if (msgContext.isDoingJSON() && contentType == null) {
+                contentType = HTTPConstants.MEDIA_TYPE_APPLICATION_JSON;
+            }
+            builder = Builder.getBuilderFromSelector(contentType, msgContext, inStream);
+            if (builder == null) {
+                builder = Builder.getBuilder(inStream, charSetEnc,
+                        soapNamespaceURI);
+            }
+        }
 
+        documentElement = builder.getDocumentElement();
+        SOAPEnvelope envelope;
+        //Check whether we have received a SOAPEnvelope or not
+        if (documentElement instanceof SOAPEnvelope) {
+            envelope = (SOAPEnvelope) documentElement;
+        } else {
+            //If it is not a SOAPEnvelope we wrap that with a fake SOAPEnvelope.
+            SOAPFactory soapFactory = new SOAP11Factory();
+            SOAPEnvelope intermediateEnvelope = soapFactory
+                    .getDefaultEnvelope();
+            intermediateEnvelope.getBody().addChild(
+                    builder.getDocumentElement());
+
+            // We now have the message inside an envelope. However, this is
+            // only an OM; We need to build a SOAP model from it.
+            builder = new StAXSOAPModelBuilder(intermediateEnvelope
+                    .getXMLStreamReader(), soapNamespaceURI);
+            envelope = (SOAPEnvelope) builder.getDocumentElement();
+        }
+
+        String charsetEncoding = builder.getDocument().getCharsetEncoding();
+        if ((charsetEncoding != null)
+                && !"".equals(charsetEncoding)
+                && (msgContext.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING) != null)
+                && !charsetEncoding.equalsIgnoreCase((String) msgContext
+                .getProperty(Constants.Configuration.CHARACTER_SET_ENCODING))) {
+            String faultCode;
+
             if (SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals(
                     envelope.getNamespace().getNamespaceURI())) {
                 faultCode = SOAP12Constants.FAULT_CODE_SENDER;
@@ -168,8 +175,8 @@
 
             throw new AxisFault(
                     "Character Set Encoding from " + "transport information do not match with "
-                    + "character set encoding in the received SOAP message", faultCode);
+                            + "character set encoding in the received SOAP message", faultCode);
         }
-		return envelope;
-	}
+        return envelope;
+    }
 }
Index: modules/kernel/src/org/apache/axis2/Constants.java
===================================================================
--- modules/kernel/src/org/apache/axis2/Constants.java	(revision 489364)
+++ modules/kernel/src/org/apache/axis2/Constants.java	(working copy)
@@ -233,6 +233,7 @@
 
     public static interface Configuration {
         public static final String ENABLE_REST = "enableREST";
+        public static final String ENABLE_JSON = "enableJSON";
         public static final String ENABLE_REST_THROUGH_GET = "restThroughGet";
 
         // globally enable MTOM
Index: modules/kernel/src/org/apache/axis2/json/JSONDataSource.java
===================================================================
--- modules/kernel/src/org/apache/axis2/json/JSONDataSource.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/json/JSONDataSource.java	(revision 0)
@@ -0,0 +1,143 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.json;
+
+import org.apache.axiom.om.OMDataSource;
+import org.apache.axiom.om.OMOutputFormat;
+import org.apache.axiom.om.OMException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+import org.json.JSONException;
+import org.codehaus.jettison.badgerfish.BadgerFishXMLInputFactory;
+
+import javax.xml.stream.XMLStreamReader;
+import javax.xml.stream.XMLStreamConstants;
+import java.io.*;
+
+public class JSONDataSource implements OMDataSource {
+
+    private InputStream jsonInputStream;
+    private String jsonString;
+    private boolean isRead = false;
+    private String localName;
+
+    public JSONDataSource(InputStream jsonInputStream, String localName) {
+        this.jsonInputStream = jsonInputStream;
+        this.localName = localName;
+    }
+
+    //gives json
+    public void serialize(OutputStream outputStream, OMOutputFormat omOutputFormat) throws javax.xml.stream.XMLStreamException {
+        OutputStreamWriter writer = new OutputStreamWriter(outputStream);
+        serialize(writer, omOutputFormat);
+        try {
+            writer.flush();
+        } catch (IOException e) {
+            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+        }
+    }
+
+    //gives json
+    public void serialize(Writer writer, OMOutputFormat omOutputFormat) throws javax.xml.stream.XMLStreamException {
+        try {
+            JSONTokener jsonTokener = new JSONTokener("{" + localName + ":" + this.getJSONString());
+            JSONObject jsonObject = new JSONObject(jsonTokener);
+            jsonObject.write(writer);
+        } catch (JSONException e) {
+            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+        }
+    }
+
+    //gives xml
+    public void serialize(javax.xml.stream.XMLStreamWriter xmlStreamWriter) throws javax.xml.stream.XMLStreamException {
+        XMLStreamReader reader = getReader();
+        xmlStreamWriter.writeStartDocument();
+        while (reader.hasNext()) {
+            int x = reader.next();
+            switch (x) {
+                case XMLStreamConstants.START_ELEMENT:
+                    xmlStreamWriter.writeStartElement(reader.getPrefix(), reader.getLocalName(), reader.getNamespaceURI(reader.getPrefix()));
+                    int namespaceCount = reader.getNamespaceCount();
+                    for (int i = namespaceCount - 1; i >= 0; i--) {
+                        xmlStreamWriter.writeNamespace(reader.getNamespacePrefix(i), reader.getNamespaceURI(i));
+                    }
+                    int attributeCount = reader.getAttributeCount();
+                    for (int i = 0; i < attributeCount; i++) {
+                        xmlStreamWriter.writeAttribute(reader.getAttributePrefix(i),
+                                reader.getAttributeNamespace(i), reader.getAttributeLocalName(i),
+                                reader.getAttributeValue(i));
+                    }
+                    break;
+                case XMLStreamConstants.START_DOCUMENT:
+                    break;
+                case XMLStreamConstants.CHARACTERS:
+                    xmlStreamWriter.writeCharacters(reader.getText());
+                    break;
+                case XMLStreamConstants.CDATA:
+                    xmlStreamWriter.writeCData(reader.getText());
+                    break;
+                case XMLStreamConstants.END_ELEMENT:
+                    xmlStreamWriter.writeEndElement();
+                    break;
+                case XMLStreamConstants.END_DOCUMENT:
+                    xmlStreamWriter.writeEndDocument();
+                    break;
+                case XMLStreamConstants.SPACE:
+                    break;
+                case XMLStreamConstants.COMMENT:
+                    xmlStreamWriter.writeComment(reader.getText());
+                    break;
+                case XMLStreamConstants.DTD:
+                    xmlStreamWriter.writeDTD(reader.getText());
+                    break;
+                case XMLStreamConstants.PROCESSING_INSTRUCTION:
+                    xmlStreamWriter.writeProcessingInstruction(reader.getPITarget(), reader.getPIData());
+                    break;
+                case XMLStreamConstants.ENTITY_REFERENCE:
+                    xmlStreamWriter.writeEntityRef(reader.getLocalName());
+                    break;
+                default :
+                    throw new OMException();
+            }
+        }
+        xmlStreamWriter.writeEndDocument();
+    }
+
+    public javax.xml.stream.XMLStreamReader getReader() throws javax.xml.stream.XMLStreamException {
+        BadgerFishXMLInputFactory inputFactory = new BadgerFishXMLInputFactory();
+        return inputFactory.createXMLStreamReader(new JSONTokener("{" + localName + ":" + this.getJSONString()));
+    }
+
+    private String getJSONString() {
+        if (isRead) {
+            return jsonString;
+        } else {
+            try {
+                char temp = (char) jsonInputStream.read();
+                jsonString = "";
+                while ((int) temp != 65535) {
+                    jsonString += temp;
+                    temp = (char) jsonInputStream.read();
+                }
+            } catch (IOException e) {
+                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+            }
+            isRead = true;
+            return jsonString;
+        }
+    }
+}

Property changes on: modules/kernel/src/org/apache/axis2/json/JSONDataSource.java
___________________________________________________________________
Name: svn:executable
   + *

Index: modules/kernel/src/org/apache/axis2/json/JSONOMBuilder.java
===================================================================
--- modules/kernel/src/org/apache/axis2/json/JSONOMBuilder.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/json/JSONOMBuilder.java	(revision 0)
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.json;
+
+import org.apache.axiom.om.impl.llom.OMSourcedElementImpl;
+import org.apache.axiom.om.impl.llom.factory.OMLinkedListImplFactory;
+import org.apache.axiom.om.impl.OMNamespaceImpl;
+import org.apache.axiom.om.impl.builder.StAXBuilder;
+import org.apache.axiom.om.*;
+//import org.apache.axis2.i18n.Messages;
+
+import java.io.InputStream;
+import java.io.IOException;
+
+
+public class JSONOMBuilder extends StAXBuilder {
+    InputStream jsonInputStream = null;
+    String localName = null;
+
+    public JSONOMBuilder(InputStream inputStream) {
+        super(null);
+        this.jsonInputStream = inputStream;
+    }
+
+    public OMElement getDocumentElement() {
+
+        OMLinkedListImplFactory factory = new OMLinkedListImplFactory();
+        OMNamespace ns = new OMNamespaceImpl("", "");
+        if (localName == null) {
+            localName = getLocalName();
+        }
+        JSONDataSource jsonDataSource = new JSONDataSource(this.jsonInputStream, localName);
+        return new OMSourcedElementImpl(localName.substring(1, localName.length() - 1), ns, factory, jsonDataSource);
+    }
+
+    private String getLocalName() {
+        String localName = "";
+        try {
+            char temp = (char) jsonInputStream.read();
+            while (temp != ':') {
+                if (temp != '{' && temp != ' ') {
+                    localName += temp;
+                }
+                temp = (char) jsonInputStream.read();
+            }
+        } catch (IOException e) {
+            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+        }
+        return localName.trim();
+    }
+
+    protected void processNamespaceData(OMElement omElement) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    protected OMNode createOMElement() throws OMException {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    public int next() throws OMException {
+        return 0;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+}
+
+//
+//    public SOAPEnvelope getSOAPEnvelope(String soapVersionURI) {
+//        SOAPFactory factory = getFactory(soapVersionURI);
+//        SOAPEnvelope envelope = factory.getDefaultEnvelope();
+//        envelope.getBody().addChild(this.getDocumentElement());
+//        return envelope;
+//    }
+
+//    protected static SOAPFactory getFactory(String soapVersionURI) {
+//
+//        if (SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals(soapVersionURI)) {
+//            return OMAbstractFactory.getSOAP11Factory();
+//        } else if (SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals(soapVersionURI)) {
+//            return OMAbstractFactory.getSOAP12Factory();
+//        } else {
+//            throw new RuntimeException(Messages.getMessage("unknownsoapversion"));
+//        }
+//    }
+
+//}
Index: modules/kernel/src/org/apache/axis2/util/MessageContextBuilder.java
===================================================================
--- modules/kernel/src/org/apache/axis2/util/MessageContextBuilder.java	(revision 489364)
+++ modules/kernel/src/org/apache/axis2/util/MessageContextBuilder.java	(working copy)
@@ -139,6 +139,7 @@
         newmsgCtx.setAxisMessage(ao.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));
 
         newmsgCtx.setDoingMTOM(inMessageContext.isDoingMTOM());
+        newmsgCtx.setDoingJSON(inMessageContext.isDoingJSON());
         newmsgCtx.setServerSide(inMessageContext.isServerSide());
         newmsgCtx.setServiceGroupContextId(inMessageContext.getServiceGroupContextId());
 
Index: modules/kernel/src/org/apache/axis2/util/Builder.java
===================================================================
--- modules/kernel/src/org/apache/axis2/util/Builder.java	(revision 489364)
+++ modules/kernel/src/org/apache/axis2/util/Builder.java	(working copy)
@@ -6,14 +6,12 @@
 import java.io.InputStreamReader;
 import java.io.PushbackInputStream;
 import java.io.Reader;
-import java.util.HashMap;
 
 import javax.xml.parsers.FactoryConfigurationError;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 
 import org.apache.axiom.attachments.Attachments;
-import org.apache.axiom.om.OMAbstractFactory;
 import org.apache.axiom.om.OMException;
 import org.apache.axiom.om.impl.MTOMConstants;
 import org.apache.axiom.om.impl.builder.StAXBuilder;
@@ -29,6 +27,7 @@
 import org.apache.axiom.soap.impl.llom.soap11.SOAP11Factory;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
+import org.apache.axis2.json.JSONOMBuilder;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.description.Parameter;
 import org.apache.axis2.transport.http.HTTPConstants;
@@ -48,13 +47,13 @@
     }
 
     /**
-	 * Use the BOM Mark to identify the encoding to be used. Fall back to
-	 * default encoding specified
-	 *
-	 * @param is
-	 * @param charSetEncoding
-	 * @throws java.io.IOException
-	 */
+     * Use the BOM Mark to identify the encoding to be used. Fall back to
+     * default encoding specified
+     *
+     * @param is
+     * @param charSetEncoding
+     * @throws java.io.IOException
+     */
     public static Reader getReader(InputStream is, String charSetEncoding) throws IOException {
         PushbackInputStream is2 = new PushbackInputStream(is, BOM_SIZE);
         String encoding;
@@ -97,7 +96,7 @@
 
     public static String getEnvelopeNamespace(String contentType) {
         String soapNS = SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI;
-        if(contentType != null) {
+        if (contentType != null) {
             if (contentType.indexOf(SOAP12Constants.SOAP_12_CONTENT_TYPE) > -1) {
                 // it is SOAP 1.2
                 soapNS = SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI;
@@ -144,7 +143,7 @@
         }
 
         // There might be "" around the value - if so remove them
-        if(value.indexOf('\"')!=-1){
+        if (value.indexOf('\"') != -1) {
             value = value.replaceAll("\"", "");
         }
 
@@ -152,67 +151,66 @@
     }
 
     public static StAXBuilder getAttachmentsBuilder(MessageContext msgContext,
-			InputStream inStream, String contentTypeString, boolean isSOAP)
-			throws OMException, XMLStreamException, FactoryConfigurationError {
-		StAXBuilder builder = null;
-		XMLStreamReader streamReader;
+                                                    InputStream inStream, String contentTypeString, boolean isSOAP)
+            throws OMException, XMLStreamException, FactoryConfigurationError {
+        StAXBuilder builder = null;
+        XMLStreamReader streamReader;
 
         Attachments attachments = createAttachment(msgContext, inStream, contentTypeString);
-		String charSetEncoding = getCharSetEncoding(attachments.getSOAPPartContentType());
+        String charSetEncoding = getCharSetEncoding(attachments.getSOAPPartContentType());
 
-		if ((charSetEncoding == null)
-				|| "null".equalsIgnoreCase(charSetEncoding)) {
-			charSetEncoding = MessageContext.UTF_8;
-		}
-		msgContext.setProperty(Constants.Configuration.CHARACTER_SET_ENCODING,
-				charSetEncoding);
+        if ((charSetEncoding == null)
+                || "null".equalsIgnoreCase(charSetEncoding)) {
+            charSetEncoding = MessageContext.UTF_8;
+        }
+        msgContext.setProperty(Constants.Configuration.CHARACTER_SET_ENCODING,
+                charSetEncoding);
 
-		try {
-			streamReader = StAXUtils.createXMLStreamReader(getReader(
-					attachments.getSOAPPartInputStream(), charSetEncoding));
-		} catch (IOException e) {
-			throw new XMLStreamException(e);
-		}
+        try {
+            streamReader = StAXUtils.createXMLStreamReader(getReader(
+                    attachments.getSOAPPartInputStream(), charSetEncoding));
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
 
-		
-		//  Put a reference to Attachments Map in to the message context For
-		// backword compatibility with Axis2 1.0 
-		msgContext.setProperty(MTOMConstants.ATTACHMENTS, attachments);
+        //  Put a reference to Attachments Map in to the message context For
+        // backword compatibility with Axis2 1.0
+        msgContext.setProperty(MTOMConstants.ATTACHMENTS, attachments);
 
-		// Setting the Attachments map to new SwA API
-		msgContext.setAttachmentMap(attachments);
+        // Setting the Attachments map to new SwA API
+        msgContext.setAttachmentMap(attachments);
 
-		String soapEnvelopeNamespaceURI = getEnvelopeNamespace(contentTypeString);
+        String soapEnvelopeNamespaceURI = getEnvelopeNamespace(contentTypeString);
 
-		if (isSOAP) {
-			if (attachments.getAttachmentSpecType().equals(
-					MTOMConstants.MTOM_TYPE)) {
-				//Creates the MTOM specific MTOMStAXSOAPModelBuilder
-				builder = new MTOMStAXSOAPModelBuilder(streamReader,
-						attachments, soapEnvelopeNamespaceURI);
+        if (isSOAP) {
+            if (attachments.getAttachmentSpecType().equals(
+                    MTOMConstants.MTOM_TYPE)) {
+                //Creates the MTOM specific MTOMStAXSOAPModelBuilder
+                builder = new MTOMStAXSOAPModelBuilder(streamReader,
+                        attachments, soapEnvelopeNamespaceURI);
 
-			} else if (attachments.getAttachmentSpecType().equals(
-					MTOMConstants.SWA_TYPE)) {
-				builder = new StAXSOAPModelBuilder(streamReader,
-						soapEnvelopeNamespaceURI);
-			}
-		}
-		// To handle REST XOP case
-		else {
-			if (attachments.getAttachmentSpecType().equals(
-					MTOMConstants.MTOM_TYPE)) {
-				XOPAwareStAXOMBuilder stAXOMBuilder = new XOPAwareStAXOMBuilder(
-						streamReader, attachments);
-				builder = stAXOMBuilder;
+            } else if (attachments.getAttachmentSpecType().equals(
+                    MTOMConstants.SWA_TYPE)) {
+                builder = new StAXSOAPModelBuilder(streamReader,
+                        soapEnvelopeNamespaceURI);
+            }
+        }
+        // To handle REST XOP case
+        else {
+            if (attachments.getAttachmentSpecType().equals(
+                    MTOMConstants.MTOM_TYPE)) {
+                XOPAwareStAXOMBuilder stAXOMBuilder = new XOPAwareStAXOMBuilder(
+                        streamReader, attachments);
+                builder = stAXOMBuilder;
 
-			} else if (attachments.getAttachmentSpecType().equals(
-					MTOMConstants.SWA_TYPE)) {
-				builder = new StAXOMBuilder(streamReader);
-			}
-		}
+            } else if (attachments.getAttachmentSpecType().equals(
+                    MTOMConstants.SWA_TYPE)) {
+                builder = new StAXOMBuilder(streamReader);
+            }
+        }
 
-		return builder;
-	}
+        return builder;
+    }
 
     private static Attachments createAttachment(MessageContext msgContext, InputStream inStream, String contentTypeString) {
         Object cacheAttachmentProperty = msgContext
@@ -280,12 +278,12 @@
     public static StAXBuilder getBuilder(InputStream inStream, String charSetEnc, String soapNamespaceURI) throws XMLStreamException {
         StAXBuilder builder;
         XMLStreamReader xmlreader;
-        if(charSetEnc == null) {
+        if (charSetEnc == null) {
             xmlreader = StAXUtils.createXMLStreamReader(inStream);
         } else {
             xmlreader = StAXUtils.createXMLStreamReader(inStream, charSetEnc);
         }
-        if(soapNamespaceURI == null) {
+        if (soapNamespaceURI == null) {
             builder = new StAXOMBuilder(xmlreader);
         } else {
             builder = new StAXSOAPModelBuilder(xmlreader, soapNamespaceURI);
@@ -299,40 +297,48 @@
         builder = new StAXOMBuilder(soapFactory, xmlreader);
         return builder;
     }
-    
+
     /**
      * Initial work for a builder selector which selects the builder for a given message format based on the the content type of the recieved message.
      * content-type to builder mapping can be specified through the Axis2.xml.
+     *
      * @param contentType
      * @param msgContext
      * @return the builder registered against the given content-type
      * @throws AxisFault
      */
-    public static StAXBuilder getBuilderFromSelector(String contentType, MessageContext msgContext) throws AxisFault {
-    	HashMap map= (HashMap)msgContext.getConfigurationContext().getProperty(Constants.BUILDER_SELECTOR);
-    	String builderClassName=null;
-    	
-    	if(map!=null)
-    	builderClassName = (String)map.get(contentType);
-  
-    	if (builderClassName==null)
-    	{
-    		//fall back if there aren't any builders registered for this content type
-    		return null;
-    	}
-    	try {
-			Class builderClass = Loader.loadClass(builderClassName);
-			StAXBuilder builder = (StAXBuilder) builderClass.newInstance();
-			builder.setOMBuilderFactory(OMAbstractFactory.getOMFactory());
-			return builder;
-		} catch (ClassNotFoundException e) {
-			throw new AxisFault("Specified Builder class cannot be found.", e);
-		} catch (InstantiationException e) {
-			throw new AxisFault(
-					"Cannot instantiate the specified Builder Class.", e);
-		} catch (IllegalAccessException e) {
-			throw new AxisFault(
-					"Cannot instantiate the specified Builder Class.", e);
-		}
-	}
+    public static StAXBuilder getBuilderFromSelector(String contentType, MessageContext msgContext, InputStream in) throws AxisFault {
+//    	HashMap map= (HashMap)msgContext.getConfigurationContext().getProperty(Constants.BUILDER_SELECTOR);
+//    	String builderClassName=null;
+//
+//    	if(map!=null)
+//    	builderClassName = (String)map.get(contentType);
+//
+//    	if (builderClassName==null)
+//    	{
+//    		//fall back if there aren't any builders registered for this content type
+//    		return null;
+//    	}
+//    	try {
+//			Class builderClass = Loader.loadClass(builderClassName);
+//			StAXBuilder builder = (StAXBuilder) builderClass.newInstance();
+//			builder.setOMBuilderFactory(OMAbstractFactory.getOMFactory());
+//			return builder;
+//		} catch (ClassNotFoundException e) {
+//			throw new AxisFault("Specified Builder class cannot be found.", e);
+//		} catch (InstantiationException e) {
+//			throw new AxisFault(
+//					"Cannot instantiate the specified Builder Class.", e);
+//		} catch (IllegalAccessException e) {
+//			throw new AxisFault(
+//					"Cannot instantiate the specified Builder Class.", e);
+//		}         
+
+        if (contentType.indexOf(HTTPConstants.MEDIA_TYPE_APPLICATION_JSON) > -1) {
+            msgContext.setDoingJSON(true);
+            return new JSONOMBuilder(in);
+        } else {
+            return null;
+        }
+    }
 }

Index: modules/integration/test/org/apache/axis2/engine/util/TestConstants.java
===================================================================
--- modules/integration/test/org/apache/axis2/engine/util/TestConstants.java	(revision 489364)
+++ modules/integration/test/org/apache/axis2/engine/util/TestConstants.java	(working copy)
@@ -27,12 +27,11 @@
 public interface TestConstants {
     public static final EndpointReference targetEPR = new EndpointReference(
             "http://127.0.0.1:" + (UtilServer.TESTING_PORT)
-//            "http://127.0.0.1:" + 5556
                     + "/axis2/services/EchoXMLService/echoOMElement");
 
     public static final QName serviceName = new QName("EchoXMLService");
 
     public static final QName operationName = new QName("echoOMElement");
-    
+
     public static final QName swaServiceName = new QName("EchoSwAService");
 }
Index: modules/integration/test/org/apache/axis2/json/JSONTestConstants.java
===================================================================
--- modules/integration/test/org/apache/axis2/json/JSONTestConstants.java	(revision 0)
+++ modules/integration/test/org/apache/axis2/json/JSONTestConstants.java	(revision 0)
@@ -0,0 +1,36 @@
+/*
+* Copyright 2004,2005 The Apache Software Foundation.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.apache.axis2.json;
+
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.integration.UtilServer;
+
+import javax.xml.namespace.QName;
+
+public interface JSONTestConstants {
+
+    public static final EndpointReference targetEPR = new EndpointReference(
+            "http://127.0.0.1:" + (UtilServer.TESTING_PORT)
+//            "http://127.0.0.1:" + 8075
+                    + "/axis2/services/EchoXMLService/echoOM");
+
+    public static final QName serviceName = new QName("EchoXMLService");
+
+    public static final QName operationName = new QName("echoOM");
+
+    public static final QName swaServiceName = new QName("EchoSwAService");
+}
Index: modules/integration/test/org/apache/axis2/json/JSONIntegrationTest.java
===================================================================
--- modules/integration/test/org/apache/axis2/json/JSONIntegrationTest.java	(revision 0)
+++ modules/integration/test/org/apache/axis2/json/JSONIntegrationTest.java	(revision 0)
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.json;
+
+
+import junit.framework.Test;
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.OMFactory;
+import org.apache.axiom.om.OMNamespace;
+
+import org.apache.axis2.Constants;
+import org.apache.axis2.json.JSONTestConstants;
+import org.apache.axis2.client.Options;
+import org.apache.axis2.client.ServiceClient;
+
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.ConfigurationContextFactory;
+
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.engine.Echo;
+
+import org.apache.axis2.integration.UtilServer;
+import org.apache.axis2.integration.UtilServerBasedTestCase;
+import org.apache.axis2.util.Utils;
+
+
+public class JSONIntegrationTest extends UtilServerBasedTestCase implements JSONTestConstants {
+
+    private AxisService service;
+
+    private String expectedString;
+
+    public JSONIntegrationTest() {
+        super(JSONIntegrationTest.class.getName());
+    }
+
+    public JSONIntegrationTest(String testName) {
+        super(testName);
+    }
+
+    public static Test suite() {
+        return getTestSetup(new TestSuite(JSONIntegrationTest.class));
+    }
+
+    protected void setUp() throws Exception {
+        service = Utils.createSimpleService(serviceName, Echo.class.getName(),
+                operationName);
+        UtilServer.deployService(service);
+    }
+
+    protected void tearDown() throws Exception {
+        UtilServer.unDeployService(serviceName);
+        UtilServer.unDeployClientService();
+    }
+
+    protected OMElement createEnvelope() throws Exception {
+        OMFactory fac = OMAbstractFactory.getOMFactory();
+        OMNamespace omNs = fac.createOMNamespace("", "");
+        OMElement rpcWrapEle = fac.createOMElement("echoOM", omNs);
+        OMElement data = fac.createOMElement("data", omNs);
+        expectedString = "my json string";
+        data.setText(expectedString);
+        rpcWrapEle.addChild(data);
+        return rpcWrapEle;
+
+    }
+
+
+    public void testEchoOMWithJSON() throws Exception {
+        OMElement payload = createEnvelope();
+        Options options = new Options();
+        options.setTo(targetEPR);
+
+        options.setProperty(Constants.Configuration.ENABLE_JSON, Constants.VALUE_TRUE);
+        options.setTransportInProtocol(Constants.TRANSPORT_HTTP);
+        ConfigurationContext configContext =
+                ConfigurationContextFactory.createConfigurationContextFromFileSystem("target/test-resources/integrationRepo", null);
+
+        ServiceClient sender = new ServiceClient(configContext, null);
+        options.setAction(Constants.AXIS2_NAMESPACE_URI + "/" + operationName.getLocalPart());
+        sender.setOptions(options);
+        options.setTo(targetEPR);
+        OMElement result = sender.sendReceive(payload);
+        OMElement ele = (OMElement) result.getFirstOMChild();
+        compareWithCreatedOMText(ele.getText());
+
+    }
+
+
+    protected void compareWithCreatedOMText(String response) {
+        TestCase.assertEquals(response, expectedString);
+    }
+
+
+}
\ No newline at end of file
Index: modules/saaj/src/org/apache/axis2/saaj/MessageFactoryImpl.java
===================================================================
--- modules/saaj/src/org/apache/axis2/saaj/MessageFactoryImpl.java	(revision 489364)
+++ modules/saaj/src/org/apache/axis2/saaj/MessageFactoryImpl.java	(working copy)
@@ -107,7 +107,8 @@
  */
 public class MessageFactoryImpl extends MessageFactory {
 
-    protected String soapVersion = SOAPConstants.SOAP_1_1_PROTOCOL;
+//    protected String soapVersion = SOAPConstants.SOAP_1_1_PROTOCOL;
+    protected String soapVersion = "SOAP 1.1 Protocol";
     /**
      * Creates a new <CODE>SOAPMessage</CODE> object with the
      * default <CODE>SOAPPart</CODE>, <CODE>SOAPEnvelope</CODE>,
@@ -129,7 +130,8 @@
      */
     public SOAPMessage createMessage() throws SOAPException {
         SOAPEnvelopeImpl soapEnvelope;
-        if (soapVersion.equals(SOAPConstants.SOAP_1_2_PROTOCOL)) {
+//        if (soapVersion.equals(SOAPConstants.SOAP_1_2_PROTOCOL)) {
+        if (soapVersion.equals("SOAP 1.2 Protocol")) {
             soapEnvelope =
                     new SOAPEnvelopeImpl((org.apache.axiom.soap.impl.dom.SOAPEnvelopeImpl)
                             new SOAP12Factory().getDefaultEnvelope());
