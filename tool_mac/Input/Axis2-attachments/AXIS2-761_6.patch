Index: org/apache/axis2/transport/http/SimpleHTTPServer.java
===================================================================
--- org/apache/axis2/transport/http/SimpleHTTPServer.java	(revision 595)
+++ org/apache/axis2/transport/http/SimpleHTTPServer.java	(working copy)
@@ -26,6 +26,7 @@
 import org.apache.axis2.description.TransportInDescription;
 import org.apache.axis2.engine.ListenerManager;
 import org.apache.axis2.transport.TransportListener;
+import org.apache.axis2.transport.http.server.HttpFactory;
 import org.apache.axis2.transport.http.server.HttpUtils;
 import org.apache.axis2.transport.http.server.SimpleHttpServer;
 import org.apache.axis2.util.OptionsParser;
@@ -40,60 +41,43 @@
 
 /**
  * This is a simple implementation of an HTTP server for processing
- * SOAP requests via Apache's xml-axis2.  This is not intended for production
- * use.  Its intended uses are for demos, debugging, and performance
- * profiling.
- * Note this classes uses static objects to provide a thread pool, so you should
- * not use multiple instances of this class in the same JVM/classloader unless
- * you want bad things to happen at shutdown.
+ * SOAP requests via Apache's xml-axis2.
+ * It can be used with no configuration other than the port to listen on, or it can
+ * be configured in detail with an HttpFactory.
  */
 public class SimpleHTTPServer implements TransportListener {
 
-    /**
-     * Field log
-     */
-	private static final Log log = LogFactory.getLog(SimpleHTTPServer.class);
+    private static final Log log = LogFactory.getLog(SimpleHTTPServer.class);
 
     /**
-     * Embedded commons http client based server
+     * Embedded commons http core based server
      */
     SimpleHttpServer embedded = null;
     int port = -1;
 
     public static int DEFAULT_PORT = 8080;
+
     private String hostAddress = null;
 
-    /**
-     * Field systemContext
-     */
     protected ConfigurationContext configurationContext;
+    protected HttpFactory httpFactory;
 
     public SimpleHTTPServer() {
     }
 
-    /**
-     * Constructor SimpleHTTPServer
-     *
-     * @param systemContext
-     * @param pool
-     */
-    public SimpleHTTPServer(ConfigurationContext systemContext, int port) throws AxisFault {
-        // If a threadPool is not passed-in the threadpool
-        // from the ConfigurationContext
-        // is used. This is a bit tricky, and might cause a
-        // thread lock. So use with
-        // caution
-        this.configurationContext = systemContext;
-        this.port = port;
-        ListenerManager listenerManager = configurationContext.getListenerManager();
-        TransportInDescription trsIn = new TransportInDescription(
-                new QName(Constants.TRANSPORT_HTTP));
-        trsIn.setReceiver(this);
-        if (listenerManager == null) {
-            listenerManager = new ListenerManager();
-            listenerManager.init(configurationContext);
-        }
-        listenerManager.addListener(trsIn, true);
+    /** Create a SimpleHTTPServer using default HttpFactory settings */
+    public SimpleHTTPServer(ConfigurationContext configurationContext, int port) throws AxisFault {
+        this(new HttpFactory(configurationContext, port));
+    }
+    
+    /** Create a configured SimpleHTTPServer */
+    public SimpleHTTPServer(HttpFactory httpFactory) throws AxisFault {
+        this.httpFactory = httpFactory;
+        this.configurationContext = httpFactory.getConfigurationContext();
+        this. port = httpFactory.getPort();
+        TransportInDescription httpDescription = new TransportInDescription(new QName(Constants.TRANSPORT_HTTP));
+        httpDescription.setReceiver(this);
+        httpFactory.getListenerManager().addListener(httpDescription, true);
     }
 
     /**
@@ -109,14 +93,18 @@
             this.configurationContext = axisConf;
 
             Parameter param = transprtIn.getParameter(PARAM_PORT);
-
-            if (param != null) {
+            if (param != null)
                 this.port = Integer.parseInt((String) param.getValue());
-            }
+            
+            if (httpFactory==null)
+                httpFactory = new HttpFactory(configurationContext, port);
+            
             param = transprtIn.getParameter(HOST_ADDRESS);
-            if (param != null) {
+            if (param != null)
                 hostAddress = ((String) param.getValue()).trim();
-            }
+            else
+                hostAddress = httpFactory.getHostAddress();
+            
         } catch (Exception e1) {
             throw new AxisFault(e1);
         }
@@ -175,7 +163,7 @@
      */
     public void start() throws AxisFault {
         try {
-            embedded = new SimpleHttpServer(new HTTPWorkerFactory(configurationContext), port);
+            embedded = new SimpleHttpServer(httpFactory, port);
             embedded.init();
             embedded.start();
         } catch (IOException e) {
@@ -199,6 +187,11 @@
             }
         }
     }
+    
+    /** Getter for httpFactory */
+    public HttpFactory getHttpFactory() {
+        return httpFactory;
+    }
 
     /**
      * Method getConfigurationContext
Index: org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java
===================================================================
--- org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java	(revision 595)
+++ org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java	(working copy)
@@ -44,7 +44,7 @@
 import org.apache.http.protocol.HttpContext;
 import org.apache.http.protocol.HttpService;
 
-public class DefaultHttpServiceProcessor extends HttpService implements IOProcessor {
+public class DefaultHttpServiceProcessor extends HttpServiceProcessor {
 
     private static final Log LOG = LogFactory.getLog(DefaultHttpServiceProcessor.class);
     private static final Log HEADERLOG = LogFactory.getLog("org.apache.axis2.transport.http.server.wire");
Index: org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java
===================================================================
--- org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java	(revision 595)
+++ org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java	(working copy)
@@ -53,6 +53,8 @@
     private final HttpParams params;
     private final List processors;
     
+    private HttpFactory httpFactory = null;
+    
     public DefaultHttpConnectionManager(
     		final Executor executor,
             final WorkerFactory workerfactory,
@@ -72,6 +74,12 @@
         this.params = params;
         this.processors = new LinkedList();
     }
+    
+    public DefaultHttpConnectionManager(final Executor executor, final WorkerFactory workerfactory, final HttpParams params, final HttpFactory httpFactory) {
+        this(executor, workerfactory, params);
+        this.httpFactory = httpFactory;
+    }
+
 
     private synchronized void cleanup() {
         for (Iterator i = this.processors.iterator(); i.hasNext(); ) {
@@ -113,8 +121,11 @@
             }
             
         };
-        DefaultHttpServiceProcessor processor = new DefaultHttpServiceProcessor(
-                conn, this.workerfactory.newWorker(), callback);
+        HttpServiceProcessor processor;
+        if (httpFactory!=null)
+            processor = httpFactory.newRequestServiceProcessor(conn, workerfactory.newWorker(), callback);
+        else
+            processor = new DefaultHttpServiceProcessor(conn, workerfactory.newWorker(), callback);
 
         processor.setParams(this.params);
         // Add required protocol interceptors
Index: org/apache/axis2/transport/http/server/HttpServiceProcessor.java
===================================================================
--- org/apache/axis2/transport/http/server/HttpServiceProcessor.java	(revision 0)
+++ org/apache/axis2/transport/http/server/HttpServiceProcessor.java	(revision 0)
@@ -0,0 +1,49 @@
+/*
+ * HttpServiceProcessor.java
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2004 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ * Created on May 25, 2006, 4:09 PM
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import org.apache.http.HttpServerConnection;
+import org.apache.http.protocol.HttpService;
+
+/**
+ * Abstract base class to process requests and fill in respnses.
+ * @author Chuck Williams
+ */
+
+public abstract class HttpServiceProcessor extends HttpService implements IOProcessor {
+    
+    /** Create an HttpServiceProcessor
+     * @param conn the connection we are receiving the request on
+     */
+    public HttpServiceProcessor(HttpServerConnection conn) {
+        super(conn);
+    }
+
+}
Index: org/apache/axis2/transport/http/server/HttpFactory.java
===================================================================
--- org/apache/axis2/transport/http/server/HttpFactory.java	(revision 0)
+++ org/apache/axis2/transport/http/server/HttpFactory.java	(revision 0)
@@ -0,0 +1,376 @@
+/*
+ * HttpFactory.java
+ *
+ * ====================================================================
+ *
+ *  Copyright 2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ * Created on May 25, 2006, 10:11 AM
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import edu.emory.mathcs.backport.java.util.concurrent.BlockingQueue;
+import edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingQueue;
+import edu.emory.mathcs.backport.java.util.concurrent.ExecutorService;
+import edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor;
+import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
+import java.io.IOException;
+import javax.xml.namespace.QName;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.description.TransportInDescription;
+import org.apache.axis2.engine.ListenerManager;
+import org.apache.axis2.transport.http.HTTPWorker;
+import org.apache.axis2.transport.http.HTTPWorkerFactory;
+import org.apache.http.HttpServerConnection;
+import org.apache.http.impl.DefaultHttpParams;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.params.HttpProtocolParams;
+
+/**
+ * Factory used to configure and create the various instances required in http transports.
+ * Either configure this class in axis2.xml, or in code via the setters, or subclass it and specialize some factory methods to gain more control.
+ *
+ * @author Chuck Williams
+ */
+public class HttpFactory {
+
+    /** Name of axis2.xml port parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_PORT = "port";
+    
+    /** Name of axis2.xml hostname parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_HOST_ADDRESS = "hostname";
+
+    /** Name of axis2.xml originServer parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_ORIGIN_SERVER = "originServer";
+
+    /** Name of axis2.xml requestTimeout parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_REQUEST_SOCKET_TIMEOUT = "requestTimeout";
+
+    /** Name of axis2.xml requestTcpNoDelay parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_REQUEST_TCP_NO_DELAY = "requestTcpNoDelay";
+
+    /** Name of axis2.xml requestCoreThreadPoolSize parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_REQUEST_CORE_THREAD_POOL_SIZE = "requestCoreThreadPoolSize";
+
+    /** Name of axis2.xml requestMaxThreadPoolSize parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_REQUEST_MAX_THREAD_POOL_SIZE = "requestMaxThreadPoolSize";
+
+    /** Name of axis2.xml threadKeepAliveTime parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_THREAD_KEEP_ALIVE_TIME = "threadKeepAliveTime";
+
+    /** Name of axis2.xml threadKeepAliveTimeUnit parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_THREAD_KEEP_ALIVE_TIME_UNIT = "threadKeepAliveTimeUnit";
+    
+    private ConfigurationContext configurationContext;
+    private TransportInDescription httpConfiguration;
+    private int port;
+    private String hostAddress;
+    private String originServer;
+    private int requestSocketTimeout;
+    private boolean requestTcpNoDelay;
+    private int requestCoreThreadPoolSize;
+    private int requestMaxThreadPoolSize;
+    private long threadKeepAliveTime;
+    private TimeUnit threadKeepAliveTimeUnit;
+    
+    private WorkerFactory requestWorkerFactory = null;
+    
+    private static final QName HTTP_NAME = new QName(Constants.TRANSPORT_HTTP);
+    
+    /** Create and configure a new HttpFactory */
+    public HttpFactory(ConfigurationContext configurationContext) throws AxisFault {
+        this.configurationContext = configurationContext;
+        httpConfiguration = configurationContext.getAxisConfiguration().getTransportIn(HTTP_NAME);
+        port = getIntParam(PARAMETER_PORT, 8080);
+        hostAddress = getStringParam(PARAMETER_HOST_ADDRESS, null);
+        originServer = getStringParam(PARAMETER_ORIGIN_SERVER, "Simple-Server/1.1");
+        requestSocketTimeout = getIntParam(PARAMETER_REQUEST_SOCKET_TIMEOUT, 20000);
+        requestTcpNoDelay = getBooleanParam(PARAMETER_REQUEST_TCP_NO_DELAY, true);
+        requestCoreThreadPoolSize = getIntParam(PARAMETER_REQUEST_CORE_THREAD_POOL_SIZE, 25);
+        requestMaxThreadPoolSize = getIntParam(PARAMETER_REQUEST_MAX_THREAD_POOL_SIZE, 150);
+        threadKeepAliveTime = getLongParam(PARAMETER_THREAD_KEEP_ALIVE_TIME, 180L);
+        threadKeepAliveTimeUnit = getTimeUnitParam(PARAMETER_THREAD_KEEP_ALIVE_TIME_UNIT, TimeUnit.SECONDS);
+    }
+    
+    /** Create and configure a new HttpFactory */
+    public HttpFactory(ConfigurationContext configurationContext, int port) throws AxisFault {
+        this(configurationContext);
+        this.port = port;
+    }
+    
+    /** Create and configure a new HttpFactory */
+    public HttpFactory(ConfigurationContext configurationContext, int port, WorkerFactory requestWorkerFactory) throws AxisFault {
+        this(configurationContext, port);
+        this.requestWorkerFactory = requestWorkerFactory;
+    }
+
+    private int getIntParam(String name, int def) {
+        String config = getStringParam(name, null);
+        if (config!=null)
+            return Integer.parseInt(config);
+        else 
+            return def;
+    }
+    
+    private long getLongParam(String name, long def) {
+        String config = getStringParam(name, null);
+        if (config!=null)
+            return Long.parseLong(config);
+        else 
+            return def;
+    }
+    
+    private boolean getBooleanParam(String name, boolean def) throws AxisFault {
+        String config = getStringParam(name, null);
+        if (config!=null) {
+            if (config.equals("yes") || config.equals("true"))
+                return true;
+            else if (config.equals("no") || config.equals("false"))
+                return false;
+            else throw new AxisFault("Boolean value must be yes, true, no or false for parameter " + name + ":  " + config);
+        }
+        return def;
+    }
+    
+    private TimeUnit getTimeUnitParam(String name, TimeUnit def) throws AxisFault {
+        String config = getStringParam(name, null);
+        if (config!=null)
+            try {
+                return (TimeUnit) TimeUnit.class.getField(name).get(null);
+            } catch (Exception e) {
+                throw new AxisFault(e);
+            }
+        return def;
+    }
+        
+    private String getStringParam(String name, String def) {
+        Parameter param = httpConfiguration.getParameter(name);
+        if (param!=null) {
+            assert param.getParameterType() == Parameter.TEXT_PARAMETER;
+            String config = (String) param.getValue();
+            if (config!=null)
+                return config;
+        }
+        return def;
+    }
+    
+    /** Return the configured listener manager or create and configure one with configurationContext */
+    public ListenerManager getListenerManager() {
+        ListenerManager lm = configurationContext.getListenerManager();
+        if (lm==null) {
+            lm = new ListenerManager();
+            lm.init(configurationContext);
+        }
+        return lm;
+    }
+    
+    /** Create the executor used to launch the single requestConnectionListener */
+    public ExecutorService newListenerExecutor(int port) {
+        return new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,
+                new LinkedBlockingQueue(),
+                new DefaultThreadFactory(new ThreadGroup("Listener thread group"), "HttpListener-" + this.port));
+    }
+    
+    /** Create the listener for request connections */
+    public IOProcessor newRequestConnectionListener(HttpConnectionFactory factory, HttpConnectionManager manager, int port) throws IOException {
+        return new DefaultConnectionListener(port, factory, manager);
+    }
+    
+    /** Create a request connection */
+    public HttpConnectionFactory newRequestConnectionFactory(HttpParams params) {
+        return new DefaultHttpConnectionFactory(params);
+    }
+    
+    /** Create and set the parameters applied to incoming request connections */
+    public HttpParams newRequestConnectionParams() {
+        HttpParams params = new DefaultHttpParams(); 
+        params
+            .setIntParameter(HttpConnectionParams.SO_TIMEOUT, requestSocketTimeout)
+            .setBooleanParameter(HttpConnectionParams.TCP_NODELAY, requestTcpNoDelay) 
+            .setParameter(HttpProtocolParams.ORIGIN_SERVER, originServer);
+        return params;
+    }
+    
+    /** Create the connection manager used to launch request threads */
+    public HttpConnectionManager newRequestConnectionManager(ExecutorService requestExecutor, WorkerFactory workerFactory, HttpParams params) {
+        return new DefaultHttpConnectionManager(requestExecutor, workerFactory, params);
+    }
+    
+    /** Create the executor use the manage request processing threads */
+    public ExecutorService newRequestExecutor(int port) {
+        return new ThreadPoolExecutor(requestCoreThreadPoolSize, requestMaxThreadPoolSize, threadKeepAliveTime, threadKeepAliveTimeUnit,
+                                      newRequestBlockingQueue(),
+                                      new DefaultThreadFactory(new ThreadGroup("Connection thread group"), "HttpConnection-" + port));
+    }
+    
+    /** Create the queue used to hold incoming requests when requestCoreThreadPoolSize threads are busy.
+     * Default is an unbounded queue.
+     */
+    public BlockingQueue newRequestBlockingQueue() {
+        return new LinkedBlockingQueue();
+    }
+    
+    /** Create the factory for request workers */
+    public WorkerFactory newRequestWorkerFactory() {
+        if (requestWorkerFactory!=null)
+            return requestWorkerFactory;
+        else
+            return new HTTPWorkerFactory(configurationContext);
+    }
+
+    /** Create a request service processor to populate the response */
+    public HttpServiceProcessor newRequestServiceProcessor(HttpServerConnection connection, Worker worker, IOProcessorCallback callback) {
+        return new DefaultHttpServiceProcessor(connection, worker, callback);
+    }
+    
+    // *****
+    // Getters and Setters
+    // *****
+
+    /** Getter for configurationContext */
+    public ConfigurationContext getConfigurationContext() {
+        return configurationContext;
+    }
+
+    /** Getter for httpConfiguration */
+    public TransportInDescription getHttpConfiguration() {
+        return httpConfiguration;
+    }
+
+    /** Getter for port
+      * return the port on which to listen for http connections (default = 8080)
+     */
+    public int getPort() {
+        return port;
+    }
+
+    /** Setter for port */
+    public void setPort(int port) {
+        this.port = port;
+    }
+
+    /** Getter for hostAddress
+     * @return the host address (or name) to be use in reply-to endpoint references, or null if not specified (default = null)
+     */
+    public String getHostAddress() {
+        return hostAddress;
+    }
+
+    /** Setter for hostAddress */
+    public void setHostAddress(String hostAddress) {
+        this.hostAddress = hostAddress;
+    }
+
+    /** Getter for originServer
+     * @return the Server header string for outgoing messages (default "Simple-Server/1.1")
+     */
+    public String getOriginServer() {
+        return originServer;
+    }
+
+    /** Setter for originServer */
+    public void setOriginServer(String originServer) {
+        this.originServer = originServer;
+    }
+
+    /** Getter for requestSocketTimeout
+     * @return the maximum time in millis to wait for data on a request socket (default 20000)
+     */
+    public int getRequestSocketTimeout() {
+        return requestSocketTimeout;
+    }
+
+    /** Setter for requestSocketTimeout */
+    public void setRequestSocketTimeout(int requestSocketTimeout) {
+        this.requestSocketTimeout = requestSocketTimeout;
+    }
+
+    /** Getter for requestTcpNoDelay
+     * return false iff Nagle's algorithm should be used to conserve bandwidth by minimizing segments
+     *              at the cost of latency and performance (default true, i.e. maximize performance at
+     *              the cost of bandwidth)
+     */
+    public boolean getRequestTcpNoDelay() {
+        return requestTcpNoDelay;
+    }
+
+    /** Setter for requestTcpNoDelay */
+    public void setRequestTcpNoDelay(boolean requestTcpNoDelay) {
+        this.requestTcpNoDelay = requestTcpNoDelay;
+    }
+
+    /** Getter for RequestCoreThreadPoolSize
+     * @return the size of the thread pool use to process requests assuming there is adequate queue space (default 25)
+     */
+    public int getRequestCoreThreadPoolSize() {
+        return requestCoreThreadPoolSize;
+    }
+
+    /** Setter for RequestCoreThreadPoolSize */
+    public void setRequestCoreThreadPoolSize(int RequestCoreThreadPoolSize) {
+        this.requestCoreThreadPoolSize = requestCoreThreadPoolSize;
+    }
+
+    /** Getter for requestMaxThreadPoolSize
+     * @return the maximum size of the thread pool used to process requests if the queue fills up (default 150).
+     *         Since the default queue is unbounded this parameter is meaningless unless you override newRequestBlockingQueue()
+     */
+    public int getRequestMaxThreadPoolSize() {
+        return requestMaxThreadPoolSize;
+    }
+
+    /** Setter for requestMaxThreadPoolSize */
+    public void setRequestMaxThreadPoolSize(int requestMaxThreadPoolSize) {
+        this.requestMaxThreadPoolSize = requestMaxThreadPoolSize;
+    }
+
+    /** Getter for threadKeepAliveTime
+     * @return how long a request processing thread in excess of the core pool size will be kept alive it if is inactive
+     *         (default with threadKeepAliveTimeUnit to 180 seconds)
+     */
+    public long getThreadKeepAliveTime() {
+        return threadKeepAliveTime;
+    }
+
+    /** Setter for threadKeepAliveTime */
+    public void setThreadKeepAliveTime(long threadKeepAliveTime) {
+        this.threadKeepAliveTime = threadKeepAliveTime;
+    }
+
+    /** Getter for threadKeepAliveTimeUnit
+     * return the time unit for threadKeepAliveTime (default SECONDS)
+     */
+    public TimeUnit getThreadKeepAliveTimeUnit() {
+        return threadKeepAliveTimeUnit;
+    }
+
+    /** Setter for threadKeepAliveTimeUnit */
+    public void setthreadKeepAliveTimeUnit(TimeUnit threadKeepAliveTimeUnit) {
+        this.threadKeepAliveTimeUnit = threadKeepAliveTimeUnit;
+    }
+
+}
Index: org/apache/axis2/transport/http/server/SimpleHttpServer.java
===================================================================
--- org/apache/axis2/transport/http/server/SimpleHttpServer.java	(revision 595)
+++ org/apache/axis2/transport/http/server/SimpleHttpServer.java	(working copy)
@@ -31,6 +31,7 @@
 package org.apache.axis2.transport.http.server;
 
 import java.io.IOException;
+import org.apache.axis2.context.ConfigurationContext;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -45,7 +46,7 @@
 import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
 
 /**
- * A simple, but extensible HTTP server.
+ * A simple, but configurable and extensible HTTP server.
  */
 public class SimpleHttpServer {
 
@@ -54,13 +55,11 @@
     private static final String ORIGIN_SERVER = "Simple-Server/1.1";
     private static final int SHUTDOWN_GRACE_PERIOD = 3000; // ms
     
+    private HttpFactory httpFactory;
     private final int port;
     private final HttpParams params;
-    private final WorkerFactory workerfactory;
+    private final WorkerFactory workerFactory;
 
-    private int minThreads = 50;
-    private int maxThreads = 150;
-    
     private IOProcessor listener = null;
     private ExecutorService listenerExecutor = null;
     private ThreadGroup listenertg = null;
@@ -68,49 +67,24 @@
     private ExecutorService requestExecutor = null;
     private ThreadGroup conntg = null;
 
-    public SimpleHttpServer(final WorkerFactory workerfactory, int port) throws IOException {
-        super();
-        if (workerfactory == null) {
-            throw new IllegalArgumentException("Worker factory may not be null");
-        }
-        this.params = new DefaultHttpParams(); 
-        this.params
-            .setIntParameter(HttpConnectionParams.SO_TIMEOUT, 20000)
-            .setBooleanParameter(HttpConnectionParams.TCP_NODELAY, true) 
-            .setParameter(HttpProtocolParams.ORIGIN_SERVER, ORIGIN_SERVER);
-        this.workerfactory = workerfactory;
+    public SimpleHttpServer(ConfigurationContext configurationContext, WorkerFactory workerFactory, int port) throws IOException {
+        this(new HttpFactory(configurationContext, port, workerFactory), port);
+    }
+    
+    public SimpleHttpServer(HttpFactory httpFactory, int port) throws IOException {
+        this.httpFactory = httpFactory;
         this.port = port;
+        this.workerFactory = httpFactory.newRequestWorkerFactory();
+        this.params = httpFactory.newRequestConnectionParams();
     }
 
     public void init() throws IOException {
-        this.conntg = new ThreadGroup("Connection thread group");
-        
-        this.requestExecutor = new ThreadPoolExecutor(
-                this.minThreads, this.maxThreads,
-                180L, TimeUnit.SECONDS,
-                new LinkedBlockingQueue(),
-                new DefaultThreadFactory(this.conntg, "HttpConnection-" + this.port));
-        
-        this.connmanager = new DefaultHttpConnectionManager( 
-                this.requestExecutor,
-                this.workerfactory, 
-                this.params);
-
-        this.listenertg = new ThreadGroup("Listener thread group");
-        
-        this.listenerExecutor = new ThreadPoolExecutor(
-                1, 1,
-                0L, TimeUnit.MILLISECONDS,
-                new LinkedBlockingQueue(),
-                new DefaultThreadFactory(this.listenertg, "HttpListener-" + this.port));
-        
-        HttpConnectionFactory connfactory = new DefaultHttpConnectionFactory(
-                this.params);
-        
-        this.listener = new DefaultConnectionListener(
-                this.port,
-                connfactory, 
-                this.connmanager);
+        requestExecutor = httpFactory.newRequestExecutor(port);
+        connmanager = httpFactory.newRequestConnectionManager(requestExecutor, workerFactory, params);
+        listenerExecutor = httpFactory.newListenerExecutor(port);
+        listener = httpFactory.newRequestConnectionListener(httpFactory.newRequestConnectionFactory(params),
+                                                            httpFactory.newRequestConnectionManager(requestExecutor, workerFactory, params),
+                                                            port);
     }
     
     public void destroy() throws IOException, InterruptedException {
