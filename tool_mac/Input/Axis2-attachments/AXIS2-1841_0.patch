Index: kernel/test/org/apache/axis2/description/RegistryTest.java
===================================================================
--- kernel/test/org/apache/axis2/description/RegistryTest.java	(revision 486006)
+++ kernel/test/org/apache/axis2/description/RegistryTest.java	(working copy)
@@ -65,7 +65,7 @@
         assertEquals(p, parmInclude.getParameter(key));
     }
 
-    public void testFlowIncludeTest(FlowInclude flowInclude) {
+    public void testFlowIncludeTest(AxisModule flowInclude) {
         Flow flow1 = new Flow();
         Flow flow2 = new Flow();
         Flow flow3 = new Flow();
@@ -81,7 +81,6 @@
 
     public void testHandlers() throws AxisFault {
         Handler handler = new AbstractHandler() {
-            private static final long serialVersionUID = 196289132377245632L;
 
 			public InvocationResponse invoke(MessageContext msgContext)  {
                 return InvocationResponse.CONTINUE;        
Index: kernel/src/org/apache/axis2/description/OutInAxisOperation.java
===================================================================
--- kernel/src/org/apache/axis2/description/OutInAxisOperation.java	(revision 486006)
+++ kernel/src/org/apache/axis2/description/OutInAxisOperation.java	(working copy)
@@ -15,7 +15,6 @@
 */
 package org.apache.axis2.description;
 
-import org.apache.axiom.om.OMElement;
 import org.apache.axiom.soap.SOAPBody;
 import org.apache.axiom.soap.SOAPEnvelope;
 import org.apache.axiom.soap.SOAPFault;
@@ -34,16 +33,12 @@
 import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.transport.TransportUtils;
 import org.apache.axis2.util.CallbackReceiver;
-import org.apache.axis2.util.UUIDGenerator;
-import org.apache.axis2.util.TargetResolver;
 import org.apache.axis2.wsdl.WSDLConstants;
 
 import javax.xml.namespace.QName;
 import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
 
-public class OutInAxisOperation extends InOutAxisOperation {
+public class OutInAxisOperation extends TwoChannelAxisOperation {
     public OutInAxisOperation() {
         super();
         setMessageExchangePattern(WSDL20_2004Constants.MEP_URI_OUT_IN);
@@ -94,57 +89,15 @@
 /**
  * MEP client for moi.
  */
-class OutInAxisOperationClient implements OperationClient {
+class OutInAxisOperationClient extends OperationClient {
 
-    private AxisOperation axisOp;
 
-    protected ServiceContext sc;
-
-    protected Options options;
-
-    protected OperationContext oc;
-
-    protected Callback callback;
-
-    /*
-     * indicates whether the MEP execution has completed (and hence ready for
-     * resetting)
-     */
-    boolean completed;
-
     OutInAxisOperationClient(OutInAxisOperation axisOp, ServiceContext sc,
                              Options options) {
-        this.axisOp = axisOp;
-        this.sc = sc;
-        this.options = options;
-        this.completed = false;
-        this.oc = new OperationContext(axisOp);
-        this.oc.setParent(this.sc);
+        super(axisOp, sc, options);
     }
 
     /**
-     * Sets the options that should be used for this particular client. This
-     * resets the entire set of options to use the new options - so you'd lose
-     * any option cascading that may have been set up.
-     *
-     * @param options the options
-     */
-    public void setOptions(Options options) {
-        this.options = options;
-    }
-
-    /**
-     * Returns the options used by this client. If you want to set a single
-     * option, then the right way is to call getOptions() and set specific
-     * options.
-     *
-     * @return Returns the options, which will never be null.
-     */
-    public Options getOptions() {
-        return options;
-    }
-
-    /**
      * Adds message context to operation context , so that it will handle the
      * logic correctly if the OperationContext is null then new one will be
      * created , and Operation Context will become null when some one calls reset().
@@ -178,31 +131,7 @@
         this.callback = callback;
     }
 
-    /**
-     * Create a message ID for the given message context if needed. If user gives an option with
-     * MessageID then just copy that into MessageContext , and with that there can be multiple
-     * message with same MessageID unless user call setOption for each invocation.
-     * <p/>
-     * If user want to give message ID then the better way is to set the message ID in the option and
-     * call setOption for each invocation then the right thing will happen.
-     * <p/>
-     * If user does not give a message ID then the new one will be created and set that into Message
-     * Context.
-     *
-     * @param mc the message context whose id is to be set
-     */
-    private void setMessageID(MessageContext mc) {
-        // now its the time to put the parameters set by the user in to the
-        // correct places and to the
-        // if there is no message id still, set a new one.
-        String messageId = options.getMessageId();
-        if (messageId == null || "".equals(messageId)) {
-            messageId = UUIDGenerator.getUUID();
-        }
-        mc.setMessageID(messageId);
-    }
 
-
     /**
      * Executes the MEP. What this does depends on the specific MEP client. The
      * basic idea is to have the MEP client execute and do something with the
@@ -228,31 +157,8 @@
         if (mc == null) {
             throw new AxisFault(Messages.getMessage("outmsgctxnull"));
         }
-        //setting AxisMessage
-        mc.setAxisMessage(axisOp.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));
-        if (mc.getSoapAction() == null || "".equals(mc.getSoapAction())) {
-            mc.setSoapAction(options.getAction());
-        }
-        mc.setOptions(options);
+        prepareMessageContext(cc, mc);
 
-        // do Target Resolution
-        TargetResolver targetResolver = cc.getAxisConfiguration().getTargetResolverChain();
-        if(targetResolver != null){
-            targetResolver.resolveTarget(mc);
-        }
-
-        // if the transport to use for sending is not specified, try to find it
-        // from the URL
-        TransportOutDescription transportOut = options.getTransportOut();
-        if (transportOut == null) {
-            EndpointReference toEPR = (options.getTo() != null) ? options
-                    .getTo() : mc.getTo();
-            transportOut = ClientUtils.inferOutTransport(cc
-                    .getAxisConfiguration(), toEPR, mc);
-        }
-        mc.setTransportOut(transportOut);
-
-
         if (options.getTransportIn() == null && mc.getTransportIn() == null) {
             mc.setTransportIn(ClientUtils.inferInTransport(cc
                     .getAxisConfiguration(), options, mc));
@@ -260,25 +166,24 @@
             mc.setTransportIn(options.getTransportIn());
         }
 
-        addReferenceParameters(mc);
         if (options.isUseSeparateListener()) {
             CallbackReceiver callbackReceiver = (CallbackReceiver) axisOp
                     .getMessageReceiver();
             callbackReceiver.addCallback(mc.getMessageID(), callback);
-            
+
             /**
              * If USE_CUSTOM_LISTENER is set to 'true' the replyTo value will not be replaced and Axis2 will not
              * start its internal listner. Some other enntity (e.g. a module) should take care of obtaining the 
              * response message.
              */
             Boolean useCustomListener = (Boolean) options.getProperty(Constants.Configuration.USE_CUSTOM_LISTENER);
-            if (useCustomListener==null || !useCustomListener.booleanValue()) {
+            if (useCustomListener == null || !useCustomListener.booleanValue()) {
 
                 EndpointReference replyToFromTransport = mc.getConfigurationContext().getListenerManager().
-                getEPRforService(sc.getAxisService().getName(), axisOp.getName().getLocalPart(), mc
-                        .getTransportIn().getName()
-                        .getLocalPart());
-                
+                        getEPRforService(sc.getAxisService().getName(), axisOp.getName().getLocalPart(), mc
+                                .getTransportIn().getName()
+                                .getLocalPart());
+
                 if (mc.getReplyTo() == null) {
                     mc.setReplyTo(replyToFromTransport);
                 } else {
@@ -286,8 +191,6 @@
                 }
             }
 
-
-            
             //if we don't do this , this guy will wait till it gets HTTP 202 in the HTTP case
             mc.setProperty(MessageContext.TRANSPORT_NON_BLOCKING, Boolean.TRUE);
             AxisEngine engine = new AxisEngine(cc);
@@ -323,24 +226,6 @@
         }
     }
 
-    private void addReferenceParameters(MessageContext msgctx) {
-        EndpointReference to = msgctx.getTo();
-        if (options.isManageSession()) {
-            EndpointReference tepr = sc.getTargetEPR();
-            if (tepr != null) {
-                Map map = tepr.getAllReferenceParameters();
-                if (map != null) {
-                    Iterator valuse = map.values().iterator();
-                    while (valuse.hasNext()) {
-                        Object refparaelement = valuse.next();
-                        if (refparaelement instanceof OMElement) {
-                            to.addReferenceParameter((OMElement) refparaelement);
-                        }
-                    }
-                }
-            }
-        }
-    }
 
     /**
      * @param msgctx
@@ -401,33 +286,6 @@
     }
 
     /**
-     * Resets the MEP client to a clean status after the MEP has completed. This
-     * is how you can reuse a MEP client. NOTE: this does not reset the options;
-     * only the internal state so the client can be used again.
-     *
-     * @throws AxisFault if reset is called before the MEP client has completed an
-     *                   interaction.
-     */
-    public void reset() throws AxisFault {
-        if (!completed) {
-            throw new AxisFault(Messages.getMessage("cannotreset"));
-        }
-        oc = null;
-        completed = false;
-    }
-
-    public void complete(MessageContext msgCtxt) throws AxisFault {
-        TransportOutDescription trsout = msgCtxt.getTransportOut();
-        if (trsout != null) {
-            trsout.getSender().cleanup(msgCtxt);
-        }
-    }
-
-    public OperationContext getOperationContext() {
-        return oc;
-    }
-
-    /**
      * This class is the workhorse for a non-blocking invocation that uses a two
      * way transport.
      */
@@ -467,10 +325,10 @@
                 }
 
             } catch (Exception e) {
-				callback.onError(e);
-			} finally {
-				callback.setComplete(true);
-			}
+                callback.onError(e);
+            } finally {
+                callback.setComplete(true);
+            }
         }
     }
 }
Index: kernel/src/org/apache/axis2/description/TwoChannelAxisOperation.java
===================================================================
--- kernel/src/org/apache/axis2/description/TwoChannelAxisOperation.java	(revision 0)
+++ kernel/src/org/apache/axis2/description/TwoChannelAxisOperation.java	(revision 0)
@@ -0,0 +1,136 @@
+package org.apache.axis2.description;
+
+import org.apache.axis2.wsdl.WSDLConstants;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.OperationContext;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.i18n.Messages;
+
+import javax.xml.namespace.QName;
+import java.util.ArrayList;
+import java.util.HashMap;
+/*
+* Copyright 2004,2005 The Apache Software Foundation.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+*
+*/
+
+/**
+ * This class is to keep common methods and properties in InOut and OutIn axisOperation
+ */
+public abstract class TwoChannelAxisOperation extends AxisOperation {
+
+    protected AxisMessage inFaultMessage;
+    protected AxisMessage outFaultMessage;
+    protected AxisMessage inMessage;
+    protected AxisMessage outMessage;
+
+    public TwoChannelAxisOperation() {
+        super();
+        createMessages();
+    }
+
+    public TwoChannelAxisOperation(QName name) {
+        super(name);
+        createMessages();
+    }
+
+    private void createMessages() {
+        inMessage = new AxisMessage();
+        inMessage.setDirection(WSDLConstants.WSDL_MESSAGE_DIRECTION_IN);
+        inMessage.setParent(this);
+        addChild("inMessage", inMessage);
+
+        inFaultMessage = new AxisMessage();
+        inFaultMessage.setParent(this);
+
+        outFaultMessage = new AxisMessage();
+        outFaultMessage.setParent(this);
+
+        outMessage = new AxisMessage();
+        outMessage.setDirection(WSDLConstants.WSDL_MESSAGE_DIRECTION_OUT);
+        outMessage.setParent(this);
+        addChild("outMessage", outMessage);
+    }
+
+    public void addMessage(AxisMessage message, String label) {
+           if (WSDLConstants.MESSAGE_LABEL_OUT_VALUE.equals(label)) {
+               addChild("outMessage", message);
+           } else if (WSDLConstants.MESSAGE_LABEL_IN_VALUE.equals(label)) {
+               addChild("inMessage", message);
+           } else if (WSDLConstants.MESSAGE_LABEL_FAULT_VALUE.equals(label)) {
+               addChild("faultMessage", message);
+           } else {
+               throw new UnsupportedOperationException("Not yet implemented");
+           }
+       }
+
+
+    public AxisMessage getMessage(String label) {
+        if (WSDLConstants.MESSAGE_LABEL_OUT_VALUE.equals(label)) {
+            return (AxisMessage) getChild("outMessage");
+        } else if (WSDLConstants.MESSAGE_LABEL_IN_VALUE.equals(label)) {
+            return (AxisMessage) getChild("inMessage");
+        } else {
+            throw new UnsupportedOperationException("Not yet implemented");
+        }
+    }
+
+    public void addFaultMessageContext(MessageContext msgContext, OperationContext opContext) throws AxisFault {
+        HashMap mep = opContext.getMessageContexts();
+        MessageContext faultMessageCtxt = (MessageContext) mep.get(MESSAGE_LABEL_FAULT_VALUE);
+
+        if (faultMessageCtxt != null) {
+            throw new AxisFault(Messages.getMessage("mepcompleted"));
+        } else {
+            mep.put(MESSAGE_LABEL_FAULT_VALUE, msgContext);
+            opContext.setComplete(true);
+            opContext.cleanup();
+        }
+
+    }
+
+    public ArrayList getPhasesInFaultFlow() {
+        return inFaultMessage.getMessageFlow();
+    }
+
+    public ArrayList getPhasesOutFaultFlow() {
+        return outFaultMessage.getMessageFlow();
+    }
+
+    public ArrayList getPhasesOutFlow() {
+        return outMessage.getMessageFlow();
+    }
+
+    public ArrayList getRemainingPhasesInFlow() {
+        return inMessage.getMessageFlow();
+    }
+
+    public void setPhasesInFaultFlow(ArrayList list) {
+        inFaultMessage.setMessageFlow(list);
+    }
+
+    public void setPhasesOutFaultFlow(ArrayList list) {
+        outFaultMessage.setMessageFlow(list);
+    }
+
+    public void setPhasesOutFlow(ArrayList list) {
+        outMessage.setMessageFlow(list);
+    }
+
+    public void setRemainingPhasesInFlow(ArrayList list) {
+        inMessage.setMessageFlow(list);
+    }
+}
Index: kernel/src/org/apache/axis2/description/AxisModule.java
===================================================================
--- kernel/src/org/apache/axis2/description/AxisModule.java	(revision 486006)
+++ kernel/src/org/apache/axis2/description/AxisModule.java	(working copy)
@@ -37,12 +37,12 @@
  * <p>Handler are registered once they are available. They are available to all services if axis2.xml
  * has a module ref="." or available to a single service if services.xml have module ref=".."</p>
  */
-public class AxisModule implements FlowInclude, ParameterInclude {
+public class AxisModule implements ParameterInclude {
 
     /**
      * Field flowInclude
      */
-    private final FlowInclude flowInclude = new FlowIncludeImpl();
+    private final FlowInclude flowInclude = new FlowInclude();
 
     /**
      * Field parameters
Index: kernel/src/org/apache/axis2/description/FlowInclude.java
===================================================================
--- kernel/src/org/apache/axis2/description/FlowInclude.java	(revision 486006)
+++ kernel/src/org/apache/axis2/description/FlowInclude.java	(working copy)
@@ -1,75 +0,0 @@
-/*
-* Copyright 2004,2005 The Apache Software Foundation.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-
-package org.apache.axis2.description;
-
-/**
- * Interface FlowInclude
- */
-public interface FlowInclude {
-
-    /**
-     * Method getFaultInFlow.
-     *
-     * @return Returns Flow.
-     */
-    public Flow getFaultInFlow();
-
-    public Flow getFaultOutFlow();
-
-    /**
-     * Method getInFlow.
-     *
-     * @return Returns Flow.
-     */
-    public Flow getInFlow();
-
-    /**
-     * Method getOutFlow.
-     *
-     * @return Returns Flow.
-     */
-    public Flow getOutFlow();
-
-    /**
-     * Method setFaultInFlow.
-     *
-     * @param faultFlow
-     */
-    public void setFaultInFlow(Flow faultFlow);
-
-    /**
-     * Method setFaultOutFlow.
-     *
-     * @param faultFlow
-     */
-    public void setFaultOutFlow(Flow faultFlow);
-
-    /**
-     * Method setInFlow.
-     *
-     * @param inFlow
-     */
-    public void setInFlow(Flow inFlow);
-
-    /**
-     * Method setOutFlow.
-     *
-     * @param outFlow
-     */
-    public void setOutFlow(Flow outFlow);
-}
Index: kernel/src/org/apache/axis2/description/FlowInclude.java
===================================================================
--- kernel/src/org/apache/axis2/description/FlowInclude.java	(revision 0)
+++ kernel/src/org/apache/axis2/description/FlowInclude.java	(revision 483330)
@@ -0,0 +1,102 @@
+/*
+* Copyright 2004,2005 The Apache Software Foundation.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+
+package org.apache.axis2.description;
+
+/**
+ * Class FlowIncludeImpl
+ */
+public class FlowInclude  {
+
+    /**
+     * Field fault
+     */
+    private Flow In_fault;
+    private Flow Out_fault;
+
+    /**
+     * Field in
+     */
+    private Flow in;
+
+    /**
+     * Field out
+     */
+    private Flow out;
+
+    /**
+     * Method getFaultInFlow.
+     *
+     * @return Returns Flow.
+     */
+    public Flow getFaultInFlow() {
+        return In_fault;
+    }
+
+    public Flow getFaultOutFlow() {
+        return this.Out_fault;
+    }
+
+    /**
+     * Method getInFlow.
+     *
+     * @return Returns Flow.
+     */
+    public Flow getInFlow() {
+        return in;
+    }
+
+    /**
+     * Method getOutFlow.
+     *
+     * @return Returns Flow.
+     */
+    public Flow getOutFlow() {
+        return out;
+    }
+
+    /**
+     * Method setFaultInFlow.
+     *
+     * @param flow
+     */
+    public void setFaultInFlow(Flow flow) {
+        this.In_fault = flow;
+    }
+
+    public void setFaultOutFlow(Flow faultFlow) {
+        this.Out_fault = faultFlow;
+    }
+
+    /**
+     * Method setInFlow.
+     *
+     * @param flow
+     */
+    public void setInFlow(Flow flow) {
+        this.in = flow;
+    }
+
+    /**
+     * Method setOutFlow.
+     *
+     * @param flow
+     */
+    public void setOutFlow(Flow flow) {
+        this.out = flow;
+    }
+}
Index: kernel/src/org/apache/axis2/description/AxisOperation.java
===================================================================
--- kernel/src/org/apache/axis2/description/AxisOperation.java	(revision 486006)
+++ kernel/src/org/apache/axis2/description/AxisOperation.java	(working copy)
@@ -44,9 +44,6 @@
     private static final Log log = LogFactory.getLog(AxisOperation.class);
     private int mep = WSDL20_2004Constants.MEP_CONSTANT_INVALID;
 
-    public static final String SOAP_ACTION = "soapaction";
-
-
     // to store engaged modules
     private ArrayList engagedModules = new ArrayList();
 
@@ -336,20 +333,15 @@
                                                  ServiceContext serviceContext)
             throws AxisFault {
         OperationContext operationContext;
-
         if (null == msgContext.getRelatesTo()) {
-
             // Its a new incoming message so get the factory to create a new
             // one
             operationContext = new OperationContext(this, serviceContext);
         } else {
-
             // So this message is part of an ongoing MEP
             ConfigurationContext configContext = msgContext.getConfigurationContext();
-
             operationContext =
                     configContext.getOperationContext(msgContext.getRelatesTo().getValue());
-
             if (null == operationContext) {
                 throw new AxisFault(Messages.getMessage("cannotCorrelateMsg",
                         this.name.toString(), msgContext.getRelatesTo().getValue()));
@@ -477,14 +469,11 @@
 
     // to check whether a given parameter is locked
     public boolean isParameterLocked(String parameterName) {
-
         // checking the locked value of parent
         boolean locked = false;
-
         if (getParent() != null) {
             locked = getParent().isParameterLocked(parameterName);
         }
-
         if (locked) {
             return true;
         } else {
Index: kernel/src/org/apache/axis2/description/InOutAxisOperation.java
===================================================================
--- kernel/src/org/apache/axis2/description/InOutAxisOperation.java	(revision 486006)
+++ kernel/src/org/apache/axis2/description/InOutAxisOperation.java	(working copy)
@@ -16,43 +16,23 @@
 package org.apache.axis2.description;
 
 import org.apache.axis2.AxisFault;
-import org.apache.axis2.wsdl.WSDLConstants;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.context.OperationContext;
 import org.apache.axis2.i18n.Messages;
 
 import javax.xml.namespace.QName;
-import java.util.ArrayList;
 import java.util.HashMap;
 
-public class InOutAxisOperation extends AxisOperation {
-    private AxisMessage inFaultMessage;
-//    private AxisMessage inMessage;
-    private AxisMessage outFaultMessage;
-//    private AxisMessage outMessage;
+public class InOutAxisOperation extends TwoChannelAxisOperation {
 
     public InOutAxisOperation() {
         super();
-        createMessages();
     }
 
     public InOutAxisOperation(QName name) {
         super(name);
-        createMessages();
     }
 
-    public void addMessage(AxisMessage message, String label) {
-        if (WSDLConstants.MESSAGE_LABEL_OUT_VALUE.equals(label)) {
-            addChild("outMessage", message);
-        } else if (WSDLConstants.MESSAGE_LABEL_IN_VALUE.equals(label)) {
-            addChild("inMessage", message);
-        } else if (WSDLConstants.MESSAGE_LABEL_FAULT_VALUE.equals(label)) {
-            addChild("faultMessage", message);
-        } else {
-            throw new UnsupportedOperationException("Not yet implemented");
-        }
-    }
-
     public void addMessageContext(MessageContext msgContext, OperationContext opContext)
             throws AxisFault {
         HashMap mep = opContext.getMessageContexts();
@@ -71,88 +51,4 @@
             opContext.cleanup();
         }
     }
-
-    public void addFaultMessageContext(MessageContext msgContext, OperationContext opContext) throws AxisFault {
-        HashMap mep = opContext.getMessageContexts();
-        MessageContext faultMessageCtxt = (MessageContext) mep.get(MESSAGE_LABEL_FAULT_VALUE);
-
-        if (faultMessageCtxt != null) {
-             throw new AxisFault(Messages.getMessage("mepcompleted"));
-        } else {
-            mep.put(MESSAGE_LABEL_FAULT_VALUE, msgContext);
-            opContext.setComplete(true);
-            opContext.cleanup();
-        }
-
-    }
-
-    private void createMessages() {
-//        inMessage = new AxisMessage();
-//        inMessage.setDirection(WSDLConstants.WSDL_MESSAGE_DIRECTION_IN);
-//        inMessage.setParent(this);
-
-        AxisMessage inMessage = new AxisMessage();
-        inMessage.setDirection(WSDLConstants.WSDL_MESSAGE_DIRECTION_IN);
-        inMessage.setParent(this);
-        addChild("inMessage", inMessage);
-
-        inFaultMessage = new AxisMessage();
-        inFaultMessage.setParent(this);
-
-        outFaultMessage = new AxisMessage();
-        outFaultMessage.setParent(this);
-
-//        outMessage = new AxisMessage();
-//        outMessage.setDirection(WSDLConstants.WSDL_MESSAGE_DIRECTION_OUT);
-//        outMessage.setParent(this);
-
-        AxisMessage outMessage = new AxisMessage();
-        outMessage.setDirection(WSDLConstants.WSDL_MESSAGE_DIRECTION_OUT);
-        outMessage.setParent(this);
-        addChild("outMessage", outMessage);
-
-
-    }
-
-    public AxisMessage getMessage(String label) {
-        if (WSDLConstants.MESSAGE_LABEL_OUT_VALUE.equals(label)) {
-            return (AxisMessage) getChild("outMessage");
-        } else if (WSDLConstants.MESSAGE_LABEL_IN_VALUE.equals(label)) {
-            return (AxisMessage) getChild("inMessage");
-        } else {
-            throw new UnsupportedOperationException("Not yet implemented");
-        }
-    }
-
-    public ArrayList getPhasesInFaultFlow() {
-        return inFaultMessage.getMessageFlow();
-    }
-
-    public ArrayList getPhasesOutFaultFlow() {
-        return outFaultMessage.getMessageFlow();
-    }
-
-    public ArrayList getPhasesOutFlow() {
-        return ((AxisMessage) getChild("outMessage")).getMessageFlow();
-    }
-
-    public ArrayList getRemainingPhasesInFlow() {
-        return ((AxisMessage) getChild("inMessage")).getMessageFlow();
-    }
-
-    public void setPhasesInFaultFlow(ArrayList list) {
-        inFaultMessage.setMessageFlow(list);
-    }
-
-    public void setPhasesOutFaultFlow(ArrayList list) {
-        outFaultMessage.setMessageFlow(list);
-    }
-
-    public void setPhasesOutFlow(ArrayList list) {
-        ((AxisMessage) getChild("outMessage")).setMessageFlow(list);
-    }
-
-    public void setRemainingPhasesInFlow(ArrayList list) {
-        ((AxisMessage) getChild("inMessage")).setMessageFlow(list);
-    }
 }
Index: kernel/src/org/apache/axis2/description/AxisDescription.java
===================================================================
--- kernel/src/org/apache/axis2/description/AxisDescription.java	(revision 486006)
+++ kernel/src/org/apache/axis2/description/AxisDescription.java	(working copy)
@@ -79,11 +79,13 @@
 
     public Parameter getParameter(String name) {
         Parameter parameter = parameterInclude.getParameter(name);
-        if (parameter == null && parent != null) {
+        if(parameter!=null){
+            return  parameter;
+        }
+        if(parent != null) {
             return parent.getParameter(name);
-        } else {
-            return parameter;
         }
+        return null;
     }
 
     public Object getParameterValue(String name) {
Index: kernel/src/org/apache/axis2/description/OutOnlyAxisOperation.java
===================================================================
--- kernel/src/org/apache/axis2/description/OutOnlyAxisOperation.java	(revision 486006)
+++ kernel/src/org/apache/axis2/description/OutOnlyAxisOperation.java	(working copy)
@@ -15,9 +15,7 @@
 */
 package org.apache.axis2.description;
 
-import org.apache.axiom.om.OMElement;
 import org.apache.axis2.AxisFault;
-import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.client.OperationClient;
 import org.apache.axis2.client.Options;
 import org.apache.axis2.client.async.Callback;
@@ -27,15 +25,11 @@
 import org.apache.axis2.context.ServiceContext;
 import org.apache.axis2.engine.AxisEngine;
 import org.apache.axis2.i18n.Messages;
-import org.apache.axis2.util.UUIDGenerator;
-import org.apache.axis2.util.TargetResolver;
 import org.apache.axis2.wsdl.WSDLConstants;
 
 import javax.xml.namespace.QName;
 import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
 
 public class OutOnlyAxisOperation extends AxisOperation {
 
@@ -162,55 +156,17 @@
 /**
  * MEP client for moi.
  */
-class OutOnlyAxisOperationClient implements OperationClient {
-    OutOnlyAxisOperation axisOp;
+class OutOnlyAxisOperationClient extends OperationClient {
 
-    ServiceContext sc;
+    private MessageContext mc;
 
-    Options options;
-
-    MessageContext mc;
-
-    OperationContext oc;
-
-    /*
-    * indicates whether the MEP execution has completed (and hence ready for
-    * resetting)
-    */
-    boolean completed;
-
     OutOnlyAxisOperationClient(OutOnlyAxisOperation axisOp, ServiceContext sc,
                                Options options) {
-        this.axisOp = axisOp;
-        this.sc = sc;
-        this.options = options;
-        this.completed = false;
-        oc = new OperationContext(axisOp, sc);
+        super(axisOp, sc, options);
     }
 
-    /**
-     * Sets the options that should be used for this particular client. This
-     * resets the entire set of options to use the new options - so you'd lose
-     * any option cascading that may have been set up.
-     *
-     * @param options the options
-     */
-    public void setOptions(Options options) {
-        this.options = options;
-    }
 
     /**
-     * Returns the options used by this client. If you want to set a single
-     * option, then the right way is to do getOptions() and set specific
-     * options.
-     *
-     * @return Returns the options, which will never be null.
-     */
-    public Options getOptions() {
-        return options;
-    }
-
-    /**
      * Adds a message context to the client for processing. This method must not
      * process the message - it only records it in the MEP client. Processing
      * only occurs when execute() is called.
@@ -260,48 +216,6 @@
     }
 
     /**
-     * Create a message ID for the given message context if needed. If user gives an option with
-     * MessageID then just copy that into MessageContext , and with that there can be multiple
-     * message with same MessageID unless user call setOption for each invocation.
-     * <p/>
-     * If user want to give message ID then the better way is to set the message ID in the option and
-     * call setOption for each invocation then the right thing will happen.
-     * <p/>
-     * If user does not give a message ID then the new one will be created and set that into Message
-     * Context.
-     *
-     * @param mc the message context whose id is to be set
-     */
-    private void setMessageID(MessageContext mc) {
-        // now its the time to put the parameters set by the user in to the
-        // correct places and to the
-        // if there is no message id still, set a new one.
-        String messageId = options.getMessageId();
-        if (messageId == null || "".equals(messageId)) {
-            messageId = UUIDGenerator.getUUID();
-        }
-        mc.setMessageID(messageId);
-    }
-
-    private void addReferenceParameters(MessageContext msgctx) {
-        EndpointReference to = msgctx.getTo();
-        if (options.isManageSession()) {
-            EndpointReference tepr = sc.getTargetEPR();
-            if (tepr != null) {
-                Map map = tepr.getAllReferenceParameters();
-                Iterator valuse = map.values().iterator();
-                while (valuse.hasNext()) {
-                    Object refparaelement = valuse.next();
-                    if (refparaelement instanceof OMElement) {
-                        to.addReferenceParameter((OMElement) refparaelement);
-                    }
-                }
-            }
-        }
-    }
-
-
-    /**
      * Executes the MEP. What this does depends on the specific MEP client. The
      * basic idea is to have the MEP client execute and do something with the
      * messages that have been added to it so far. For example, if its an Out-In
@@ -319,36 +233,12 @@
             throw new AxisFault(Messages.getMessage("mepiscomplted"));
         }
         ConfigurationContext cc = sc.getConfigurationContext();
-
-        // set options on the message context
-        if (mc.getSoapAction() == null || "".equals(mc.getSoapAction())) {
-            mc.setSoapAction(options.getAction());
-        }
-        mc.setOptions(options);
-        mc.setAxisMessage(axisOp.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));
-
-        // do Target Resolution
-        TargetResolver targetResolver = cc.getAxisConfiguration().getTargetResolverChain();
-        if(targetResolver != null){
-            targetResolver.resolveTarget(mc);
-        }
-
+        prepareMessageContext(cc, mc);
         // setting message ID if it null
-        // if the transport to use for sending is not specified, try to find it
-        // from the URL
-        TransportOutDescription senderTransport = options.getTransportOut();
-        if (senderTransport == null) {
-            EndpointReference toEPR = (options.getTo() != null) ? options
-                    .getTo() : mc.getTo();
-            senderTransport = ClientUtils.inferOutTransport(cc
-                    .getAxisConfiguration(), toEPR, mc);
-        }
-        mc.setTransportOut(senderTransport);
 
         // create the operation context for myself
         OperationContext oc = new OperationContext(axisOp, sc);
         oc.addMessageContext(mc);
-        addReferenceParameters(mc);
         // ship it out
         AxisEngine engine = new AxisEngine(cc);
         if (!block) {
@@ -358,32 +248,4 @@
         // all done
         completed = true;
     }
-
-    /**
-     * Resets the MEP client to a clean status after the MEP has completed. This
-     * is how you can reuse a MEP client. NOTE: this does not reset the options;
-     * only the internal state so the client can be used again.
-     *
-     * @throws AxisFault if reset is called before the MEP client has completed an
-     *                   interaction.
-     */
-    public void reset() throws AxisFault {
-        if (!completed) {
-            throw new AxisFault(Messages.getMessage("cannotreset"));
-        }
-        mc = null;
-        completed = false;
-    }
-
-    public void complete(MessageContext msgCtxt) throws AxisFault {
-        TransportOutDescription trsout = msgCtxt.getTransportOut();
-        if (trsout != null) {
-            trsout.getSender().cleanup(msgCtxt);
-        }
-    }
-
-    public OperationContext getOperationContext() {
-        return oc;
-    }
-
 }
Index: kernel/src/org/apache/axis2/description/FlowIncludeImpl.java
===================================================================
--- kernel/src/org/apache/axis2/description/FlowIncludeImpl.java	(revision 486006)
+++ kernel/src/org/apache/axis2/description/FlowIncludeImpl.java	(working copy)
@@ -1,102 +0,0 @@
-/*
-* Copyright 2004,2005 The Apache Software Foundation.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-
-package org.apache.axis2.description;
-
-/**
- * Class FlowIncludeImpl
- */
-public class FlowIncludeImpl implements FlowInclude {
-
-    /**
-     * Field fault
-     */
-    private Flow In_fault;
-    private Flow Out_fault;
-
-    /**
-     * Field in
-     */
-    private Flow in;
-
-    /**
-     * Field out
-     */
-    private Flow out;
-
-    /**
-     * Method getFaultInFlow.
-     *
-     * @return Returns Flow.
-     */
-    public Flow getFaultInFlow() {
-        return In_fault;
-    }
-
-    public Flow getFaultOutFlow() {
-        return this.Out_fault;
-    }
-
-    /**
-     * Method getInFlow.
-     *
-     * @return Returns Flow.
-     */
-    public Flow getInFlow() {
-        return in;
-    }
-
-    /**
-     * Method getOutFlow. 
-     *
-     * @return Returns Flow.
-     */
-    public Flow getOutFlow() {
-        return out;
-    }
-
-    /**
-     * Method setFaultInFlow.
-     *
-     * @param flow
-     */
-    public void setFaultInFlow(Flow flow) {
-        this.In_fault = flow;
-    }
-
-    public void setFaultOutFlow(Flow faultFlow) {
-        this.Out_fault = faultFlow;
-    }
-
-    /**
-     * Method setInFlow.
-     *
-     * @param flow
-     */
-    public void setInFlow(Flow flow) {
-        this.in = flow;
-    }
-
-    /**
-     * Method setOutFlow.
-     *
-     * @param flow
-     */
-    public void setOutFlow(Flow flow) {
-        this.out = flow;
-    }
-}
Index: kernel/src/org/apache/axis2/context/AbstractContext.java
===================================================================
--- kernel/src/org/apache/axis2/context/AbstractContext.java	(revision 486006)
+++ kernel/src/org/apache/axis2/context/AbstractContext.java	(working copy)
@@ -17,7 +17,6 @@
 
 package org.apache.axis2.context;
 
-import java.util.Date;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
Index: kernel/src/org/apache/axis2/context/MessageContext.java
===================================================================
--- kernel/src/org/apache/axis2/context/MessageContext.java	(revision 486006)
+++ kernel/src/org/apache/axis2/context/MessageContext.java	(working copy)
@@ -68,7 +68,7 @@
 
     public static final String TRANSPORT_HEADERS = "TRANSPORT_HEADERS";
 
-    public Attachments attachments = new Attachments();
+    public Attachments attachments;
 
     /**
      * Field TRANSPORT_OUT
@@ -1072,10 +1072,16 @@
     }
 
     public Attachments getAttachmentMap() {
+        if (attachments == null) {
+            attachments = new Attachments();
+        }
         return attachments;
     }
 
     public void addAttachment(String contentID, DataHandler dataHandler) {
+        if (attachments == null) {
+            attachments = new Attachments();
+        }
         attachments.addDataHandler(contentID, dataHandler);
     }
 
@@ -1086,6 +1092,9 @@
     }
 
     public DataHandler getAttachment(String contentID) {
+        if (attachments == null) {
+            attachments = new Attachments();
+        }
         return attachments.getDataHandler(contentID);
     }
 }
Index: kernel/src/org/apache/axis2/context/ConfigurationContext.java
===================================================================
--- kernel/src/org/apache/axis2/context/ConfigurationContext.java	(revision 486006)
+++ kernel/src/org/apache/axis2/context/ConfigurationContext.java	(working copy)
@@ -119,7 +119,7 @@
                 if (serviceGroupContext == null) {
                     AxisServiceGroup axisServiceGroup = messageContext.getAxisServiceGroup();
                     if (axisServiceGroup == null) {
-                        axisServiceGroup = (AxisServiceGroup) messageContext.getAxisService().getParent();
+                        axisServiceGroup = (AxisServiceGroup) axisService.getParent();
                     }
                     serviceGroupContext = new ServiceGroupContext(messageContext.getConfigurationContext(),
                             axisServiceGroup);
@@ -134,7 +134,7 @@
                 serviceGroupContext =
                         getServiceGroupContext(serviceGroupContextId, messageContext);
                 serviceContext =
-                        serviceGroupContext.getServiceContext(messageContext.getAxisService());
+                        serviceGroupContext.getServiceContext(axisService);
             } else {
 
                 // either the key is null or no SGC is found from the give key
@@ -144,10 +144,10 @@
                 }
 
                 if (messageContext.getAxisService() != null) {
-                    AxisServiceGroup axisServiceGroup = (AxisServiceGroup) messageContext.getAxisService().getParent();
+                    AxisServiceGroup axisServiceGroup = (AxisServiceGroup) axisService.getParent();
 
                     serviceGroupContext = new ServiceGroupContext(this, axisServiceGroup);
-                    serviceContext = serviceGroupContext.getServiceContext(messageContext.getAxisService());
+                    serviceContext = serviceGroupContext.getServiceContext(axisService);
 
                     // set the serviceGroupContextID
                     serviceGroupContext.setId(serviceGroupContextId);
@@ -191,13 +191,13 @@
      * @param messageID
      * @param mepContext
      */
-    public synchronized void registerOperationContext(String messageID,
-                                                      OperationContext mepContext) {
+    public void registerOperationContext(String messageID,
+                                         OperationContext mepContext) {
         mepContext.setKey(messageID);
         this.operationContextMap.put(messageID, mepContext);
     }
 
-    public synchronized void registerServiceGroupContext(ServiceGroupContext serviceGroupContext) {
+    public void registerServiceGroupContext(ServiceGroupContext serviceGroupContext) {
         String id = serviceGroupContext.getId();
 
         if (serviceGroupContextMap.get(id) == null) {
@@ -210,7 +210,7 @@
         cleanupServiceGroupContexts();
     }
 
-    public synchronized void addServiceGroupContextintoApplicatoionScopeTable(
+    public void addServiceGroupContextintoApplicatoionScopeTable(
             ServiceGroupContext serviceGroupContext) {
         applicationSessionServiceGroupContextTable.put(
                 serviceGroupContext.getDescription().getServiceGroupName(), serviceGroupContext);
@@ -247,22 +247,19 @@
         return null;
     }
 
-    public synchronized ServiceGroupContext getServiceGroupContext(String serviceGroupContextId,
-                                                                   MessageContext msgContext) {
-        ServiceGroupContext serviceGroupContext = null;
-        if (serviceGroupContextMap != null) {
-            serviceGroupContext = (ServiceGroupContext) serviceGroupContextMap.get(serviceGroupContextId);
-            if (serviceGroupContext != null) {
-                serviceGroupContext.touch();
-            }
+    public ServiceGroupContext getServiceGroupContext(String serviceGroupContextId,
+                                                      MessageContext msgContext) {
+        ServiceGroupContext serviceGroupContext;
+        serviceGroupContext = (ServiceGroupContext) serviceGroupContextMap.get(serviceGroupContextId);
+        if (serviceGroupContext != null) {
+            serviceGroupContext.touch();
         }
         if (serviceGroupContext == null
-                && msgContext != null
                 && msgContext.getSessionContext() != null) {
             serviceGroupContext = msgContext.getSessionContext().getServiceGroupContext(
                     serviceGroupContextId);
         }
-        if (serviceGroupContext == null && msgContext != null) {
+        if (serviceGroupContext == null) {
             AxisService axisService = msgContext.getAxisService();
             if (axisService != null) {
                 AxisServiceGroup asg = (AxisServiceGroup) axisService.getParent();
@@ -324,18 +321,16 @@
     }
 
     private void cleanupServiceGroupContexts() {
-        synchronized (serviceGroupContextMap) {
-            long currentTime = new Date().getTime();
-            Iterator sgCtxtMapKeyIter = serviceGroupContextMap.keySet().iterator();
-            while (sgCtxtMapKeyIter.hasNext()) {
-                String sgCtxtId = (String) sgCtxtMapKeyIter.next();
-                ServiceGroupContext serviceGroupContext =
-                        (ServiceGroupContext) serviceGroupContextMap.get(sgCtxtId);
-                if ((currentTime - serviceGroupContext.getLastTouchedTime()) >
-                        getServiceGroupContextTimoutInterval()) {
-                    sgCtxtMapKeyIter.remove();
-                    cleanupServiceContexts(serviceGroupContext);
-                }
+        long currentTime = new Date().getTime();
+        Iterator sgCtxtMapKeyIter = serviceGroupContextMap.keySet().iterator();
+        while (sgCtxtMapKeyIter.hasNext()) {
+            String sgCtxtId = (String) sgCtxtMapKeyIter.next();
+            ServiceGroupContext serviceGroupContext =
+                    (ServiceGroupContext) serviceGroupContextMap.get(sgCtxtId);
+            if ((currentTime - serviceGroupContext.getLastTouchedTime()) >
+                    getServiceGroupContextTimoutInterval()) {
+                sgCtxtMapKeyIter.remove();
+                cleanupServiceContexts(serviceGroupContext);
             }
         }
     }
Index: kernel/src/org/apache/axis2/receivers/RawXMLINOutAsyncMessageReceiver.java
===================================================================
--- kernel/src/org/apache/axis2/receivers/RawXMLINOutAsyncMessageReceiver.java	(revision 486006)
+++ kernel/src/org/apache/axis2/receivers/RawXMLINOutAsyncMessageReceiver.java	(working copy)
@@ -41,9 +41,9 @@
  */
 public class RawXMLINOutAsyncMessageReceiver extends AbstractInOutAsyncMessageReceiver {
 
-    private Method findOperation(AxisOperation op, Class ImplClass) {
+    private Method findOperation(AxisOperation op, Class implClass) {
         String methodName = op.getName().getLocalPart();
-        Method[] methods = ImplClass.getMethods();
+        Method[] methods = implClass.getMethods();
 
         for (int i = 0; i < methods.length; i++) {
             if (methods[i].getName().equals(methodName) &&
@@ -73,10 +73,10 @@
             Object obj = getTheImplementationObject(msgContext);
 
             // find the WebService method
-            Class ImplClass = obj.getClass();
+            Class implClass = obj.getClass();
 
-            AxisOperation opDesc = msgContext.getOperationContext().getAxisOperation();
-            Method method = findOperation(opDesc, ImplClass);
+            AxisOperation opDesc = msgContext.getAxisOperation();
+            Method method = findOperation(opDesc, implClass);
 
             if (method != null) {
                 OMElement result = (OMElement) method.invoke(
Index: kernel/src/org/apache/axis2/receivers/RawXMLINOutMessageReceiver.java
===================================================================
--- kernel/src/org/apache/axis2/receivers/RawXMLINOutMessageReceiver.java	(revision 486006)
+++ kernel/src/org/apache/axis2/receivers/RawXMLINOutMessageReceiver.java	(working copy)
@@ -26,8 +26,6 @@
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.engine.MessageReceiver;
 import org.apache.axis2.i18n.Messages;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 
 import java.lang.reflect.Method;
 
@@ -45,11 +43,9 @@
 public class RawXMLINOutMessageReceiver extends AbstractInOutSyncMessageReceiver
         implements MessageReceiver {
 
-    private static final Log log = LogFactory.getLog(RawXMLINOutMessageReceiver.class);
-
-    private Method findOperation(AxisOperation op, Class ImplClass) {
+    private Method findOperation(AxisOperation op, Class implClass) {
         String methodName = op.getName().getLocalPart();
-        Method[] methods = ImplClass.getMethods();
+        Method[] methods = implClass.getMethods();
 
         for (int i = 0; i < methods.length; i++) {
             if (methods[i].getName().equals(methodName) &&
@@ -79,10 +75,10 @@
             Object obj = getTheImplementationObject(msgContext);
 
             // find the WebService method
-            Class ImplClass = obj.getClass();
+            Class implClass = obj.getClass();
 
-            AxisOperation opDesc = msgContext.getOperationContext().getAxisOperation();
-            Method method = findOperation(opDesc, ImplClass);
+            AxisOperation opDesc = msgContext.getAxisOperation();
+            Method method = findOperation(opDesc, implClass);
 
             if (method != null) {
                 OMElement result = (OMElement) method.invoke(
Index: kernel/src/org/apache/axis2/receivers/RawXMLINOnlyMessageReceiver.java
===================================================================
--- kernel/src/org/apache/axis2/receivers/RawXMLINOnlyMessageReceiver.java	(revision 486006)
+++ kernel/src/org/apache/axis2/receivers/RawXMLINOnlyMessageReceiver.java	(working copy)
@@ -23,8 +23,6 @@
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.engine.MessageReceiver;
 import org.apache.axis2.i18n.Messages;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 
 import java.lang.reflect.Method;
 
@@ -42,11 +40,9 @@
 public class RawXMLINOnlyMessageReceiver extends AbstractInMessageReceiver
         implements MessageReceiver {
 
-    private static final Log log = LogFactory.getLog(RawXMLINOnlyMessageReceiver.class);
-
-    private Method findOperation(AxisOperation op, Class ImplClass) {
+    private Method findOperation(AxisOperation op, Class implClass) {
         String methodName = op.getName().getLocalPart();
-        Method[] methods = ImplClass.getMethods();
+        Method[] methods = implClass.getMethods();
 
         for (int i = 0; i < methods.length; i++) {
             if (methods[i].getName().equals(methodName) &&
@@ -74,10 +70,10 @@
             Object obj = getTheImplementationObject(msgContext);
 
             // find the WebService method
-            Class ImplClass = obj.getClass();
+            Class implClass = obj.getClass();
 
-            AxisOperation op = msgContext.getOperationContext().getAxisOperation();
-            Method method = findOperation(op, ImplClass);
+            AxisOperation op = msgContext.getAxisOperation();
+            Method method = findOperation(op, implClass);
 
             if (method != null) {
                 method.invoke(
Index: kernel/src/org/apache/axis2/transport/http/AxisServlet.java
===================================================================
--- kernel/src/org/apache/axis2/transport/http/AxisServlet.java	(revision 486006)
+++ kernel/src/org/apache/axis2/transport/http/AxisServlet.java	(working copy)
@@ -62,7 +62,6 @@
 public class AxisServlet extends HttpServlet implements TransportListener {
 
     private static final Log log = LogFactory.getLog(AxisServlet.class);
-    private static final long serialVersionUID = -2085869393709833372L;
     public static final String CONFIGURATION_CONTEXT = "CONFIGURATION_CONTEXT";
     public static final String SESSION_ID = "SessionId";
     protected transient ConfigurationContext configContext;
@@ -104,10 +103,8 @@
         msgContext.setFrom(new EndpointReference(req.getRemoteAddr()));
         msgContext.setProperty(MessageContext.TRANSPORT_HEADERS,
                 getTransportHeaders(req));
-        msgContext.setProperty(Constants.Configuration.TRANSPORT_IN_URL, req.getRequestURL().toString());
         msgContext.setIncomingTransportName(Constants.TRANSPORT_HTTP);
         msgContext.setProperty(HTTPConstants.MC_HTTP_SERVLETREQUEST, req);
-//        msgContext.setProperty(HTTPConstants.MC_HTTP_SERVLETCONTEXT, servletConfig.getServletContext());
         return msgContext;
     }
 
@@ -247,7 +244,6 @@
 
             try {
                 // adding ServletContext into msgContext;
-                out = res.getOutputStream();
                 HTTPTransportUtils.processHTTPPostRequest(msgContext, req.getInputStream(), out,
                         req.getContentType(), req.getHeader(HTTPConstants.HEADER_SOAP_ACTION),
                         req.getRequestURL().toString());
Index: kernel/src/org/apache/axis2/transport/http/HTTPWorker.java
===================================================================
--- kernel/src/org/apache/axis2/transport/http/HTTPWorker.java	(revision 486006)
+++ kernel/src/org/apache/axis2/transport/http/HTTPWorker.java	(working copy)
@@ -173,7 +173,7 @@
                     if (schema != null) {
                         EntityTemplate entity = new EntityTemplate(new ContentProducer() {
 
-                            public void writeTo(final OutputStream outstream) throws IOException {
+                            public void writeTo(final OutputStream outstream) {
                                 schema.write(outstream);
                             }
 
Index: kernel/src/org/apache/axis2/transport/http/HTTPTransportUtils.java
===================================================================
--- kernel/src/org/apache/axis2/transport/http/HTTPTransportUtils.java	(revision 486006)
+++ kernel/src/org/apache/axis2/transport/http/HTTPTransportUtils.java	(working copy)
@@ -160,8 +160,12 @@
     private static final int VERSION_SOAP11 = 1;
     private static final int VERSION_SOAP12 = 2;
 
-    public static void processHTTPPostRequest(MessageContext msgContext, InputStream in,
-                                              OutputStream out, String contentType, String soapActionHeader, String requestURI)
+    public static void processHTTPPostRequest(MessageContext msgContext,
+                                              InputStream in,
+                                              OutputStream out,
+                                              String contentType,
+                                              String soapActionHeader,
+                                              String requestURI)
             throws AxisFault {
 
         int soapVersion = VERSION_UNKNOWN;
Index: kernel/src/org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java
===================================================================
--- kernel/src/org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java	(revision 486006)
+++ kernel/src/org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java	(working copy)
@@ -175,7 +175,6 @@
             msgContext.setTransportOut(transportOut);
             msgContext.setServiceGroupContextId(UUIDGenerator.getUUID());
             msgContext.setServerSide(true);
-            msgContext.setProperty(Constants.Configuration.TRANSPORT_IN_URL, reqline.getUri());
 
             // set the transport Headers
             HashMap headerMap = new HashMap();
Index: kernel/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java
===================================================================
--- kernel/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java	(revision 486006)
+++ kernel/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java	(working copy)
@@ -23,7 +23,6 @@
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.util.JavaUtils;
-import org.apache.axis2.addressing.AddressingConstants;
 import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.MessageContext;
@@ -266,8 +265,6 @@
             }
         }
 
-        format.setDoOptimize(msgContext.isDoingMTOM());
-        format.setDoingSWA(msgContext.isDoingSwA());
         format.setAutoCloseWriter(true);
         if (!(msgContext.isDoingMTOM()) & (msgContext.isDoingSwA())
                 & !(msgContext.isDoingREST())) {
Index: kernel/src/org/apache/axis2/engine/InstanceDispatcher.java
===================================================================
--- kernel/src/org/apache/axis2/engine/InstanceDispatcher.java	(revision 486006)
+++ kernel/src/org/apache/axis2/engine/InstanceDispatcher.java	(working copy)
@@ -101,8 +101,6 @@
                         msgContext);
             }
         }
-        // setting myEPR
-        String transportURL = (String) msgContext.getProperty(Constants.Configuration.TRANSPORT_IN_URL);
         if (serviceContext != null) {
             serviceContext.setMyEPR(msgContext.getTo());
         }
Index: kernel/src/org/apache/axis2/engine/RequestURIBasedDispatcher.java
===================================================================
--- kernel/src/org/apache/axis2/engine/RequestURIBasedDispatcher.java	(revision 486006)
+++ kernel/src/org/apache/axis2/engine/RequestURIBasedDispatcher.java	(working copy)
@@ -20,6 +20,7 @@
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.HandlerDescription;
@@ -84,12 +85,13 @@
             }
             String filePart = toEPR.getAddress();
             //REVIEW: (nagy) Parsing the RequestURI will also give us the operationName if present, so we could conceivably store it in the MessageContext, but doing so and retrieving it is probably no faster than simply reparsing the URI
+            ConfigurationContext configurationContext = messageContext.getConfigurationContext();
             String[] values = Utils.parseRequestURLForServiceAndOperation(filePart,
-                    messageContext.getConfigurationContext().getServiceContextPath());
+                    configurationContext.getServiceContextPath());
 
             if ((values.length >= 1) && (values[0] != null)) {
                 AxisConfiguration registry =
-                        messageContext.getConfigurationContext().getAxisConfiguration();
+                        configurationContext.getAxisConfiguration();
 
                 return registry.getService(values[0]);
             } else {
Index: kernel/src/org/apache/axis2/engine/DispatchPhase.java
===================================================================
--- kernel/src/org/apache/axis2/engine/DispatchPhase.java	(revision 486006)
+++ kernel/src/org/apache/axis2/engine/DispatchPhase.java	(working copy)
@@ -1,7 +1,6 @@
 package org.apache.axis2.engine;
 
 import org.apache.axis2.AxisFault;
-import org.apache.axis2.Constants;
 import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.addressing.AddressingHelper;
 import org.apache.axis2.context.MessageContext;
@@ -32,8 +31,6 @@
 
 public class DispatchPhase extends Phase {
 
-    private static final long serialVersionUID = -6596799621473224363L;
-
     public DispatchPhase() {
     }
 
Index: kernel/src/org/apache/axis2/engine/AddressingBasedDispatcher.java
===================================================================
--- kernel/src/org/apache/axis2/engine/AddressingBasedDispatcher.java	(revision 486006)
+++ kernel/src/org/apache/axis2/engine/AddressingBasedDispatcher.java	(working copy)
@@ -20,10 +20,7 @@
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.addressing.AddressingConstants;
 import org.apache.axis2.addressing.EndpointReference;
-import org.apache.axis2.context.MessageContext;
-import org.apache.axis2.context.OperationContext;
-import org.apache.axis2.context.ServiceContext;
-import org.apache.axis2.context.ServiceGroupContext;
+import org.apache.axis2.context.*;
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.HandlerDescription;
@@ -76,8 +73,9 @@
                 log.debug(Messages.getMessage("checkingserviceforepr", address));
             }
             QName serviceName;
+            ConfigurationContext configurationContext = messageContext.getConfigurationContext();
             String[] values = Utils.parseRequestURLForServiceAndOperation(address,
-                    messageContext.getConfigurationContext().getServiceContextPath());
+                    configurationContext.getServiceContextPath());
             if (values == null) {
                 return null;
             }
@@ -89,7 +87,7 @@
                 serviceName = new QName(values[0]);
 
                 AxisConfiguration registry =
-                        messageContext.getConfigurationContext().getAxisConfiguration();
+                        configurationContext.getAxisConfiguration();
 
                 return registry.getService(serviceName.getLocalPart());
             }
Index: kernel/src/org/apache/axis2/engine/SOAPMessageBodyBasedDispatcher.java
===================================================================
--- kernel/src/org/apache/axis2/engine/SOAPMessageBodyBasedDispatcher.java	(revision 486006)
+++ kernel/src/org/apache/axis2/engine/SOAPMessageBodyBasedDispatcher.java	(working copy)
@@ -21,6 +21,7 @@
 import org.apache.axiom.om.OMNamespace;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.HandlerDescription;
@@ -45,7 +46,7 @@
 
     public AxisOperation findOperation(AxisService service, MessageContext messageContext)
             throws AxisFault {
-        QName operationName = null;
+        QName operationName ;
         
         OMElement bodyFirstChild = messageContext.getEnvelope().getBody().getFirstElement();
 
@@ -68,7 +69,7 @@
      * @see org.apache.axis2.engine.AbstractDispatcher#findService(org.apache.axis2.context.MessageContext)
      */
     public AxisService findService(MessageContext messageContext) throws AxisFault {
-        String serviceName = null;
+        String serviceName ;
         
         OMElement bodyFirstChild = messageContext.getEnvelope().getBody().getFirstElement();
 
@@ -83,14 +84,15 @@
                             "Checking for Service using SOAP message body's first child's namespace : "
                                     + filePart);
                 }
+                ConfigurationContext configurationContext = messageContext.getConfigurationContext();
                 String[] values = Utils.parseRequestURLForServiceAndOperation(filePart,
-                        messageContext.getConfigurationContext().getServiceContextPath());
+                        configurationContext.getServiceContextPath());
 
                 if (values[0] != null) {
                     serviceName = values[0];
 
                     AxisConfiguration registry =
-                            messageContext.getConfigurationContext().getAxisConfiguration();
+                            configurationContext.getAxisConfiguration();
 
                     return registry.getService(serviceName);
                 }
Index: kernel/src/org/apache/axis2/client/OperationClient.java
===================================================================
--- kernel/src/org/apache/axis2/client/OperationClient.java	(revision 486006)
+++ kernel/src/org/apache/axis2/client/OperationClient.java	(working copy)
@@ -16,11 +16,25 @@
 
 package org.apache.axis2.client;
 
+import org.apache.axiom.om.OMElement;
 import org.apache.axis2.AxisFault;
+import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.client.async.Callback;
+import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.context.OperationContext;
+import org.apache.axis2.context.ServiceContext;
+import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.TransportOutDescription;
+import org.apache.axis2.description.ClientUtils;
+import org.apache.axis2.i18n.Messages;
+import org.apache.axis2.util.UUIDGenerator;
+import org.apache.axis2.util.TargetResolver;
+import org.apache.axis2.wsdl.WSDLConstants;
 
+import java.util.Iterator;
+import java.util.Map;
+
 /**
  * An operation client is the way an advanced user interacts with Axis2. Actual
  * operation clients understand a specific MEP and hence their behavior is
@@ -31,7 +45,34 @@
  * in a new message being created, then if a message receiver is registered with
  * the client then the message will be delivered to that client.
  */
-public interface OperationClient {
+public abstract class OperationClient {
+
+    protected AxisOperation axisOp;
+
+    protected ServiceContext sc;
+
+    protected Options options;
+
+    protected OperationContext oc;
+
+    protected Callback callback;
+
+    /*
+     * indicates whether the MEP execution has completed (and hence ready for
+     * resetting)
+     */
+    protected boolean completed;
+
+    protected OperationClient(AxisOperation axisOp, ServiceContext sc,
+                              Options options) {
+        this.axisOp = axisOp;
+        this.sc = sc;
+        this.options = options;
+        this.completed = false;
+        this.oc = new OperationContext(axisOp);
+        this.oc.setParent(this.sc);
+    }
+
     /**
      * Sets the options that should be used for this particular client. This
      * resets the entire set of options to use the new options - so you'd lose
@@ -39,7 +80,9 @@
      *
      * @param options the options
      */
-    public void setOptions(Options options);
+    public void setOptions(Options options) {
+        this.options = options;
+    }
 
     /**
      * Return the options used by this client. If you want to set a single
@@ -48,7 +91,9 @@
      *
      * @return the options, which will never be null.
      */
-    public Options getOptions();
+    public Options getOptions() {
+        return options;
+    }
 
     /**
      * Add a message context to the client for processing. This method must not
@@ -58,7 +103,7 @@
      * @param messageContext the message context
      * @throws AxisFault if this is called inappropriately.
      */
-    public void addMessageContext(MessageContext messageContext) throws AxisFault;
+    public abstract void addMessageContext(MessageContext messageContext) throws AxisFault;
 
     /**
      * Return a message from the client - will return null if the requested
@@ -68,7 +113,7 @@
      * @return the desired message context or null if its not available.
      * @throws AxisFault if the message label is invalid
      */
-    public MessageContext getMessageContext(String messageLabel)
+    public abstract MessageContext getMessageContext(String messageLabel)
             throws AxisFault;
 
     /**
@@ -81,7 +126,7 @@
      * @param callback the callback to be used when the client decides its time to
      *                 use it
      */
-    public void setCallback(Callback callback);
+    public abstract void setCallback(Callback callback);
 
     /**
      * Execute the MEP. What this does depends on the specific operation client.
@@ -97,7 +142,7 @@
      * @throws AxisFault if something goes wrong during the execution of the operation
      *                   client.
      */
-    public void execute(boolean block) throws AxisFault;
+    public abstract void execute(boolean block) throws AxisFault;
 
     /**
      * Reset the operation client to a clean status after the MEP has completed.
@@ -107,24 +152,110 @@
      * @throws AxisFault if reset is called before the MEP client has completed an
      *                   interaction.
      */
-    public void reset() throws AxisFault;
+    public void reset() throws AxisFault {
+        if (!completed) {
+            throw new AxisFault(Messages.getMessage("cannotreset"));
+        }
+        oc = null;
+        completed = false;
+    }
 
+
     /**
-     * To close the transport if necessary , can call this method. The main 
-     * usage of this method is when client uses two tarnsports for sending and 
-     * receiving , and we need to remove entries for waiting calls in the 
+     * To close the transport if necessary , can call this method. The main
+     * usage of this method is when client uses two tarnsports for sending and
+     * receiving , and we need to remove entries for waiting calls in the
      * transport listener queue.
-     * Note : DO NOT call this method if you are not using two transports to 
+     * Note : DO NOT call this method if you are not using two transports to
      * send and receive
      *
      * @param msgCtxt : MessageContext# which has all the transport information
      * @throws AxisFault : throws AxisFault if something goes wrong
      */
-    public void complete(MessageContext msgCtxt) throws AxisFault;
+    public void complete(MessageContext msgCtxt) throws AxisFault {
+        TransportOutDescription trsout = msgCtxt.getTransportOut();
+        if (trsout != null) {
+            trsout.getSender().cleanup(msgCtxt);
+        }
+    }
 
+
     /**
      * To get the operation context of the operation client
+     *
      * @return OperationContext
      */
-    public OperationContext getOperationContext();
+    public OperationContext getOperationContext() {
+        return oc;
+    }
+
+    /**
+     * Create a message ID for the given message context if needed. If user gives an option with
+     * MessageID then just copy that into MessageContext , and with that there can be multiple
+     * message with same MessageID unless user call setOption for each invocation.
+     * <p/>
+     * If user want to give message ID then the better way is to set the message ID in the option and
+     * call setOption for each invocation then the right thing will happen.
+     * <p/>
+     * If user does not give a message ID then the new one will be created and set that into Message
+     * Context.
+     *
+     * @param mc the message context whose id is to be set
+     */
+    protected void setMessageID(MessageContext mc) {
+        // now its the time to put the parameters set by the user in to the
+        // correct places and to the
+        // if there is no message id still, set a new one.
+        String messageId = options.getMessageId();
+        if (messageId == null || "".equals(messageId)) {
+            messageId = UUIDGenerator.getUUID();
+        }
+        mc.setMessageID(messageId);
+    }
+
+    protected void addReferenceParameters(MessageContext msgctx) {
+        EndpointReference to = msgctx.getTo();
+        if (options.isManageSession()) {
+            EndpointReference tepr = sc.getTargetEPR();
+            if (tepr != null) {
+                Map map = tepr.getAllReferenceParameters();
+                if (map != null) {
+                    Iterator valuse = map.values().iterator();
+                    while (valuse.hasNext()) {
+                        Object refparaelement = valuse.next();
+                        if (refparaelement instanceof OMElement) {
+                            to.addReferenceParameter((OMElement) refparaelement);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    protected void prepareMessageContext(ConfigurationContext cc, MessageContext mc)  throws AxisFault{
+        // set options on the message context
+        if (mc.getSoapAction() == null || "".equals(mc.getSoapAction())) {
+            mc.setSoapAction(options.getAction());
+        }
+        mc.setOptions(options);
+        mc.setAxisMessage(axisOp.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));
+
+        // do Target Resolution
+        TargetResolver targetResolver = cc.getAxisConfiguration().getTargetResolverChain();
+        if (targetResolver != null) {
+            targetResolver.resolveTarget(mc);
+        }
+        // if the transport to use for sending is not specified, try to find it
+        // from the URL
+        TransportOutDescription senderTransport = options.getTransportOut();
+        if (senderTransport == null) {
+            EndpointReference toEPR = (options.getTo() != null) ? options
+                    .getTo() : mc.getTo();
+            senderTransport = ClientUtils.inferOutTransport(cc
+                    .getAxisConfiguration(), toEPR, mc);
+        }
+        mc.setTransportOut(senderTransport);
+
+        addReferenceParameters(mc);
+    }
 }
