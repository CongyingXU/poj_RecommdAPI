Index: modules/kernel/src/org/apache/axis2/transport/http/HTTPWorker.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/HTTPWorker.java	(revision 525829)
+++ modules/kernel/src/org/apache/axis2/transport/http/HTTPWorker.java	(working copy)
@@ -16,49 +16,41 @@
 
 package org.apache.axis2.transport.http;
 
-import edu.emory.mathcs.backport.java.util.concurrent.CountDownLatch;
-import org.apache.axis2.AxisFault;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.URI;
+import java.util.HashMap;
+import java.util.Map;
+
 import org.apache.axis2.Constants;
-import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.context.OperationContext;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.engine.Handler.InvocationResponse;
 import org.apache.axis2.transport.RequestResponseTransport;
+import org.apache.axis2.transport.http.server.AxisHttpRequest;
+import org.apache.axis2.transport.http.server.AxisHttpResponse;
 import org.apache.axis2.transport.http.server.HttpUtils;
-import org.apache.axis2.transport.http.server.OutputBuffer;
 import org.apache.axis2.transport.http.server.Worker;
 import org.apache.axis2.transport.http.util.RESTUtil;
 import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpEntityEnclosingRequest;
 import org.apache.http.HttpException;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpVersion;
+import org.apache.http.HttpStatus;
 import org.apache.http.MethodNotSupportedException;
-import org.apache.http.entity.ContentProducer;
-import org.apache.http.entity.EntityTemplate;
-import org.apache.http.entity.StringEntity;
 import org.apache.http.message.BasicHeader;
-import org.apache.http.message.BasicStatusLine;
+import org.apache.http.protocol.HTTP;
+import org.apache.http.util.EncodingUtils;
 import org.apache.ws.commons.schema.XmlSchema;
 
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.URI;
-import java.util.HashMap;
-import java.util.Map;
-
 public class HTTPWorker implements Worker {
 
     public HTTPWorker() {
     }
 
     public void service(
-            final HttpRequest request,
-            final HttpResponse response,
+            final AxisHttpRequest request,
+            final AxisHttpResponse response,
             final MessageContext msgContext) throws HttpException, IOException {
 
         ConfigurationContext configurationContext = msgContext.getConfigurationContext();
@@ -66,41 +58,40 @@
         final String contextPath =
                 (servicePath.startsWith("/") ? servicePath : "/" + servicePath) + "/";
 
-        HttpVersion ver = request.getRequestLine().getHttpVersion();
-        String uri = request.getRequestLine().getUri();
-        String method = request.getRequestLine().getMethod();
+        String uri = request.getRequestURI();
+        String method = request.getMethod();
         String soapAction = HttpUtils.getSoapAction(request);
-        OutputBuffer outbuffer;
         InvocationResponse pi;
 
         if (method.equals(HTTPConstants.HEADER_GET)) {
             if (uri.equals("/favicon.ico")) {
-                response.setStatusLine(new BasicStatusLine(ver, 301, "Redirect"));
+                response.setStatus(HttpStatus.SC_MOVED_PERMANENTLY);
                 response.addHeader(new BasicHeader("Location", "http://ws.apache.org/favicon.ico"));
                 return;
             }
             if (!uri.startsWith(contextPath)) {
-                response.setStatusLine(new BasicStatusLine(ver, 301, "Redirect"));
+                response.setStatus(HttpStatus.SC_MOVED_PERMANENTLY);
                 response.addHeader(new BasicHeader("Location", contextPath));
                 return;
             }
             if (uri.endsWith("axis2/services/")) {
-                response.setStatusLine(new BasicStatusLine(ver, 200, "OK"));
                 String s = HTTPTransportReceiver.getServicesHTML(configurationContext);
-                StringEntity entity = new StringEntity(s);
-                entity.setContentType("text/html");
-                response.setEntity(entity);
+                response.setStatus(HttpStatus.SC_OK);
+                response.setContentType("text/html");
+                OutputStream out = response.getOutputStream();
+                out.write(EncodingUtils.getBytes(s, HTTP.ISO_8859_1));
                 return;
             }
             if (uri.indexOf("?") < 0) {
                 if (!uri.endsWith(contextPath)) {
                     String serviceName = uri.replaceAll(contextPath, "");
                     if (serviceName.indexOf("/") < 0) {
-                        String res = HTTPTransportReceiver
+                        String s = HTTPTransportReceiver
                                 .printServiceHTML(serviceName, configurationContext);
-                        StringEntity entity = new StringEntity(res);
-                        entity.setContentType("text/html");
-                        response.setEntity(entity);
+                        response.setStatus(HttpStatus.SC_OK);
+                        response.setContentType("text/html");
+                        OutputStream out = response.getOutputStream();
+                        out.write(EncodingUtils.getBytes(s, HTTP.ISO_8859_1));
                         return;
                     }
                 }
@@ -110,16 +101,10 @@
                 HashMap services = configurationContext.getAxisConfiguration().getServices();
                 final AxisService service = (AxisService) services.get(serviceName);
                 if (service != null) {
-                    final String ip = getHostAddress(request);
-                    EntityTemplate entity = new EntityTemplate(new ContentProducer() {
-
-                        public void writeTo(final OutputStream outstream) throws IOException {
-                            service.printWSDL2(outstream, ip, servicePath);
-                        }
-
-                    });
-                    entity.setContentType("text/xml");
-                    response.setEntity(entity);
+                    String ip = getHostAddress(request);
+                    response.setStatus(HttpStatus.SC_OK);
+                    response.setContentType("text/xml");
+                    service.printWSDL2(response.getOutputStream(), ip, servicePath);
                     return;
                 }
             }
@@ -128,16 +113,10 @@
                 HashMap services = configurationContext.getAxisConfiguration().getServices();
                 final AxisService service = (AxisService) services.get(serviceName);
                 if (service != null) {
-                    final String ip = getHostAddress(request);
-                    EntityTemplate entity = new EntityTemplate(new ContentProducer() {
-
-                        public void writeTo(final OutputStream outstream) throws IOException {
-                            service.printWSDL(outstream, ip, servicePath);
-                        }
-
-                    });
-                    entity.setContentType("text/xml");
-                    response.setEntity(entity);
+                    String ip = getHostAddress(request);
+                    response.setStatus(HttpStatus.SC_OK);
+                    response.setContentType("text/xml");
+                    service.printWSDL(response.getOutputStream(), ip, servicePath);
                     return;
                 }
             }
@@ -146,15 +125,9 @@
                 HashMap services = configurationContext.getAxisConfiguration().getServices();
                 final AxisService service = (AxisService) services.get(serviceName);
                 if (service != null) {
-                    EntityTemplate entity = new EntityTemplate(new ContentProducer() {
-
-                        public void writeTo(final OutputStream outstream) throws IOException {
-                            service.printSchema(outstream);
-                        }
-
-                    });
-                    entity.setContentType("text/xml");
-                    response.setEntity(entity);
+                    response.setStatus(HttpStatus.SC_OK);
+                    response.setContentType("text/xml");
+                    service.printSchema(response.getOutputStream());
                     return;
                 }
             }
@@ -174,75 +147,86 @@
                     final XmlSchema schema = (XmlSchema) schemaTable.get(schemaName);
                     //schema found - write it to the stream
                     if (schema != null) {
-                        EntityTemplate entity = new EntityTemplate(new ContentProducer() {
-
-                            public void writeTo(final OutputStream outstream) {
-                                schema.write(outstream);
-                            }
-
-                        });
-                        entity.setContentType("text/xml");
-                        response.setEntity(entity);
+                        response.setStatus(HttpStatus.SC_OK);
+                        response.setContentType("text/xml");
+                        schema.write(response.getOutputStream());
                         return;
                     } else {
                         // no schema available by that name  - send 404
-                        response.setStatusLine(new BasicStatusLine(ver, 404, "Schema Not Found!"));
+                        response.sendError(HttpStatus.SC_NOT_FOUND, "Schema Not Found!");
                         return;
                     }
                 }
             }
 
-            outbuffer = copyCommonProperties(msgContext, request);
-            String contentType = null;
-            Header[] headers = request.getHeaders(HTTPConstants.HEADER_CONTENT_TYPE);
-            if (headers != null && headers.length > 0) {
-                contentType = headers[0].getValue();
-                int index = contentType.indexOf(';');
-                if (index > 0) {
-                    contentType = contentType.substring(0, index);
-                }
-            }
             // deal with GET request
-            pi = RESTUtil.processURLRequest(msgContext, outbuffer.getOutputStream(), contentType);
+            pi = RESTUtil.processURLRequest(
+                    msgContext, 
+                    response.getOutputStream(), 
+                    request.getContentType());
 
         } else if (method.equals(HTTPConstants.HEADER_POST)) {
             // deal with POST request
 
-            outbuffer = copyCommonProperties(msgContext, request);
-            HttpEntity inentity = ((HttpEntityEnclosingRequest) request).getEntity();
-            String contentType = processContentType(inentity, msgContext);
+            String contentType = request.getContentType();
+            msgContext.setProperty(Constants.Configuration.CONTENT_TYPE, contentType);
+            
             if (HTTPTransportUtils.isRESTRequest(contentType)) {
-                pi = RESTUtil.processXMLRequest(msgContext, inentity.getContent(),
-                                                outbuffer.getOutputStream(), contentType);
+                pi = RESTUtil.processXMLRequest(
+                        msgContext, 
+                        request.getInputStream(),
+                        response.getOutputStream(), 
+                        contentType);
             } else {
                 String ip = (String)msgContext.getProperty(MessageContext.TRANSPORT_ADDR);
-                if(ip!=null){
+                if (ip != null){
                     uri = ip + uri;
                 }
-                pi = HTTPTransportUtils.processHTTPPostRequest(msgContext, inentity.getContent(),
-                                                               outbuffer.getOutputStream(),
-                                                               contentType, soapAction, uri);
+                pi = HTTPTransportUtils.processHTTPPostRequest(
+                        msgContext, 
+                        request.getInputStream(),
+                        response.getOutputStream(),
+                        contentType, 
+                        soapAction, 
+                        uri);
             }
 
-
         } else if (method.equals(HTTPConstants.HEADER_PUT)) {
-            outbuffer = copyCommonProperties(msgContext, request);
-            HttpEntity inentity = ((HttpEntityEnclosingRequest) request).getEntity();
-            String contentType = processContentType(inentity, msgContext);
-            pi = RESTUtil.processXMLRequest(msgContext, inentity.getContent(),
-                                            outbuffer.getOutputStream(), contentType);
 
+            String contentType = request.getContentType();
+            msgContext.setProperty(Constants.Configuration.CONTENT_TYPE, contentType);
+            
+            pi = RESTUtil.processXMLRequest(
+                    msgContext, 
+                    request.getInputStream(),
+                    response.getOutputStream(), 
+                    contentType);
+
         } else if (method.equals(HTTPConstants.HEADER_DELETE)) {
-            outbuffer = copyCommonProperties(msgContext, request);
 
+            pi = RESTUtil.processURLRequest(
+                    msgContext, 
+                    response.getOutputStream(), 
+                    null);
 
-            pi = RESTUtil.processURLRequest(msgContext, outbuffer.getOutputStream(), null);
-
         } else {
-
             throw new MethodNotSupportedException(method + " method not supported");
         }
-        handleResponse(pi, response, outbuffer, msgContext);
+        
+        Boolean holdResponse =
+            (Boolean) msgContext.getProperty(RequestResponseTransport.HOLD_RESPONSE);
+        if (pi.equals(InvocationResponse.SUSPEND) ||
+                (holdResponse != null && Boolean.TRUE.equals(holdResponse))) {
+            try {
+                ((RequestResponseTransport) msgContext
+                        .getProperty(RequestResponseTransport.TRANSPORT_CONTROL)).awaitResponse();
+            }
+            catch (InterruptedException e) {
+                throw new IOException("We were interrupted, so this may not function correctly:" +
+                        e.getMessage());
+            }
+        }
+        
         // Finalize response
         OperationContext operationContext = msgContext.getOperationContext();
         Object contextWritten = null;
@@ -255,58 +239,14 @@
 
         if ((contextWritten != null) && Constants.VALUE_TRUE.equals(contextWritten)) {
             if ((isTwoChannel != null) && Constants.VALUE_TRUE.equals(isTwoChannel)) {
-                response.setStatusLine(new BasicStatusLine(ver, 202, "OK"));
-                return;
+                response.setStatus(HttpStatus.SC_ACCEPTED);
             }
-            response.setStatusLine(new BasicStatusLine(ver, 200, "OK"));
         } else {
-            response.setStatusLine(new BasicStatusLine(ver, 202, "OK"));
+            response.setStatus(HttpStatus.SC_ACCEPTED);
         }
     }
 
-    private void handleResponse(InvocationResponse pi, HttpResponse response,
-                                OutputBuffer outbuffer, MessageContext msgContext)
-            throws IOException {
-        Boolean holdResponse =
-                (Boolean) msgContext.getProperty(RequestResponseTransport.HOLD_RESPONSE);
-
-        if (pi.equals(InvocationResponse.SUSPEND) ||
-                (holdResponse != null && Boolean.TRUE.equals(holdResponse))) {
-            try {
-                ((RequestResponseTransport) msgContext
-                        .getProperty(RequestResponseTransport.TRANSPORT_CONTROL)).awaitResponse();
-            }
-            catch (InterruptedException e) {
-                throw new IOException("We were interrupted, so this may not function correctly:" +
-                        e.getMessage());
-            }
-        }
-
-        response.setEntity(outbuffer);
-    }
-
-    private String processContentType(HttpEntity inentity, MessageContext msgContext) {
-        String contentType = null;
-        Header header = inentity.getContentType();
-        if (header != null) {
-            contentType = header.getValue();
-        }
-        msgContext.setProperty(Constants.Configuration.CONTENT_TYPE, contentType);
-        return contentType;
-    }
-
-    private OutputBuffer copyCommonProperties(MessageContext msgContext, HttpRequest request) {
-        request.getRequestLine().getUri();
-        OutputBuffer outbuffer = new OutputBuffer();
-        msgContext.setProperty(MessageContext.TRANSPORT_OUT, outbuffer);
-        msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outbuffer);
-        msgContext.setTo(new EndpointReference(request.getRequestLine().getUri()));
-        msgContext.setProperty(RequestResponseTransport.TRANSPORT_CONTROL,
-                               new SimpleHTTPRequestResponseTransport());
-        return outbuffer;
-    }
-
-    public String getHostAddress(HttpRequest request) throws java.net.SocketException {
+    public String getHostAddress(AxisHttpRequest request) throws java.net.SocketException {
         try {
             Header hostHeader = request.getFirstHeader("host");
             if (hostHeader != null) {
@@ -319,38 +259,4 @@
         return HttpUtils.getIpAddress();
     }
 
-    class SimpleHTTPRequestResponseTransport implements RequestResponseTransport {
-
-        private CountDownLatch responseReadySignal = new CountDownLatch(1);
-        RequestResponseTransportStatus status = RequestResponseTransportStatus.INITIAL;
-        AxisFault faultToBeThrownOut = null;
-        
-        public void acknowledgeMessage(MessageContext msgContext) throws AxisFault {
-            //TODO: Once the core HTTP API allows us to return an ack before unwinding, then the should be fixed
-            signalResponseReady();
-        }
-
-        public void awaitResponse() throws InterruptedException,AxisFault {
-            status = RequestResponseTransportStatus.WAITING;
-            responseReadySignal.await();
-            
-            if (faultToBeThrownOut!=null)
-            	throw faultToBeThrownOut;
-        }
-
-        public void signalResponseReady() {
-            status = RequestResponseTransportStatus.SIGNALLED;
-            responseReadySignal.countDown();
-        }
-
-        public RequestResponseTransportStatus getStatus() {
-            return status;
-        }
-
-		public void signalFaultReady(AxisFault fault) {
-			faultToBeThrownOut = fault;
-			signalResponseReady();
-		}
-        
-    }
 }
Index: modules/kernel/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java	(revision 525829)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java	(working copy)
@@ -35,7 +35,6 @@
 import org.apache.commons.logging.LogFactory;
 import org.apache.http.ConnectionReuseStrategy;
 import org.apache.http.HttpResponseFactory;
-import org.apache.http.HttpServerConnection;
 import org.apache.http.impl.DefaultConnectionReuseStrategy;
 import org.apache.http.impl.DefaultHttpResponseFactory;
 import org.apache.http.params.HttpParams;
@@ -59,7 +58,6 @@
     private final WorkerFactory workerfactory;
     private final HttpParams params;
     private final List processors;
-    private final SessionManager sessionManager;
 
     private HttpFactory httpFactory = null;
 
@@ -82,7 +80,6 @@
             throw new IllegalArgumentException("HTTP parameters may not be null");
         }
         this.configurationContext = configurationContext;
-        this.sessionManager = new SessionManager();
         this.executor = executor;
         this.workerfactory = workerfactory;
         this.params = params;
@@ -123,7 +120,7 @@
         this.processors.remove(processor);
     }
 
-    public void process(final HttpServerConnection conn) {
+    public void process(final AxisHttpConnection conn) {
         if (conn == null) {
             throw new IllegalArgumentException("HTTP connection may not be null");
         }
@@ -147,7 +144,7 @@
             p.addInterceptor(new ResponseContent());
             p.addInterceptor(new ResponseConnControl());
             p.addInterceptor(new ResponseSessionCookie());
-            httpProcessor = new LoggingProcessorDecorator(p);
+            httpProcessor = p;
             connStrategy = new DefaultConnectionReuseStrategy();
             responseFactory = new DefaultHttpResponseFactory();
         }
@@ -157,7 +154,6 @@
                 connStrategy,
                 responseFactory,
                 this.configurationContext,
-                this.sessionManager,
                 this.workerfactory.newWorker());
         httpService.setParams(this.params);
 
Index: modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpRequestImpl.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpRequestImpl.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpRequestImpl.java	(revision 0)
@@ -0,0 +1,175 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Iterator;
+
+import org.apache.http.Header;
+import org.apache.http.HeaderElement;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpVersion;
+import org.apache.http.params.HttpParams;
+import org.apache.http.protocol.HTTP;
+import org.apache.http.protocol.HttpContext;
+import org.apache.http.protocol.HttpExecutionContext;
+import org.apache.http.protocol.HttpProcessor;
+
+public class AxisHttpRequestImpl implements AxisHttpRequest {
+
+    private final HttpRequest request;
+    private final AxisHttpConnection conn;
+    private final HttpProcessor httpproc;
+    private final HttpContext context;
+    
+    public AxisHttpRequestImpl(
+            final AxisHttpConnection conn,
+            final HttpRequest request, 
+            final HttpProcessor httpproc,
+            final HttpContext context) {
+        super();
+        if (conn == null) {
+            throw new IllegalArgumentException("HTTP connection may not be null");
+        }
+        if (request == null) {
+            throw new IllegalArgumentException("HTTP request may not be null");
+        }
+        if (httpproc == null) {
+            throw new IllegalArgumentException("HTTP processor may not be null");
+        }
+        if (context == null) {
+            throw new IllegalArgumentException("HTTP context may not be null");
+        }
+        this.request = request;
+        this.conn = conn;
+        this.httpproc = httpproc;
+        this.context = context;
+    }
+    
+    public void prepare() throws IOException, HttpException {
+        this.context.setAttribute(HttpExecutionContext.HTTP_CONNECTION, this.conn);
+        this.context.setAttribute(HttpExecutionContext.HTTP_REQUEST, this.request);
+        
+        this.httpproc.process(this.request, this.context);
+    }
+
+    public String getMethod() {
+        return this.request.getRequestLine().getMethod();
+    }
+
+    public String getRequestURI() {
+        return this.request.getRequestLine().getUri();
+    }
+
+    public HttpVersion getHttpVersion() {
+        return this.request.getRequestLine().getHttpVersion();
+    }
+
+    public String getContentType() {
+        Header header = this.request.getFirstHeader(HTTP.CONTENT_TYPE);
+        if (header != null) {
+            HeaderElement[] elements = header.getElements();
+            if (elements.length > 0) {
+                return elements[0].getName(); 
+            } else {
+                return null;
+            }
+        } else {
+            return null;
+        }
+    }
+
+    public InputStream getInputStream() {
+        return this.conn.getInputStream();
+    }
+
+    public void addHeader(final Header header) {
+        this.request.addHeader(header);
+    }
+
+    public void addHeader(final String name, final String value) {
+        this.request.addHeader(name, value);
+    }
+
+    public boolean containsHeader(final String name) {
+        return this.request.containsHeader(name);
+    }
+
+    public Header[] getAllHeaders() {
+        return this.request.getAllHeaders();
+    }
+
+    public Header getFirstHeader(final String name) {
+        return this.request.getFirstHeader(name);
+    }
+
+    public Header[] getHeaders(String name) {
+        return this.request.getHeaders(name);
+    }
+
+    public Header getLastHeader(final String name) {
+        return this.request.getLastHeader(name);
+    }
+
+    public Iterator headerIterator() {
+        return this.request.headerIterator();
+    }
+
+    public void removeHeader(final Header header) {
+        this.request.removeHeader(header);
+    }
+
+    public void removeHeaders(final String name) {
+        this.request.removeHeaders(name);
+    }
+
+    public void setHeader(final Header header) {
+        this.request.setHeader(header);
+    }
+
+    public void setHeader(final String name, final String value) {
+        this.request.setHeader(name, value);
+    }
+
+    public void setHeaders(Header[] headers) {
+        this.request.setHeaders(headers);
+    }
+
+    public HttpParams getParams() {
+        return this.request.getParams();
+    }
+
+    public void setParams(final HttpParams params) {
+        this.request.setParams(params);
+    }
+    
+}

Property changes on: modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpRequestImpl.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL

Index: modules/kernel/src/org/apache/axis2/transport/http/server/HttpServiceProcessor.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/HttpServiceProcessor.java	(revision 525829)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/HttpServiceProcessor.java	(working copy)
@@ -33,10 +33,8 @@
 import org.apache.commons.logging.LogFactory;
 import org.apache.http.ConnectionClosedException;
 import org.apache.http.HttpException;
-import org.apache.http.HttpServerConnection;
 import org.apache.http.protocol.HttpContext;
 import org.apache.http.protocol.HttpExecutionContext;
-import org.apache.http.protocol.HttpService;
 
 import java.io.IOException;
 import java.net.SocketException;
@@ -53,13 +51,13 @@
 
     private volatile boolean terminated;
 
-    private final HttpService httpservice;
-    private final HttpServerConnection conn;
+    private final AxisHttpService httpservice;
+    private final AxisHttpConnection conn;
     private final IOProcessorCallback callback;
 
     public HttpServiceProcessor(
-            final HttpService httpservice,
-            final HttpServerConnection conn,
+            final AxisHttpService httpservice,
+            final AxisHttpConnection conn,
             final IOProcessorCallback callback) {
         super();
         this.httpservice = httpservice;
Index: modules/kernel/src/org/apache/axis2/transport/http/server/HttpUtils.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/HttpUtils.java	(revision 525829)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/HttpUtils.java	(working copy)
@@ -29,7 +29,6 @@
 
 import org.apache.axis2.transport.http.HTTPConstants;
 import org.apache.http.Header;
-import org.apache.http.HttpRequest;
 
 import java.net.InetAddress;
 import java.net.NetworkInterface;
@@ -41,7 +40,7 @@
     private HttpUtils() {
     }
 
-    public static String getSoapAction(final HttpRequest request) {
+    public static String getSoapAction(final AxisHttpRequest request) {
         if (request == null) {
             return null;
         }
Index: modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpResponseImpl.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpResponseImpl.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpResponseImpl.java	(revision 0)
@@ -0,0 +1,257 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Iterator;
+
+import org.apache.axis2.transport.OutTransportInfo;
+import org.apache.http.Header;
+import org.apache.http.HttpException;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpVersion;
+import org.apache.http.entity.BasicHttpEntity;
+import org.apache.http.params.HttpParams;
+import org.apache.http.protocol.HttpContext;
+import org.apache.http.protocol.HttpExecutionContext;
+import org.apache.http.protocol.HttpProcessor;
+
+public class AxisHttpResponseImpl implements AxisHttpResponse, OutTransportInfo {
+
+    private final HttpResponse response;
+    private final AxisHttpConnection conn;
+    private final HttpProcessor httpproc;
+    private final HttpContext context;
+    
+    private AutoCommitOutputStream outstream;
+    private String contentType;
+    
+    private volatile boolean commited;
+    
+    public AxisHttpResponseImpl(
+            final AxisHttpConnection conn,
+            final HttpResponse response, 
+            final HttpProcessor httpproc,
+            final HttpContext context) {
+        super();
+        if (response == null) {
+            throw new IllegalArgumentException("HTTP response may not be null");
+        }
+        if (conn == null) {
+            throw new IllegalArgumentException("HTTP connection may not be null");
+        }
+        if (httpproc == null) {
+            throw new IllegalArgumentException("HTTP processor may not be null");
+        }
+        if (context == null) {
+            throw new IllegalArgumentException("HTTP context may not be null");
+        }
+        this.response = response;
+        this.conn = conn;
+        this.httpproc = httpproc;
+        this.context = context;
+    }
+
+    private void assertNotCommitted() {
+        if (this.commited) {
+            throw new IllegalStateException("Response already committed");
+        }
+    }
+    
+    public boolean isCommitted() {
+        return this.commited;
+    }
+    
+    public void commit() throws IOException, HttpException {
+        if (this.commited) {
+            return;
+        }
+        this.commited = true;
+        
+        this.context.setAttribute(HttpExecutionContext.HTTP_CONNECTION, this.conn);
+        this.context.setAttribute(HttpExecutionContext.HTTP_RESPONSE, this.response);
+        
+        BasicHttpEntity entity = new BasicHttpEntity();
+        entity.setChunked(true);
+        entity.setContentType(this.contentType);
+        
+        this.response.setEntity(entity);
+        
+        this.httpproc.process(this.response, this.context);
+        this.conn.sendResponse(this.response);
+    }
+    
+    public OutputStream getOutputStream() {
+        if (this.outstream == null) {
+            this.outstream = new AutoCommitOutputStream();
+        }
+        return this.outstream;
+    }
+
+    public void sendError(int sc, final String msg) {
+        assertNotCommitted();
+        HttpVersion ver = this.response.getHttpVersion();
+        this.response.setStatusLine(ver, sc, msg);
+    }
+
+    public void sendError(int sc) {
+        assertNotCommitted();
+        this.response.setStatusCode(sc);
+    }
+
+    public void setStatus(int sc) {
+        assertNotCommitted();
+        this.response.setStatusCode(sc);
+    }
+
+    public void setContentType(final String contentType) {
+        assertNotCommitted();
+        this.contentType = contentType;
+    }
+
+    public HttpVersion getHttpVersion() {
+        return this.response.getHttpVersion();
+    }
+
+    public void addHeader(final Header header) {
+        assertNotCommitted();
+        this.response.addHeader(header);
+    }
+
+    public void addHeader(final String name, final String value) {
+        assertNotCommitted();
+        this.response.addHeader(name, value);
+    }
+
+    public boolean containsHeader(final String name) {
+        return this.response.containsHeader(name);
+    }
+
+    public Header[] getAllHeaders() {
+        return this.response.getAllHeaders();
+    }
+
+    public Header getFirstHeader(final String name) {
+        return this.response.getFirstHeader(name);
+    }
+
+    public Header[] getHeaders(String name) {
+        return this.response.getHeaders(name);
+    }
+
+    public Header getLastHeader(final String name) {
+        return this.response.getLastHeader(name);
+    }
+
+    public Iterator headerIterator() {
+        return this.response.headerIterator();
+    }
+
+    public void removeHeader(final Header header) {
+        assertNotCommitted();
+        this.response.removeHeader(header);
+    }
+
+    public void removeHeaders(final String name) {
+        assertNotCommitted();
+        this.response.removeHeaders(name);
+    }
+
+    public void setHeader(final Header header) {
+        assertNotCommitted();
+        this.response.setHeader(header);
+    }
+
+    public void setHeader(final String name, final String value) {
+        assertNotCommitted();
+        this.response.setHeader(name, value);
+    }
+
+    public void setHeaders(Header[] headers) {
+        assertNotCommitted();
+        this.response.setHeaders(headers);
+    }
+
+    public HttpParams getParams() {
+        return this.response.getParams();
+    }
+
+    public void setParams(final HttpParams params) {
+        this.response.setParams(params);
+    }
+    
+    class AutoCommitOutputStream extends OutputStream {
+
+        private OutputStream out;
+        
+        public AutoCommitOutputStream() {
+            super();
+        }
+
+        private void ensureCommitted() throws IOException {
+            try {
+                commit();
+            } catch (HttpException ex) {
+                throw new IOException("HTTP protocol exception: " + ex.getMessage());
+            }
+            if (this.out == null) {
+                this.out = conn.getOutputStream();
+            }
+        }
+        
+        public void close() throws IOException {
+            ensureCommitted();
+            this.out.close();
+        }
+
+        public void write(final byte[] b, int off, int len) throws IOException {
+            ensureCommitted();
+            this.out.write(b, off, len);
+        }
+
+        public void write(final byte[] b) throws IOException {
+            ensureCommitted();
+            this.out.write(b);
+        }
+
+        public void write(int b) throws IOException {
+            ensureCommitted();
+            this.out.write(b);
+        }
+        
+        public void flush() throws IOException {
+            ensureCommitted();
+            this.out.flush();
+        }
+
+    }
+    
+}

Property changes on: modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpResponseImpl.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL

Index: modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpConnectionImpl.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpConnectionImpl.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpConnectionImpl.java	(revision 0)
@@ -0,0 +1,323 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.net.SocketException;
+import java.util.Iterator;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.ConnectionClosedException;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpEntityEnclosingRequest;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpRequestFactory;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpVersion;
+import org.apache.http.RequestLine;
+import org.apache.http.entity.ContentLengthStrategy;
+import org.apache.http.impl.DefaultHttpRequestFactory;
+import org.apache.http.impl.entity.StrictContentLengthStrategy;
+import org.apache.http.impl.io.ChunkedInputStream;
+import org.apache.http.impl.io.ChunkedOutputStream;
+import org.apache.http.impl.io.ContentLengthInputStream;
+import org.apache.http.impl.io.ContentLengthOutputStream;
+import org.apache.http.impl.io.HttpDataInputStream;
+import org.apache.http.impl.io.IdentityOutputStream;
+import org.apache.http.impl.io.SocketHttpDataReceiver;
+import org.apache.http.impl.io.SocketHttpDataTransmitter;
+import org.apache.http.io.HttpDataReceiver;
+import org.apache.http.io.HttpDataTransmitter;
+import org.apache.http.message.BasicHeader;
+import org.apache.http.message.BasicRequestLine;
+import org.apache.http.message.BasicStatusLine;
+import org.apache.http.message.BufferedHeader;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.util.CharArrayBuffer;
+import org.apache.http.util.HeaderUtils;
+
+public class AxisHttpConnectionImpl implements AxisHttpConnection {
+
+    private static final Log HEADERLOG =
+        LogFactory.getLog("org.apache.axis2.transport.http.server.wire");
+
+    private final Socket socket;
+    private final HttpDataTransmitter datatransmitter;
+    private final HttpDataReceiver datareceiver;
+    private final CharArrayBuffer charbuffer; 
+    private final HttpRequestFactory requestfactory;
+    private final ContentLengthStrategy contentLenStrategy;
+    private final int maxHeaderCount;
+
+    private OutputStream out = null;
+    private InputStream in = null;
+    
+    public AxisHttpConnectionImpl(final Socket socket, final HttpParams params) 
+            throws IOException {
+        super();
+        if (socket == null) {
+            throw new IllegalArgumentException("Socket may not be null"); 
+        }
+        if (params == null) {
+            throw new IllegalArgumentException("HTTP parameters may not be null"); 
+        }
+        socket.setTcpNoDelay(HttpConnectionParams.getTcpNoDelay(params));
+        socket.setSoTimeout(HttpConnectionParams.getSoTimeout(params));
+        
+        int linger = HttpConnectionParams.getLinger(params);
+        if (linger >= 0) {
+            socket.setSoLinger(linger > 0, linger);
+        }
+        
+        int buffersize = HttpConnectionParams.getSocketBufferSize(params);
+        this.socket = socket;
+        this.datatransmitter = new SocketHttpDataTransmitter(socket, buffersize); 
+        this.datareceiver = new SocketHttpDataReceiver(socket, buffersize); 
+        this.charbuffer = new CharArrayBuffer(256);
+        this.requestfactory = new DefaultHttpRequestFactory();
+        this.contentLenStrategy = new StrictContentLengthStrategy();
+        this.maxHeaderCount = params.getIntParameter(HttpConnectionParams.MAX_HEADER_COUNT, -1);
+    }
+
+    public void close() throws IOException {
+        this.datatransmitter.flush();
+        try {
+            this.socket.shutdownOutput();
+        } catch (IOException ignore) {
+        }
+        try {
+            this.socket.shutdownInput();
+        } catch (IOException ignore) {
+        }
+        this.socket.close();
+    }
+
+    public boolean isOpen() {
+        return !this.socket.isClosed();
+    }
+
+    public boolean isStale() {
+        try {
+            this.datareceiver.isDataAvailable(1);
+            return false;
+        } catch (IOException ex) {
+            return true;
+        }
+    }
+
+    public void shutdown() throws IOException {
+        Socket tmpsocket = this.socket;
+        if (tmpsocket != null) {
+            tmpsocket.close();
+        }
+    }
+
+    public HttpRequest receiveRequest(final HttpParams params) 
+            throws HttpException, IOException {
+        if (params == null) {
+            throw new IllegalArgumentException("HTTP parameters may not be null");
+        }
+        this.charbuffer.clear();
+        int i = this.datareceiver.readLine(this.charbuffer);
+        if (i == -1) {
+            throw new ConnectionClosedException("Client closed connection"); 
+        }
+        RequestLine requestline = BasicRequestLine.parse(this.charbuffer, 0, this.charbuffer.length());
+        HttpRequest request = this.requestfactory.newHttpRequest(requestline);
+        request.getParams().setDefaults(params);
+        Header[] headers = HeaderUtils.parseHeaders(this.datareceiver, this.maxHeaderCount);
+        request.setHeaders(headers);
+        
+        if (HEADERLOG.isDebugEnabled()) {
+            HEADERLOG.debug(">> " + request.getRequestLine().toString());
+            for (i = 0; i < headers.length; i++) {
+                HEADERLOG.debug(">> " + headers[i].toString());
+            }
+        }
+        
+        // Prepare input stream
+        this.in = null;
+        if (request instanceof HttpEntityEnclosingRequest) {
+            long len = this.contentLenStrategy.determineLength(request);
+            if (len == ContentLengthStrategy.CHUNKED) {
+                this.in = new ChunkedInputStream(this.datareceiver);
+            } else if (len == ContentLengthStrategy.IDENTITY) {
+                this.in = new HttpDataInputStream(this.datareceiver);                            
+            } else {
+                this.in = new ContentLengthInputStream(datareceiver, len);
+            }
+        }
+        return request;
+    }
+    
+    public void sendResponse(final HttpResponse response) 
+            throws HttpException, IOException {
+        if (response == null) {
+            throw new IllegalArgumentException("HTTP response may not be null");
+        }
+
+        if (HEADERLOG.isDebugEnabled()) {
+            HEADERLOG.debug("<< " + response.getStatusLine().toString());
+            Header[] headers = response.getAllHeaders();
+            for (int i = 0; i < headers.length; i++) {
+                HEADERLOG.debug("<< " + headers[i].toString());
+            }
+        }
+        
+        this.charbuffer.clear();
+        BasicStatusLine.format(this.charbuffer, response.getStatusLine());
+        this.datatransmitter.writeLine(this.charbuffer);
+        for (Iterator it = response.headerIterator(); it.hasNext(); ) {
+            Header header = (Header) it.next();
+            if (header instanceof BufferedHeader) {
+                this.datatransmitter.writeLine(((BufferedHeader)header).getBuffer());
+            } else {
+                this.charbuffer.clear();
+                BasicHeader.format(this.charbuffer, header);
+                this.datatransmitter.writeLine(this.charbuffer);
+            }
+        }
+        this.charbuffer.clear();
+        this.datatransmitter.writeLine(this.charbuffer);
+
+        // Prepare output stream
+        this.out = null;
+        HttpVersion ver = response.getStatusLine().getHttpVersion();
+        HttpEntity entity = response.getEntity();
+        if (entity != null) {
+            long len = entity.getContentLength();
+            if (entity.isChunked() && ver.greaterEquals(HttpVersion.HTTP_1_1)) {
+                this.out = new ChunkedOutputStream(this.datatransmitter);
+            } else if (len >= 0) {
+                this.out = new ContentLengthOutputStream(this.datatransmitter, len);
+            } else {
+                this.out = new IdentityOutputStream(this.datatransmitter); 
+            }
+        } else {
+            this.datatransmitter.flush();
+        }
+    }
+    
+    public InputStream getInputStream() {
+        return this.in;
+    }
+
+    public OutputStream getOutputStream() {
+        return this.out;
+    }
+    
+    public void flush() throws IOException {
+        if (this.out != null) {
+            this.out.flush();
+        } else {
+            this.datatransmitter.flush();
+        }
+    }
+
+    public void reset() throws IOException {
+        if (this.in != null) {
+            this.in.close();
+            this.in = null;
+        }
+        if (this.out != null) {
+            this.out.flush();
+            this.out.close();
+            this.out = null;
+        }
+    }
+    
+    public int getSocketTimeout() {
+        try {
+            return this.socket.getSoTimeout();
+        } catch (SocketException ex) {
+            return -1;
+        }
+    }
+
+    public void setSocketTimeout(int timeout) {
+        try {
+            this.socket.setSoTimeout(timeout);
+        } catch (SocketException ex) {
+        }
+    }
+
+    public InetAddress getLocalAddress() {
+        if (this.socket != null) {
+            return this.socket.getLocalAddress();
+        } else {
+            return null;
+        }
+    }
+
+    public int getLocalPort() {
+        if (this.socket != null) {
+            return this.socket.getLocalPort();
+        } else {
+            return -1;
+        }
+    }
+
+    public InetAddress getRemoteAddress() {
+        if (this.socket != null) {
+            return this.socket.getInetAddress();
+        } else {
+            return null;
+        }
+    }
+
+    public int getRemotePort() {
+        if (this.socket != null) {
+            return this.socket.getPort();
+        } else {
+            return -1;
+        }
+    }
+
+    public String toString() {
+        StringBuffer buffer = new StringBuffer();
+        buffer.append("[");
+        if (isOpen()) {
+            buffer.append(this.socket.getInetAddress());
+        } else {
+            buffer.append("closed");
+        }
+        buffer.append("]");
+        return buffer.toString();
+    }
+
+}

Property changes on: modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpConnectionImpl.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL

Index: modules/kernel/src/org/apache/axis2/transport/http/server/HttpFactory.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/HttpFactory.java	(revision 525829)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/HttpFactory.java	(working copy)
@@ -29,11 +29,8 @@
 
 package org.apache.axis2.transport.http.server;
 
-import edu.emory.mathcs.backport.java.util.concurrent.BlockingQueue;
-import edu.emory.mathcs.backport.java.util.concurrent.ExecutorService;
-import edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingQueue;
-import edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor;
-import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
+import java.io.IOException;
+
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.context.ConfigurationContext;
@@ -44,8 +41,8 @@
 import org.apache.http.ConnectionReuseStrategy;
 import org.apache.http.HttpResponseFactory;
 import org.apache.http.impl.DefaultConnectionReuseStrategy;
-import org.apache.http.impl.DefaultHttpParams;
 import org.apache.http.impl.DefaultHttpResponseFactory;
+import org.apache.http.params.BasicHttpParams;
 import org.apache.http.params.HttpConnectionParams;
 import org.apache.http.params.HttpParams;
 import org.apache.http.params.HttpProtocolParams;
@@ -56,7 +53,11 @@
 import org.apache.http.protocol.ResponseDate;
 import org.apache.http.protocol.ResponseServer;
 
-import java.io.IOException;
+import edu.emory.mathcs.backport.java.util.concurrent.BlockingQueue;
+import edu.emory.mathcs.backport.java.util.concurrent.ExecutorService;
+import edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingQueue;
+import edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor;
+import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
 
 /**
  * Factory used to configure and create the various instances required in http transports.
@@ -244,24 +245,22 @@
     /**
      * Create the listener for request connections
      */
-    public IOProcessor newRequestConnectionListener(HttpConnectionFactory factory,
-                                                    HttpConnectionManager manager, int port)
-            throws IOException {
-        return new DefaultConnectionListener(port, factory, manager);
+    public IOProcessor newRequestConnectionListener(
+            int port,
+            final HttpConnectionManager manager, 
+            final HttpParams params) throws IOException {
+        return new DefaultConnectionListener(
+                port, 
+                manager, 
+                new DefaultConnectionListenerFailureHandler(), 
+                params);
     }
 
     /**
-     * Create a request connection
-     */
-    public HttpConnectionFactory newRequestConnectionFactory(HttpParams params) {
-        return new DefaultHttpConnectionFactory(params);
-    }
-
-    /**
      * Create and set the parameters applied to incoming request connections
      */
     public HttpParams newRequestConnectionParams() {
-        HttpParams params = new DefaultHttpParams();
+        HttpParams params = new BasicHttpParams();
         params
                 .setIntParameter(HttpConnectionParams.SO_TIMEOUT, requestSocketTimeout)
                 .setBooleanParameter(HttpConnectionParams.TCP_NODELAY, requestTcpNoDelay)
@@ -320,7 +319,7 @@
         httpProcessor.addInterceptor(new ResponseContent());
         httpProcessor.addInterceptor(new ResponseConnControl());
         httpProcessor.addInterceptor(new ResponseSessionCookie());
-        return new LoggingProcessorDecorator(httpProcessor);
+        return httpProcessor;
     }
 
     public ConnectionReuseStrategy newConnStrategy() {
Index: modules/kernel/src/org/apache/axis2/transport/http/server/Worker.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/Worker.java	(revision 525829)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/Worker.java	(working copy)
@@ -29,14 +29,12 @@
 
 import org.apache.axis2.context.MessageContext;
 import org.apache.http.HttpException;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpResponse;
 
 import java.io.IOException;
 
 public interface Worker {
 
-    void service(HttpRequest request, HttpResponse response, MessageContext msgContext)
+    void service(AxisHttpRequest request, AxisHttpResponse response, MessageContext msgContext)
             throws HttpException, IOException;
 
 }
Index: modules/kernel/src/org/apache/axis2/transport/http/server/DefaultConnectionListener.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/DefaultConnectionListener.java	(revision 525829)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/DefaultConnectionListener.java	(working copy)
@@ -31,7 +31,7 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.http.HttpServerConnection;
+import org.apache.http.params.HttpParams;
 
 import java.io.IOException;
 import java.net.ServerSocket;
@@ -44,40 +44,34 @@
     private volatile boolean destroyed = false;
 
     private final int port;
-    private final HttpConnectionFactory connfactory;
     private final HttpConnectionManager connmanager;
-    private ServerSocket serversocket = null;
     private final ConnectionListenerFailureHandler failureHandler;
+    private final HttpParams params;
 
-    /**
-     * Default constructor called by HttpFactory.  A custom HttpFactory subclass can call the other constructor to provide a custom ConnectionListenerErrorHandler
-     */
-    public DefaultConnectionListener(int port, HttpConnectionFactory connfactory,
-                                     HttpConnectionManager connmanager) throws IOException {
-        this(port, connfactory, connmanager, new DefaultConnectionListenerFailureHandler());
-    }
+    private ServerSocket serversocket = null;
 
     /**
      * Use this constructor to provide a custom ConnectionListenerFailureHandler, e.g. by subclassing DefaultConnectionListenerFailureHandler
      */
-    public DefaultConnectionListener(int port, HttpConnectionFactory connfactory,
-                                     HttpConnectionManager connmanager,
-                                     ConnectionListenerFailureHandler failureHandler)
-            throws IOException {
+    public DefaultConnectionListener(
+            int port,
+            final HttpConnectionManager connmanager,
+            final ConnectionListenerFailureHandler failureHandler,
+            final HttpParams params) throws IOException {
         super();
-        if (connfactory == null) {
-            throw new IllegalArgumentException("Connection factory may not be null");
-        }
         if (connmanager == null) {
             throw new IllegalArgumentException("Connection manager may not be null");
         }
         if (failureHandler == null) {
             throw new IllegalArgumentException("Failure handler may not be null");
         }
+        if (params == null) {
+            throw new IllegalArgumentException("HTTP parameters may not be null");
+        }
         this.port = port;
         this.connmanager = connmanager;
-        this.connfactory = connfactory;
         this.failureHandler = failureHandler;
+        this.params = params;
     }
 
     public void run() {
@@ -97,7 +91,7 @@
                         LOG.debug("Incoming HTTP connection from " +
                                 socket.getRemoteSocketAddress());
                     }
-                    HttpServerConnection conn = this.connfactory.newConnection(socket);
+                    AxisHttpConnection conn = new AxisHttpConnectionImpl(socket, this.params);
                     this.connmanager.process(conn);
                 } catch (Throwable ex) {
                     if (Thread.interrupted()) {
Index: modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpRequest.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpRequest.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpRequest.java	(revision 0)
@@ -0,0 +1,46 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.io.InputStream;
+
+import org.apache.http.HttpMessage;
+
+public interface AxisHttpRequest extends HttpMessage {
+
+    String getMethod();
+    
+    String getRequestURI();
+    
+    String getContentType();
+    
+    InputStream getInputStream();
+    
+}

Property changes on: modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpRequest.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL

Index: modules/kernel/src/org/apache/axis2/transport/http/server/SimpleHttpServer.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/SimpleHttpServer.java	(revision 525829)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/SimpleHttpServer.java	(working copy)
@@ -56,7 +56,6 @@
     private IOProcessor listener = null;
     private ExecutorService listenerExecutor = null;
     private HttpConnectionManager connmanager = null;
-    private HttpConnectionFactory connfactory = null;
     private ExecutorService requestExecutor = null;
 
     public SimpleHttpServer(ConfigurationContext configurationContext, WorkerFactory workerFactory,
@@ -77,8 +76,7 @@
         connmanager =
                 httpFactory.newRequestConnectionManager(requestExecutor, workerFactory, params);
         listenerExecutor = httpFactory.newListenerExecutor(port);
-        connfactory = httpFactory.newRequestConnectionFactory(params);
-        listener = httpFactory.newRequestConnectionListener(connfactory, connmanager, port);
+        listener = httpFactory.newRequestConnectionListener(port, connmanager, params);
     }
 
     public void destroy() throws IOException, InterruptedException {
Index: modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpResponse.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpResponse.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpResponse.java	(revision 0)
@@ -0,0 +1,48 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.io.OutputStream;
+
+import org.apache.http.HttpMessage;
+
+public interface AxisHttpResponse extends HttpMessage {
+
+    void setStatus(int sc);
+
+    void sendError(int sc, String msg);
+    
+    void sendError(int sc);
+
+    void setContentType(String contentType);
+    
+    OutputStream getOutputStream();
+    
+}

Property changes on: modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpResponse.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL

Index: modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpConnection.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpConnection.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpConnection.java	(revision 0)
@@ -0,0 +1,61 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import org.apache.http.HttpConnection;
+import org.apache.http.HttpException;
+import org.apache.http.HttpInetConnection;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.params.HttpParams;
+
+public interface AxisHttpConnection extends HttpConnection, HttpInetConnection {
+
+    HttpRequest receiveRequest(HttpParams params)
+        throws HttpException, IOException;
+    
+    InputStream getInputStream();
+    
+    void sendResponse(HttpResponse response) 
+        throws HttpException, IOException;    
+    
+    OutputStream getOutputStream();
+    
+    void flush()
+        throws IOException;
+    
+    void reset()
+        throws IOException;
+
+}

Property changes on: modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpConnection.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + Date Author Id Revision HeadURL

Index: modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpService.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpService.java	(revision 525829)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/AxisHttpService.java	(working copy)
@@ -27,95 +27,218 @@
 */
 package org.apache.axis2.transport.http.server;
 
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.SocketException;
+import java.util.HashMap;
+import java.util.Iterator;
+
+import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.addressing.AddressingHelper;
+import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.ContextFactory;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.description.TransportInDescription;
 import org.apache.axis2.description.TransportOutDescription;
 import org.apache.axis2.engine.AxisEngine;
+import org.apache.axis2.transport.RequestResponseTransport;
 import org.apache.axis2.transport.http.HTTPConstants;
 import org.apache.axis2.util.MessageContextBuilder;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.http.ConnectionReuseStrategy;
 import org.apache.http.Header;
+import org.apache.http.HttpEntityEnclosingRequest;
 import org.apache.http.HttpException;
 import org.apache.http.HttpInetConnection;
 import org.apache.http.HttpRequest;
 import org.apache.http.HttpResponse;
 import org.apache.http.HttpResponseFactory;
-import org.apache.http.HttpServerConnection;
+import org.apache.http.HttpStatus;
 import org.apache.http.HttpVersion;
-import org.apache.http.RequestLine;
+import org.apache.http.MethodNotSupportedException;
+import org.apache.http.ProtocolException;
 import org.apache.http.UnsupportedHttpVersionException;
-import org.apache.http.entity.StringEntity;
-import org.apache.http.message.BasicStatusLine;
+import org.apache.http.params.HttpParams;
 import org.apache.http.protocol.HttpContext;
 import org.apache.http.protocol.HttpProcessor;
-import org.apache.http.protocol.HttpService;
 
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.SocketException;
-import java.util.HashMap;
-import java.util.Iterator;
+import edu.emory.mathcs.backport.java.util.concurrent.CountDownLatch;
 
 /**
  * This class is an extension of the defaulf HTTP service responsible for
  * maintaining and polulating the {@link MessageContext} for incoming Axis
  * requests.
  */
-public class AxisHttpService extends HttpService {
+public class AxisHttpService {
 
     private static final Log LOG = LogFactory.getLog(AxisHttpService.class);
 
+    private final HttpProcessor httpProcessor;
+    private final ConnectionReuseStrategy connStrategy;
+    private final HttpResponseFactory responseFactory;
     private final MessageContext msgContext;
     private final ConfigurationContext configurationContext;
-    private final SessionManager sessionManager;
     private final Worker worker;
 
+    private HttpParams params;
+
     public AxisHttpService(
             final HttpProcessor httpProcessor,
             final ConnectionReuseStrategy connStrategy,
             final HttpResponseFactory responseFactory,
             final ConfigurationContext configurationContext,
-            final SessionManager sessionManager,
             final Worker worker) {
-        super(httpProcessor, connStrategy, responseFactory);
+        super();
+        if (httpProcessor == null) {
+            throw new IllegalArgumentException("HTTP processor may not be null");
+        }
+        if (connStrategy == null) {
+            throw new IllegalArgumentException("Connection strategy may not be null");
+        }
+        if (responseFactory == null) {
+            throw new IllegalArgumentException("Response factory may not be null");
+        }
         if (worker == null) {
             throw new IllegalArgumentException("Worker may not be null");
         }
         if (configurationContext == null) {
             throw new IllegalArgumentException("Configuration context may not be null");
         }
-        if (sessionManager == null) {
-            throw new IllegalArgumentException("Session manager may not be null");
-        }
+        this.httpProcessor = httpProcessor;
+        this.connStrategy = connStrategy;
+        this.responseFactory = responseFactory;
         this.configurationContext = configurationContext;
-        this.sessionManager = sessionManager;
         this.worker = worker;
 
         this.msgContext = ContextFactory.createMessageContext(configurationContext);
         this.msgContext.setIncomingTransportName(Constants.TRANSPORT_HTTP);
     }
 
+    public HttpParams getParams() {
+        return this.params;
+    }
+    
+    public void setParams(final HttpParams params) {
+        this.params = params;
+    }
+    
+    public void handleRequest(final AxisHttpConnection conn, final HttpContext context) 
+            throws IOException, HttpException { 
+        
+        if (conn instanceof HttpInetConnection) {
+            HttpInetConnection inetconn = (HttpInetConnection) conn;
+            this.msgContext.setProperty(MessageContext.REMOTE_ADDR, 
+                    inetconn.getRemoteAddress().getHostAddress());
+            this.msgContext.setProperty(MessageContext.TRANSPORT_ADDR,
+                    inetconn.getLocalAddress().getHostAddress());
+
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Remote address of the connection : " + 
+                        inetconn.getRemoteAddress().getHostAddress());
+            }
+        }
+        
+        HttpResponse response;
+        try {
+            HttpRequest request = conn.receiveRequest(this.params);
+            HttpVersion ver = request.getRequestLine().getHttpVersion();
+            if (!ver.lessEquals(HttpVersion.HTTP_1_1)) {
+                // Downgrade protocol version if greater than HTTP/1.1 
+                ver = HttpVersion.HTTP_1_1;
+            }
+
+            response = this.responseFactory.newHttpResponse
+                (ver, HttpStatus.SC_OK, context);
+            response.getParams().setDefaults(this.params);
+            
+            if (request instanceof HttpEntityEnclosingRequest) {
+                if (((HttpEntityEnclosingRequest) request).expectContinue()) {
+                    HttpResponse ack = this.responseFactory.newHttpResponse
+                        (ver, HttpStatus.SC_CONTINUE, context);
+                    ack.getParams().setDefaults(this.params);
+                    conn.sendResponse(ack);
+                    conn.flush();
+                }
+            }
+            
+            // Create Axis request and response objects
+            AxisHttpRequestImpl axisreq = new AxisHttpRequestImpl(
+                    conn, 
+                    request, 
+                    this.httpProcessor, 
+                    context); 
+            AxisHttpResponseImpl axisres = new AxisHttpResponseImpl(
+                    conn, 
+                    response, 
+                    this.httpProcessor, 
+                    context); 
+
+            // Prepare HTTP request
+            axisreq.prepare();
+            
+            // Run the service
+            doService(axisreq, axisres, context);
+            
+            // Make sure the request content is fully consumed
+            InputStream instream = conn.getInputStream();
+            if (instream != null) {
+                instream.close();
+            }
+
+            // Commit response if not committed
+            if (!axisres.isCommitted()) {
+                axisres.commit();
+            }
+
+            // Make sure the response content is properly terminated
+            OutputStream outstream = conn.getOutputStream();
+            if (outstream != null) {
+                outstream.close();
+            }
+            
+        } catch (HttpException ex) {
+            response = this.responseFactory.newHttpResponse
+                (HttpVersion.HTTP_1_0, HttpStatus.SC_INTERNAL_SERVER_ERROR,
+                 context);
+            response.getParams().setDefaults(this.params);
+            handleException(ex, response);
+            this.httpProcessor.process(response, context);
+            conn.sendResponse(response);
+        }
+        
+        conn.flush();
+        if (!this.connStrategy.keepAlive(response, context)) {
+            conn.close();
+        } else {
+            conn.reset();
+        }
+    }    
+    
+    protected void handleException(final HttpException ex, final HttpResponse response) {
+        if (ex instanceof MethodNotSupportedException) {
+            response.setStatusCode(HttpStatus.SC_NOT_IMPLEMENTED);
+        } else if (ex instanceof UnsupportedHttpVersionException) {
+            response.setStatusCode(HttpStatus.SC_HTTP_VERSION_NOT_SUPPORTED);
+        } else if (ex instanceof ProtocolException) {
+            response.setStatusCode(HttpStatus.SC_BAD_REQUEST);
+        } else {
+            response.setStatusCode(HttpStatus.SC_INTERNAL_SERVER_ERROR);
+        }
+    }
+       
     protected void doService(
-            final HttpRequest request,
-            final HttpResponse response,
+            final AxisHttpRequest request, 
+            final AxisHttpResponse response,
             final HttpContext context) throws HttpException, IOException {
-        RequestLine reqline = request.getRequestLine();
         if (LOG.isDebugEnabled()) {
-            LOG.debug("Request method: " + reqline.getMethod());
-            LOG.debug("Target URI: " + reqline.getUri());
+            LOG.debug("Request method: " + request.getMethod());
+            LOG.debug("Target URI: " + request.getRequestURI());
         }
 
-        HttpVersion ver = reqline.getHttpVersion();
-        if (!ver.lessEquals(HttpVersion.HTTP_1_1)) {
-            throw new UnsupportedHttpVersionException("Unsupported HTTP version: " + ver);
-        }
-
         try {
             TransportOutDescription transportOut = this.configurationContext.getAxisConfiguration()
                     .getTransportOut(Constants.TRANSPORT_HTTP);
@@ -127,7 +250,8 @@
             this.msgContext.setTransportOut(transportOut);
             this.msgContext.setServerSide(true);
             this.msgContext.setProperty(HTTPConstants.COOKIE_STRING, sessionKey);
-            this.msgContext.setProperty(Constants.Configuration.TRANSPORT_IN_URL, reqline.getUri());
+            this.msgContext.setProperty(Constants.Configuration.TRANSPORT_IN_URL, 
+                    request.getRequestURI());
 
             // set the transport Headers
             HashMap headerMap = new HashMap();
@@ -135,7 +259,17 @@
                 Header header = (Header) it.next();
                 headerMap.put(header.getName(), header.getValue());
             }
-            this.msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, headerMap);
+            this.msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, 
+                    headerMap);
+            
+            this.msgContext.setProperty(MessageContext.TRANSPORT_OUT, 
+                    response.getOutputStream());
+            this.msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, 
+                    response);
+            this.msgContext.setTo(new EndpointReference(request.getRequestURI()));
+            this.msgContext.setProperty(RequestResponseTransport.TRANSPORT_CONTROL,
+                                   new SimpleHTTPRequestResponseTransport());
+            
             this.worker.service(request, response, this.msgContext);
         } catch (SocketException ex) {
             // Socket is unreliable. 
@@ -144,59 +278,60 @@
             // HTTP protocol violation. Transport is unrelaible
             throw ex;
         } catch (Throwable e) {
-            try {
-                AxisEngine engine = new AxisEngine(this.configurationContext);
 
-                OutputBuffer outbuffer = new OutputBuffer();
-                this.msgContext
-                        .setProperty(MessageContext.TRANSPORT_OUT, outbuffer.getOutputStream());
-                this.msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outbuffer);
+            AxisEngine engine = new AxisEngine(this.configurationContext);
 
-                MessageContext faultContext =
-                        MessageContextBuilder.createFaultMessageContext(msgContext, e);
-                // If the fault is not going along the back channel we should be 202ing
-                if (AddressingHelper.isFaultRedirected(this.msgContext)) {
-                    response.setStatusLine(new BasicStatusLine(ver, 202, "Accepted"));
-                } else {
-                    response.setStatusLine(new BasicStatusLine(ver, 500, "Internal server error"));
-                }
-                engine.sendFault(faultContext);
-                response.setEntity(outbuffer);
-            } catch (Exception ex) {
-                if (AddressingHelper.isFaultRedirected(this.msgContext)) {
-                    response.setStatusLine(new BasicStatusLine(ver, 202, "Accepted"));
-                } else {
-                    // TODO: Why isn't this a SOAP fault?
-                    response.setStatusLine(new BasicStatusLine(ver, 500, "Internal server error"));
-                    String msg = ex.getMessage();
-                    StringEntity entity;
-                    if (msg != null && msg.trim().length() != 0) {
-                        entity = new StringEntity(msg);
-                    } else {
-                        entity = new StringEntity("Exception message unknown");
-                    }
-                    entity.setContentType("text/plain");
-                    response.setEntity(entity);
-                }
+            this.msgContext.setProperty(MessageContext.TRANSPORT_OUT, 
+                    response.getOutputStream());
+            this.msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, 
+                    response);
+
+            MessageContext faultContext =
+                    MessageContextBuilder.createFaultMessageContext(msgContext, e);
+            // If the fault is not going along the back channel we should be 202ing
+            if (AddressingHelper.isFaultRedirected(this.msgContext)) {
+                response.setStatus(HttpStatus.SC_ACCEPTED);
+            } else {
+                response.sendError(HttpStatus.SC_INTERNAL_SERVER_ERROR, "Internal server error");
             }
+            engine.sendFault(faultContext);
         }
 
     }
 
-    public void handleRequest(final HttpServerConnection conn, final HttpContext context)
-            throws IOException, HttpException {
-        if (conn instanceof HttpInetConnection) {
-            HttpInetConnection inetconn = (HttpInetConnection) conn;
-            InetAddress address = inetconn.getRemoteAddress();
-            this.msgContext.setProperty(MessageContext.REMOTE_ADDR, address.getHostAddress());
+    class SimpleHTTPRequestResponseTransport implements RequestResponseTransport {
 
-            if (LOG.isDebugEnabled()) {
-                LOG.debug("Remote address of the connection : " + address);
-            }
+        private CountDownLatch responseReadySignal = new CountDownLatch(1);
+        RequestResponseTransportStatus status = RequestResponseTransportStatus.INITIAL;
+        AxisFault faultToBeThrownOut = null;
+        
+        public void acknowledgeMessage(MessageContext msgContext) throws AxisFault {
+            //TODO: Once the core HTTP API allows us to return an ack before unwinding, then the should be fixed
+            signalResponseReady();
         }
-        this.msgContext.setProperty(MessageContext.TRANSPORT_ADDR,
-                ((DefaultHttpConnectionFactory.Axis2HttpServerConnection)conn).getLocalIPAddress());
-        super.handleRequest(conn, context);
+
+        public void awaitResponse() throws InterruptedException,AxisFault {
+            status = RequestResponseTransportStatus.WAITING;
+            responseReadySignal.await();
+            
+            if (faultToBeThrownOut!=null)
+                throw faultToBeThrownOut;
+        }
+
+        public void signalResponseReady() {
+            status = RequestResponseTransportStatus.SIGNALLED;
+            responseReadySignal.countDown();
+        }
+
+        public RequestResponseTransportStatus getStatus() {
+            return status;
+        }
+
+        public void signalFaultReady(AxisFault fault) {
+            faultToBeThrownOut = fault;
+            signalResponseReady();
+        }
+        
     }
-
+    
 }
Index: modules/kernel/src/org/apache/axis2/transport/http/server/HttpConnectionFactory.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/HttpConnectionFactory.java	(revision 525829)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/HttpConnectionFactory.java	(working copy)
@@ -1,41 +0,0 @@
-/*
- * $HeadURL$
- * $Revision$
- * $Date$
- *
- * ====================================================================
- *
- *  Copyright 1999-2006 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- *
- */
-
-package org.apache.axis2.transport.http.server;
-
-import org.apache.http.HttpServerConnection;
-
-import java.io.IOException;
-import java.net.Socket;
-
-public interface HttpConnectionFactory {
-
-    HttpServerConnection newConnection(Socket socket) throws IOException;
-
-}
Index: modules/kernel/src/org/apache/axis2/transport/http/server/LoggingProcessorDecorator.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/LoggingProcessorDecorator.java	(revision 525829)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/LoggingProcessorDecorator.java	(working copy)
@@ -1,84 +0,0 @@
-/*
-* $HeadURL$
-* $Revision$
-* $Date$
-*
-* ====================================================================
-*
-*  Copyright 1999-2004 The Apache Software Foundation
-*
-*  Licensed under the Apache License, Version 2.0 (the "License");
-*  you may not use this file except in compliance with the License.
-*  You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-*  Unless required by applicable law or agreed to in writing, software
-*  distributed under the License is distributed on an "AS IS" BASIS,
-*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-*  See the License for the specific language governing permissions and
-*  limitations under the License.
-* ====================================================================
-*
-* This software consists of voluntary contributions made by many
-* individuals on behalf of the Apache Software Foundation.  For more
-* information on the Apache Software Foundation, please see
-* <http://www.apache.org/>.
-*/
-package org.apache.axis2.transport.http.server;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.http.Header;
-import org.apache.http.HttpException;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpResponse;
-import org.apache.http.protocol.HttpContext;
-import org.apache.http.protocol.HttpProcessor;
-
-import java.io.IOException;
-
-/**
- * This class wraps an arbitrary {@link HttpProcessor} and extends it with
- * an additional request / response debugging service
- */
-public class LoggingProcessorDecorator implements HttpProcessor {
-
-    private static final Log HEADERLOG =
-            LogFactory.getLog("org.apache.axis2.transport.http.server.wire");
-
-    final private HttpProcessor httpProcessor;
-
-    public LoggingProcessorDecorator(final HttpProcessor httpProcessor) {
-        super();
-        if (httpProcessor == null) {
-            throw new IllegalArgumentException("HTTP processor may not be null");
-        }
-        this.httpProcessor = httpProcessor;
-    }
-
-    public void process(final HttpRequest request, final HttpContext context)
-            throws HttpException, IOException {
-        this.httpProcessor.process(request, context);
-        if (HEADERLOG.isDebugEnabled()) {
-            HEADERLOG.debug(">> " + request.getRequestLine().toString());
-            Header[] headers = request.getAllHeaders();
-            for (int i = 0; i < headers.length; i++) {
-                HEADERLOG.debug(">> " + headers[i].toString());
-            }
-        }
-    }
-
-    public void process(final HttpResponse response, final HttpContext context)
-            throws HttpException, IOException {
-        this.httpProcessor.process(response, context);
-        if (HEADERLOG.isDebugEnabled()) {
-            HEADERLOG.debug("<< " + response.getStatusLine().toString());
-            Header[] headers = response.getAllHeaders();
-            for (int i = 0; i < headers.length; i++) {
-                HEADERLOG.debug("<< " + headers[i].toString());
-            }
-        }
-    }
-
-}
Index: modules/kernel/src/org/apache/axis2/transport/http/server/HttpConnectionManager.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/HttpConnectionManager.java	(revision 525829)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/HttpConnectionManager.java	(working copy)
@@ -29,11 +29,9 @@
 
 package org.apache.axis2.transport.http.server;
 
-import org.apache.http.HttpServerConnection;
-
 public interface HttpConnectionManager {
 
-    void process(HttpServerConnection incoming);
+    void process(AxisHttpConnection incoming);
 
     void shutdown();
 
Index: modules/kernel/src/org/apache/axis2/transport/http/server/OutputBuffer.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/OutputBuffer.java	(revision 525829)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/OutputBuffer.java	(working copy)
@@ -1,152 +0,0 @@
-/*
-* $HeadURL$
-* $Revision$
-* $Date$
-*
-* ====================================================================
-*
-*  Copyright 1999-2004 The Apache Software Foundation
-*
-*  Licensed under the Apache License, Version 2.0 (the "License");
-*  you may not use this file except in compliance with the License.
-*  You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-*  Unless required by applicable law or agreed to in writing, software
-*  distributed under the License is distributed on an "AS IS" BASIS,
-*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-*  See the License for the specific language governing permissions and
-*  limitations under the License.
-* ====================================================================
-*
-* This software consists of voluntary contributions made by many
-* individuals on behalf of the Apache Software Foundation.  For more
-* information on the Apache Software Foundation, please see
-* <http://www.apache.org/>.
-*/
-package org.apache.axis2.transport.http.server;
-
-import org.apache.axis2.transport.OutTransportInfo;
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.message.BasicHeader;
-import org.apache.http.protocol.HTTP;
-import org.apache.http.util.ByteArrayBuffer;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-public class OutputBuffer implements OutTransportInfo, HttpEntity {
-
-    private final ByteArrayBuffer buffer;
-    private String contentType;
-    private boolean chunked;
-
-    public OutputBuffer(int initialCapacity) {
-        super();
-        this.buffer = new ByteArrayBuffer(initialCapacity);
-        this.contentType = "text/xml";
-    }
-
-    public OutputBuffer() {
-        this(1024);
-    }
-
-    public OutputStream getOutputStream() {
-        return new BufferOutputStream(this.buffer);
-    }
-
-    public InputStream getContent() throws IOException, IllegalStateException {
-        return new ByteArrayInputStream(this.buffer.toByteArray());
-    }
-
-    public void setContentType(final String contentType) {
-        this.contentType = contentType;
-    }
-
-    public Header getContentType() {
-        return new BasicHeader(HTTP.CONTENT_TYPE, this.contentType);
-    }
-
-    public void consumeContent() throws IOException {
-    }
-
-    public Header getContentEncoding() {
-        return null;
-    }
-
-    public long getContentLength() {
-        return this.buffer.length();
-    }
-
-    public boolean isChunked() {
-        return this.chunked;
-    }
-
-    public void setChunked(boolean b) {
-        this.chunked = b;
-    }
-
-    public boolean isRepeatable() {
-        return true;
-    }
-
-    public boolean isStreaming() {
-        return false;
-    }
-
-    public void writeTo(final OutputStream outstream) throws IOException {
-        outstream.write(this.buffer.buffer(), 0, this.buffer.length());
-    }
-
-    public String toString() {
-        return new String(this.buffer.buffer(), 0, this.buffer.length());
-    }
-
-    private static class BufferOutputStream extends OutputStream {
-
-        private final ByteArrayBuffer buffer;
-        private boolean closed = false;
-
-        public BufferOutputStream(final ByteArrayBuffer buffer) {
-            super();
-            this.buffer = buffer;
-        }
-
-        public void close() throws IOException {
-            this.closed = true;
-        }
-
-        private void ensureNotClosed() {
-            if (this.closed) {
-                throw new IllegalStateException("Stream closed");
-            }
-        }
-
-        public void write(byte[] b, int off, int len) throws IOException {
-            ensureNotClosed();
-            if (b == null) {
-                return;
-            }
-            this.buffer.append(b, off, len);
-        }
-
-        public void write(byte[] b) throws IOException {
-            ensureNotClosed();
-            if (b == null) {
-                return;
-            }
-            this.buffer.append(b, 0, b.length);
-        }
-
-        public void write(int b) throws IOException {
-            ensureNotClosed();
-            this.buffer.append(b);
-        }
-
-    }
-
-}
Index: modules/kernel/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionFactory.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionFactory.java	(revision 525829)
+++ modules/kernel/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionFactory.java	(working copy)
@@ -1,103 +0,0 @@
-/*
- * $HeadURL:https://svn.apache.org/repos/asf/jakarta/httpcomponents/trunk/coyote-httpconnector/src/java/org/apache/http/tcconnector/impl/DefaultHttpConnectionFactory.java $
- * $Revision:379772 $
- * $Date:2006-02-22 14:52:29 +0100 (Wed, 22 Feb 2006) $
- *
- * ====================================================================
- *
- *  Copyright 1999-2006 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- *
- */
-
-package org.apache.axis2.transport.http.server;
-
-import org.apache.http.HttpServerConnection;
-import org.apache.http.impl.DefaultHttpServerConnection;
-import org.apache.http.params.HttpParams;
-
-import java.io.IOException;
-import java.net.Socket;
-
-public class DefaultHttpConnectionFactory implements HttpConnectionFactory {
-
-    final HttpParams params;
-
-    public DefaultHttpConnectionFactory(final HttpParams params) {
-        super();
-        if (params == null) {
-            throw new IllegalArgumentException("HTTP parameters may not be null");
-        }
-        this.params = params;
-    }
-
-    public HttpServerConnection newConnection(final Socket socket)
-            throws IOException {
-        DefaultHttpServerConnection conn = new Axis2HttpServerConnection();
-        conn.bind(socket, this.params);
-        return conn;
-    }
-
-    public class Axis2HttpServerConnection extends DefaultHttpServerConnection {
-        public Axis2HttpServerConnection() {
-            super();
-        }
-        //((InetAddress)socket.getLocalAddress()).getHostAddress()
-
-        public String getRemoteIPAddress() {
-            java.net.SocketAddress sa = socket.getRemoteSocketAddress();
-            if (sa instanceof java.net.InetSocketAddress) {
-                return ((java.net.InetSocketAddress) sa).getAddress().getHostAddress();
-            } else {
-                return sa.toString();
-            }
-        }
-
-         public String getLocalIPAddress() {
-            java.net.SocketAddress sa = socket.getLocalSocketAddress();
-            if (sa instanceof java.net.InetSocketAddress) {
-                return ((java.net.InetSocketAddress) sa).getAddress().getHostAddress()
-                        + ":" + socket.getLocalPort();
-            } else {
-                return sa.toString();
-            }
-        }
-
-        public String getRemoteHostName() {
-            java.net.SocketAddress sa = socket.getRemoteSocketAddress();
-            if (sa instanceof java.net.InetSocketAddress) {
-                return ((java.net.InetSocketAddress) sa).getHostName();
-            } else {
-                return sa.toString();
-                // fail-safe and fall back to something which one can use in place of the host name
-            }
-        }
-         public String getLocalHostName() {
-            java.net.SocketAddress sa = socket.getLocalSocketAddress();
-            if (sa instanceof java.net.InetSocketAddress) {
-                return ((java.net.InetSocketAddress) sa).getHostName();
-            } else {
-                return sa.toString();
-                // fail-safe and fall back to something which one can use in place of the host name
-            }
-        }
-    }
-
-}
Index: modules/parent/pom.xml
===================================================================
--- modules/parent/pom.xml	(revision 525829)
+++ modules/parent/pom.xml	(working copy)
@@ -101,7 +101,7 @@
         <commons.logging.version>1.1</commons.logging.version>
         <geronimo.spec.jms.version>1.1-rc4</geronimo.spec.jms.version>
         <groovy.all.version>1.0-jsr-06</groovy.all.version>
-        <jakarta.httpcore.version>4.0-alpha3</jakarta.httpcore.version>
+        <jakarta.httpcore.version>4.0-alpha4</jakarta.httpcore.version>
         <javamail.version>1.4</javamail.version>
         <jaxbri.version>2.0.2</jaxbri.version>
         <jaxen.version>1.1-beta-10</jaxen.version>
@@ -542,7 +542,7 @@
             <dependency>
                 <groupId>org.apache.httpcomponents</groupId>
                 <artifactId>jakarta-httpcore</artifactId>
-                <version>4.0-alpha3</version>
+                <version>4.0-alpha4</version>
             </dependency>
             <dependency>
                 <groupId>wsdl4j</groupId>
Index: etc/project.properties
===================================================================
--- etc/project.properties	(revision 525829)
+++ etc/project.properties	(working copy)
@@ -113,7 +113,7 @@
 fastinfoset.version=1.2.1
 geronimo.spec.jms.version=1.1-rc4
 groovy.all.version=1.0-jsr-06
-jakarta.httpcore.version=4.0-alpha3
+jakarta.httpcore.version=4.0-alpha4
 javamail.version=1.4
 jaxbri.version=2.0.2
 jaxen.version=1.1-beta-10
