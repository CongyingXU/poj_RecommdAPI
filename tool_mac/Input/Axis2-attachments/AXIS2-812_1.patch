Index: modules/core/src/org/apache/axis2/transport/http/HTTPWorkerFactory.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/HTTPWorkerFactory.java	(revision 413684)
+++ modules/core/src/org/apache/axis2/transport/http/HTTPWorkerFactory.java	(working copy)
@@ -29,24 +29,17 @@
 
 package org.apache.axis2.transport.http;
 
-import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.transport.http.server.Worker;
 import org.apache.axis2.transport.http.server.WorkerFactory;
 
 public class HTTPWorkerFactory implements WorkerFactory {
 
-    final ConfigurationContext configurationContext;
-    
-    public HTTPWorkerFactory(final ConfigurationContext configurationContext) {
+    public HTTPWorkerFactory() {
         super();
-        if (configurationContext == null) {
-            throw new IllegalArgumentException("Configuration context may not be null");
-        }
-        this.configurationContext = configurationContext;
     }
     
     public Worker newWorker() {
-        return new HTTPWorker(this.configurationContext);
+        return new HTTPWorker();
     }
     
 }
Index: modules/core/src/org/apache/axis2/transport/http/HTTPWorker.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/HTTPWorker.java	(revision 413684)
+++ modules/core/src/org/apache/axis2/transport/http/HTTPWorker.java	(working copy)
@@ -18,38 +18,19 @@
 
 import java.io.IOException;
 import java.io.OutputStream;
-import java.net.SocketException;
-import java.util.Date;
 import java.util.HashMap;
 import java.util.Hashtable;
-import java.util.Iterator;
 
-import javax.xml.namespace.QName;
-
-import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.context.OperationContext;
-import org.apache.axis2.context.ServiceContext;
-import org.apache.axis2.context.ServiceGroupContext;
-import org.apache.axis2.context.SessionContext;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.Parameter;
-import org.apache.axis2.description.TransportInDescription;
 import org.apache.axis2.description.TransportOutDescription;
-import org.apache.axis2.engine.AxisEngine;
-import org.apache.axis2.engine.DependencyManager;
-import org.apache.axis2.i18n.Messages;
-import org.apache.axis2.transport.http.HTTPConstants;
-import org.apache.axis2.transport.http.HTTPTransportReceiver;
-import org.apache.axis2.transport.http.HTTPTransportUtils;
-import org.apache.axis2.transport.http.server.OutputBuffer;
 import org.apache.axis2.transport.http.server.HttpUtils;
+import org.apache.axis2.transport.http.server.OutputBuffer;
 import org.apache.axis2.transport.http.server.Worker;
-import org.apache.axis2.util.UUIDGenerator;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpEntityEnclosingRequest;
@@ -66,134 +47,142 @@
 
 public class HTTPWorker implements Worker {
 
-    private static final Log log = LogFactory.getLog(HTTPWorker.class);
-    
-    private ConfigurationContext configurationContext;
-    // to store session object
-    private static Hashtable sessionContextTable = new Hashtable();
-    private String contextPath = null;
-    private String servicePath = null;
-
-    public HTTPWorker(ConfigurationContext configurationContext) {
-        this.configurationContext = configurationContext;
-        contextPath = configurationContext.getContextPath() + "/";
-        servicePath = configurationContext.getServicePath();
+    public HTTPWorker() {
     }
 
-    public void service(final HttpRequest request, final HttpResponse response) 
-            throws HttpException, IOException {    
-        MessageContext msgContext = new MessageContext();
-        msgContext.setIncomingTransportName(Constants.TRANSPORT_HTTP);
-        try {
-            if (configurationContext == null) {
-                throw new AxisFault(Messages.getMessage("cannotBeNullConfigurationContext"));
-            }
-            // Get relevant request parameters
-            HttpVersion ver = request.getRequestLine().getHttpVersion();
-            String uri = request.getRequestLine().getUri();
-            String method = request.getRequestLine().getMethod();
+    public void service(
+            final HttpRequest request, 
+            final HttpResponse response, 
+            final MessageContext msgContext) throws HttpException, IOException {    
 
-            String soapAction = HttpUtils.getSoapAction(request);
-            String cookieID = HttpUtils.getCookieID(request);
-            
-            boolean chunked = false;
+        ConfigurationContext configurationContext = msgContext.getConfigurationContext();
+        final String contextPath = configurationContext.getContextPath() + "/";;
+        final String servicePath = configurationContext.getServicePath();;
 
-            TransportOutDescription transportOut = configurationContext.getAxisConfiguration()
-                .getTransportOut(new QName(Constants.TRANSPORT_HTTP));
-            TransportInDescription transportIn = configurationContext.getAxisConfiguration()
-                .getTransportIn(new QName(Constants.TRANSPORT_HTTP));            
+        HttpVersion ver = request.getRequestLine().getHttpVersion();
+        String uri = request.getRequestLine().getUri();
+        String method = request.getRequestLine().getMethod();
+        String soapAction = HttpUtils.getSoapAction(request);
         
-            // Configure message context
-            msgContext.setConfigurationContext(configurationContext);
-            if (configurationContext.getAxisConfiguration().isManageTransportSession()) {
-                SessionContext sessionContext = getSessionContext(cookieID);
-                msgContext.setSessionContext(sessionContext);
+        // Adjust version and content chunking based on the config
+        boolean chunked = false;
+        TransportOutDescription transportOut = msgContext.getTransportOut();
+        if (transportOut != null) {
+            Parameter p = transportOut.getParameter(HTTPConstants.PROTOCOL_VERSION);
+            if (p != null) {
+                if (HTTPConstants.HEADER_PROTOCOL_10.equals(p.getValue())) {
+                    ver = HttpVersion.HTTP_1_0;
+                }
             }
-            msgContext.setTransportIn(transportIn);
-            msgContext.setTransportOut(transportOut);
-            msgContext.setServiceGroupContextId(UUIDGenerator.getUUID());
-            msgContext.setServerSide(true);
-            msgContext.setProperty(Constants.Configuration.TRANSPORT_IN_URL, uri);
-
-            // set the transport Headers
-            HashMap headerMap = new HashMap();
-            Header[] headers = request.getAllHeaders();
-            for (int i = 0; i < headers.length; i++) {
-                headerMap.put(headers[i].getName(), headers[i].getValue());
-            }
-            msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, headerMap);
-
-            // Adjust version and content chunking based on the config
-            if (transportOut != null) {
-                Parameter p = transportOut.getParameter(HTTPConstants.PROTOCOL_VERSION);
+            if (ver.greaterEquals(HttpVersion.HTTP_1_1)) {
+                p = transportOut.getParameter(HTTPConstants.HEADER_TRANSFER_ENCODING);
                 if (p != null) {
-                    if (HTTPConstants.HEADER_PROTOCOL_10.equals(p.getValue())) {
-                        ver = HttpVersion.HTTP_1_0;
+                    if (HTTPConstants.HEADER_TRANSFER_ENCODING_CHUNKED.equals(p.getValue())) {
+                        chunked = true;
                     }
                 }
-                if (ver.greaterEquals(HttpVersion.HTTP_1_1)) {
-                    p = transportOut.getParameter(HTTPConstants.HEADER_TRANSFER_ENCODING);
-                    if (p != null) {
-                        if (HTTPConstants.HEADER_TRANSFER_ENCODING_CHUNKED.equals(p.getValue())) {
-                            chunked = true;
-                        }
+            }
+        }
+        
+        if (method.equals(HTTPConstants.HEADER_GET)) {
+            if (uri.equals("/favicon.ico")) {
+                response.setStatusLine(new StatusLine(ver, 301, "Redirect"));
+                response.addHeader(new Header("Location", "http://ws.apache.org/favicon.ico"));
+                return;
+            }
+            if (!uri.startsWith(contextPath)) {
+                response.setStatusLine(new StatusLine(ver, 301, "Redirect"));
+                response.addHeader(new Header("Location", contextPath));
+                return;
+            }
+            if (uri.indexOf("?") < 0) {
+                if (!(uri.endsWith(contextPath) || uri.endsWith(contextPath+"/"))) {
+                    String serviceName = uri.replaceAll(contextPath+"/", "");
+                    if (serviceName.indexOf("/") < 0) {
+                        String res = HTTPTransportReceiver.printServiceHTML(serviceName, configurationContext);
+                        StringEntity entity = new StringEntity(res);
+                        entity.setContentType("text/html");
+                        entity.setChunked(chunked);
+                        response.setEntity(entity);
+                        return;
                     }
                 }
             }
+            if (uri.endsWith("?wsdl2")) {
+                String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.length() - 6);
+                HashMap services = configurationContext.getAxisConfiguration().getServices();
+                final AxisService service = (AxisService) services.get(serviceName);
+                if (service != null) {
+                    final String ip = HttpUtils.getIpAddress();
+                    EntityTemplate entity = new EntityTemplate(new ContentProducer() {
 
-            if (method.equals(HTTPConstants.HEADER_GET)) {
-                if (uri.equals("/favicon.ico")) {
-                    response.setStatusLine(new StatusLine(ver, 301, "Redirect"));
-                    response.addHeader(new Header("Location", "http://ws.apache.org/favicon.ico"));
+                        public void writeTo(final OutputStream outstream) throws IOException {
+                            service.printWSDL2(outstream, ip, servicePath);
+                        }
+                        
+                    });
+                    entity.setContentType("text/xml");
+                    entity.setChunked(chunked);
+                    response.setEntity(entity);
                     return;
                 }
-                if (!uri.startsWith(contextPath)) {
-                    response.setStatusLine(new StatusLine(ver, 301, "Redirect"));
-                    response.addHeader(new Header("Location", contextPath));
+            }
+            if (uri.endsWith("?wsdl")) {
+                String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.length() - 5);
+                HashMap services = configurationContext.getAxisConfiguration().getServices();
+                final AxisService service = (AxisService) services.get(serviceName);
+                if (service != null) {
+                    final String ip = HttpUtils.getIpAddress();
+                    EntityTemplate entity = new EntityTemplate(new ContentProducer() {
+
+                        public void writeTo(final OutputStream outstream) throws IOException {
+                            service.printWSDL(outstream, ip, servicePath);
+                        }
+                        
+                    });
+                    entity.setContentType("text/xml");
+                    entity.setChunked(chunked);
+                    response.setEntity(entity);
                     return;
                 }
-                if (uri.indexOf("?") < 0) {
-                    if (!(uri.endsWith(contextPath) || uri.endsWith(contextPath+"/"))) {
-                        String serviceName = uri.replaceAll(contextPath+"/", "");
-                        if (serviceName.indexOf("/") < 0) {
-                            String res = HTTPTransportReceiver.printServiceHTML(serviceName, configurationContext);
-                            StringEntity entity = new StringEntity(res);
-                            entity.setContentType("text/html");
-                            entity.setChunked(chunked);
-                            response.setEntity(entity);
-                            return;
+            }
+            if (uri.endsWith("?xsd")) {
+                String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.length() - 4);
+                HashMap services = configurationContext.getAxisConfiguration().getServices();
+                final AxisService service = (AxisService) services.get(serviceName);
+                if (service != null) {
+                    EntityTemplate entity = new EntityTemplate(new ContentProducer() {
+
+                        public void writeTo(final OutputStream outstream) throws IOException {
+                            service.printSchema(outstream);
                         }
-                    }
+                        
+                    });
+                    entity.setContentType("text/xml");
+                    entity.setChunked(chunked);
+                    response.setEntity(entity);
+                    return;
                 }
-                if (uri.endsWith("?wsdl2")) {
-                    String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.length() - 6);
-                    HashMap services = configurationContext.getAxisConfiguration().getServices();
-                    final AxisService service = (AxisService) services.get(serviceName);
-                    if (service != null) {
-                        final String ip = HttpUtils.getIpAddress();
-                        EntityTemplate entity = new EntityTemplate(new ContentProducer() {
+            }
+            //cater for named xsds - check for the xsd name
+            if (uri.indexOf("?xsd=") > 0) {
+                String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.lastIndexOf("?xsd="));
+                String schemaName = uri.substring(uri.lastIndexOf("=") + 1);
 
-                            public void writeTo(final OutputStream outstream) throws IOException {
-                                service.printWSDL2(outstream, ip, servicePath);
-                            }
-                            
-                        });
-                        entity.setContentType("text/xml");
-                        entity.setChunked(chunked);
-                        response.setEntity(entity);
-                        return;
-                    }
-                }
-                if (uri.endsWith("?wsdl")) {
-                    String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.length() - 5);
-                    HashMap services = configurationContext.getAxisConfiguration().getServices();
-                    final AxisService service = (AxisService) services.get(serviceName);
-                    if (service != null) {
-                        final String ip = HttpUtils.getIpAddress();
+                HashMap services = configurationContext.getAxisConfiguration().getServices();
+                AxisService service = (AxisService) services.get(serviceName);
+                if (service != null) {
+                    //run the population logic just to be sure
+                    service.populateSchemaMappings();
+                    //write out the correct schema
+                    Hashtable schemaTable = service.getSchemaMappingTable();
+                    final XmlSchema schema = (XmlSchema)schemaTable.get(schemaName);
+                    //schema found - write it to the stream
+                    if (schema != null) {
                         EntityTemplate entity = new EntityTemplate(new ContentProducer() {
 
                             public void writeTo(final OutputStream outstream) throws IOException {
-                                service.printWSDL(outstream, ip, servicePath);
+                                schema.write(outstream);
                             }
                             
                         });
@@ -201,220 +190,77 @@
                         entity.setChunked(chunked);
                         response.setEntity(entity);
                         return;
-                    }
-                }
-                if (uri.endsWith("?xsd")) {
-                    String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.length() - 4);
-                    HashMap services = configurationContext.getAxisConfiguration().getServices();
-                    final AxisService service = (AxisService) services.get(serviceName);
-                    if (service != null) {
-                        EntityTemplate entity = new EntityTemplate(new ContentProducer() {
-
-                            public void writeTo(final OutputStream outstream) throws IOException {
-                                service.printSchema(outstream);
-                            }
-                            
-                        });
-                        entity.setContentType("text/xml");
-                        entity.setChunked(chunked);
-                        response.setEntity(entity);
+                    } else {
+                        // no schema available by that name  - send 404
+                        response.setStatusLine(new StatusLine(ver, 404, "Schema Not Found!"));
                         return;
                     }
                 }
-                //cater for named xsds - check for the xsd name
-                if (uri.indexOf("?xsd=") > 0) {
-                    String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.lastIndexOf("?xsd="));
-                    String schemaName = uri.substring(uri.lastIndexOf("=") + 1);
+            }
 
-                    HashMap services = configurationContext.getAxisConfiguration().getServices();
-                    AxisService service = (AxisService) services.get(serviceName);
-                    if (service != null) {
-                        //run the population logic just to be sure
-                        service.populateSchemaMappings();
-                        //write out the correct schema
-                        Hashtable schemaTable = service.getSchemaMappingTable();
-                        final XmlSchema schema = (XmlSchema)schemaTable.get(schemaName);
-                        //schema found - write it to the stream
-                        if (schema != null) {
-                            EntityTemplate entity = new EntityTemplate(new ContentProducer() {
+            OutputBuffer outbuffer = new OutputBuffer(); 
+            msgContext.setProperty(MessageContext.TRANSPORT_OUT, outbuffer);
+            msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outbuffer);
 
-                                public void writeTo(final OutputStream outstream) throws IOException {
-                                    schema.write(outstream);
-                                }
-                                
-                            });
-                            entity.setContentType("text/xml");
-                            entity.setChunked(chunked);
-                            response.setEntity(entity);
-                            return;
-                        } else {
-                            // no schema available by that name  - send 404
-                            response.setStatusLine(new StatusLine(ver, 404, "Schema Not Found!"));
-                            return;
-                        }
-                    }
-                }
-
-                OutputBuffer outbuffer = new OutputBuffer(); 
-                msgContext.setProperty(MessageContext.TRANSPORT_OUT, outbuffer);
-                msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outbuffer);
-
-                // deal with GET request
-                boolean processed = HTTPTransportUtils.processHTTPGetRequest(
-                        msgContext, 
-                        outbuffer.getOutputStream(), 
-                        soapAction, 
-                        uri,
-                        configurationContext,
-                        HTTPTransportReceiver.getGetRequestParameters(uri));
-                
-                if (processed) {
-                    outbuffer.setChunked(chunked);
-                    response.setEntity(outbuffer);
-                } else {
-                    response.setStatusLine(new StatusLine(ver, 200, "OK"));
-                    String s = HTTPTransportReceiver.getServicesHTML(configurationContext);
-                    StringEntity entity = new StringEntity(s);
-                    entity.setContentType("text/html");
-                    entity.setChunked(chunked);
-                    response.setEntity(entity);
-                }
-                
-            } else if (method.equals(HTTPConstants.HEADER_POST)) {
-                // deal with POST request
-
-                OutputBuffer outbuffer = new OutputBuffer(); 
-                msgContext.setProperty(MessageContext.TRANSPORT_OUT, outbuffer);
-                msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outbuffer);
-
-                HttpEntity inentity = ((HttpEntityEnclosingRequest) request).getEntity();
-                String contenttype = null;
-                if (inentity.getContentType() != null) {
-                    contenttype = inentity.getContentType().getValue();
-                }
-                HTTPTransportUtils.processHTTPPostRequest(
-                        msgContext, 
-                        inentity.getContent(), 
-                        outbuffer.getOutputStream(),
-                        contenttype, 
-                        soapAction, 
-                        uri);
-                
+            // deal with GET request
+            boolean processed = HTTPTransportUtils.processHTTPGetRequest(
+                    msgContext, 
+                    outbuffer.getOutputStream(), 
+                    soapAction, 
+                    uri,
+                    configurationContext,
+                    HTTPTransportReceiver.getGetRequestParameters(uri));
+            
+            if (processed) {
                 outbuffer.setChunked(chunked);
                 response.setEntity(outbuffer);
-                
             } else {
-                throw new MethodNotSupportedException(method + " method not supported");
-            }
-            
-            // Finalize response
-            OperationContext operationContext = msgContext.getOperationContext();
-            Object contextWritten = null;
-            if (operationContext != null) {
-                contextWritten = operationContext.getProperty(Constants.RESPONSE_WRITTEN);
-            }
-            if ((contextWritten != null) && Constants.VALUE_TRUE.equals(contextWritten)) {
                 response.setStatusLine(new StatusLine(ver, 200, "OK"));
-            } else {
-                response.setStatusLine(new StatusLine(ver, 202, "OK"));
+                String s = HTTPTransportReceiver.getServicesHTML(configurationContext);
+                StringEntity entity = new StringEntity(s);
+                entity.setContentType("text/html");
+                entity.setChunked(chunked);
+                response.setEntity(entity);
             }
-            setCookie(response, msgContext);
             
-        } catch (SocketException ex) {
-            // Socket is unreliable. 
-            throw ex;
-        } catch (HttpException ex) {
-            // HTTP protocol violation. Transport is unrelaible
-            throw ex;
-        } catch (Throwable e) {
-            HttpVersion ver = request.getRequestLine().getHttpVersion();
-            try {
-                AxisEngine engine = new AxisEngine(configurationContext);
-                
-                OutputBuffer outbuffer = new OutputBuffer(); 
-                msgContext.setProperty(MessageContext.TRANSPORT_OUT, outbuffer.getOutputStream());
-                msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outbuffer);
+        } else if (method.equals(HTTPConstants.HEADER_POST)) {
+            // deal with POST request
 
-                MessageContext faultContext = engine.createFaultMessageContext(msgContext, e);
+            OutputBuffer outbuffer = new OutputBuffer(); 
+            msgContext.setProperty(MessageContext.TRANSPORT_OUT, outbuffer);
+            msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outbuffer);
 
-                response.setStatusLine(new StatusLine(ver, 500, "Internal server error"));
-                engine.sendFault(faultContext);
-                response.setEntity(outbuffer);
-                setCookie(response, msgContext);
-            } catch (Exception ex) {
-                response.setStatusLine(new StatusLine(ver, 500, "Internal server error"));
-                StringEntity entity = new StringEntity(ex.getMessage());
-                entity.setContentType("text/plain");
-                response.setEntity(entity);
+            HttpEntity inentity = ((HttpEntityEnclosingRequest) request).getEntity();
+            String contenttype = null;
+            if (inentity.getContentType() != null) {
+                contenttype = inentity.getContentType().getValue();
             }
+            HTTPTransportUtils.processHTTPPostRequest(
+                    msgContext, 
+                    inentity.getContent(), 
+                    outbuffer.getOutputStream(),
+                    contenttype, 
+                    soapAction, 
+                    uri);
+            
+            outbuffer.setChunked(chunked);
+            response.setEntity(outbuffer);
+            
+        } else {
+            throw new MethodNotSupportedException(method + " method not supported");
         }
-    }
-
-    private static void setCookie(final HttpResponse response, MessageContext msgContext) {
-        //TODO : provide a way to enable and diable cookies
-        //setting the coolie in the out path
-        Object cookieString = msgContext.getProperty(Constants.COOKIE_STRING);
-        if (cookieString != null) {
-            response.addHeader(new Header(HTTPConstants.HEADER_SET_COOKIE, (String) cookieString));
-            response.addHeader(new Header(HTTPConstants.HEADER_SET_COOKIE2, (String) cookieString));
+        
+        // Finalize response
+        OperationContext operationContext = msgContext.getOperationContext();
+        Object contextWritten = null;
+        if (operationContext != null) {
+            contextWritten = operationContext.getProperty(Constants.RESPONSE_WRITTEN);
         }
-    }
-
-    /**
-     * To get the sessioncontext , if its not there in the hashtable , new one will be created and
-     * added to the list.
-     *
-     * @param cookieID
-     * @return <code>SessionContext</code>
-     */
-    private synchronized SessionContext getSessionContext(String cookieID) {
-        SessionContext sessionContext = null;
-        if (!(cookieID == null || cookieID.trim().equals(""))) {
-            sessionContext = (SessionContext) sessionContextTable.get(cookieID);
+        if ((contextWritten != null) && Constants.VALUE_TRUE.equals(contextWritten)) {
+            response.setStatusLine(new StatusLine(ver, 200, "OK"));
+        } else {
+            response.setStatusLine(new StatusLine(ver, 202, "OK"));
         }
-        if (sessionContext == null) {
-            String cookieString = UUIDGenerator.getUUID();
-            sessionContext = new SessionContext(null);
-            sessionContext.setCookieID(cookieString);
-            sessionContextTable.put(cookieString, sessionContext);
-        }
-        sessionContext.touch();
-        cleanupServiceGroupContexts();
-        return sessionContext;
     }
 
-    private void cleanupServiceGroupContexts() {
-        synchronized (sessionContextTable) {
-            long currentTime = new Date().getTime();
-            Iterator sgCtxtMapKeyIter = sessionContextTable.keySet().iterator();
-            while (sgCtxtMapKeyIter.hasNext()) {
-                String cookieID = (String) sgCtxtMapKeyIter.next();
-                SessionContext sessionContext = (SessionContext) sessionContextTable.get(cookieID);
-                if ((currentTime - sessionContext.getLastTouchedTime()) >
-                        sessionContext.sessionContextTimeoutInterval) {
-                    sgCtxtMapKeyIter.remove();
-                    Iterator serviceGroupContext = sessionContext.getServiceGroupContext();
-                    if (serviceGroupContext != null) {
-                        while (serviceGroupContext.hasNext()) {
-                            ServiceGroupContext groupContext = (ServiceGroupContext) serviceGroupContext.next();
-                            cleanupServiceContextes(groupContext);
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    private void cleanupServiceContextes(ServiceGroupContext serviceGroupContext) {
-        Iterator serviceContecxtes = serviceGroupContext.getServiceContexts();
-        while (serviceContecxtes.hasNext()) {
-            ServiceContext serviceContext = (ServiceContext) serviceContecxtes.next();
-            try {
-                DependencyManager.destroyServiceClass(serviceContext);
-            } catch (AxisFault axisFault) {
-                log.info(axisFault.getMessage());
-            }
-        }
-    }
-
 }
Index: modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java	(revision 413684)
+++ modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java	(working copy)
@@ -33,6 +33,7 @@
 import java.util.LinkedList;
 import java.util.List;
 
+import org.apache.axis2.context.ConfigurationContext;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.http.HttpServerConnection;
@@ -48,6 +49,7 @@
 
     private static Log LOG = LogFactory.getLog(DefaultHttpConnectionManager.class);
     
+    private final ConfigurationContext configurationContext;
     private final Executor executor;
     private final WorkerFactory workerfactory;
     private final HttpParams params;
@@ -56,10 +58,14 @@
     private HttpFactory httpFactory = null;
     
     public DefaultHttpConnectionManager(
+            final ConfigurationContext configurationContext,
     		final Executor executor,
             final WorkerFactory workerfactory,
     		final HttpParams params) {
         super();
+        if (configurationContext == null) {
+            throw new IllegalArgumentException("Configuration context may not be null");
+        }
         if (executor == null) {
             throw new IllegalArgumentException("Executor may not be null");
         }
@@ -69,14 +75,20 @@
         if (params == null) {
             throw new IllegalArgumentException("HTTP parameters may not be null");
         }
+        this.configurationContext = configurationContext;
         this.executor = executor;
         this.workerfactory = workerfactory;
         this.params = params;
         this.processors = new LinkedList();
     }
     
-    public DefaultHttpConnectionManager(final Executor executor, final WorkerFactory workerfactory, final HttpParams params, final HttpFactory httpFactory) {
-        this(executor, workerfactory, params);
+    public DefaultHttpConnectionManager(
+            final ConfigurationContext configurationContext,
+            final Executor executor,
+            final WorkerFactory workerfactory,
+            final HttpParams params, 
+            final HttpFactory httpFactory) {
+        this(configurationContext, executor, workerfactory, params);
         this.httpFactory = httpFactory;
     }
 
@@ -125,7 +137,7 @@
         if (httpFactory!=null)
             processor = httpFactory.newRequestServiceProcessor(conn, workerfactory.newWorker(), callback);
         else
-            processor = new DefaultHttpServiceProcessor(conn, workerfactory.newWorker(), callback);
+            processor = new DefaultHttpServiceProcessor(conn, configurationContext, workerfactory.newWorker(), callback);
 
         processor.setParams(this.params);
         // Add required protocol interceptors
Index: modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java	(revision 413684)
+++ modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java	(working copy)
@@ -30,7 +30,25 @@
 import java.io.IOException;
 import java.net.SocketException;
 import java.net.SocketTimeoutException;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Iterator;
 
+import javax.xml.namespace.QName;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.ServiceContext;
+import org.apache.axis2.context.ServiceGroupContext;
+import org.apache.axis2.context.SessionContext;
+import org.apache.axis2.description.TransportInDescription;
+import org.apache.axis2.description.TransportOutDescription;
+import org.apache.axis2.engine.AxisEngine;
+import org.apache.axis2.engine.DependencyManager;
+import org.apache.axis2.transport.http.HTTPConstants;
+import org.apache.axis2.util.UUIDGenerator;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.http.Header;
@@ -40,7 +58,9 @@
 import org.apache.http.HttpServerConnection;
 import org.apache.http.HttpVersion;
 import org.apache.http.RequestLine;
+import org.apache.http.StatusLine;
 import org.apache.http.UnsupportedHttpVersionException;
+import org.apache.http.entity.StringEntity;
 import org.apache.http.protocol.HttpContext;
 
 public class DefaultHttpServiceProcessor extends HttpServiceProcessor {
@@ -48,17 +68,26 @@
     private static final Log LOG = LogFactory.getLog(DefaultHttpServiceProcessor.class);
     private static final Log HEADERLOG = LogFactory.getLog("org.apache.axis2.transport.http.server.wire");
     
+    // to store session object
+    private static Hashtable sessionContextTable = new Hashtable();
+    
+    private final ConfigurationContext configurationContext;
     private final Worker worker;
     private final IOProcessorCallback callback;
     
     public DefaultHttpServiceProcessor(
-            final HttpServerConnection conn, 
+            final HttpServerConnection conn,
+            final ConfigurationContext configurationContext,
             final Worker worker,
             final IOProcessorCallback callback) {
         super(conn);
         if (worker == null) {
             throw new IllegalArgumentException("Worker may not be null");
         }
+        if (configurationContext == null) {
+            throw new IllegalArgumentException("Configuration context may not be null");
+        }
+        this.configurationContext = configurationContext;
         this.worker = worker;
         this.callback = callback;
     }
@@ -99,8 +128,134 @@
         if (!ver.lessEquals(HttpVersion.HTTP_1_1)) {
             throw new UnsupportedHttpVersionException("Unsupported HTTP version: " + ver); 
         }
-        this.worker.service(request, response);
+        
+        MessageContext msgContext = new MessageContext();
+        msgContext.setIncomingTransportName(Constants.TRANSPORT_HTTP);
+        try {
+            TransportOutDescription transportOut = this.configurationContext.getAxisConfiguration()
+                .getTransportOut(new QName(Constants.TRANSPORT_HTTP));
+            TransportInDescription transportIn = this.configurationContext.getAxisConfiguration()
+                .getTransportIn(new QName(Constants.TRANSPORT_HTTP));            
+        
+            String cookieID = HttpUtils.getCookieID(request);
+            msgContext.setConfigurationContext(this.configurationContext);
+            if (this.configurationContext.getAxisConfiguration().isManageTransportSession()) {
+                SessionContext sessionContext = getSessionContext(cookieID);
+                msgContext.setSessionContext(sessionContext);
+            }
+            msgContext.setTransportIn(transportIn);
+            msgContext.setTransportOut(transportOut);
+            msgContext.setServiceGroupContextId(UUIDGenerator.getUUID());
+            msgContext.setServerSide(true);
+            msgContext.setProperty(Constants.Configuration.TRANSPORT_IN_URL, 
+                    request.getRequestLine().getUri());
+
+            // set the transport Headers
+            HashMap headerMap = new HashMap();
+            Header[] headers = request.getAllHeaders();
+            for (int i = 0; i < headers.length; i++) {
+                headerMap.put(headers[i].getName(), headers[i].getValue());
+            }
+            msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, headerMap);
+
+            this.worker.service(request, response, msgContext);
+            setCookie(response, msgContext);
+        } catch (SocketException ex) {
+            // Socket is unreliable. 
+            throw ex;
+        } catch (HttpException ex) {
+            // HTTP protocol violation. Transport is unrelaible
+            throw ex;
+        } catch (Throwable e) {
+            try {
+                AxisEngine engine = new AxisEngine(this.configurationContext);
+                
+                OutputBuffer outbuffer = new OutputBuffer(); 
+                msgContext.setProperty(MessageContext.TRANSPORT_OUT, outbuffer.getOutputStream());
+                msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outbuffer);
+
+                MessageContext faultContext = engine.createFaultMessageContext(msgContext, e);
+
+                response.setStatusLine(new StatusLine(ver, 500, "Internal server error"));
+                engine.sendFault(faultContext);
+                response.setEntity(outbuffer);
+                setCookie(response, msgContext);
+            } catch (Exception ex) {
+                response.setStatusLine(new StatusLine(ver, 500, "Internal server error"));
+                StringEntity entity = new StringEntity(ex.getMessage());
+                entity.setContentType("text/plain");
+                response.setEntity(entity);
+            }
+        }
+        
     }
+
+    private static void setCookie(final HttpResponse response, MessageContext msgContext) {
+        //TODO : provide a way to enable and diable cookies
+        //setting the coolie in the out path
+        Object cookieString = msgContext.getProperty(Constants.COOKIE_STRING);
+        if (cookieString != null) {
+            response.addHeader(new Header(HTTPConstants.HEADER_SET_COOKIE, (String) cookieString));
+            response.addHeader(new Header(HTTPConstants.HEADER_SET_COOKIE2, (String) cookieString));
+        }
+    }
+
+    /**
+     * To get the sessioncontext , if its not there in the hashtable , new one will be created and
+     * added to the list.
+     *
+     * @param cookieID
+     * @return <code>SessionContext</code>
+     */
+    private synchronized SessionContext getSessionContext(String cookieID) {
+        SessionContext sessionContext = null;
+        if (!(cookieID == null || cookieID.trim().equals(""))) {
+            sessionContext = (SessionContext) sessionContextTable.get(cookieID);
+        }
+        if (sessionContext == null) {
+            String cookieString = UUIDGenerator.getUUID();
+            sessionContext = new SessionContext(null);
+            sessionContext.setCookieID(cookieString);
+            sessionContextTable.put(cookieString, sessionContext);
+        }
+        sessionContext.touch();
+        cleanupServiceGroupContexts();
+        return sessionContext;
+    }
+
+    private void cleanupServiceGroupContexts() {
+        synchronized (sessionContextTable) {
+            long currentTime = System.currentTimeMillis();
+            Iterator sgCtxtMapKeyIter = sessionContextTable.keySet().iterator();
+            while (sgCtxtMapKeyIter.hasNext()) {
+                String cookieID = (String) sgCtxtMapKeyIter.next();
+                SessionContext sessionContext = (SessionContext) sessionContextTable.get(cookieID);
+                if ((currentTime - sessionContext.getLastTouchedTime()) >
+                        sessionContext.sessionContextTimeoutInterval) {
+                    sgCtxtMapKeyIter.remove();
+                    Iterator serviceGroupContext = sessionContext.getServiceGroupContext();
+                    if (serviceGroupContext != null) {
+                        while (serviceGroupContext.hasNext()) {
+                            ServiceGroupContext groupContext = (ServiceGroupContext) serviceGroupContext.next();
+                            cleanupServiceContextes(groupContext);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private void cleanupServiceContextes(ServiceGroupContext serviceGroupContext) {
+        Iterator serviceContecxtes = serviceGroupContext.getServiceContexts();
+        while (serviceContecxtes.hasNext()) {
+            ServiceContext serviceContext = (ServiceContext) serviceContecxtes.next();
+            try {
+                DependencyManager.destroyServiceClass(serviceContext);
+            } catch (AxisFault axisFault) {
+                LOG.info(axisFault.getMessage());
+            }
+        }
+    }
     
     protected void logIOException(final IOException ex) {
         if (ex instanceof SocketTimeoutException) {
Index: modules/core/src/org/apache/axis2/transport/http/server/HttpFactory.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/HttpFactory.java	(revision 413684)
+++ modules/core/src/org/apache/axis2/transport/http/server/HttpFactory.java	(working copy)
@@ -210,13 +210,15 @@
         params
             .setIntParameter(HttpConnectionParams.SO_TIMEOUT, requestSocketTimeout)
             .setBooleanParameter(HttpConnectionParams.TCP_NODELAY, requestTcpNoDelay) 
+            .setIntParameter(HttpConnectionParams.MAX_LINE_LENGTH, 4000)
+            .setIntParameter(HttpConnectionParams.MAX_HEADER_COUNT, 500)
             .setParameter(HttpProtocolParams.ORIGIN_SERVER, originServer);
         return params;
     }
     
     /** Create the connection manager used to launch request threads */
     public HttpConnectionManager newRequestConnectionManager(ExecutorService requestExecutor, WorkerFactory workerFactory, HttpParams params) {
-        return new DefaultHttpConnectionManager(requestExecutor, workerFactory, params);
+        return new DefaultHttpConnectionManager(configurationContext, requestExecutor, workerFactory, params);
     }
     
     /** Create the executor use the manage request processing threads */
@@ -238,12 +240,12 @@
         if (requestWorkerFactory!=null)
             return requestWorkerFactory;
         else
-            return new HTTPWorkerFactory(configurationContext);
+            return new HTTPWorkerFactory();
     }
 
     /** Create a request service processor to populate the response */
     public HttpServiceProcessor newRequestServiceProcessor(HttpServerConnection connection, Worker worker, IOProcessorCallback callback) {
-        return new DefaultHttpServiceProcessor(connection, worker, callback);
+        return new DefaultHttpServiceProcessor(connection, configurationContext, worker, callback);
     }
     
     // *****
Index: modules/core/src/org/apache/axis2/transport/http/server/AdminAppException.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/AdminAppException.java	(revision 413684)
+++ modules/core/src/org/apache/axis2/transport/http/server/AdminAppException.java	(working copy)
@@ -1,38 +0,0 @@
-/*
-* Copyright 2004,2005 The Apache Software Foundation.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-
-package org.apache.axis2.transport.http.server;
-
-public class AdminAppException extends Exception {
-
-	private static final long serialVersionUID = -968033744797396457L;
-
-	public AdminAppException() {
-    }
-
-    public AdminAppException(String message) {
-        super(message);
-    }
-
-    public AdminAppException(Throwable cause) {
-        super(cause);
-    }
-
-    public AdminAppException(String message, Throwable cause) {
-        super(message, cause);
-    }
-}
Index: modules/core/src/org/apache/axis2/transport/http/server/Worker.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/Worker.java	(revision 413684)
+++ modules/core/src/org/apache/axis2/transport/http/server/Worker.java	(working copy)
@@ -29,13 +29,14 @@
 
 import java.io.IOException;
 
+import org.apache.axis2.context.MessageContext;
 import org.apache.http.HttpException;
 import org.apache.http.HttpRequest;
 import org.apache.http.HttpResponse;
 
 public interface Worker {
 
-    void service(HttpRequest request, HttpResponse response) 
+    void service(HttpRequest request, HttpResponse response, MessageContext msgContext) 
         throws HttpException, IOException;    
     
 }
Index: modules/core/src/org/apache/axis2/transport/http/server/SimpleHttpServer.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/SimpleHttpServer.java	(revision 413684)
+++ modules/core/src/org/apache/axis2/transport/http/server/SimpleHttpServer.java	(working copy)
@@ -57,6 +57,7 @@
     private IOProcessor listener = null;
     private ExecutorService listenerExecutor = null;
     private HttpConnectionManager connmanager = null;
+    private HttpConnectionFactory connfactory = null;
     private ExecutorService requestExecutor = null;
 
     public SimpleHttpServer(ConfigurationContext configurationContext, WorkerFactory workerFactory, int port) throws IOException {
@@ -74,9 +75,8 @@
         requestExecutor = httpFactory.newRequestExecutor(port);
         connmanager = httpFactory.newRequestConnectionManager(requestExecutor, workerFactory, params);
         listenerExecutor = httpFactory.newListenerExecutor(port);
-        listener = httpFactory.newRequestConnectionListener(httpFactory.newRequestConnectionFactory(params),
-                                                            httpFactory.newRequestConnectionManager(requestExecutor, workerFactory, params),
-                                                            port);
+        connfactory = httpFactory.newRequestConnectionFactory(params);
+        listener = httpFactory.newRequestConnectionListener(connfactory, connmanager, port);
     }
     
     public void destroy() throws IOException, InterruptedException {
