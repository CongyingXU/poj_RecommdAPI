Index: modules/saaj/src/org/apache/axis2/saaj/AttachmentPartImpl.java
===================================================================
--- modules/saaj/src/org/apache/axis2/saaj/AttachmentPartImpl.java	(revision 499326)
+++ modules/saaj/src/org/apache/axis2/saaj/AttachmentPartImpl.java	(working copy)
@@ -15,12 +15,12 @@
  */
 package org.apache.axis2.saaj;
 
-import org.apache.axiom.om.OMText;
-import org.apache.axiom.om.impl.dom.DOOMAbstractFactory;
-import org.apache.axiom.om.impl.dom.DocumentImpl;
-import org.apache.axiom.om.impl.dom.TextImpl;
-import org.apache.axis2.saaj.util.SAAJDataSource;
-import org.apache.axis2.transport.http.HTTPConstants;
+import java.awt.image.BufferedImage;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.StringReader;
+import java.util.Iterator;
 
 import javax.activation.DataHandler;
 import javax.activation.UnsupportedDataTypeException;
@@ -29,12 +29,14 @@
 import javax.xml.soap.MimeHeaders;
 import javax.xml.soap.SOAPException;
 import javax.xml.transform.stream.StreamSource;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.StringReader;
-import java.util.Iterator;
 
+import org.apache.axiom.om.OMText;
+import org.apache.axiom.om.impl.dom.DOOMAbstractFactory;
+import org.apache.axiom.om.impl.dom.DocumentImpl;
+import org.apache.axiom.om.impl.dom.TextImpl;
+import org.apache.axis2.saaj.util.SAAJDataSource;
+import org.apache.axis2.transport.http.HTTPConstants;
+
 /**
  * 
  */
@@ -225,8 +227,9 @@
             }
         } else if (object instanceof java.io.InputStream) {
             try {
-                source = new SAAJDataSource((java.io.InputStream) object,
-                        SAAJDataSource.MAX_MEMORY_DISK_CACHED,
+            	
+            	source = new SAAJDataSource((java.io.InputStream) object,
+                        SAAJDataSource.MIN_MEMORY_DISK_CACHED,
                         contentType, true);
                 extractFilename(source);
                 dataHandler = new DataHandler(source);
@@ -245,7 +248,24 @@
             } catch (java.io.IOException io) {
                 throw new java.lang.IllegalArgumentException("Illegal Argument");
             }
-        } else {
+        }else if (object instanceof BufferedImage) {
+            try {
+                dataHandler = new DataHandler(object,contentType);
+                contentObject = null; // the stream has been consumed
+            } catch (Exception e) {
+            	throw new java.lang.IllegalArgumentException(e);
+            }
+        }
+        /*
+        else if (object instanceof byte[]) {
+            try {
+                dataHandler = new DataHandler();
+                contentObject = null; // the stream has been consumed
+            } catch (Exception e) {
+            	throw new java.lang.IllegalArgumentException(e);
+            }
+        }*/
+        else {
             throw new java.lang.IllegalArgumentException("Illegal Argument");
         }
     }
@@ -421,10 +441,25 @@
         }
     }
 
+    
+    /**
+     * Gets the content of this AttachmentPart object as an InputStream as if a call had been made 
+     * to getContent and no DataContentHandler had been registered for the content-type of this 
+     * AttachmentPart.Note that reading from the returned InputStream would result in consuming 
+     * the data in the stream. It is the responsibility of the caller to reset the InputStream 
+     * appropriately before calling a Subsequent API. If a copy of the raw attachment content is 
+     * required then the getRawContentBytes() API should be used instead.
+     *
+     * @return an InputStream from which the raw data contained by the AttachmentPart can be 
+     * accessed.
+     * @throws SOAPException - if there is no content set into this AttachmentPart object or if 
+     * there was a data transformation error.
+     * @since SAAJ 1.3 
+     */
     public InputStream getRawContent() throws SOAPException {
         try {
             if (dataHandler == null) {
-                return null;
+                throw new SOAPException("No content set");
             }
             return dataHandler.getInputStream();
         } catch (IOException e) {
@@ -432,9 +467,19 @@
         }
     }
 
+    /**
+     * Gets the content of this AttachmentPart object as a byte[] array as if a call had been made 
+     * to getContent and no DataContentHandler had been registered for the content-type of this 
+     * AttachmentPart.
+     * 
+     * @return a byte[] array containing the raw data of the AttachmentPart.
+     * @throws SOAPException - if there is no content set into this AttachmentPart object or if 
+     *         there was a data transformation error.
+     * @since SAAJ 1.3
+     */
     public byte[] getRawContentBytes() throws SOAPException {
         if (dataHandler == null) {
-            return null;
+        	throw new SOAPException("Content is null");
         }
         ByteArrayOutputStream bout = new ByteArrayOutputStream();
         try {
@@ -445,16 +490,92 @@
         return bout.toByteArray();
     }
 
-    public void setBase64Content(InputStream inputstream, String s) throws SOAPException {
-        //TODO - Not yet implemented
+    
+    /**
+     * Sets the content of this attachment part from the Base64 source InputStream and sets the 
+     * value of the Content-Type header to the value contained in contentType, This method would 
+     * first decode the base64 input and write the resulting raw bytes to the attachment.
+     * A subsequent call to getSize() may not be an exact measure of the content size.
+     * 
+     * @param content - the base64 encoded data to add to the attachment part
+     *        contentType - the value to set into the Content-Type header
+     * @throws SOAPException - if there is an error in setting the content
+     *         java.lang.NullPointerException - if content is null
+     */
+    public void setBase64Content(InputStream content, String contentType) throws SOAPException {
+    	if(content == null){
+    		throw new SOAPException("Content is null");
+    	}
+    	try {
+    		if(isValidBase64Encoding(content)){
+    			setContent(content, contentType);		
+    		}else{
+    			throw new SOAPException("Not a valid Base64 encoding");
+    		}
+    	} catch (Exception ex) {
+    		throw new SOAPException(ex);
+    	}
     }
 
-    public void setRawContent(InputStream inputstream, String s) throws SOAPException {
-        //TODO - Not yet implemented
+    /*
+     * check if the given InputStream contains valid Base64 Encoding
+     */
+    private boolean isValidBase64Encoding (InputStream content) {
+    	//TODO need to add more checks
+    	int size;
+		try {
+			size = content.available();
+	    	if (size%4 != 0){
+	    		//Length of Base64 encoded input string is not a multiple of 4
+	    		return false;
+	    	}else{
+	    		return true;
+	    	}
+		} catch (IOException e) {
+			return false;
+		}
     }
+    
+    /**
+     * Sets the content of this attachment part to that contained by the InputStream content and 
+     * sets the value of the Content-Type header to the value contained in contentType.A subsequent
+     * call to getSize() may not be an exact measure of the content size.
+     * 
+     * @param content - the raw data to add to the attachment part
+     *        contentType - the value to set into the Content-Type header
+     * @throws SOAPException - if there is an error in setting the content
+     *         java.lang.NullPointerException - if content is null
+     *         
+     */
+    public void setRawContent(InputStream content, String contentType) throws SOAPException {
+    	//TODO check
+    	if(content == null){
+    		//throw new NullPointerException("content is null"); 
+    		throw new SOAPException("content is null");
+    	}
+    	setContent(content, contentType);
+    }
+    
+    
+    /**
+     * Sets the content of this attachment part to that contained by the byte[] array content and 
+     * sets the value of the Content-Type header to the value contained in contentType.
+     * 
+     * @param content - the raw data to add to the attachment part
+     *        contentType - the value to set into the Content-Type header
+     *        offset - the offset in the byte array of the content
+     *        len - the number of bytes that form the content
+     * @throws SOAPException - if an there is an error in setting the content or content is null
+     * @since SAAJ 1.3
+     * 
+     */
 
-    public void setRawContentBytes(byte[] abyte0, int i, int j, String s) throws SOAPException {
-        //TODO - Not yet implemented
+    public void setRawContentBytes(byte[] content, int offset, int len, String contentType) throws SOAPException {
+        //TODO - complete
+    	if(content == null){
+    		throw new SOAPException("Content is null");
+    	}
+    	
     }
 
     /**
Index: modules/saaj/src/org/apache/axis2/saaj/SOAPBodyImpl.java
===================================================================
--- modules/saaj/src/org/apache/axis2/saaj/SOAPBodyImpl.java	(revision 499326)
+++ modules/saaj/src/org/apache/axis2/saaj/SOAPBodyImpl.java	(working copy)
@@ -379,12 +379,18 @@
         //TODO - check
         Iterator childElements = this.getChildElements();
         org.w3c.dom.Node domNode = null;
+        int childCount = 0;
         while (childElements.hasNext()) {
             domNode = (org.w3c.dom.Node) childElements.next();
-            break;
+            childCount++;
+            if(childCount > 1){
+            	throw new SOAPException("SOAPBody contains more than one child element");
+            }
         }
+        //The child SOAPElement is removed as part of the process
+        this.removeContents();
+        
 
-
         Document document;
         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
         factory.setNamespaceAware(true);
@@ -392,12 +398,12 @@
         try {
             DocumentBuilder builder = factory.newDocumentBuilder();
             document = builder.newDocument();
-            Element element = document.createElement(domNode.getLocalName());
+            //Element element = document.createElement(domNode.getLocalName());
             //TODO: WIP
             //element.setAttribute(domNode.getNodeName(), domNode.getNodeValue());
-            //Element element = document.createElementNS(domNode.getNamespaceURI(), domNode.getLocalName());
-            //element.setNodeValue(domNode.getNodeValue());
-            //document.appendChild(domNode);
+            Element element = document.createElementNS(domNode.getNamespaceURI(), domNode.getLocalName());
+            element.setNodeValue(domNode.getNodeValue());
+            document.appendChild(element);
 
 
         } catch (ParserConfigurationException e) {
Index: modules/saaj/src/org/apache/axis2/saaj/SOAPFactoryImpl.java
===================================================================
--- modules/saaj/src/org/apache/axis2/saaj/SOAPFactoryImpl.java	(revision 499326)
+++ modules/saaj/src/org/apache/axis2/saaj/SOAPFactoryImpl.java	(working copy)
@@ -31,10 +31,6 @@
 import org.apache.axiom.om.impl.dom.DOOMAbstractFactory;
 import org.apache.axiom.om.impl.dom.ElementImpl;
 import org.apache.axiom.om.impl.dom.factory.OMDOMFactory;
-import org.apache.axiom.soap.impl.dom.soap11.SOAP11Factory;
-import org.apache.axiom.soap.impl.dom.soap11.SOAP11HeaderBlockImpl;
-import org.apache.axiom.soap.impl.dom.soap12.SOAP12Factory;
-import org.apache.axiom.soap.impl.dom.soap12.SOAP12HeaderBlockImpl;
 import org.w3c.dom.Element;
 
 /**
Index: modules/saaj/src/org/apache/axis2/saaj/SOAPMessageImpl.java
===================================================================
--- modules/saaj/src/org/apache/axis2/saaj/SOAPMessageImpl.java	(revision 499326)
+++ modules/saaj/src/org/apache/axis2/saaj/SOAPMessageImpl.java	(working copy)
@@ -15,18 +15,6 @@
  */
 package org.apache.axis2.saaj;
 
-import org.apache.axiom.om.OMOutputFormat;
-import org.apache.axis2.transport.http.HTTPConstants;
-
-import javax.xml.soap.AttachmentPart;
-import javax.xml.soap.SOAPBody;
-import javax.xml.soap.SOAPException;
-import javax.xml.soap.SOAPHeader;
-import javax.xml.soap.SOAPMessage;
-import javax.xml.soap.SOAPPart;
-import javax.xml.soap.SOAPElement;
-import javax.xml.soap.MimeHeaders;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -36,6 +24,19 @@
 import java.util.Iterator;
 import java.util.Map;
 
+import javax.xml.soap.AttachmentPart;
+import javax.xml.soap.MimeHeader;
+import javax.xml.soap.MimeHeaders;
+import javax.xml.soap.SOAPBody;
+import javax.xml.soap.SOAPElement;
+import javax.xml.soap.SOAPException;
+import javax.xml.soap.SOAPHeader;
+import javax.xml.soap.SOAPMessage;
+import javax.xml.soap.SOAPPart;
+
+import org.apache.axiom.om.OMOutputFormat;
+import org.apache.axis2.transport.http.HTTPConstants;
+
 public class SOAPMessageImpl extends SOAPMessage {
 
     private SOAPPart soapPart;
@@ -386,8 +387,36 @@
         return null;  //TODO - Not yet implemented        
     }
 
-    public void removeAttachments(MimeHeaders mimeheaders) {
-        //TODO - Not yet implemented
+    /**
+     * Removes all the AttachmentPart objects that have header entries that match the specified
+     * headers. Note that the removed attachment could have headers in addition to those 
+     * specified.
+     * @param headers - a MimeHeaders object containing the MIME headers for which to search
+     * @since SAAJ 1.3
+     */
+    public void removeAttachments(MimeHeaders headers) {
+        //TODO - check
+    	
+    	Collection newAttachmentParts = new ArrayList();
+    	Iterator attachmentPartsItr = attachmentParts.iterator();
+    	for (Iterator iter = attachmentPartsItr; iter.hasNext();) {
+			AttachmentPart attachmentPart = (AttachmentPart) iter.next();
+			
+			//Get all the headers
+			Iterator allMIMEHeaders = headers.getAllHeaders();
+			for (Iterator iterator = allMIMEHeaders; iterator.hasNext();) {
+				MimeHeader mimeHeader = (MimeHeader) iterator.next();
+				String[] headerValues = attachmentPart.getMimeHeader(mimeHeader.getName());
+				//if values for this header name, do not remove it
+				if(headerValues.length != 0){
+					if(!(headerValues[0].equals(mimeHeader.getValue()))){
+						newAttachmentParts.add(attachmentPart);
+					}
+				}
+			}
+		}
+    	attachmentParts.clear();
+    	this.attachmentParts = newAttachmentParts;
     }
 
     /**
Index: modules/saaj/src/org/apache/axis2/saaj/util/SAAJDataSource.java
===================================================================
--- modules/saaj/src/org/apache/axis2/saaj/util/SAAJDataSource.java	(revision 499326)
+++ modules/saaj/src/org/apache/axis2/saaj/util/SAAJDataSource.java	(working copy)
@@ -26,6 +26,9 @@
 import java.io.FileInputStream;
 import java.util.LinkedList;
 import java.util.List;
+import org.apache.axis2.Constants;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.description.Parameter;
 
 /**
  * 
@@ -161,13 +164,13 @@
         // for now read all in to disk.
         if (readall) {
             byte[] readbuffer = new byte[READ_CHUNK_SZ];
+            
             int read = 0;
-
             do {
                 read = ss.read(readbuffer);
 
                 if (read > 0) {
-                    write(readbuffer, read);
+                    writeToMemory(readbuffer, read);
                 }
             } while (read > -1);
             close();
@@ -220,12 +223,26 @@
                             ? null
                             : mc.getStrProp(
                     MessageContext.ATTACHMENTS_DIR);*/
-                    String attdir = "temp";
+                	
+                	
+                	MessageContext messageContext = MessageContext.getCurrentMessageContext();
+                	String attachementDir = "";
+                	attachementDir = (String)messageContext.getProperty
+                			(Constants.Configuration.ATTACHMENT_TEMP_DIR);
+
+                	if (attachementDir.equals("")) {
+                		Parameter param  = (Parameter)messageContext.getParameter
+                			(Constants.Configuration.ATTACHMENT_TEMP_DIR);
+                		if(param != null){
+                			attachementDir = (String)param.getValue();
+                		}
+                	}
+                    
                     diskCacheFile = java.io.File.createTempFile("Axis", ".att",
-                                                                (attdir == null)
+                                                                (attachementDir == null)
                                                                 ? null
                                                                 : new File(
-                                                                        attdir));
+                                                                		attachementDir));
                     cachediskstream = new BufferedOutputStream(new FileOutputStream(diskCacheFile));
                     int listsz = ml.size();
 
@@ -324,6 +341,53 @@
 
 
     /**
+     * This method is a low level write.
+     * Writes only to memory
+     * 
+     * @param data
+     * @param length
+     * @throws java.io.IOException
+     */
+    protected synchronized void writeToMemory(byte[] data, int length) throws java.io.IOException {
+
+        if (closed) {
+            throw new java.io.IOException("streamClosed");
+        }
+
+        int byteswritten = 0;
+        if (memorybuflist != null) {    // Can write to memory.
+            do {
+                if (null == currentMemoryBuf) {
+                    currentMemoryBuf = new byte[READ_CHUNK_SZ];
+                    currentMemoryBufSz = 0;
+
+                    memorybuflist.add(currentMemoryBuf);
+                }
+
+                // bytes to write is the min. between the remaining bytes and what is left in this buffer.
+                int bytes2write = Math.min((length - byteswritten),
+                                           (currentMemoryBuf.length
+                                            - currentMemoryBufSz));
+
+                // copy the data.
+                System.arraycopy(data, byteswritten, currentMemoryBuf,
+                                 currentMemoryBufSz, bytes2write);
+
+                byteswritten += bytes2write;
+                currentMemoryBufSz += bytes2write;
+
+                if (byteswritten
+                    < length) {    // only get more if we really need it.
+                    currentMemoryBuf = new byte[READ_CHUNK_SZ];
+                    currentMemoryBufSz = 0;
+                    memorybuflist.add(currentMemoryBuf);    // add it to the chain.
+                }
+            } while (byteswritten < length);
+        }
+        totalsz += length;
+    }
+    
+    /**
      * get the filename of the content if it is cached to disk.
      *
      * @return file object pointing to file, or null for memory-stored content
Index: modules/saaj/test/org/apache/axis2/saaj/AttachmentTest.java
===================================================================
--- modules/saaj/test/org/apache/axis2/saaj/AttachmentTest.java	(revision 499326)
+++ modules/saaj/test/org/apache/axis2/saaj/AttachmentTest.java	(working copy)
@@ -1,23 +1,30 @@
 package org.apache.axis2.saaj;
 
+import java.awt.Image;
 import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.net.URL;
+import java.util.Iterator;
 
 import javax.activation.DataHandler;
 import javax.activation.DataSource;
 import javax.xml.soap.AttachmentPart;
 import javax.xml.soap.MessageFactory;
+import javax.xml.soap.MimeHeader;
 import javax.xml.soap.SOAPException;
 import javax.xml.soap.SOAPMessage;
 import javax.xml.transform.stream.StreamSource;
 
 import junit.framework.TestCase;
 
+import com.sun.mail.util.BASE64EncoderStream;
+
 public class AttachmentTest extends TestCase {
 
     public AttachmentTest(String name) {
@@ -141,4 +148,185 @@
             throw new UnsupportedOperationException("I don't give output streams");
         }
     }
+    
+    public void testClearContent() throws Exception {
+    	try {
+    		InputStream in1 = new FileInputStream(new File("test-resources" + File.separator + "attach.xml"));
+
+        	MessageFactory factory = MessageFactory.newInstance();
+        	SOAPMessage message = factory.createMessage();
+            AttachmentPart ap = message.createAttachmentPart();
+            MimeHeader mh = null;
+    		
+    		System.out.println("Setting Mime Header ");
+    		ap.setMimeHeader("Content-Description","some text");
+
+    		System.out.println("Setting Content Id Header ");
+    		ap.setContentId("id@abc.com");
+
+    		System.out.println("Setting Content ");
+    		ap.setContent( new StreamSource(in1),"text/xml");
+
+    		System.out.println("Clearing Content ");
+    		ap.clearContent();
+
+    		try {
+
+    			System.out.println("Getting Content ");
+    			InputStream is = (InputStream)ap.getContent();
+
+    			System.out.println("Error: SOAPException should have been thrown");
+    		} catch(SOAPException e) {
+    			System.out.println("Error thrown.(expected)");
+    		}
+
+    		Iterator iterator = ap.getAllMimeHeaders();
+    		int cnt=0;
+    		boolean foundHeader1=false;
+    		boolean foundHeader2=false;
+    		boolean foundDefaultHeader=false;
+    		while (iterator.hasNext()) {
+    			cnt++;
+    			mh = (MimeHeader)iterator.next();
+    			String name=mh.getName();
+    			String value=mh.getValue();
+    			if (name.equals("Content-Description") && value.equals("some text")){
+    				if (!foundHeader1){
+    					foundHeader1=true;
+    					System.out.println("MimeHeaders do match for header1");
+    					System.out.println("receive: name="+name+", value="+value);
+    				}
+    				else {
+    					System.out.println("Error: Received the same header1 header twice");
+    					System.out.println("received: name="+name+", value="+value);
+    				}
+    			} else if (name.equals("Content-Id") && value.equals("id@abc.com")){
+    				//TODO Content-Id or Content-ID??
+    				if (!foundHeader2){
+    					foundHeader2=true;
+    					System.out.println("MimeHeaders do match for header2");
+    					System.out.println("receive: name="+name+", value="+value);
+    				}
+    				else {
+    					System.out.println("Error: Received the same header2 header twice");
+    					System.out.println("received: name="+name+", value="+value);
+    				}
+    			} else if (name.equals("Content-Type") && value.equals("text/xml")){
+    				if (!foundDefaultHeader){
+    					foundDefaultHeader=true;
+    					System.out.println("MimeHeaders do match for default header");
+    					System.out.println("receive: name="+name+", value="+value);
+    				}
+    				else {
+    					System.out.println("Error: Received the same default header header twice");
+    					System.out.println("received: name="+name+", value="+value);
+    				}
+    			} else {
+    				System.out.println("Error: Received an invalid header");
+    				System.out.println("received: name="+name+", value="+value);
+    			}
+    		}
+
+    		if (!(foundHeader1 && foundHeader2)){
+    			System.out.println("Error: did not receive both headers");
+    		}
+
+    	} catch(Exception e) {
+    		System.out.println("Exception: " + e);
+    	}
+
+    }
+    
+
+    
+    public void testGetContent() throws Exception 
+    {
+    	try 
+    	{
+    		MessageFactory factory = MessageFactory.newInstance();
+    		SOAPMessage msg = factory.createMessage();
+    		AttachmentPart ap = msg.createAttachmentPart();
+    		Image image = javax.imageio.ImageIO.read(new File("test-resources" + File.separator + "attach.gif"));
+    		ap = msg.createAttachmentPart(image, "image/gif");
+
+    		System.out.println("Getting Content should return an Image object");
+    		Object o = ap.getContent();
+    		System.out.println("object returned="+o);
+    		if(o != null) {
+    			if(o instanceof Image)
+    				System.out.println("Image object was returned (ok)");
+    			else {
+    				System.out.println("Unexpected object was returned (not ok)");
+    				System.out.println("Unexpected object="+o);
+    			}
+    		} else {
+    			System.out.println("null was returned");
+    		}
+    	} catch(Exception e) {
+    		System.out.println("Exception: " + e);
+    	}
+    }
+    
+    public void testGetRawContents(){
+    	try 
+    	{
+    		MessageFactory factory = MessageFactory.newInstance();
+    		SOAPMessage msg = factory.createMessage();
+    		AttachmentPart ap = msg.createAttachmentPart();
+    		ap = msg.createAttachmentPart();
+    		byte data1[] = null;
+    		data1 = ap.getRawContentBytes();
+
+    	} catch(SOAPException e) {
+    		System.out.println("Caught expected SOAPException");
+    	} catch(NullPointerException e) {
+    		System.out.println("Caught expected NullPointerException");
+    	} catch(Exception e) {
+    		fail();
+    	}
+    }
+    
+    public void testSetBase64Content(){
+    	try 
+    	{
+    		MessageFactory factory = MessageFactory.newInstance();
+    		SOAPMessage msg = factory.createMessage();
+    		AttachmentPart ap = msg.createAttachmentPart();
+
+    		URL url = new URL("http://ws.apache.org/images/project-logo.jpg");
+    		DataHandler dh = new DataHandler(url);
+    		System.out.println("Create InputStream from DataHandler's InputStream");
+    		InputStream is = dh.getInputStream();
+
+    		System.out.println("Setting Content via InputStream for image/jpeg mime type");
+    		ByteArrayOutputStream bos = new ByteArrayOutputStream();
+    		OutputStream ret = new BASE64EncoderStream(bos);
+    		int count;
+    		byte buf[] = new byte[8192];
+    		while ((count = is.read(buf, 0, 8192)) != -1) {
+    			ret.write(buf, 0, count);
+    		}
+    		ret.flush();
+    		buf = bos.toByteArray();
+    		InputStream stream = new ByteArrayInputStream(buf);
+    		ap.setBase64Content(stream,"image/jpeg");
+
+    		System.out.println("Getting Content should return InputStream object");
+    		InputStream r = ap.getBase64Content();
+    		System.out.println("object returned="+r);
+    		if(r != null) {
+    			if(r instanceof InputStream)
+    				System.out.println("InputStream object was returned (ok)");
+    			else {
+    				System.out.println("Unexpected object was returned (not ok)");
+    				System.out.println("Unexpected object="+r);
+    			}
+    		} else {
+    			System.out.println("null was returned");
+    		}
+    	} catch(Exception e) {
+    		System.out.println("Exception: " + e);
+    	}
+    }
+    
 }
Index: modules/saaj/test/org/apache/axis2/saaj/SOAPBodyTest.java
===================================================================
--- modules/saaj/test/org/apache/axis2/saaj/SOAPBodyTest.java	(revision 499326)
+++ modules/saaj/test/org/apache/axis2/saaj/SOAPBodyTest.java	(working copy)
@@ -176,7 +176,7 @@
     }
 
     //TODO : fix
-    public void _testExtractContentAsDocument(){
+    public void testExtractContentAsDocument(){
     	try
     	{
     		MessageFactory fact = MessageFactory.newInstance();
Index: modules/saaj/test/org/apache/axis2/saaj/SOAPElementTest.java
===================================================================
--- modules/saaj/test/org/apache/axis2/saaj/SOAPElementTest.java	(revision 499326)
+++ modules/saaj/test/org/apache/axis2/saaj/SOAPElementTest.java	(working copy)
@@ -351,6 +351,49 @@
         }
     }
     
+    public void testRemoveAttribute2() {
+    	boolean pass = true;
+    	try 
+    	{
+    		SOAPMessage msg = MessageFactory.newInstance().createMessage();
+    		SOAPEnvelope envelope = msg.getSOAPPart().getEnvelope();
+    		SOAPBody body = envelope.getBody();
+
+    		QName name = new QName("MyAttr1");
+    		String value = "MyValue1";
+    		System.out.println("Add attribute qname = " + name.getLocalPart() + 
+    				", value = " + value);
+    		body.addAttribute(name, value);
+    		System.out.println("Remove attribute qname = " + name.getLocalPart() + 
+    				", value = " + value);
+    		boolean b = body.removeAttribute(name);
+    		if(!b) {
+    			System.out.println("removeAttribute() did not return true");
+    			System.out.println("removeAttributeTest() test FAILED");
+    			pass = false;
+    		} 
+    		if(pass) {
+    			b = body.removeAttribute(name);
+    			if(b) {
+    				System.out.println("removeAttribute() did not return false");
+    				System.out.println("removeAttributeTest() test FAILED");
+    				pass = false;
+    			}
+    		}
+    		if(pass) {
+    			if(body.getAttributeValue(name) == null) {
+    				System.out.println("removeAttributeTest() test PASSED");
+    			} else {
+    				System.out.println("removeAttributeTest() test FAILED");
+    				pass = false;
+    			}
+    		}
+    	} catch(Exception e) {
+    		System.out.println("Exception: " + e);
+    		pass = false;
+    	}
+    }    
+    
     /*
      * name
      */
Index: modules/saaj/test/org/apache/axis2/saaj/SOAPFactoryTest.java
===================================================================
--- modules/saaj/test/org/apache/axis2/saaj/SOAPFactoryTest.java	(revision 499326)
+++ modules/saaj/test/org/apache/axis2/saaj/SOAPFactoryTest.java	(working copy)
@@ -232,8 +232,8 @@
     public void testCreateFault1(){
     	try 
     	{
-    		SOAPFactory factory = SOAPFactory.newInstance(SOAPConstants.SOAP_1_2_PROTOCOL);
-    		//SOAPFactory factory = SOAPFactory.newInstance();
+    		//SOAPFactory factory = SOAPFactory.newInstance(SOAPConstants.SOAP_1_2_PROTOCOL);
+    		SOAPFactory factory = SOAPFactory.newInstance();
 
     		if(factory == null) {
     			System.out.println(
Index: modules/saaj/test/org/apache/axis2/saaj/SOAPMessageTest.java
===================================================================
--- modules/saaj/test/org/apache/axis2/saaj/SOAPMessageTest.java	(revision 499326)
+++ modules/saaj/test/org/apache/axis2/saaj/SOAPMessageTest.java	(working copy)
@@ -15,6 +15,9 @@
  */
 package org.apache.axis2.saaj;
 
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
 import java.net.URL;
 import java.util.Iterator;
 
@@ -205,8 +208,12 @@
     
     
     //TODO : sumedha complete
-    public void testRemoveAttachement(){
+    public void testRemoveAttachements(){
     	Iterator iterator = null;
+        AttachmentPart ap1 = null;
+        AttachmentPart ap2 = null;
+        AttachmentPart ap3 = null;
+    	
     	try 
     	{
     		MessageFactory fac = MessageFactory.newInstance(SOAPConstants.SOAP_1_2_PROTOCOL);
@@ -217,6 +224,20 @@
     		SOAPBody body = envelope.getBody();
     		SOAPFault sf = body.addFault();
 
+    		
+    		InputStream in1 = new FileInputStream(new File("test-resources" + File.separator + "attach.xml"));
+    		ap1 = msg.createAttachmentPart(in1, "text/xml");
+            msg.addAttachmentPart(ap1);
+
+    		InputStream in2 = new FileInputStream(new File("test-resources" + File.separator + "axis2.xml"));
+    		ap2 = msg.createAttachmentPart(in2, "text/xml");
+            msg.addAttachmentPart(ap2);
+
+    		InputStream in3 = new FileInputStream(new File("test-resources" + File.separator + "axis2.xml"));
+    		ap3 = msg.createAttachmentPart(in3, "text/plain");
+            msg.addAttachmentPart(ap3);
+    		
+    		
     		System.out.println("get all attachments");
     		iterator = msg.getAttachments();
 
@@ -254,6 +275,7 @@
     		if (cnt > 1) {
     			System.out.println("the 2 text/xml attachments were not removed (unexpected)");
     		} else if(cnt == 1) {
+    			iterator = msg.getAttachments();
     			AttachmentPart ap = (AttachmentPart) iterator.next();
     			String ctype = ap.getContentType();
     			System.out.println("Content-Type of remaining attachment is: "+ctype);
