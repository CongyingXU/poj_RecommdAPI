Index: modules/json/test/org/apache/axis2/json/impl/GsonXMLStreamWriterTest.java
===================================================================
--- modules/json/test/org/apache/axis2/json/impl/GsonXMLStreamWriterTest.java	(revision 0)
+++ modules/json/test/org/apache/axis2/json/impl/GsonXMLStreamWriterTest.java	(revision 0)
@@ -0,0 +1,94 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.json.impl;
+
+import com.google.gson.stream.JsonWriter;
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.OMFactory;
+import org.apache.axiom.om.OMNamespace;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.xml.namespace.QName;
+import javax.xml.transform.stream.StreamSource;
+import java.io.ByteArrayOutputStream;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+
+public class GsonXMLStreamWriterTest {
+    private String jsonString;
+
+    @Test
+    public void testGsonXMLStreamWriter() throws Exception {
+        jsonString = "{\"response\":{\"return\":{\"name\":\"kate\",\"age\":\"35\",\"gender\":\"female\"}}}";
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(baos, "UTF-8");
+        JsonWriter jsonWriter = new JsonWriter(outputStreamWriter);
+        String fileName = "test-resources/custom_schema/testSchema_1.xsd";
+        InputStream is = new FileInputStream(fileName);
+        XmlSchemaCollection schemaCol = new XmlSchemaCollection();
+        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        List<XmlSchema> schemaList = new ArrayList<XmlSchema>();
+        schemaList.add(schema);
+        QName elementQName = new QName("http://www.w3schools.com", "response");
+        ConfigurationContext configCtxt = new ConfigurationContext(new AxisConfiguration());
+
+        GsonXMLStreamWriter gsonXMLStreamWriter = new GsonXMLStreamWriter(jsonWriter, elementQName, schemaList, configCtxt);
+        OMElement omElement = getResponseOMElement();
+        gsonXMLStreamWriter.writeStartDocument();
+        omElement.serialize(gsonXMLStreamWriter);
+        gsonXMLStreamWriter.writeEndDocument();
+
+        String actualString = baos.toString();
+        outputStreamWriter.close();
+        Assert.assertEquals(jsonString, actualString);
+    }
+
+
+    private OMElement getResponseOMElement() {
+        OMFactory omFactory = OMAbstractFactory.getOMFactory();
+        OMNamespace ns = omFactory.createOMNamespace("", "");
+
+        OMElement response = omFactory.createOMElement("response", ns);
+        OMElement ret = omFactory.createOMElement("return", ns);
+        OMElement name = omFactory.createOMElement("name", ns);
+        name.setText("kate");
+        OMElement age = omFactory.createOMElement("age", ns);
+        age.setText("35");
+        OMElement gender = omFactory.createOMElement("gender", ns);
+        gender.setText("female");
+        ret.addChild(name);
+        ret.addChild(age);
+        ret.addChild(gender);
+        response.addChild(ret);
+        return response;
+    }
+}
Index: modules/json/test/org/apache/axis2/json/impl/JsonBuilderTest.java
===================================================================
--- modules/json/test/org/apache/axis2/json/impl/JsonBuilderTest.java	(revision 0)
+++ modules/json/test/org/apache/axis2/json/impl/JsonBuilderTest.java	(revision 0)
@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.json.impl;
+
+import com.google.gson.stream.JsonReader;
+import org.apache.axis2.Constants;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.json.impl.utils.JsonConstant;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
+public class JsonBuilderTest {
+
+    @Test
+    public void testProcessDocument() throws Exception {
+        MessageContext messageContext = new MessageContext();
+        String contentType = "application/json-impl";
+        String jsonString = "{\"methodName\":{\"param\":\"value\"}}";
+        ByteArrayInputStream inputStream = new ByteArrayInputStream(jsonString.getBytes("UTF-8"));
+        messageContext.setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, "UTF-8");
+
+        JsonBuilder jsonBuilder = new JsonBuilder();
+        jsonBuilder.processDocument(inputStream, contentType, messageContext);
+
+        Object isJson = messageContext.getProperty(JsonConstant.IS_JSON_STREAM);
+        Assert.assertNotNull(isJson);
+        isJson = Boolean.valueOf(isJson.toString());
+        Assert.assertEquals(true, isJson);
+        Object streamReader = messageContext.getProperty(JsonConstant.GSON_XML_STREAM_READER);
+        Assert.assertNotNull(streamReader);
+        GsonXMLStreamReader gsonXMLStreamReader = (GsonXMLStreamReader) streamReader;
+        JsonReader jsonReader = gsonXMLStreamReader.getJsonReader();
+        Assert.assertNotNull(jsonReader);
+        try {
+            String actualString = readJsonReader(jsonReader);
+            Assert.assertEquals("value", actualString);
+        } catch (IOException e) {
+            Assert.assertFalse(true);
+        }
+
+        inputStream.close();
+
+    }
+
+    private String readJsonReader(JsonReader jsonReader) throws IOException {
+        jsonReader.beginObject();
+        jsonReader.nextName();
+        jsonReader.beginObject();
+        jsonReader.nextName();
+        String name = jsonReader.nextString();
+        jsonReader.endObject();
+        jsonReader.endObject();
+        return name;
+    }
+}
Index: modules/json/test/org/apache/axis2/json/impl/GsonXMLStreamReaderTest.java
===================================================================
--- modules/json/test/org/apache/axis2/json/impl/GsonXMLStreamReaderTest.java	(revision 0)
+++ modules/json/test/org/apache/axis2/json/impl/GsonXMLStreamReaderTest.java	(revision 0)
@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.json.impl;
+
+import com.google.gson.stream.JsonReader;
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.impl.builder.StAXOMBuilder;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.xml.namespace.QName;
+import javax.xml.transform.stream.StreamSource;
+import java.io.ByteArrayInputStream;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.List;
+
+public class GsonXMLStreamReaderTest {
+    
+    
+    @Test
+    public void testGsonXMLStreamReader() throws Exception {
+        String jsonString = "{\"response\":{\"return\":{\"name\":\"kate\",\"age\":\"35\",\"gender\":\"female\"}}}";
+        String xmlString = "<response xmlns=\"http://www.w3schools.com\"><return><name>kate</name><age>35</age><gender>female</gender></return></response>";
+        InputStream inputStream = new ByteArrayInputStream(jsonString.getBytes());
+        JsonReader jsonReader = new JsonReader(new InputStreamReader(inputStream , "UTF-8"));
+        String fileName = "test-resources/custom_schema/testSchema_1.xsd";
+        InputStream is = new FileInputStream(fileName);
+        XmlSchemaCollection schemaCol = new XmlSchemaCollection();
+        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        List<XmlSchema> schemaList = new ArrayList<XmlSchema>();
+        schemaList.add(schema);
+        QName elementQName = new QName("http://www.w3schools.com", "response");
+        ConfigurationContext configCtxt = new ConfigurationContext(new AxisConfiguration());
+        GsonXMLStreamReader gsonXMLStreamReader = new GsonXMLStreamReader(jsonReader);
+        gsonXMLStreamReader.initXmlStreamReader(elementQName , schemaList , configCtxt);
+        StAXOMBuilder stAXOMBuilder = new StAXOMBuilder(gsonXMLStreamReader);
+        OMElement omElement = stAXOMBuilder.getDocumentElement();
+        String actual = omElement.toString();
+        inputStream.close();
+        is.close();
+        Assert.assertEquals(xmlString , actual);
+
+    }
+}
Index: modules/json/test/org/apache/axis2/json/impl/JsonFormatterTest.java
===================================================================
--- modules/json/test/org/apache/axis2/json/impl/JsonFormatterTest.java	(revision 0)
+++ modules/json/test/org/apache/axis2/json/impl/JsonFormatterTest.java	(revision 0)
@@ -0,0 +1,211 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.json.impl;
+
+import com.google.gson.Gson;
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.OMFactory;
+import org.apache.axiom.om.OMNamespace;
+import org.apache.axiom.om.OMOutputFormat;
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axiom.soap.SOAPFactory;
+import org.apache.axis2.Constants;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.description.AxisMessage;
+import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.AxisOperationFactory;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.axis2.json.impl.utils.JsonConstant;
+import org.apache.axis2.wsdl.WSDLConstants;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.xml.namespace.QName;
+import javax.xml.transform.stream.StreamSource;
+import java.io.ByteArrayOutputStream;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+public class JsonFormatterTest {
+    MessageContext outMsgContext;
+    String contentType;
+    String jsonString;
+    SOAPEnvelope soapEnvelope;
+    OMOutputFormat outputFormat;
+    OutputStream outputStream;
+    @Before
+    public void setUp() throws Exception {
+        contentType = "application/json-impl";
+        SOAPFactory soapFactory = OMAbstractFactory.getSOAP11Factory();
+        soapEnvelope = soapFactory.getDefaultEnvelope();
+        outputFormat = new OMOutputFormat();
+        outputStream = new ByteArrayOutputStream();
+
+        outMsgContext = new MessageContext();
+        outMsgContext.setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, "UTF-8");
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        outputStream.close();
+    }
+
+    @Test
+    public void testWriteToFaultMessage() throws Exception {
+        jsonString = "{\"Fault\":{\"faultcode\":\"soapenv:Server\",\"faultstring\":\"javax.xml.stream.XMLStreamException\",\"detail\":\"testFaultMsg\"}}";
+        outMsgContext.setProcessingFault(true);
+        soapEnvelope.getBody().addChild(createFaultOMElement());
+        outMsgContext.setEnvelope(soapEnvelope);
+        JsonFormatter jsonFormatter = new JsonFormatter();
+        jsonFormatter.writeTo(outMsgContext, outputFormat, outputStream, false);
+        String faultMsg = outputStream.toString();
+        Assert.assertEquals(jsonString , faultMsg);
+    }
+
+
+    @Test
+    public void testWriteToXMLtoJSON() throws Exception {
+        jsonString = "{\"response\":{\"return\":{\"name\":\"kate\",\"age\":\"35\",\"gender\":\"female\"}}}";
+        String fileName = "test-resources/custom_schema/testSchema_1.xsd";
+        InputStream is = new FileInputStream(fileName);
+        XmlSchemaCollection schemaCol = new XmlSchemaCollection();
+        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        QName elementQName = new QName("http://www.w3schools.com", "response");
+        ConfigurationContext configCtxt = new ConfigurationContext(new AxisConfiguration());
+        outMsgContext.setConfigurationContext(configCtxt);
+        AxisOperation axisOperation = AxisOperationFactory.getAxisOperation(AxisOperation.MEP_CONSTANT_IN_OUT);
+        AxisMessage message = new AxisMessage();
+        message.setElementQName(elementQName);
+        axisOperation.addMessage(message , WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
+        outMsgContext.setAxisOperation(axisOperation);
+        AxisService axisService = new AxisService("testService");
+        axisService.addSchema(schema);
+        outMsgContext.setAxisService(axisService);
+        soapEnvelope.getBody().addChild(getResponseOMElement());
+        outMsgContext.setEnvelope(soapEnvelope);
+        JsonFormatter jsonFormatter = new JsonFormatter();
+        jsonFormatter.writeTo(outMsgContext, outputFormat , outputStream , false);
+        String response = outputStream.toString();
+        Assert.assertEquals(jsonString, response);
+    }
+
+
+    @Test
+    public void testWriteToJSON() throws Exception {
+        Person person = new Person();
+        person.setName("Leo");
+        person.setAge(27);
+        person.setGender("Male");
+        person.setSingle(true);
+        outMsgContext.setProperty(JsonConstant.RETURN_OBJECT, person);
+        outMsgContext.setProperty(JsonConstant.RETURN_TYPE, Person.class);
+        jsonString = "{\""+ JsonConstant.RESPONSE +"\":" + new Gson().toJson(person, Person.class) + "}";
+
+        JsonFormatter jsonFormatter = new JsonFormatter();
+        jsonFormatter.writeTo(outMsgContext, outputFormat, outputStream, false);
+        String personString = outputStream.toString();
+        Assert.assertEquals(jsonString, personString);
+
+    }
+
+
+    private OMElement createFaultOMElement() {
+        OMFactory omFactory = OMAbstractFactory.getOMFactory();
+        OMNamespace ns = omFactory.createOMNamespace("", "");
+        OMElement faultCode = omFactory.createOMElement("faultcode", ns);
+        faultCode.setText("soapenv:Server");
+        OMElement faultString = omFactory.createOMElement("faultstring", ns);
+        faultString.setText("javax.xml.stream.XMLStreamException");
+        OMElement detail = omFactory.createOMElement("detail", ns);
+        detail.setText("testFaultMsg");
+        OMElement fault = omFactory.createOMElement("Fault", ns);
+        fault.addChild(faultCode);
+        fault.addChild(faultString);
+        fault.addChild(detail);
+        return  fault;
+    }
+
+    private OMElement getResponseOMElement() {
+        OMFactory omFactory = OMAbstractFactory.getOMFactory();
+        OMNamespace ns = omFactory.createOMNamespace("", "");
+
+        OMElement response = omFactory.createOMElement("response", ns);
+        OMElement ret = omFactory.createOMElement("return", ns);
+        OMElement name = omFactory.createOMElement("name", ns);
+        name.setText("kate");
+        OMElement age = omFactory.createOMElement("age", ns);
+        age.setText("35");
+        OMElement gender = omFactory.createOMElement("gender", ns);
+        gender.setText("female");
+        ret.addChild(name);
+        ret.addChild(age);
+        ret.addChild(gender);
+        response.addChild(ret);
+        return response;
+    }
+
+    public static class Person {
+
+        private String name;
+        private int age;
+        private String gender;
+        private boolean single;
+
+        public String getName() {
+            return name;
+        }
+
+        public void setName(String name) {
+            this.name = name;
+        }
+
+        public int getAge() {
+            return age;
+        }
+
+        public void setAge(int age) {
+            this.age = age;
+        }
+
+        public String getGender() {
+            return gender;
+        }
+
+        public void setGender(String gender) {
+            this.gender = gender;
+        }
+
+        public boolean isSingle() {
+            return single;
+        }
+
+        public void setSingle(boolean single) {
+            this.single = single;
+        }
+    }
+}
Index: modules/json/src/org/apache/axis2/json/impl/GsonXMLStreamWriter.java
===================================================================
--- modules/json/src/org/apache/axis2/json/impl/GsonXMLStreamWriter.java	(revision 0)
+++ modules/json/src/org/apache/axis2/json/impl/GsonXMLStreamWriter.java	(revision 0)
@@ -0,0 +1,801 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.json.impl;
+
+import com.google.gson.stream.JsonWriter;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.json.impl.utils.JSONType;
+import org.apache.axis2.json.impl.utils.JsonConstant;
+import org.apache.axis2.json.impl.utils.JsonObject;
+import org.apache.axis2.json.impl.utils.XmlNode;
+import org.apache.axis2.json.impl.utils.XmlNodeGenerator;
+import org.apache.ws.commons.schema.XmlSchema;
+
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamWriter;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Queue;
+import java.util.Stack;
+
+
+public class GsonXMLStreamWriter implements XMLStreamWriter {
+
+    private JsonWriter jsonWriter;
+
+    /**
+     * queue is used to keep the outgoing response structure according to the response XMLSchema
+     */
+    private Queue<JsonObject> queue = new LinkedList<JsonObject>();
+
+    /**
+     * This stacks use to process the outgoing response
+     */
+    private Stack<JsonObject> stack = new Stack<JsonObject>();
+    private Stack<JsonObject> miniStack = new Stack<JsonObject>();
+
+    private JsonObject flushObject;
+
+    /**
+     * topNestedArrayObj is use to keep the most top nested array object
+     */
+    private JsonObject topNestedArrayObj;
+
+    /**
+     * processedJsonObject stack is used to keep processed JsonObject for future reference
+     */
+    private Stack<JsonObject> processedJsonObjects = new Stack<JsonObject>();
+
+    private List<XmlSchema> xmlSchemaList;
+
+    /**
+     * Element QName of outgoing message , which is get from the outgoing message context
+     */
+    private QName elementQName;
+
+    /**
+     * Intermediate representation of XmlSchema
+     */
+    private XmlNode mainXmlNode;
+
+    private ConfigurationContext configContext;
+
+    private XmlNodeGenerator xmlNodeGenerator;
+
+    private boolean isProcessed;
+
+    /**
+     * This map is used to keep namespace uri with prefixes
+     */
+    private Map<String, String> uriPrefixMap = new HashMap<String, String>();
+
+
+    public GsonXMLStreamWriter(JsonWriter jsonWriter, QName elementQName, List<XmlSchema> xmlSchemaList,
+                               ConfigurationContext context) {
+        this.jsonWriter = jsonWriter;
+        this.elementQName = elementQName;
+        this.xmlSchemaList = xmlSchemaList;
+        this.configContext = context;
+    }
+
+    private void process() throws IOException {
+        Object ob = configContext.getProperty(JsonConstant.XMLNODES);
+        if (ob != null) {
+            Map<QName, XmlNode> nodeMap = (Map<QName, XmlNode>) ob;
+            XmlNode resNode = nodeMap.get(elementQName);
+            if (resNode != null) {
+                xmlNodeGenerator = new XmlNodeGenerator();
+                queue = xmlNodeGenerator.getQueue(resNode);
+            } else {
+                xmlNodeGenerator = new XmlNodeGenerator(xmlSchemaList, elementQName);
+                mainXmlNode = xmlNodeGenerator.getMainXmlNode();
+                queue = xmlNodeGenerator.getQueue(mainXmlNode);
+                nodeMap.put(elementQName, mainXmlNode);
+                configContext.setProperty(JsonConstant.XMLNODES, nodeMap);
+            }
+        } else {
+            Map<QName, XmlNode> newNodeMap = new HashMap<QName, XmlNode>();
+            xmlNodeGenerator = new XmlNodeGenerator(xmlSchemaList, elementQName);
+            mainXmlNode = xmlNodeGenerator.getMainXmlNode();
+            queue = xmlNodeGenerator.getQueue(mainXmlNode);
+            newNodeMap.put(elementQName, mainXmlNode);
+            configContext.setProperty(JsonConstant.XMLNODES, newNodeMap);
+        }
+        isProcessed = true;
+        this.jsonWriter.beginObject();
+    }
+
+
+    private void writeStartJson(JsonObject jsonObject) throws IOException {
+
+        if (jsonObject.getType() == JSONType.OBJECT) {
+            jsonWriter.name(jsonObject.getName());
+        } else if (jsonObject.getType() == JSONType.ARRAY) {
+            jsonWriter.name(jsonObject.getName());
+            jsonWriter.beginArray();
+
+        } else if (jsonObject.getType() == JSONType.NESTED_ARRAY) {
+            jsonWriter.name(jsonObject.getName());
+            jsonWriter.beginArray();
+            jsonWriter.beginObject();
+            if (topNestedArrayObj == null) {
+                topNestedArrayObj = jsonObject;
+                processedJsonObjects.push(jsonObject);
+            }
+        } else if (jsonObject.getType() == JSONType.NESTED_OBJECT) {
+            jsonWriter.name(jsonObject.getName());
+            jsonWriter.beginObject();
+
+        }
+
+    }
+
+    private void writeEndJson(JsonObject endJson) throws IOException {
+        if (endJson.getType() == JSONType.OBJECT) {
+            // nothing write to json writer
+        } else if (endJson.getType() == JSONType.ARRAY) {
+            jsonWriter.endArray();
+        } else if (endJson.getType() == JSONType.NESTED_ARRAY) {
+            jsonWriter.endArray();
+        } else if (endJson.getType() == JSONType.NESTED_OBJECT) {
+            jsonWriter.endObject();
+        }
+
+    }
+
+
+    private JsonObject popStack() {
+        if (topNestedArrayObj == null || stack.peek().getType() == JSONType.NESTED_OBJECT
+                || stack.peek().getType() == JSONType.NESTED_ARRAY) {
+            return stack.pop();
+        } else {
+            processedJsonObjects.push(stack.peek());
+            return stack.pop();
+        }
+    }
+
+    private void fillMiniStack(JsonObject nestedJsonObject) {
+
+        while (!processedJsonObjects.peek().getName().equals(nestedJsonObject.getName())) {
+            miniStack.push(processedJsonObjects.pop());
+        }
+        processedJsonObjects.pop();
+    }
+
+
+    /**
+     * Writes a start tag to the output.  All writeStartElement methods
+     * open a new scope in the internal namespace context.  Writing the
+     * corresponding EndElement causes the scope to be closed.
+     *
+     * @param localName local name of the tag, may not be null
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeStartElement(String localName) throws XMLStreamException {
+        if (!isProcessed) {
+            try {
+                process();
+            } catch (IOException e) {
+                throw new XMLStreamException("Error occours while write first begin object ");
+            }
+        }
+        JsonObject stackObj = null;
+        try {
+            if (miniStack.isEmpty()) {
+                if (!queue.isEmpty()) {
+                    JsonObject queObj = queue.peek();
+                    if (queObj.getName().equals(localName)) {
+                        if (flushObject != null) {
+                            if (topNestedArrayObj != null && flushObject.getType() == JSONType.NESTED_ARRAY
+                                    && flushObject.getName().equals(topNestedArrayObj.getName())) {
+                                topNestedArrayObj = null;
+                                processedJsonObjects.clear();
+                            }
+                            popStack();
+                            writeEndJson(flushObject);
+                            flushObject = null;
+                        }
+
+                        if (topNestedArrayObj != null && (queObj.getType() == JSONType.NESTED_ARRAY ||
+                                queObj.getType() == JSONType.NESTED_OBJECT)) {
+                            processedJsonObjects.push(queObj);
+                        }
+                        writeStartJson(queObj);
+                        stack.push(queue.poll());
+                    } else if (!stack.isEmpty()) {
+                        stackObj = stack.peek();
+                        if (stackObj.getName().equals(localName)) {
+                            if (stackObj.getType() == JSONType.NESTED_ARRAY) {
+                                fillMiniStack(stackObj);
+                                jsonWriter.beginObject();
+                                processedJsonObjects.push(stackObj);
+                            }
+                            flushObject = null;
+                        } else {
+                            throw new XMLStreamException("Invalid Staring element");
+                        }
+                    }
+                } else {
+                    if (!stack.isEmpty()) {
+                        stackObj = stack.peek();
+                        if (stackObj.getName().equals(localName)) {
+                            flushObject = null;
+                            if (stackObj.getType() == JSONType.NESTED_ARRAY) {
+                                fillMiniStack(stackObj);
+                                jsonWriter.beginObject();
+                                processedJsonObjects.push(stackObj);
+                            }
+                        } else {
+                            throw new XMLStreamException("Invalid Staring element");
+                        }
+                    } else {
+                        throw new XMLStreamException("Invalid Starting  element");
+                    }
+                }
+            } else {
+                JsonObject queObj = miniStack.peek();
+                if (queObj.getName().equals(localName)) {
+                    if (flushObject != null) {
+                        popStack();
+                        writeEndJson(flushObject);
+                        flushObject = null;
+                    }
+                    if (topNestedArrayObj != null && (queObj.getType() == JSONType.NESTED_OBJECT
+                            || queObj.getType() == JSONType.NESTED_ARRAY)) {
+                        processedJsonObjects.push(queObj);
+                    }
+                    writeStartJson(queObj);
+                    stack.push(miniStack.pop());
+                } else if (!stack.isEmpty()) {
+                    stackObj = stack.peek();
+                    if (stackObj.getName().equals(localName)) {
+                        flushObject = null;
+                        if (stackObj.getType() == JSONType.NESTED_ARRAY) {
+                            fillMiniStack(stackObj);
+                            jsonWriter.beginObject();
+                            processedJsonObjects.push(stackObj);
+                        }
+                    } else {
+                        throw new XMLStreamException("Invalid Staring element");
+                    }
+                }
+            }
+        } catch (IOException e) {
+            throw new XMLStreamException(" Json Writer throw an error");
+        }
+    }
+
+    /**
+     * Writes a start tag to the output
+     *
+     * @param namespaceURI the namespaceURI of the prefix to use, may not be null
+     * @param localName    local name of the tag, may not be null
+     * @throws javax.xml.stream.XMLStreamException
+     *          if the namespace URI has not been bound to a prefix and
+     *          javax.xml.stream.isRepairingNamespaces has not been set to true
+     */
+    @Override
+    public void writeStartElement(String namespaceURI, String localName) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Writes a start tag to the output
+     *
+     * @param localName    local name of the tag, may not be null
+     * @param prefix       the prefix of the tag, may not be null
+     * @param namespaceURI the uri to bind the prefix to, may not be null
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeStartElement(String prefix, String localName, String namespaceURI) throws XMLStreamException {
+        writeStartElement(localName);
+    }
+
+    /**
+     * Writes an empty element tag to the output
+     *
+     * @param namespaceURI the uri to bind the tag to, may not be null
+     * @param localName    local name of the tag, may not be null
+     * @throws javax.xml.stream.XMLStreamException
+     *          if the namespace URI has not been bound to a prefix and
+     *          javax.xml.stream.isRepairingNamespaces has not been set to true
+     */
+    @Override
+    public void writeEmptyElement(String namespaceURI, String localName) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Writes an empty element tag to the output
+     *
+     * @param prefix       the prefix of the tag, may not be null
+     * @param localName    local name of the tag, may not be null
+     * @param namespaceURI the uri to bind the tag to, may not be null
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeEmptyElement(String prefix, String localName, String namespaceURI) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Writes an empty element tag to the output
+     *
+     * @param localName local name of the tag, may not be null
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeEmptyElement(String localName) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Writes an end tag to the output relying on the internal
+     * state of the writer to determine the prefix and local name
+     * of the event.
+     *
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeEndElement() throws XMLStreamException {
+        if (!isProcessed) {
+            try {
+                process();
+            } catch (IOException e) {
+                throw new XMLStreamException("Error occours while write first begin object ");
+            }
+        }
+        JsonObject stackObj = null;
+        try {
+            if (flushObject != null) {
+                if (topNestedArrayObj != null && flushObject.getType() == JSONType.NESTED_ARRAY &&
+                        flushObject.equals(topNestedArrayObj.getName())) {
+                    topNestedArrayObj = null;
+                    processedJsonObjects.clear();
+                }
+                popStack();
+                writeEndJson(flushObject);
+                flushObject = null;
+                writeEndElement();
+            } else {
+                if (stack.peek().getType() == JSONType.ARRAY) {
+                    flushObject = stack.peek();
+                } else if (stack.peek().getType() == JSONType.NESTED_ARRAY) {
+                    flushObject = stack.peek();
+                    jsonWriter.endObject();
+                } else {
+                    stackObj = popStack();
+                    writeEndJson(stackObj);
+                }
+            }
+        } catch (IOException e) {
+            throw new XMLStreamException("Json writer throw an exception");
+        }
+    }
+
+    /**
+     * Closes any start tags and writes corresponding end tags.
+     *
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeEndDocument() throws XMLStreamException {
+        if (!isProcessed) {
+            try {
+                process();
+            } catch (IOException e) {
+                throw new XMLStreamException("Error occours while write first begin object ");
+            }
+        }
+        if (queue.isEmpty() && stack.isEmpty()) {
+            try {
+                if (flushObject != null) {
+                    writeEndJson(flushObject);
+                }
+                jsonWriter.endObject();
+                jsonWriter.flush();
+                jsonWriter.close();
+            } catch (IOException e) {
+                throw new XMLStreamException("JsonWriter threw an exception", e);
+            }
+        } else {
+            throw new XMLStreamException("Invalid xml element");
+        }
+    }
+
+    /**
+     * Close this writer and free any resources associated with the
+     * writer.  This must not close the underlying output stream.
+     *
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void close() throws XMLStreamException {
+        try {
+            jsonWriter.close();
+        } catch (IOException e) {
+            throw new RuntimeException("Error occur while closing JsonWriter");
+        }
+    }
+
+    /**
+     * Write any cached data to the underlying output mechanism.
+     *
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void flush() throws XMLStreamException {
+    }
+
+    /**
+     * Writes an attribute to the output stream without
+     * a prefix.
+     *
+     * @param localName the local name of the attribute
+     * @param value     the value of the attribute
+     * @throws IllegalStateException if the current state does not allow Attribute writing
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeAttribute(String localName, String value) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Writes an attribute to the output stream
+     *
+     * @param prefix       the prefix for this attribute
+     * @param namespaceURI the uri of the prefix for this attribute
+     * @param localName    the local name of the attribute
+     * @param value        the value of the attribute
+     * @throws IllegalStateException if the current state does not allow Attribute writing
+     * @throws javax.xml.stream.XMLStreamException
+     *                               if the namespace URI has not been bound to a prefix and
+     *                               javax.xml.stream.isRepairingNamespaces has not been set to true
+     */
+    @Override
+    public void writeAttribute(String prefix, String namespaceURI, String localName, String value) throws XMLStreamException {
+        // GsonXMLStreamReader doesn't write Attributes
+    }
+
+    /**
+     * Writes an attribute to the output stream
+     *
+     * @param namespaceURI the uri of the prefix for this attribute
+     * @param localName    the local name of the attribute
+     * @param value        the value of the attribute
+     * @throws IllegalStateException if the current state does not allow Attribute writing
+     * @throws javax.xml.stream.XMLStreamException
+     *                               if the namespace URI has not been bound to a prefix and
+     *                               javax.xml.stream.isRepairingNamespaces has not been set to true
+     */
+    @Override
+    public void writeAttribute(String namespaceURI, String localName, String value) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Writes a namespace to the output stream
+     * If the prefix argument to this method is the empty string,
+     * "xmlns", or null this method will delegate to writeDefaultNamespace
+     *
+     * @param prefix       the prefix to bind this namespace to
+     * @param namespaceURI the uri to bind the prefix to
+     * @throws IllegalStateException if the current state does not allow Namespace writing
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeNamespace(String prefix, String namespaceURI) throws XMLStreamException {
+    }
+
+    /**
+     * Writes the default namespace to the stream
+     *
+     * @param namespaceURI the uri to bind the default namespace to
+     * @throws IllegalStateException if the current state does not allow Namespace writing
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeDefaultNamespace(String namespaceURI) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Writes an xml comment with the data enclosed
+     *
+     * @param data the data contained in the comment, may be null
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeComment(String data) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Writes a processing instruction
+     *
+     * @param target the target of the processing instruction, may not be null
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeProcessingInstruction(String target) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Writes a processing instruction
+     *
+     * @param target the target of the processing instruction, may not be null
+     * @param data   the data contained in the processing instruction, may not be null
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeProcessingInstruction(String target, String data) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Writes a CData section
+     *
+     * @param data the data contained in the CData Section, may not be null
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeCData(String data) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Write a DTD section.  This string represents the entire doctypedecl production
+     * from the XML 1.0 specification.
+     *
+     * @param dtd the DTD to be written
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeDTD(String dtd) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Writes an entity reference
+     *
+     * @param name the name of the entity
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeEntityRef(String name) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Write the XML Declaration. Defaults the XML version to 1.0, and the encoding to utf-8
+     *
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeStartDocument() throws XMLStreamException {
+        if (!isProcessed) {
+            try {
+                process();
+            } catch (IOException e) {
+                throw new XMLStreamException("Error occur while write first begin object ");
+            }
+        }
+    }
+
+    /**
+     * Write the XML Declaration. Defaults the XML version to 1.0
+     *
+     * @param version version of the xml document
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeStartDocument(String version) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Write the XML Declaration.  Note that the encoding parameter does
+     * not set the actual encoding of the underlying output.  That must
+     * be set when the instance of the XMLStreamWriter is created using the
+     * XMLOutputFactory
+     *
+     * @param encoding encoding of the xml declaration
+     * @param version  version of the xml document
+     * @throws javax.xml.stream.XMLStreamException
+     *          If given encoding does not match encoding
+     *          of the underlying stream
+     */
+    @Override
+    public void writeStartDocument(String encoding, String version) throws XMLStreamException {
+        if (!isProcessed) {
+            xmlNodeGenerator.getMainXmlNode();
+            queue = xmlNodeGenerator.getQueue(mainXmlNode);
+            isProcessed = true;
+        }
+    }
+
+    /**
+     * Write text to the output
+     *
+     * @param text the value to write
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeCharacters(String text) throws XMLStreamException {
+        if (!isProcessed) {
+            try {
+                process();
+            } catch (IOException e) {
+                throw new XMLStreamException("Error occur while trying to write first begin object ");
+            }
+        }
+        try {
+            JsonObject peek = stack.peek();
+            String valueType = peek.getValueType();
+            if (valueType.equals("string")) {
+                jsonWriter.value(text);
+            } else if (valueType.equals("int")) {
+                Number num = new Integer(text);
+                jsonWriter.value(num);
+            } else if (valueType.equals("long")) {
+                jsonWriter.value(Long.valueOf(text));
+            } else if (valueType.equals("double")) {
+                jsonWriter.value(Double.valueOf(text));
+            } else if (valueType.equals("boolean")) {
+                jsonWriter.value(Boolean.valueOf(text));
+            } else {
+                jsonWriter.value(text);
+            }
+        } catch (IOException e) {
+            throw new XMLStreamException("JsonWriter throw an exception");
+        }
+    }
+
+    /**
+     * Write text to the output
+     *
+     * @param text  the value to write
+     * @param start the starting position in the array
+     * @param len   the number of characters to write
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void writeCharacters(char[] text, int start, int len) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Gets the prefix the uri is bound to
+     *
+     * @return the prefix or null
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public String getPrefix(String uri) throws XMLStreamException {
+        return uriPrefixMap.get(uri);
+    }
+
+    /**
+     * Sets the prefix the uri is bound to.  This prefix is bound
+     * in the scope of the current START_ELEMENT / END_ELEMENT pair.
+     * If this method is called before a START_ELEMENT has been written
+     * the prefix is bound in the root scope.
+     *
+     * @param prefix the prefix to bind to the uri, may not be null
+     * @param uri    the uri to bind to the prefix, may be null
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void setPrefix(String prefix, String uri) throws XMLStreamException {
+        uriPrefixMap.put(uri, prefix);
+    }
+
+    /**
+     * Binds a URI to the default namespace
+     * This URI is bound
+     * in the scope of the current START_ELEMENT / END_ELEMENT pair.
+     * If this method is called before a START_ELEMENT has been written
+     * the uri is bound in the root scope.
+     *
+     * @param uri the uri to bind to the default namespace, may be null
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void setDefaultNamespace(String uri) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Sets the current namespace context for prefix and uri bindings.
+     * This context becomes the root namespace context for writing and
+     * will replace the current root namespace context.  Subsequent calls
+     * to setPrefix and setDefaultNamespace will bind namespaces using
+     * the context passed to the method as the root context for resolving
+     * namespaces.  This method may only be called once at the start of
+     * the document.  It does not cause the namespaces to be declared.
+     * If a namespace URI to prefix mapping is found in the namespace
+     * context it is treated as declared and the prefix may be used
+     * by the StreamWriter.
+     *
+     * @param context the namespace context to use for this writer, may not be null
+     * @throws javax.xml.stream.XMLStreamException
+     *
+     */
+    @Override
+    public void setNamespaceContext(NamespaceContext context) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    /**
+     * Returns the current namespace context.
+     *
+     * @return the current NamespaceContext
+     */
+    @Override
+    public NamespaceContext getNamespaceContext() {
+        return null;
+    }
+
+    /**
+     * Get the value of a feature/property from the underlying implementation
+     *
+     * @param name The name of the property, may not be null
+     * @return The value of the property
+     * @throws IllegalArgumentException if the property is not supported
+     * @throws NullPointerException     if the name is null
+     */
+    @Override
+    public Object getProperty(String name) throws IllegalArgumentException {
+        return null;
+    }
+}
Index: modules/json/src/org/apache/axis2/json/impl/JsonBuilder.java
===================================================================
--- modules/json/src/org/apache/axis2/json/impl/JsonBuilder.java	(revision 1375161)
+++ modules/json/src/org/apache/axis2/json/impl/JsonBuilder.java	(working copy)
@@ -19,26 +19,41 @@
 
 package org.apache.axis2.json.impl;
 
+import com.google.gson.stream.JsonReader;
 import org.apache.axiom.om.OMAbstractFactory;
 import org.apache.axiom.om.OMElement;
 import org.apache.axiom.soap.SOAPEnvelope;
 import org.apache.axiom.soap.SOAPFactory;
 import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
 import org.apache.axis2.builder.Builder;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.json.impl.utils.JsonConstant;
 
+import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.UnsupportedEncodingException;
 
 public class JsonBuilder implements Builder {
     public OMElement processDocument(InputStream inputStream, String s, MessageContext messageContext) throws AxisFault {
-        messageContext.setProperty(JsonConstant.INPUT_STREAM ,inputStream);
         messageContext.setProperty(JsonConstant.IS_JSON_STREAM , true);
-        // dummy envelop
-        SOAPFactory soapFactory = OMAbstractFactory.getSOAP11Factory();
-        SOAPEnvelope soapEnvelope = soapFactory.getDefaultEnvelope();
-
-        return soapEnvelope;
+        JsonReader jsonReader = null;
+        String charSetEncoding=null;
+           try {
+               charSetEncoding = (String) messageContext.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
+               jsonReader = new JsonReader(new InputStreamReader(inputStream , charSetEncoding));
+               GsonXMLStreamReader gsonXMLStreamReader = new GsonXMLStreamReader(jsonReader);
+               messageContext.setProperty(JsonConstant.GSON_XML_STREAM_READER , gsonXMLStreamReader);
+               // dummy envelop
+               SOAPFactory soapFactory = OMAbstractFactory.getSOAP11Factory();
+               SOAPEnvelope soapEnvelope = soapFactory.getDefaultEnvelope();
+               return soapEnvelope;
+           } catch (UnsupportedEncodingException e) {
+               throw new AxisFault(charSetEncoding + " encoding is may not supported by json inputStream ", e);
+           } catch (IOException e) {
+               throw new AxisFault("IOException while processing JsonReader ", e);
+           }
     }
 
 }
Index: modules/json/src/org/apache/axis2/json/impl/utils/JsonObject.java
===================================================================
--- modules/json/src/org/apache/axis2/json/impl/utils/JsonObject.java	(revision 0)
+++ modules/json/src/org/apache/axis2/json/impl/utils/JsonObject.java	(revision 0)
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.json.impl.utils;
+
+
+public class JsonObject {
+    private String name;
+    private JSONType type;
+    private String valueType;
+    private String namespaceUri;
+
+    public JsonObject(String name, JSONType type, String valueType , String namespaceUri) {
+        this.name = name;
+        this.type = type;
+        this.valueType = valueType;
+        this.namespaceUri = namespaceUri;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public JSONType getType() {
+        return type;
+    }
+
+    public String getValueType() {
+        return valueType;
+    }
+
+    public String getNamespaceUri() {
+        return namespaceUri;
+    }
+}
Index: modules/json/src/org/apache/axis2/json/impl/utils/JsonConstant.java
===================================================================
--- modules/json/src/org/apache/axis2/json/impl/utils/JsonConstant.java	(revision 1375161)
+++ modules/json/src/org/apache/axis2/json/impl/utils/JsonConstant.java	(working copy)
@@ -25,10 +25,18 @@
 
     public static final String RESPONSE = "response";
 
-    public static final String INPUT_STREAM = "inputStream";
     public static final String RETURN_OBJECT = "returnObject";
     public static final String RETURN_TYPE = "returnType";
 
     public static final String IS_JSON_STREAM = "isJsonStream";
 
+    public static final String GSON_XML_STREAM_READER = "GsonXMLStreamReader";
+
+    public static final String XMLNODES = "xmlnodes";
+
+
+//    error messages
+
+    public static final String IN_JSON_MESSAGE_NOT_VALID = "Input JSON message is not valid ";
+
 }
Index: modules/json/src/org/apache/axis2/json/impl/utils/XmlNode.java
===================================================================
--- modules/json/src/org/apache/axis2/json/impl/utils/XmlNode.java	(revision 0)
+++ modules/json/src/org/apache/axis2/json/impl/utils/XmlNode.java	(revision 0)
@@ -0,0 +1,71 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.json.impl.utils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class XmlNode {
+
+    private String name;
+    private boolean isAttribute;
+    private boolean isArray;
+    private List<XmlNode> childrenList = new ArrayList<XmlNode>();
+    private String valueType;
+    private String namespaceUri;
+
+    public XmlNode(String name,String namespaceUri, boolean attribute, boolean array , String valueType) {
+        this.name = name;
+        this.namespaceUri = namespaceUri;
+        isAttribute = attribute;
+        isArray = array;
+        this.valueType = valueType;
+    }
+
+
+    public void addChildtoList(XmlNode child) {
+        childrenList.add(child);
+    }
+
+
+    public String getName() {
+        return name;
+    }
+
+    public boolean isAttribute() {
+        return isAttribute;
+    }
+
+    public boolean isArray() {
+        return isArray;
+    }
+
+    public List<XmlNode> getChildrenList() {
+        return childrenList;
+    }
+
+    public String getValueType() {
+        return valueType;
+    }
+
+    public String getNamespaceUri() {
+        return namespaceUri;
+    }
+}
Index: modules/json/src/org/apache/axis2/json/impl/utils/JsonUtils.java
===================================================================
--- modules/json/src/org/apache/axis2/json/impl/utils/JsonUtils.java	(revision 1375161)
+++ modules/json/src/org/apache/axis2/json/impl/utils/JsonUtils.java	(working copy)
@@ -31,20 +31,17 @@
 
 public class JsonUtils {
 
-    public static Object invokeServiceClass(InputStream inputStream ,
+    public static Object invokeServiceClass(JsonReader jsonReader,
                                             Object service,
                                             Method operation ,
                                             Class[] paramClasses ,
-                                            int paramCount , String charSetEncoding ) throws InvocationTargetException,
+                                            int paramCount ) throws InvocationTargetException,
             IllegalAccessException, IOException  {
 
         Object[] methodParam = new Object[paramCount];
         Gson gson = new Gson();
         String[] argNames = new String[paramCount];
-        JsonReader jsonReader = null;
 
-        jsonReader = new JsonReader(new InputStreamReader(inputStream,charSetEncoding));
-
         if( ! jsonReader.isLenient()){
             jsonReader.setLenient(true);
         }
Index: modules/json/src/org/apache/axis2/json/impl/utils/JSONType.java
===================================================================
--- modules/json/src/org/apache/axis2/json/impl/utils/JSONType.java	(revision 0)
+++ modules/json/src/org/apache/axis2/json/impl/utils/JSONType.java	(revision 0)
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.json.impl.utils;
+
+public enum JSONType {
+    ARRAY,
+    NESTED_ARRAY,
+    NESTED_OBJECT,
+    OBJECT,
+}
Index: modules/json/src/org/apache/axis2/json/impl/utils/XmlNodeGenerator.java
===================================================================
--- modules/json/src/org/apache/axis2/json/impl/utils/XmlNodeGenerator.java	(revision 0)
+++ modules/json/src/org/apache/axis2/json/impl/utils/XmlNodeGenerator.java	(revision 0)
@@ -0,0 +1,242 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.json.impl.utils;
+
+
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaComplexType;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.apache.ws.commons.schema.XmlSchemaObjectCollection;
+import org.apache.ws.commons.schema.XmlSchemaParticle;
+import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaSimpleType;
+import org.apache.ws.commons.schema.XmlSchemaType;
+
+import javax.xml.namespace.QName;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+public class XmlNodeGenerator {
+
+    List<XmlSchema> xmlSchemaList;
+
+    QName elementQname;
+
+    private XmlNode mainXmlNode;
+
+    Queue<JsonObject> queue = new LinkedList<JsonObject>();
+
+    public XmlNodeGenerator(List<XmlSchema> xmlSchemaList, QName elementQname) {
+        this.xmlSchemaList = xmlSchemaList;
+        this.elementQname = elementQname;
+    }
+
+    public XmlNodeGenerator() {
+    }
+
+    private void processSchemaList() {
+        // get the response schema and find the type then process.
+        XmlSchema responseSchema = getXmlSchema(elementQname);
+        XmlSchemaElement methodElement = responseSchema.getElementByName(elementQname.getLocalPart());
+        QName methodSchemaTypeName = methodElement.getSchemaTypeName();
+        mainXmlNode = new XmlNode(elementQname.getLocalPart(), elementQname.getNamespaceURI() , false, (methodElement.getMaxOccurs() == 1 ? false : true) , "");
+        XmlSchemaParticle particle = ((XmlSchemaComplexType) methodElement.getSchemaType()).getParticle();
+        XmlSchemaSequence sequence = (XmlSchemaSequence) particle;
+        XmlSchemaObjectCollection xmlSchemaObjectCollection = sequence.getItems();
+
+        Iterator iterator = xmlSchemaObjectCollection.getIterator();
+        while (iterator.hasNext()) {
+            Object nextEle = iterator.next();
+            if (nextEle instanceof XmlSchemaElement) {
+                XmlSchemaElement innerElement = ((XmlSchemaElement) nextEle);   // todo add to xml node
+                XmlSchemaType innerEleType = innerElement.getSchemaType();
+                if (innerEleType == null) {
+                    processSchemaTypeName(innerElement, mainXmlNode);
+                } else if (innerEleType instanceof XmlSchemaComplexType) {
+                    processComplexType(innerElement , mainXmlNode);
+                } else if (innerEleType instanceof XmlSchemaSimpleType) {
+                    processSimpleType(innerElement , mainXmlNode);
+                }
+            }
+        }
+
+/*        XmlSchemaElement argElement = (XmlSchemaElement) xmlSchemaObjectCollection.getItem(0);
+        XmlSchemaType schemaType = argElement.getSchemaType();
+        QName argQname = argElement.getQName();
+        QName schemaTypeName = argElement.getSchemaTypeName();
+        XmlNode temp;
+        if (argQname == null) {
+            temp = new XmlNode(argElement.getName(),elementQname.getNamespaceURI(), false, (argElement.getMaxOccurs() == 1 ? false : true) ,schemaTypeName.getLocalPart());
+        } else {
+            temp = new XmlNode(argQname.getLocalPart(),argQname.getNamespaceURI(), false, (argElement.getMaxOccurs() == 1 ? false : true) ,schemaTypeName.getLocalPart());
+
+        }
+        mainXmlNode.addChildtoList(temp);
+        String pref = schemaTypeName.getPrefix();
+        if (("xs").equals(pref)) {
+        } else {
+            XmlSchema tempXmlSchema = getXmlSchema(schemaTypeName);
+            processXmlSchema(tempXmlSchema, schemaTypeName,temp);
+        }*/
+    }
+
+    private XmlSchema getXmlSchema(QName qName) {
+        for (XmlSchema xmlSchema : xmlSchemaList) {
+            if (xmlSchema.getTargetNamespace().equals(qName.getNamespaceURI())) {
+                return xmlSchema;
+            }
+        }
+        return null;
+    }
+
+    private void processSchemaTypeName(XmlSchemaElement element, XmlNode parentNode) {
+        QName schemaTypeName = element.getSchemaTypeName();
+        QName qName = element.getQName();
+        String pref = schemaTypeName.getPrefix();
+        XmlNode temp;
+        if (qName == null) {
+            temp = new XmlNode(element.getName(), parentNode.getNamespaceUri(), false, (element.getMaxOccurs() == 1 ? false : true), schemaTypeName.getLocalPart());
+
+        } else {
+            temp = new XmlNode(qName.getLocalPart(), qName.getNamespaceURI(), false, (element.getMaxOccurs() == 1 ? false : true), schemaTypeName.getLocalPart());
+        }
+        parentNode.addChildtoList(temp);
+        if (("xs").equals(pref)) {
+        } else {
+            XmlSchema tempXmlSchema = getXmlSchema(schemaTypeName);
+            processXmlSchema(tempXmlSchema, schemaTypeName, temp);
+        }
+    }
+
+    private void processXmlSchema(XmlSchema schema, QName elementQName, XmlNode xmlNode) {
+        XmlSchemaElement element = schema.getElementByName(elementQName);
+        if (element != null) {
+            XmlNode temp = new XmlNode(elementQName.getLocalPart(), elementQName.getNamespaceURI(), false, (element.getMaxOccurs() == 1 ? false : true) , element.getSchemaTypeName().getLocalPart());
+            xmlNode.addChildtoList(temp);
+        } else {
+            XmlSchemaObjectCollection schemaObjectCollection = schema.getItems();
+            if (schemaObjectCollection.getCount() != 0) {
+                Iterator schemaObjIterator = schemaObjectCollection.getIterator();
+                while (schemaObjIterator.hasNext()) {
+                    Object next = schemaObjIterator.next();
+                    if (next instanceof XmlSchemaComplexType) {
+                        XmlSchemaComplexType comtype = (XmlSchemaComplexType) next;
+                        if (elementQName.getLocalPart().equals(comtype.getName())) {
+                            XmlSchemaParticle particle = comtype.getParticle();
+                            if (particle instanceof XmlSchemaSequence) {
+                                XmlSchemaSequence schemaSequence = (XmlSchemaSequence) particle;
+                                XmlSchemaObjectCollection InnerSchemaObjectCollection = schemaSequence.getItems();
+                                Iterator iterator = InnerSchemaObjectCollection.getIterator();
+                                while (iterator.hasNext()) {
+                                    Object nextEle = iterator.next();
+                                    if (nextEle instanceof XmlSchemaElement) {
+                                        XmlSchemaElement innerElement = ((XmlSchemaElement) nextEle);   // todo add to xml node
+                                        XmlSchemaType innerEleType = innerElement.getSchemaType();
+                                        if (innerEleType == null) {
+                                            processSchemaTypeName(innerElement, xmlNode);
+                                        } else if (innerEleType instanceof XmlSchemaComplexType) {
+                                            processComplexType(innerElement , xmlNode);
+                                        } else if (innerEleType instanceof XmlSchemaSimpleType) {
+                                            processSimpleType(innerElement , xmlNode);
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    } else {
+                        // process simpletype
+                    }
+                }
+            }
+        }
+    }
+
+    private void generateQueue(XmlNode node) {
+        if (node.isArray()) {
+            if (node.getChildrenList().size() > 0) {
+                queue.add(new JsonObject(node.getName(), JSONType.NESTED_ARRAY, node.getValueType() , node.getNamespaceUri()));
+                processXmlNodeChildren(node.getChildrenList());
+            } else {
+                queue.add(new JsonObject(node.getName(), JSONType.ARRAY , node.getValueType() , node.getNamespaceUri()));
+            }
+        } else {
+            if (node.getChildrenList().size() > 0) {
+                queue.add(new JsonObject(node.getName(), JSONType.NESTED_OBJECT, node.getValueType() , node.getNamespaceUri()));
+                processXmlNodeChildren(node.getChildrenList());
+            } else {
+                queue.add(new JsonObject(node.getName(), JSONType.OBJECT , node.getValueType() , node.getNamespaceUri()));
+            }
+        }
+    }
+
+    private void processComplexType(XmlSchemaElement xmlSchemaElement , XmlNode parentNode) {
+        QName schemaTypeName = xmlSchemaElement.getSchemaTypeName();
+        QName qName = xmlSchemaElement.getQName();
+        XmlNode temp = new XmlNode(qName.getLocalPart(), qName.getNamespaceURI(), false, (xmlSchemaElement.getMaxOccurs() == 1 ? false : true) , schemaTypeName.getLocalPart());
+        parentNode.addChildtoList(temp);
+        XmlSchemaSequence schemaSequence;
+        XmlSchemaParticle particle = ((XmlSchemaComplexType)xmlSchemaElement.getSchemaType()).getParticle();
+        if (particle instanceof XmlSchemaSequence) {
+            schemaSequence = (XmlSchemaSequence) particle;
+            XmlSchemaObjectCollection schemaObjectCollection = schemaSequence.getItems();
+            Iterator iterator = schemaObjectCollection.getIterator();
+            while (iterator.hasNext()) {
+                Object element = iterator.next();
+                if (element instanceof XmlSchemaElement) {
+                    XmlSchemaElement innerElement = ((XmlSchemaElement) element);
+                    XmlSchemaType innerEleType = innerElement.getSchemaType();
+                    if (innerEleType instanceof XmlSchemaComplexType) {
+                        processComplexType(innerElement , temp);
+                    } else if(innerEleType instanceof XmlSchemaSimpleType){
+                        processSimpleType(innerElement , temp);
+                    }
+                }
+            }
+        }
+    }
+
+    private void processSimpleType(XmlSchemaElement xmlSchemaElement , XmlNode parentNode) {
+        QName schemaTypeName= xmlSchemaElement.getSchemaTypeName();
+        QName qName = xmlSchemaElement.getQName();
+        XmlNode temp = new XmlNode(qName.getLocalPart(), qName.getNamespaceURI(), false, (xmlSchemaElement.getMaxOccurs() == 1 ? false : true) , schemaTypeName.getLocalPart());
+        parentNode.addChildtoList(temp);
+    }
+
+    private void processXmlNodeChildren(List<XmlNode> childrenNodes) {
+        for (int i = 0; i < childrenNodes.size(); i++) {
+            generateQueue(childrenNodes.get(i));
+        }
+    }
+
+    public XmlNode getMainXmlNode() {
+        if (mainXmlNode == null) {
+            processSchemaList();
+        }
+        return mainXmlNode;
+    }
+
+    public Queue<JsonObject> getQueue(XmlNode node) {
+        generateQueue(node);
+        return queue;
+    }
+
+}
Index: modules/json/src/org/apache/axis2/json/impl/rpc/JsonInOnlyRPCMessageReceiver.java
===================================================================
--- modules/json/src/org/apache/axis2/json/impl/rpc/JsonInOnlyRPCMessageReceiver.java	(revision 1375161)
+++ modules/json/src/org/apache/axis2/json/impl/rpc/JsonInOnlyRPCMessageReceiver.java	(working copy)
@@ -19,10 +19,12 @@
 
 package org.apache.axis2.json.impl.rpc;
 
+import com.google.gson.stream.JsonReader;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.json.impl.GsonXMLStreamReader;
 import org.apache.axis2.json.impl.utils.JsonConstant;
 import org.apache.axis2.json.impl.utils.JsonUtils;
 import org.apache.axis2.rpc.receivers.RPCInOnlyMessageReceiver;
@@ -39,7 +41,59 @@
     private static Log log = LogFactory.getLog(JsonInOnlyRPCMessageReceiver.class);
     @Override
     public void invokeBusinessLogic(MessageContext inMessage) throws AxisFault {
-        InputStream inputStream = (InputStream)inMessage.getProperty(JsonConstant.INPUT_STREAM);
+
+        Object tempObj = inMessage.getProperty(JsonConstant.IS_JSON_STREAM);
+        boolean isJsonStream;
+
+        if (tempObj != null) {
+            isJsonStream = Boolean.valueOf(tempObj.toString());
+        } else {
+            // if IS_JSON_STREAM property  is not set then it is not a JSON request
+            isJsonStream = false;
+        }
+
+        if (isJsonStream) {
+            Object o = inMessage.getProperty(JsonConstant.GSON_XML_STREAM_READER);
+            if (o != null) {
+                GsonXMLStreamReader gsonXMLStreamReader = (GsonXMLStreamReader)o;
+                JsonReader jsonReader = gsonXMLStreamReader.getJsonReader();
+                if (jsonReader == null) {
+                    throw new AxisFault("JsonReader should not be null");
+                }
+                Method method = null;
+                String msg;
+                Object serviceObj = getTheImplementationObject(inMessage);
+                Class implClass = serviceObj.getClass();
+                Method[] allMethods = implClass.getDeclaredMethods();
+                AxisOperation op = inMessage.getOperationContext().getAxisOperation();
+                String operation = op.getName().getLocalPart();
+                method = JsonUtils.getOpMethod(operation, allMethods);
+                Class[] paramClasses = method.getParameterTypes();
+                try {
+                    int paramCount = paramClasses.length;
+                    JsonUtils.invokeServiceClass(jsonReader, serviceObj, method, paramClasses, paramCount);
+                } catch (IllegalAccessException e) {
+                    msg = "Does not have access to " +
+                            "the definition of the specified class, field, method or constructor";
+                    log.error(msg, e);
+                    throw AxisFault.makeFault(e);
+
+                } catch (InvocationTargetException e) {
+                    msg = "Exception occurred while trying to invoke service method " +
+                            (method != null ? method.getName() : "null");
+                    log.error(msg, e);
+                    throw AxisFault.makeFault(e);
+                } catch (IOException e) {
+                    msg = "Exception occur while encording or " +
+                            "access to the input string at the JsonRpcMessageReceiver";
+                    log.error(msg, e);
+                    throw AxisFault.makeFault(e);
+                }
+            } else {
+                throw new AxisFault("GsonXMLStreamReader should have put as a property of messageContext " +
+                        "to evaluate JSON message");
+            }
+/*        InputStream inputStream = (InputStream)inMessage.getProperty(JsonConstant.INPUT_STREAM);
         if (inputStream != null) {
             Method method = null;
             String msg;
@@ -74,8 +128,8 @@
                         "access to the input string at the JsonRpcMessageReceiver";
                 log.error(msg, e);
                 throw AxisFault.makeFault(e);
-            }
-        } else{
+            }*/
+    } else{
             super.invokeBusinessLogic(inMessage);   // call RPCMessageReceiver if inputstream is null
         }
     }
Index: modules/json/src/org/apache/axis2/json/impl/rpc/JsonRpcMessageReceiver.java
===================================================================
--- modules/json/src/org/apache/axis2/json/impl/rpc/JsonRpcMessageReceiver.java	(revision 1375161)
+++ modules/json/src/org/apache/axis2/json/impl/rpc/JsonRpcMessageReceiver.java	(working copy)
@@ -18,10 +18,12 @@
  */
 package org.apache.axis2.json.impl.rpc;
 
+import com.google.gson.stream.JsonReader;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.json.impl.GsonXMLStreamReader;
 import org.apache.axis2.json.impl.utils.JsonConstant;
 import org.apache.axis2.json.impl.utils.JsonUtils;
 import org.apache.axis2.rpc.receivers.RPCMessageReceiver;
@@ -40,60 +42,63 @@
     @Override
     public void invokeBusinessLogic(MessageContext inMessage, MessageContext outMessage) throws AxisFault {
         Object tempObj = inMessage.getProperty(JsonConstant.IS_JSON_STREAM);
-        boolean isJsonStream = false;
+        boolean isJsonStream;
+
         if (tempObj != null) {
             isJsonStream = Boolean.valueOf(tempObj.toString());
+        } else {
+            // if IS_JSON_STREAM property  is not set then it is not a JSON request
+            isJsonStream = false;
         }
 
         if (isJsonStream) {
-            InputStream inputStream = (InputStream) inMessage.getProperty(JsonConstant.INPUT_STREAM);
-            Method method = null;
-            String msg;
+            Object o = inMessage.getProperty(JsonConstant.GSON_XML_STREAM_READER);
+            if (o != null) {
+                GsonXMLStreamReader gsonXMLStreamReader = (GsonXMLStreamReader)o;
+                JsonReader jsonReader = gsonXMLStreamReader.getJsonReader();
+                if (jsonReader == null) {
+                    throw new AxisFault("JsonReader should not be null");
+                }
+                Method method = null;
+                String msg;
+                Object serviceObj = getTheImplementationObject(inMessage);
+                Class implClass = serviceObj.getClass();
+                Method[] allMethods = implClass.getDeclaredMethods();
+                AxisOperation op = inMessage.getOperationContext().getAxisOperation();
+                String operation = op.getName().getLocalPart();
+                method = JsonUtils.getOpMethod(operation, allMethods);
+                Class[] paramClasses = method.getParameterTypes();
+                try {
+                    int paramCount = paramClasses.length;
+                    Object retObj = JsonUtils.invokeServiceClass(jsonReader, serviceObj, method, paramClasses, paramCount);
 
-            if (inputStream == null) {
-                msg = "Input Stream is null";
-                log.error(msg);
-                throw new AxisFault(msg);
-            }
+                    // handle response
+                    outMessage.setProperty(JsonConstant.RETURN_OBJECT, retObj);
+                    outMessage.setProperty(JsonConstant.RETURN_TYPE, method.getReturnType());
 
-            Object serviceObj = getTheImplementationObject(inMessage);
-            Class implClass = serviceObj.getClass();
-            Method[] allMethods = implClass.getDeclaredMethods();
-            AxisOperation op = inMessage.getOperationContext().getAxisOperation();
-            String operation = op.getName().getLocalPart();
-            method = JsonUtils.getOpMethod(operation, allMethods);
-            Class[] paramClasses = method.getParameterTypes();
-            String charSetEncoding = (String) inMessage.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
-            try {
-                int paramCount = paramClasses.length;
+                } catch (IllegalAccessException e) {
+                    msg = "Does not have access to " +
+                            "the definition of the specified class, field, method or constructor";
+                    log.error(msg, e);
+                    throw AxisFault.makeFault(e);
 
-                Object retObj = JsonUtils.invokeServiceClass(inputStream,
-                        serviceObj, method, paramClasses, paramCount, charSetEncoding);
-
-                outMessage.setProperty(JsonConstant.RETURN_OBJECT, retObj);
-                outMessage.setProperty(JsonConstant.RETURN_TYPE, method.getReturnType());
-
-            } catch (IllegalAccessException e) {
-                msg = "Does not have access to " +
-                        "the definition of the specified class, field, method or constructor";
-                log.error(msg, e);
-                throw AxisFault.makeFault(e);
-
-            } catch (InvocationTargetException e) {
-                msg = "Exception occurred while trying to invoke service method " +
-                        (method != null ? method.getName() : "null");
-                log.error(msg, e);
-                throw AxisFault.makeFault(e);
-            } catch (IOException e) {
-                msg = "Exception occur while encording or " +
-                        "access to the input string at the JsonRpcMessageReceiver";
-                log.error(msg, e);
-                throw AxisFault.makeFault(e);
+                } catch (InvocationTargetException e) {
+                    msg = "Exception occurred while trying to invoke service method " +
+                            (method != null ? method.getName() : "null");
+                    log.error(msg, e);
+                    throw AxisFault.makeFault(e);
+                } catch (IOException e) {
+                    msg = "Exception occur while encording or " +
+                            "access to the input string at the JsonRpcMessageReceiver";
+                    log.error(msg, e);
+                    throw AxisFault.makeFault(e);
+                }
+            } else {
+                throw new AxisFault("GsonXMLStreamReader should have put as a property of messageContext " +
+                        "to evaluate JSON message");
             }
         } else {
             super.invokeBusinessLogic(inMessage, outMessage);   // call RPCMessageReceiver if inputstream is null
         }
     }
-
-
 }
Index: modules/json/src/org/apache/axis2/json/impl/GsonXMLStreamReader.java
===================================================================
--- modules/json/src/org/apache/axis2/json/impl/GsonXMLStreamReader.java	(revision 0)
+++ modules/json/src/org/apache/axis2/json/impl/GsonXMLStreamReader.java	(revision 0)
@@ -0,0 +1,752 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.json.impl;
+
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.json.impl.utils.JSONType;
+import org.apache.axis2.json.impl.utils.JsonConstant;
+import org.apache.axis2.json.impl.utils.JsonObject;
+import org.apache.axis2.json.impl.utils.XmlNode;
+import org.apache.axis2.json.impl.utils.XmlNodeGenerator;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.ws.commons.schema.XmlSchema;
+
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.namespace.QName;
+import javax.xml.stream.Location;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Queue;
+import java.util.Stack;
+
+
+public class GsonXMLStreamReader implements XMLStreamReader {
+
+    private static final Log log = LogFactory.getLog(GsonXMLStreamReader.class);
+
+    private JsonReader jsonReader;
+
+    private JsonState state = JsonState.StartState;
+
+    private JsonToken tokenType;
+
+    private String localName;
+
+    private String value;
+
+    private boolean isProcessed;
+
+    private ConfigurationContext configContext;
+
+    private QName elementQname;
+
+    private XmlNode mainXmlNode;
+
+    private List<XmlSchema> xmlSchemaList;
+
+    private Queue<JsonObject> queue = new LinkedList<JsonObject>();
+
+    private XmlNodeGenerator xmlNodeGenerator;
+
+    private Stack<JsonObject> stackObj = new Stack<JsonObject>();
+    private Stack<JsonObject> miniStack = new Stack<JsonObject>();
+    private JsonObject topNestedArrayObj = null;
+    private Stack<JsonObject> processedJsonObject = new Stack<JsonObject>();
+
+    private String namespace;
+
+
+    // Default namespace
+    final static private String DEFAULT_NAMESPACE = "http://axis2.apache.org/axis/json";
+
+    final static private String DEFAULT_NAMESPACE_PREFIX = "ns";
+
+    public GsonXMLStreamReader(JsonReader jsonReader) {
+        this.jsonReader = jsonReader;
+    }
+
+    public GsonXMLStreamReader(JsonReader jsonReader, QName elementQname, List<XmlSchema> xmlSchemaList,
+                               ConfigurationContext configContext) {
+        this.jsonReader = jsonReader;
+        initXmlStreamReader(elementQname, xmlSchemaList, configContext);
+    }
+
+    public JsonReader getJsonReader() {
+        return jsonReader;
+    }
+
+    public void initXmlStreamReader(QName elementQname, List<XmlSchema> xmlSchemaList, ConfigurationContext configContext) {
+        this.elementQname = elementQname;
+        this.xmlSchemaList = xmlSchemaList;
+        this.configContext = configContext;
+        process();
+        isProcessed = true;
+
+    }
+
+    private void process() {
+        Object ob = configContext.getProperty(JsonConstant.XMLNODES);
+        if (ob != null) {
+            Map<QName, XmlNode> nodeMap = (Map<QName, XmlNode>) ob;
+            XmlNode requesNode = nodeMap.get(elementQname);
+            if (requesNode != null) {
+                xmlNodeGenerator = new XmlNodeGenerator();
+                queue = xmlNodeGenerator.getQueue(requesNode);
+            } else {
+                xmlNodeGenerator = new XmlNodeGenerator(xmlSchemaList, elementQname);
+                mainXmlNode = xmlNodeGenerator.getMainXmlNode();
+                queue = xmlNodeGenerator.getQueue(mainXmlNode);
+                nodeMap.put(elementQname, mainXmlNode);
+                configContext.setProperty(JsonConstant.XMLNODES, nodeMap);
+            }
+        } else {
+            Map<QName, XmlNode> newNodeMap = new HashMap<QName, XmlNode>();
+            xmlNodeGenerator = new XmlNodeGenerator(xmlSchemaList, elementQname);
+            mainXmlNode = xmlNodeGenerator.getMainXmlNode();
+            queue = xmlNodeGenerator.getQueue(mainXmlNode);
+            newNodeMap.put(elementQname, mainXmlNode);
+            configContext.setProperty(JsonConstant.XMLNODES, newNodeMap);
+        }
+        isProcessed = true;
+    }
+
+    @Override
+    public Object getProperty(String name) throws IllegalArgumentException {
+        return null;
+    }
+
+    @Override
+    public int next() throws XMLStreamException {
+        if (hasNext()) {
+            try {
+                stateTransition();
+            } catch (IOException e) {
+                throw new XMLStreamException("I/O error while reading JSON input Stream");
+            }
+            return getEventType();
+        } else {
+            throw new NoSuchElementException("There is no any next event");
+        }
+    }
+
+    @Override
+    public void require(int type, String namespaceURI, String localName) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public String getElementText() throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public int nextTag() throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public boolean hasNext() throws XMLStreamException {
+        try {
+            tokenType = jsonReader.peek();
+            if (tokenType == JsonToken.END_DOCUMENT) {
+                return false;
+            } else {
+                return true;
+            }
+        } catch (IOException e) {
+            throw new XMLStreamException("Unexpected end of json stream");
+        }
+    }
+
+    @Override
+    public void close() throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public String getNamespaceURI(String prefix) {
+        if (isStartElement() || isEndElement()) {
+            return namespace;
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public boolean isStartElement() {
+        if (state == JsonState.NameName
+                || state == JsonState.NameValue
+                || state == JsonState.ValueValue_CHAR
+                || state == JsonState.EndObjectBeginObject_START) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public boolean isEndElement() {
+        if (state == JsonState.ValueValue_START
+                || state == JsonState.EndArrayName
+                || state == JsonState.ValueEndObject_END_2
+                || state == JsonState.ValueName_START
+                || state == JsonState.EndObjectName
+                || state == JsonState.EndObjectBeginObject_END
+                || state == JsonState.EndArrayEndObject
+                || state == JsonState.EndObjectEndObject) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public boolean isCharacters() {
+        if (state == JsonState.ValueValue_END
+                || state == JsonState.ValueEndArray
+                || state == JsonState.ValueEndObject_END_1
+                || state == JsonState.ValueName_END) {
+            return true;
+        } else {
+            return false;
+        }
+
+    }
+
+    @Override
+    public boolean isWhiteSpace() {
+        return false;
+    }
+
+    @Override
+    public String getAttributeValue(String namespaceURI, String localName) {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public int getAttributeCount() {
+        if (isStartElement()) {
+            return 0; // don't support attributes on tags  in JSON convention
+        } else {
+            throw new IllegalStateException("Only valid on START_ELEMENT state");
+        }
+    }
+
+    @Override
+    public QName getAttributeName(int index) {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public String getAttributeNamespace(int index) {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public String getAttributeLocalName(int index) {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public String getAttributePrefix(int index) {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public String getAttributeType(int index) {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public String getAttributeValue(int index) {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public boolean isAttributeSpecified(int index) {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public int getNamespaceCount() {
+        if (isStartElement() || isEndElement()) {
+            return 1; // we have one default namesapce
+        } else {
+            throw new IllegalStateException("only valid on a START_ELEMENT or END_ELEMENT state");
+        }
+    }
+
+    @Override
+    public String getNamespacePrefix(int index) {
+        if (isStartElement() || isEndElement()) {
+            return null;
+        } else {
+            throw new IllegalStateException("only valid on a START_ELEMENT or END_ELEMENT state");
+        }
+    }
+
+    @Override
+    public String getNamespaceURI(int index) {
+        if (isStartElement() || isEndElement()) {
+            return namespace;
+        } else {
+            throw new IllegalStateException("only valid on a START_ELEMENT or END_ELEMENT state");
+        }
+    }
+
+    @Override
+    public NamespaceContext getNamespaceContext() {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public int getEventType() {
+        if (state == JsonState.StartState) {
+            return START_DOCUMENT;
+        } else if (isStartElement()) {
+            return START_ELEMENT;
+        } else if (isCharacters()) {
+            return CHARACTERS;
+        } else if (isEndElement()) {
+            return END_ELEMENT;
+        } else if (state == JsonState.EndObjectEndDocument) {
+            return END_DOCUMENT;
+        } else {
+            return 0;  //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+    }
+
+    @Override
+    public String getText() {
+        if (isCharacters()) {
+            return value;
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public char[] getTextCharacters() {
+        if (isCharacters()) {
+            if (value == null) {
+                return new char[0];
+            } else {
+                return value.toCharArray();
+            }
+        } else {
+            throw new IllegalStateException("This is not a valid state");
+        }
+    }
+
+    @Override
+    public int getTextCharacters(int sourceStart, char[] target, int targetStart, int length) throws XMLStreamException {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public int getTextStart() {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public int getTextLength() {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public String getEncoding() {
+        return null;
+    }
+
+    @Override
+    public boolean hasText() {
+        if (isCharacters()) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public Location getLocation() {
+        return new Location() {          // Location is unKnown
+            @Override
+            public int getLineNumber() {
+                return -1;
+            }
+
+            @Override
+            public int getColumnNumber() {
+                return -1;
+            }
+
+            @Override
+            public int getCharacterOffset() {
+                return 0;  //To change body of implemented methods use File | Settings | File Templates.
+            }
+
+            @Override
+            public String getPublicId() {
+                return null;  //To change body of implemented methods use File | Settings | File Templates.
+            }
+
+            @Override
+            public String getSystemId() {
+                return null;  //To change body of implemented methods use File | Settings | File Templates.
+            }
+        };
+    }
+
+    @Override
+    public QName getName() {
+        if (isStartElement() || isEndElement()) {
+            return new QName(namespace, localName);
+        } else {
+            throw new IllegalStateException("getName method is valid only for the START_ELEMENT or END_ELEMENT event");
+        }
+
+    }
+
+    @Override
+    public String getLocalName() {
+        int i = getEventType();
+        if (i == XMLStreamReader.START_ELEMENT || i == XMLStreamReader.END_ELEMENT) {
+            return localName;
+        } else {
+            throw new IllegalStateException("To get local name state should be START_ELEMENT or END_ELEMENT");
+        }
+    }
+
+    @Override
+    public boolean hasName() {
+        return (isStartElement() || isEndElement());
+    }
+
+    @Override
+    public String getNamespaceURI() {
+        if (isStartElement() || isEndElement()) {
+            return namespace;
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public String getPrefix() {
+        return null;
+    }
+
+    @Override
+    public String getVersion() {
+        return null;
+    }
+
+    @Override
+    public boolean isStandalone() {
+        return false;
+    }
+
+    @Override
+    public boolean standaloneSet() {
+        return false;
+    }
+
+    @Override
+    public String getCharacterEncodingScheme() {
+        return null;
+    }
+
+    @Override
+    public String getPITarget() {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    @Override
+    public String getPIData() {
+        throw new UnsupportedOperationException("Method is not implemented");
+    }
+
+    private void stateTransition() throws XMLStreamException, IOException {
+        if (state == JsonState.StartState) {
+            beginObject();
+            JsonObject topElement = new JsonObject("StackTopElement", JSONType.NESTED_OBJECT,
+                    null, "http://axis2.apache.org/axis/json");
+            stackObj.push(topElement);
+            readName();
+        } else if (state == JsonState.NameName) {
+            readName();
+        } else if (state == JsonState.NameValue) {
+            readValue();
+        } else if (state == JsonState.ValueEndObject_END_1) {
+            state = JsonState.ValueEndObject_END_2;
+            removeStackObj();
+        } else if (state == JsonState.ValueEndObject_END_2) {
+            readEndObject();
+        } else if (state == JsonState.ValueName_END) {
+            state = JsonState.ValueName_START;
+            removeStackObj();
+        } else if (state == JsonState.ValueName_START) {
+            readName();
+        } else if (state == JsonState.ValueValue_END) {
+            state = JsonState.ValueValue_START;
+        } else if (state == JsonState.ValueValue_START) {
+            value = null;
+            state = JsonState.ValueValue_CHAR;
+        } else if (state == JsonState.ValueValue_CHAR) {
+            readValue();
+        } else if (state == JsonState.ValueEndArray) {
+            readEndArray();
+            removeStackObj();
+        } else if (state == JsonState.EndArrayName) {
+            readName();
+        } else if (state == JsonState.EndObjectEndObject) {
+            readEndObject();
+        } else if (state == JsonState.EndObjectName) {
+            readName();
+        } else if (state == JsonState.EndObjectBeginObject_END) {
+            state = JsonState.EndObjectBeginObject_START;
+            fillMiniStack();
+        } else if (state == JsonState.EndObjectBeginObject_START) {
+            readBeginObject();
+        } else if (state == JsonState.EndArrayEndObject) {
+            readEndObject();
+        }
+
+    }
+
+    private void removeStackObj() throws XMLStreamException {
+        if (!stackObj.empty()) {
+            if (topNestedArrayObj == null) {
+                stackObj.pop();
+            } else {
+                if (stackObj.peek().equals(topNestedArrayObj)) {
+                    topNestedArrayObj = null;
+                    processedJsonObject.clear();
+                    stackObj.pop();
+                } else {
+                    processedJsonObject.push(stackObj.pop());
+                }
+            }
+            if (!stackObj.empty()) {
+                localName = stackObj.peek().getName();
+            } else {
+                localName = "";
+            }
+        } else {
+            System.out.println("stackObj is empty");
+            throw new XMLStreamException("Error while processing input JSON stream, JSON request may not valid ," +
+                    " it may has more end object characters ");
+        }
+    }
+
+    private void fillMiniStack() {
+        miniStack.clear();
+        JsonObject nestedArray = stackObj.peek();
+        while (!processedJsonObject.peek().equals(nestedArray)) {
+            miniStack.push(processedJsonObject.pop());
+        }
+    }
+
+    private void readName() throws IOException, XMLStreamException {
+        nextName();
+        tokenType = jsonReader.peek();
+        if (tokenType == JsonToken.BEGIN_OBJECT) {
+            beginObject();
+            state = JsonState.NameName;
+        } else if (tokenType == JsonToken.BEGIN_ARRAY) {
+            beginArray();
+            tokenType = jsonReader.peek();
+            if (tokenType == JsonToken.BEGIN_OBJECT) {
+                beginObject();
+                state = JsonState.NameName;
+            } else {
+                state = JsonState.NameValue;
+            }
+        } else if (tokenType == JsonToken.STRING || tokenType == JsonToken.NUMBER || tokenType == JsonToken.BOOLEAN
+                || tokenType == JsonToken.NULL) {
+            state = JsonState.NameValue;
+        }
+    }
+
+    private void readValue() throws IOException {
+        nextValue();
+        tokenType = jsonReader.peek();
+        if (tokenType == JsonToken.NAME) {
+            state = JsonState.ValueName_END;
+        } else if (tokenType == JsonToken.STRING || tokenType == JsonToken.NUMBER || tokenType == JsonToken.BOOLEAN
+                || tokenType == JsonToken.NULL) {
+            state = JsonState.ValueValue_END;
+        } else if (tokenType == JsonToken.END_ARRAY) {
+            state = JsonState.ValueEndArray;
+        } else if (tokenType == JsonToken.END_OBJECT) {
+            state = JsonState.ValueEndObject_END_1;
+        }
+    }
+
+    private void readBeginObject() throws IOException, XMLStreamException {
+        beginObject();
+        readName();
+    }
+
+    private void readEndObject() throws IOException, XMLStreamException {
+        endObject();
+        tokenType = jsonReader.peek();
+        if (tokenType == JsonToken.END_OBJECT) {
+            removeStackObj();
+            state = JsonState.EndObjectEndObject;
+        } else if (tokenType == JsonToken.END_ARRAY) {
+            readEndArray();
+            removeStackObj();
+        } else if (tokenType == JsonToken.NAME) {
+            removeStackObj();
+            state = JsonState.EndObjectName;
+        } else if (tokenType == JsonToken.BEGIN_OBJECT) {
+            state = JsonState.EndObjectBeginObject_END;
+        } else if (tokenType == JsonToken.END_DOCUMENT) {
+            removeStackObj();
+            state = JsonState.EndObjectEndDocument;
+        }
+    }
+
+    private void readEndArray() throws IOException {
+        endArray();
+        tokenType = jsonReader.peek();
+        if (tokenType == JsonToken.END_OBJECT) {
+            state = JsonState.EndArrayEndObject;
+        } else if (tokenType == JsonToken.NAME) {
+            state = JsonState.EndArrayName;
+        }
+    }
+
+    private void nextName() throws IOException, XMLStreamException {
+        String name = jsonReader.nextName();
+        if (!miniStack.empty()) {
+            JsonObject jsonObj = miniStack.peek();
+            if (jsonObj.getName().equals(name)) {
+                namespace = jsonObj.getNamespaceUri();
+                stackObj.push(miniStack.pop());
+            } else {
+                throw new XMLStreamException(JsonConstant.IN_JSON_MESSAGE_NOT_VALID + "required : " + jsonObj.getName() + " but get : " + name);
+            }
+        } else if (!queue.isEmpty()) {
+            JsonObject jsonObj = queue.peek();
+            if (jsonObj.getName().equals(name)) {
+                namespace = jsonObj.getNamespaceUri();
+                stackObj.push(queue.poll());
+            } else {
+                throw new XMLStreamException(JsonConstant.IN_JSON_MESSAGE_NOT_VALID + "required : " + jsonObj.getName() + " but get : " + name);
+            }
+        } else {
+            throw new XMLStreamException(JsonConstant.IN_JSON_MESSAGE_NOT_VALID);
+        }
+
+        localName = stackObj.peek().getName();
+        value = null;
+    }
+
+    private String nextValue() {
+        try {
+            tokenType = jsonReader.peek();
+
+            if (tokenType == JsonToken.STRING) {
+                value = jsonReader.nextString();
+            } else if (tokenType == JsonToken.BOOLEAN) {
+                value = String.valueOf(jsonReader.nextBoolean());
+            } else if (tokenType == JsonToken.NUMBER) {
+                JsonObject peek = stackObj.peek();
+                String valueType = peek.getValueType();
+                if (valueType.equals("int")) {
+                    value = String.valueOf(jsonReader.nextInt());
+                } else if (valueType.equals("long")) {
+                    value = String.valueOf(jsonReader.nextLong());
+                } else if (valueType.equals("double")) {
+                    value = String.valueOf(jsonReader.nextDouble());
+                } else if (valueType.equals("float")) {
+                    value = String.valueOf(jsonReader.nextDouble());
+                }
+            } else if (tokenType == JsonToken.NULL) {
+                value = null;
+            } else {
+                log.error("Couldn't read the value, Illegal state exception");
+                throw new RuntimeException("Couldn't read the value, Illegal state exception");
+            }
+        } catch (IOException e) {
+            log.error("IO error while reading json stream");
+            throw new RuntimeException("IO error while reading json stream");
+        }
+        return value;
+    }
+
+    private void beginObject() throws IOException {
+        jsonReader.beginObject();
+    }
+
+    private void beginArray() throws IOException {
+        jsonReader.beginArray();
+        if (stackObj.peek().getType() == JSONType.NESTED_ARRAY) {
+            if (topNestedArrayObj == null) {
+                topNestedArrayObj = stackObj.peek();
+            }
+            processedJsonObject.push(stackObj.peek());
+        }
+    }
+
+    private void endObject() throws IOException {
+        jsonReader.endObject();
+    }
+
+    private void endArray() throws IOException {
+        jsonReader.endArray();
+        if (stackObj.peek().equals(topNestedArrayObj)) {
+            topNestedArrayObj = null;
+        }
+    }
+
+    public enum JsonState {
+        StartState,
+        NameValue,
+        NameName,
+        ValueValue_END,
+        ValueValue_START,
+        ValueValue_CHAR,
+        ValueEndArray,
+        ValueEndObject_END_1,
+        ValueEndObject_END_2,
+        ValueName_END,
+        ValueName_START,
+        EndObjectEndObject,
+        EndObjectName,
+        EndArrayName,
+        EndArrayEndObject,
+        EndObjectBeginObject_END,
+        EndObjectBeginObject_START,
+        EndObjectEndDocument,
+    }
+}
Index: modules/json/src/org/apache/axis2/json/impl/JSONMessageHandler.java
===================================================================
--- modules/json/src/org/apache/axis2/json/impl/JSONMessageHandler.java	(revision 0)
+++ modules/json/src/org/apache/axis2/json/impl/JSONMessageHandler.java	(revision 0)
@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.json.impl;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.impl.builder.StAXOMBuilder;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.engine.MessageReceiver;
+import org.apache.axis2.handlers.AbstractHandler;
+import org.apache.axis2.json.impl.rpc.JsonRpcMessageReceiver;
+import org.apache.axis2.json.impl.utils.JsonConstant;
+import org.apache.axis2.wsdl.WSDLConstants;
+import org.apache.ws.commons.schema.XmlSchema;
+
+import javax.xml.namespace.QName;
+import java.util.List;
+
+
+public class JSONMessageHandler extends AbstractHandler {
+    /**
+     * This method will be called on each registered handler when a message
+     * needs to be processed.  If the message processing is paused by the
+     * handler, then this method will be called again for the handler that
+     * paused the processing once it is resumed.
+     * <p/>
+     * This method may be called concurrently from multiple threads.
+     * <p/>
+     * Handlers that want to determine the type of message that is to be
+     * processed (e.g. response vs request, inbound vs. outbound, etc.) can
+     * retrieve that information from the MessageContext via
+     * MessageContext.getFLOW() and
+     * MessageContext.getAxisOperation().getMessageExchangePattern() APIs.
+     *
+     * @param msgContext the <code>MessageContext</code> to process with this
+     *                   <code>Handler</code>.
+     * @return An InvocationResponse that indicates what
+     *         the next step in the message processing should be.
+     * @throws org.apache.axis2.AxisFault if the handler encounters an error
+     */
+    @Override
+    public InvocationResponse invoke(MessageContext msgContext) throws AxisFault {
+        MessageReceiver messageReceiver = msgContext.getAxisOperation().getMessageReceiver();
+        if (messageReceiver instanceof JsonRpcMessageReceiver) {
+            // do not need to parse XMLSchema list, as  this message receiver will not use GsonXMLStreamReader  to read the inputStream.
+        } else {
+            Object tempObj = msgContext.getProperty(JsonConstant.IS_JSON_STREAM);
+            if (tempObj != null) {
+                boolean isJSON = Boolean.valueOf(tempObj.toString());
+                Object o = msgContext.getProperty(JsonConstant.GSON_XML_STREAM_READER);
+                if (o != null) {
+                    GsonXMLStreamReader gsonXMLStreamReader = (GsonXMLStreamReader) o;
+                    QName elementQname = msgContext.getAxisOperation().getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE).getElementQName();
+                    List<XmlSchema> schemas = msgContext.getAxisService().getSchema();
+                    gsonXMLStreamReader.initXmlStreamReader(elementQname, schemas, msgContext.getConfigurationContext());
+                    StAXOMBuilder stAXOMBuilder = new StAXOMBuilder(gsonXMLStreamReader);
+                    OMElement omElement = stAXOMBuilder.getDocumentElement();
+                    msgContext.getEnvelope().getBody().addChild(omElement);
+                } else {
+                    throw new AxisFault("GsonXMLStreamReader should not be null");
+                }
+            } else {
+                // request is not a JSON request so don't need to initialize GsonXMLStreamReader
+            }
+        }
+        return InvocationResponse.CONTINUE;
+    }
+}
Index: modules/json/src/org/apache/axis2/json/impl/JsonFormatter.java
===================================================================
--- modules/json/src/org/apache/axis2/json/impl/JsonFormatter.java	(revision 1375161)
+++ modules/json/src/org/apache/axis2/json/impl/JsonFormatter.java	(working copy)
@@ -21,21 +21,28 @@
 
 import com.google.gson.Gson;
 import com.google.gson.stream.JsonWriter;
+import org.apache.axiom.om.OMElement;
 import org.apache.axiom.om.OMOutputFormat;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.json.impl.utils.JsonConstant;
 import org.apache.axis2.transport.MessageFormatter;
+import org.apache.axis2.wsdl.WSDLConstants;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.ws.commons.schema.XmlSchema;
 
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Type;
 import java.net.URL;
+import java.util.ArrayList;
+import java.util.Iterator;
 
 
 public class JsonFormatter implements MessageFormatter {
@@ -46,28 +53,76 @@
     }
 
     public void writeTo(MessageContext outMsgCtxt, OMOutputFormat omOutputFormat, OutputStream outputStream, boolean b) throws AxisFault {
-        JsonWriter writer = null;
+        String charSetEncoding = (String) outMsgCtxt.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
+        JsonWriter jsonWriter = null;
         String msg;
 
         try {
-            String charSetEncoding = (String) outMsgCtxt.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
-            writer = new JsonWriter(new OutputStreamWriter(outputStream, charSetEncoding ));
-            Gson gson = new Gson();
+            jsonWriter = new JsonWriter(new OutputStreamWriter(outputStream, charSetEncoding));
             Object retObj = outMsgCtxt.getProperty(JsonConstant.RETURN_OBJECT);
-            writer.beginObject();
-            writer.name(JsonConstant.RESPONSE);
-            Type returnType = (Type) outMsgCtxt.getProperty(JsonConstant.RETURN_TYPE);
 
-            gson.toJson(retObj, returnType, writer);
-            writer.endObject();
-            writer.flush();
+            if (outMsgCtxt.isProcessingFault()) {
+                OMElement element = outMsgCtxt.getEnvelope().getBody().getFirstElement();
+                try {
+                    jsonWriter.beginObject();
+                    jsonWriter.name(element.getLocalName());
+                    jsonWriter.beginObject();
+                    Iterator childrenIterator = element.getChildElements();
+                    while (childrenIterator.hasNext()) {
+                        Object next = childrenIterator.next();
+                        OMElement omElement = (OMElement) next;
+                        jsonWriter.name(omElement.getLocalName());
+                        jsonWriter.value(omElement.getText());
+                    }
+                    jsonWriter.endObject();
+                    jsonWriter.endObject();
+                    jsonWriter.flush();
+                    jsonWriter.close();
+                } catch (IOException e) {
+                    throw new AxisFault("Error while processing fault code in JsonWriter");
+                }
+
+            } else if (retObj == null) {
+                OMElement element = outMsgCtxt.getEnvelope().getBody().getFirstElement();
+                QName elementQname = outMsgCtxt.getAxisOperation().getMessage
+                        (WSDLConstants.MESSAGE_LABEL_OUT_VALUE).getElementQName();
+
+                ArrayList<XmlSchema> schemas = outMsgCtxt.getAxisService().getSchema();
+                GsonXMLStreamWriter xmlsw = new GsonXMLStreamWriter(jsonWriter,
+                                                                    elementQname,
+                                                                    schemas,
+                                                                    outMsgCtxt.getConfigurationContext());
+                try {
+                    xmlsw.writeStartDocument();
+                    if (b) {
+                        element.serialize(xmlsw);
+                    } else {
+                        element.serializeAndConsume(xmlsw);
+                    }
+                    xmlsw.writeEndDocument();
+                } catch (XMLStreamException e) {
+                    throw new AxisFault("Error while writing to the output stream using JsonWriter");
+                }
+
+            } else {
+                try {
+                    Gson gson = new Gson();
+                    jsonWriter.beginObject();
+                    jsonWriter.name(JsonConstant.RESPONSE);
+                    Type returnType = (Type) outMsgCtxt.getProperty(JsonConstant.RETURN_TYPE);
+                    gson.toJson(retObj, returnType, jsonWriter);
+                    jsonWriter.endObject();
+                    jsonWriter.flush();
+
+                } catch (IOException e) {
+                    msg = "Exception occur while writting to JsonWriter at the JsonFormatter ";
+                    log.error(msg, e);
+                    throw AxisFault.makeFault(e);
+                }
+            }
         } catch (UnsupportedEncodingException e) {
             msg = "Exception occur when try to encode output stream usig  " +
                     Constants.Configuration.CHARACTER_SET_ENCODING + " charset";
-            log.error(msg , e);
-            throw AxisFault.makeFault(e);
-        } catch (IOException e) {
-            msg = "Exception occur while writting to JsonWriter at the JsonFormatter ";
             log.error(msg, e);
             throw AxisFault.makeFault(e);
         }
@@ -75,8 +130,7 @@
 
     public String getContentType(MessageContext outMsgCtxt, OMOutputFormat omOutputFormat, String s) {
         String contentType = (String)outMsgCtxt.getProperty(Constants.Configuration.CONTENT_TYPE);
-        outMsgCtxt.setProperty(Constants.Configuration.CONTENT_TYPE , "application/json-impl");
-        return "application/json-impl";
+        return contentType;
     }
 
     public URL getTargetAddress(MessageContext messageContext, OMOutputFormat omOutputFormat, URL url) throws AxisFault {
Index: modules/json/test-resources/custom_schema/testSchema_1.xsd
===================================================================
--- modules/json/test-resources/custom_schema/testSchema_1.xsd	(revision 0)
+++ modules/json/test-resources/custom_schema/testSchema_1.xsd	(revision 0)
@@ -0,0 +1,44 @@
+<?xml version="1.0"?>
+
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one
+  ~ or more contributor license agreements. See the NOTICE file
+  ~ distributed with this work for additional information
+  ~ regarding copyright ownership. The ASF licenses this file
+  ~ to you under the Apache License, Version 2.0 (the
+  ~ "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing,
+  ~ software distributed under the License is distributed on an
+  ~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  ~ KIND, either express or implied. See the License for the
+  ~ specific language governing permissions and limitations
+  ~ under the License.
+  -->
+
+
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
+targetNamespace="http://www.w3schools.com"
+xmlns="http://www.w3schools.com"
+elementFormDefault="qualified">
+
+    <xs:element name="response">
+        <xs:complexType>
+            <xs:sequence>
+                <xs:element name="return" type="Person"/>
+            </xs:sequence>
+        </xs:complexType>
+    </xs:element>
+
+    <xs:complexType name="Person">
+        <xs:sequence>
+            <xs:element name="name" type="xs:string"/>
+            <xs:element name="age" type="xs:string"/>
+            <xs:element name="gender" type="xs:string"/>
+        </xs:sequence>
+    </xs:complexType>
+
+</xs:schema>
\ No newline at end of file
