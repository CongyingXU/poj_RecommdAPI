Index: test/org/apache/axis2/saaj2/SOAPBodyTest.java
===================================================================
--- test/org/apache/axis2/saaj2/SOAPBodyTest.java	(revision 0)
+++ test/org/apache/axis2/saaj2/SOAPBodyTest.java	(revision 0)
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.saaj2;
+
+import junit.framework.TestCase;
+
+import javax.xml.soap.MessageFactory;
+import javax.xml.soap.Name;
+import javax.xml.soap.SOAPBody;
+import javax.xml.soap.SOAPElement;
+import javax.xml.soap.SOAPHeader;
+import javax.xml.soap.SOAPMessage;
+import javax.xml.soap.SOAPPart;
+import java.util.Iterator;
+
+import org.apache.axis2.saaj2.SOAPEnvelopeImpl;
+
+public class SOAPBodyTest extends TestCase {
+
+    /**
+     * Method suite
+     *                                                         
+     * @return
+     */
+    /*  public static Test suite() {
+          return new TestSuite(test.message.TestSOAPBody.class);
+      }
+    */
+
+    /**
+     * Constructor TestSOAPBody
+     *
+     * @param name
+     */
+    public SOAPBodyTest(String name) {
+        super(name);
+    }
+
+    /**
+     * Method testSoapBodyBUG
+     *
+     * @throws Exception
+     */
+    public void testSoapBody() throws Exception {
+
+        MessageFactory fact = MessageFactory.newInstance();
+        SOAPMessage message = fact.createMessage();
+        SOAPPart soapPart = message.getSOAPPart();
+        SOAPEnvelopeImpl env = (SOAPEnvelopeImpl) soapPart.getEnvelope();
+        SOAPHeader header = env.getHeader();
+        Name hns = env.createName("Hello",
+                                  "shw",
+                                  "http://www.jcommerce.net/soap/ns/SOAPHelloWorld");
+        SOAPElement headElmnt = header.addHeaderElement(hns);
+        Name hns1 = env.createName("Myname",
+                                   "shw",
+                                   "http://www.jcommerce.net/soap/ns/SOAPHelloWorld");
+        SOAPElement myName = headElmnt.addChildElement(hns1);
+        myName.addTextNode("Tony");
+        Name ns = env.createName("Address",
+                                 "shw",
+                                 "http://www.jcommerce.net/soap/ns/SOAPHelloWorld");
+        SOAPBody body = env.getBody();
+        SOAPElement bodyElmnt = body.addBodyElement(ns);
+        Name ns1 = env.createName("City",
+                                  "shw",
+                                  "http://www.jcommerce.net/soap/ns/SOAPHelloWorld");
+        SOAPElement city = bodyElmnt.addChildElement(ns1);
+        city.addTextNode("GENT");
+
+        SOAPElement city2 = body.addBodyElement(ns1);
+        city2.addTextNode("CIT2");
+
+        Iterator it = body.getChildElements();
+        int count = 0;
+
+        while (it.hasNext()) {
+            SOAPElement el = (SOAPElement) it.next();
+            count++;
+//            Name name = el.getElementName();
+        }
+        assertEquals(2,count);
+    }
+
+}
Index: test/org/apache/axis2/saaj2/SOAPFaultDetailTest.java
===================================================================
--- test/org/apache/axis2/saaj2/SOAPFaultDetailTest.java	(revision 0)
+++ test/org/apache/axis2/saaj2/SOAPFaultDetailTest.java	(revision 0)
@@ -0,0 +1,71 @@
+package org.apache.axis2.saaj2;
+
+import junit.framework.TestCase;
+
+import javax.xml.soap.DetailEntry;
+import javax.xml.soap.MessageFactory;
+import javax.xml.soap.MimeHeaders;
+import javax.xml.soap.SOAPBody;
+import javax.xml.soap.SOAPFault;
+import javax.xml.soap.SOAPMessage;
+import java.io.ByteArrayInputStream;
+import java.util.Iterator;
+
+public class SOAPFaultDetailTest extends TestCase {
+	
+	public SOAPFaultDetailTest(String name){
+		super(name);
+	}
+	
+    String xmlString =
+    	"<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
+    	"<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">" +
+    	" <soapenv:Body>" +
+    	"  <soapenv:Fault>" +
+    	"   <faultcode>soapenv:Server.generalException</faultcode>" +
+    	"   <faultstring></faultstring>" +
+    	"   <detail>" +
+    	"    <tickerSymbol xsi:type=\"xsd:string\">MACR</tickerSymbol>" +
+    	"   <ns1:exceptionName xmlns:ns1=\"http://xml.apache.org/axis/\">test.wsdl.faults.InvalidTickerFaultMessage</ns1:exceptionName>" +
+    	"   </detail>" +
+    	"  </soapenv:Fault>" +
+    	" </soapenv:Body>" +
+    	"</soapenv:Envelope>";
+    
+    public void testDetails() throws Exception{
+    	MessageFactory mf = MessageFactory.newInstance();
+    	SOAPMessage smsg = 
+    		mf.createMessage(new MimeHeaders(), new ByteArrayInputStream(xmlString.getBytes()));
+    	SOAPBody body = smsg.getSOAPBody();
+    	//smsg.writeTo(System.out);
+    	SOAPFault flt = body.getFault();
+    	flt.addDetail();
+    	javax.xml.soap.Detail d = flt.getDetail();
+    	Iterator i = d.getDetailEntries();
+    	while (i.hasNext()){
+    		DetailEntry entry = (DetailEntry) i.next();
+    		String name = entry.getElementName().getLocalName();
+    		if ("tickerSymbol".equals(name)) {
+    			assertEquals("the value of the tickerSymbol element didn't match",
+    					"MACR", entry.getValue());
+    		} else if ("exceptionName".equals(name)) {
+    			assertEquals("the value of the exceptionName element didn't match",
+    					"test.wsdl.faults.InvalidTickerFaultMessage", entry.getValue());
+    		} else {
+    			assertTrue("Expecting details element name of 'tickerSymbol' or 'expceptionName' - I found :" + name, false);
+    		}
+    	}
+    	assertTrue(d != null);
+    }
+    
+    /**
+     * Main
+     */
+    public static void main(String[] args)
+            throws Exception
+    {
+        SOAPFaultDetailTest detailTest = new SOAPFaultDetailTest("faultdetails");
+        detailTest.testDetails();
+    }
+
+}
Index: test/org/apache/axis2/saaj2/SOAPFaultsTest.java
===================================================================
--- test/org/apache/axis2/saaj2/SOAPFaultsTest.java	(revision 0)
+++ test/org/apache/axis2/saaj2/SOAPFaultsTest.java	(revision 0)
@@ -0,0 +1,152 @@
+package org.apache.axis2.saaj2;
+
+import junit.framework.TestCase;
+
+import javax.xml.soap.*;
+import java.io.ByteArrayOutputStream;
+
+public class SOAPFaultsTest extends TestCase {
+	
+	public SOAPFaultsTest(String name){
+		super(name);
+	}
+	
+	//Create SOAPFault with additional detail elements
+	public void testAdditionDetail() throws Exception{
+        String xml ="<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:cwmp=\"http://cwmp.com\">\n" +
+        " <soapenv:Header>\n" +
+        "  <cwmp:ID soapenv:mustUnderstand=\"1\">HEADERID-7867678</cwmp:ID>\n" +
+        " </soapenv:Header>\n" +
+        " <soapenv:Body>\n" +
+        "  <soapenv:Fault>\n" +
+        "   <faultcode>soapenv:Client</faultcode>\n" +
+        "   <faultstring>CWMP fault</faultstring>\n" +
+        "   <detail>\n" +
+        "    <cwmp:Fault>\n" +
+        "     <cwmp:FaultCode>This is the fault code</cwmp:FaultCode>\n" +
+        "     <cwmp:FaultString>Fault Message</cwmp:FaultString>\n" +
+        "    </cwmp:Fault>\n" +
+        "   </detail>\n" +
+        "  </soapenv:Fault>\n" +
+        " </soapenv:Body>\n" +
+        "</soapenv:Envelope>";
+        
+        MessageFactory fac = MessageFactory.newInstance();
+        SOAPMessage faultMessage = fac.createMessage();
+        
+        //Create the response to the message
+        faultMessage = fac.createMessage();
+        SOAPPart part = faultMessage.getSOAPPart();
+        SOAPEnvelope envelope = part.getEnvelope();
+        envelope.addNamespaceDeclaration("cwmp", "http://cwmp.com");
+        SOAPBody body = envelope.getBody();
+        SOAPHeader header = envelope.getHeader();
+        Name idName = envelope.createName("ID", "cwmp", "http://cwmp.com");
+        SOAPHeaderElement id = header.addHeaderElement(idName);
+        id.setMustUnderstand(true);
+        id.addTextNode("HEADERID-7867678");
+        
+        //Create the SOAPFault object
+        SOAPFault fault = body.addFault();
+        fault.setFaultCode("Client");
+        fault.setFaultString("CWMP fault");
+        
+        //Add Fault Detail information
+        Detail faultDetail = fault.addDetail();
+        Name cwmpFaultName = envelope.createName("Fault", "cwmp",
+        		"http://cwmp.com");
+        DetailEntry cwmpFaultDetail =
+        	faultDetail.addDetailEntry(cwmpFaultName);
+        SOAPElement e = cwmpFaultDetail.addChildElement("FaultCode");
+        
+        e.addTextNode("This is the fault code");
+        SOAPElement e2 = cwmpFaultDetail.addChildElement(envelope.createName("FaultString", "cwmp", "http://cwmp.com"));
+        e2.addTextNode("Fault Message");
+        faultMessage.saveChanges();
+        
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        faultMessage.writeTo(baos);
+        String xml2 = new String(baos.toByteArray());
+        faultMessage.writeTo(System.out);
+        //assertXMLEqual(xml,xml2);	
+	}
+	
+	public void testQuick() throws Exception {
+		MessageFactory msgfactory = MessageFactory.newInstance();
+		SOAPFactory factory = SOAPFactory.newInstance();
+		SOAPMessage outputmsg = msgfactory.createMessage();
+		String valueCode = "faultcode";
+		String valueString = "faultString";
+		SOAPFault fault = outputmsg.getSOAPPart().getEnvelope().getBody().addFault();
+		fault.setFaultCode(valueCode);
+		fault.setFaultString(valueString);
+		Detail d;
+		d = fault.addDetail();
+		d.addDetailEntry(factory.createName("Hello"));
+		ByteArrayOutputStream baos = new ByteArrayOutputStream();
+		if (outputmsg != null) {
+			if (outputmsg.saveRequired()) {
+				outputmsg.saveChanges();
+			}
+			outputmsg.writeTo(baos);
+		}
+		String xml = new String(baos.toByteArray());
+		assertTrue(xml.indexOf("Hello")!=-1);
+	}
+	
+	public void testSOAPFaultSaveChanges() throws Exception {
+		MessageFactory msgFactory =
+			MessageFactory.newInstance();
+		SOAPMessage msg = msgFactory.createMessage();
+		SOAPEnvelope envelope =
+			msg.getSOAPPart().getEnvelope();
+		SOAPBody body = envelope.getBody();
+		SOAPFault fault = body.addFault();
+		
+		fault.setFaultCode("Client");
+		fault.setFaultString(
+			"Message does not have necessary info");
+		fault.setFaultActor("http://gizmos.com/order");
+		
+		Detail detail = fault.addDetail();
+		
+		Name entryName = envelope.createName("order", "PO",
+			"http://gizmos.com/orders/");
+		DetailEntry entry = detail.addDetailEntry(entryName);
+		entry.addTextNode("quantity element does not have a value");
+		
+		Name entryName2 = envelope.createName("confirmation",
+				"PO", "http://gizmos.com/confirm");
+		DetailEntry entry2 = detail.addDetailEntry(entryName2);
+		entry2.addTextNode("Incomplete address: no zip code");
+		
+		msg.saveChanges();
+		
+        // Now retrieve the SOAPFault object and its contents
+        //after checking to see that there is one
+
+        if (body.hasFault()) {
+            fault = body.getFault();
+            String code = fault.getFaultCode();
+            String string = fault.getFaultString();
+            String actor = fault.getFaultActor();
+
+
+            detail = fault.getDetail();
+            if (detail != null) {
+                java.util.Iterator it = detail.getDetailEntries();
+                while (it.hasNext()) {
+                    entry = (DetailEntry) it.next();
+                    String value = entry.getValue();
+                }
+            }
+        }
+	}
+	
+    public static void main(String[] args) throws Exception {
+        SOAPFaultsTest detailTest = new SOAPFaultsTest("TestSOAPFaults");
+        detailTest.testQuick();
+        detailTest.testAdditionDetail();
+        detailTest.testSOAPFaultSaveChanges();
+    }
+}
Index: test/org/apache/axis2/saaj2/TextTest.java
===================================================================
--- test/org/apache/axis2/saaj2/TextTest.java	(revision 0)
+++ test/org/apache/axis2/saaj2/TextTest.java	(revision 0)
@@ -0,0 +1,170 @@
+package org.apache.axis2.saaj2;
+
+import junit.framework.TestCase;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+import javax.xml.soap.MessageFactory;
+import javax.xml.soap.MimeHeaders;
+import javax.xml.soap.Name;
+import javax.xml.soap.SOAPBody;
+import javax.xml.soap.SOAPBodyElement;
+import javax.xml.soap.SOAPElement;
+import javax.xml.soap.SOAPException;
+import javax.xml.soap.SOAPFactory;
+import javax.xml.soap.SOAPMessage;
+import javax.xml.soap.Text;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
+public class TextTest extends TestCase {
+
+    public TextTest(String name) {
+        super(name);
+    }
+
+    //Test SAAJ addTextNode performance
+    public void testAddTextNode() throws Exception {
+        SOAPFactory soapFactory = SOAPFactory.newInstance();
+        MessageFactory factory = MessageFactory.newInstance();
+        SOAPMessage message = factory.createMessage();
+        SOAPBody body = message.getSOAPBody();
+
+        // Create the base element
+        Name bodyName = soapFactory.createName("VBGenReceiver", "xsi",
+                                               "http://www.w3.org/2001/XMLSchema-instance");
+        SOAPBodyElement bodyElement = body.addBodyElement(bodyName);
+
+        // Create the MetaData Tag
+        Name name = soapFactory.createName("MetaData");
+        SOAPElement metaData = bodyElement.addChildElement(name);
+
+        //Create the SKey Tag
+        name = soapFactory.createName("SKey");
+        SOAPElement sKey = metaData.addChildElement(name);
+        sKey.addTextNode("SKEY001");
+
+        //Create Object Tag
+        name = soapFactory.createName("Object");
+        SOAPElement object = bodyElement.addChildElement(name);
+
+        //Create Book ID Tag
+        name = soapFactory.createName("BookID");
+        SOAPElement bookID = object.addChildElement(name);
+        bookID.addTextNode("BookID002");
+
+        //Create OrderID tag
+        name = soapFactory.createName("OrderID");
+        SOAPElement orderID = object.addChildElement(name);
+        orderID.addTextNode("OrderID003");
+
+        //create PurchaseID tage
+        name = soapFactory.createName("PurchaseID");
+        SOAPElement purchaseID = object.addChildElement(name);
+        purchaseID.addTextNode("PurchaseID005");
+
+        //create LanguageID Tag
+        name = soapFactory.createName("LanguageID");
+        SOAPElement languageID = object.addChildElement(name);
+        languageID.addTextNode("LanguageID004");
+
+        //create LanguageID Tag
+        name = soapFactory.createName("LanguageName");
+        SOAPElement languageName = object.addChildElement(name);
+        languageName.addTextNode("LanguageName006");
+
+        //create LanguageID Tag
+        name = soapFactory.createName("Title");
+        SOAPElement title = object.addChildElement(name);
+        title.addTextNode("Title007");
+
+        //create LanguageID Tag
+        name = soapFactory.createName("Author");
+        SOAPElement author = object.addChildElement(name);
+        author.addTextNode("Author008");
+
+        //create LanguageID Tag
+        name = soapFactory.createName("Format");
+        SOAPElement format = bodyElement.addChildElement(name);
+
+        //create LanguageID Tag
+        name = soapFactory.createName("Type");
+        SOAPElement formatType = format.addChildElement(name);
+        formatType.addTextNode("Type009");
+
+        //create LanguageID Tag
+        name = soapFactory.createName("Delivery");
+        SOAPElement delivery = bodyElement.addChildElement(name);
+
+        //create LanguageID Tag
+        name = soapFactory.createName("Name");
+        SOAPElement delName = delivery.addChildElement(name);
+        delName.addTextNode("Name010");
+
+        //create LanguageID Tag
+        name = soapFactory.createName("Address1");
+        SOAPElement address1 = delivery.addChildElement(name);
+        address1.addTextNode("Address1011");
+
+        //create LanguageID Tag
+        name = soapFactory.createName("Address2");
+        SOAPElement address2 = delivery.addChildElement(name);
+        address2.addTextNode("Address2012");
+
+        //create LanguageID Tag
+        name = soapFactory.createName("City");
+        SOAPElement city = delivery.addChildElement(name);
+        city.addTextNode("City013");
+
+        //create LanguageID Tag
+        name = soapFactory.createName("State");
+        SOAPElement state = delivery.addChildElement(name);
+        state.addTextNode("State014");
+
+        //create LanguageID Tag
+        name = soapFactory.createName("PostalCode");
+        SOAPElement postalCode = delivery.addChildElement(name);
+        postalCode.addTextNode("PostalCode015");
+
+        System.out.println("The message is:\n");
+        message.writeTo(System.out);
+        System.out.flush();
+    }
+
+    public void testComment() throws SOAPException, IOException {
+
+        String xmlString = "<?xml version='1.0' encoding='utf-8'?> " +
+                           "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">" +
+                           "<soapenv:Header></soapenv:Header>" +
+                           "<soapenv:Body>" +
+                           "<Node:abc xmlns:Node=\"http://www.simpletest.org\">" +
+                           "This is some text" +
+                           "<!--This is comment-->This is other text" +
+                           "<!--This is another comment-->This is some other text" +
+                           "</Node:abc>" +
+                           "</soapenv:Body>" +
+                           "</soapenv:Envelope>";
+
+        MessageFactory mf = MessageFactory.newInstance();
+        SOAPMessage message =
+                mf.createMessage(new MimeHeaders(), new ByteArrayInputStream(xmlString.getBytes()));
+
+        SOAPBody body = message.getSOAPBody();
+        Node bodyElement = body.getFirstChild();
+        NodeList textNodes = bodyElement.getChildNodes();
+
+        assertEquals(5, textNodes.getLength());
+
+        for (int i = 0; i < textNodes.getLength(); i++) {
+            Node nde = textNodes.item(i);
+            boolean isComment;
+            if (nde instanceof Text) {
+                isComment = ((Text) nde).isComment();
+                if (i == 1)
+                    assertEquals(true, isComment);
+                else
+                    assertEquals(false, isComment);
+            }
+        }
+    }
+}
Index: test/org/apache/axis2/saaj2/PrefixesTest.java
===================================================================
--- test/org/apache/axis2/saaj2/PrefixesTest.java	(revision 0)
+++ test/org/apache/axis2/saaj2/PrefixesTest.java	(revision 0)
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.saaj2;
+
+import junit.framework.TestCase;
+
+public class PrefixesTest extends TestCase {
+
+    public PrefixesTest(String name) {
+        super(name);
+    }
+
+    public void testOK() {
+
+    }
+
+    //TODO: Fix this
+    /*public void testAddingPrefixesForChildElements() throws Exception {
+        MessageFactory factory = MessageFactory.newInstance();
+        SOAPMessage msg = factory.createMessage();
+        SOAPPart sp = msg.getSOAPPart();
+        SOAPEnvelope se = sp.getEnvelope();
+        SOAPBody sb = se.getBody();
+        SOAPElement el1 = sb.addBodyElement(
+                se.createName
+                ("element1", "prefix1", "http://www.sun.com"));
+        SOAPElement el2 = el1.addChildElement(
+                se.createName
+                ("element2", "prefix2", "http://www.apache.org"));
+
+        org.apache.axis2.soap.SOAPEnvelope omEnv = ((SOAPEnvelopeImpl) se).getOMEnvelope();
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        msg.writeTo(baos);
+
+        String xml = new String(baos.toByteArray());
+        assertTrue(xml.indexOf("prefix1") != -1);
+        assertTrue(xml.indexOf("prefix2") != -1);
+        assertTrue(xml.indexOf("http://www.sun.com") != -1);
+        assertTrue(xml.indexOf("http://www.apache.org") != -1);
+    }*/
+
+    /* public void testAttribute() throws Exception {
+        String soappacket = "<SOAP-ENV:Envelope xmlns:SOAP-ENV =\"http://schemas.xmlsoap.org/soap/envelope/\"" +
+                            "xmlns:xsi =\"http://www.w3.org/1999/XMLSchema-instance\"" +
+                            "xmlns:xsd =\"http://www.w3.org/1999/XMLSchema\">" +
+                            "<SOAP-ENV:Body>" +
+                            "<helloworld name=\"tester\" />" +
+                            "</SOAP-ENV:Body>" +
+                            "</SOAP-ENV:Envelope>";
+        SOAPMessage msg = MessageFactory.newInstance().createMessage(new MimeHeaders(), new ByteArrayInputStream(soappacket.getBytes()));
+        SOAPBody body = msg.getSOAPPart().getEnvelope().getBody();
+        msg.writeTo(System.out);
+
+        SOAPElement ele = (SOAPElement) body.getChildElements().next();
+        java.util.Iterator attit = ele.getAllAttributes();
+
+        System.out.println(attit.next().getClass());
+
+        javax.xml.soap.Name n = (javax.xml.soap.Name) attit.next();
+        //assertEquals("Test fail prefix problem",n.getQualifiedName(),"name");
+    }*/
+
+}
Index: test/org/apache/axis2/saaj2/AttachmentSerializationTest.java
===================================================================
--- test/org/apache/axis2/saaj2/AttachmentSerializationTest.java	(revision 0)
+++ test/org/apache/axis2/saaj2/AttachmentSerializationTest.java	(revision 0)
@@ -0,0 +1,119 @@
+package org.apache.axis2.saaj2;
+
+import junit.framework.TestCase;
+
+import javax.activation.DataHandler;
+import javax.activation.FileDataSource;
+import javax.xml.soap.*;
+import javax.xml.soap.MimeHeaders;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.FileInputStream;
+import java.util.Iterator;
+
+import org.w3c.dom.Document;
+import org.apache.axis2.om.impl.dom.DocumentImpl;
+
+public class AttachmentSerializationTest extends TestCase {
+
+    public AttachmentSerializationTest(String name) {
+        super(name);
+    }
+
+    public static void main(String args[]) throws Exception {
+        AttachmentSerializationTest tester = new AttachmentSerializationTest("tester");
+        tester.testAttachments();
+    }
+
+    public void testAttachments() throws Exception {
+        try {
+            ByteArrayOutputStream bais = new ByteArrayOutputStream();
+            int count = saveMsgWithAttachments(bais);
+            assertEquals(count, 2);
+        } catch (Exception e) {
+//            throw new Exception("Fault returned from test: " + e);
+            e.printStackTrace();
+            fail("Unexpected Exception : " + e);
+        }
+    }
+
+    public static final String MIME_MULTIPART_RELATED = "multipart/related";
+    public static final String MIME_APPLICATION_DIME = "application/dime";
+    public static final String NS_PREFIX = "jaxmtst";
+    public static final String NS_URI = "http://www.jcommerce.net/soap/jaxm/TestJaxm";
+
+    public int saveMsgWithAttachments(OutputStream os) throws Exception {
+        MessageFactory mf = MessageFactory.newInstance();
+        SOAPMessage msg = mf.createMessage();
+
+        SOAPPart soapPart = msg.getSOAPPart();
+        SOAPEnvelope envelope = soapPart.getEnvelope();
+        SOAPHeader header = envelope.getHeader();
+        SOAPBody body = envelope.getBody();
+
+        SOAPElement el = header.addHeaderElement(envelope.createName("field4", NS_PREFIX, NS_URI));
+
+        SOAPElement el2 = el.addChildElement("field4b", NS_PREFIX);
+        SOAPElement el3 = el2.addTextNode("field4value");
+
+        el = body.addBodyElement(envelope.createName("bodyfield3", NS_PREFIX, NS_URI));
+        el2 = el.addChildElement("bodyfield3a", NS_PREFIX);
+        el2.addTextNode("bodyvalue3a");
+        el2 = el.addChildElement("bodyfield3b", NS_PREFIX);
+        el2.addTextNode("bodyvalue3b");
+        el2 = el.addChildElement("datefield", NS_PREFIX);
+
+        // First Attachment
+        AttachmentPart ap = msg.createAttachmentPart();
+        final String testText = "some attachment text...";
+        ap.setContent(testText, "text/plain");
+        msg.addAttachmentPart(ap);
+
+        // Second attachment
+        String jpgfilename = "./test-resources/axis.jpg";
+        File myfile = new File(jpgfilename);
+        FileDataSource fds = new FileDataSource(myfile);
+        DataHandler dh = new DataHandler(fds);
+        AttachmentPart ap2 = msg.createAttachmentPart(dh);
+        ap2.setContentType("image/jpg");
+        msg.addAttachmentPart(ap2);
+
+        MimeHeaders headers = msg.getMimeHeaders();
+        assertTrue(headers != null);
+        String [] contentType = headers.getHeader("Content-Type");
+        assertTrue(contentType != null);
+
+        for (Iterator iter = msg.getAttachments(); iter.hasNext();) {
+            AttachmentPart attachmentPart =  (AttachmentPart) iter.next();
+            final Object content = attachmentPart.getDataHandler().getContent();
+            if(content instanceof String){
+                assertEquals(testText, (String) content);
+            } else if(content instanceof FileInputStream){
+                final FileInputStream fis = (FileInputStream) content;
+                /*File file = new File("output-file.jpg");
+                file.createNewFile();
+
+                fis.read(new byte[(int)file.length()])*/
+            }
+        }
+
+        msg.writeTo(os);
+        os.flush();
+        msg.writeTo(System.out);
+        return msg.countAttachments();
+    }
+
+    public int loadMsgWithAttachments(InputStream is) throws Exception {
+        MimeHeaders headers = new MimeHeaders();
+        headers.setHeader("Content-Type", MIME_MULTIPART_RELATED);
+        MessageFactory mf = MessageFactory.newInstance();
+        SOAPMessage msg = mf.createMessage(headers, is);
+        SOAPPart sp = msg.getSOAPPart();
+        SOAPEnvelope envelope = sp.getEnvelope();
+        assertTrue(sp != null);
+        assertTrue(envelope != null);
+        return msg.countAttachments();
+    }
+}
Index: test/org/apache/axis2/saaj2/JUnitTestAttachmentIntegration.java
===================================================================
--- test/org/apache/axis2/saaj2/JUnitTestAttachmentIntegration.java	(revision 0)
+++ test/org/apache/axis2/saaj2/JUnitTestAttachmentIntegration.java	(revision 0)
@@ -0,0 +1,85 @@
+package org.apache.axis2.saaj2;
+
+import junit.framework.TestCase;
+
+import javax.activation.DataHandler;
+import javax.activation.FileDataSource;
+import javax.xml.soap.*;
+import java.io.File;
+import java.util.Iterator;
+//import javax.activation.FileDataSource;
+
+public class JUnitTestAttachmentIntegration extends TestCase {
+	
+    public JUnitTestAttachmentIntegration(String name) {
+        super(name);
+    }
+    
+    public static void main(String args[]) throws Exception {
+    	JUnitTestAttachmentIntegration tester = new JUnitTestAttachmentIntegration("tester");
+        testSendReceive();
+    }
+
+	public static void testSendReceive() throws Exception{
+		MessageFactory mf = MessageFactory.newInstance();
+		SOAPMessage message = mf.createMessage();
+		
+		//create the SOAPPart
+		createSOAPPart(message);
+		
+		//Attach a text/plain object with the SOAP message
+		String sampleMessage = "Sample Message: Hello World!";
+		AttachmentPart textAttach = message.createAttachmentPart(sampleMessage,"text/plain");
+		textAttach.addMimeHeader("Content-Transfer-Encoding", "binary");
+		textAttach.setContentId("submitSampleText@apache.org");
+		message.addAttachmentPart(textAttach);
+		
+		//Attach a java.awt.Image object to the SOAP message
+        String jpgfilename = "./test-resources/axis.jpg";
+        File myfile = new File(jpgfilename);
+        FileDataSource fds = new FileDataSource(myfile);
+		DataHandler imageDH = new DataHandler(fds);
+		AttachmentPart jpegAttach = message.createAttachmentPart(imageDH);
+		jpegAttach.addMimeHeader("Content-Transfer-Encoding", "binary");
+		jpegAttach.setContentId("submitSampleImage@apache.org");
+		message.addAttachmentPart(jpegAttach);
+		
+		SOAPConnection sCon = SOAPConnectionFactory.newInstance().createConnection();
+		
+		SOAPMessage sMsg =  sCon.call(message,"http://localhost:8080/axis2/services/Echo");
+		int attachmentCount = sMsg.countAttachments();
+		assertTrue(attachmentCount == 2);
+
+		Iterator attachIter = sMsg.getAttachments();		
+		//Of the two attachments first should be of type text/plain and 
+		//second of content-type image/jpeg
+		
+		//Underlying MTOM is converting all contentTypes to application/octet-stream
+		//Thats something to be fixed, I guess. Till then commenting out
+		//these two asserts
+		/*
+		AttachmentPart ap1 = (AttachmentPart)attachIter.next();
+		assertTrue(ap1.getContentType().equals("text/plain"));
+		AttachmentPart ap2 = (AttachmentPart)attachIter.next();
+		assertTrue(ap2.getContentType().equals("image/jpeg"));
+		*/
+	}
+	
+	private static void createSOAPPart(SOAPMessage message) throws SOAPException {
+		SOAPPart sPart = message.getSOAPPart();
+		SOAPEnvelope env = sPart.getEnvelope();
+		SOAPBody body = env.getBody();
+		
+		Name ns = env.createName("echo","swa","http://fakeNamespace.org");
+		SOAPBodyElement sbe = body.addBodyElement(ns);
+		
+		Name ns2 = env.createName("text");
+		SOAPElement textReference = sbe.addChildElement(ns2);
+		Name hrefAttr = env.createName("href");
+		textReference.addAttribute(hrefAttr, "cid:submitSampleText@apache.org");
+		
+		Name ns3 = env.createName("image");
+		SOAPElement imageReference = sbe.addChildElement(ns3);
+		imageReference.addAttribute(hrefAttr, "cid:submitSampleImage@apache.org");
+	}
+}
Index: test/org/apache/axis2/saaj2/AttachmentTest.java
===================================================================
--- test/org/apache/axis2/saaj2/AttachmentTest.java	(revision 0)
+++ test/org/apache/axis2/saaj2/AttachmentTest.java	(revision 0)
@@ -0,0 +1,128 @@
+package org.apache.axis2.saaj2;
+
+import junit.framework.TestCase;
+
+import javax.activation.DataHandler;
+import javax.activation.DataSource;
+import javax.xml.soap.AttachmentPart;
+import javax.xml.soap.MessageFactory;
+import javax.xml.soap.SOAPConnection;
+import javax.xml.soap.SOAPConnectionFactory;
+import javax.xml.soap.SOAPMessage;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+public class AttachmentTest extends TestCase {
+
+    public AttachmentTest(String name) {
+        super(name);
+    }
+    
+    public void testStringAttachment() throws Exception {
+    	SOAPConnectionFactory scFactory = SOAPConnectionFactory.newInstance();
+    	SOAPConnection con = scFactory.createConnection();
+    	
+    	MessageFactory factory = MessageFactory.newInstance();
+    	SOAPMessage message = factory.createMessage();
+    	AttachmentPart attachment = message.createAttachmentPart();
+    	String stringContent = "Update address for Sunny Skies " +
+    			"Inc., to 10 Upbeat Street, Pleasant Grove, CA 95439";
+    	
+    	attachment.setContent(stringContent, "text/plain");
+    	attachment.setContentId("update_address");
+    	message.addAttachmentPart(attachment);
+    	
+    	assertTrue(message.countAttachments()==1);
+    	
+    	java.util.Iterator it = message.getAttachments();
+    	while (it.hasNext()) {
+    		attachment = (AttachmentPart) it.next();
+    		Object content = attachment.getContent();
+    		String id = attachment.getContentId();
+    		System.out.println("Attachment " + id + " contains: " + content);
+    		assertEquals(content,stringContent);
+    	}
+    	System.out.println("Here is what the XML message looks like:");
+    	message.writeTo(System.out);
+    	
+    	message.removeAllAttachments();
+    	assertTrue(message.countAttachments()==0);
+    }
+    
+    public void testMultipleAttachments() throws Exception {
+        SOAPConnectionFactory scFactory = SOAPConnectionFactory.newInstance();
+        SOAPConnection con = scFactory.createConnection();
+
+        MessageFactory factory = MessageFactory.newInstance();
+        SOAPMessage msg = factory.createMessage();
+        java.net.URL url1 = new java.net.URL("http://slashdot.org/slashdot.xml");
+        java.net.URL url2 = new java.net.URL("http://www.apache.org/LICENSE.txt");
+
+        AttachmentPart a1 = msg.createAttachmentPart(new javax.activation.DataHandler(url1));
+        a1.setContentType("text/xml");
+        msg.addAttachmentPart(a1);
+        AttachmentPart a2 = msg.createAttachmentPart(new javax.activation.DataHandler(url1));
+        a2.setContentType("text/xml");
+        msg.addAttachmentPart(a2);
+        AttachmentPart a3 = msg.createAttachmentPart(new javax.activation.DataHandler(url2));
+        a3.setContentType("text/plain");
+        msg.addAttachmentPart(a3);
+
+        assertTrue(msg.countAttachments()==3);
+
+        javax.xml.soap.MimeHeaders mimeHeaders = new javax.xml.soap.MimeHeaders();
+        mimeHeaders.addHeader("Content-Type", "text/xml");
+
+        int nAttachments = 0;
+        java.util.Iterator iterator = msg.getAttachments(mimeHeaders);
+	    while (iterator.hasNext()) {
+            nAttachments++;
+	        AttachmentPart ap = (AttachmentPart)iterator.next();
+	        assertTrue(ap.equals(a1) || ap.equals(a2));
+	    }
+        assertTrue(nAttachments==2);
+    }
+    
+    public void testBadAttSize() throws Exception {
+        MessageFactory factory = MessageFactory.newInstance();
+        SOAPMessage message = factory.createMessage();
+
+        ByteArrayInputStream ins=new ByteArrayInputStream(new byte[5]);
+        DataHandler dh=new DataHandler(new Src(ins,"text/plain"));
+        AttachmentPart part = message.createAttachmentPart(dh);
+        assertEquals("Size should match",5,part.getSize());
+    }
+
+    class Src implements DataSource{
+        InputStream m_src;
+        String m_type;
+
+        public Src(InputStream data, String type){
+            m_src=data;
+            m_type=type;
+        }
+        public String getContentType(){
+            return m_type;
+        }
+        public InputStream getInputStream() throws IOException{
+            m_src.reset();
+            return m_src;
+        }
+        public String getName(){
+            return "Some-Data";
+        }
+        public OutputStream getOutputStream(){
+            throw new UnsupportedOperationException("I don't give output streams");
+        }
+    }
+    
+    public static void main(String[] args) throws Exception {
+        AttachmentTest tester = new AttachmentTest("TestSAAJ");
+        tester.testMultipleAttachments();
+        tester.testStringAttachment();
+        tester.testBadAttSize();
+    }
+
+}
Index: test/org/apache/axis2/saaj2/HeadersTest.java
===================================================================
--- test/org/apache/axis2/saaj2/HeadersTest.java	(revision 0)
+++ test/org/apache/axis2/saaj2/HeadersTest.java	(revision 0)
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.saaj2;
+
+import junit.framework.TestCase;
+
+import javax.xml.soap.SOAPElement;
+import java.util.Iterator;
+
+public class HeadersTest extends TestCase {
+
+    private final String actor = "ACTOR#1";
+    private final String localName = "Local1";
+    private final String namespace = "http://ws.apache.org";
+    private final String prefix = "P1";
+
+    public HeadersTest(String name) {
+        super(name);
+    }
+
+    public void testAddingHeaderElements() throws Exception {
+        javax.xml.soap.SOAPMessage soapMessage =
+                javax.xml.soap.MessageFactory.newInstance().createMessage();
+        javax.xml.soap.SOAPEnvelope soapEnv =
+                soapMessage.getSOAPPart().getEnvelope();
+        javax.xml.soap.SOAPHeader header = soapEnv.getHeader();
+        header.addChildElement("ebxmlms");
+
+        /*ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      soapMessage.writeTo(baos);
+      String xml = new String(baos.toByteArray());
+      assertTrue(xml.indexOf("ebxmlms") != -1);*/
+
+        Iterator it = header.getChildElements();
+        boolean b = false;
+        while (it.hasNext()) {
+            SOAPElement el = (SOAPElement) it.next();
+            String lName = el.getNodeName();
+            if (lName.equalsIgnoreCase("ebxmlms")) {
+                b = true;
+                break;
+            }
+        }
+        assertTrue(b);
+    }
+
+}
Index: test/org/apache/axis2/saaj2/Readme.txt
===================================================================
--- test/org/apache/axis2/saaj2/Readme.txt	(revision 0)
+++ test/org/apache/axis2/saaj2/Readme.txt	(revision 0)
@@ -0,0 +1,16 @@
+The testcase JUnitTestAttachmentsIntegration.java is a round trip 
+integration test written to put to test the attachment support added 
+to SAAJ module. However this test can't be run as part of maven b'coz
+of following pre-requisites
+A web service to echo back attachments is expected to be up and running
+at "http://localhost:8080/axis2/services/Echo" with operation name as
+"echo". We don't want the maven to break because of this dependency.
+The name of the test case is hence modified not to match *Test.java pattern,
+so that maven wouldn't run it.
+
+However, for those who want to test this round trip test of attachments
+support, we are providing the Echo.aar service in the test-resources
+folder. Hot deploy this service on a servlet container at 8080 port and
+manually run this test case.
+
+****
\ No newline at end of file
Index: test/org/apache/axis2/saaj2/SOAPElementTest.java
===================================================================
--- test/org/apache/axis2/saaj2/SOAPElementTest.java	(revision 0)
+++ test/org/apache/axis2/saaj2/SOAPElementTest.java	(revision 0)
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.saaj2;
+
+import junit.framework.TestCase;
+
+import javax.xml.soap.SOAPElement;
+import java.util.List;
+
+import org.apache.axis2.saaj2.TextImplEx;
+import org.apache.axis2.om.impl.dom.NodeImpl;
+
+public class SOAPElementTest extends TestCase {
+
+    private SOAPElement soapElem;
+
+    protected void setUp() throws Exception {
+        soapElem =
+                SOAPFactoryImpl.newInstance().createElement("Test",
+                                                            "test",
+                                                            "http://test.apache.org/");
+    }
+
+    public void testAddTextNode() throws Exception {
+        assertNotNull(soapElem);
+        final String value = "foo";
+        soapElem.addTextNode(value);
+        assertEquals(value, soapElem.getValue());
+        TextImplEx text = assertContainsText(soapElem);
+        assertEquals(value, text.getValue());
+    }
+
+    private TextImplEx assertContainsText(SOAPElement soapElem) {
+        assertTrue(soapElem.hasChildNodes());
+        List childElems = toList(soapElem.getChildElements());
+        assertTrue(childElems.size() == 1);
+        NodeImpl node = (NodeImpl) childElems.get(0);
+        assertTrue(node instanceof TextImplEx);
+        return (TextImplEx) node;
+    }
+
+    private List toList(java.util.Iterator iter) {
+        List list = new java.util.ArrayList();
+        while (iter.hasNext()) {
+            list.add(iter.next());
+        }
+        return list;
+    }
+}
Index: test/org/apache/axis2/saaj2/EnvelopeTest.java
===================================================================
--- test/org/apache/axis2/saaj2/EnvelopeTest.java	(revision 0)
+++ test/org/apache/axis2/saaj2/EnvelopeTest.java	(revision 0)
@@ -0,0 +1,441 @@
+package org.apache.axis2.saaj2;
+
+import junit.framework.TestCase;
+
+import javax.xml.soap.MessageFactory;
+import javax.xml.soap.MimeHeaders;
+import javax.xml.soap.Name;
+import javax.xml.soap.Node;
+import javax.xml.soap.SOAPBody;
+import javax.xml.soap.SOAPElement;
+import javax.xml.soap.SOAPEnvelope;
+import javax.xml.soap.SOAPFault;
+import javax.xml.soap.SOAPHeader;
+import javax.xml.soap.SOAPHeaderElement;
+import javax.xml.soap.SOAPMessage;
+import javax.xml.soap.SOAPPart;
+import javax.xml.soap.Text;
+import javax.xml.soap.SOAPConnectionFactory;
+import javax.xml.soap.SOAPConnection;
+import java.io.ByteArrayInputStream;
+import java.util.Iterator;
+
+public class EnvelopeTest extends TestCase {
+
+    private static final String XML_STRING =
+            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
+            "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"\n" +
+            "                   xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n" +
+            "                   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n" +
+            " <soapenv:Header>\n" +
+            "  <shw:Hello xmlns:shw=\"http://www.jcommerce.net/soap/ns/SOAPHelloWorld\">\n" +
+            "    <shw:Myname>Tony</shw:Myname>\n" +
+            "  </shw:Hello>\n" +
+            " </soapenv:Header>\n" +
+            " <soapenv:Body>\n" +
+            "  <shw:Address xmlns:shw=\"http://www.jcommerce.net/soap/ns/SOAPHelloWorld\">\n" +
+            "    <shw:City>GENT</shw:City>\n" +
+            "  </shw:Address>\n" +
+            " </soapenv:Body>\n" +
+            "</soapenv:Envelope>";
+
+    public EnvelopeTest(String name) {
+        super(name);
+    }
+
+    public void testEnvelope() throws Exception {
+        MessageFactory mf = MessageFactory.newInstance();
+        SOAPMessage smsg =
+                mf.createMessage(new MimeHeaders(), new ByteArrayInputStream(XML_STRING.getBytes()));
+        SOAPPart sp = smsg.getSOAPPart();
+        SOAPEnvelope se = sp.getEnvelope();
+        smsg.writeTo(System.out);
+        assertTrue(se != null);
+    }
+
+    public void testEnvelope2() throws Exception {
+        MessageFactory mf = MessageFactory.newInstance();
+        final ByteArrayInputStream baIS = new ByteArrayInputStream(XML_STRING.getBytes());
+        final MimeHeaders mimeheaders = new MimeHeaders();
+        mimeheaders.addHeader("Content-Type", "multipart/related");
+        SOAPMessage smsg =
+                mf.createMessage(mimeheaders, baIS);
+
+        smsg.writeTo(System.out);
+
+        SOAPEnvelope envelope = smsg.getSOAPPart().getEnvelope();
+        SOAPBody body = envelope.getBody();
+        assertTrue(body != null);
+    }
+
+    // TODO: This test fails due to some issues in OM. Needs to be added to the test suite
+    //   that issue is fixed
+    public void _testEnvelopeWithLeadingComment() throws Exception {
+        String soapMessageWithLeadingComment =
+                "<?xml version='1.0' encoding='UTF-8'?>" +
+                "<!-- Comment -->" +
+                "<env:Envelope xmlns:env='http://schemas.xmlsoap.org/soap/envelope/'>" +
+                "<env:Body><echo><arg0>Hello</arg0></echo></env:Body>" +
+                "</env:Envelope>";
+
+        SOAPConnectionFactory scFactory = SOAPConnectionFactory.newInstance();
+        SOAPConnection con = scFactory.createConnection();
+
+        MessageFactory factory = MessageFactory.newInstance();
+        SOAPMessage message =
+                factory.createMessage(new MimeHeaders(),
+                                      new ByteArrayInputStream(soapMessageWithLeadingComment.getBytes()));
+        SOAPPart part = message.getSOAPPart();
+        SOAPEnvelope envelope = part.getEnvelope();
+        message.writeTo(System.out);
+        assertTrue(envelope != null);
+        assertTrue(envelope.getBody() != null);
+    }
+
+    public void testEnvelopeWithCommentInEnvelope() throws Exception {
+
+        String soapMessageWithLeadingComment =
+                "<?xml version='1.0' encoding='UTF-8'?>\n" +
+                "<soapenv:Envelope  xmlns='http://somewhere.com/html'\n" +
+                "                   xmlns:soapenv='http://schemas.xmlsoap.org/soap/envelope/'\n" +
+                "                   xmlns:xsd='http://www.w3.org/2001/XMLSchema'\n" +
+                "                   xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>\n" +
+                "<!-- Comment -->" +
+                " <soapenv:Body>\n" +
+                "    <echo><arg0>Hello</arg0></echo>" +
+//                "    <t:echo xmlns:t='http://test.org/Test'><t:arg0>Hello</t:arg0></t:echo>" +
+" </soapenv:Body>\n" +
+"</soapenv:Envelope>";
+
+        MessageFactory factory = MessageFactory.newInstance();
+        SOAPMessage message =
+                factory.createMessage(new MimeHeaders(),
+                                      new ByteArrayInputStream(soapMessageWithLeadingComment.getBytes()));
+        SOAPPart part = message.getSOAPPart();
+        SOAPEnvelope envelope = part.getEnvelope();
+        message.writeTo(System.out);
+        assertTrue(envelope != null);
+        assertTrue(envelope.getBody() != null);
+    }
+
+    public void testEnvelopeWithCommentInBody() throws Exception {
+
+        String soapMessageWithLeadingComment =
+                "<?xml version='1.0' encoding='UTF-8'?>\n" +
+                "<soapenv:Envelope xmlns:soapenv='http://schemas.xmlsoap.org/soap/envelope/'\n" +
+                "                   xmlns:xsd='http://www.w3.org/2001/XMLSchema'\n" +
+                "                   xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>\n" +
+                " <soapenv:Body>\n" +
+                "<!-- Comment -->" +
+//                "    <echo><arg0>Hello</arg0></echo>" +
+"    <t:echo xmlns:t='http://test.org/Test'><t:arg0>Hello</t:arg0></t:echo>" +
+" </soapenv:Body>\n" +
+"</soapenv:Envelope>";
+
+        MessageFactory factory = MessageFactory.newInstance();
+        SOAPMessage message =
+                factory.createMessage(new MimeHeaders(),
+                                      new ByteArrayInputStream(soapMessageWithLeadingComment.getBytes()));
+        SOAPPart part = message.getSOAPPart();
+        SOAPEnvelope envelope = part.getEnvelope();
+        message.writeTo(System.out);
+        assertTrue(envelope != null);
+        assertTrue(envelope.getBody() != null);
+    }
+
+    public void testEnvelopeWithComments() throws Exception {
+
+        String soapMessageWithLeadingComment =
+                "<?xml version='1.0' encoding='UTF-8'?>\n" +
+                "<soapenv:Envelope xmlns:soapenv='http://schemas.xmlsoap.org/soap/envelope/'\n" +
+                "                   xmlns:xsd='http://www.w3.org/2001/XMLSchema'\n" +
+                "                   xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>\n" +
+                " <soapenv:Header>\n" +
+                "<!-- Comment -->" +
+                "  <shw:Hello xmlns:shw=\"http://www.jcommerce.net/soap/ns/SOAPHelloWorld\">\n" +
+                "<!-- Comment -->" +
+                "    <shw:Myname><!-- Comment -->Tony</shw:Myname>\n" +
+                "  </shw:Hello>\n" +
+                " </soapenv:Header>\n" +
+                " <soapenv:Body>\n" +
+                "<!-- Comment -->" +
+                "    <t:echo xmlns:t='http://test.org/Test'><t:arg0>Hello</t:arg0></t:echo>" +
+                " </soapenv:Body>\n" +
+                "</soapenv:Envelope>";
+
+        MessageFactory factory = MessageFactory.newInstance();
+        SOAPMessage message =
+                factory.createMessage(new MimeHeaders(),
+                                      new ByteArrayInputStream(soapMessageWithLeadingComment.getBytes()));
+        SOAPPart part = message.getSOAPPart();
+        SOAPEnvelope envelope = part.getEnvelope();
+        message.writeTo(System.out);
+        assertTrue(envelope != null);
+        assertTrue(envelope.getBody() != null);
+    }
+
+    //TODO: Fails. Check this. Faults need more thorough testing
+    public void testFaults() throws Exception {
+        SOAPEnvelope envelope = getSOAPEnvelope();
+        SOAPBody body = envelope.getBody();
+
+        assertFalse(body.hasFault());
+        SOAPFault soapFault = body.addFault();
+        assertTrue(body.hasFault());
+        assertNotNull(body.getFault());
+
+        soapFault.setFaultString("myFault");
+        String faultString = soapFault.getFaultString();
+        System.err.println("######## faultString=" + faultString);
+
+//        soapFault.setFaultCode("CODE");
+//        soapFault.getFaultCode();
+//        System.err.println("######## faultCode=" + soapFault.getFaultCode());
+
+//        assertEquals()
+
+        //soapFault.setFaultCode("myFault");
+        //String fc = soapFault.getFaultCode();
+        /*soapFault.setFaultString("myFault");
+        String fc = soapFault.getFaultString(); //Chk the same for FaultCode as well
+
+        // currently not done in SAAJ
+        assertTrue(fc.equals("myFault"));*/
+    }
+    /*
+   public void testFaults2() throws Exception {
+
+       SOAPEnvelope envelope = getSOAPEnvelope();
+       SOAPBody body = envelope.getBody();
+       SOAPFault sf = body.addFault();
+
+       assertTrue(body.getFault() != null);
+
+       Detail d1 = sf.addDetail();
+       Name name = envelope.createName("GetLastTradePrice", "WOMBAT",
+                                       "http://www.wombat.org/trader");
+       d1.addDetailEntry(name);
+
+       Detail d2 = sf.getDetail();
+       assertTrue(d2 != null);
+       Iterator i = d2.getDetailEntries();
+       assertTrue(getIteratorCount(i) == 1);
+       i = d2.getDetailEntries();
+       //message.writeTo(System.out);
+       while (i.hasNext()) {
+           DetailEntry de = (DetailEntry) i.next();
+           assertEquals(de.getElementName(), name);
+       }
+   }*/
+
+    public void testHeaderElements() throws Exception {
+        SOAPEnvelope envelope = getSOAPEnvelope();
+        SOAPHeader header = envelope.getHeader();
+
+        SOAPHeaderElement headerEle = header.addHeaderElement(envelope.createName("foo1",
+                                                                                  "f1",
+                                                                                  "foo1-URI"));
+        headerEle.setActor("actor-URI");
+        headerEle.setMustUnderstand(true);
+
+        Iterator iterator = header.extractHeaderElements("actor-URI");
+        int cnt = 0;
+        while (iterator.hasNext()) {
+            cnt++;
+            SOAPHeaderElement resultHeaderEle = (SOAPHeaderElement) iterator.next();
+
+            assertEquals(headerEle.getActor(), resultHeaderEle.getActor());
+            assertEquals(resultHeaderEle.getMustUnderstand(),headerEle.getMustUnderstand());
+        }
+        assertTrue(cnt == 1);
+        iterator = header.extractHeaderElements("actor-URI");
+        assertTrue(!iterator.hasNext());
+    }
+
+    public void testText() throws Exception {
+        SOAPEnvelope envelope = getSOAPEnvelope();
+        SOAPBody body = envelope.getBody();
+        Iterator iStart = body.getChildElements();
+        int countStart = getIteratorCount(iStart);
+
+        final String bodyText = "<txt>This is the body text</txt>";
+
+        SOAPElement se = body.addTextNode(bodyText);
+        assertTrue(se != null);
+
+        assertTrue(body.getValue().equals(bodyText));
+
+        Iterator i = body.getChildElements();
+        int count = getIteratorCount(i);
+        assertTrue(count == countStart + 1);
+    }
+
+    public void testNonCommentText() throws Exception {
+        SOAPEnvelope envelope = getSOAPEnvelope();
+        SOAPBody body = envelope.getBody();
+        SOAPElement se = body.addTextNode("<txt>This is text</txt>");
+        Iterator iterator = se.getChildElements();
+        Object o = null;
+        while (iterator.hasNext()) {
+            o = iterator.next();
+            if (o instanceof Text) {
+                break;
+            }
+        }
+        assertTrue(o instanceof Text);
+        Text t = (Text) o;
+        assertTrue(!t.isComment());
+    }
+
+    public void testCommentText() throws Exception {
+        SOAPEnvelope envelope = getSOAPEnvelope();
+        SOAPBody body = envelope.getBody();
+        SOAPElement se = body.addTextNode("<!-- This is a comment -->");
+        Iterator iterator = se.getChildElements();
+        Node n = null;
+        while (iterator.hasNext()) {
+            n = (Node) iterator.next();
+            if (n instanceof Text)
+                break;
+        }
+        assertTrue(n instanceof Text);
+        Text t = (Text) n;
+        assertTrue(t.isComment());
+    }
+
+    public void testAttributes() throws Exception {
+        SOAPEnvelope envelope = getSOAPEnvelope();
+        SOAPBody body = envelope.getBody();
+
+        Name name1 = envelope.createName("MyAttr1");
+        String value1 = "MyValue1";
+
+        Name name2 = envelope.createName("MyAttr2");
+        String value2 = "MyValue2";
+
+        Name name3 = envelope.createName("MyAttr3");
+        String value3 = "MyValue3";
+
+        body.addAttribute(name1, value1);
+        body.addAttribute(name2, value2);
+        body.addAttribute(name3, value3);
+
+        Iterator iterator = body.getAllAttributes();
+        assertTrue(getIteratorCount(iterator) == 3);
+        iterator = body.getAllAttributes();
+
+        boolean foundName1 = false;
+        boolean foundName2 = false;
+        boolean foundName3 = false;
+        while (iterator.hasNext()) {
+            Name name = (Name) iterator.next();
+            if (name.equals(name1)) {
+                foundName1 = true;
+                assertEquals(value1, body.getAttributeValue(name));
+            } else if (name.equals(name2)) {
+                foundName2 = true;
+                assertEquals(value2, body.getAttributeValue(name));
+            } else if (name.equals(name3)) {
+                foundName3 = true;
+                assertEquals(value3, body.getAttributeValue(name));
+            }
+        }
+        assertTrue(foundName1 && foundName2 && foundName3);
+    }
+
+    public void testAttributes2() throws Exception {
+        SOAPEnvelope envelope = getSOAPEnvelope();
+        SOAPBody body = envelope.getBody();
+
+        Name name1 = envelope.createName("MyAttr1", "att", "http://test.com/Attr");
+        String value1 = "MyValue1";
+
+        Name name2 = envelope.createName("MyAttr2");
+        String value2 = "MyValue2";
+
+        Name name3 = envelope.createName("MyAttr3");
+        String value3 = "MyValue3";
+
+        body.addAttribute(name1, value1);
+        body.addAttribute(name2, value2);
+        body.addAttribute(name3, value3);
+
+        Iterator iterator = body.getAllAttributes();
+        assertTrue(getIteratorCount(iterator) == 3);
+        iterator = body.getAllAttributes();
+
+        boolean foundName1 = false;
+        boolean foundName2 = false;
+        boolean foundName3 = false;
+        while (iterator.hasNext()) {
+            Name name = (Name) iterator.next();
+            if (name.equals(name1)) {
+                foundName1 = true;
+                assertEquals(value1, body.getAttributeValue(name));
+            } else if (name.equals(name2)) {
+                foundName2 = true;
+                assertEquals(value2, body.getAttributeValue(name));
+            } else if (name.equals(name3)) {
+                foundName3 = true;
+                assertEquals(value3, body.getAttributeValue(name));
+            }
+        }
+        assertTrue(foundName1 && foundName2 && foundName3);
+    }
+
+    public void testAttributes3() throws Exception {
+        SOAPEnvelope envelope = getSOAPEnvelope();
+        SOAPBody body = envelope.getBody();
+
+        Name name1 = envelope.createName("MyAttr1", "att", "http://test.com/Attr");
+        String value1 = "MyValue1";
+
+        Name name2 = envelope.createName("MyAttr2", "att", "http://test.com/Attr");
+        String value2 = "MyValue2";
+
+        Name name3 = envelope.createName("MyAttr3", "att", "http://test.com/Attr");
+        String value3 = "MyValue3";
+
+        body.addAttribute(name1, value1);
+        body.addAttribute(name2, value2);
+        body.addAttribute(name3, value3);
+
+        Iterator iterator = body.getAllAttributes();
+        assertTrue(getIteratorCount(iterator) == 3);
+        iterator = body.getAllAttributes();
+
+        boolean foundName1 = false;
+        boolean foundName2 = false;
+        boolean foundName3 = false;
+        while (iterator.hasNext()) {
+            Name name = (Name) iterator.next();
+            if (name.equals(name1)) {
+                foundName1 = true;
+                assertEquals(value1, body.getAttributeValue(name));
+            } else if (name.equals(name2)) {
+                foundName2 = true;
+                assertEquals(value2, body.getAttributeValue(name));
+            } else if (name.equals(name3)) {
+                foundName3 = true;
+                assertEquals(value3, body.getAttributeValue(name));
+            }
+        }
+        assertTrue(foundName1 && foundName2 && foundName3);
+    }
+
+    private SOAPEnvelope getSOAPEnvelope() throws Exception {
+        MessageFactory factory = MessageFactory.newInstance();
+        SOAPMessage message = factory.createMessage();
+        return message.getSOAPPart().getEnvelope();
+    }
+
+    private int getIteratorCount(java.util.Iterator i) {
+        int count = 0;
+        while (i.hasNext()) {
+            count++;
+            i.next();
+        }
+        return count;
+    }
+
+}
Index: src/org/apache/axis2/saaj2/AttachmentPartImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/AttachmentPartImpl.java	(revision 0)
+++ src/org/apache/axis2/saaj2/AttachmentPartImpl.java	(revision 0)
@@ -0,0 +1,366 @@
+/*                                                                             
+ * Copyright 2004,2005 The Apache Software Foundation.                         
+ *                                                                             
+ * Licensed under the Apache License, Version 2.0 (the "License");             
+ * you may not use this file except in compliance with the License.            
+ * You may obtain a copy of the License at                                     
+ *                                                                             
+ *      http://www.apache.org/licenses/LICENSE-2.0                             
+ *                                                                             
+ * Unless required by applicable law or agreed to in writing, software         
+ * distributed under the License is distributed on an "AS IS" BASIS,           
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    
+ * See the License for the specific language governing permissions and         
+ * limitations under the License.                                              
+ */
+package org.apache.axis2.saaj2;
+
+import org.apache.axis2.om.OMText;
+import org.apache.axis2.om.DOOMAbstractFactory;
+import org.apache.axis2.om.impl.dom.factory.OMDOMFactory;
+import org.apache.axis2.transport.http.HTTPConstants;
+
+import javax.activation.DataHandler;
+import javax.activation.UnsupportedDataTypeException;
+import javax.xml.soap.AttachmentPart;
+import javax.xml.soap.MimeHeader;
+import javax.xml.soap.MimeHeaders;
+import javax.xml.soap.SOAPException;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.Iterator;
+
+/**
+ * 
+ */
+public class AttachmentPartImpl extends AttachmentPart {
+
+    private DataHandler dataHandler;
+
+    /**
+     * Field mimeHeaders.
+     */
+    private MimeHeaders mimeHeaders = new MimeHeaders();
+
+    private OMText omText;
+
+    /**
+     * Check whether at least one of the headers of this object matches a provided header
+     *
+     * @param headers
+     * @return <b>true</b> if at least one header of this AttachmentPart matches
+     *         a header in the provided <code>headers</code> parameter,
+     *         <b>false</b> if none of the headers of this AttachmentPart matches
+     *         at least one of the header in the provided <code>headers</code> parameter
+     */
+    public boolean matches(MimeHeaders headers) {
+        for (Iterator i = headers.getAllHeaders(); i.hasNext();) {
+            MimeHeader hdr = (javax.xml.soap.MimeHeader) i.next();
+            String values[] = mimeHeaders.getHeader(hdr.getName());
+            boolean found = false;
+            if (values != null) {
+                for (int j = 0; j < values.length; j++) {
+                    if (!hdr.getValue().equalsIgnoreCase(values[j])) {
+                        continue;
+                    }
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Returns the number of bytes in this <CODE>
+     * AttachmentPart</CODE> object.
+     *
+     * @return the size of this <CODE>AttachmentPart</CODE> object
+     *         in bytes or -1 if the size cannot be determined
+     * @throws javax.xml.soap.SOAPException if the content of this
+     *                                      attachment is corrupted of if there was an exception
+     *                                      while trying to determine the size.
+     */
+    public int getSize() throws SOAPException {
+        if (dataHandler == null) {
+            return -1;
+        }
+        ByteArrayOutputStream bout = new ByteArrayOutputStream();
+        try {
+            dataHandler.writeTo(bout);
+        } catch (java.io.IOException ex) {
+            throw new SOAPException(ex);
+        }
+        return bout.size();
+    }
+
+    /**
+     * Clears out the content of this <CODE>
+     * AttachmentPart</CODE> object. The MIME header portion is left
+     * untouched.
+     */
+    public void clearContent() {
+        dataHandler = null;
+		omText = null;
+    }
+
+    /**
+     * Gets the content of this <code>AttachmentPart</code> object as a Java
+     * object. The type of the returned Java object depends on
+     * <ol>
+     * <li> the
+     * <code>DataContentHandler</code> object that is used to interpret the bytes
+     * </li>
+     * <li> the <code>Content-Type</code> given in the header</li>
+     * </ol>
+     * <p/>
+     * For the MIME content types "text/plain", "text/html" and "text/xml", the
+     * <code>DataContentHandler</code> object does the conversions to and
+     * from the Java types corresponding to the MIME types.
+     * For other MIME types,the <code>DataContentHandler</code> object
+     * can return an <code>InputStream</code> object that contains the content data
+     * as raw bytes.
+     * <p/>
+     * A JAXM-compliant implementation must, as a minimum, return a
+     * <code>java.lang.String</code> object corresponding to any content
+     * stream with a <code>Content-Type</code> value of
+     * <code>text/plain</code>, a
+     * <code>javax.xml.transform.StreamSource</code> object corresponding to a
+     * content stream with a <code>Content-Type</code> value of
+     * <code>text/xml</code>, a <code>java.awt.Image</code> object
+     * corresponding to a content stream with a
+     * <code>Content-Type</code> value of <code>image/gif</code> or
+     * <code>image/jpeg</code>.  For those content types that an
+     * installed <code>DataContentHandler</code> object does not understand, the
+     * <code>DataContentHandler</code> object is required to return a
+     * <code>java.io.InputStream</code> object with the raw bytes.
+     *
+     * @return a Java object with the content of this <CODE>
+     *         AttachmentPart</CODE> object
+     * @throws javax.xml.soap.SOAPException if there is no content set
+     *                                      into this <CODE>AttachmentPart</CODE> object or if there
+     *                                      was a data transformation error
+     */
+    public Object getContent() throws SOAPException {
+        if (dataHandler == null) {
+            throw new SOAPException("No content is present in this AttachmentPart");
+        }
+        try {
+            String ContentType = dataHandler.getContentType();
+            if (ContentType.equals("text/plain") ||
+                ContentType.equals("text/xml") ||
+                ContentType.equals("text/html")) {
+
+                //For these content types underlying DataContentHandler surely does
+                //the conversion to appropriate java object and we will return that java object
+                return dataHandler.getContent();
+            } else {
+                try {
+                    return dataHandler.getContent();
+                } catch (UnsupportedDataTypeException e) {
+
+                    //If the underlying DataContentHandler can't handle the object contents,
+                    //we will return an inputstream of raw bytes represneting the content data
+                    return dataHandler.getDataSource().getInputStream();
+                }
+            }
+        } catch (IOException e) {
+            throw new SOAPException(e);
+        }
+    }
+
+    /**
+     * Sets the content of this attachment part to that of the
+     * given <CODE>Object</CODE> and sets the value of the <CODE>
+     * Content-Type</CODE> header to the given type. The type of the
+     * <CODE>Object</CODE> should correspond to the value given for
+     * the <CODE>Content-Type</CODE>. This depends on the particular
+     * set of <CODE>DataContentHandler</CODE> objects in use.
+     *
+     * @param object      the Java object that makes up
+     *                    the content for this attachment part
+     * @param contentType the MIME string that
+     *                    specifies the type of the content
+     * @throws IllegalArgumentException if
+     *                                  the contentType does not match the type of the content
+     *                                  object, or if there was no <CODE>
+     *                                  DataContentHandler</CODE> object for this content
+     *                                  object
+     * @see #getContent()
+     */
+    public void setContent(Object object, String contentType) {
+
+        //TODO: need to check whether the type of the content object matches contentType
+        //TODO: need to check whether there is a DataContentHandler for this object
+        setDataHandler(new DataHandler(object, contentType));
+    }
+
+    /**
+     * Gets the <CODE>DataHandler</CODE> object for this <CODE>
+     * AttachmentPart</CODE> object.
+     *
+     * @return the <CODE>DataHandler</CODE> object associated with
+     *         this <CODE>AttachmentPart</CODE> object
+     * @throws javax.xml.soap.SOAPException if there is
+     *                                      no data in this <CODE>AttachmentPart</CODE> object
+     */
+    public DataHandler getDataHandler() throws SOAPException {
+        if (getContent() == null) {
+            throw new SOAPException("No Content present in the Attachment part");
+        }
+        return dataHandler;
+    }
+
+    /**
+     * Sets the given <CODE>DataHandler</CODE> object as the
+     * data handler for this <CODE>AttachmentPart</CODE> object.
+     * Typically, on an incoming message, the data handler is
+     * automatically set. When a message is being created and
+     * populated with content, the <CODE>setDataHandler</CODE>
+     * method can be used to get data from various data sources into
+     * the message.
+     *
+     * @param datahandler <CODE>DataHandler</CODE> object to
+     *                    be set
+     * @throws IllegalArgumentException if
+     *                                  there was a problem with the specified <CODE>
+     *                                  DataHandler</CODE> object
+     */
+    public void setDataHandler(DataHandler datahandler) {
+        if (datahandler != null) {
+            this.dataHandler = datahandler;
+            setMimeHeader(HTTPConstants.HEADER_CONTENT_TYPE, datahandler.getContentType());
+            omText = DOOMAbstractFactory.getOMFactory().createText(dataHandler, true);
+        }
+    }
+
+    /**
+     * Removes all MIME headers that match the given name.
+     *
+     * @param header - the string name of the MIME
+     *               header/s to be removed
+     */
+    public void removeMimeHeader(String header) {
+        mimeHeaders.removeHeader(header);
+    }
+
+    /**
+     * Removes all the MIME header entries.
+     */
+    public void removeAllMimeHeaders() {
+        mimeHeaders.removeAllHeaders();
+    }
+
+    /**
+     * Gets all the values of the header identified by the given
+     * <CODE>String</CODE>.
+     *
+     * @param name the name of the header; example:
+     *             "Content-Type"
+     * @return a <CODE>String</CODE> array giving the value for the
+     *         specified header
+     * @see #setMimeHeader(String, String) setMimeHeader(java.lang.String, java.lang.String)
+     */
+    public String[] getMimeHeader(String name) {
+        return mimeHeaders.getHeader(name);
+    }
+
+    /**
+     * Changes the first header entry that matches the given name
+     * to the given value, adding a new header if no existing
+     * header matches. This method also removes all matching
+     * headers but the first.
+     * <p/>
+     * <P>Note that RFC822 headers can only contain US-ASCII
+     * characters.</P>
+     *
+     * @param name  a <CODE>String</CODE> giving the
+     *              name of the header for which to search
+     * @param value a <CODE>String</CODE> giving the
+     *              value to be set for the header whose name matches the
+     *              given name
+     * @throws IllegalArgumentException if
+     *                                  there was a problem with the specified mime header name
+     *                                  or value
+     */
+    public void setMimeHeader(String name, String value) {
+        mimeHeaders.setHeader(name, value);
+    }
+
+    /**
+     * Adds a MIME header with the specified name and value to
+     * this <CODE>AttachmentPart</CODE> object.
+     * <p/>
+     * <P>Note that RFC822 headers can contain only US-ASCII
+     * characters.</P>
+     *
+     * @param name  a <CODE>String</CODE> giving the
+     *              name of the header to be added
+     * @param value a <CODE>String</CODE> giving the
+     *              value of the header to be added
+     * @throws IllegalArgumentException if
+     *                                  there was a problem with the specified mime header name
+     *                                  or value
+     */
+    public void addMimeHeader(String name, String value) {
+        mimeHeaders.addHeader(name, value);
+    }
+
+    /**
+     * Retrieves all the headers for this <CODE>
+     * AttachmentPart</CODE> object as an iterator over the <CODE>
+     * MimeHeader</CODE> objects.
+     *
+     * @return an <CODE>Iterator</CODE> object with all of the Mime
+     *         headers for this <CODE>AttachmentPart</CODE> object
+     */
+    public Iterator getAllMimeHeaders() {
+        return mimeHeaders.getAllHeaders();
+    }
+
+    /**
+     * Retrieves all <CODE>MimeHeader</CODE> objects that match
+     * a name in the given array.
+     *
+     * @param names a <CODE>String</CODE> array with
+     *              the name(s) of the MIME headers to be returned
+     * @return all of the MIME headers that match one of the names
+     *         in the given array as an <CODE>Iterator</CODE>
+     *         object
+     */
+    public Iterator getMatchingMimeHeaders(String names[]) {
+        return mimeHeaders.getMatchingHeaders(names);
+    }
+
+    /**
+     * Retrieves all <CODE>MimeHeader</CODE> objects whose name
+     * does not match a name in the given array.
+     *
+     * @param names a <CODE>String</CODE> array with
+     *              the name(s) of the MIME headers not to be returned
+     * @return all of the MIME headers in this <CODE>
+     *         AttachmentPart</CODE> object except those that match one
+     *         of the names in the given array. The nonmatching MIME
+     *         headers are returned as an <CODE>Iterator</CODE>
+     *         object.
+     */
+    public Iterator getNonMatchingMimeHeaders(String names[]) {
+        return mimeHeaders.getNonMatchingHeaders(names);
+    }
+
+    /**
+     * Retrieve the OMText
+     *
+     * @return the OMText
+     * @throws SOAPException If omText is not available
+     */
+    public OMText getOMText() throws SOAPException{
+		if(omText == null){
+			throw new SOAPException("OMText set to null");
+		}
+		return omText;
+	}
+}
Index: src/org/apache/axis2/saaj2/SOAPBodyImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/SOAPBodyImpl.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/SOAPBodyImpl.java	(working copy)
@@ -15,96 +15,150 @@
  */
 package org.apache.axis2.saaj2;
 
-import java.util.Locale;
+import org.apache.axis2.om.impl.dom.ElementImpl;
+import org.apache.axis2.soap.impl.dom.soap11.SOAP11FaultImpl;
+import org.w3c.dom.Document;
 
 import javax.xml.soap.Name;
 import javax.xml.soap.SOAPBody;
 import javax.xml.soap.SOAPBodyElement;
 import javax.xml.soap.SOAPException;
 import javax.xml.soap.SOAPFault;
+import java.util.Locale;
 
-import org.apache.axis2.om.impl.dom.ElementImpl;
-import org.apache.axis2.soap.impl.dom.soap11.SOAP11FaultImpl;
-import org.w3c.dom.Document;
-
 public class SOAPBodyImpl extends SOAPElementImpl implements SOAPBody {
 
     private org.apache.axis2.soap.SOAPBody omSOAPBody;
-    
-	/**
-	 * @param element
-	 */
-	public SOAPBodyImpl(org.apache.axis2.soap.SOAPBody omSOAPBody) {
-		super((ElementImpl)omSOAPBody);
-		this.omSOAPBody = omSOAPBody;
-	}
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPBody#addFault()
-	 */
-	public SOAPFault addFault() throws SOAPException {
-		SOAP11FaultImpl fault = new SOAP11FaultImpl(omSOAPBody);
-		this.omSOAPBody.addFault(fault);
-		return new SOAPFaultImpl(fault);
-	}
+    /**
+     * @param omSOAPBody
+     */
+    public SOAPBodyImpl(org.apache.axis2.soap.SOAPBody omSOAPBody) {
+        super((ElementImpl) omSOAPBody);
+        this.omSOAPBody = omSOAPBody;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPBody#hasFault()
-	 */
-	public boolean hasFault() {
-		return this.omSOAPBody.hasFault();
-	}
+    /**
+     * Creates a new <code>SOAPFault</code> object and adds it to
+     * this <code>SOAPBody</code> object.
+     *
+     * @return the new <code>SOAPFault</code> object
+     * @throws SOAPException if there is a SOAP error
+     */
+    public SOAPFault addFault() throws SOAPException {
+        SOAP11FaultImpl fault = new SOAP11FaultImpl(omSOAPBody);
+        omSOAPBody.addFault(fault);
+        return new SOAPFaultImpl(fault);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPBody#getFault()
-	 */
-	public SOAPFault getFault() {
-		if(this.omSOAPBody.hasFault()) {
-			return new SOAPFaultImpl(this.omSOAPBody.getFault());
-		}
-		return null;
-	}
+    /**
+     * Indicates whether a <code>SOAPFault</code> object exists in
+     * this <code>SOAPBody</code> object.
+     *
+     * @return <code>true</code> if a <code>SOAPFault</code> object exists in
+     *         this <code>SOAPBody</code> object; <code>false</code>
+     *         otherwise
+     */
+    public boolean hasFault() {
+        return omSOAPBody.hasFault();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPBody#addBodyElement(javax.xml.soap.Name)
-	 */
-	public SOAPBodyElement addBodyElement(Name name) throws SOAPException {
-		SOAPElementImpl elem = (SOAPElementImpl)this.addChildElement(name);
-		return new SOAPBodyElementImpl(elem.element);
-	}
+    /**
+     * Returns the <code>SOAPFault</code> object in this <code>SOAPBody</code>
+     * object.
+     *
+     * @return the <code>SOAPFault</code> object in this <code>SOAPBody</code>
+     *         object
+     */
+    public SOAPFault getFault() {
+        if (omSOAPBody.hasFault()) {
+            return new SOAPFaultImpl(omSOAPBody.getFault());
+        }
+        return null;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPBody#addFault(javax.xml.soap.Name, java.lang.String, java.util.Locale)
-	 */
-	public SOAPFault addFault(Name faultCode, String faultString, Locale locale) throws SOAPException {
-		SOAP11FaultImpl fault = new SOAP11FaultImpl(this.omSOAPBody, new Exception(faultString));
-		SOAPFaultImpl faultImpl = new SOAPFaultImpl(fault);
-		faultImpl.setFaultCode(faultCode);
-		if(locale != null) {
-			faultImpl.setFaultString(faultString, locale);
-		} else {
-			faultImpl.setFaultString(faultString);
-		}
-		
-		return faultImpl;
-	}
+    /**
+     * Creates a new <code>SOAPBodyElement</code> object with the
+     * specified name and adds it to this <code>SOAPBody</code> object.
+     *
+     * @param name a <code>Name</code> object with the name for the new
+     *             <code>SOAPBodyElement</code> object
+     * @return the new <code>SOAPBodyElement</code> object
+     * @throws SOAPException if a SOAP error occurs
+     */
+    public SOAPBodyElement addBodyElement(Name name) throws SOAPException {
+        SOAPElementImpl elem = (SOAPElementImpl) addChildElement(name);
+        return new SOAPBodyElementImpl(elem.element);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPBody#addFault(javax.xml.soap.Name, java.lang.String)
-	 */
-	public SOAPFault addFault(Name faultCode, String faultString) throws SOAPException {
-		return this.addFault(faultCode, faultString, null);
-	}
+    /**
+     * Creates a new <code>SOAPFault</code> object and adds it to this
+     * <code>SOAPBody</code> object. The new <code>SOAPFault</code> will have a
+     * <code>faultcode</code> element that is set to the <code>faultCode</code>
+     * parameter and a <code>faultstring</code> set to <code>faultstring</code>
+     * and localized to <code>locale</code>.
+     *
+     * @param faultCode   a <code>Name</code> object giving the fault code to be
+     *                    set; must be one of the fault codes defined in the SOAP 1.1
+     *                    specification and of type QName
+     * @param faultString a <code>String</code> giving an explanation of the
+     *                    fault
+     * @param locale      a <code>Locale</code> object indicating the native language
+     *                    of the <ocde>faultString</code>
+     * @return the new <code>SOAPFault</code> object
+     * @throws SOAPException if there is a SOAP error
+     */
+    public SOAPFault addFault(Name faultCode, String faultString, Locale locale) throws SOAPException {
+        SOAP11FaultImpl fault = new SOAP11FaultImpl(omSOAPBody, new Exception(faultString));
+        SOAPFaultImpl faultImpl = new SOAPFaultImpl(fault);
+        faultImpl.setFaultCode(faultCode);
+        if (locale != null) {
+            faultImpl.setFaultString(faultString, locale);
+        } else {
+            faultImpl.setFaultString(faultString);
+        }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPBody#addDocument(org.w3c.dom.Document)
-	 */
-	public SOAPBodyElement addDocument(Document document) throws SOAPException {
+        return faultImpl;
+    }
+
+    /**
+     * Creates a new <code>SOAPFault</code> object and adds it to this
+     * <code>SOAPBody</code> object. The new <code>SOAPFault</code> will have a
+     * <code>faultcode</code> element that is set to the <code>faultCode</code>
+     * parameter and a <code>faultstring</code> set to <code>faultstring</code>.
+     *
+     * @param faultCode   a <code>Name</code> object giving the fault code to be
+     *                    set; must be one of the fault codes defined in the SOAP 1.1
+     *                    specification and of type QName
+     * @param faultString a <code>String</code> giving an explanation of the
+     *                    fault
+     * @return the new <code>SOAPFault</code> object
+     * @throws SOAPException if there is a SOAP error
+     */
+    public SOAPFault addFault(Name faultCode, String faultString) throws SOAPException {
+        return addFault(faultCode, faultString, null);
+    }
+
+    /**
+     * Adds the root node of the DOM <code>Document</code> to this
+     * <code>SOAPBody</code> object.
+     * <p/>
+     * Calling this method invalidates the <code>document</code> parameter. The
+     * client application should discard all references to this
+     * <code>Document</code> and its contents upon calling
+     * <code>addDocument</code>. The behavior of an application that continues
+     * to use such references is undefined.
+     *
+     * @param document the <code>Document</code> object whose root node will be
+     *                 added to this <code>SOAPBody</code>
+     * @return the <code>SOAPBodyElement</code> that represents the root node
+     *         that was added
+     * @throws SOAPException if the <code>Document</code> cannot be added
+     */
+    public SOAPBodyElement addDocument(Document document) throws SOAPException {
+
+        SOAPElementImpl elem = new SOAPElementImpl((ElementImpl) document.getDocumentElement());
+        return new SOAPBodyElementImpl(elem.element);
 		
-		SOAPElementImpl elem = new SOAPElementImpl((ElementImpl)document.getDocumentElement());
-		return new SOAPBodyElementImpl(elem.element);
-		
 	}
-
-
 }
Index: src/org/apache/axis2/saaj2/NodeListImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/NodeListImpl.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/NodeListImpl.java	(working copy)
@@ -22,6 +22,14 @@
 import java.util.Collections;
 import java.util.List;
 
+/**
+ * The <code>NodeList</code> interface provides the abstraction of an ordered
+ * collection of nodes, without defining or constraining how this collection
+ * is implemented. <code>NodeList</code> objects in the DOM are live.
+ * <p>The items in the <code>NodeList</code> are accessible via an integral
+ * index, starting from 0.
+ * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113'>Document Object Model (DOM) Level 2 Core Specification</a>.
+ */
 public class NodeListImpl implements NodeList {
 
     List mNodes;
@@ -52,10 +60,13 @@
     }
 
     /**
-     * Interface Implemented
-     *
-     * @param index
-     * @return
+     * Returns the <code>index</code>th item in the collection. If
+     * <code>index</code> is greater than or equal to the number of nodes in
+     * the list, this returns <code>null</code>.
+     * @param index Index into the collection.
+     * @return The node at the <code>index</code>th position in the
+     *   <code>NodeList</code>, or <code>null</code> if that is not a valid
+     *   index.
      */
     public Node item(int index) {
         if (mNodes != null && mNodes.size() > index) {
@@ -65,6 +76,10 @@
         }
     }
 
+    /**
+     * The number of nodes in the list. The range of valid child node indices
+     * is 0 to <code>length-1</code> inclusive.
+     */
     public int getLength() {
         return mNodes.size();
     }
Index: src/org/apache/axis2/saaj2/TextImplEx.java
===================================================================
--- src/org/apache/axis2/saaj2/TextImplEx.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/TextImplEx.java	(working copy)
@@ -15,130 +15,264 @@
  */
 package org.apache.axis2.saaj2;
 
-import javax.xml.soap.Text;
-import javax.xml.stream.XMLStreamException;
-
 import org.apache.axis2.om.OMContainer;
 import org.apache.axis2.om.OMException;
+import org.apache.axis2.om.DOOMAbstractFactory;
 import org.apache.axis2.om.impl.OMOutputImpl;
 import org.apache.axis2.om.impl.dom.TextImpl;
+import org.apache.axis2.om.impl.dom.factory.OMDOMFactory;
 import org.w3c.dom.DOMException;
 
+import javax.xml.soap.Text;
+import javax.xml.stream.XMLStreamException;
+
 public class TextImplEx extends NodeImplEx implements Text {
 
-	TextImpl textNode;
-	
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.Text#isComment()
-	 */
-	public boolean isComment() {
-		String value = this.textNode.getText();
-		return value.startsWith("<!--") && value.endsWith("-->");
-	}
+    //TODO: assign textNode
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getNodeName()
-	 */
-	public String getNodeName() {
-		return this.textNode.getNodeName();
-	}
+    private TextImpl textNode;
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getNodeType()
-	 */
-	public short getNodeType() {
-		return this.textNode.getNodeType();
-	}
+    public TextImplEx(String data) {
+        textNode = (TextImpl) DOOMAbstractFactory.getOMFactory().createText(data);
+    }
+    /*public TextImplEx(SOAPElementImpl parent, String s) throws SOAPException {
+        //super();
+        //super.setParentElement(parent);
+        OMElement par = parent.getOMElement();
+        omNode =
+        omText =
+                org.apache.axis2.om.OMAbstractFactory.getOMFactory()
+                        .createText(par, s);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Text#splitText(int)
-	 */
-	public org.w3c.dom.Text splitText(int offset) throws DOMException {
-		return this.textNode.splitText(offset);
-	}
+    public TextImplEx(org.w3c.dom.CharacterData data) {
+        if (data == null) {
+            throw new IllegalArgumentException("Text value may not be null.");
+        }
+        omText =
+                org.apache.axis2.om.OMAbstractFactory.getOMFactory()
+                        .createText(data.getData());
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.CharacterData#getData()
-	 */
-	public String getData() throws DOMException {
-		return this.textNode.getData();
-	}
+    public TextImplEx(OMText omText) {
+        omNode = this.omText = omText;
+    }*/
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.CharacterData#setData(java.lang.String)
-	 */
-	public void setData(String data) throws DOMException {
-		this.textNode.setData(data);
-	}
+    /**
+     * Retrieves whether this <CODE>Text</CODE> object
+     * represents a comment.
+     *
+     * @return <CODE>true</CODE> if this <CODE>Text</CODE> object is
+     *         a comment; <CODE>false</CODE> otherwise
+     */
+    public boolean isComment() {
+        String value = textNode.getText();
+        return value.startsWith("<!--") && value.endsWith("-->");
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.CharacterData#substringData(int, int)
-	 */
-	public String substringData(int offset, int count) throws DOMException {
-		return this.textNode.substringData(offset, count);
-	}
+    /**
+     * The name of this node, depending on its type; see the table above.
+     */
+    public String getNodeName() {
+        return textNode.getNodeName();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.CharacterData#appendData(java.lang.String)
-	 */
-	public void appendData(String value) throws DOMException {
-		this.textNode.appendData(value);
-	}
+    /**
+     * A code representing the type of the underlying object, as defined above.
+     */
+    public short getNodeType() {
+        return textNode.getNodeType();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.CharacterData#insertData(int, java.lang.String)
-	 */
-	public void insertData(int offset, String data) throws DOMException {
-		this.textNode.insertData(offset, data);
-	}
+    /**
+     * Breaks this node into two nodes at the specified <code>offset</code>,
+     * keeping both in the tree as siblings. After being split, this node
+     * will contain all the content up to the <code>offset</code> point. A
+     * new node of the same type, which contains all the content at and
+     * after the <code>offset</code> point, is returned. If the original
+     * node had a parent node, the new node is inserted as the next sibling
+     * of the original node. When the <code>offset</code> is equal to the
+     * length of this node, the new node has no data.
+     *
+     * @param offset The 16-bit unit offset at which to split, starting from
+     *               <code>0</code>.
+     * @return The new node, of the same type as this node.
+     * @throws DOMException INDEX_SIZE_ERR: Raised if the specified offset is negative or greater
+     *                      than the number of 16-bit units in <code>data</code>.
+     *                      <br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
+     */
+    public org.w3c.dom.Text splitText(int offset) throws DOMException {
+        return textNode.splitText(offset);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.CharacterData#deleteData(int, int)
-	 */
-	public void deleteData(int offset, int count) throws DOMException {
-		this.textNode.deleteData(offset, count);
-	}
+    /**
+     * The character data of the node that implements this interface. The DOM
+     * implementation may not put arbitrary limits on the amount of data
+     * that may be stored in a <code>CharacterData</code> node. However,
+     * implementation limits may mean that the entirety of a node's data may
+     * not fit into a single <code>DOMString</code>. In such cases, the user
+     * may call <code>substringData</code> to retrieve the data in
+     * appropriately sized pieces.
+     *
+     * @throws DOMException NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.
+     * @throws DOMException DOMSTRING_SIZE_ERR: Raised when it would return more characters than
+     *                      fit in a <code>DOMString</code> variable on the implementation
+     *                      platform.
+     */
+    public String getData() throws DOMException {
+        return textNode.getData();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.CharacterData#replaceData(int, int, java.lang.String)
-	 */
-	public void replaceData(int offset, int count, String data) throws DOMException {
-		this.textNode.replaceData(offset, count, data);
-	}
+    /**
+     * The character data of the node that implements this interface. The DOM
+     * implementation may not put arbitrary limits on the amount of data
+     * that may be stored in a <code>CharacterData</code> node. However,
+     * implementation limits may mean that the entirety of a node's data may
+     * not fit into a single <code>DOMString</code>. In such cases, the user
+     * may call <code>substringData</code> to retrieve the data in
+     * appropriately sized pieces.
+     *
+     * @throws DOMException NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.
+     * @throws DOMException DOMSTRING_SIZE_ERR: Raised when it would return more characters than
+     *                      fit in a <code>DOMString</code> variable on the implementation
+     *                      platform.
+     */
+    public void setData(String data) throws DOMException {
+        textNode.setData(data);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.om.impl.OMNodeEx#setParent(org.apache.axis2.om.OMContainer)
-	 */
-	public void setParent(OMContainer element) {
-		this.textNode.setParent(element);
-	}
+    /**
+     * Extracts a range of data from the node.
+     *
+     * @param offset Start offset of substring to extract.
+     * @param count  The number of 16-bit units to extract.
+     * @return The specified substring. If the sum of <code>offset</code> and
+     *         <code>count</code> exceeds the <code>length</code>, then all 16-bit
+     *         units to the end of the data are returned.
+     * @throws DOMException INDEX_SIZE_ERR: Raised if the specified <code>offset</code> is
+     *                      negative or greater than the number of 16-bit units in
+     *                      <code>data</code>, or if the specified <code>count</code> is
+     *                      negative.
+     *                      <br>DOMSTRING_SIZE_ERR: Raised if the specified range of text does
+     *                      not fit into a <code>DOMString</code>.
+     */
+    public String substringData(int offset, int count) throws DOMException {
+        return textNode.substringData(offset, count);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.om.OMNode#getParent()
-	 */
-	public OMContainer getParent() {
-		return this.textNode.getParent();
-	}
+    /**
+     * Append the string to the end of the character data of the node. Upon
+     * success, <code>data</code> provides access to the concatenation of
+     * <code>data</code> and the <code>DOMString</code> specified.
+     *
+     * @param value The <code>DOMString</code> to append.
+     * @throws DOMException NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
+     */
+    public void appendData(String value) throws DOMException {
+        textNode.appendData(value);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.om.OMNode#discard()
-	 */
-	public void discard() throws OMException {
-		this.textNode.discard();
-	}
+    /**
+     * Insert a string at the specified 16-bit unit offset.
+     *
+     * @param offset The character offset at which to insert.
+     * @param data   The <code>DOMString</code> to insert.
+     * @throws DOMException INDEX_SIZE_ERR: Raised if the specified <code>offset</code> is
+     *                      negative or greater than the number of 16-bit units in
+     *                      <code>data</code>.
+     *                      <br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
+     */
+    public void insertData(int offset, String data) throws DOMException {
+        textNode.insertData(offset, data);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.om.OMNode#serialize(org.apache.axis2.om.impl.OMOutputImpl)
-	 */
-	public void serialize(OMOutputImpl omOutput) throws XMLStreamException {
-		this.textNode.serialize(omOutput);
-	}
+    /**
+     * Remove a range of 16-bit units from the node. Upon success,
+     * <code>data</code> and <code>length</code> reflect the change.
+     *
+     * @param offset The offset from which to start removing.
+     * @param count  The number of 16-bit units to delete. If the sum of
+     *               <code>offset</code> and <code>count</code> exceeds
+     *               <code>length</code> then all 16-bit units from <code>offset</code>
+     *               to the end of the data are deleted.
+     * @throws DOMException INDEX_SIZE_ERR: Raised if the specified <code>offset</code> is
+     *                      negative or greater than the number of 16-bit units in
+     *                      <code>data</code>, or if the specified <code>count</code> is
+     *                      negative.
+     *                      <br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
+     */
+    public void deleteData(int offset, int count) throws DOMException {
+        textNode.deleteData(offset, count);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.om.OMNode#serializeAndConsume(org.apache.axis2.om.impl.OMOutputImpl)
-	 */
-	public void serializeAndConsume(OMOutputImpl omOutput) throws XMLStreamException {
-		this.textNode.serializeAndConsume(omOutput);
-	}
+    /**
+     * Replace the characters starting at the specified 16-bit unit offset
+     * with the specified string.
+     *
+     * @param offset The offset from which to start replacing.
+     * @param count  The number of 16-bit units to replace. If the sum of
+     *               <code>offset</code> and <code>count</code> exceeds
+     *               <code>length</code>, then all 16-bit units to the end of the data
+     *               are replaced; (i.e., the effect is the same as a <code>remove</code>
+     *               method call with the same range, followed by an <code>append</code>
+     *               method invocation).
+     * @param data   The <code>DOMString</code> with which the range must be
+     *               replaced.
+     * @throws DOMException INDEX_SIZE_ERR: Raised if the specified <code>offset</code> is
+     *                      negative or greater than the number of 16-bit units in
+     *                      <code>data</code>, or if the specified <code>count</code> is
+     *                      negative.
+     *                      <br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
+     */
+    public void replaceData(int offset, int count, String data) throws DOMException {
+        textNode.replaceData(offset, count, data);
+    }
 
+    /* (non-Javadoc)
+      * @see org.apache.axis2.om.impl.OMNodeEx#setParent(org.apache.axis2.om.OMContainer)
+      */
+    public void setParent(OMContainer element) {
+        textNode.setParent(element);
+    }
+
+    /* (non-Javadoc)
+      * @see org.apache.axis2.om.OMNode#getParent()
+      */
+    public OMContainer getParent() {
+        return textNode.getParent();
+    }
+
+    /* (non-Javadoc)
+      * @see org.apache.axis2.om.OMNode#discard()
+      */
+    public void discard() throws OMException {
+        textNode.discard();
+    }
+
+    /* (non-Javadoc)
+      * @see org.apache.axis2.om.OMNode#serialize(org.apache.axis2.om.impl.OMOutputImpl)
+      */
+    public void serialize(OMOutputImpl omOutput) throws XMLStreamException {
+        textNode.serialize(omOutput);
+    }
+
+    /* (non-Javadoc)
+      * @see org.apache.axis2.om.OMNode#serializeAndConsume(org.apache.axis2.om.impl.OMOutputImpl)
+      */
+    public void serializeAndConsume(OMOutputImpl omOutput) throws XMLStreamException {
+        textNode.serializeAndConsume(omOutput);
+    }
+
+    /**
+     * Retrieve the text value (data) of this
+     *
+     * @return The text value (data) of this
+     */
+    public String getValue() {
+        return textNode.getData();
+    }
+
+    public String toString(){
+        return getValue();
+    }
 }
Index: src/org/apache/axis2/saaj2/SOAPConnectionImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/SOAPConnectionImpl.java	(revision 0)
+++ src/org/apache/axis2/saaj2/SOAPConnectionImpl.java	(revision 0)
@@ -0,0 +1,216 @@
+/*                                                                             
+ * Copyright 2004,2005 The Apache Software Foundation.                         
+ *                                                                             
+ * Licensed under the Apache License, Version 2.0 (the "License");             
+ * you may not use this file except in compliance with the License.            
+ * You may obtain a copy of the License at                                     
+ *                                                                             
+ *      http://www.apache.org/licenses/LICENSE-2.0                             
+ *                                                                             
+ * Unless required by applicable law or agreed to in writing, software         
+ * distributed under the License is distributed on an "AS IS" BASIS,           
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    
+ * See the License for the specific language governing permissions and         
+ * limitations under the License.                                              
+ */
+package org.apache.axis2.saaj2;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.client.Call;
+import org.apache.axis2.client.Options;
+import org.apache.axis2.om.OMAttribute;
+import org.apache.axis2.om.OMElement;
+import org.apache.axis2.om.OMNode;
+import org.apache.axis2.om.OMText;
+import org.apache.axis2.om.impl.dom.ElementImpl;
+import org.apache.axis2.util.SessionUtils;
+
+import javax.activation.DataHandler;
+import javax.xml.namespace.QName;
+import javax.xml.soap.AttachmentPart;
+import javax.xml.soap.SOAPConnection;
+import javax.xml.soap.SOAPException;
+import javax.xml.soap.SOAPMessage;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Iterator;
+
+/**
+ * 
+ */
+public class SOAPConnectionImpl extends SOAPConnection {
+    /**
+     * Sends the given message to the specified endpoint and
+     * blocks until it has returned the response.
+     *
+     * @param request  the <CODE>SOAPMessage</CODE>
+     *                 object to be sent
+     * @param endpoint an <code>Object</code> that identifies
+     *                 where the message should be sent. It is required to
+     *                 support Objects of type
+     *                 <code>java.lang.String</code>,
+     *                 <code>java.net.URL</code>, and when JAXM is present
+     *                 <code>javax.xml.messaging.URLEndpoint</code>
+     * @return the <CODE>SOAPMessage</CODE> object that is the
+     *         response to the message that was sent
+     * @throws javax.xml.soap.SOAPException if there is a SOAP error
+     */
+    public SOAPMessage call(SOAPMessage request, Object endpoint) throws SOAPException {
+        try {
+            OMElement envelope =
+                    ((SOAPEnvelopeImpl) request.getSOAPPart().getEnvelope()).getOMEnvelope();
+
+            //parse the omEnvelope element and stuff it with the attachment
+            //specific omText nodes
+            insertAttachmentNodes(envelope, request);
+
+            Call call = new Call();
+            URL url = new URL(endpoint.toString());
+
+            Options options = new Options();
+            options.setProperty(Constants.Configuration.ENABLE_MTOM, Constants.VALUE_TRUE);
+            options.setListenerTransportProtocol(Constants.TRANSPORT_HTTP);
+            options.setTo(new EndpointReference(url.toString()));
+            call.setClientOptions(options);
+
+            String axisOp = request.getSOAPBody().getFirstChild().getNodeName();
+            NodeImplEx bodyContentNode = (NodeImplEx) request.getSOAPBody().getFirstChild();
+
+            //TODO; check this
+            ElementImpl bodyContent = ((SOAPElementImpl) bodyContentNode).getElement();
+
+            OMElement result = call.invokeBlocking(axisOp, (OMElement) bodyContent);
+            org.apache.axis2.soap.SOAPEnvelope responseEnv =
+                    (org.apache.axis2.soap.SOAPEnvelope) ((OMElement) result.getParent()).getParent();
+            SOAPEnvelopeImpl response = new SOAPEnvelopeImpl(responseEnv);
+
+            SOAPMessageImpl sMsg = new SOAPMessageImpl(response);
+            extractAttachmentNodes(responseEnv, sMsg);
+            return sMsg;
+
+        } catch (MalformedURLException mue) {
+            throw new SOAPException(mue);
+        } catch (AxisFault af) {
+            throw new SOAPException(af);
+        }
+    }
+
+    /**
+     * Closes this <CODE>SOAPConnection</CODE> object.
+     *
+     * @throws javax.xml.soap.SOAPException if there is a SOAP error
+     */
+    public void close() throws SOAPException {
+        //TODO: Method implementation
+
+    }
+
+    /**
+     * This method recursively stuffs the OMElement with appropriate OMText nodes
+     * that are prepared out of attachment contents whereever those attachments are referenced
+     *
+     * @param element
+     * @param soapMsg
+     */
+    private void insertAttachmentNodes(OMElement element, SOAPMessage soapMsg) throws SOAPException {
+        Iterator childIter = element.getChildElements();
+        while (childIter.hasNext()) {
+            OMElement child = (OMElement) childIter.next();
+            //check if there is an href attribute
+            OMAttribute hrefAttr = child.getAttribute(new QName("href"));
+            String hrefContentId = validateHref(hrefAttr);
+
+            if (hrefContentId != null) {//This is an element referencing an attachment!
+                OMText omText = getOMTextForReferencedAttachment(hrefContentId, soapMsg);
+                child.build();
+                child.removeAttribute(hrefAttr);
+                child.addChild(omText);
+
+            } else { //possibly there can be references in the children of this element
+                //so recurse through.
+                insertAttachmentNodes(child, soapMsg);
+            }
+        }
+    }
+
+    /**
+     * The method recursively looks for the binary text nodes and adds them as attachment
+     * to soapMessage at the same time removing them from soapEnv and putting appropriate
+     * contentId
+     *
+     * @param element
+     * @param soapMsg
+     */
+    private void extractAttachmentNodes(OMElement element, SOAPMessage soapMsg) {
+        Iterator childIter = element.getChildren();
+        while (childIter.hasNext()) {
+            OMNode child = (OMNode) childIter.next();
+            if (child instanceof OMText) {
+                OMText binaryNode = (OMText) child;
+                DataHandler actualDH = (DataHandler) binaryNode.getDataHandler();
+                if (actualDH != null) {
+                    AttachmentPart ap = soapMsg.createAttachmentPart(actualDH);
+                    String contentId = SessionUtils.generateSessionId();
+                    ap.setContentId(contentId);
+                    ap.setContentType(actualDH.getContentType());
+                    OMElement parent = (OMElement) child.getParent();
+                    OMAttribute attr = org.apache.axis2.om.OMAbstractFactory.getOMFactory().createOMAttribute("href", null, "cid:" + contentId);
+                    parent.addAttribute(attr);
+                    binaryNode.detach();
+                    soapMsg.addAttachmentPart(ap);
+                }
+            } else {
+                if (child instanceof OMElement) {
+                    OMElement childElement = (OMElement) child;
+                    extractAttachmentNodes(childElement, soapMsg);
+                }
+            }
+        }
+    }
+
+    /**
+     * This method checks the value of attribute and if it is a valid CID then
+     * returns the contentID (with cid: prefix stripped off) or else returns null.
+     * A null return value can be assumed that this attribute is not an attachment
+     * referencing attribute
+     */
+    private String validateHref(OMAttribute attr) {
+        String contentId;
+        if (attr != null) {
+            contentId = attr.getAttributeValue();
+        } else {
+            return null;
+        }
+
+        if (contentId.startsWith("cid:")) {
+            contentId = contentId.substring(4);
+            return contentId;
+        }
+        return null;
+    }
+
+    /**
+     * This method looks up the attachment part corresponding to the given contentId and
+     * returns the OMText node thta has the content of the attachment.
+     *
+     * @param contentId
+     * @param soapMsg
+     * @return OMText
+     */
+    private OMText getOMTextForReferencedAttachment(String contentId, SOAPMessage soapMsg) throws SOAPException {
+        Iterator attachIter = soapMsg.getAttachments();
+        while (attachIter.hasNext()) {
+            AttachmentPart attachment = (AttachmentPart) attachIter.next();
+            if (attachment.getContentId().equals(contentId)) {
+                try {
+                    return ((AttachmentPartImpl) attachment).getOMText();
+                } catch (Exception e) {
+                    throw new SOAPException(e);
+                }
+            }
+        }
+        throw new SOAPException("No attachment found with the given contentID");
+    }
+}
Index: src/org/apache/axis2/saaj2/NodeImplEx.java
===================================================================
--- src/org/apache/axis2/saaj2/NodeImplEx.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/NodeImplEx.java	(working copy)
@@ -15,77 +15,137 @@
  */
 package org.apache.axis2.saaj2;
 
-import javax.xml.soap.Node;
-import javax.xml.soap.SOAPElement;
-import javax.xml.soap.SOAPException;
-
 import org.apache.axis2.om.OMContainer;
 import org.apache.axis2.om.OMElement;
 import org.apache.axis2.om.OMException;
 import org.apache.axis2.om.OMNode;
 import org.apache.axis2.om.impl.dom.NodeImpl;
 
+import javax.xml.soap.Node;
+import javax.xml.soap.SOAPElement;
+import javax.xml.soap.SOAPException;
+import java.util.Iterator;
+
+/**
+ * A representation of a node (element) in a DOM representation of an XML document
+ * that provides some tree manipulation methods.
+ * This interface provides methods for getting the value of a node, for
+ * getting and setting the parent of a node, and for removing a node.
+ */
 public abstract class NodeImplEx extends NodeImpl implements Node {
 
-	private SOAPElement parentElement;
-	
-	public void detachNode() {
-		this.detach();
-	}
+    private SOAPElement parentElement;
 
-	public SOAPElement getParentElement() {
-		return this.parentElement;
-	}
-	
-	public OMContainer getParent() {
-		return (OMContainer)this.parentElement;
-	}
+    /**
+     * Removes this <code>Node</code> object from the tree. Once
+     * removed, this node can be garbage collected if there are no
+     * application references to it.
+     */
+    public void detachNode() {
+        this.detach();
+    }
 
-	public String getValue() {
-		if(this.getNodeType() == Node.TEXT_NODE) {
-			return this.getNodeValue();
-		} else if(this.getType() == Node.TEXT_NODE) {
-			return ((NodeImplEx)(((OMElement)this).getFirstOMChild())).getValue();
-		} else {
-			return null;
-		}
-	}
+    /**
+     * Removes this <code>Node</code> object from the tree. Once
+     * removed, this node can be garbage collected if there are no
+     * application references to it.
+     */
+    public SOAPElement getParentElement() {
+        return this.parentElement;
+    }
 
-	public void recycleNode() {
+    public OMContainer getParent() {
+        return (OMContainer) this.parentElement;
+    }
+
+    /* public OMNode getOMNode() {
+        return omNode;
+    }*/
+
+    /**
+     * Returns the the value of the immediate child of this <code>Node</code>
+     * object if a child exists and its valu e is text.
+     *
+     * @return a <code>String</code> with the text of the immediate child of
+     *         this <code>Node</code> object if (1) there is a child and
+     *         (2) the child is a <code>Text</code> object;
+     *         <code>null</code> otherwise
+     */
+    public String getValue() {
+        if (this.getNodeType() == Node.TEXT_NODE) {
+            return this.getNodeValue();
+        } else if (this.getNodeType() == Node.ELEMENT_NODE) {
+            return ((NodeImplEx) (((OMElement) this).getFirstOMChild())).getValue();
+        }
+        return null;
+    }
+
+    /**
+     * Notifies the implementation that this <code>Node</code>
+     * object is no longer being used by the application and that the
+     * implementation is free to reuse this object for nodes that may
+     * be created later.
+     * <p/>
+     * Calling the method <code>recycleNode</code> implies that the method
+     * <code>detachNode</code> has been called previously.
+     */
+    public void recycleNode() {
         // No corresponding implementation in OM
         // There is no implementation in Axis 1.2 also
-	}
+    }
 
-	public void setParentElement(SOAPElement parent) throws SOAPException {
-		this.parentElement = parent;
-	}
+    /**
+     * Sets the parent of this <code>Node</code> object to the given
+     * <code>SOAPElement</code> object.
+     *
+     * @param parent the <code>SOAPElement</code> object to be set as
+     *               the parent of this <code>Node</code> object
+     * @throws SOAPException if there is a problem in setting the
+     *                       parent to the given element
+     * @see #getParentElement() getParentElement()
+     */
+    public void setParentElement(SOAPElement parent) throws SOAPException {
+        this.parentElement = parent;
+    }
 
-	public void setValue(String value) {
-		if(this.getNodeType() == Node.TEXT_NODE) {
-			this.setNodeValue(value);
-		} else if(this.getNodeType() == Node.ELEMENT_NODE) {
-			OMElement elem = ((OMElement)this);
-			OMNode firstChild = elem.getFirstOMChild();
-			if(firstChild == null ||
-				(((Node)firstChild).getNodeType() == Node.TEXT_NODE && firstChild.getNextOMSibling() == null)) {
-				//If there are no children OR
-				//the first child is a text node and the only child
+    /**
+     * If this is a Text node then this method will set its value, otherwise it
+     * sets the value of the immediate (Text) child of this node. The value of
+     * the immediate child of this node can be set only if, there is one child
+     * node and that node is a Text node, or if there are no children in which
+     * case a child Text node will be created.
+     *
+     * @param value the text to set
+     * @throws IllegalStateException if the node is not a Text  node and
+     *                               either has more than one child node or has a child node that
+     *                               is not a Text node
+     */
+    public void setValue(String value) {
+        if (this.getNodeType() == Node.TEXT_NODE) {
+            this.setNodeValue(value);
+        } else if (this.getNodeType() == Node.ELEMENT_NODE) {
+            OMElement elem = ((OMElement) this);
+            OMNode firstChild = elem.getFirstOMChild();
+            if (firstChild == null ||
+                (((Node) firstChild).getNodeType() == Node.TEXT_NODE && firstChild.getNextOMSibling() == null))
+            {
+                //If there are no children OR
+                //the first child is a text node and the only child
 
-				((OMElement)this).setText(value);				
-			} else {
-				throw new IllegalStateException("This node is not a Text  node and either has more than one child node or has a child node that is not a Text node");
-			}
-			
-			
-		}
-	}
+                ((OMElement) this).setText(value);
+            } else {
+                throw new IllegalStateException("This node is not a Text  node and either has more than one child node or has a child node that is not a Text node");
+            }
 
-	public void setType(int nodeType) throws OMException {
-		throw new UnsupportedOperationException("TODO");
-	}
 
-	public int getType() {
-		return this.getNodeType();
-	}
+        }
+    }
 
+    public void setType(int nodeType) throws OMException {
+        throw new UnsupportedOperationException("TODO");
+    }
+
+    public int getType() {
+        return this.getNodeType();
+    }
 }
Index: src/org/apache/axis2/saaj2/DetailEntryImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/DetailEntryImpl.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/DetailEntryImpl.java	(working copy)
@@ -15,17 +15,22 @@
  */
 package org.apache.axis2.saaj2;
 
+import org.apache.axis2.om.impl.dom.ElementImpl;
+
 import javax.xml.soap.DetailEntry;
 
-import org.apache.axis2.om.impl.dom.ElementImpl;
-
+/**
+ * The content for a Detail object, giving details for a SOAPFault object.
+ * A DetailEntry object, which carries information about errors related to the
+ * SOAPBody  object that contains it, is application-specific.
+ */
 public class DetailEntryImpl extends SOAPElementImpl implements DetailEntry {
 
-	/**
-	 * @param element
-	 */
-	public DetailEntryImpl(ElementImpl element) {
-		super(element);
-	}
+    /**
+     * @param element
+     */
+    public DetailEntryImpl(ElementImpl element) {
+        super(element);
+    }
 
 }
Index: src/org/apache/axis2/saaj2/SOAPHeaderElementImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/SOAPHeaderElementImpl.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/SOAPHeaderElementImpl.java	(working copy)
@@ -15,48 +15,83 @@
  */
 package org.apache.axis2.saaj2;
 
-import javax.xml.soap.SOAPHeaderElement;
-
 import org.apache.axis2.om.impl.dom.ElementImpl;
 import org.apache.axis2.soap.SOAPHeaderBlock;
 
-public class SOAPHeaderElementImpl extends SOAPElementImpl implements
-		SOAPHeaderElement {
+import javax.xml.soap.SOAPHeaderElement;
 
-	SOAPHeaderBlock headerElem;
-	/**
-	 * @param element
-	 */
-	public SOAPHeaderElementImpl(SOAPHeaderBlock element) {
-		super((ElementImpl)element);
-	}
+public class SOAPHeaderElementImpl extends SOAPElementImpl implements SOAPHeaderElement {
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPHeaderElement#setActor(java.lang.String)
-	 */
-	public void setActor(String actorURI) {
-		this.headerElem.setRole(actorURI);
-	}
+    private SOAPHeaderBlock headerElem;
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPHeaderElement#getActor()
-	 */
-	public String getActor() {
-		return this.headerElem.getRole();
-	}
+    /**
+     * @param element
+     */
+    public SOAPHeaderElementImpl(SOAPHeaderBlock element) {
+        super((ElementImpl) element);
+        this.headerElem = element;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPHeaderElement#setMustUnderstand(boolean)
-	 */
-	public void setMustUnderstand(boolean mustUnderstand) {
-		this.headerElem.setMustUnderstand(mustUnderstand);
-	}
+    /**
+     * Sets the actor associated with this <CODE>
+     * SOAPHeaderElement</CODE> object to the specified actor. The
+     * default value of an actor is: <CODE>
+     * SOAPConstants.URI_SOAP_ACTOR_NEXT</CODE>
+     *
+     * @param actorURI a <CODE>String</CODE> giving
+     *                 the URI of the actor to set
+     * @throws java.lang.IllegalArgumentException
+     *          if
+     *          there is a problem in setting the actor.
+     * @see #getActor() getActor()
+     */
+    public void setActor(String actorURI) {
+        this.headerElem.setRole(actorURI);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPHeaderElement#getMustUnderstand()
-	 */
-	public boolean getMustUnderstand() {
-		return this.headerElem.getMustUnderstand();
-	}
+    /**
+     * Returns the uri of the actor associated with this <CODE>
+     * SOAPHeaderElement</CODE> object.
+     *
+     * @return a <CODE>String</CODE> giving the URI of the
+     *         actor
+     * @see #setActor(java.lang.String) setActor(java.lang.String)
+     */
+    public String getActor() {
+        return this.headerElem.getRole();
+    }
 
+    /**
+     * Sets the mustUnderstand attribute for this <CODE>
+     * SOAPHeaderElement</CODE> object to be on or off.
+     * <p/>
+     * <P>If the mustUnderstand attribute is on, the actor who
+     * receives the <CODE>SOAPHeaderElement</CODE> must process it
+     * correctly. This ensures, for example, that if the <CODE>
+     * SOAPHeaderElement</CODE> object modifies the message, that
+     * the message is being modified correctly.</P>
+     *
+     * @param mustUnderstand <CODE>true</CODE> to
+     *                       set the mustUnderstand attribute on; <CODE>false</CODE>
+     *                       to turn if off
+     * @throws java.lang.IllegalArgumentException
+     *          if
+     *          there is a problem in setting the actor.
+     * @see #getMustUnderstand() getMustUnderstand()
+     */
+    public void setMustUnderstand(boolean mustUnderstand) {
+        this.headerElem.setMustUnderstand(mustUnderstand);
+    }
+
+    /**
+     * Returns whether the mustUnderstand attribute for this
+     * <CODE>SOAPHeaderElement</CODE> object is turned on.
+     *
+     * @return <CODE>true</CODE> if the mustUnderstand attribute of
+     *         this <CODE>SOAPHeaderElement</CODE> object is turned on;
+     *         <CODE>false</CODE> otherwise
+     */
+    public boolean getMustUnderstand() {
+        return this.headerElem.getMustUnderstand();
+    }
 }
Index: src/org/apache/axis2/saaj2/SOAPPartImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/SOAPPartImpl.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/SOAPPartImpl.java	(working copy)
@@ -15,19 +15,8 @@
  */
 package org.apache.axis2.saaj2;
 
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.util.Iterator;
-
-import javax.xml.soap.SOAPEnvelope;
-import javax.xml.soap.SOAPException;
-import javax.xml.soap.SOAPPart;
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.transform.Source;
-
 import org.apache.axis2.om.impl.dom.DocumentImpl;
-import org.apache.axis2.saaj.SOAPEnvelopeImpl;
-import org.apache.axis2.soap.impl.dom.factory.DOMSOAPFactory;
+import org.apache.axis2.soap.impl.dom.soap11.SOAP11Factory;
 import org.apache.axis2.soap.impl.llom.builder.StAXSOAPModelBuilder;
 import org.apache.axis2.transport.http.HTTPConstants;
 import org.apache.axis2.util.SessionUtils;
@@ -47,416 +36,1064 @@
 import org.w3c.dom.ProcessingInstruction;
 import org.w3c.dom.Text;
 
+import javax.xml.soap.SOAPEnvelope;
+import javax.xml.soap.SOAPException;
+import javax.xml.soap.SOAPMessage;
+import javax.xml.soap.SOAPPart;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.transform.Source;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.Iterator;
+
 public class SOAPPartImpl extends SOAPPart {
-	
-	Document document = new DocumentImpl();
-	SOAPMessageImpl msgObject;
-	MimeHeadersEx mimeHeaders = new MimeHeadersEx();
-	private Object envelope;
-	
 
-	public SOAPPartImpl(SOAPMessageImpl parent, Object initialContents)  throws SOAPException {
-        setMimeHeader(HTTPConstants.HEADER_CONTENT_ID,
-                SessionUtils.generateSessionId());
+    private Document document;
+    private SOAPMessage soapMessage;
+    private SOAPEnvelopeImpl envelope;
+    private MimeHeadersEx mimeHeaders = new MimeHeadersEx();
+
+
+    public SOAPPartImpl(SOAPMessageImpl parentSoapMsg,
+                        SOAPEnvelopeImpl soapEnvelope) {
+
+        setMimeHeader(HTTPConstants.HEADER_CONTENT_ID, SessionUtils.generateSessionId());
         setMimeHeader(HTTPConstants.HEADER_CONTENT_TYPE, "text/xml");
-        
-        StAXSOAPModelBuilder stAXSOAPModelBuilder;
 
-        msgObject = parent;
+        soapMessage = parentSoapMsg;
+        envelope = soapEnvelope;
+        this.document = soapEnvelope.getOwnerDocument();
+    }
+
+    public SOAPPartImpl(SOAPMessageImpl parentSoapMsg,
+                        InputStream inputStream) throws SOAPException {
+
+        setMimeHeader(HTTPConstants.HEADER_CONTENT_ID, SessionUtils.generateSessionId());
+        setMimeHeader(HTTPConstants.HEADER_CONTENT_TYPE, "text/xml");
+
+        soapMessage = parentSoapMsg;
+
         try {
-            if (initialContents instanceof SOAPEnvelope) {
-                ((SOAPEnvelopeImpl) initialContents).setOwnerDocument(this);
-                envelope = initialContents;
-            }else if (initialContents instanceof InputStream) {
-                //XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader((InputStream)initialContents);
-                InputStreamReader inr = new InputStreamReader(
-                        (InputStream) initialContents);
-                
-                stAXSOAPModelBuilder =
-                    new StAXSOAPModelBuilder(XMLInputFactory.newInstance()
-                            .createXMLStreamReader(inr), new DOMSOAPFactory(), null);
-                org.apache.axis2.soap.SOAPEnvelope omEnv = stAXSOAPModelBuilder.getSOAPEnvelope();
-                ///TODO ave to complete SOAP Env
-            }
-        } catch (Exception e) {
+            InputStreamReader isReader = new InputStreamReader(inputStream);
+
+            StAXSOAPModelBuilder builder =
+                    new StAXSOAPModelBuilder(XMLInputFactory.newInstance().createXMLStreamReader(isReader),
+                                             new SOAP11Factory(),
+                                             null);
+            org.apache.axis2.soap.SOAPEnvelope soapEnvelope = builder.getSOAPEnvelope();
+            envelope = new SOAPEnvelopeImpl(soapEnvelope);
+            this.document = envelope.getOwnerDocument();
+        } catch (XMLStreamException e) {
+            e.printStackTrace();
             throw new SOAPException(e);
         }
-	}
-	
-	
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPPart#getEnvelope()
-	 */
-	public SOAPEnvelope getEnvelope() throws SOAPException {
-		return (SOAPEnvelope)this.envelope;
-	}
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPPart#removeMimeHeader(java.lang.String)
-	 */
-	public void removeMimeHeader(String header) {
-		this.mimeHeaders.removeHeader(header);
-	}
+    /**
+     * Obtain the SOAPMessage
+     *
+     * @return the related SOAPMessage
+     */
+    public SOAPMessage getSoapMessage() {
+        return soapMessage;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPPart#removeAllMimeHeaders()
-	 */
-	public void removeAllMimeHeaders() {
-		this.mimeHeaders.removeAllHeaders();
-	}
+    /**
+     * Gets the <CODE>SOAPEnvelope</CODE> object associated with
+     * this <CODE>SOAPPart</CODE> object. Once the SOAP envelope is
+     * obtained, it can be used to get its contents.
+     *
+     * @return the <CODE>SOAPEnvelope</CODE> object for this <CODE>
+     *         SOAPPart</CODE> object
+     * @throws SOAPException if there is a SOAP error
+     */
+    public SOAPEnvelope getEnvelope() throws SOAPException {
+        return envelope;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPPart#getMimeHeader(java.lang.String)
-	 */
-	public String[] getMimeHeader(String name) {
-		return this.mimeHeaders.getHeader(name);
-	}
+    /**
+     * Removes all MIME headers that match the given name.
+     *
+     * @param header a <CODE>String</CODE> giving
+     *               the name of the MIME header(s) to be removed
+     */
+    public void removeMimeHeader(String header) {
+        mimeHeaders.removeHeader(header);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPPart#setMimeHeader(java.lang.String, java.lang.String)
-	 */
-	public void setMimeHeader(String name, String value) {
-		this.mimeHeaders.setHeader(name, value);
-	}
+    /**
+     * Removes all the <CODE>MimeHeader</CODE> objects for this
+     * <CODE>SOAPEnvelope</CODE> object.
+     */
+    public void removeAllMimeHeaders() {
+        mimeHeaders.removeAllHeaders();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPPart#addMimeHeader(java.lang.String, java.lang.String)
-	 */
-	public void addMimeHeader(String header, String value) {
-		this.mimeHeaders.addHeader(header, value);
-	}
+    /**
+     * Gets all the values of the <CODE>MimeHeader</CODE> object
+     * in this <CODE>SOAPPart</CODE> object that is identified by
+     * the given <CODE>String</CODE>.
+     *
+     * @param name the name of the header; example:
+     *             "Content-Type"
+     * @return a <CODE>String</CODE> array giving all the values for
+     *         the specified header
+     * @see #setMimeHeader(java.lang.String, java.lang.String) setMimeHeader(java.lang.String, java.lang.String)
+     */
+    public String[] getMimeHeader(String name) {
+        return mimeHeaders.getHeader(name);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPPart#getAllMimeHeaders()
-	 */
-	public Iterator getAllMimeHeaders() {
-		return this.mimeHeaders.getAllHeaders();
-	}
+    /**
+     * Changes the first header entry that matches the given
+     * header name so that its value is the given value, adding a
+     * new header with the given name and value if no existing
+     * header is a match. If there is a match, this method clears
+     * all existing values for the first header that matches and
+     * sets the given value instead. If more than one header has
+     * the given name, this method removes all of the matching
+     * headers after the first one.
+     * <p/>
+     * <P>Note that RFC822 headers can contain only US-ASCII
+     * characters.</P>
+     *
+     * @param name  a <CODE>String</CODE> giving the
+     *              header name for which to search
+     * @param value a <CODE>String</CODE> giving the
+     *              value to be set. This value will be substituted for the
+     *              current value(s) of the first header that is a match if
+     *              there is one. If there is no match, this value will be
+     *              the value for a new <CODE>MimeHeader</CODE> object.
+     * @throws java.lang.IllegalArgumentException
+     *          if
+     *          there was a problem with the specified mime header name
+     *          or value
+     * @throws java.lang.IllegalArgumentException
+     *          if there was a problem with the specified mime header name or value
+     * @see #getMimeHeader(java.lang.String) getMimeHeader(java.lang.String)
+     */
+    public void setMimeHeader(String name, String value) {
+        mimeHeaders.setHeader(name, value);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPPart#getMatchingMimeHeaders(java.lang.String[])
-	 */
-	public Iterator getMatchingMimeHeaders(String[] names) {
-		return this.mimeHeaders.getMatchingHeaders(names);
-	}
+    /**
+     * Creates a <CODE>MimeHeader</CODE> object with the specified
+     * name and value and adds it to this <CODE>SOAPPart</CODE>
+     * object. If a <CODE>MimeHeader</CODE> with the specified
+     * name already exists, this method adds the specified value
+     * to the already existing value(s).
+     * <p/>
+     * <P>Note that RFC822 headers can contain only US-ASCII
+     * characters.</P>
+     *
+     * @param header a <CODE>String</CODE> giving the
+     *               header name
+     * @param value  a <CODE>String</CODE> giving the
+     *               value to be set or added
+     * @throws IllegalArgumentException if
+     *                                  there was a problem with the specified mime header name
+     *                                  or value
+     */
+    public void addMimeHeader(String header, String value) {
+        mimeHeaders.addHeader(header, value);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPPart#getNonMatchingMimeHeaders(java.lang.String[])
-	 */
-	public Iterator getNonMatchingMimeHeaders(String[] names) {
-		return this.mimeHeaders.getNonMatchingHeaders(names);
-	}
+    /**
+     * Retrieves all the headers for this <CODE>SOAPPart</CODE>
+     * object as an iterator over the <CODE>MimeHeader</CODE>
+     * objects.
+     *
+     * @return an <CODE>Iterator</CODE> object with all of the Mime
+     *         headers for this <CODE>SOAPPart</CODE> object
+     */
+    public Iterator getAllMimeHeaders() {
+        return mimeHeaders.getAllHeaders();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPPart#setContent(javax.xml.transform.Source)
-	 */
-	public void setContent(Source source) throws SOAPException {
-		throw new UnsupportedOperationException("TODO");
-	}
+    /**
+     * Retrieves all <CODE>MimeHeader</CODE> objects that match
+     * a name in the given array.
+     *
+     * @param names a <CODE>String</CODE> array with
+     *              the name(s) of the MIME headers to be returned
+     * @return all of the MIME headers that match one of the names
+     *         in the given array, returned as an <CODE>Iterator</CODE>
+     *         object
+     */
+    public Iterator getMatchingMimeHeaders(String[] names) {
+        return mimeHeaders.getMatchingHeaders(names);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPPart#getContent()
-	 */
-	public Source getContent() throws SOAPException {
-		throw new UnsupportedOperationException("TODO");
-	}
+    /**
+     * Retrieves all <CODE>MimeHeader</CODE> objects whose name
+     * does not match a name in the given array.
+     *
+     * @param names a <CODE>String</CODE> array with
+     *              the name(s) of the MIME headers not to be returned
+     * @return all of the MIME headers in this <CODE>SOAPPart</CODE>
+     *         object except those that match one of the names in the
+     *         given array. The nonmatching MIME headers are returned as
+     *         an <CODE>Iterator</CODE> object.
+     */
+    public Iterator getNonMatchingMimeHeaders(String[] names) {
+        return mimeHeaders.getNonMatchingHeaders(names);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#getDoctype()
-	 */
-	public DocumentType getDoctype() {
-		return this.document.getDoctype();
-	}
+    /**
+     * Sets the content of the <CODE>SOAPEnvelope</CODE> object
+     * with the data from the given <CODE>Source</CODE> object.
+     *
+     * @param source javax.xml.transform.Source</CODE> object with the data to
+     *               be set
+     * @throws SOAPException if there is a problem in
+     *                       setting the source
+     * @see #getContent() getContent()
+     */
+    public void setContent(Source source) throws SOAPException {
+        //TODO: implementation
+        throw new UnsupportedOperationException("TODO");
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#getImplementation()
-	 */
-	public DOMImplementation getImplementation() {
-		return this.document.getImplementation();
-	}
+    /**
+     * Returns the content of the SOAPEnvelope as a JAXP <CODE>
+     * Source</CODE> object.
+     *
+     * @return the content as a <CODE>
+     *         javax.xml.transform.Source</CODE> object
+     * @throws SOAPException if the implementation cannot
+     *                       convert the specified <CODE>Source</CODE> object
+     * @see #setContent(javax.xml.transform.Source) setContent(javax.xml.transform.Source)
+     */
+    public Source getContent() throws SOAPException {
+        //TODO: implementation
+        throw new UnsupportedOperationException("TODO");
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#getDocumentElement()
-	 */
-	public Element getDocumentElement() {
-		return this.document.getDocumentElement();
-	}
+    /**
+     * The Document Type Declaration (see <code>DocumentType</code>)
+     * associated with this document. For HTML documents as well as XML
+     * documents without a document type declaration this returns
+     * <code>null</code>. The DOM Level 2 does not support editing the
+     * Document Type Declaration. <code>docType</code> cannot be altered in
+     * any way, including through the use of methods inherited from the
+     * <code>Node</code> interface, such as <code>insertNode</code> or
+     * <code>removeNode</code>.
+     */
+    public DocumentType getDoctype() {
+        return document.getDoctype();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#createElement(java.lang.String)
-	 */
-	public Element createElement(String arg0) throws DOMException {
-		return this.document.createElement(arg0);
-	}
+    /**
+     * The <code>DOMImplementation</code> object that handles this document. A
+     * DOM application may use objects from multiple implementations.
+     */
+    public DOMImplementation getImplementation() {
+        return document.getImplementation();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#createDocumentFragment()
-	 */
-	public DocumentFragment createDocumentFragment() {
-		return this.document.createDocumentFragment();
-	}
+    /**
+     * This is a convenience attribute that allows direct access to the child
+     * node that is the root element of the document. For HTML documents,
+     * this is the element with the tagName "HTML".
+     */
+    public Element getDocumentElement() {
+        return document.getDocumentElement();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#createTextNode(java.lang.String)
-	 */
-	public Text createTextNode(String arg0) {
-		return this.document.createTextNode(arg0);
-	}
+    /**
+     * Creates an element of the type specified. Note that the instance
+     * returned implements the <code>Element</code> interface, so attributes
+     * can be specified directly on the returned object.
+     * <br>In addition, if there are known attributes with default values,
+     * <code>Attr</code> nodes representing them are automatically created
+     * and attached to the element.
+     * <br>To create an element with a qualified name and namespace URI, use
+     * the <code>createElementNS</code> method.
+     *
+     * @param tagName The name of the element type to instantiate. For XML,
+     *                this is case-sensitive. For HTML, the <code>tagName</code>
+     *                parameter may be provided in any case, but it must be mapped to the
+     *                canonical uppercase form by the DOM implementation.
+     * @return A new <code>Element</code> object with the
+     *         <code>nodeName</code> attribute set to <code>tagName</code>, and
+     *         <code>localName</code>, <code>prefix</code>, and
+     *         <code>namespaceURI</code> set to <code>null</code>.
+     * @throws DOMException INVALID_CHARACTER_ERR: Raised if the specified name contains an
+     *                      illegal character.
+     */
+    public Element createElement(String tagName) throws DOMException {
+        return document.createElement(tagName);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#createComment(java.lang.String)
-	 */
-	public Comment createComment(String arg0) {
-		return this.document.createComment(arg0);
-	}
+    /**
+     * Creates an empty <code>DocumentFragment</code> object.
+     *
+     * @return A new <code>DocumentFragment</code>.
+     */
+    public DocumentFragment createDocumentFragment() {
+        return document.createDocumentFragment();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#createCDATASection(java.lang.String)
-	 */
-	public CDATASection createCDATASection(String arg0) throws DOMException {
-		return this.document.createCDATASection(arg0);
-	}
+    /**
+     * Creates a <code>Text</code> node given the specified string.
+     *
+     * @param data The data for the node.
+     * @return The new <code>Text</code> object.
+     */
+    public Text createTextNode(String data) {
+        return document.createTextNode(data);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#createProcessingInstruction(java.lang.String, java.lang.String)
-	 */
-	public ProcessingInstruction createProcessingInstruction(String arg0, String arg1) throws DOMException {
-		return this.document.createProcessingInstruction(arg0,arg1);
-	}
+    /**
+     * Creates a <code>CDATASection</code> node whose value is the specified
+     * string.
+     *
+     * @param data The data for the <code>CDATASection</code> contents.
+     * @return The new <code>CDATASection</code> object.
+     * @throws DOMException NOT_SUPPORTED_ERR: Raised if this document is an HTML document.
+     */
+    public Comment createComment(String data) {
+        return document.createComment(data);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#createAttribute(java.lang.String)
-	 */
-	public Attr createAttribute(String arg0) throws DOMException {
-		return this.document.createAttribute(arg0);
-	}
+    /**
+     * Creates a <code>CDATASection</code> node whose value is the specified
+     * string.
+     *
+     * @param data The data for the <code>CDATASection</code> contents.
+     * @return The new <code>CDATASection</code> object.
+     * @throws DOMException NOT_SUPPORTED_ERR: Raised if this document is an HTML document.
+     */
+    public CDATASection createCDATASection(String data) throws DOMException {
+        return document.createCDATASection(data);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#createEntityReference(java.lang.String)
-	 */
-	public EntityReference createEntityReference(String arg0) throws DOMException {
-		return this.document.createEntityReference(arg0);
-	}
+    /**
+     * Creates a <code>ProcessingInstruction</code> node given the specified
+     * name and data strings.
+     *
+     * @param target The target part of the processing instruction.
+     * @param data   The data for the node.
+     * @return The new <code>ProcessingInstruction</code> object.
+     * @throws DOMException INVALID_CHARACTER_ERR: Raised if the specified target contains an
+     *                      illegal character.
+     *                      <br>NOT_SUPPORTED_ERR: Raised if this document is an HTML document.
+     */
+    public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {
+        return document.createProcessingInstruction(target, data);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#getElementsByTagName(java.lang.String)
-	 */
-	public NodeList getElementsByTagName(String arg0) {
-		return this.document.getElementsByTagName(arg0);
-	}
+    /**
+     * Creates an <code>Attr</code> of the given name. Note that the
+     * <code>Attr</code> instance can then be set on an <code>Element</code>
+     * using the <code>setAttributeNode</code> method.
+     * <br>To create an attribute with a qualified name and namespace URI, use
+     * the <code>createAttributeNS</code> method.
+     *
+     * @param name The name of the attribute.
+     * @return A new <code>Attr</code> object with the <code>nodeName</code>
+     *         attribute set to <code>name</code>, and <code>localName</code>,
+     *         <code>prefix</code>, and <code>namespaceURI</code> set to
+     *         <code>null</code>. The value of the attribute is the empty string.
+     * @throws DOMException INVALID_CHARACTER_ERR: Raised if the specified name contains an
+     *                      illegal character.
+     */
+    public Attr createAttribute(String name) throws DOMException {
+        return document.createAttribute(name);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#importNode(org.w3c.dom.Node, boolean)
-	 */
-	public Node importNode(Node arg0, boolean arg1) throws DOMException {
-		return this.document.importNode(arg0, arg1);
-	}
+    /**
+     * Creates an <code>EntityReference</code> object. In addition, if the
+     * referenced entity is known, the child list of the
+     * <code>EntityReference</code> node is made the same as that of the
+     * corresponding <code>Entity</code> node.If any descendant of the
+     * <code>Entity</code> node has an unbound namespace prefix, the
+     * corresponding descendant of the created <code>EntityReference</code>
+     * node is also unbound; (its <code>namespaceURI</code> is
+     * <code>null</code>). The DOM Level 2 does not support any mechanism to
+     * resolve namespace prefixes.
+     *
+     * @param name The name of the entity to reference.
+     * @return The new <code>EntityReference</code> object.
+     * @throws DOMException INVALID_CHARACTER_ERR: Raised if the specified name contains an
+     *                      illegal character.
+     *                      <br>NOT_SUPPORTED_ERR: Raised if this document is an HTML document.
+     */
+    public EntityReference createEntityReference(String name) throws DOMException {
+        return document.createEntityReference(name);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#createElementNS(java.lang.String, java.lang.String)
-	 */
-	public Element createElementNS(String arg0, String arg1) throws DOMException {
-		return this.document.createElementNS(arg0, arg1);
-	}
+    /**
+     * Returns a <code>NodeList</code> of all the <code>Elements</code> with a
+     * given tag name in the order in which they are encountered in a
+     * preorder traversal of the <code>Document</code> tree.
+     *
+     * @param tagname The name of the tag to match on. The special value "*"
+     *                matches all tags.
+     * @return A new <code>NodeList</code> object containing all the matched
+     *         <code>Elements</code>.
+     */
+    public NodeList getElementsByTagName(String tagname) {
+        return document.getElementsByTagName(tagname);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#createAttributeNS(java.lang.String, java.lang.String)
-	 */
-	public Attr createAttributeNS(String arg0, String arg1) throws DOMException {
-		return this.document.createAttributeNS(arg0, arg1);
-	}
+    /**
+     * Imports a node from another document to this document. The returned
+     * node has no parent; (<code>parentNode</code> is <code>null</code>).
+     * The source node is not altered or removed from the original document;
+     * this method creates a new copy of the source node.
+     * <br>For all nodes, importing a node creates a node object owned by the
+     * importing document, with attribute values identical to the source
+     * node's <code>nodeName</code> and <code>nodeType</code>, plus the
+     * attributes related to namespaces (<code>prefix</code>,
+     * <code>localName</code>, and <code>namespaceURI</code>). As in the
+     * <code>cloneNode</code> operation on a <code>Node</code>, the source
+     * node is not altered.
+     * <br>Additional information is copied as appropriate to the
+     * <code>nodeType</code>, attempting to mirror the behavior expected if
+     * a fragment of XML or HTML source was copied from one document to
+     * another, recognizing that the two documents may have different DTDs
+     * in the XML case. The following list describes the specifics for each
+     * type of node.
+     * <dl>
+     * <dt>ATTRIBUTE_NODE</dt>
+     * <dd>The <code>ownerElement</code> attribute
+     * is set to <code>null</code> and the <code>specified</code> flag is
+     * set to <code>true</code> on the generated <code>Attr</code>. The
+     * descendants of the source <code>Attr</code> are recursively imported
+     * and the resulting nodes reassembled to form the corresponding subtree.
+     * Note that the <code>deep</code> parameter has no effect on
+     * <code>Attr</code> nodes; they always carry their children with them
+     * when imported.</dd>
+     * <dt>DOCUMENT_FRAGMENT_NODE</dt>
+     * <dd>If the <code>deep</code> option
+     * was set to <code>true</code>, the descendants of the source element
+     * are recursively imported and the resulting nodes reassembled to form
+     * the corresponding subtree. Otherwise, this simply generates an empty
+     * <code>DocumentFragment</code>.</dd>
+     * <dt>DOCUMENT_NODE</dt>
+     * <dd><code>Document</code>
+     * nodes cannot be imported.</dd>
+     * <dt>DOCUMENT_TYPE_NODE</dt>
+     * <dd><code>DocumentType</code>
+     * nodes cannot be imported.</dd>
+     * <dt>ELEMENT_NODE</dt>
+     * <dd>Specified attribute nodes of the
+     * source element are imported, and the generated <code>Attr</code>
+     * nodes are attached to the generated <code>Element</code>. Default
+     * attributes are not copied, though if the document being imported into
+     * defines default attributes for this element name, those are assigned.
+     * If the <code>importNode</code> <code>deep</code> parameter was set to
+     * <code>true</code>, the descendants of the source element are
+     * recursively imported and the resulting nodes reassembled to form the
+     * corresponding subtree.</dd>
+     * <dt>ENTITY_NODE</dt>
+     * <dd><code>Entity</code> nodes can be
+     * imported, however in the current release of the DOM the
+     * <code>DocumentType</code> is readonly. Ability to add these imported
+     * nodes to a <code>DocumentType</code> will be considered for addition
+     * to a future release of the DOM.On import, the <code>publicId</code>,
+     * <code>systemId</code>, and <code>notationName</code> attributes are
+     * copied. If a <code>deep</code> import is requested, the descendants
+     * of the the source <code>Entity</code> are recursively imported and
+     * the resulting nodes reassembled to form the corresponding subtree.</dd>
+     * <dt>
+     * ENTITY_REFERENCE_NODE</dt>
+     * <dd>Only the <code>EntityReference</code> itself is
+     * copied, even if a <code>deep</code> import is requested, since the
+     * source and destination documents might have defined the entity
+     * differently. If the document being imported into provides a
+     * definition for this entity name, its value is assigned.</dd>
+     * <dt>NOTATION_NODE</dt>
+     * <dd>
+     * <code>Notation</code> nodes can be imported, however in the current
+     * release of the DOM the <code>DocumentType</code> is readonly. Ability
+     * to add these imported nodes to a <code>DocumentType</code> will be
+     * considered for addition to a future release of the DOM.On import, the
+     * <code>publicId</code> and <code>systemId</code> attributes are copied.
+     * Note that the <code>deep</code> parameter has no effect on
+     * <code>Notation</code> nodes since they never have any children.</dd>
+     * <dt>
+     * PROCESSING_INSTRUCTION_NODE</dt>
+     * <dd>The imported node copies its
+     * <code>target</code> and <code>data</code> values from those of the
+     * source node.</dd>
+     * <dt>TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE</dt>
+     * <dd>These three
+     * types of nodes inheriting from <code>CharacterData</code> copy their
+     * <code>data</code> and <code>length</code> attributes from those of
+     * the source node.</dd>
+     * </dl>
+     *
+     * @param importedNode The node to import.
+     * @param deep         If <code>true</code>, recursively import the subtree under
+     *                     the specified node; if <code>false</code>, import only the node
+     *                     itself, as explained above. This has no effect on <code>Attr</code>
+     *                     , <code>EntityReference</code>, and <code>Notation</code> nodes.
+     * @return The imported node that belongs to this <code>Document</code>.
+     * @throws DOMException NOT_SUPPORTED_ERR: Raised if the type of node being imported is not
+     *                      supported.
+     * @since DOM Level 2
+     */
+    public Node importNode(Node importedNode, boolean deep) throws DOMException {
+        return document.importNode(importedNode, deep);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#getElementsByTagNameNS(java.lang.String, java.lang.String)
-	 */
-	public NodeList getElementsByTagNameNS(String arg0, String arg1) {
-		return this.document.getElementsByTagNameNS(arg0, arg1);
-	}
+    /**
+     * Creates an element of the given qualified name and namespace URI.
+     *
+     * @param namespaceURI  The namespace URI of the element to create.
+     * @param qualifiedName The qualified name of the element type to
+     *                      instantiate.
+     * @return A new <code>Element</code> object with the following
+     *         attributes:
+     *         <table border='1' summary="Description of attributes and values for the new Element object">
+     *         <tr>
+     *         <th>Attribute</th>
+     *         <th>Value</th>
+     *         </tr>
+     *         <tr>
+     *         <td valign='top'><code>Node.nodeName</code></td>
+     *         <td valign='top'>
+     *         <code>qualifiedName</code></td>
+     *         </tr>
+     *         <tr>
+     *         <td valign='top'><code>Node.namespaceURI</code></td>
+     *         <td valign='top'>
+     *         <code>namespaceURI</code></td>
+     *         </tr>
+     *         <tr>
+     *         <td valign='top'><code>Node.prefix</code></td>
+     *         <td valign='top'>prefix, extracted
+     *         from <code>qualifiedName</code>, or <code>null</code> if there is
+     *         no prefix</td>
+     *         </tr>
+     *         <tr>
+     *         <td valign='top'><code>Node.localName</code></td>
+     *         <td valign='top'>local name, extracted from
+     *         <code>qualifiedName</code></td>
+     *         </tr>
+     *         <tr>
+     *         <td valign='top'><code>Element.tagName</code></td>
+     *         <td valign='top'>
+     *         <code>qualifiedName</code></td>
+     *         </tr>
+     *         </table>
+     * @throws DOMException INVALID_CHARACTER_ERR: Raised if the specified qualified name
+     *                      contains an illegal character, per the XML 1.0 specification .
+     *                      <br>NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is
+     *                      malformed per the Namespaces in XML specification, if the
+     *                      <code>qualifiedName</code> has a prefix and the
+     *                      <code>namespaceURI</code> is <code>null</code>, or if the
+     *                      <code>qualifiedName</code> has a prefix that is "xml" and the
+     *                      <code>namespaceURI</code> is different from "
+     *                      http://www.w3.org/XML/1998/namespace" .
+     *                      <br>NOT_SUPPORTED_ERR: Always thrown if the current document does not
+     *                      support the <code>"XML"</code> feature, since namespaces were
+     *                      defined by XML.
+     * @since DOM Level 2
+     */
+    public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {
+        return document.createElementNS(namespaceURI, qualifiedName);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Document#getElementById(java.lang.String)
-	 */
-	public Element getElementById(String arg0) {
-		return this.document.getElementById(arg0);
-	}
+    /**
+     * Creates an attribute of the given qualified name and namespace URI.
+     *
+     * @param namespaceURI  The namespace URI of the attribute to create.
+     * @param qualifiedName The qualified name of the attribute to
+     *                      instantiate.
+     * @return A new <code>Attr</code> object with the following attributes:
+     *         <table border='1' summary="Description of attributes and values for the new Attr object">
+     *         <tr>
+     *         <th>
+     *         Attribute</th>
+     *         <th>Value</th>
+     *         </tr>
+     *         <tr>
+     *         <td valign='top'><code>Node.nodeName</code></td>
+     *         <td valign='top'>qualifiedName</td>
+     *         </tr>
+     *         <tr>
+     *         <td valign='top'>
+     *         <code>Node.namespaceURI</code></td>
+     *         <td valign='top'><code>namespaceURI</code></td>
+     *         </tr>
+     *         <tr>
+     *         <td valign='top'>
+     *         <code>Node.prefix</code></td>
+     *         <td valign='top'>prefix, extracted from
+     *         <code>qualifiedName</code>, or <code>null</code> if there is no
+     *         prefix</td>
+     *         </tr>
+     *         <tr>
+     *         <td valign='top'><code>Node.localName</code></td>
+     *         <td valign='top'>local name, extracted from
+     *         <code>qualifiedName</code></td>
+     *         </tr>
+     *         <tr>
+     *         <td valign='top'><code>Attr.name</code></td>
+     *         <td valign='top'>
+     *         <code>qualifiedName</code></td>
+     *         </tr>
+     *         <tr>
+     *         <td valign='top'><code>Node.nodeValue</code></td>
+     *         <td valign='top'>the empty
+     *         string</td>
+     *         </tr>
+     *         </table>
+     * @throws DOMException INVALID_CHARACTER_ERR: Raised if the specified qualified name
+     *                      contains an illegal character, per the XML 1.0 specification .
+     *                      <br>NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is
+     *                      malformed per the Namespaces in XML specification, if the
+     *                      <code>qualifiedName</code> has a prefix and the
+     *                      <code>namespaceURI</code> is <code>null</code>, if the
+     *                      <code>qualifiedName</code> has a prefix that is "xml" and the
+     *                      <code>namespaceURI</code> is different from "
+     *                      http://www.w3.org/XML/1998/namespace", or if the
+     *                      <code>qualifiedName</code>, or its prefix, is "xmlns" and the
+     *                      <code>namespaceURI</code> is different from "
+     *                      http://www.w3.org/2000/xmlns/".
+     *                      <br>NOT_SUPPORTED_ERR: Always thrown if the current document does not
+     *                      support the <code>"XML"</code> feature, since namespaces were
+     *                      defined by XML.
+     * @since DOM Level 2
+     */
+    public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {
+        return document.createAttributeNS(namespaceURI, qualifiedName);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getNodeName()
-	 */
-	public String getNodeName() {
-		return this.document.getNodeName();
-	}
+    /**
+     * Returns a <code>NodeList</code> of all the <code>Elements</code> with a
+     * given local name and namespace URI in the order in which they are
+     * encountered in a preorder traversal of the <code>Document</code> tree.
+     *
+     * @param namespaceURI The namespace URI of the elements to match on. The
+     *                     special value "*" matches all namespaces.
+     * @param localName    The local name of the elements to match on. The
+     *                     special value "*" matches all local names.
+     * @return A new <code>NodeList</code> object containing all the matched
+     *         <code>Elements</code>.
+     * @since DOM Level 2
+     */
+    public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {
+        return document.getElementsByTagNameNS(namespaceURI, localName);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getNodeValue()
-	 */
-	public String getNodeValue() throws DOMException {
-		return this.document.getNodeValue();
-	}
+    /**
+     * Returns the <code>Element</code> whose <code>ID</code> is given by
+     * <code>elementId</code>. If no such element exists, returns
+     * <code>null</code>. Behavior is not defined if more than one element
+     * has this <code>ID</code>. The DOM implementation must have
+     * information that says which attributes are of type ID. Attributes
+     * with the name "ID" are not of type ID unless so defined.
+     * Implementations that do not know whether attributes are of type ID or
+     * not are expected to return <code>null</code>.
+     *
+     * @param elementId The unique <code>id</code> value for an element.
+     * @return The matching element.
+     * @since DOM Level 2
+     */
+    public Element getElementById(String elementId) {
+        return document.getElementById(elementId);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#setNodeValue(java.lang.String)
-	 */
-	public void setNodeValue(String arg0) throws DOMException {
-		this.document.setNodeValue(arg0);
-	}
+    /**
+     * The name of this node, depending on its type; see the table above.
+     */
+    public String getNodeName() {
+        return document.getNodeName();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getNodeType()
-	 */
-	public short getNodeType() {
-		return this.document.getNodeType();
-	}
+    /**
+     * The value of this node, depending on its type; see the table above.
+     * When it is defined to be <code>null</code>, setting it has no effect.
+     *
+     * @throws DOMException NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.
+     * @throws DOMException DOMSTRING_SIZE_ERR: Raised when it would return more characters than
+     *                      fit in a <code>DOMString</code> variable on the implementation
+     *                      platform.
+     */
+    public String getNodeValue() throws DOMException {
+        return document.getNodeValue();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getParentNode()
-	 */
-	public Node getParentNode() {
-		return this.getParentNode();
-	}
+    /**
+     * The value of this node, depending on its type; see the table above.
+     * When it is defined to be <code>null</code>, setting it has no effect.
+     *
+     * @throws DOMException NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.
+     * @throws DOMException DOMSTRING_SIZE_ERR: Raised when it would return more characters than
+     *                      fit in a <code>DOMString</code> variable on the implementation
+     *                      platform.
+     */
+    public void setNodeValue(String arg0) throws DOMException {
+        document.setNodeValue(arg0);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getChildNodes()
-	 */
-	public NodeList getChildNodes() {
-		return this.document.getChildNodes();
-	}
+    /**
+     * A code representing the type of the underlying object, as defined above.
+     */
+    public short getNodeType() {
+        return document.getNodeType();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getFirstChild()
-	 */
-	public Node getFirstChild() {
-		return this.document.getFirstChild();
-	}
+    /**
+     * The parent of this node. All nodes, except <code>Attr</code>,
+     * <code>Document</code>, <code>DocumentFragment</code>,
+     * <code>Entity</code>, and <code>Notation</code> may have a parent.
+     * However, if a node has just been created and not yet added to the
+     * tree, or if it has been removed from the tree, this is
+     * <code>null</code>.
+     */
+    public Node getParentNode() {
+        return document.getParentNode();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getLastChild()
-	 */
-	public Node getLastChild() {
-		return this.document.getLastChild();
-	}
+    /**
+     * A <code>NodeList</code> that contains all children of this node. If
+     * there are no children, this is a <code>NodeList</code> containing no
+     * nodes.
+     */
+    public NodeList getChildNodes() {
+        return document.getChildNodes();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getPreviousSibling()
-	 */
-	public Node getPreviousSibling() {
-		return this.document.getPreviousSibling();
-	}
+    /**
+     * The first child of this node. If there is no such node, this returns
+     * <code>null</code>.
+     */
+    public Node getFirstChild() {
+        return document.getFirstChild();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getNextSibling()
-	 */
-	public Node getNextSibling() {
-		return this.document.getNextSibling();
-	}
+    /**
+     * The last child of this node. If there is no such node, this returns
+     * <code>null</code>.
+     */
+    public Node getLastChild() {
+        return document.getLastChild();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getAttributes()
-	 */
-	public NamedNodeMap getAttributes() {
-		return this.document.getAttributes();
-	}
+    /**
+     * The node immediately preceding this node. If there is no such node,
+     * this returns <code>null</code>.
+     */
+    public Node getPreviousSibling() {
+        return document.getPreviousSibling();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getOwnerDocument()
-	 */
-	public Document getOwnerDocument() {
-		return this.document.getOwnerDocument();
-	}
+    /**
+     * The node immediately following this node. If there is no such node,
+     * this returns <code>null</code>.
+     */
+    public Node getNextSibling() {
+        return document.getNextSibling();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#insertBefore(org.w3c.dom.Node, org.w3c.dom.Node)
-	 */
-	public Node insertBefore(Node arg0, Node arg1) throws DOMException {
-		return this.document.insertBefore(arg0, arg1);
-	}
+    /**
+     * A <code>NamedNodeMap</code> containing the attributes of this node (if
+     * it is an <code>Element</code>) or <code>null</code> otherwise.
+     */
+    public NamedNodeMap getAttributes() {
+        return document.getAttributes();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#replaceChild(org.w3c.dom.Node, org.w3c.dom.Node)
-	 */
-	public Node replaceChild(Node arg0, Node arg1) throws DOMException {
-		return this.document.replaceChild(arg0, arg1);
-	}
+    /**
+     * The <code>Document</code> object associated with this node. This is
+     * also the <code>Document</code> object used to create new nodes. When
+     * this node is a <code>Document</code> or a <code>DocumentType</code>
+     * which is not used with any <code>Document</code> yet, this is
+     * <code>null</code>.
+     */
+    public Document getOwnerDocument() {
+        return document.getOwnerDocument();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#removeChild(org.w3c.dom.Node)
-	 */
-	public Node removeChild(Node arg0) throws DOMException {
-		return this.document.removeChild(arg0);
-	}
+    /**
+     * Inserts the node <code>newChild</code> before the existing child node
+     * <code>refChild</code>. If <code>refChild</code> is <code>null</code>,
+     * insert <code>newChild</code> at the end of the list of children.
+     * <br>If <code>newChild</code> is a <code>DocumentFragment</code> object,
+     * all of its children are inserted, in the same order, before
+     * <code>refChild</code>. If the <code>newChild</code> is already in the
+     * tree, it is first removed.
+     *
+     * @param newChild The node to insert.
+     * @param refChild The reference node, i.e., the node before which the
+     *                 new node must be inserted.
+     * @return The node being inserted.
+     * @throws DOMException HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not
+     *                      allow children of the type of the <code>newChild</code> node, or if
+     *                      the node to insert is one of this node's ancestors or this node
+     *                      itself.
+     *                      <br>WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created
+     *                      from a different document than the one that created this node.
+     *                      <br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or
+     *                      if the parent of the node being inserted is readonly.
+     *                      <br>NOT_FOUND_ERR: Raised if <code>refChild</code> is not a child of
+     *                      this node.
+     */
+    public Node insertBefore(Node newChild, Node refChild) throws DOMException {
+        return document.insertBefore(newChild, refChild);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#appendChild(org.w3c.dom.Node)
-	 */
-	public Node appendChild(Node arg0) throws DOMException {
-		return this.document.appendChild(arg0);
-	}
+    /**
+     * Replaces the child node <code>oldChild</code> with <code>newChild</code>
+     * in the list of children, and returns the <code>oldChild</code> node.
+     * <br>If <code>newChild</code> is a <code>DocumentFragment</code> object,
+     * <code>oldChild</code> is replaced by all of the
+     * <code>DocumentFragment</code> children, which are inserted in the
+     * same order. If the <code>newChild</code> is already in the tree, it
+     * is first removed.
+     *
+     * @param newChild The new node to put in the child list.
+     * @param oldChild The node being replaced in the list.
+     * @return The node replaced.
+     * @throws DOMException HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not
+     *                      allow children of the type of the <code>newChild</code> node, or if
+     *                      the node to put in is one of this node's ancestors or this node
+     *                      itself.
+     *                      <br>WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created
+     *                      from a different document than the one that created this node.
+     *                      <br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node or the parent of
+     *                      the new node is readonly.
+     *                      <br>NOT_FOUND_ERR: Raised if <code>oldChild</code> is not a child of
+     *                      this node.
+     */
+    public Node replaceChild(Node newChild, Node oldChild) throws DOMException {
+        return document.replaceChild(newChild, oldChild);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#hasChildNodes()
-	 */
-	public boolean hasChildNodes() {
-		return this.document.hasChildNodes();
-	}
+    /**
+     * Removes the child node indicated by <code>oldChild</code> from the list
+     * of children, and returns it.
+     *
+     * @param oldChild The node being removed.
+     * @return The node removed.
+     * @throws DOMException NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
+     *                      <br>NOT_FOUND_ERR: Raised if <code>oldChild</code> is not a child of
+     *                      this node.
+     */
+    public Node removeChild(Node oldChild) throws DOMException {
+        return document.removeChild(oldChild);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#cloneNode(boolean)
-	 */
-	public Node cloneNode(boolean arg0) {
-		return this.document.cloneNode(arg0);
-	}
+    /**
+     * Adds the node <code>newChild</code> to the end of the list of children
+     * of this node. If the <code>newChild</code> is already in the tree, it
+     * is first removed.
+     *
+     * @param newChild The node to add.If it is a
+     *                 <code>DocumentFragment</code> object, the entire contents of the
+     *                 document fragment are moved into the child list of this node
+     * @return The node added.
+     * @throws DOMException HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not
+     *                      allow children of the type of the <code>newChild</code> node, or if
+     *                      the node to append is one of this node's ancestors or this node
+     *                      itself.
+     *                      <br>WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created
+     *                      from a different document than the one that created this node.
+     *                      <br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or
+     *                      if the previous parent of the node being inserted is readonly.
+     */
+    public Node appendChild(Node newChild) throws DOMException {
+        return document.appendChild(newChild);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#normalize()
-	 */
-	public void normalize() {
-		this.document.normalize();
-	}
+    /**
+     * Returns whether this node has any children.
+     *
+     * @return <code>true</code> if this node has any children,
+     *         <code>false</code> otherwise.
+     */
+    public boolean hasChildNodes() {
+        return document.hasChildNodes();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#isSupported(java.lang.String, java.lang.String)
-	 */
-	public boolean isSupported(String arg0, String arg1) {
-		return this.document.isSupported(arg0, arg1);
-	}
+    /**
+     * Returns a duplicate of this node, i.e., serves as a generic copy
+     * constructor for nodes. The duplicate node has no parent; (
+     * <code>parentNode</code> is <code>null</code>.).
+     * <br>Cloning an <code>Element</code> copies all attributes and their
+     * values, including those generated by the XML processor to represent
+     * defaulted attributes, but this method does not copy any text it
+     * contains unless it is a deep clone, since the text is contained in a
+     * child <code>Text</code> node. Cloning an <code>Attribute</code>
+     * directly, as opposed to be cloned as part of an <code>Element</code>
+     * cloning operation, returns a specified attribute (
+     * <code>specified</code> is <code>true</code>). Cloning any other type
+     * of node simply returns a copy of this node.
+     * <br>Note that cloning an immutable subtree results in a mutable copy,
+     * but the children of an <code>EntityReference</code> clone are readonly
+     * . In addition, clones of unspecified <code>Attr</code> nodes are
+     * specified. And, cloning <code>Document</code>,
+     * <code>DocumentType</code>, <code>Entity</code>, and
+     * <code>Notation</code> nodes is implementation dependent.
+     *
+     * @param deep If <code>true</code>, recursively clone the subtree under
+     *             the specified node; if <code>false</code>, clone only the node
+     *             itself (and its attributes, if it is an <code>Element</code>).
+     * @return The duplicate node.
+     */
+    public Node cloneNode(boolean deep) {
+        return document.cloneNode(deep);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getNamespaceURI()
-	 */
-	public String getNamespaceURI() {
-		return this.document.getNamespaceURI();
-	}
+    /**
+     * Puts all <code>Text</code> nodes in the full depth of the sub-tree
+     * underneath this <code>Node</code>, including attribute nodes, into a
+     * "normal" form where only structure (e.g., elements, comments,
+     * processing instructions, CDATA sections, and entity references)
+     * separates <code>Text</code> nodes, i.e., there are neither adjacent
+     * <code>Text</code> nodes nor empty <code>Text</code> nodes. This can
+     * be used to ensure that the DOM view of a document is the same as if
+     * it were saved and re-loaded, and is useful when operations (such as
+     * XPointer  lookups) that depend on a particular document tree
+     * structure are to be used.In cases where the document contains
+     * <code>CDATASections</code>, the normalize operation alone may not be
+     * sufficient, since XPointers do not differentiate between
+     * <code>Text</code> nodes and <code>CDATASection</code> nodes.
+     */
+    public void normalize() {
+        document.normalize();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getPrefix()
-	 */
-	public String getPrefix() {
-		return this.document.getPrefix();
-	}
+    /**
+     * Tests whether the DOM implementation implements a specific feature and
+     * that feature is supported by this node.
+     *
+     * @param feature The name of the feature to test. This is the same name
+     *                which can be passed to the method <code>hasFeature</code> on
+     *                <code>DOMImplementation</code>.
+     * @param version This is the version number of the feature to test. In
+     *                Level 2, version 1, this is the string "2.0". If the version is not
+     *                specified, supporting any version of the feature will cause the
+     *                method to return <code>true</code>.
+     * @return Returns <code>true</code> if the specified feature is
+     *         supported on this node, <code>false</code> otherwise.
+     * @since DOM Level 2
+     */
+    public boolean isSupported(String feature, String version) {
+        return document.isSupported(feature, version);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#setPrefix(java.lang.String)
-	 */
-	public void setPrefix(String arg0) throws DOMException {
-		this.document.setPrefix(arg0);
-	}
+    /**
+     * The namespace URI of this node, or <code>null</code> if it is
+     * unspecified.
+     * <br>This is not a computed value that is the result of a namespace
+     * lookup based on an examination of the namespace declarations in
+     * scope. It is merely the namespace URI given at creation time.
+     * <br>For nodes of any type other than <code>ELEMENT_NODE</code> and
+     * <code>ATTRIBUTE_NODE</code> and nodes created with a DOM Level 1
+     * method, such as <code>createElement</code> from the
+     * <code>Document</code> interface, this is always <code>null</code>.Per
+     * the Namespaces in XML Specification  an attribute does not inherit
+     * its namespace from the element it is attached to. If an attribute is
+     * not explicitly given a namespace, it simply has no namespace.
+     *
+     * @since DOM Level 2
+     */
+    public String getNamespaceURI() {
+        return document.getNamespaceURI();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getLocalName()
-	 */
-	public String getLocalName() {
-		return this.document.getLocalName();
-	}
+    /**
+     * The namespace prefix of this node, or <code>null</code> if it is
+     * unspecified.
+     * <br>Note that setting this attribute, when permitted, changes the
+     * <code>nodeName</code> attribute, which holds the qualified name, as
+     * well as the <code>tagName</code> and <code>name</code> attributes of
+     * the <code>Element</code> and <code>Attr</code> interfaces, when
+     * applicable.
+     * <br>Note also that changing the prefix of an attribute that is known to
+     * have a default value, does not make a new attribute with the default
+     * value and the original prefix appear, since the
+     * <code>namespaceURI</code> and <code>localName</code> do not change.
+     * <br>For nodes of any type other than <code>ELEMENT_NODE</code> and
+     * <code>ATTRIBUTE_NODE</code> and nodes created with a DOM Level 1
+     * method, such as <code>createElement</code> from the
+     * <code>Document</code> interface, this is always <code>null</code>.
+     *
+     * @throws DOMException INVALID_CHARACTER_ERR: Raised if the specified prefix contains an
+     *                      illegal character, per the XML 1.0 specification .
+     *                      <br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
+     *                      <br>NAMESPACE_ERR: Raised if the specified <code>prefix</code> is
+     *                      malformed per the Namespaces in XML specification, if the
+     *                      <code>namespaceURI</code> of this node is <code>null</code>, if the
+     *                      specified prefix is "xml" and the <code>namespaceURI</code> of this
+     *                      node is different from "http://www.w3.org/XML/1998/namespace", if
+     *                      this node is an attribute and the specified prefix is "xmlns" and
+     *                      the <code>namespaceURI</code> of this node is different from "
+     *                      http://www.w3.org/2000/xmlns/", or if this node is an attribute and
+     *                      the <code>qualifiedName</code> of this node is "xmlns" .
+     * @since DOM Level 2
+     */
+    public String getPrefix() {
+        return document.getPrefix();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#hasAttributes()
-	 */
-	public boolean hasAttributes() {
-		return this.document.hasAttributes();
-	}
-	
-	protected void setMessage(SOAPMessageImpl message) {
-		this.msgObject = message;
-	}
+    /**
+     * The namespace prefix of this node, or <code>null</code> if it is
+     * unspecified.
+     * <br>Note that setting this attribute, when permitted, changes the
+     * <code>nodeName</code> attribute, which holds the qualified name, as
+     * well as the <code>tagName</code> and <code>name</code> attributes of
+     * the <code>Element</code> and <code>Attr</code> interfaces, when
+     * applicable.
+     * <br>Note also that changing the prefix of an attribute that is known to
+     * have a default value, does not make a new attribute with the default
+     * value and the original prefix appear, since the
+     * <code>namespaceURI</code> and <code>localName</code> do not change.
+     * <br>For nodes of any type other than <code>ELEMENT_NODE</code> and
+     * <code>ATTRIBUTE_NODE</code> and nodes created with a DOM Level 1
+     * method, such as <code>createElement</code> from the
+     * <code>Document</code> interface, this is always <code>null</code>.
+     *
+     * @throws DOMException INVALID_CHARACTER_ERR: Raised if the specified prefix contains an
+     *                      illegal character, per the XML 1.0 specification .
+     *                      <br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
+     *                      <br>NAMESPACE_ERR: Raised if the specified <code>prefix</code> is
+     *                      malformed per the Namespaces in XML specification, if the
+     *                      <code>namespaceURI</code> of this node is <code>null</code>, if the
+     *                      specified prefix is "xml" and the <code>namespaceURI</code> of this
+     *                      node is different from "http://www.w3.org/XML/1998/namespace", if
+     *                      this node is an attribute and the specified prefix is "xmlns" and
+     *                      the <code>namespaceURI</code> of this node is different from "
+     *                      http://www.w3.org/2000/xmlns/", or if this node is an attribute and
+     *                      the <code>qualifiedName</code> of this node is "xmlns" .
+     * @since DOM Level 2
+     */
+    public void setPrefix(String arg0) throws DOMException {
+        document.setPrefix(arg0);
+    }
 
+    /**
+     * Returns the local part of the qualified name of this node.
+     * <br>For nodes of any type other than <code>ELEMENT_NODE</code> and
+     * <code>ATTRIBUTE_NODE</code> and nodes created with a DOM Level 1
+     * method, such as <code>createElement</code> from the
+     * <code>Document</code> interface, this is always <code>null</code>.
+     *
+     * @since DOM Level 2
+     */
+    public String getLocalName() {
+        return document.getLocalName();
+    }
+
+    /**
+     * Returns whether this node (if it is an element) has any attributes.
+     *
+     * @return <code>true</code> if this node has any attributes,
+     *         <code>false</code> otherwise.
+     * @since DOM Level 2
+     */
+    public boolean hasAttributes() {
+        return document.hasAttributes();
+    }
+
+    protected void setMessage(SOAPMessageImpl message) {
+        soapMessage = message;
+    }
 }
Index: src/org/apache/axis2/saaj2/SOAPFactoryImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/SOAPFactoryImpl.java	(revision 0)
+++ src/org/apache/axis2/saaj2/SOAPFactoryImpl.java	(revision 0)
@@ -0,0 +1,143 @@
+/*                                                                             
+ * Copyright 2004,2005 The Apache Software Foundation.                         
+ *                                                                             
+ * Licensed under the Apache License, Version 2.0 (the "License");             
+ * you may not use this file except in compliance with the License.            
+ * You may obtain a copy of the License at                                     
+ *                                                                             
+ *      http://www.apache.org/licenses/LICENSE-2.0                             
+ *                                                                             
+ * Unless required by applicable law or agreed to in writing, software         
+ * distributed under the License is distributed on an "AS IS" BASIS,           
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    
+ * See the License for the specific language governing permissions and         
+ * limitations under the License.                                              
+ */
+package org.apache.axis2.saaj2;
+
+import org.apache.axis2.om.DOOMAbstractFactory;
+import org.apache.axis2.om.OMElement;
+import org.apache.axis2.om.OMNamespace;
+import org.apache.axis2.om.impl.dom.ElementImpl;
+import org.apache.axis2.om.impl.dom.factory.OMDOMFactory;
+
+import javax.xml.soap.Detail;
+import javax.xml.soap.Name;
+import javax.xml.soap.SOAPElement;
+import javax.xml.soap.SOAPException;
+import javax.xml.soap.SOAPFactory;
+
+/**
+ * 
+ */
+public class SOAPFactoryImpl extends SOAPFactory {
+
+    /**
+     * Create a <code>SOAPElement</code> object initialized with the
+     * given <code>Name</code> object.
+     *
+     * @param name a <code>Name</code> object with the XML name for
+     *             the new element
+     * @return the new <code>SOAPElement</code> object that was
+     *         created
+     * @throws javax.xml.soap.SOAPException if there is an error in creating the
+     *                                      <code>SOAPElement</code> object
+     */
+    public SOAPElement createElement(Name name) throws SOAPException {
+        String localName = name.getLocalName();
+        String prefix = name.getPrefix();
+        String uri = name.getURI();
+        OMElement omElement = DOOMAbstractFactory.getOMFactory().createOMElement(localName, uri, prefix);
+        return new SOAPElementImpl((ElementImpl) omElement);
+    }
+
+    /**
+     * Create a <code>SOAPElement</code> object initialized with the
+     * given local name.
+     *
+     * @param localName a <code>String</code> giving the local name for
+     *                  the new element
+     * @return the new <code>SOAPElement</code> object that was
+     *         created
+     * @throws javax.xml.soap.SOAPException if there is an error in creating the
+     *                                      <code>SOAPElement</code> object
+     */
+    public SOAPElement createElement(String localName) throws SOAPException {
+        OMDOMFactory omdomFactory = (OMDOMFactory) DOOMAbstractFactory.getOMFactory();
+
+        OMNamespace ns = omdomFactory.createOMNamespace(null, null);
+        OMElement omElement = omdomFactory.createOMElement(localName, ns);
+        return new SOAPElementImpl((ElementImpl) omElement);
+    }
+
+    /**
+     * Create a new <code>SOAPElement</code> object with the given
+     * local name, prefix and uri.
+     *
+     * @param localName a <code>String</code> giving the local name
+     *                  for the new element
+     * @param prefix    the prefix for this <code>SOAPElement</code>
+     * @param uri       a <code>String</code> giving the URI of the
+     *                  namespace to which the new element belongs
+     * @return the new <code>SOAPElement</code> object that was
+     *         created
+     * @throws javax.xml.soap.SOAPException if there is an error in creating the
+     *                                      <code>SOAPElement</code> object
+     */
+    public SOAPElement createElement(String localName, String prefix, String uri) throws SOAPException {
+        OMElement omElement = DOOMAbstractFactory.getOMFactory().createOMElement(localName, uri, prefix);
+        return new SOAPElementImpl((ElementImpl) omElement);
+    }
+
+    /**
+     * Creates a new <code>Detail</code> object which serves as a container
+     * for <code>DetailEntry</code> objects.
+     * <p/>
+     * This factory method creates <code>Detail</code> objects for use in
+     * situations where it is not practical to use the <code>SOAPFault</code>
+     * abstraction.
+     *
+     * @return a <code>Detail</code> object
+     * @throws javax.xml.soap.SOAPException if there is a SOAP error
+     */
+    public Detail createDetail() throws SOAPException {
+        //TODO: Method implementation
+        return null;
+    }
+
+    /**
+     * Creates a new <code>Name</code> object initialized with the
+     * given local name, namespace prefix, and namespace URI.
+     * <p/>
+     * This factory method creates <code>Name</code> objects for use in
+     * situations where it is not practical to use the <code>SOAPEnvelope</code>
+     * abstraction.
+     *
+     * @param localName a <code>String</code> giving the local name
+     * @param prefix    a <code>String</code> giving the prefix of the namespace
+     * @param uri       a <code>String</code> giving the URI of the namespace
+     * @return a <code>Name</code> object initialized with the given
+     *         local name, namespace prefix, and namespace URI
+     * @throws javax.xml.soap.SOAPException if there is a SOAP error
+     */
+    public Name createName(String localName, String prefix, String uri) throws SOAPException {
+        return new PrefixedQName(uri, localName, prefix);
+    }
+
+    /**
+     * Creates a new <code>Name</code> object initialized with the
+     * given local name.
+     * <p/>
+     * This factory method creates <code>Name</code> objects for use in
+     * situations where it is not practical to use the <code>SOAPEnvelope</code>
+     * abstraction.
+     *
+     * @param localName a <code>String</code> giving the local name
+     * @return a <code>Name</code> object initialized with the given
+     *         local name
+     * @throws javax.xml.soap.SOAPException if there is a SOAP error
+     */
+    public Name createName(String localName) throws SOAPException {
+        return new PrefixedQName(null, localName, null);
+    }
+}
Index: src/org/apache/axis2/saaj2/SOAPBodyElementImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/SOAPBodyElementImpl.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/SOAPBodyElementImpl.java	(working copy)
@@ -19,8 +19,7 @@
 
 import org.apache.axis2.om.impl.dom.ElementImpl;
 
-public class SOAPBodyElementImpl extends SOAPElementImpl implements
-		SOAPBodyElement {
+public class SOAPBodyElementImpl extends SOAPElementImpl implements SOAPBodyElement {
 
 	/**
 	 * @param element
Index: src/org/apache/axis2/saaj2/MimeHeadersEx.java
===================================================================
--- src/org/apache/axis2/saaj2/MimeHeadersEx.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/MimeHeadersEx.java	(working copy)
@@ -1,42 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.saaj2;
-
-import javax.xml.soap.MimeHeader;
-import java.util.Iterator;
-
-public class MimeHeadersEx extends javax.xml.soap.MimeHeaders {
-    public MimeHeadersEx() {
-    }
-
-    public MimeHeadersEx(javax.xml.soap.MimeHeaders h) {
-        Iterator iterator = h.getAllHeaders();
-        while (iterator.hasNext()) {
-            MimeHeader hdr = (MimeHeader) iterator.next();
-            addHeader(hdr.getName(), hdr.getValue());
-        }
-    }
-
-    private int getHeaderSize() {
-        int size = 0;
-        Iterator iterator = getAllHeaders();
-        while (iterator.hasNext()) {
-            iterator.next();
-            size++;
-        }
-        return size;
-    }
-}
Index: src/org/apache/axis2/saaj2/SOAPFaultImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/SOAPFaultImpl.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/SOAPFaultImpl.java	(working copy)
@@ -1,12 +1,5 @@
 package org.apache.axis2.saaj2;
 
-import java.util.Locale;
-
-import javax.xml.soap.Detail;
-import javax.xml.soap.Name;
-import javax.xml.soap.SOAPException;
-import javax.xml.soap.SOAPFault;
-
 import org.apache.axis2.om.impl.dom.ElementImpl;
 import org.apache.axis2.soap.SOAPFaultCode;
 import org.apache.axis2.soap.SOAPFaultReason;
@@ -19,162 +12,175 @@
 import org.apache.axis2.soap.impl.dom.soap11.SOAP11FaultTextImpl;
 import org.apache.axis2.soap.impl.dom.soap11.SOAP11FaultValueImpl;
 
-public class SOAPFaultImpl extends SOAPBodyElementImpl implements
-		SOAPFault {
-	
-	protected org.apache.axis2.soap.SOAPFault fault;
-	
-	/**
-	 * @param element
-	 */
-	public SOAPFaultImpl(org.apache.axis2.soap.SOAPFault element) {
-		super((ElementImpl)element);
-		fault = element;
-	}
+import javax.xml.soap.Detail;
+import javax.xml.soap.Name;
+import javax.xml.soap.SOAPException;
+import javax.xml.soap.SOAPFault;
+import java.util.Locale;
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPFault#setFaultCode(java.lang.String)
-	 */
-	public void setFaultCode(String faultCode) throws SOAPException {
-		SOAPFaultCode code = new SOAP11FaultCodeImpl(fault);
-		SOAP11FaultValueImpl faultValueImpl = new SOAP11FaultValueImpl(code);
-		faultValueImpl.setText(faultCode);
-		code.setValue(faultValueImpl);
-		this.fault.setCode(code);
-	}
+public class SOAPFaultImpl extends SOAPBodyElementImpl implements SOAPFault {
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPFault#getFaultCode()
-	 */
-	public String getFaultCode() {
-		return this.fault.getCode().getValue().getText();
-	}
+    protected org.apache.axis2.soap.SOAPFault fault;
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPFault#setFaultActor(java.lang.String)
-	 */
-	public void setFaultActor(String faultActor) throws SOAPException {
-		if(this.fault.getRole() == null) {
-			SOAP11FaultRoleImpl faultRoleImpl = new SOAP11FaultRoleImpl(this.fault);
-			faultRoleImpl.setRoleValue(faultActor);
-			this.fault.setRole(faultRoleImpl);
-		} else {
-			SOAPFaultRole role = this.fault.getRole();
-			role.setRoleValue(faultActor);
-		}
-	}
+    /**
+     * @param element
+     */
+    public SOAPFaultImpl(org.apache.axis2.soap.SOAPFault element) {
+        super((ElementImpl) element);
+        fault = element;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPFault#getFaultActor()
-	 */
-	public String getFaultActor() {
-		if(this.fault.getRole() != null) {
-			return this.fault.getRole().getRoleValue();
-		}
-		return null;
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPFault#setFaultCode(java.lang.String)
+      */
+    public void setFaultCode(String faultCode) throws SOAPException {
+        SOAPFaultCode code = new SOAP11FaultCodeImpl(fault);
+        SOAP11FaultValueImpl faultValueImpl = new SOAP11FaultValueImpl(code);
+        faultValueImpl.setText(faultCode);
+        code.setValue(faultValueImpl);
+        this.fault.setCode(code);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPFault#setFaultString(java.lang.String)
-	 */
-	public void setFaultString(String faultString) throws SOAPException {
-		if(this.fault.getReason() != null) {
-			SOAPFaultReason reason = this.fault.getReason();
-			if(reason.getSOAPText() != null) {
-				reason.getSOAPText().setText(faultString);
-			} else {
-				SOAPFaultText text = new SOAP11FaultTextImpl(reason);
-				text.setText(faultString);
-				reason.setSOAPText(text);
-			}
-		} else {
-			SOAPFaultReason reason = new SOAP11FaultReasonImpl(this.fault);
-			SOAPFaultText text = new SOAP11FaultTextImpl(reason);
-			text.setText(faultString);
-			reason.setSOAPText(text);
-			this.fault.setReason(reason);
-		}
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPFault#getFaultCode()
+      */
+    public String getFaultCode() {
+        return this.fault.getCode().getValue().getText();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPFault#getFaultString()
-	 */
-	public String getFaultString() {
-		if(this.fault.getReason() != null && this.fault.getReason().getSOAPText() != null) {
-			return this.fault.getReason().getSOAPText().getText();
-		}
-		return null;
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPFault#setFaultActor(java.lang.String)
+      */
+    public void setFaultActor(String faultActor) throws SOAPException {
+        if (this.fault.getRole() == null) {
+            SOAP11FaultRoleImpl faultRoleImpl = new SOAP11FaultRoleImpl(this.fault);
+            faultRoleImpl.setRoleValue(faultActor);
+            this.fault.setRole(faultRoleImpl);
+        } else {
+            SOAPFaultRole role = this.fault.getRole();
+            role.setRoleValue(faultActor);
+        }
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPFault#getDetail()
-	 */
-	public Detail getDetail() {
-		if(this.fault.getDetail() != null) {
-			return new DetailImpl(this.fault.getDetail());
-		}
-		return null;
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPFault#getFaultActor()
+      */
+    public String getFaultActor() {
+        if (this.fault.getRole() != null) {
+            return this.fault.getRole().getRoleValue();
+        }
+        return null;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPFault#addDetail()
-	 */
-	public Detail addDetail() throws SOAPException {
-		SOAP11FaultDetailImpl omDetail = new SOAP11FaultDetailImpl(this.fault);
-		this.fault.setDetail(omDetail);
-		Detail detail = new DetailImpl(omDetail);
-		return detail;
-	}
+    /**
+     * Sets the fault string for this <CODE>SOAPFault</CODE>
+     * object to the given string.
+     *
+     * @param faultString a <CODE>String</CODE>
+     *                    giving an explanation of the fault
+     * @throws SOAPException if there was an error in
+     *                       adding the <CODE>faultString</CODE> to the underlying XML
+     *                       tree.
+     * @see #getFaultString() getFaultString()
+     */
+    public void setFaultString(String faultString) throws SOAPException {
+        if (this.fault.getReason() != null) {
+            SOAPFaultReason reason = this.fault.getReason();
+            if (reason.getSOAPText() != null) {
+                reason.getSOAPText().setText(faultString);
+            } else {
+                SOAPFaultText text = new SOAP11FaultTextImpl(reason);
+                text.setText(faultString);
+                reason.setSOAPText(text);
+            }
+        } else {
+            SOAPFaultReason reason = new SOAP11FaultReasonImpl(this.fault);
+            SOAPFaultText text = new SOAP11FaultTextImpl(reason);
+            text.setText(faultString);
+            reason.setSOAPText(text);
+            this.fault.setReason(reason);
+        }
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPFault#setFaultCode(javax.xml.soap.Name)
-	 */
-	public void setFaultCode(Name name) throws SOAPException {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPFault#getFaultString()
+      */
+    public String getFaultString() {
+        if (this.fault.getReason() != null && this.fault.getReason().getSOAPText() != null) {
+            return this.fault.getReason().getSOAPText().getText();
+        }
+        return null;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPFault#getFaultCodeAsName()
-	 */
-	public Name getFaultCodeAsName() {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPFault#getDetail()
+      */
+    public Detail getDetail() {
+        if (this.fault.getDetail() != null) {
+            return new DetailImpl(this.fault.getDetail());
+        }
+        return null;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPFault#setFaultString(java.lang.String, java.util.Locale)
-	 */
-	public void setFaultString(String faultString, Locale locale) throws SOAPException {
-		if(this.fault.getReason() != null) {
-			SOAPFaultReason reason = this.fault.getReason();
-			if(reason.getSOAPText() != null) {
-				reason.getSOAPText().setText(faultString);
-				reason.getSOAPText().setLang(locale.getLanguage());
-			} else {
-				SOAPFaultText text = new SOAP11FaultTextImpl(reason);
-				text.setText(faultString);
-				text.setLang(locale.getLanguage());
-				reason.setSOAPText(text);
-			}
-		} else {
-			SOAPFaultReason reason = new SOAP11FaultReasonImpl(this.fault);
-			SOAPFaultText text = new SOAP11FaultTextImpl(reason);
-			text.setText(faultString);
-			text.setLang(locale.getLanguage());
-			reason.setSOAPText(text);
-			this.fault.setReason(reason);
-		}
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPFault#addDetail()
+      */
+    public Detail addDetail() throws SOAPException {
+        SOAP11FaultDetailImpl omDetail = new SOAP11FaultDetailImpl(this.fault);
+        this.fault.setDetail(omDetail);
+        Detail detail = new DetailImpl(omDetail);
+        return detail;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPFault#getFaultStringLocale()
-	 */
-	public Locale getFaultStringLocale() {
-		//We only save the language in OM,
-		//Can we construct a Locale with it :-?
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPFault#setFaultCode(javax.xml.soap.Name)
+      */
+    public void setFaultCode(Name name) throws SOAPException {
+        // TODO TODO
+        throw new UnsupportedOperationException("TODO");
+    }
 
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPFault#getFaultCodeAsName()
+      */
+    public Name getFaultCodeAsName() {
+        // TODO TODO
+        throw new UnsupportedOperationException("TODO");
+    }
+
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPFault#setFaultString(java.lang.String, java.util.Locale)
+      */
+    public void setFaultString(String faultString, Locale locale) throws SOAPException {
+        if (this.fault.getReason() != null) {
+            SOAPFaultReason reason = this.fault.getReason();
+            if (reason.getSOAPText() != null) {
+                reason.getSOAPText().setText(faultString);
+                reason.getSOAPText().setLang(locale.getLanguage());
+            } else {
+                SOAPFaultText text = new SOAP11FaultTextImpl(reason);
+                text.setText(faultString);
+                text.setLang(locale.getLanguage());
+                reason.setSOAPText(text);
+            }
+        } else {
+            SOAPFaultReason reason = new SOAP11FaultReasonImpl(this.fault);
+            SOAPFaultText text = new SOAP11FaultTextImpl(reason);
+            text.setText(faultString);
+            text.setLang(locale.getLanguage());
+            reason.setSOAPText(text);
+            this.fault.setReason(reason);
+        }
+    }
+
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPFault#getFaultStringLocale()
+      */
+    public Locale getFaultStringLocale() {
+        //We only save the language in OM,
+        //Can we construct a Locale with it :-?
+        // TODO TODO
+        throw new UnsupportedOperationException("TODO");
+    }
+
 }
Index: src/org/apache/axis2/saaj2/SOAPEnvelopeImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/SOAPEnvelopeImpl.java	(revision 0)
+++ src/org/apache/axis2/saaj2/SOAPEnvelopeImpl.java	(revision 0)
@@ -0,0 +1,198 @@
+/*                                                                             
+ * Copyright 2004,2005 The Apache Software Foundation.                         
+ *                                                                             
+ * Licensed under the Apache License, Version 2.0 (the "License");             
+ * you may not use this file except in compliance with the License.            
+ * You may obtain a copy of the License at                                     
+ *                                                                             
+ *      http://www.apache.org/licenses/LICENSE-2.0                             
+ *                                                                             
+ * Unless required by applicable law or agreed to in writing, software         
+ * distributed under the License is distributed on an "AS IS" BASIS,           
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    
+ * See the License for the specific language governing permissions and         
+ * limitations under the License.                                              
+ */
+package org.apache.axis2.saaj2;
+
+import org.apache.axis2.om.impl.dom.DocumentImpl;
+import org.apache.axis2.om.impl.dom.ElementImpl;
+import org.apache.axis2.soap.impl.dom.soap11.SOAP11BodyImpl;
+import org.apache.axis2.soap.impl.dom.soap11.SOAP11HeaderImpl;
+import org.w3c.dom.Document;
+
+import javax.xml.soap.Name;
+import javax.xml.soap.SOAPBody;
+import javax.xml.soap.SOAPException;
+import javax.xml.soap.SOAPHeader;
+import javax.xml.soap.SOAPElement;
+
+/**
+ * 
+ */
+public class SOAPEnvelopeImpl extends SOAPElementImpl implements javax.xml.soap.SOAPEnvelope {
+
+    private org.apache.axis2.soap.SOAPEnvelope omSOAPEnvelope;
+
+    public SOAPEnvelopeImpl(final org.apache.axis2.soap.SOAPEnvelope element) {
+        super((ElementImpl) element);
+        omSOAPEnvelope = element;
+    }
+
+    public void setOwnerDocument(Document document) {
+        super.setOwnerDocument((DocumentImpl) document);
+    }
+
+    public org.apache.axis2.soap.SOAPEnvelope getOMEnvelope() {
+        return omSOAPEnvelope;
+    }
+    
+    /**
+     * Creates a new <CODE>Name</CODE> object initialized with the
+     * given local name, namespace prefix, and namespace URI.
+     * <p/>
+     * <P>This factory method creates <CODE>Name</CODE> objects
+     * for use in the SOAP/XML document.
+     *
+     * @param localName a <CODE>String</CODE> giving
+     *                  the local name
+     * @param prefix    a <CODE>String</CODE> giving
+     *                  the prefix of the namespace
+     * @param uri       a <CODE>String</CODE> giving the
+     *                  URI of the namespace
+     * @return a <CODE>Name</CODE> object initialized with the given
+     *         local name, namespace prefix, and namespace URI
+     * @throws javax.xml.soap.SOAPException if there is a SOAP error
+     */
+    public Name createName(String localName, String prefix, String uri) throws SOAPException {
+        try {
+            return new PrefixedQName(uri, localName, prefix);
+        } catch (Exception e) {
+            throw new SOAPException(e);
+        }
+    }
+
+    /**
+     * Creates a new <CODE>Name</CODE> object initialized with the
+     * given local name.
+     * <p/>
+     * <P>This factory method creates <CODE>Name</CODE> objects
+     * for use in the SOAP/XML document.
+     *
+     * @param localName a <CODE>String</CODE> giving
+     *                  the local name
+     * @return a <CODE>Name</CODE> object initialized with the given
+     *         local name
+     * @throws javax.xml.soap.SOAPException if there is a SOAP error
+     */
+    public Name createName(String localName) throws SOAPException {
+        try {
+            return new PrefixedQName(null, localName, null);
+        } catch (Exception e) {
+            throw new SOAPException(e);
+        }
+    }
+
+    /**
+     * Returns the <CODE>SOAPHeader</CODE> object for this <CODE>
+     * SOAPEnvelope</CODE> object.
+     * <p/>
+     * <P>A new <CODE>SOAPMessage</CODE> object is by default
+     * created with a <CODE>SOAPEnvelope</CODE> object that
+     * contains an empty <CODE>SOAPHeader</CODE> object. As a
+     * result, the method <CODE>getHeader</CODE> will always
+     * return a <CODE>SOAPHeader</CODE> object unless the header
+     * has been removed and a new one has not been added.
+     *
+     * @return the <CODE>SOAPHeader</CODE> object or <CODE>
+     *         null</CODE> if there is none
+     * @throws javax.xml.soap.SOAPException if there is a problem
+     *                                      obtaining the <CODE>SOAPHeader</CODE> object
+     */
+    public SOAPHeader getHeader() throws SOAPException {
+        org.apache.axis2.soap.SOAPHeader soapHeader = omSOAPEnvelope.getHeader();
+        if (soapHeader != null) {
+            return new SOAPHeaderImpl(soapHeader);
+        }
+        return null;
+    }
+
+    /**
+     * Returns the <CODE>SOAPBody</CODE> object associated with
+     * this <CODE>SOAPEnvelope</CODE> object.
+     * <p/>
+     * <P>A new <CODE>SOAPMessage</CODE> object is by default
+     * created with a <CODE>SOAPEnvelope</CODE> object that
+     * contains an empty <CODE>SOAPBody</CODE> object. As a
+     * result, the method <CODE>getBody</CODE> will always return
+     * a <CODE>SOAPBody</CODE> object unless the body has been
+     * removed and a new one has not been added.
+     *
+     * @return the <CODE>SOAPBody</CODE> object for this <CODE>
+     *         SOAPEnvelope</CODE> object or <CODE>null</CODE> if there
+     *         is none
+     * @throws javax.xml.soap.SOAPException if there is a problem
+     *                                      obtaining the <CODE>SOAPBody</CODE> object
+     */
+    public SOAPBody getBody() throws SOAPException {
+        final org.apache.axis2.soap.SOAPBody body = omSOAPEnvelope.getBody();
+        if (body != null) {
+            return new SOAPBodyImpl(body);
+        }
+        return null;
+    }
+
+    /**
+     * Creates a <CODE>SOAPHeader</CODE> object and sets it as the
+     * <CODE>SOAPHeader</CODE> object for this <CODE>
+     * SOAPEnvelope</CODE> object.
+     * <p/>
+     * <P>It is illegal to add a header when the envelope already
+     * contains a header. Therefore, this method should be called
+     * only after the existing header has been removed.
+     *
+     * @return the new <CODE>SOAPHeader</CODE> object
+     * @throws javax.xml.soap.SOAPException if this <CODE>
+     *                                      SOAPEnvelope</CODE> object already contains a valid
+     *                                      <CODE>SOAPHeader</CODE> object
+     */
+    public SOAPHeader addHeader() throws SOAPException {
+
+        org.apache.axis2.soap.SOAPHeader header = omSOAPEnvelope.getHeader();
+        if (header == null) {
+            header = new SOAP11HeaderImpl(omSOAPEnvelope);
+            omSOAPEnvelope.addChild(header);
+            return (new SOAPHeaderImpl(header));
+        } else {
+            throw new SOAPException("Header already present, can't set header again without " +
+                                    "deleting the existing header.");
+        }
+    }
+
+    /**
+     * Creates a <CODE>SOAPBody</CODE> object and sets it as the
+     * <CODE>SOAPBody</CODE> object for this <CODE>
+     * SOAPEnvelope</CODE> object.
+     * <p/>
+     * <P>It is illegal to add a body when the envelope already
+     * contains a body. Therefore, this method should be called
+     * only after the existing body has been removed.
+     *
+     * @return the new <CODE>SOAPBody</CODE> object
+     * @throws javax.xml.soap.SOAPException if this <CODE>
+     *                                      SOAPEnvelope</CODE> object already contains a valid
+     *                                      <CODE>SOAPBody</CODE> object
+     */
+    public SOAPBody addBody() throws SOAPException {
+        org.apache.axis2.soap.SOAPBody body = omSOAPEnvelope.getBody();
+        if (body == null) {
+            body = new SOAP11BodyImpl(omSOAPEnvelope);
+            omSOAPEnvelope.addChild(body);
+            return (new SOAPBodyImpl(body));
+        } else {
+            throw new SOAPException("Body already present, can't set body again without " +
+                                    "deleting the existing body.");
+        }
+    }
+
+}
Index: src/org/apache/axis2/saaj2/DetailImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/DetailImpl.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/DetailImpl.java	(working copy)
@@ -27,6 +27,34 @@
 import org.apache.axis2.om.impl.dom.ElementImpl;
 import org.apache.axis2.soap.SOAPFaultDetail;
 
+/**
+ * A container for <code>DetailEntry</code> objects. <code>DetailEntry</code>
+ * objects give detailed error information that is application-specific and
+ * related to the <code>SOAPBody</code> object that contains it.
+ * <P>
+ * A <code>Detail</code> object, which is part of a <code>SOAPFault</code>
+ * object, can be retrieved using the method <code>SOAPFault.getDetail</code>.
+ * The <code>Detail</code> interface provides two methods. One creates a new
+ * <code>DetailEntry</code> object and also automatically adds it to
+ * the <code>Detail</code> object. The second method gets a list of the
+ * <code>DetailEntry</code> objects contained in a <code>Detail</code>
+ * object.
+ * <P>
+ * The following code fragment, in which <i>sf</i> is a <code>SOAPFault</code>
+ * object, gets its <code>Detail</code> object (<i>d</i>), adds a new
+ * <code>DetailEntry</code> object to <i>d</i>, and then gets a list of all the
+ * <code>DetailEntry</code> objects in <i>d</i>. The code also creates a
+ * <code>Name</code> object to pass to the method <code>addDetailEntry</code>.
+ * The variable <i>se</i>, used to create the <code>Name</code> object,
+ * is a <code>SOAPEnvelope</code> object.
+ * <PRE>
+ * Detail d = sf.getDetail();
+ * Name name = se.createName("GetLastTradePrice", "WOMBAT",
+ * "http://www.wombat.org/trader");
+ * d.addDetailEntry(name);
+ * Iterator it = d.getDetailEntries();
+ * </PRE>
+ */
 public class DetailImpl extends SOAPFaultElementImpl implements Detail {
 
 	SOAPFaultDetail faultDetail;
@@ -36,24 +64,32 @@
 	 */
 	public DetailImpl(SOAPFaultDetail element) {
 		super((ElementImpl)element);
-		this.faultDetail = element;
+		faultDetail = element;
 	}
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.Detail#addDetailEntry(javax.xml.soap.Name)
-	 */
+	/**
+     * Creates a new <code>DetailEntry</code> object with the given
+     * name and adds it to this <code>Detail</code> object.
+     *
+     * @param name a <code>Name</code> object identifying the new <code>DetailEntry</code> object
+     * @return DetailEntry.
+     * @throws SOAPException thrown when there is a problem in adding a DetailEntry object to this Detail object.
+     */
 	public DetailEntry addDetailEntry(Name name) throws SOAPException {
-		SOAPElementImpl childElement = (SOAPElementImpl)this.addChildElement(name);
+		SOAPElementImpl childElement = (SOAPElementImpl)addChildElement(name);
 		DetailEntryImpl detailEntryImpl = new DetailEntryImpl(childElement.element);
-		this.faultDetail.addDetailEntry((OMElement)detailEntryImpl);
+		faultDetail.addDetailEntry((OMElement)detailEntryImpl);
 		return detailEntryImpl;
 	}
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.Detail#getDetailEntries()
-	 */
+	/**
+     * Gets a list of the detail entries in this <code>Detail</code> object.
+     *
+     * @return an <code>Iterator</code> object over the <code>DetailEntry</code>
+     *         objects in this <code>Detail</code> object
+     */
 	public Iterator getDetailEntries() {
-		return this.faultDetail.getAllDetailEntries();
+		return faultDetail.getAllDetailEntries();
 	}
 
 }
Index: src/org/apache/axis2/saaj2/PrefixedQName.java
===================================================================
--- src/org/apache/axis2/saaj2/PrefixedQName.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/PrefixedQName.java	(working copy)
@@ -27,7 +27,7 @@
     /**
      * comment/shared empty string
      */
-    private static final String emptyString = "".intern();
+    private static final String EMPTY_STRING = "".intern();
 
     /**
      * Field prefix
@@ -43,13 +43,13 @@
      *
      * @param uri
      * @param localName
-     * @param pre
+     * @param prefix
      */
-    public PrefixedQName(String uri, String localName, String pre) {
+    public PrefixedQName(String uri, String localName, String prefix) {
         qName = new QName(uri, localName);
-        prefix = (pre == null)
-                ? emptyString
-                : pre.intern();
+        this.prefix = (prefix == null)
+                      ? EMPTY_STRING
+                      : prefix.intern();
     }
 
     /**
@@ -60,55 +60,53 @@
      */
     public PrefixedQName(QName qname) {
         this.qName = qname;
-        prefix = emptyString;
+        prefix = EMPTY_STRING;
     }
 
     /**
-     * Method getLocalName
+     * Gets the local name part of the XML name that this <code>Name</code>
+     * object represents.
      *
-     * @return
+     * @return a string giving the local name
      */
     public String getLocalName() {
         return qName.getLocalPart();
     }
 
     /**
-     * Method getQualifiedName
+     * Gets the namespace-qualified name of the XML name that this
+     * <code>Name</code> object represents.
      *
-     * @return
+     * @return the namespace-qualified name as a string
      */
     public String getQualifiedName() {
         StringBuffer buf = new StringBuffer(prefix);
-        if (!prefix.equals(emptyString))
+        if (!prefix.equals(EMPTY_STRING))
             buf.append(':');
         buf.append(qName.getLocalPart());
         return buf.toString();
     }
 
     /**
-     * Method getURI
+     * Returns the URI of the namespace for the XML
+     * name that this <code>Name</code> object represents.
      *
-     * @return
+     * @return the URI as a string
      */
     public String getURI() {
         return qName.getNamespaceURI();
     }
 
     /**
-     * Method getPrefix
+     * Returns the prefix associated with the namespace for the XML
+     * name that this <code>Name</code> object represents.
      *
-     * @return
+     * @return the prefix as a string
      */
     public String getPrefix() {
         return prefix;
     }
 
-    /**
-     * Method equals
-     *
-     * @param obj
-     * @return
-     */
     public boolean equals(Object obj) {
         if (obj == this) {
             return true;
@@ -122,20 +120,10 @@
         return prefix.equals(((PrefixedQName) obj).prefix);
     }
 
-    /**
-     * Method hasCode
-     *
-     * @return
-     */
     public int hashCode() {
         return prefix.hashCode() + qName.hashCode();
     }
 
-    /**
-     * Method toString
-     *
-     * @return
-     */
     public String toString() {
         return qName.toString();
     }
Index: src/org/apache/axis2/saaj2/SOAPMessageImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/SOAPMessageImpl.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/SOAPMessageImpl.java	(working copy)
@@ -15,162 +15,387 @@
  */
 package org.apache.axis2.saaj2;
 
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.Iterator;
+import org.apache.axis2.om.OMOutputFormat;
+import org.apache.axis2.transport.http.HTTPConstants;
 
 import javax.xml.soap.AttachmentPart;
-import javax.xml.soap.MimeHeaders;
+import javax.xml.soap.MimeHeader;
 import javax.xml.soap.SOAPException;
 import javax.xml.soap.SOAPMessage;
 import javax.xml.soap.SOAPPart;
+import javax.xml.soap.SOAPHeader;
+import javax.xml.soap.SOAPBody;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Hashtable;
+import java.util.Iterator;
+import java.util.Map;
 
 public class SOAPMessageImpl extends SOAPMessage {
 
-	
-    private SOAPPartImpl mSOAPPart;
-    private ArrayList attachments = new ArrayList();
-    private java.util.Hashtable mProps = new java.util.Hashtable();
-    private MimeHeadersEx headers;
-	
-    
-    
-    
-	private void setup(Object initialContents, String contentType, String contentLocation,
-            MimeHeaders mimeHeaders) throws SOAPException {
-        if(contentType == null && mimeHeaders != null) {
+    private SOAPPart soapPart;
+    private Collection attachmentParts = new ArrayList();
+    private MimeHeadersEx mimeHeaders;
+
+    private Map props = new Hashtable();
+
+    public SOAPMessageImpl(SOAPEnvelopeImpl soapEnvelope) {
+        String contentType = null;
+        if (mimeHeaders != null) {
             String contentTypes[] = mimeHeaders.getHeader("Content-Type");
-            contentType = (contentTypes != null)? contentTypes[0] : null;
+            contentType = (contentTypes != null) ? contentTypes[0] : null;
         }
 
-        if(contentLocation == null && mimeHeaders != null) {
-            String contentLocations[] = mimeHeaders.getHeader("Content-Location");
-            contentLocation = (contentLocations != null)? contentLocations[0] : null;
+        setCharsetEncoding(contentType);
+
+        soapPart = new SOAPPartImpl(this, soapEnvelope);
+
+        this.mimeHeaders = new MimeHeadersEx();
+    }
+
+    public SOAPMessageImpl(InputStream inputstream,
+                           javax.xml.soap.MimeHeaders mimeHeaders) throws SOAPException {
+        String contentType = null;
+        if (mimeHeaders != null) {
+            String contentTypes[] = mimeHeaders.getHeader("Content-Type");
+            contentType = (contentTypes != null) ? contentTypes[0] : null;
         }
 
-        if (contentType != null) {
-            int delimiterIndex = contentType.lastIndexOf("charset");
-            if (delimiterIndex > 0) {
-                String charsetPart = contentType.substring(delimiterIndex);
-                int charsetIndex = charsetPart.indexOf('=');
-                String charset = charsetPart.substring(charsetIndex + 1).trim();
-                if ((charset.startsWith("\"") || charset.startsWith("\'"))) {
-                    charset = charset.substring(1, charset.length());
+        setCharsetEncoding(contentType);
+        soapPart = new SOAPPartImpl(this, inputstream);
+
+        this.mimeHeaders = (mimeHeaders == null) ?
+                           new MimeHeadersEx() :
+                           new MimeHeadersEx(mimeHeaders);
+    }
+
+    /**
+     * Retrieves a description of this <CODE>SOAPMessage</CODE>
+     * object's content.
+     *
+     * @return a <CODE>String</CODE> describing the content of this
+     *         message or <CODE>null</CODE> if no description has been
+     *         set
+     * @see #setContentDescription(java.lang.String) setContentDescription(java.lang.String)
+     */
+    public String getContentDescription() {
+        String values[] = mimeHeaders.getHeader(HTTPConstants.HEADER_CONTENT_DESCRIPTION);
+        if (values != null && values.length > 0) {
+            return values[0];
+        }
+        return null;
+    }
+
+    /**
+     * Sets the description of this <CODE>SOAPMessage</CODE>
+     * object's content with the given description.
+     *
+     * @param description a <CODE>String</CODE>
+     *                    describing the content of this message
+     * @see #getContentDescription() getContentDescription()
+     */
+    public void setContentDescription(String description) {
+        mimeHeaders.setHeader(HTTPConstants.HEADER_CONTENT_DESCRIPTION, description);
+    }
+
+    /**
+     * Gets the SOAP part of this <CODE>SOAPMessage</CODE> object.
+     * <p/>
+     * <p/>
+     * <P>If a <CODE>SOAPMessage</CODE> object contains one or
+     * more attachments, the SOAP Part must be the first MIME body
+     * part in the message.</P>
+     *
+     * @return the <CODE>SOAPPart</CODE> object for this <CODE>
+     *         SOAPMessage</CODE> object
+     */
+    public SOAPPart getSOAPPart() {
+        return soapPart;
+    }
+
+    /**
+     * Removes all <CODE>AttachmentPart</CODE> objects that have
+     * been added to this <CODE>SOAPMessage</CODE> object.
+     * <p/>
+     * <P>This method does not touch the SOAP part.</P>
+     */
+    public void removeAllAttachments() {
+        attachmentParts.clear();
+    }
+
+    /**
+     * Gets a count of the number of attachments in this
+     * message. This count does not include the SOAP part.
+     *
+     * @return the number of <CODE>AttachmentPart</CODE> objects
+     *         that are part of this <CODE>SOAPMessage</CODE>
+     *         object
+     */
+    public int countAttachments() {
+        return attachmentParts.size();
+    }
+
+    /**
+     * Retrieves all the <CODE>AttachmentPart</CODE> objects
+     * that are part of this <CODE>SOAPMessage</CODE> object.
+     *
+     * @return an iterator over all the attachments in this
+     *         message
+     */
+    public Iterator getAttachments() {
+        return attachmentParts.iterator();
+    }
+
+    /**
+     * Retrieves all the AttachmentPart objects that have header entries that match the specified
+     * headers.
+     * Note that a returned attachment could have headers in addition to those specified.
+     *
+     * @param headers a {@link javax.xml.soap.MimeHeaders}
+     *                object containing the MIME headers for which to search
+     * @return an iterator over all attachments({@link javax.xml.soap.AttachmentPart})
+     *         that have a header that matches one of the given headers
+     */
+    public Iterator getAttachments(javax.xml.soap.MimeHeaders headers) {
+        Collection matchingAttachmentParts = new ArrayList();
+        Iterator iterator = getAttachments();
+        {
+            AttachmentPartImpl part;
+            while (iterator.hasNext()) {
+                part = (AttachmentPartImpl) iterator.next();
+                if (part.matches(headers)) {
+                    matchingAttachmentParts.add(part);
                 }
-                if ((charset.endsWith("\"") || charset.endsWith("\'"))) {
-                    charset = charset.substring(0, charset.length()-1);
-                }
-                try {
-                    setProperty(SOAPMessage.CHARACTER_SET_ENCODING, charset);
-                } catch (SOAPException e) {
-                }
             }
         }
-        
-	}
-	
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPMessage#getContentDescription()
-	 */
-	public String getContentDescription() {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+        return matchingAttachmentParts.iterator();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPMessage#setContentDescription(java.lang.String)
-	 */
-	public void setContentDescription(String description) {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+    /**
+     * Adds the given <CODE>AttachmentPart</CODE> object to this
+     * <CODE>SOAPMessage</CODE> object. An <CODE>
+     * AttachmentPart</CODE> object must be created before it can be
+     * added to a message.
+     *
+     * @param attachmentPart an <CODE>
+     *                       AttachmentPart</CODE> object that is to become part of
+     *                       this <CODE>SOAPMessage</CODE> object
+     * @throws java.lang.IllegalArgumentException
+     *
+     */
+    public void addAttachmentPart(AttachmentPart attachmentPart) {
+        if (attachmentPart != null) {
+            attachmentParts.add(attachmentPart);
+            mimeHeaders.setHeader("Content-Type", "multipart/related");
+        }
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPMessage#getSOAPPart()
-	 */
-	public SOAPPart getSOAPPart() {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+    /**
+     * Creates a new empty <CODE>AttachmentPart</CODE> object.
+     * Note that the method <CODE>addAttachmentPart</CODE> must be
+     * called with this new <CODE>AttachmentPart</CODE> object as
+     * the parameter in order for it to become an attachment to this
+     * <CODE>SOAPMessage</CODE> object.
+     *
+     * @return a new <CODE>AttachmentPart</CODE> object that can be
+     *         populated and added to this <CODE>SOAPMessage</CODE>
+     *         object
+     */
+    public AttachmentPart createAttachmentPart() {
+        return new AttachmentPartImpl();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPMessage#removeAllAttachments()
-	 */
-	public void removeAllAttachments() {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+    /**
+     * Returns all the transport-specific MIME headers for this
+     * <CODE>SOAPMessage</CODE> object in a transport-independent
+     * fashion.
+     *
+     * @return a <CODE>MimeHeaders</CODE> object containing the
+     *         <CODE>MimeHeader</CODE> objects
+     */
+    public javax.xml.soap.MimeHeaders getMimeHeaders() {
+        return mimeHeaders;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPMessage#countAttachments()
-	 */
-	public int countAttachments() {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+    /**
+     * Updates this <CODE>SOAPMessage</CODE> object with all the
+     * changes that have been made to it. This method is called
+     * automatically when a message is sent or written to by the
+     * methods <CODE>ProviderConnection.send</CODE>, <CODE>
+     * SOAPConnection.call</CODE>, or <CODE>
+     * SOAPMessage.writeTo</CODE>. However, if changes are made to
+     * a message that was received or to one that has already been
+     * sent, the method <CODE>saveChanges</CODE> needs to be
+     * called explicitly in order to save the changes. The method
+     * <CODE>saveChanges</CODE> also generates any changes that
+     * can be read back (for example, a MessageId in profiles that
+     * support a message id). All MIME headers in a message that
+     * is created for sending purposes are guaranteed to have
+     * valid values only after <CODE>saveChanges</CODE> has been
+     * called.
+     * <p/>
+     * <P>In addition, this method marks the point at which the
+     * data from all constituent <CODE>AttachmentPart</CODE>
+     * objects are pulled into the message.</P>
+     *
+     * @throws SOAPException if there was a problem saving changes to this message.
+     */
+    public void saveChanges() throws SOAPException {
+        // TODO not sure of the implementation
+        throw new UnsupportedOperationException("TODO");
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPMessage#getAttachments()
-	 */
-	public Iterator getAttachments() {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+    /**
+     * Indicates whether this <CODE>SOAPMessage</CODE> object
+     * has had the method {@link #saveChanges()} called on
+     * it.
+     *
+     * @return <CODE>true</CODE> if <CODE>saveChanges</CODE> has
+     *         been called on this message at least once; <CODE>
+     *         false</CODE> otherwise.
+     */
+    public boolean saveRequired() {
+        return false;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPMessage#getAttachments(javax.xml.soap.MimeHeaders)
-	 */
-	public Iterator getAttachments(javax.xml.soap.MimeHeaders headers) {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+    /**
+     * Writes this <CODE>SOAPMessage</CODE> object to the given
+     * output stream. The externalization format is as defined by
+     * the SOAP 1.1 with Attachments specification.
+     * <p/>
+     * <P>If there are no attachments, just an XML stream is
+     * written out. For those messages that have attachments,
+     * <CODE>writeTo</CODE> writes a MIME-encoded byte stream.</P>
+     *
+     * @param out the <CODE>OutputStream</CODE>
+     *            object to which this <CODE>SOAPMessage</CODE> object will
+     *            be written
+     * @throws SOAPException if there was a problem in externalizing this SOAP message
+     * @throws IOException   if an I/O error occurs
+     */
+    public void writeTo(OutputStream out) throws SOAPException, IOException {
+        try {
+            OMOutputFormat format = new OMOutputFormat();
+            format.setCharSetEncoding((String) getProperty(CHARACTER_SET_ENCODING));
+            String writeXmlDecl = (String) getProperty(WRITE_XML_DECLARATION);
+            if (writeXmlDecl == null || writeXmlDecl.equals("false")) {
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPMessage#addAttachmentPart(javax.xml.soap.AttachmentPart)
-	 */
-	public void addAttachmentPart(AttachmentPart attachmentpart) {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+                //SAAJ default case doesn't send XML decl
+                format.setIgnoreXMLDeclaration(true);
+            }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPMessage#createAttachmentPart()
-	 */
-	public AttachmentPart createAttachmentPart() {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+            //the writeTo method forces the elements to be built!!!
+            ((SOAPEnvelopeImpl) soapPart.getEnvelope()).getOMEnvelope().serialize(out, format);
+        } catch (Exception e) {
+            throw new SOAPException(e);
+        }
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPMessage#getMimeHeaders()
-	 */
-	public javax.xml.soap.MimeHeaders getMimeHeaders() {
-		return this.headers;
-	}
+    /**
+     * Associates the specified value with the specified property. If there was
+     * already a value associated with this property, the old value is replaced.
+     * <p/>
+     * The valid property names include <code>WRITE_XML_DECLARATION</code> and
+     * <code>CHARACTER_SET_ENCODING</code>. All of these standard SAAJ
+     * properties are prefixed by "javax.xml.soap". Vendors may also add
+     * implementation specific properties. These properties must be prefixed
+     * with package names that are unique to the vendor.
+     * <p/>
+     * Setting the property <code>WRITE_XML_DECLARATION</code> to
+     * <code>"true"</code> will cause an XML Declaration to be written out at
+     * the start of the SOAP message. The default value of "false" suppresses
+     * this declaration.
+     * <p/>
+     * The property <code>CHARACTER_SET_ENCODING</code> defaults to the value
+     * <code>"utf-8"</code> which causes the SOAP message to be encoded using
+     * UTF-8. Setting <code>CHARACTER_SET_ENCODING</code> to
+     * <code>"utf-16"</code> causes the SOAP message to be encoded using UTF-16.
+     * <p/>
+     * Some implementations may allow encodings in addition to UTF-8 and UTF-16.
+     * Refer to your vendor's documentation for details.
+     *
+     * @param property the property with which the specified value is to be
+     *                 associated
+     * @param value    the value
+     *                 to be associated with the specified property
+     */
+    public void setProperty(String property, Object value) {
+        props.put(property, value);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPMessage#saveChanges()
-	 */
-	public void saveChanges() throws SOAPException {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+    /**
+     * Retrieves value of the specified property.
+     *
+     * @param property the name of the property to retrieve
+     * @return the value of the property or <code>null</code> if no such
+     *         property exists
+     * @throws SOAPException if the property name is not recognized
+     */
+    public Object getProperty(String property) throws SOAPException {
+        return props.get(property);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPMessage#saveRequired()
-	 */
-	public boolean saveRequired() {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+    /**
+     * Gets the SOAP Header contained in this <code>SOAPMessage</code> object.
+     *
+     * @return the <code>SOAPHeader</code> object contained by this
+     *         <code>SOAPMessage</code> object
+     * @throws javax.xml.soap.SOAPException if the SOAP Header does not exist or cannot be
+     *                                      retrieved
+     */
+    public SOAPHeader getSOAPHeader() throws SOAPException {
+        return this.soapPart.getEnvelope().getHeader();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPMessage#writeTo(java.io.OutputStream)
-	 */
-	public void writeTo(OutputStream out) throws SOAPException, IOException {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
-	
+    /**
+     * Gets the SOAP Body contained in this <code>SOAPMessage</code> object.
+     *
+     * @return the <code>SOAPBody</code> object contained by this
+     *         <code>SOAPMessage</code> object
+     * @throws javax.xml.soap.SOAPException if the SOAP Body does not exist or cannot be
+     *                                      retrieved
+     */
+    public SOAPBody getSOAPBody() throws SOAPException {
+        return this.soapPart.getEnvelope().getBody();
+    }
+
+    /**
+     * Retrieve the MIME Header names by providing the {@link javax.xml.soap.MimeHeaders} Object
+     *
+     * @param headers The {@link javax.xml.soap.MimeHeaders} Object
+     * @return MIME Header names corresponding to the <code>headers</code>
+     */
+    private String[] getMimeHeaderNames(final javax.xml.soap.MimeHeaders headers) {
+        Collection mimeHeaderNames = new ArrayList();
+        for (Iterator iterator = headers.getAllHeaders(); iterator.hasNext();) {
+            mimeHeaderNames.add(((MimeHeader) iterator.next()).getName());
+        }
+        return (String[]) mimeHeaderNames.toArray(new String[0]);
+    }
+
+    /**
+     * Set the character encoding based on the <code>contentType</code> parameter
+     *
+     * @param contentType
+     */
+    private void setCharsetEncoding(final String contentType) {
+        if (contentType != null) {
+            int delimiterIndex = contentType.lastIndexOf("charset");
+            if (delimiterIndex > 0) {
+                String charsetPart = contentType.substring(delimiterIndex);
+                int charsetIndex = charsetPart.indexOf('=');
+                String charset = charsetPart.substring(charsetIndex + 1).trim();
+                if ((charset.startsWith("\"") || charset.startsWith("\'"))) {
+                    charset = charset.substring(1, charset.length());
+                }
+                if ((charset.endsWith("\"") || charset.endsWith("\'"))) {
+                    charset = charset.substring(0, charset.length() - 1);
+                }
+                setProperty(SOAPMessage.CHARACTER_SET_ENCODING, charset);
+            }
+        }
+    }
 }
Index: src/org/apache/axis2/saaj2/SOAPConnectionFactoryImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/SOAPConnectionFactoryImpl.java	(revision 0)
+++ src/org/apache/axis2/saaj2/SOAPConnectionFactoryImpl.java	(revision 0)
@@ -0,0 +1,36 @@
+/*                                                                             
+ * Copyright 2004,2005 The Apache Software Foundation.                         
+ *                                                                             
+ * Licensed under the Apache License, Version 2.0 (the "License");             
+ * you may not use this file except in compliance with the License.            
+ * You may obtain a copy of the License at                                     
+ *                                                                             
+ *      http://www.apache.org/licenses/LICENSE-2.0                             
+ *                                                                             
+ * Unless required by applicable law or agreed to in writing, software         
+ * distributed under the License is distributed on an "AS IS" BASIS,           
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    
+ * See the License for the specific language governing permissions and         
+ * limitations under the License.                                              
+ */
+package org.apache.axis2.saaj2;
+
+import javax.xml.soap.SOAPConnectionFactory;
+import javax.xml.soap.SOAPConnection;
+import javax.xml.soap.SOAPException;
+
+/**
+ * 
+ */
+public class SOAPConnectionFactoryImpl extends SOAPConnectionFactory {
+    /**
+     * Create a new <CODE>SOAPConnection</CODE>.
+     *
+     * @return the new <CODE>SOAPConnection</CODE> object.
+     * @throws javax.xml.soap.SOAPException if there was an exception
+     *                                      creating the <CODE>SOAPConnection</CODE> object.
+     */
+    public SOAPConnection createConnection() throws SOAPException {
+        return new SOAPConnectionImpl();
+    }
+}
Index: src/org/apache/axis2/saaj2/SOAPHeaderImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/SOAPHeaderImpl.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/SOAPHeaderImpl.java	(working copy)
@@ -15,121 +15,157 @@
  */
 package org.apache.axis2.saaj2;
 
-import java.util.ArrayList;
-import java.util.Iterator;
+import org.apache.axis2.om.OMNamespace;
+import org.apache.axis2.om.impl.dom.ElementImpl;
+import org.apache.axis2.om.impl.dom.NamespaceImpl;
+import org.apache.axis2.soap.SOAPHeaderBlock;
+import org.apache.axis2.soap.impl.dom.soap11.SOAP11HeaderBlockImpl;
 
 import javax.xml.soap.Name;
 import javax.xml.soap.SOAPException;
 import javax.xml.soap.SOAPHeader;
 import javax.xml.soap.SOAPHeaderElement;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
 
-import org.apache.axis2.om.OMNamespace;
-import org.apache.axis2.om.impl.dom.ElementImpl;
-import org.apache.axis2.om.impl.dom.NamespaceImpl;
-import org.apache.axis2.soap.SOAPHeaderBlock;
-import org.apache.axis2.soap.impl.dom.soap11.SOAP11HeaderBlockImpl;
+public class SOAPHeaderImpl extends SOAPElementImpl implements SOAPHeader {
 
-public class SOAPHeaderImpl extends SOAPElementImpl implements
-		SOAPHeader {
+    private org.apache.axis2.soap.SOAPHeader omSOAPHeader;
 
-    private org.apache.axis2.soap.SOAPHeader omHeader;
-    
-	/**
-	 * @param element
-	 */
-	public SOAPHeaderImpl(org.apache.axis2.soap.SOAPHeader header) {
-		super((ElementImpl)header);
-		this.omHeader = header;
-	}
+    /**
+     * Constructor
+     *
+     * @param header
+     */
+    public SOAPHeaderImpl(org.apache.axis2.soap.SOAPHeader header) {
+        super((ElementImpl) header);
+        omSOAPHeader = header;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPHeader#addHeaderElement(javax.xml.soap.Name)
-	 */
-	public SOAPHeaderElement addHeaderElement(Name name) throws SOAPException {
-		OMNamespace ns = new NamespaceImpl(name.getURI(), name.getPrefix());
-		SOAPHeaderBlock headerBlock = new SOAP11HeaderBlockImpl(name.getLocalName(), ns, this.omHeader);
-		return new SOAPHeaderElementImpl(headerBlock);
-	}
+    /**
+     * Creates a new <CODE>SOAPHeaderElement</CODE> object
+     * initialized with the specified name and adds it to this
+     * <CODE>SOAPHeader</CODE> object.
+     *
+     * @param name a <CODE>Name</CODE> object with
+     *             the name of the new <CODE>SOAPHeaderElement</CODE>
+     *             object
+     * @return the new <CODE>SOAPHeaderElement</CODE> object that
+     *         was inserted into this <CODE>SOAPHeader</CODE>
+     *         object
+     * @throws SOAPException if a SOAP error occurs
+     */
+    public SOAPHeaderElement addHeaderElement(Name name) throws SOAPException {
+        OMNamespace ns = new NamespaceImpl(name.getURI(), name.getPrefix());
+        SOAPHeaderBlock headerBlock = new SOAP11HeaderBlockImpl(name.getLocalName(), ns, omSOAPHeader);
+        return new SOAPHeaderElementImpl(headerBlock);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPHeader#examineHeaderElements(java.lang.String)
-	 */
-	public Iterator examineHeaderElements(String actor) {
-		Iterator headerElems = this.omHeader.examineHeaderBlocks(actor);
-		ArrayList aList = new ArrayList();
-		while (headerElems.hasNext()) {
-			Object element =  headerElems.next();
-			if(element instanceof SOAPHeaderBlock) {
-				aList.add(new SOAPHeaderElementImpl((SOAPHeaderBlock)element));
-			}
-			
-		}
-		return aList.iterator();
-	}
+    /**
+     * Returns a list of all the <CODE>SOAPHeaderElement</CODE>
+     * objects in this <CODE>SOAPHeader</CODE> object that have the
+     * the specified actor. An actor is a global attribute that
+     * indicates the intermediate parties to whom the message should
+     * be sent. An actor receives the message and then sends it to
+     * the next actor. The default actor is the ultimate intended
+     * recipient for the message, so if no actor attribute is
+     * included in a <CODE>SOAPHeader</CODE> object, the message is
+     * sent to its ultimate destination.
+     *
+     * @param actor a <CODE>String</CODE> giving the
+     *              URI of the actor for which to search
+     * @return an <CODE>Iterator</CODE> object over all the <CODE>
+     *         SOAPHeaderElement</CODE> objects that contain the
+     *         specified actor
+     * @see #extractHeaderElements(java.lang.String) extractHeaderElements(java.lang.String)
+     */
+    public Iterator examineHeaderElements(String actor) {
+        Collection elements = new ArrayList();
+        for (Iterator iterator = omSOAPHeader.examineHeaderBlocks(actor); iterator.hasNext();) {
+            elements.add(new SOAPHeaderElementImpl((SOAPHeaderBlock) iterator.next()));
+        }
+        return elements.iterator();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPHeader#extractHeaderElements(java.lang.String)
-	 */
-	public Iterator extractHeaderElements(String actor) {
-		Iterator headerElems = this.omHeader.extractHeaderBlocks(actor);
-		ArrayList aList = new ArrayList();
-		while (headerElems.hasNext()) {
-			Object element =  headerElems.next();
-			if(element instanceof SOAPHeaderBlock) {
-				aList.add(new SOAPHeaderElementImpl((SOAPHeaderBlock)element));
-			}
-			
-		}
-		return aList.iterator();
-	}
+    /**
+     * Returns a list of all the <CODE>SOAPHeaderElement</CODE>
+     * objects in this <CODE>SOAPHeader</CODE> object that have
+     * the the specified actor and detaches them from this <CODE>
+     * SOAPHeader</CODE> object.
+     * <p/>
+     * <P>This method allows an actor to process only the parts of
+     * the <CODE>SOAPHeader</CODE> object that apply to it and to
+     * remove them before passing the message on to the next
+     * actor.
+     *
+     * @param actor a <CODE>String</CODE> giving the
+     *              URI of the actor for which to search
+     * @return an <CODE>Iterator</CODE> object over all the <CODE>
+     *         SOAPHeaderElement</CODE> objects that contain the
+     *         specified actor
+     * @see #examineHeaderElements(java.lang.String) examineHeaderElements(java.lang.String)
+     */
+    public Iterator extractHeaderElements(String actor) {
+        Collection elements = new ArrayList();
+        for (Iterator iterator = omSOAPHeader.extractHeaderBlocks(actor); iterator.hasNext();) {
+            elements.add(new SOAPHeaderElementImpl((SOAPHeaderBlock) iterator.next()));
+        }
+        return elements.iterator();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPHeader#examineMustUnderstandHeaderElements(java.lang.String)
-	 */
-	public Iterator examineMustUnderstandHeaderElements(String actor) {
-		Iterator headerElems = this.omHeader.examineMustUnderstandHeaderBlocks(actor);
-		ArrayList aList = new ArrayList();
-		while (headerElems.hasNext()) {
-			Object element =  headerElems.next();
-			if(element instanceof SOAPHeaderBlock) {
-				aList.add(new SOAPHeaderElementImpl((SOAPHeaderBlock)element));
-			}
-			
-		}
-		return aList.iterator();
-	}
+    /**
+     * Returns an <code>Iterator</code> over all the
+     * <code>SOAPHeaderElement</code> objects in this <code>SOAPHeader</code>
+     * object that have the specified actor and that have a MustUnderstand
+     * attribute whose value is equivalent to <code>true</code>.
+     *
+     * @param actor a <code>String</code> giving the URI of the actor for which
+     *              to search
+     * @return an <code>Iterator</code> object over all the
+     *         <code>SOAPHeaderElement</code> objects that contain the
+     *         specified actor and are marked as MustUnderstand
+     */
+    public Iterator examineMustUnderstandHeaderElements(String actor) {
+        Collection elements = new ArrayList();
+        for (Iterator iterator = omSOAPHeader.examineMustUnderstandHeaderBlocks(actor); iterator.hasNext();)
+        {
+            elements.add(new SOAPHeaderElementImpl((SOAPHeaderBlock) iterator.next()));
+        }
+        return elements.iterator();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPHeader#examineAllHeaderElements()
-	 */
-	public Iterator examineAllHeaderElements() {
-		Iterator headerElems = this.omHeader.examineAllHeaderBlocks();
-		ArrayList aList = new ArrayList();
-		while (headerElems.hasNext()) {
-			Object element =  headerElems.next();
-			if(element instanceof SOAPHeaderBlock) {
-				aList.add(new SOAPHeaderElementImpl((SOAPHeaderBlock)element));
-			}
-			
-		}
-		return aList.iterator();
-	}
+    /**
+     * Returns an <code>Iterator</code> over all the
+     * <code>SOAPHeaderElement</code> objects in this <code>SOAPHeader</code>
+     * object.
+     *
+     * @return an <code>Iterator</code> object over all the
+     *         <code>SOAPHeaderElement</code> objects contained by this
+     *         <code>SOAPHeader</code>
+     */
+    public Iterator examineAllHeaderElements() {
+        Collection elements = new ArrayList();
+        for (Iterator iterator = omSOAPHeader.examineAllHeaderBlocks(); iterator.hasNext();) {
+            elements.add(new SOAPHeaderElementImpl((SOAPHeaderBlock) iterator.next()));
+        }
+        return elements.iterator();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPHeader#extractAllHeaderElements()
-	 */
-	public Iterator extractAllHeaderElements() {
-		Iterator headerElems = this.omHeader.extractAllHeaderBlocks();
-		ArrayList aList = new ArrayList();
-		while (headerElems.hasNext()) {
-			Object element =  headerElems.next();
-			if(element instanceof SOAPHeaderBlock) {
-				aList.add(new SOAPHeaderElementImpl((SOAPHeaderBlock)element));
-			}
-			
-		}
-		return aList.iterator();
-	}
-
-	
+    /**
+     * Returns an <code>Iterator</code> over all the
+     * <code>SOAPHeaderElement</code> objects in this <code>SOAPHeader </code>
+     * object and detaches them from this <code>SOAPHeader</code> object.
+     *
+     * @return an <code>Iterator</code> object over all the
+     *         <code>SOAPHeaderElement</code> objects contained by this
+     *         <code>SOAPHeader</code>
+     */
+    public Iterator extractAllHeaderElements() {
+        Collection elements = new ArrayList();
+        for (Iterator iterator = omSOAPHeader.extractAllHeaderBlocks(); iterator.hasNext();) {
+            elements.add(new SOAPHeaderElementImpl((SOAPHeaderBlock) iterator.next()));
+        }
+        return elements.iterator();
+    }
 }
\ No newline at end of file
Index: src/org/apache/axis2/saaj2/SOAPElementImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/SOAPElementImpl.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/SOAPElementImpl.java	(working copy)
@@ -15,179 +15,226 @@
  */
 package org.apache.axis2.saaj2;
 
-import java.util.ArrayList;
-import java.util.Iterator;
-
-import javax.xml.namespace.QName;
-import javax.xml.soap.Name;
-import javax.xml.soap.SOAPElement;
-import javax.xml.soap.SOAPException;
-import javax.xml.stream.XMLStreamException;
-
+import org.apache.axis2.om.OMAttribute;
 import org.apache.axis2.om.OMContainer;
 import org.apache.axis2.om.OMException;
 import org.apache.axis2.om.OMNamespace;
+import org.apache.axis2.om.OMNode;
 import org.apache.axis2.om.impl.OMOutputImpl;
 import org.apache.axis2.om.impl.dom.DocumentImpl;
 import org.apache.axis2.om.impl.dom.ElementImpl;
+import org.apache.axis2.om.impl.dom.TextImpl;
 import org.w3c.dom.Attr;
 import org.w3c.dom.DOMException;
+import org.w3c.dom.Document;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 import org.w3c.dom.Text;
 
+import javax.xml.namespace.QName;
+import javax.xml.soap.Name;
+import javax.xml.soap.SOAPElement;
+import javax.xml.soap.SOAPException;
+import javax.xml.stream.XMLStreamException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
 
+
 public class SOAPElementImpl extends NodeImplEx implements SOAPElement {
 
-	
-	/**
-	 * Using a delegate because we can't extend from 
-	 * org.apache.axis2.om.impl.dom.ElementImpl since this class
-	 * must extend SNodeImpl
-	 */
-	protected ElementImpl element;
-	
-	public SOAPElementImpl(ElementImpl element) {
-		this.element = element;
-	}
 
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.om.OMNode#discard()
-	 */
-	public void discard() throws OMException {
-		this.element.discard();
-	}
+    /**
+     * Using a delegate because we can't extend from
+     * org.apache.axis2.om.impl.dom.ElementImpl since this class
+     * must extend SNodeImpl
+     */
+    protected ElementImpl element;
 
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.om.OMNode#serialize(org.apache.axis2.om.impl.OMOutputImpl)
-	 */
-	public void serialize(OMOutputImpl omOutput) throws XMLStreamException {
-		this.element.serialize(omOutput);
-	}
+    public SOAPElementImpl(ElementImpl element) {
+        this.element = element;
+    }
 
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.om.OMNode#serializeAndConsume(org.apache.axis2.om.impl.OMOutputImpl)
-	 */
-	public void serializeAndConsume(OMOutputImpl omOutput) throws XMLStreamException {
-		this.element.serializeAndConsume(omOutput);
-	}
+    /* (non-Javadoc)
+      * @see org.apache.axis2.om.OMNode#discard()
+      */
+    public void discard() throws OMException {
+        this.element.discard();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#addAttribute(javax.xml.soap.Name, java.lang.String)
-	 */
-	public SOAPElement addAttribute(Name name, String value) throws SOAPException {
-		this.element.setAttributeNS(name.getURI(), name.getPrefix() + ":" + name.getLocalName(), value);
-		return this;
-	}
+    /* (non-Javadoc)
+      * @see org.apache.axis2.om.OMNode#serialize(org.apache.axis2.om.impl.OMOutputImpl)
+      */
+    public void serialize(OMOutputImpl omOutput) throws XMLStreamException {
+        this.element.serialize(omOutput);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#addChildElement(javax.xml.soap.Name)
-	 */
-	public SOAPElement addChildElement(Name name) throws SOAPException {
-		return this.addChildElement(name.getLocalName(),name.getPrefix(), name.getURI());
-	}
+    /* (non-Javadoc)
+      * @see org.apache.axis2.om.OMNode#serializeAndConsume(org.apache.axis2.om.impl.OMOutputImpl)
+      */
+    public void serializeAndConsume(OMOutputImpl omOutput) throws XMLStreamException {
+        this.element.serializeAndConsume(omOutput);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#addChildElement(javax.xml.soap.SOAPElement)
-	 */
-	public SOAPElement addChildElement(SOAPElement soapElement) throws SOAPException {
-		this.element.appendChild(soapElement);
-		return soapElement;
-	}
+    /**
+     * Adds an attribute with the specified name and value to this
+     * <code>SOAPElement</code> object.
+     * <p/>
+     *
+     * @param name  a <code>Name</code> object with the name of the attribute
+     * @param value a <code>String</code> giving the value of the attribute
+     * @return the <code>SOAPElement</code> object into which the attribute was
+     *         inserted
+     * @throws SOAPException if there is an error in creating the
+     *                       Attribute
+     */
+    public SOAPElement addAttribute(Name name, String value) throws SOAPException {
+        if (name.getURI() == null || name.getURI().trim().length() == 0) {
+            this.element.setAttribute(name.getLocalName(), value);
+        } else {
+            this.element.setAttributeNS(name.getURI(), name.getPrefix() + ":" + name.getLocalName(), value);
+        }
+        return this;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#addChildElement(java.lang.String, java.lang.String, java.lang.String)
-	 */
-	public SOAPElement addChildElement(String localName, String prefix, String uri) throws SOAPException {
-		this.element.declareNamespace(uri, prefix);
-		return this.addChildElement(localName, prefix);
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#addChildElement(javax.xml.soap.Name)
+      */
+    public SOAPElement addChildElement(Name name) throws SOAPException {
+        return this.addChildElement(name.getLocalName(), name.getPrefix(), name.getURI());
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#addChildElement(java.lang.String, java.lang.String)
-	 */
-	public SOAPElement addChildElement(String localName, String prefix) throws SOAPException {
-		String namespaceURI = this.getNamespaceURI(prefix);
-		if(namespaceURI == null) {
-			throw new SOAPException("Namespace not declared for the give prefix: " + prefix);
-		}
-		SOAPElementImpl elem = new SOAPElementImpl((ElementImpl)this.getOwnerDocument().createElementNS(namespaceURI, localName));
-		this.element.appendChild(elem);
-		return elem;
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#addChildElement(javax.xml.soap.SOAPElement)
+      */
+    public SOAPElement addChildElement(SOAPElement soapElement) throws SOAPException {
+        this.element.appendChild(soapElement);
+        return soapElement;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#addChildElement(java.lang.String)
-	 */
-	public SOAPElement addChildElement(String localName) throws SOAPException {
-		SOAPElementImpl elem = new SOAPElementImpl((ElementImpl)this.getOwnerDocument().createElement(localName));
-		this.element.appendChild(elem);
-		return elem;
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#addChildElement(java.lang.String, java.lang.String, java.lang.String)
+      */
+    public SOAPElement addChildElement(String localName, String prefix, String uri) throws SOAPException {
+        this.element.declareNamespace(uri, prefix);
+        return this.addChildElement(localName, prefix);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#addNamespaceDeclaration(java.lang.String, java.lang.String)
-	 */
-	public SOAPElement addNamespaceDeclaration(String prefix, String uri) throws SOAPException {
-		this.element.declareNamespace(prefix, uri);
-		return this;
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#addChildElement(java.lang.String, java.lang.String)
+      */
+    public SOAPElement addChildElement(String localName, String prefix) throws SOAPException {
+        String namespaceURI = this.getNamespaceURI(prefix);
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#addTextNode(java.lang.String)
-	 */
-	public SOAPElement addTextNode(String text) throws SOAPException {
-		//OmElement.setText() will remove all the other text nodes that it contains
-		//Therefore create a text node and add it
-		Text textNode = this.getOwnerDocument().createTextNode(text);
-		this.element.appendChild(textNode);
-		return this;
-	}
+        if (namespaceURI == null) {
+            throw new SOAPException("Namespace not declared for the give prefix: " + prefix);
+        }
+        SOAPElementImpl elem =
+                new SOAPElementImpl((ElementImpl) this.getOwnerDocument().createElementNS(namespaceURI,
+                                                                                          localName));
+        this.element.appendChild(elem.element);
+        return elem;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#getAllAttributes()
-	 */
-	public Iterator getAllAttributes() {
-		return this.element.getAllAttributes();
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#addChildElement(java.lang.String)
+      */
+    public SOAPElement addChildElement(String localName) throws SOAPException {
+        SOAPElementImpl elem = new SOAPElementImpl((ElementImpl) this.getOwnerDocument().createElement(localName));
+        this.element.appendChild(elem.element);
+        return elem;
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#getAttributeValue(javax.xml.soap.Name)
-	 */
-	public String getAttributeValue(Name name) {
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#addNamespaceDeclaration(java.lang.String, java.lang.String)
+      */
+    public SOAPElement addNamespaceDeclaration(String prefix, String uri) throws SOAPException {
+        this.element.declareNamespace(prefix, uri);
+        return this;
+    }
+
+    /**
+     * Creates a new <code>Text</code> object initialized with the given
+     * <code>String</code> and adds it to this <code>SOAPElement</code> object.
+     *
+     * @param text a <code>String</code> object with the textual content to be added
+     * @return the <code>SOAPElement</code> object into which
+     *         the new <code>Text</code> object was inserted
+     * @throws SOAPException if there is an error in creating the
+     *                       new <code>Text</code> object
+     */
+    public SOAPElement addTextNode(String text) throws SOAPException {
+        //OmElement.setText() will remove all the other text nodes that it contains
+        //Therefore create a text node and add it
+        Text textNode = this.getOwnerDocument().createTextNode(text);
+        this.element.appendChild(textNode);
+        return this;
+    }
+
+    /**
+     * Returns an iterator over all of the attribute names in
+     * this <CODE>SOAPElement</CODE> object. The iterator can be
+     * used to get the attribute names, which can then be passed to
+     * the method <CODE>getAttributeValue</CODE> to retrieve the
+     * value of each attribute.
+     *
+     * @return an iterator over the names of the attributes
+     */
+    public Iterator getAllAttributes() {
+        final Iterator attribIter = this.element.getAllAttributes();
+        Collection attribName = new ArrayList();
+        Attr attr;
+        while (attribIter.hasNext()) {
+            attr = (Attr) attribIter.next();
+            PrefixedQName qname;
+            if (attr.getNamespaceURI() == null || attr.getNamespaceURI().trim().length() == 0) {
+                qname = new PrefixedQName(attr.getNamespaceURI(),
+                                          attr.getName(),
+                                          attr.getPrefix());
+            } else {
+                qname = new PrefixedQName(attr.getNamespaceURI(),
+                                          attr.getLocalName(),
+                                          attr.getPrefix());
+            }
+            attribName.add(qname);
+        }
+        return attribName.iterator();
+    }
+
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#getAttributeValue(javax.xml.soap.Name)
+      */
+    public String getAttributeValue(Name name) {
         //This method is waiting on the finalization of the name for a method
         //in OMElement that returns a OMAttribute from an input QName
-		return this.element.getFirstAttribute(
-                new QName(name.getURI(),
-                        name.getLocalName(),
-                        name.getPrefix()))
-                .getAttributeValue();
-	}
+        final OMAttribute attribute = this.element.getAttribute(new QName(name.getURI(),
+                                                                          name.getLocalName(),
+                                                                          name.getPrefix()));
+        return attribute.getAttributeValue();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#getChildElements()
-	 */
-	public Iterator getChildElements() {
+    public Iterator getChildElements() {
         //Actually all the children are being treated as OMNodes and are being
         //wrapped accordingly to a single type (SOAPElement) and being returned in an iterator.
         //Text nodes and element nodes are all being treated alike here. Is that a serious issue???
+
         Iterator childIter = this.element.getChildren();
-        ArrayList arrayList = new ArrayList();
+        Collection childElements = new ArrayList();
         while (childIter.hasNext()) {
             Object o = childIter.next();
-            if (o instanceof javax.xml.soap.Node) {
-            	arrayList.add(o);
-                //javax.xml.soap.Node childElement = new NodeImpl((org.apache.axis2.om.OMNode)o);
-
+            if (o instanceof Text) {
+                childElements.add(new TextImplEx(((Text) o).getData()));
+            } else {
+                childElements.add(new SOAPElementImpl((ElementImpl) o));
             }
         }
-        return arrayList.iterator();
-	}
+        return childElements.iterator();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#getChildElements(javax.xml.soap.Name)
-	 */
-	public Iterator getChildElements(Name name) {
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#getChildElements(javax.xml.soap.Name)
+      */
+    public Iterator getChildElements(Name name) {
         QName qName = new QName(name.getURI(), name.getLocalName());
         Iterator childIter = this.element.getChildrenWithName(qName);
         ArrayList arrayList = new ArrayList();
@@ -198,29 +245,29 @@
             }
         }
         return arrayList.iterator();
-	}
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#getElementName()
-	 */
-	public Name getElementName() {
-		QName qName = this.element.getQName();
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#getElementName()
+      */
+    public Name getElementName() {
+        QName qName = this.element.getQName();
         return new PrefixedQName(qName.getNamespaceURI(),
-                qName.getLocalPart(),
-                qName.getPrefix());
-	}
+                                 qName.getLocalPart(),
+                                 qName.getPrefix());
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#getEncodingStyle()
-	 */
-	public String getEncodingStyle() {
-		return ((DocumentImpl)this.getOwnerDocument()).getCharsetEncoding();
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#getEncodingStyle()
+      */
+    public String getEncodingStyle() {
+        return ((DocumentImpl) this.getOwnerDocument()).getCharsetEncoding();
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#getNamespacePrefixes()
-	 */
-	public Iterator getNamespacePrefixes() {
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#getNamespacePrefixes()
+      */
+    public Iterator getNamespacePrefixes() {
         //Get all declared namespace, make a list of their prefixes and return an iterator over that list
         ArrayList prefixList = new ArrayList();
         Iterator nsIter = this.element.getAllDeclaredNamespaces();
@@ -232,29 +279,29 @@
             }
         }
         return prefixList.iterator();
-	}
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#getNamespaceURI(java.lang.String)
-	 */
-	public String getNamespaceURI(String prefix) {
-		return this.element.getNamespaceURI(prefix);
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#getNamespaceURI(java.lang.String)
+      */
+    public String getNamespaceURI(String prefix) {
+        return this.element.getNamespaceURI(prefix);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#getVisibleNamespacePrefixes()
-	 */
-	public Iterator getVisibleNamespacePrefixes() {
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#getVisibleNamespacePrefixes()
+      */
+    public Iterator getVisibleNamespacePrefixes() {
         //I'll recursively return all the declared namespaces till this node, including its parents etc.
         Iterator namespacesIter = this.element.getAllDeclaredNamespaces();
         ArrayList returnList = new ArrayList();
         while (namespacesIter.hasNext()) {
             Object o = namespacesIter.next();
             if (o instanceof OMNamespace) {
-            	OMNamespace ns = (OMNamespace)o;
-            	if(ns.getPrefix() != null) {
-            		returnList.add(ns.getPrefix());
-            	}
+                OMNamespace ns = (OMNamespace) o;
+                if (ns.getPrefix() != null) {
+                    returnList.add(ns.getPrefix());
+                }
             }
         }
         //taken care of adding namespaces of this node.
@@ -266,35 +313,34 @@
             while (parentScopeNamespacesIter.hasNext()) {
                 Object o = parentScopeNamespacesIter.next();
                 if (o instanceof OMNamespace) {
-                	OMNamespace ns = (OMNamespace)o;
-                	if(ns.getPrefix() != null) {
-                		returnList.add(ns.getPrefix());
-                	}
+                    OMNamespace ns = (OMNamespace) o;
+                    if (ns.getPrefix() != null) {
+                        returnList.add(ns.getPrefix());
+                    }
                 }
             }
         }
         return returnList.iterator();
-	}
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#removeAttribute(javax.xml.soap.Name)
-	 */
-	public boolean removeAttribute(Name name) {
-        org.apache.axis2.om.OMAttribute attr = this.element.getFirstAttribute(
-                new QName(name.getURI(),
-                        name.getLocalName(),
-                        name.getPrefix()));
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#removeAttribute(javax.xml.soap.Name)
+      */
+    public boolean removeAttribute(Name name) {
+        org.apache.axis2.om.OMAttribute attr = element.getAttribute(new QName(name.getURI(),
+                                                                              name.getLocalName(),
+                                                                              name.getPrefix()));
         if (attr != null) {
             this.element.removeAttribute(attr);
             return true;
         }
         return false;
-	}
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#removeContents()
-	 */
-	public void removeContents() {
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#removeContents()
+      */
+    public void removeContents() {
         //We will get all the children and iteratively call the detach() on all of 'em.
         Iterator childIter = this.element.getChildren();
 
@@ -303,155 +349,233 @@
             if (o instanceof org.apache.axis2.om.OMNode)
                 ((org.apache.axis2.om.OMNode) o).detach();
         }
-	}
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#removeNamespaceDeclaration(java.lang.String)
-	 */
-	public boolean removeNamespaceDeclaration(String prefix) {
-		return this.element.removeNamespace(prefix);
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#removeNamespaceDeclaration(java.lang.String)
+      */
+    public boolean removeNamespaceDeclaration(String prefix) {
+        return this.element.removeNamespace(prefix);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.SOAPElement#setEncodingStyle(java.lang.String)
-	 */
-	public void setEncodingStyle(String encodingStyle) throws SOAPException {
-		((DocumentImpl)this.getOwnerDocument()).setCharsetEncoding(encodingStyle);
-	}
+    /* (non-Javadoc)
+      * @see javax.xml.soap.SOAPElement#setEncodingStyle(java.lang.String)
+      */
+    public void setEncodingStyle(String encodingStyle) throws SOAPException {
+        ((DocumentImpl) this.getOwnerDocument()).setCharsetEncoding(encodingStyle);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.om.impl.OMNodeEx#setParent(org.apache.axis2.om.OMContainer)
-	 */
-	public void setParent(OMContainer parentElement) {
-		this.element.setParent(parentElement);
-	}
+    /* (non-Javadoc)
+      * @see org.apache.axis2.om.impl.OMNodeEx#setParent(org.apache.axis2.om.OMContainer)
+      */
+    public void setParent(OMContainer parentElement) {
+        this.element.setParent(parentElement);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#getAttribute(java.lang.String)
-	 */
-	public String getAttribute(String name) {
-		return this.element.getAttribute(name);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#getAttribute(java.lang.String)
+      */
+    public String getAttribute(String name) {
+        return this.element.getAttribute(name);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#getAttributeNode(java.lang.String)
-	 */
-	public Attr getAttributeNode(String name) {
-		return this.element.getAttributeNode(name);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#getAttributeNode(java.lang.String)
+      */
+    public Attr getAttributeNode(String name) {
+        return this.element.getAttributeNode(name);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#getAttributeNodeNS(java.lang.String, java.lang.String)
-	 */
-	public Attr getAttributeNodeNS(String namespaceURI, String localName) {
-		return this.element.getAttributeNodeNS(namespaceURI, localName);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#getAttributeNodeNS(java.lang.String, java.lang.String)
+      */
+    public Attr getAttributeNodeNS(String namespaceURI, String localName) {
+        return this.element.getAttributeNodeNS(namespaceURI, localName);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#getAttributeNS(java.lang.String, java.lang.String)
-	 */
-	public String getAttributeNS(String namespaceURI, String localName) {
-		return this.element.getAttributeNS(namespaceURI, localName);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#getAttributeNS(java.lang.String, java.lang.String)
+      */
+    public String getAttributeNS(String namespaceURI, String localName) {
+        return this.element.getAttributeNS(namespaceURI, localName);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#getElementsByTagName(java.lang.String)
-	 */
-	public NodeList getElementsByTagName(String name) {
-		return this.element.getElementsByTagName(name);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#getElementsByTagName(java.lang.String)
+      */
+    public NodeList getElementsByTagName(String name) {
+        return this.element.getElementsByTagName(name);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#getElementsByTagNameNS(java.lang.String, java.lang.String)
-	 */
-	public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {
-		return this.element.getElementsByTagNameNS(namespaceURI, localName);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#getElementsByTagNameNS(java.lang.String, java.lang.String)
+      */
+    public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {
+        return this.element.getElementsByTagNameNS(namespaceURI, localName);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#getTagName()
-	 */
-	public String getTagName() {
-		return this.element.getTagName();
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#getTagName()
+      */
+    public String getTagName() {
+        return this.element.getTagName();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#hasAttribute(java.lang.String)
-	 */
-	public boolean hasAttribute(String name) {
-		return this.element.hasAttribute(name);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#hasAttribute(java.lang.String)
+      */
+    public boolean hasAttribute(String name) {
+        return this.element.hasAttribute(name);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#hasAttributeNS(java.lang.String, java.lang.String)
-	 */
-	public boolean hasAttributeNS(String namespaceURI, String localName) {
-		return this.element.hasAttributeNS(namespaceURI, localName);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#hasAttributeNS(java.lang.String, java.lang.String)
+      */
+    public boolean hasAttributeNS(String namespaceURI, String localName) {
+        return this.element.hasAttributeNS(namespaceURI, localName);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#removeAttribute(java.lang.String)
-	 */
-	public void removeAttribute(String name) throws DOMException {
-		this.element.removeAttribute(name);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#removeAttribute(java.lang.String)
+      */
+    public void removeAttribute(String name) throws DOMException {
+        this.element.removeAttribute(name);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#removeAttributeNode(org.w3c.dom.Attr)
-	 */
-	public Attr removeAttributeNode(Attr attr) throws DOMException {
-		return this.element.removeAttributeNode(attr);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#removeAttributeNode(org.w3c.dom.Attr)
+      */
+    public Attr removeAttributeNode(Attr attr) throws DOMException {
+        return this.element.removeAttributeNode(attr);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#removeAttributeNS(java.lang.String, java.lang.String)
-	 */
-	public void removeAttributeNS(String namespaceURI, String localName) throws DOMException {
-		this.element.removeAttributeNS(namespaceURI, localName);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#removeAttributeNS(java.lang.String, java.lang.String)
+      */
+    public void removeAttributeNS(String namespaceURI, String localName) throws DOMException {
+        this.element.removeAttributeNS(namespaceURI, localName);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#setAttribute(java.lang.String, java.lang.String)
-	 */
-	public void setAttribute(String name, String value) throws DOMException {
-		this.element.setAttribute(name, value);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#setAttribute(java.lang.String, java.lang.String)
+      */
+    public void setAttribute(String name, String value) throws DOMException {
+        this.element.setAttribute(name, value);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#setAttributeNode(org.w3c.dom.Attr)
-	 */
-	public Attr setAttributeNode(Attr attr) throws DOMException {
-		return this.element.setAttributeNode(attr);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#setAttributeNode(org.w3c.dom.Attr)
+      */
+    public Attr setAttributeNode(Attr attr) throws DOMException {
+        return this.element.setAttributeNode(attr);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#setAttributeNodeNS(org.w3c.dom.Attr)
-	 */
-	public Attr setAttributeNodeNS(Attr attr) throws DOMException {
-		return this.element.setAttributeNodeNS(attr);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#setAttributeNodeNS(org.w3c.dom.Attr)
+      */
+    public Attr setAttributeNodeNS(Attr attr) throws DOMException {
+        return this.element.setAttributeNodeNS(attr);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Element#setAttributeNS(java.lang.String, java.lang.String, java.lang.String)
-	 */
-	public void setAttributeNS(String namespaceURI, String qualifiedName, String value) throws DOMException {
-		this.element.setAttributeNS(namespaceURI, qualifiedName, value);
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Element#setAttributeNS(java.lang.String, java.lang.String, java.lang.String)
+      */
+    public void setAttributeNS(String namespaceURI, String qualifiedName, String value) throws DOMException {
+        this.element.setAttributeNS(namespaceURI, qualifiedName, value);
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getNodeName()
-	 */
-	public String getNodeName() {
-		return this.element.getNodeName();
-	}
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Node#getNodeName()
+      */
+    public String getNodeName() {
+        return this.element.getNodeName();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.w3c.dom.Node#getNodeType()
-	 */
-	public short getNodeType() {
-		return Node.ELEMENT_NODE;
-	}
-	
-	
-	
+    /* (non-Javadoc)
+      * @see org.w3c.dom.Node#getNodeType()
+      */
+    public short getNodeType() {
+        return Node.ELEMENT_NODE;
+    }
+
+    public ElementImpl getElement() {
+        return element;
+    }
+
+    /**
+     * Returns the parent element of this <code>Node</code> object.
+     * This method can throw an <code>UnsupportedOperationException</code>
+     * if the tree is not kept in memory.
+     *
+     * @return the <code>SOAPElement</code> object that is the parent of
+     *         this <code>Node</code> object or <code>null</code> if this
+     *         <code>Node</code> object is root
+     * @throws UnsupportedOperationException if the whole tree is not kept in memory
+     * @see #setParentElement(javax.xml.soap.SOAPElement) setParentElement(javax.xml.soap.SOAPElement)
+     */
+    public SOAPElement getParentElement() {
+        return (SOAPElement) this.element.getParent();
+    }
+
+
+    /**
+     * Find the Document that this Node belongs to (the document in
+     * whose context the Node was created). The Node may or may not
+     */
+    public Document getOwnerDocument() {
+        return this.element.getOwnerDocument();
+    }
+
+    /**
+     * Returns the the value of the immediate child of this <code>Node</code>
+     * object if a child exists and its value is text.
+     *
+     * @return a <code>String</code> with the text of the immediate child of
+     *         this <code>Node</code> object if (1) there is a child and
+     *         (2) the child is a <code>Text</code> object;
+     *         <code>null</code> otherwise
+     */
+    public String getValue() {
+
+        if (element.getType() == OMNode.TEXT_NODE) {
+            return element.getText();
+        } else if (element.getType() == OMNode.ELEMENT_NODE) {
+            final OMNode firstOMChild = element.getFirstOMChild();
+            if (firstOMChild instanceof TextImpl) {
+                return ((TextImpl) firstOMChild).getData();
+            } else {
+                return ((SOAPElementImpl) firstOMChild).getValue();
+            }
+        }
+        return null;
+    }
+
+
+    public org.w3c.dom.Node getFirstChild() {
+        return this.element.getFirstChild();
+    }
+
+    /**
+     * Method getLastChild
+     *
+     * @see org.w3c.dom.Node#getLastChild()
+     */
+    public org.w3c.dom.Node getLastChild() {
+        return this.element.getLastChild();
+    }
+
+    /**
+     * dom Node method
+     */
+    public org.w3c.dom.Node getNextSibling() {
+        return this.element.getNextSibling();
+    }
+
+    public Node getPreviousSibling() {
+        return this.element.getPreviousSibling();
+    }
+
+    public NodeList getChildNodes() {
+        return this.element.getChildNodes();
+    }
 }
Index: src/org/apache/axis2/saaj2/MessageFactoryImpl.java
===================================================================
--- src/org/apache/axis2/saaj2/MessageFactoryImpl.java	(revision 356731)
+++ src/org/apache/axis2/saaj2/MessageFactoryImpl.java	(working copy)
@@ -15,31 +15,140 @@
  */
 package org.apache.axis2.saaj2;
 
-import java.io.IOException;
-import java.io.InputStream;
+import org.apache.axis2.om.impl.dom.ElementImpl;
+import org.apache.axis2.soap.impl.dom.soap11.SOAP11Factory;
 
 import javax.xml.soap.MessageFactory;
 import javax.xml.soap.MimeHeaders;
 import javax.xml.soap.SOAPException;
 import javax.xml.soap.SOAPMessage;
+import java.io.IOException;
+import java.io.InputStream;
 
+/**
+ * <P>A factory for creating <CODE>SOAPMessage</CODE> objects.</P>
+ * <p/>
+ * <P>A JAXM client performs the following steps to create a
+ * message.</P>
+ * <p/>
+ * <UL>
+ * <LI>
+ * Creates a <CODE>MessageFactory</CODE> object from a <CODE>
+ * ProviderConnection</CODE> object (<CODE>con</CODE> in the
+ * following line of code). The <CODE>String</CODE> passed to
+ * the <CODE>createMessageFactory</CODE> method is the name of
+ * of a messaging profile, which must be the URL for the
+ * schema.
+ * <PRE>
+ * MessageFactory mf = con.createMessageFactory(schemaURL);
+ * </PRE>
+ * </LI>
+ * <p/>
+ * <LI>
+ * Calls the method <CODE>createMessage</CODE> on the <CODE>
+ * MessageFactory</CODE> object. All messages produced by this
+ * <CODE>MessageFactory</CODE> object will have the header
+ * information appropriate for the messaging profile that was
+ * specified when the <CODE>MessageFactory</CODE> object was
+ * created.
+ * <PRE>
+ * SOAPMessage m = mf.createMessage();
+ * </PRE>
+ * </LI>
+ * </UL>
+ * It is also possible to create a <CODE>MessageFactory</CODE>
+ * object using the method <CODE>newInstance</CODE>, as shown in
+ * the following line of code.
+ * <PRE>
+ * MessageFactory mf = MessageFactory.newInstance();
+ * </PRE>
+ * A standalone client (a client that is not running in a
+ * container) can use the <CODE>newInstance</CODE> method to
+ * create a <CODE>MessageFactory</CODE> object.
+ * <p/>
+ * <P>All <CODE>MessageFactory</CODE> objects, regardless of how
+ * they are created, will produce <CODE>SOAPMessage</CODE> objects
+ * that have the following elements by default:</P>
+ * <p/>
+ * <UL>
+ * <LI>A <CODE>SOAPPart</CODE> object</LI>
+ * <p/>
+ * <LI>A <CODE>SOAPEnvelope</CODE> object</LI>
+ * <p/>
+ * <LI>A <CODE>SOAPBody</CODE> object</LI>
+ * <p/>
+ * <LI>A <CODE>SOAPHeader</CODE> object</LI>
+ * </UL>
+ * If a <CODE>MessageFactory</CODE> object was created using a
+ * <CODE>ProviderConnection</CODE> object, which means that it was
+ * initialized with a specified profile, it will produce messages
+ * that also come prepopulated with additional entries in the
+ * <CODE>SOAPHeader</CODE> object and the <CODE>SOAPBody</CODE>
+ * object. The content of a new <CODE>SOAPMessage</CODE> object
+ * depends on which of the two <CODE>MessageFactory</CODE> methods
+ * is used to create it.
+ * <p/>
+ * <UL>
+ * <LI><CODE>createMessage()</CODE> -- message has no
+ * content<BR>
+ * This is the method clients would normally use to create a
+ * request message.</LI>
+ * <p/>
+ * <LI><CODE>createMessage(MimeHeaders,
+ * java.io.InputStream)</CODE> -- message has content from the
+ * <CODE>InputStream</CODE> object and headers from the <CODE>
+ * MimeHeaders</CODE> object<BR>
+ * This method can be used internally by a service
+ * implementation to create a message that is a response to a
+ * request.</LI>
+ * </UL>
+ */
 public class MessageFactoryImpl extends MessageFactory {
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.MessageFactory#createMessage()
-	 */
-	public SOAPMessage createMessage() throws SOAPException {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+    /**
+     * Creates a new <CODE>SOAPMessage</CODE> object with the
+     * default <CODE>SOAPPart</CODE>, <CODE>SOAPEnvelope</CODE>,
+     * <CODE>SOAPBody</CODE>, and <CODE>SOAPHeader</CODE> objects.
+     * Profile-specific message factories can choose to
+     * prepopulate the <CODE>SOAPMessage</CODE> object with
+     * profile-specific headers.
+     * <p/>
+     * <P>Content can be added to this message's <CODE>
+     * SOAPPart</CODE> object, and the message can be sent "as is"
+     * when a message containing only a SOAP part is sufficient.
+     * Otherwise, the <CODE>SOAPMessage</CODE> object needs to
+     * create one or more <CODE>AttachmentPart</CODE> objects and
+     * add them to itself. Any content that is not in XML format
+     * must be in an <CODE>AttachmentPart</CODE> object.</P>
+     *
+     * @return a new <CODE>SOAPMessage</CODE> object
+     * @throws SOAPException if a SOAP error occurs
+     */
+    public SOAPMessage createMessage() throws SOAPException {
+        final SOAPEnvelopeImpl soapEnvelope =
+                new SOAPEnvelopeImpl(new SOAP11Factory().getDefaultEnvelope());
+        return new SOAPMessageImpl(soapEnvelope);
+    }
 
-	/* (non-Javadoc)
-	 * @see javax.xml.soap.MessageFactory#createMessage(javax.xml.soap.MimeHeaders, java.io.InputStream)
-	 */
-	public SOAPMessage createMessage(MimeHeaders mimeheaders,
-			InputStream inputstream) throws IOException, SOAPException {
-		// TODO TODO
-		throw new UnsupportedOperationException("TODO");
-	}
+    /**
+     * Internalizes the contents of the given <CODE>
+     * InputStream</CODE> object into a new <CODE>SOAPMessage</CODE>
+     * object and returns the <CODE>SOAPMessage</CODE> object.
+     *
+     * @param mimeheaders the transport-specific headers
+     *                    passed to the message in a transport-independent fashion
+     *                    for creation of the message
+     * @param inputstream the <CODE>InputStream</CODE> object
+     *                    that contains the data for a message
+     * @return a new <CODE>SOAPMessage</CODE> object containing the
+     *         data from the given <CODE>InputStream</CODE> object
+     * @throws IOException   if there is a
+     *                       problem in reading data from the input stream
+     * @throws SOAPException if the message is invalid
+     */
+    public SOAPMessage createMessage(MimeHeaders mimeheaders,
+                                     InputStream inputstream) throws IOException, SOAPException {
+        return new SOAPMessageImpl(inputstream, mimeheaders);
+    }
 
 }
Index: test-resources/axis.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: test-resources/axis.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

