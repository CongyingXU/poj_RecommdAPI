Index: modules/jaxbri/src/test/java/org/temp/XMLSchemaTest.java
===================================================================
--- modules/jaxbri/src/test/java/org/temp/XMLSchemaTest.java	(revision 1467549)
+++ modules/jaxbri/src/test/java/org/temp/XMLSchemaTest.java	(working copy)
@@ -19,6 +19,13 @@
 
 package org.temp;
 
+import junit.framework.TestCase;
+import org.apache.axis2.util.XMLPrettyPrinter;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.custommonkey.xmlunit.Diff;
+
+import javax.xml.transform.stream.StreamSource;
 import java.io.BufferedReader;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -26,17 +33,9 @@
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 
-import javax.xml.transform.stream.StreamSource;
-
-import junit.framework.TestCase;
-
-import org.apache.axis2.util.XMLPrettyPrinter;
-import org.apache.ws.commons.schema.XmlSchema;
-import org.apache.ws.commons.schema.XmlSchemaCollection;
-import org.custommonkey.xmlunit.Diff;
-
 public abstract class XMLSchemaTest extends TestCase {
 
     public final String XMLSchemaNameSpace = "xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"";
@@ -79,7 +78,7 @@
             while (file.exists()) {
                 InputStream is = new FileInputStream(file);
                 XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-                XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+                XmlSchema schema = schemaCol.read(new StreamSource(is));
                 schemas.add(schema);
                 i++;
                 file = new File(SampleSchemasDirectory + "sampleSchema" + i
@@ -93,7 +92,7 @@
                 + ".xsd");
         InputStream is = new FileInputStream(file);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         return schema;
     }
      
@@ -115,7 +114,7 @@
     public String readXMLfromSchemaFile(String path) throws Exception {
         InputStream is = new FileInputStream(path);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         ByteArrayOutputStream stream = new ByteArrayOutputStream();
         schema.write(stream);
         is.close();
@@ -136,7 +135,7 @@
         fileWriter.close();        
     }
     
-    public String schemaToString(XmlSchema schema){
+    public String schemaToString(XmlSchema schema) throws UnsupportedEncodingException {
         ByteArrayOutputStream stream=new ByteArrayOutputStream();
         schema.write(stream);
         return stream.toString();
@@ -146,7 +145,7 @@
         File file = new File(path);
         InputStream is = new FileInputStream(file);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         return schema;
     }
     
Index: modules/jaxbri/src/main/java/org/apache/axis2/jaxbri/CodeGenerationUtility.java
===================================================================
--- modules/jaxbri/src/main/java/org/apache/axis2/jaxbri/CodeGenerationUtility.java	(revision 1467549)
+++ modules/jaxbri/src/main/java/org/apache/axis2/jaxbri/CodeGenerationUtility.java	(working copy)
@@ -419,7 +419,7 @@
         return pkg;
     }
 
-    private static String getSchemaAsString(XmlSchema schema) {
+    private static String getSchemaAsString(XmlSchema schema) throws UnsupportedEncodingException {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         schema.write(baos);
         return baos.toString();
Index: modules/jaxbri/src/main/java/org/apache/axis2/jaxbri/JaxbSchemaGenerator.java
===================================================================
--- modules/jaxbri/src/main/java/org/apache/axis2/jaxbri/JaxbSchemaGenerator.java	(revision 1467549)
+++ modules/jaxbri/src/main/java/org/apache/axis2/jaxbri/JaxbSchemaGenerator.java	(working copy)
@@ -21,10 +21,16 @@
 
 import com.sun.xml.bind.v2.runtime.JAXBContextImpl;
 import com.sun.xml.bind.v2.runtime.JaxBeanInfo;
+import org.apache.axis2.deployment.util.BeanExcludeInfo;
 import org.apache.axis2.description.java2wsdl.DefaultSchemaGenerator;
 import org.apache.axis2.util.Loader;
-import org.apache.axis2.deployment.util.BeanExcludeInfo;
-import org.apache.ws.commons.schema.*;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaComplexContent;
+import org.apache.ws.commons.schema.XmlSchemaComplexContentExtension;
+import org.apache.ws.commons.schema.XmlSchemaComplexType;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.apache.ws.commons.schema.XmlSchemaImport;
+import org.apache.ws.commons.schema.XmlSchemaSequence;
 import org.apache.ws.commons.schema.utils.NamespaceMap;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
@@ -37,11 +43,11 @@
 import javax.xml.namespace.QName;
 import javax.xml.transform.Result;
 import javax.xml.transform.dom.DOMResult;
+import java.beans.BeanInfo;
+import java.beans.Introspector;
+import java.beans.PropertyDescriptor;
 import java.io.IOException;
 import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-import java.lang.reflect.Field;
-import java.lang.reflect.ParameterizedType;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -50,9 +56,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.beans.BeanInfo;
-import java.beans.Introspector;
-import java.beans.PropertyDescriptor;
 
 public class JaxbSchemaGenerator extends DefaultSchemaGenerator {
     public JaxbSchemaGenerator(ClassLoader loader, String className,
@@ -260,15 +263,15 @@
                 targetNamespacePrefixMap.put(targetNameSpace, targetNamespacePrefix);
             }
 
-            XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema);
+            XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema, false);
             XmlSchemaSequence sequence = new XmlSchemaSequence();
             XmlSchemaComplexContentExtension complexExtension =
                     new XmlSchemaComplexContentExtension();
 
-            XmlSchemaElement eltOuter = new XmlSchemaElement();
+            XmlSchemaElement eltOuter = new XmlSchemaElement(xmlSchema, false);
             schemaTypeName = new QName(targetNameSpace, simpleName, targetNamespacePrefix);
             eltOuter.setName(simpleName);
-            eltOuter.setQName(schemaTypeName);
+            eltOuter.setSchemaTypeName(schemaTypeName);
 
             Class sup = javaType.getSuperclass();
             if ((sup != null) && !("java.lang.Object".compareTo(sup.getName()) == 0) &&
@@ -299,7 +302,7 @@
                 //if the parent class package name is differ from the child
                 if (!((NamespaceMap) xmlSchema.getNamespaceContext()).values().
                         contains(tgtNamespace)) {
-                    XmlSchemaImport importElement = new XmlSchemaImport();
+                    XmlSchemaImport importElement = new XmlSchemaImport(xmlSchema);
                     importElement.setNamespace(tgtNamespace);
                     xmlSchema.getItems().add(importElement);
                     ((NamespaceMap) xmlSchema.getNamespaceContext()).
@@ -320,11 +323,11 @@
             complexType.setName(simpleName);
 
 //            xmlSchema.getItems().add(eltOuter);
-            xmlSchema.getElements().add(schemaTypeName, eltOuter);
+            xmlSchema.getElements().put(schemaTypeName, eltOuter);
             eltOuter.setSchemaTypeName(complexType.getQName());
 
             xmlSchema.getItems().add(complexType);
-            xmlSchema.getSchemaTypes().add(schemaTypeName, complexType);
+            xmlSchema.getSchemaTypes().put(schemaTypeName, complexType);
 
             // adding this type to the table
             typeTable.addComplexSchema(name, eltOuter.getQName());
Index: modules/kernel/test/org/apache/axis2/description/java2wsdl/XMLSchemaTest.java
===================================================================
--- modules/kernel/test/org/apache/axis2/description/java2wsdl/XMLSchemaTest.java	(revision 1467549)
+++ modules/kernel/test/org/apache/axis2/description/java2wsdl/XMLSchemaTest.java	(working copy)
@@ -19,6 +19,13 @@
 
 package org.apache.axis2.description.java2wsdl;
 
+import junit.framework.TestCase;
+import org.apache.axis2.util.XMLPrettyPrinter;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.custommonkey.xmlunit.Diff;
+
+import javax.xml.transform.stream.StreamSource;
 import java.io.BufferedReader;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -28,15 +35,6 @@
 import java.io.InputStream;
 import java.util.ArrayList;
 
-import javax.xml.transform.stream.StreamSource;
-
-import junit.framework.TestCase;
-
-import org.apache.axis2.util.XMLPrettyPrinter;
-import org.apache.ws.commons.schema.XmlSchema;
-import org.apache.ws.commons.schema.XmlSchemaCollection;
-import org.custommonkey.xmlunit.Diff;
-
 public abstract class XMLSchemaTest extends TestCase {
 
     public final String XMLSchemaNameSpace = "xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"";
@@ -79,7 +77,7 @@
             while (file.exists()) {
                 InputStream is = new FileInputStream(file);
                 XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-                XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+                XmlSchema schema = schemaCol.read(new StreamSource(is));
                 schemas.add(schema);
                 i++;
                 file = new File(SampleSchemasDirectory + "sampleSchema" + i
@@ -93,7 +91,7 @@
                 + ".xsd");
         InputStream is = new FileInputStream(file);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         return schema;
     }
     
@@ -114,7 +112,7 @@
     public String readXMLfromSchemaFile(String path) throws Exception {
         InputStream is = new FileInputStream(path);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         ByteArrayOutputStream stream = new ByteArrayOutputStream();
         schema.write(stream);
         return stream.toString();
Index: modules/kernel/test/org/apache/axis2/description/java2wsdl/DefaultSchemaGeneratorTest.java
===================================================================
--- modules/kernel/test/org/apache/axis2/description/java2wsdl/DefaultSchemaGeneratorTest.java	(revision 1467549)
+++ modules/kernel/test/org/apache/axis2/description/java2wsdl/DefaultSchemaGeneratorTest.java	(working copy)
@@ -19,6 +19,12 @@
 
 package org.apache.axis2.description.java2wsdl;
 
+import org.apache.axis2.description.AxisService;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.w3c.dom.Document;
+
+import javax.management.RuntimeErrorException;
+import javax.xml.namespace.QName;
 import java.io.BufferedReader;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -29,13 +35,6 @@
 import java.util.List;
 import java.util.Map;
 
-import javax.management.RuntimeErrorException;
-import javax.xml.namespace.QName;
-
-import org.apache.axis2.description.AxisService;
-import org.apache.ws.commons.schema.XmlSchema;
-import org.w3c.dom.Document;
-
 public class DefaultSchemaGeneratorTest extends XMLSchemaTest {
 
     protected AxisService axisService;
@@ -81,9 +80,7 @@
         XmlSchema schema = schemaColl.iterator().next();
 
         boolean foundExtra = false;
-        Iterator names = schema.getSchemaTypes().getNames();
-        while (names.hasNext()) {
-            QName name = (QName) names.next();
+        for (QName name : schema.getSchemaTypes().keySet()) {
             if (name.getLocalPart().equals("ExtraClass"))
                 foundExtra = true;
         }
Index: modules/kernel/test/org/apache/axis2/description/AxisServiceTest.java
===================================================================
--- modules/kernel/test/org/apache/axis2/description/AxisServiceTest.java	(revision 1467549)
+++ modules/kernel/test/org/apache/axis2/description/AxisServiceTest.java	(working copy)
@@ -19,17 +19,6 @@
 
 package org.apache.axis2.description;
 
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.InputStream;
-import java.io.ObjectOutputStream;
-import java.util.ArrayList;
-
-import javax.xml.namespace.QName;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.transform.stream.StreamSource;
-
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.context.ServiceContext;
@@ -44,6 +33,16 @@
 import org.w3c.dom.ls.DOMImplementationLS;
 import org.w3c.dom.ls.LSSerializer;
 
+import javax.xml.namespace.QName;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.transform.stream.StreamSource;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.io.ObjectOutputStream;
+import java.util.ArrayList;
+
 public class AxisServiceTest extends XMLSchemaTest {
     public static final String PARAM_NAME = "CustomParameter";
     public static final Object PARAM_VALUE = new Object();
@@ -256,7 +255,7 @@
     public void testPrintXSD() throws Exception {
         InputStream is = new FileInputStream(SampleSchemasDirectory + "sampleSchema1.xsd");
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         ByteArrayOutputStream stream = new ByteArrayOutputStream();
         ArrayList<XmlSchema> xmlSchemas = new ArrayList<XmlSchema>();
         xmlSchemas.add(schema);
Index: modules/kernel/src/org/apache/axis2/description/AxisService2WSDL20.java
===================================================================
--- modules/kernel/src/org/apache/axis2/description/AxisService2WSDL20.java	(revision 1467549)
+++ modules/kernel/src/org/apache/axis2/description/AxisService2WSDL20.java	(working copy)
@@ -25,8 +25,8 @@
 import org.apache.axiom.om.OMFactory;
 import org.apache.axiom.om.OMNamespace;
 import org.apache.axiom.om.OMNode;
-import org.apache.axiom.soap.SOAP12Constants;
 import org.apache.axiom.soap.SOAP11Constants;
+import org.apache.axiom.soap.SOAP12Constants;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.addressing.AddressingConstants;
@@ -46,9 +46,9 @@
 import org.apache.ws.commons.schema.XmlSchema;
 import org.apache.ws.commons.schema.XmlSchemaComplexType;
 import org.apache.ws.commons.schema.XmlSchemaElement;
-import org.apache.ws.commons.schema.XmlSchemaObjectCollection;
 import org.apache.ws.commons.schema.XmlSchemaParticle;
 import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaSequenceMember;
 import org.apache.ws.commons.schema.XmlSchemaSimpleType;
 import org.apache.ws.commons.schema.XmlSchemaType;
 
@@ -398,41 +398,38 @@
                 }
                 inMessageElementQname = schemaElement.getQName();
                 XmlSchemaType type = schemaElement.getSchemaType();
-                if (type != null && type instanceof XmlSchemaComplexType){
+                if (type != null && type instanceof XmlSchemaComplexType) {
                     XmlSchemaComplexType complexType = (XmlSchemaComplexType) type;
                     XmlSchemaParticle particle = complexType.getParticle();
-                    if (particle != null && particle instanceof XmlSchemaSequence){
+                    if (particle != null && particle instanceof XmlSchemaSequence) {
                         XmlSchemaSequence xmlSchemaSequence = (XmlSchemaSequence) particle;
-                        XmlSchemaObjectCollection schemaObjectCollection =
-                                xmlSchemaSequence.getItems();
-                        if (schemaObjectCollection != null) {
-                            Iterator iterator = schemaObjectCollection.getIterator();
-                            while (iterator.hasNext()) {
-                                Object next = iterator.next();
-                                if (!(next instanceof XmlSchemaElement)) {
-                                    return new URI [0];
+                        if (!xmlSchemaSequence.getItems().isEmpty()) {
+                            for (XmlSchemaSequenceMember member : xmlSchemaSequence.getItems()) {
+
+                                if (!(member instanceof XmlSchemaElement)) {
+                                    return new URI[0];
                                 }
-                                XmlSchemaElement innerElement = (XmlSchemaElement) next;
-                                if (innerElement.getRefName() != null) {
-                                    return new URI [0];
+                                XmlSchemaElement innerElement = (XmlSchemaElement) member;
+                                if (innerElement.getRef().getTargetQName() != null) {
+                                    return new URI[0];
                                 }
                                 if (innerElement.getMinOccurs() != 1 ||
-                                        innerElement.getMaxOccurs() != 1) {
+                                    innerElement.getMaxOccurs() != 1) {
                                     isMultipart = false;
                                 }
                                 XmlSchemaType schemaType = innerElement.getSchemaType();
                                 QName innerElementQName = innerElement.getSchemaTypeName();
                                 if (schemaType instanceof XmlSchemaSimpleType) {
                                     if (Constants.XSD_QNAME.equals(innerElementQName) ||
-                                            Constants.XSD_NOTATION.equals(innerElementQName) ||
-                                            Constants.XSD_HEXBIN.equals(innerElementQName) ||
-                                            Constants.XSD_BASE64.equals(innerElementQName)) {
-                                            isIRI = false;
+                                        Constants.XSD_NOTATION.equals(innerElementQName) ||
+                                        Constants.XSD_HEXBIN.equals(innerElementQName) ||
+                                        Constants.XSD_BASE64.equals(innerElementQName)) {
+                                        isIRI = false;
                                     }
                                 } else {
                                     isIRI = false;
                                 }
-                                if (Constants.XSD_ANY.equals(innerElementQName) && iterator.hasNext()) {
+                                if (Constants.XSD_ANY.equals(innerElementQName)) {
                                     isRPC = false;
                                 }
                                 String name = innerElement.getName();
@@ -444,11 +441,11 @@
                             }
                         }
                     } else {
-                        return new URI [0];
+                        return new URI[0];
                     }
                 } else {
-                        return new URI [0];
-                    }
+                    return new URI[0];
+                }
             } else {
                 return new URI [0];
             }
@@ -479,19 +476,15 @@
                     XmlSchemaParticle particle = complexType.getParticle();
                     if (particle != null && particle instanceof XmlSchemaSequence) {
                         XmlSchemaSequence xmlSchemaSequence = (XmlSchemaSequence) particle;
-                        XmlSchemaObjectCollection schemaObjectCollection =
-                                xmlSchemaSequence.getItems();
-                        if (schemaObjectCollection != null) {
-                            Iterator iterator = schemaObjectCollection.getIterator();
-                            while (iterator.hasNext()) {
-                                Object next = iterator.next();
-                                if (!(next instanceof XmlSchemaElement)) {
+                        if (!xmlSchemaSequence.getItems().isEmpty()) {
+                            for (XmlSchemaSequenceMember member : xmlSchemaSequence.getItems()) {
+                                if (!(member instanceof XmlSchemaElement)) {
                                     isRPC = false;
                                 }
-                                XmlSchemaElement innerElement = (XmlSchemaElement) next;
+                                XmlSchemaElement innerElement = (XmlSchemaElement) member;
                                 QName schemaTypeName = innerElement.getSchemaTypeName();
                                 String name = innerElement.getName();
-                                if (innerElement.getRefName() != null) {
+                                if (innerElement.getRef().getTargetQName() != null) {
                                     isRPC = false;
                                 }
                                 if (outMessageElementDetails.get(name) != null) {
@@ -500,7 +493,7 @@
                                 QName inMessageElementType =
                                         (QName) inMessageElementDetails.get(name);
                                 if (inMessageElementType != null &&
-                                        inMessageElementType != schemaTypeName) {
+                                    inMessageElementType != schemaTypeName) {
                                     isRPC = false;
                                 }
                                 outMessageElementDetails.put(name, schemaTypeName);
Index: modules/kernel/src/org/apache/axis2/description/AxisService.java
===================================================================
--- modules/kernel/src/org/apache/axis2/description/AxisService.java	(revision 1467549)
+++ modules/kernel/src/org/apache/axis2/description/AxisService.java	(working copy)
@@ -72,7 +72,6 @@
 import org.apache.ws.commons.schema.XmlSchema;
 import org.apache.ws.commons.schema.XmlSchemaElement;
 import org.apache.ws.commons.schema.XmlSchemaExternal;
-import org.apache.ws.commons.schema.XmlSchemaObjectCollection;
 import org.apache.ws.commons.schema.utils.NamespaceMap;
 import org.apache.ws.commons.schema.utils.NamespacePrefixList;
 
@@ -107,6 +106,7 @@
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
+import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Method;
 import java.net.SocketException;
 import java.net.URISyntaxException;
@@ -988,8 +988,13 @@
 	public void printSchema(OutputStream out) throws AxisFault {
 		for (int i = 0; i < schemaList.size(); i++) {
 			XmlSchema schema = addNameSpaces(i);
-			schema.write(out);
-		}
+            try {
+                schema.write(out);
+            } catch (UnsupportedEncodingException e) {
+                log.error("Error while printing schema ", e);
+                throw new AxisFault(e.getMessage(), e);
+            }
+        }
 	}
 
 	public XmlSchema getSchema(int index) {
@@ -1291,17 +1296,12 @@
     }
 
 	private void updateSchemaLocation(XmlSchema schema) throws AxisFault {
-        XmlSchemaObjectCollection includes = schema.getIncludes();
-        for (int j = 0; j < includes.getCount(); j++) {
-            Object item = includes.getItem(j);
-            if (item instanceof XmlSchemaExternal) {
-                XmlSchemaExternal xmlSchemaExternal = (XmlSchemaExternal) item;
-                XmlSchema s = xmlSchemaExternal.getSchema();
-                updateSchemaLocation(s, xmlSchemaExternal);
-            }
+        for (XmlSchemaExternal xmlSchemaExternal : schema.getExternals()) {
+            XmlSchema s = xmlSchemaExternal.getSchema();
+            updateSchemaLocation(s, xmlSchemaExternal);
         }
     }
-	   
+
 	private void updateSchemaLocation(XmlSchema s, XmlSchemaExternal xmlSchemaExternal) throws AxisFault {
         if (s != null) {
             String schemaLocation = xmlSchemaExternal.getSchemaLocation();
@@ -2786,15 +2786,9 @@
 		// first traversal - fill the hashtable
 		for (int i = 0; i < schemas.size(); i++) {
 			XmlSchema schema = (XmlSchema) schemas.get(i);
-			XmlSchemaObjectCollection includes = schema.getIncludes();
-
-			for (int j = 0; j < includes.getCount(); j++) {
-				Object item = includes.getItem(j);
-				XmlSchema s;
-				if (item instanceof XmlSchemaExternal) {
-					XmlSchemaExternal externalSchema = (XmlSchemaExternal) item;
-					s = externalSchema.getSchema();
-
+			for (XmlSchemaExternal externalSchema : schema.getExternals()) {
+				if (externalSchema != null) {
+                    XmlSchema s = externalSchema.getSchema();
 					if (s != null
 							&& getScheamLocationWithDot(
 									sourceURIToNewLocationMap, s) == null) {
@@ -2878,22 +2872,16 @@
 	 * @param parentSchema
 	 * @param nameTable
 	 */
-	private void adjustSchemaName(XmlSchema parentSchema, Hashtable nameTable,
-			Hashtable importedScheams, Hashtable sourceURIToNewLocationMap) {
-		XmlSchemaObjectCollection includes = parentSchema.getIncludes();
-		for (int j = 0; j < includes.getCount(); j++) {
-			Object item = includes.getItem(j);
-			if (item instanceof XmlSchemaExternal) {
-				XmlSchemaExternal xmlSchemaExternal = (XmlSchemaExternal) item;
-				XmlSchema s = xmlSchemaExternal.getSchema();
-				adjustSchemaLocation(s, xmlSchemaExternal, nameTable,
-						importedScheams, sourceURIToNewLocationMap);
-			}
-		}
+    private void adjustSchemaName(XmlSchema parentSchema, Hashtable nameTable,
+                                  Hashtable importedScheams, Hashtable sourceURIToNewLocationMap) {
+        for (XmlSchemaExternal xmlSchemaExternal : parentSchema.getExternals()) {
+            XmlSchema s = xmlSchemaExternal.getSchema();
+            adjustSchemaLocation(s, xmlSchemaExternal, nameTable,
+                                 importedScheams, sourceURIToNewLocationMap);
+        }
+    }
 
-	}
-		
-	/**
+    /**
 	 * Adjusts a given schema location
 	 * 
 	 * @param s
@@ -3401,7 +3389,7 @@
     /**
      * returns a axisService given a input Stream of WSDL2.0 document.
      * 
-     * @param Description
+     * @param description
      *            WSDL description
      * @param wsdlServiceName
      * @param endPoint
Index: modules/kernel/src/org/apache/axis2/description/AxisMessage.java
===================================================================
--- modules/kernel/src/org/apache/axis2/description/AxisMessage.java	(revision 1467549)
+++ modules/kernel/src/org/apache/axis2/description/AxisMessage.java	(working copy)
@@ -28,13 +28,16 @@
 import org.apache.axis2.wsdl.SOAPHeaderMessage;
 import org.apache.neethi.Policy;
 import org.apache.neethi.PolicyComponent;
-import org.apache.ws.commons.schema.*;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.apache.ws.commons.schema.XmlSchemaImport;
+import org.apache.ws.commons.schema.XmlSchemaInclude;
+import org.apache.ws.commons.schema.XmlSchemaObject;
 
 import javax.xml.namespace.QName;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Date;
-import java.util.Iterator;
 import java.util.List;
 
 
@@ -145,24 +148,18 @@
             xmlSchemaElement = schema.getElementByName(this.elementQname);
             if (xmlSchemaElement == null) {
                 // try to find in an import or an include
-                XmlSchemaObjectCollection includes = schema.getIncludes();
-                if (includes != null) {
-                    Iterator includesIter = includes.getIterator();
-                    Object object;
-                    while (includesIter.hasNext()) {
-                        object = includesIter.next();
-                        if (object instanceof XmlSchemaImport) {
-                            XmlSchema schema1 = ((XmlSchemaImport) object).getSchema();
-                            xmlSchemaElement = getSchemaElement(schema1);
-                        }
-                        if (object instanceof XmlSchemaInclude) {
-                            XmlSchema schema1 = ((XmlSchemaInclude) object).getSchema();
-                            xmlSchemaElement = getSchemaElement(schema1);
-                        }
-                        if (xmlSchemaElement != null){
-                            break;
-                        }
+                for (XmlSchemaObject external : schema.getExternals()) {
+                    if (external instanceof XmlSchemaImport) {
+                        XmlSchema schema1 = ((XmlSchemaImport) external).getSchema();
+                        xmlSchemaElement = getSchemaElement(schema1);
                     }
+                    if (external instanceof XmlSchemaInclude) {
+                        XmlSchema schema1 = ((XmlSchemaInclude) external).getSchema();
+                        xmlSchemaElement = getSchemaElement(schema1);
+                    }
+                    if (xmlSchemaElement != null) {
+                        break;
+                    }
                 }
             }
         }
Index: modules/kernel/src/org/apache/axis2/description/java2wsdl/DocLitBareSchemaGenerator.java
===================================================================
--- modules/kernel/src/org/apache/axis2/description/java2wsdl/DocLitBareSchemaGenerator.java	(revision 1467549)
+++ modules/kernel/src/org/apache/axis2/description/java2wsdl/DocLitBareSchemaGenerator.java	(working copy)
@@ -65,10 +65,10 @@
     protected Method[] processMethods(Method[] declaredMethods) throws Exception {
         ArrayList<Method> list = new ArrayList<Method>();
         //short the elements in the array
-        Arrays.sort(declaredMethods , new MathodComparator());
+        Arrays.sort(declaredMethods, new MathodComparator());
 
         // since we do not support overload
-        HashMap<String,Method> uniqueMethods = new LinkedHashMap<String,Method>();
+        HashMap<String, Method> uniqueMethods = new LinkedHashMap<String, Method>();
         XmlSchemaComplexType methodSchemaType;
         XmlSchemaSequence sequence;
 
@@ -85,11 +85,11 @@
 
             if (uniqueMethods.get(methodName) != null) {
                 log.warn("We don't support method overloading. Ignoring [" +
-                        methodName + "]");
+                         methodName + "]");
                 continue;
             }
 
-           if (!Modifier.isPublic(jMethod.getModifiers())) {
+            if (!Modifier.isPublic(jMethod.getModifiers())) {
                 // no need to generate Schema for non public methods
                 continue;
             }
@@ -99,10 +99,10 @@
             if (axisOperation == null) {
                 axisOperation = Utils.getAxisOperationForJmethod(jMethod);
                 if (WSDL2Constants.MEP_URI_ROBUST_IN_ONLY.equals(
-                        axisOperation.getMessageExchangePattern())){
+                        axisOperation.getMessageExchangePattern())) {
                     AxisMessage outMessage = axisOperation.getMessage(
                             WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
-                    if (outMessage !=null ){
+                    if (outMessage != null) {
                         outMessage.setName(methodName + RESULT);
                     }
                 }
@@ -111,7 +111,7 @@
 
             // Maintain a list of methods we actually work with
             list.add(jMethod);
-            processException(jMethod,axisOperation);
+            processException(jMethod, axisOperation);
             uniqueMethods.put(methodName, jMethod);
             //create the schema type for the method wrapper
 
@@ -130,12 +130,12 @@
                 methodSchemaType.setParticle(sequence);
                 inMessage.setElementQName(typeTable.getQNamefortheType(methodName));
                 service.addMessageElementQNameToOperationMapping(methodSchemaType.getQName(),
-                        axisOperation);
+                                                                 axisOperation);
                 inMessage.setPartName(methodName);
                 for (int j = 0; j < paras.length; j++) {
                     Class<?> methodParameter = paras[j];
                     String parameterName = getParameterName(parameterAnnotation, j, parameterNames);
-                    if (generateRequestSchema(methodParameter , parameterName,jMethod, sequence, genericParameterTypes[j])) {
+                    if (generateRequestSchema(methodParameter, parameterName, jMethod, sequence, genericParameterTypes[j])) {
                         break;
                     }
                 }
@@ -148,10 +148,10 @@
                     Class<?> methodParameter = paras[0];
                     inMessage.setElementQName(typeTable.getQNamefortheType(methodName));
                     service.addMessageElementQNameToOperationMapping(methodSchemaType.getQName(),
-                            axisOperation);
+                                                                     axisOperation);
                     inMessage.setPartName(methodName);
                     String parameterName = getParameterName(parameterAnnotation, 0, parameterNames);
-                    if (generateRequestSchema(methodParameter , parameterName,jMethod, sequence, genericParameterTypes[0])) {
+                    if (generateRequestSchema(methodParameter, parameterName, jMethod, sequence, genericParameterTypes[0])) {
                         break;
                     }
                 } else {
@@ -160,35 +160,35 @@
                     Method processMethod = processedParameters.get(parameterName);
                     if (processMethod != null) {
                         throw new AxisFault("Inavalid Java class," +
-                                " there are two methods [" + processMethod.getName() + " and " +
-                                jMethod.getName() + " ]which have the same parameter names");
+                                            " there are two methods [" + processMethod.getName() + " and " +
+                                            jMethod.getName() + " ]which have the same parameter names");
                     } else {
                         processedParameters.put(parameterName, jMethod);
-                        if (methodParameter != null && Map.class.isAssignableFrom(methodParameter)){                        	
-							generateBareSchemaTypeForMap(parameterName, genericParameterTypes[0], null);
-							
+                        if (methodParameter != null && Map.class.isAssignableFrom(methodParameter)) {
+                            generateBareSchemaTypeForMap(parameterName, genericParameterTypes[0], null);
+
                         } else if (methodParameter != null
-                        	&& Collection.class
-                        	.isAssignableFrom(methodParameter)) {
-                            
+                                   && Collection.class
+                                .isAssignableFrom(methodParameter)) {
+
                             sequence = new XmlSchemaSequence();
                             methodSchemaType = createSchemaTypeForMethodPart(methodName);
                             methodSchemaType.setParticle(sequence);
                             generateBareSchemaTypeForCollection(sequence,
-                        	    genericParameterTypes[0], parameterName,
-                        	    methodName);
+                                                                genericParameterTypes[0], parameterName,
+                                                                methodName);
                             parameterName = methodName;
 
-                        } else if (methodParameter != null && Document.class.isAssignableFrom(methodParameter)){                         
-                            generateBareSchemaTypeForDocument(null, parameterName);                            
+                        } else if (methodParameter != null && Document.class.isAssignableFrom(methodParameter)) {
+                            generateBareSchemaTypeForDocument(null, parameterName);
                         } else {
-                        	generateSchemaForType(null, methodParameter, parameterName);                        	
-                        }                        
+                            generateSchemaForType(null, methodParameter, parameterName);
+                        }
                         inMessage.setElementQName(typeTable.getQNamefortheType(parameterName));
                         inMessage.setPartName(parameterName);
                         inMessage.setWrapped(false);
                         service.addMessageElementQNameToOperationMapping(typeTable.getQNamefortheType(parameterName),
-                                axisOperation);
+                                                                         axisOperation);
                     }
                 }
             }
@@ -213,23 +213,23 @@
                         generateSchemaForType(sequence, returnType, returnName);
                     }
                 } else {
-                    if(returnType != null && Document.class.isAssignableFrom(returnType)) {
-                        generateBareSchemaTypeForDocument(null, methodTypeName);  
-                        
-                    } else if (returnType != null && Map.class.isAssignableFrom(returnType)){                        	
-						generateBareSchemaTypeForMap(methodTypeName, genericReturnType, null);
-						
-                	} else if (returnType != null
-                		&& Collection.class.isAssignableFrom(returnType)) {
-                	    sequence = new XmlSchemaSequence();
-                	    methodSchemaType = createSchemaTypeForMethodPart(methodTypeName);
-                	    methodSchemaType.setParticle(sequence);
-                	    generateBareSchemaTypeForCollection(sequence,
-                		    genericReturnType, returnName, methodName);
+                    if (returnType != null && Document.class.isAssignableFrom(returnType)) {
+                        generateBareSchemaTypeForDocument(null, methodTypeName);
 
-                	} else {
-                    	generateSchemaForType(null, returnType, methodTypeName);                    	
-                    }                    
+                    } else if (returnType != null && Map.class.isAssignableFrom(returnType)) {
+                        generateBareSchemaTypeForMap(methodTypeName, genericReturnType, null);
+
+                    } else if (returnType != null
+                               && Collection.class.isAssignableFrom(returnType)) {
+                        sequence = new XmlSchemaSequence();
+                        methodSchemaType = createSchemaTypeForMethodPart(methodTypeName);
+                        methodSchemaType.setParticle(sequence);
+                        generateBareSchemaTypeForCollection(sequence,
+                                                            genericReturnType, returnName, methodName);
+
+                    } else {
+                        generateSchemaForType(null, returnType, methodTypeName);
+                    }
                     outMessage.setWrapped(false);
                 }
                 outMessage.setElementQName(typeTable.getQNamefortheType(methodTypeName));
@@ -325,15 +325,14 @@
     protected void generateSchemaForSingleElement(QName schemaTypeName,
                                                   String paraName,
                                                   boolean isArray) throws Exception {
-        XmlSchemaElement elt1 = new XmlSchemaElement();
+        XmlSchemaElement elt1 = new XmlSchemaElement(getXmlSchema(schemaTargetNameSpace), false);
         elt1.setName(paraName);
         elt1.setSchemaTypeName(schemaTypeName);
         elt1.setNillable(true);
         QName elementName =
                 new QName(schemaTargetNameSpace, paraName, schema_namespace_prefix);
-        elt1.setQName(elementName);
         XmlSchema xmlSchema = getXmlSchema(schemaTargetNameSpace);
-        xmlSchema.getElements().add(elementName, elt1);
+        xmlSchema.getElements().put(elementName, elt1);
         xmlSchema.getItems().add(elt1);
         typeTable.addComplexSchema(paraName, elementName);
     }
@@ -341,7 +340,7 @@
     /**
      * Generate schema construct for given type
      *
-     * @param javaType
+     * @param localPartName
      */
     private XmlSchemaComplexType createSchemaTypeForMethodPart(String localPartName) {
         XmlSchema xmlSchema = getXmlSchema(schemaTargetNameSpace);
@@ -350,14 +349,13 @@
 
         XmlSchemaComplexType complexType = getComplexTypeForElement(xmlSchema, elementName);
         if (complexType == null) {
-            complexType = new XmlSchemaComplexType(xmlSchema);
+            complexType = new XmlSchemaComplexType(xmlSchema, false);
 
-            XmlSchemaElement globalElement = new XmlSchemaElement();
+            XmlSchemaElement globalElement = new XmlSchemaElement(xmlSchema, false);
             globalElement.setSchemaType(complexType);
             globalElement.setName(localPartName);
-            globalElement.setQName(elementName);
             xmlSchema.getItems().add(globalElement);
-            xmlSchema.getElements().add(elementName, globalElement);
+            xmlSchema.getElements().put(elementName, globalElement);
         }
         typeTable.addComplexSchema(localPartName, elementName);
 
@@ -412,15 +410,14 @@
 		if (sequence != null) {
 			return;
 		}
-		XmlSchemaElement elt1 = new XmlSchemaElement();
+        XmlSchema xmlSchema = getXmlSchema(schemaTargetNameSpace);
+		XmlSchemaElement elt1 = new XmlSchemaElement(xmlSchema, false);
 		elt1.setSchemaTypeName(schemaTypeName);
 		elt1.setName(paraName);
 		elt1.setNillable(true);
 		QName elementName = new QName(schemaTargetNameSpace, paraName,
 				schema_namespace_prefix);
-		elt1.setQName(elementName);
-		XmlSchema xmlSchema = getXmlSchema(schemaTargetNameSpace);
-		xmlSchema.getElements().add(elementName, elt1);
+		xmlSchema.getElements().put(elementName, elt1);
 		xmlSchema.getItems().add(elt1);
 		typeTable.addComplexSchema(paraName, elementName);
 
@@ -457,15 +454,14 @@
         if (sequence != null) {
             return;
         }
-        XmlSchemaElement elt1 = new XmlSchemaElement();
+        XmlSchema xmlSchema = getXmlSchema(schemaTargetNameSpace);
+        XmlSchemaElement elt1 = new XmlSchemaElement(xmlSchema, false);
         elt1.setSchemaTypeName(schemaTypeName);
         elt1.setName(parameterName);
         elt1.setNillable(true);
         QName elementName = new QName(schemaTargetNameSpace, parameterName,
                 schema_namespace_prefix);
-        elt1.setQName(elementName);
-        XmlSchema xmlSchema = getXmlSchema(schemaTargetNameSpace);
-        xmlSchema.getElements().add(elementName, elt1);
+        xmlSchema.getElements().put(elementName, elt1);
         xmlSchema.getItems().add(elt1);
         typeTable.addComplexSchema(parameterName, elementName);
 
Index: modules/kernel/src/org/apache/axis2/description/java2wsdl/DefaultSchemaGenerator.java
===================================================================
--- modules/kernel/src/org/apache/axis2/description/java2wsdl/DefaultSchemaGenerator.java	(revision 1467549)
+++ modules/kernel/src/org/apache/axis2/description/java2wsdl/DefaultSchemaGenerator.java	(working copy)
@@ -75,7 +75,6 @@
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Hashtable;
-import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -321,7 +320,7 @@
 
 
         // since we do not support overload
-        Map<String,Method> uniqueMethods = new LinkedHashMap<String,Method>();
+        Map<String, Method> uniqueMethods = new LinkedHashMap<String, Method>();
         XmlSchemaComplexType methodSchemaType;
         XmlSchemaSequence sequence = null;
 
@@ -339,7 +338,7 @@
 
             if (uniqueMethods.get(methodName) != null) {
                 log.warn("We don't support method overloading. Ignoring [" +
-                        methodName + "]");
+                         methodName + "]");
                 continue;
             }
             if (!Modifier.isPublic(jMethod.getModifiers())) {
@@ -361,8 +360,8 @@
                 addToService = true;
             }
 // by now axis operation should be assigned but we better recheck & add the paramether
-            if(axisOperation != null){
-             axisOperation.addParameter("JAXRSAnnotaion", JAXRSUtils.getMethodModel(this.classModel,jMethod));
+            if (axisOperation != null) {
+                axisOperation.addParameter("JAXRSAnnotaion", JAXRSUtils.getMethodModel(this.classModel, jMethod));
             }
             // Maintain a list of methods we actually work with
             list.add(jMethod);
@@ -401,7 +400,7 @@
             }
 
             service.addMessageElementQNameToOperationMapping(methodSchemaType.getQName(),
-                    axisOperation);
+                                                             axisOperation);
 
 
             Annotation[][] parameterAnnotation = jMethod.getParameterAnnotations();
@@ -413,36 +412,36 @@
                 if (nonRpcMethods.contains(jMethod.getName())) {
                     generateSchemaForType(sequence, null, jMethod.getName());
                     break;
-                    
-                } else if(methodParameter != null && Document.class.isAssignableFrom(methodParameter)) {
-                    generateSchemaTypeForDocument(sequence, parameterName);  
-                    
-                } else if(methodParameter != null && Map.class.isAssignableFrom(methodParameter)) {
-                	generateWrappedSchemaTypeForMap(sequence, genericParameterTypes[j], parameterName);   
-                	
-                } else if(methodParameter != null && Collection.class.isAssignableFrom(methodParameter)){
-                	generateWrappedSchemaTypeForCollection(sequence, genericParameterTypes[j], parameterName); 
-                	
-                }else if(methodParameter != null && Enum.class.isAssignableFrom(methodParameter)){
-                    generateWrappedSchemaTypeForEnum(sequence , parameterName , methodParameter , false);
-                }else {
+
+                } else if (methodParameter != null && Document.class.isAssignableFrom(methodParameter)) {
+                    generateSchemaTypeForDocument(sequence, parameterName);
+
+                } else if (methodParameter != null && Map.class.isAssignableFrom(methodParameter)) {
+                    generateWrappedSchemaTypeForMap(sequence, genericParameterTypes[j], parameterName);
+
+                } else if (methodParameter != null && Collection.class.isAssignableFrom(methodParameter)) {
+                    generateWrappedSchemaTypeForCollection(sequence, genericParameterTypes[j], parameterName);
+
+                } else if (methodParameter != null && Enum.class.isAssignableFrom(methodParameter)) {
+                    generateWrappedSchemaTypeForEnum(sequence, parameterName, methodParameter, false);
+                } else {
                     Type genericParameterType = genericParameterTypes[j];
                     Type genericType = null;
-                    if(genericParameterType instanceof ParameterizedType){
+                    if (genericParameterType instanceof ParameterizedType) {
                         ParameterizedType aType = (ParameterizedType) genericParameterType;
                         Type[] parameterArgTypes = aType.getActualTypeArguments();
                         genericType = parameterArgTypes[0];
                         generateSchemaForType(sequence, genericType, parameterName, true);
-                    }else{
-                        if(methodParameter.isArray()){
+                    } else {
+                        if (methodParameter.isArray()) {
                             Class<?> componentType = methodParameter.getComponentType();
                             if (Enum.class.isAssignableFrom(componentType)) {
-                                generateWrappedSchemaTypeForEnum(sequence,  parameterName, componentType, true);
+                                generateWrappedSchemaTypeForEnum(sequence, parameterName, componentType, true);
                             } else {
-                                 generateSchemaForType(sequence, methodParameter, parameterName);
+                                generateSchemaForType(sequence, methodParameter, parameterName);
                             }
 
-                        }else{
+                        } else {
                             generateSchemaForType(sequence, methodParameter, parameterName);
                         }
                     }
@@ -455,30 +454,30 @@
                 methodSchemaType =
                         createSchemaTypeForMethodPart(partQname);
                 sequence = new XmlSchemaSequence();
-                methodSchemaType.setParticle(sequence);               
-                String returnName = "return";                
+                methodSchemaType.setParticle(sequence);
+                String returnName = "return";
                 Type genericParameterType = jMethod.getGenericReturnType();
                 if (nonRpcMethods.contains(jMethod.getName())) {
                     generateSchemaForType(sequence, null, returnName);
-                    
-                } else if(returnType != null && Document.class.isAssignableFrom(returnType)) {
-                    generateSchemaTypeForDocument(sequence, returnName);   
-                    
-                } else if (Map.class.isAssignableFrom(returnType)){
-					if (genericParameterType instanceof ParameterizedType) {
-						generateWrappedSchemaTypeForMap(sequence, genericParameterType, returnName);
-					} else {
-						generateWrappedSchemaTypeForMap(sequence, returnType, returnName);
-					}                  	
-                } else if (Collection.class.isAssignableFrom(returnType)){
-					if (genericParameterType instanceof ParameterizedType) {						
-						generateWrappedSchemaTypeForCollection(sequence, genericParameterType, returnName);
-					} else {						
-						generateWrappedSchemaTypeForCollection(sequence, genericParameterType, returnName);
-					}
-                }else if(Enum.class .isAssignableFrom(returnType)){
-                      generateWrappedSchemaTypeForEnum(sequence ,  returnName , returnType , false);
-                } else if(genericParameterType instanceof ParameterizedType){
+
+                } else if (returnType != null && Document.class.isAssignableFrom(returnType)) {
+                    generateSchemaTypeForDocument(sequence, returnName);
+
+                } else if (Map.class.isAssignableFrom(returnType)) {
+                    if (genericParameterType instanceof ParameterizedType) {
+                        generateWrappedSchemaTypeForMap(sequence, genericParameterType, returnName);
+                    } else {
+                        generateWrappedSchemaTypeForMap(sequence, returnType, returnName);
+                    }
+                } else if (Collection.class.isAssignableFrom(returnType)) {
+                    if (genericParameterType instanceof ParameterizedType) {
+                        generateWrappedSchemaTypeForCollection(sequence, genericParameterType, returnName);
+                    } else {
+                        generateWrappedSchemaTypeForCollection(sequence, genericParameterType, returnName);
+                    }
+                } else if (Enum.class.isAssignableFrom(returnType)) {
+                    generateWrappedSchemaTypeForEnum(sequence, returnName, returnType, false);
+                } else if (genericParameterType instanceof ParameterizedType) {
                     ParameterizedType aType = (ParameterizedType) genericParameterType;
                     Type[] parameterArgTypes = aType.getActualTypeArguments();
                     generateSchemaForType(sequence, parameterArgTypes[0], returnName, true);
@@ -486,7 +485,7 @@
                     if (returnType.isArray()) {
                         Class<?> returnComponentType = returnType.getComponentType();
                         if (Enum.class.isAssignableFrom(returnComponentType)) {
-                            generateWrappedSchemaTypeForEnum(sequence,  returnName, returnComponentType, true);
+                            generateWrappedSchemaTypeForEnum(sequence, returnName, returnComponentType, true);
                         } else {
                             generateSchemaForType(sequence, returnType, returnName);
                         }
@@ -506,7 +505,7 @@
                 }
 
                 service.addMessageElementQNameToOperationMapping(methodSchemaType.getQName(),
-                        axisOperation);
+                                                                 axisOperation);
             }
             if (addToService) {
                 service.addOperation(axisOperation);
@@ -576,10 +575,10 @@
         XmlSchemaSequence sequence = new XmlSchemaSequence();
         XmlSchema xmlSchema = getXmlSchema(schemaTargetNameSpace);
         QName elementName = new QName(schemaTargetNameSpace, "Exception", schema_namespace_prefix);
-        XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema);
+        XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema, false);
         complexType.setName("Exception");
         xmlSchema.getItems().add(complexType);
-        xmlSchema.getSchemaTypes().add(elementName, complexType);
+        xmlSchema.getSchemaTypes().put(elementName, complexType);
         typeTable.addComplexSchema(Exception.class.getName(), elementName);
         QName schemaTypeName = new QName(Java2WSDLConstants.URI_2001_SCHEMA_XSD, "string");
         addContentToMethodSchemaType(sequence, schemaTypeName, "Message", false);
@@ -608,7 +607,7 @@
                 targetNamespacePrefixMap.put(targetNameSpace, targetNamespacePrefix);
             }
 
-            XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema);
+            XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema, false);
             XmlSchemaSequence sequence = new XmlSchemaSequence();
             XmlSchemaComplexContentExtension complexExtension =
                     new XmlSchemaComplexContentExtension();
@@ -645,7 +644,7 @@
                 //if the parent class package name is differ from the child
                 if (!((NamespaceMap) xmlSchema.getNamespaceContext()).values().
                         contains(tgtNamespace)) {
-                    XmlSchemaImport importElement = new XmlSchemaImport();
+                    XmlSchemaImport importElement = new XmlSchemaImport(xmlSchema);
                     importElement.setNamespace(tgtNamespace);
                     xmlSchema.getItems().add(importElement);
                     ((NamespaceMap) xmlSchema.getNamespaceContext()).
@@ -670,7 +669,7 @@
             }
 
             xmlSchema.getItems().add(complexType);
-            xmlSchema.getSchemaTypes().add(schemaTypeName, complexType);
+            xmlSchema.getSchemaTypes().put(schemaTypeName, complexType);
 
             // adding this type to the table
             typeTable.addComplexSchema(name, schemaTypeName);
@@ -774,7 +773,7 @@
                 simpleTypeName += getSimpleClassName(simpleType);
 
                 if (xmlSchema.getTypeByName(simpleTypeName) == null) {
-                    XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema);
+                    XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema, false);
                     XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
                     xmlSchemaComplexType.setParticle(xmlSchemaSequence);
                     generateSchemaforFieldsandProperties(xmlSchema,
@@ -782,25 +781,25 @@
 
                     xmlSchemaComplexType.setName(simpleTypeName);
                     xmlSchema.getItems().add(xmlSchemaComplexType);
-                    xmlSchema.getSchemaTypes().add(
+                    xmlSchema.getSchemaTypes().put(
                             new QName(xmlSchema.getTargetNamespace(), simpleTypeName), xmlSchemaComplexType);
                 }
 
                 if (isGenerateWrappedArrayTypes) {
-                    XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
+                    XmlSchemaElement xmlSchemaElement = new XmlSchemaElement(xmlSchema, false);
                     xmlSchemaElement.setName( name + "Wrapper");
                     xmlSchemaElement.setNillable(true);
                     sequence.getItems().add(xmlSchemaElement);
 
                     String complexTypeName = simpleTypeName + "Wrapper";
 
-                    XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema);
+                    XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema, false);
                     XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
                     xmlSchemaComplexType.setParticle(xmlSchemaSequence);
                     xmlSchemaComplexType.setName(complexTypeName);
 
                     xmlSchema.getItems().add(xmlSchemaComplexType);
-                    xmlSchema.getSchemaTypes().add(
+                    xmlSchema.getSchemaTypes().put(
                             new QName(schemaTargetNameSpace, xmlSchemaComplexType.getName()),
                             xmlSchemaComplexType);
                     addContentToMethodSchemaType(xmlSchemaSequence,
@@ -869,7 +868,7 @@
 
             if (typeTable.getComplexSchemaType(propertyName) != null && !((NamespaceMap) xmlSchema.getNamespaceContext()).values().
                     contains(typeTable.getComplexSchemaType(propertyName).getNamespaceURI())) {
-                XmlSchemaImport importElement = new XmlSchemaImport();
+                XmlSchemaImport importElement = new XmlSchemaImport(xmlSchema);
                 importElement.setNamespace(
                         typeTable.getComplexSchemaType(propertyName).getNamespaceURI());
                 xmlSchema.getItems().add(importElement);
@@ -901,7 +900,7 @@
             simpleTypeName += simpleType.getSimpleName();
 
             if (xmlSchema.getTypeByName(simpleTypeName) == null) {
-                XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema);
+                XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema, false);
                 XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
                 xmlSchemaComplexType.setParticle(xmlSchemaSequence);
                 generateSchemaforGenericFields(xmlSchema,
@@ -909,25 +908,25 @@
 
                 xmlSchemaComplexType.setName(simpleTypeName);
                 xmlSchema.getItems().add(xmlSchemaComplexType);
-                xmlSchema.getSchemaTypes().add(
+                xmlSchema.getSchemaTypes().put(
                         new QName(xmlSchema.getTargetNamespace(), simpleTypeName), xmlSchemaComplexType);
             }
 
             if (isGenerateWrappedArrayTypes) {
-                XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
+                XmlSchemaElement xmlSchemaElement = new XmlSchemaElement(xmlSchema, false);
                 xmlSchemaElement.setName( name + "Wrapper");
                 xmlSchemaElement.setNillable(true);
                 sequence.getItems().add(xmlSchemaElement);
 
                 String complexTypeName = simpleTypeName + "Wrapper";
 
-                XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema);
+                XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema, false);
                 XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
                 xmlSchemaComplexType.setParticle(xmlSchemaSequence);
                 xmlSchemaComplexType.setName(complexTypeName);
 
                 xmlSchema.getItems().add(xmlSchemaComplexType);
-                xmlSchema.getSchemaTypes().add(
+                xmlSchema.getSchemaTypes().put(
                         new QName(schemaTargetNameSpace, xmlSchemaComplexType.getName()),
                         xmlSchemaComplexType);
                 addContentToMethodSchemaType(xmlSchemaSequence,
@@ -998,7 +997,7 @@
 
             if (typeTable.getComplexSchemaType(propertyName) != null && !((NamespaceMap) xmlSchema.getNamespaceContext()).values().
                     contains(typeTable.getComplexSchemaType(propertyName).getNamespaceURI())) {
-                XmlSchemaImport importElement = new XmlSchemaImport();
+                XmlSchemaImport importElement = new XmlSchemaImport(xmlSchema);
                 importElement.setNamespace(
                         typeTable.getComplexSchemaType(propertyName).getNamespaceURI());
                 xmlSchema.getItems().add(importElement);
@@ -1018,7 +1017,7 @@
                                                   String name,
                                                   boolean isArrayType,
                                                   String propertyName) {
-        XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
+        XmlSchemaElement xmlSchemaElement = new XmlSchemaElement(xmlSchema, false);
         xmlSchemaElement.setName( name + "Wrapper");
         xmlSchemaElement.setNillable(true);
         sequence.getItems().add(xmlSchemaElement);
@@ -1028,13 +1027,13 @@
 
         XmlSchemaComplexType xmlSchemaComplexType ;
         if (xmlSchema.getTypeByName(complexTypeName) == null) {
-            xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema);
+            xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema, false);
             XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
             xmlSchemaComplexType.setParticle(xmlSchemaSequence);
             xmlSchemaComplexType.setName(complexTypeName);
 
             xmlSchema.getItems().add(xmlSchemaComplexType);
-            xmlSchema.getSchemaTypes().add(
+            xmlSchema.getSchemaTypes().put(
                     new QName(schemaTargetNameSpace, xmlSchemaComplexType.getName()),
                     xmlSchemaComplexType);
             addElementToSequence("array",
@@ -1057,7 +1056,7 @@
                                       boolean isBase64Binary,
                                       boolean isArryType,
                                       boolean isPrimitive) {
-        XmlSchemaElement elt1 = new XmlSchemaElement();
+        XmlSchemaElement elt1 = new XmlSchemaElement(getXmlSchema(schemaTargetNameSpace), false);
         elt1.setName(name);
         elt1.setSchemaTypeName(propertyQName);
         sequence.getItems().add(elt1);
@@ -1150,31 +1149,31 @@
 
             XmlSchema xmlSchema = getXmlSchema(schemaTargetNameSpace);
             if (xmlSchema.getTypeByName(simpleTypeName) == null) {
-                XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema);
+                XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema, false);
                 XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
                 xmlSchemaComplexType.setParticle(xmlSchemaSequence);
                 generateSchemaForType(xmlSchemaSequence, simpleType, "array",true);
                 xmlSchemaComplexType.setName(simpleTypeName);
                 xmlSchema.getItems().add(xmlSchemaComplexType);
-                xmlSchema.getSchemaTypes().add(
+                xmlSchema.getSchemaTypes().put(
                         new QName(xmlSchema.getTargetNamespace(), simpleTypeName), xmlSchemaComplexType);
             }
 
             if (isGenerateWrappedArrayTypes) {
-                XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
+                XmlSchemaElement xmlSchemaElement = new XmlSchemaElement(xmlSchema, false);
                 xmlSchemaElement.setName(partName + "Wrapper");
                 xmlSchemaElement.setNillable(true);
                 sequence.getItems().add(xmlSchemaElement);
 
                 String complexTypeName = simpleTypeName + "Wrapper";
 
-                XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema);
+                XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema, false);
                 XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
                 xmlSchemaComplexType.setParticle(xmlSchemaSequence);
                 xmlSchemaComplexType.setName(complexTypeName);
 
                 xmlSchema.getItems().add(xmlSchemaComplexType);
-                xmlSchema.getSchemaTypes().add(
+                xmlSchema.getSchemaTypes().put(
                         new QName(schemaTargetNameSpace, xmlSchemaComplexType.getName()),
                         xmlSchemaComplexType);
                 addContentToMethodSchemaType(xmlSchemaSequence,
@@ -1227,24 +1226,23 @@
         if (schemaTypeName == null) {
             schemaTypeName = generateSchema(type);
             if (isGenerateWrappedArrayTypes && isArrayType) {
-
-                XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
+                XmlSchema xmlSchema = getXmlSchema(schemaTargetNameSpace);
+                XmlSchemaElement xmlSchemaElement = new XmlSchemaElement(xmlSchema, false);
                 xmlSchemaElement.setName(partName + "Wrapper");
                 xmlSchemaElement.setNillable(true);
                 sequence.getItems().add(xmlSchemaElement);
 
                 String complexTypeName = schemaTypeName.getLocalPart() + "Wrapper";
-                XmlSchema xmlSchema = getXmlSchema(schemaTargetNameSpace);
 
                 XmlSchemaComplexType xmlSchemaComplexType = null;
                 if (xmlSchema.getTypeByName(complexTypeName) == null) {
-                    xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema);
+                    xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema, false);
                     XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
                     xmlSchemaComplexType.setParticle(xmlSchemaSequence);
                     xmlSchemaComplexType.setName(complexTypeName);
 
                     xmlSchema.getItems().add(xmlSchemaComplexType);
-                    xmlSchema.getSchemaTypes().add(
+                    xmlSchema.getSchemaTypes().put(
                             new QName(schemaTargetNameSpace, xmlSchemaComplexType.getName()),
                             xmlSchemaComplexType);
                     addContentToMethodSchemaType(xmlSchemaSequence,
@@ -1272,24 +1270,23 @@
 
         } else {
             if (isGenerateWrappedArrayTypes && isArrayType) {
-
-                XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
+                XmlSchema xmlSchema = getXmlSchema(schemaTargetNameSpace);
+                XmlSchemaElement xmlSchemaElement = new XmlSchemaElement(xmlSchema, false);
                 xmlSchemaElement.setName(partName +"Wrapper");
                 xmlSchemaElement.setNillable(true);
                 sequence.getItems().add(xmlSchemaElement);
 
                 String complexTypeName = schemaTypeName.getLocalPart() + "Wrapper";
-                XmlSchema xmlSchema = getXmlSchema(schemaTargetNameSpace);
 
                 XmlSchemaComplexType xmlSchemaComplexType = null;
                 if (xmlSchema.getTypeByName(complexTypeName) == null) {
-                    xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema);
+                    xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema, false);
                     XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
                     xmlSchemaComplexType.setParticle(xmlSchemaSequence);
                     xmlSchemaComplexType.setName(complexTypeName);
 
                     xmlSchema.getItems().add(xmlSchemaComplexType);
-                    xmlSchema.getSchemaTypes().add(
+                    xmlSchema.getSchemaTypes().put(
                             new QName(schemaTargetNameSpace, xmlSchemaComplexType.getName()),
                             xmlSchemaComplexType);
                     addContentToMethodSchemaType(xmlSchemaSequence,
@@ -1319,31 +1316,31 @@
     private QName processParameterArrayTypes(XmlSchemaSequence sequence, Class<?> type, String partName, String simpleTypeName) throws Exception {
         XmlSchema xmlSchema = getXmlSchema(schemaTargetNameSpace);
         if (xmlSchema.getTypeByName(simpleTypeName) == null) {
-            XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema);
+            XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema, false);
             XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
             xmlSchemaComplexType.setParticle(xmlSchemaSequence);
             generateSchemaForType(xmlSchemaSequence, type.getComponentType(), "array");
             xmlSchemaComplexType.setName(simpleTypeName);
             xmlSchema.getItems().add(xmlSchemaComplexType);
-            xmlSchema.getSchemaTypes().add(
+            xmlSchema.getSchemaTypes().put(
                     new QName(xmlSchema.getTargetNamespace(), simpleTypeName), xmlSchemaComplexType);
         }
 
         if (isGenerateWrappedArrayTypes) {
-            XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
+            XmlSchemaElement xmlSchemaElement = new XmlSchemaElement(xmlSchema, false);
             xmlSchemaElement.setName(partName + "Wrapper");
             xmlSchemaElement.setNillable(true);
             sequence.getItems().add(xmlSchemaElement);
 
             String complexTypeName = simpleTypeName + "Wrapper";
 
-            XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema);
+            XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(xmlSchema, false);
             XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
             xmlSchemaComplexType.setParticle(xmlSchemaSequence);
             xmlSchemaComplexType.setName(complexTypeName);
 
             xmlSchema.getItems().add(xmlSchemaComplexType);
-            xmlSchema.getSchemaTypes().add(
+            xmlSchema.getSchemaTypes().put(
                     new QName(schemaTargetNameSpace, xmlSchemaComplexType.getName()),
                     xmlSchemaComplexType);
             addContentToMethodSchemaType(xmlSchemaSequence,
@@ -1371,7 +1368,7 @@
                                                 QName schemaTypeName,
                                                 String paraName,
                                                 boolean isArray) {
-        XmlSchemaElement elt1 = new XmlSchemaElement();
+        XmlSchemaElement elt1 = new XmlSchemaElement(getXmlSchema(schemaTargetNameSpace), false);
         elt1.setName(paraName);
 
         elt1.setSchemaTypeName(schemaTypeName);
@@ -1424,11 +1421,10 @@
 
         XmlSchemaComplexType complexType = getComplexTypeForElement(xmlSchema, elementName);
         if (complexType == null) {
-            complexType = new XmlSchemaComplexType(xmlSchema);
+            complexType = new XmlSchemaComplexType(xmlSchema, false);
 
-            XmlSchemaElement globalElement = new XmlSchemaElement();
+            XmlSchemaElement globalElement = new XmlSchemaElement(xmlSchema, false);
             globalElement.setName(localPartName);
-            globalElement.setQName(elementName);
 
             boolean disallowAnonTypes = isAnonymousTypesDisallowed();
             if (disallowAnonTypes) {
@@ -1437,13 +1433,13 @@
                 complexType.setName(complexTypeName);
                 globalElement.setSchemaTypeName(complexType.getQName());
                 xmlSchema.getItems().add(complexType);
-                xmlSchema.getSchemaTypes().add(complexType.getQName(), complexType);
+                xmlSchema.getSchemaTypes().put(complexType.getQName(), complexType);
             } else {
                 globalElement.setSchemaType(complexType);
             }
 
             xmlSchema.getItems().add(globalElement);
-            xmlSchema.getElements().add(elementName, globalElement);
+            xmlSchema.getElements().put(elementName, globalElement);
         }
         typeTable.addComplexSchema(localPartName, elementName);
 
@@ -1457,24 +1453,23 @@
 
         XmlSchemaComplexType complexType = getComplexTypeForElement(xmlSchema, elementName);
         if (complexType == null) {
-            complexType = new XmlSchemaComplexType(xmlSchema);
+            complexType = new XmlSchemaComplexType(xmlSchema, false);
 
-            XmlSchemaElement globalElement = new XmlSchemaElement();
+            XmlSchemaElement globalElement = new XmlSchemaElement(xmlSchema, false);
             globalElement.setName(localPartName);
-            globalElement.setQName(elementName);
 
             boolean disallowAnonTypes = isAnonymousTypesDisallowed();
             if (disallowAnonTypes) {
                 complexType.setName(localPartName);
                 globalElement.setSchemaTypeName(complexType.getQName());
                 xmlSchema.getItems().add(complexType);
-                xmlSchema.getSchemaTypes().add(complexType.getQName(), complexType);
+                xmlSchema.getSchemaTypes().put(complexType.getQName(), complexType);
             } else {
                 globalElement.setSchemaType(complexType);
             }
 
             xmlSchema.getItems().add(globalElement);
-            xmlSchema.getElements().add(elementName, globalElement);
+            xmlSchema.getElements().put(elementName, globalElement);
 
         }
         return complexType;
@@ -1499,13 +1494,11 @@
     }
 
     protected XmlSchemaComplexType getComplexTypeForElement(XmlSchema xmlSchema, QName name) {
-        
-        Iterator<?> iterator = xmlSchema.getItems().getIterator();
-        while (iterator.hasNext()) {
-            XmlSchemaObject object = (XmlSchemaObject) iterator.next();
+
+        for (XmlSchemaObject object : xmlSchema.getItems()) {
             if (object instanceof XmlSchemaElement && ((XmlSchemaElement) object).getQName().equals(name)) {
                 XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType) ((XmlSchemaElement) object).getSchemaType();
-                if ((xmlSchemaComplexType == null) && (((XmlSchemaElement) object).getSchemaTypeName() != null)){
+                if ((xmlSchemaComplexType == null) && (((XmlSchemaElement) object).getSchemaTypeName() != null)) {
                     xmlSchemaComplexType =
                             (XmlSchemaComplexType) xmlSchema.getTypeByName(((XmlSchemaElement) object).getSchemaTypeName());
                 }
@@ -1576,9 +1569,11 @@
         }
         if (map instanceof NamespaceMap && !((NamespaceMap) map).values().
                 contains(schemaTypeName.getNamespaceURI())) {
-            XmlSchemaImport importElement = new XmlSchemaImport();
+            XmlSchemaImport importElement = new XmlSchemaImport(xmlSchema);
             importElement.setNamespace(schemaTypeName.getNamespaceURI());
-            xmlSchema.getItems().add(importElement);
+            if (!xmlSchema.getItems().contains(importElement)) {
+                xmlSchema.getItems().add(importElement);
+            }
             ((NamespaceMap) xmlSchema.getNamespaceContext()).
                     put(generatePrefix(), schemaTypeName.getNamespaceURI());
         }
@@ -1602,17 +1597,17 @@
 
     protected XmlSchemaForm getAttrFormDefaultSetting() {
         if (FORM_DEFAULT_UNQUALIFIED.equals(getAttrFormDefault())) {
-            return new XmlSchemaForm(XmlSchemaForm.UNQUALIFIED);
+            return XmlSchemaForm.schemaValueOf(FORM_DEFAULT_UNQUALIFIED);
         } else {
-            return new XmlSchemaForm(XmlSchemaForm.QUALIFIED);
+            return XmlSchemaForm.schemaValueOf(FORM_DEFAULT_QUALIFIED);
         }
     }
 
     protected XmlSchemaForm getElementFormDefaultSetting() {
         if (FORM_DEFAULT_UNQUALIFIED.equals(getElementFormDefault())) {
-            return new XmlSchemaForm(XmlSchemaForm.UNQUALIFIED);
+            return XmlSchemaForm.schemaValueOf(FORM_DEFAULT_UNQUALIFIED);
         } else {
-            return new XmlSchemaForm(XmlSchemaForm.QUALIFIED);
+            return XmlSchemaForm.schemaValueOf(FORM_DEFAULT_QUALIFIED);
         }
     }
 
@@ -1810,7 +1805,7 @@
 		String targetNamespacePrefix = targetNamespacePrefixMap
 				.get(Constants.AXIS2_MAP_NAMESPACE_URI);
 		
-		XmlSchemaComplexType entryType = new XmlSchemaComplexType(xmlSchema);
+		XmlSchemaComplexType entryType = new XmlSchemaComplexType(xmlSchema, false);
 		QName entryTypeName = new QName(Constants.AXIS2_MAP_NAMESPACE_URI,
 				entryName, targetNamespacePrefix);
 		XmlSchemaSequence entrySequence = new XmlSchemaSequence();
@@ -1822,15 +1817,14 @@
 		entryType.setName(entryName);
 		xmlSchema.getItems().add(entryType);
 
-		XmlSchemaElement entryElement = new XmlSchemaElement();
+		XmlSchemaElement entryElement = new XmlSchemaElement(xmlSchema, false);
 		entryElement.setName(Constants.MAP_ENTRY_ELEMENT_NAME);
 		entryElement.setNillable(true);
 		entryElement.setSchemaTypeName(entryTypeName);
 		entryElement.setMaxOccurs(Long.MAX_VALUE);
 		entryElement.setMinOccurs(0);
-		entryElement.setQName(entryTypeName);
 
-		XmlSchemaComplexType mapType = new XmlSchemaComplexType(xmlSchema);
+		XmlSchemaComplexType mapType = new XmlSchemaComplexType(xmlSchema, false);
 		QName mapTypeName = new QName(Constants.AXIS2_MAP_NAMESPACE_URI,
 				mapName, targetNamespacePrefix);
 		XmlSchemaSequence mapSequence = new XmlSchemaSequence();
@@ -1844,8 +1838,7 @@
 		addImport(getXmlSchema(schemaTargetNameSpace), schemaTypeName);
 
 		if (sequence != null) {
-			XmlSchemaComplexType parameterType = new XmlSchemaComplexType(
-					xmlSchema);
+			XmlSchemaComplexType parameterType = new XmlSchemaComplexType(xmlSchema, false);
 			QName parameterTypeName = new QName(
 					Constants.AXIS2_MAP_NAMESPACE_URI, mapName,
 					targetNamespacePrefix);
@@ -1853,7 +1846,7 @@
 			parameterSequence.getItems().add(entryElement);
 			parameterType.setParticle(parameterSequence);
 
-			XmlSchemaElement parameterElement = new XmlSchemaElement();
+			XmlSchemaElement parameterElement = new XmlSchemaElement(xmlSchema, false);
 			parameterElement.setName(parameterName);
             parameterElement.setMinOccurs(0);
 			parameterElement.setNillable(true);
@@ -1940,7 +1933,7 @@
 				.isAssignableFrom((Class<?>) innerParameterizedType
 					.getRawType())) {
 			    XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType(
-				    xmlSchema);
+				    xmlSchema, false);
 			    XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
 			    xmlSchemaComplexType.setParticle(xmlSchemaSequence);
 			    generateWrappedSchemaTypeForCollection(
@@ -1948,7 +1941,7 @@
 			    "array");
 			    xmlSchemaComplexType.setName(simpleTypeName);
 			    xmlSchema.getItems().add(xmlSchemaComplexType);
-			    xmlSchema.getSchemaTypes().add(
+			    xmlSchema.getSchemaTypes().put(
 				    new QName(xmlSchema.getTargetNamespace(),
 					    simpleTypeName), xmlSchemaComplexType);
 
@@ -2069,22 +2062,21 @@
         XmlSchemaType schemaType = xmlSchema.getTypeByName(entryName);
 
         if (schemaType == null) {
-            XmlSchemaComplexType entryType = new XmlSchemaComplexType(xmlSchema);
+            XmlSchemaComplexType entryType = new XmlSchemaComplexType(xmlSchema, false);
             XmlSchemaSequence entrySequence = new XmlSchemaSequence();
             XmlSchemaAny any = new XmlSchemaAny();
             entrySequence.getItems().add(any);
             entryType.setParticle(entrySequence);
             entryType.setName(entryName.getLocalPart());
             xmlSchema.getItems().add(entryType);
-            xmlSchema.getSchemaTypes().add(entryName, entryType);
+            xmlSchema.getSchemaTypes().put(entryName, entryType);
             schemaType = entryType;
 
         }
 
-        XmlSchemaElement entryElement = new XmlSchemaElement();
+        XmlSchemaElement entryElement = new XmlSchemaElement(xmlSchema, false);
         entryElement.setName(parameterName);
         entryElement.setSchemaTypeName(schemaType.getQName());
-        entryElement.setQName(schemaType.getQName());
         entryElement.setMinOccurs(0);
         entryElement.setNillable(true);
         if (sequence != null) {
@@ -2134,7 +2126,7 @@
                   enumClass, targetNamespacePrefix);
                  // check weather this enum class have already added to schema
             if(typeTable.getSimpleTypeEnum(classType.getName())==null){
-                XmlSchemaSimpleType simpleType = new XmlSchemaSimpleType(xmlSchema);
+                XmlSchemaSimpleType simpleType = new XmlSchemaSimpleType(xmlSchema, false);
                 simpleType.setName(enumClass);
                 XmlSchemaSimpleTypeRestriction restriction = new XmlSchemaSimpleTypeRestriction();
                 restriction.setBaseTypeName(Constants.XSD_STRING);
@@ -2148,17 +2140,15 @@
             }
 
 
-          XmlSchemaElement entryElement = new XmlSchemaElement();
+          XmlSchemaElement entryElement = new XmlSchemaElement(xmlSchema, false);
           entryElement.setName(Constants.ENUM_ELEMENT_NAME);
           entryElement.setNillable(true);
           entryElement.setSchemaTypeName(enumQname);
-          entryElement.setQName(enumQname);
              QName schemaTypeName = new QName(Constants.AXIS2_ENUM_NAMESPACE_URI,
                   enumClass);
           addImport(getXmlSchema(schemaTargetNameSpace), schemaTypeName);
           if (sequence != null) {
-              XmlSchemaComplexType parameterType = new XmlSchemaComplexType(
-                      xmlSchema);
+              XmlSchemaComplexType parameterType = new XmlSchemaComplexType(xmlSchema, false);
               QName parameterTypeName = new QName(
                       Constants.AXIS2_ENUM_NAMESPACE_URI, enumClass,
                       targetNamespacePrefix);
@@ -2166,7 +2156,7 @@
               parameterSequence.getItems().add(entryElement);
               parameterType.setParticle(parameterSequence);
 
-              XmlSchemaElement parameterElement = new XmlSchemaElement();
+              XmlSchemaElement parameterElement = new XmlSchemaElement(xmlSchema, false);
               parameterElement.setName(parameterName);
               if(isArrayType){
                   parameterElement.setMaxOccurs(Long.MAX_VALUE);
Index: modules/kernel/src/org/apache/axis2/builder/BuilderUtil.java
===================================================================
--- modules/kernel/src/org/apache/axis2/builder/BuilderUtil.java	(revision 1467549)
+++ modules/kernel/src/org/apache/axis2/builder/BuilderUtil.java	(working copy)
@@ -29,10 +29,8 @@
 import org.apache.axiom.om.OMText;
 import org.apache.axiom.om.OMXMLBuilderFactory;
 import org.apache.axiom.om.OMXMLParserWrapper;
-import org.apache.axiom.om.impl.MTOMConstants;
 import org.apache.axiom.om.impl.builder.StAXBuilder;
 import org.apache.axiom.om.impl.builder.StAXOMBuilder;
-import org.apache.axiom.om.impl.builder.XOPAwareStAXOMBuilder;
 import org.apache.axiom.om.util.StAXParserConfiguration;
 import org.apache.axiom.om.util.StAXUtils;
 import org.apache.axiom.soap.SOAP11Constants;
@@ -43,7 +41,6 @@
 import org.apache.axiom.soap.SOAPFactory;
 import org.apache.axiom.soap.SOAPModelBuilder;
 import org.apache.axiom.soap.SOAPProcessingException;
-import org.apache.axiom.soap.impl.builder.MTOMStAXSOAPModelBuilder;
 import org.apache.axiom.soap.impl.builder.StAXSOAPModelBuilder;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
@@ -65,9 +62,9 @@
 import org.apache.ws.commons.schema.XmlSchemaAll;
 import org.apache.ws.commons.schema.XmlSchemaComplexType;
 import org.apache.ws.commons.schema.XmlSchemaElement;
-import org.apache.ws.commons.schema.XmlSchemaGroupBase;
 import org.apache.ws.commons.schema.XmlSchemaParticle;
 import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaSequenceMember;
 import org.apache.ws.commons.schema.XmlSchemaType;
 
 import javax.activation.DataHandler;
@@ -84,7 +81,6 @@
 import java.io.UnsupportedEncodingException;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
-import java.util.Iterator;
 import java.util.Map;
 
 public class BuilderUtil {
@@ -138,58 +134,50 @@
                     XmlSchemaComplexType complexType = ((XmlSchemaComplexType)schemaType);
                     XmlSchemaParticle particle = complexType.getParticle();
                     if (particle instanceof XmlSchemaSequence || particle instanceof XmlSchemaAll) {
-                        XmlSchemaGroupBase xmlSchemaGroupBase = (XmlSchemaGroupBase)particle;
-                        Iterator iterator = xmlSchemaGroupBase.getItems().getIterator();
 
-                        // now we need to know some information from the binding operation.
+                        if (particle instanceof XmlSchemaSequence) {
+                            XmlSchemaSequence sequence = (XmlSchemaSequence) particle;
+                            // now we need to know some information from the binding operation.
 
-                        while (iterator.hasNext()) {
-                            XmlSchemaElement innerElement = (XmlSchemaElement)iterator.next();
-                            QName qName = innerElement.getQName();
-                            // ignoring the elements without proper type and minoccurs zero
-                            if ((innerElement.getSchemaTypeName() == null) && (innerElement.getMinOccurs() == 0)){
-                                continue;
-                            }
-                            if (qName == null && innerElement.getSchemaTypeName()
-                                    .equals(org.apache.ws.commons.schema.constants.Constants.XSD_ANYTYPE)) {
-                                createSOAPMessageWithoutSchema(soapFactory, bodyFirstChild,
-                                                               requestParameterMap);
-                                break;
-                            }
-                            long minOccurs = innerElement.getMinOccurs();
-                            boolean nillable = innerElement.isNillable();
-                            String name =
-                                    qName != null ? qName.getLocalPart() : innerElement.getName();
-                            Object value;
-                            OMNamespace ns = (qName == null ||
-                                              qName.getNamespaceURI() == null
-                                              || qName.getNamespaceURI().length() == 0) ?
-                                    null : soapFactory.createOMNamespace(
-                                    qName.getNamespaceURI(), null);
+                            for (XmlSchemaSequenceMember sequenceMember : sequence.getItems()) {
 
-                            // FIXME changed
-                            while ((value = requestParameterMap.get(name)) != null) {
-                                addRequestParameter(soapFactory,
-                                                    bodyFirstChild, ns, name, value);
-                                minOccurs--;
+                                XmlSchemaElement innerElement = (XmlSchemaElement) sequenceMember;
+                                QName qName = innerElement.getQName();
+                                // ignoring the elements without proper type and minoccurs zero
+                                if ((innerElement.getSchemaTypeName() == null) &&
+                                    (innerElement.getMinOccurs() == 0)) {
+                                    continue;
+                                }
+                                if (qName == null && innerElement.getSchemaTypeName()
+                                        .equals(org.apache.ws.commons.schema.constants.Constants.XSD_ANYTYPE)) {
+                                    createSOAPMessageWithoutSchema(soapFactory, bodyFirstChild,
+                                                                   requestParameterMap);
+                                    break;
+                                }
+                                checkMinOccurs(innerElement, qName, soapFactory, requestParameterMap,
+                                               bodyFirstChild);
                             }
-                            if (minOccurs > 0) {
-                                if (nillable) {
+                        } else {
+                            XmlSchemaAll sequence = (XmlSchemaAll) particle;
+                            // now we need to know some information from the binding operation.
 
-                                    OMNamespace xsi = soapFactory.createOMNamespace(
-                                            Constants.URI_DEFAULT_SCHEMA_XSI,
-                                            Constants.NS_PREFIX_SCHEMA_XSI);
-                                    OMAttribute omAttribute =
-                                            soapFactory.createOMAttribute("nil", xsi, "true");
-                                    soapFactory.createOMElement(name, ns,
-                                                                bodyFirstChild)
-                                            .addAttribute(omAttribute);
+                            for (XmlSchemaSequenceMember sequenceMember : sequence.getItems()) {
 
-                                } else {
-                                    throw new AxisFault("Required element " + qName +
-                                                        " defined in the schema can not be" +
-                                                        " found in the request");
+                                XmlSchemaElement innerElement = (XmlSchemaElement) sequenceMember;
+                                QName qName = innerElement.getQName();
+                                // ignoring the elements without proper type and minoccurs zero
+                                if ((innerElement.getSchemaTypeName() == null) &&
+                                    (innerElement.getMinOccurs() == 0)) {
+                                    continue;
                                 }
+                                if (qName == null && innerElement.getSchemaTypeName()
+                                        .equals(org.apache.ws.commons.schema.constants.Constants.XSD_ANYTYPE)) {
+                                    createSOAPMessageWithoutSchema(soapFactory, bodyFirstChild,
+                                                                   requestParameterMap);
+                                    break;
+                                }
+                                checkMinOccurs(innerElement, qName, soapFactory, requestParameterMap,
+                                               bodyFirstChild);
                             }
                         }
                     }
@@ -199,6 +187,48 @@
         return soapEnvelope;
     }
 
+    private static void checkMinOccurs(XmlSchemaElement innerElement, QName qName,
+                                       SOAPFactory soapFactory,
+                                       MultipleEntryHashMap requestParameterMap,
+                                       OMElement bodyFirstChild)
+            throws AxisFault {
+        long minOccurs = innerElement.getMinOccurs();
+        boolean nillable = innerElement.isNillable();
+        String name =
+                qName != null ? qName.getLocalPart() : innerElement.getName();
+        Object value;
+        OMNamespace ns = (qName == null ||
+                          qName.getNamespaceURI() == null
+                          || qName.getNamespaceURI().length() == 0) ?
+                         null : soapFactory.createOMNamespace(
+                qName.getNamespaceURI(), null);
+
+        // FIXME changed
+        while ((value = requestParameterMap.get(name)) != null) {
+            addRequestParameter(soapFactory,
+                                bodyFirstChild, ns, name, value);
+            minOccurs--;
+        }
+        if (minOccurs > 0) {
+            if (nillable) {
+
+                OMNamespace xsi = soapFactory.createOMNamespace(
+                        Constants.URI_DEFAULT_SCHEMA_XSI,
+                        Constants.NS_PREFIX_SCHEMA_XSI);
+                OMAttribute omAttribute =
+                        soapFactory.createOMAttribute("nil", xsi, "true");
+                soapFactory.createOMElement(name, ns,
+                                            bodyFirstChild)
+                        .addAttribute(omAttribute);
+
+            } else {
+                throw new AxisFault("Required element " + qName +
+                                    " defined in the schema can not be" +
+                                    " found in the request");
+            }
+        }
+    }
+
     public static void createSOAPMessageWithoutSchema(SOAPFactory soapFactory,
                                                        OMElement bodyFirstChild,
                                                        MultipleEntryHashMap requestParameterMap) {
Index: modules/kernel/src/org/apache/axis2/util/SchemaUtil.java
===================================================================
--- modules/kernel/src/org/apache/axis2/util/SchemaUtil.java	(revision 1467549)
+++ modules/kernel/src/org/apache/axis2/util/SchemaUtil.java	(working copy)
@@ -22,12 +22,11 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaExternal;
 import org.apache.ws.commons.schema.XmlSchemaImport;
 import org.apache.ws.commons.schema.XmlSchemaInclude;
-import org.apache.ws.commons.schema.XmlSchemaObjectCollection;
 
 import java.util.HashMap;
-import java.util.Iterator;
 
 /**
  * 
@@ -49,22 +48,17 @@
         }
         map.put(key, schema);
 
-        XmlSchemaObjectCollection includes = schema.getIncludes();
-        if (includes != null) {
-            Iterator tempIterator = includes.getIterator();
-            while (tempIterator.hasNext()) {
-                Object o = tempIterator.next();
-                if (o instanceof XmlSchemaImport) {
-                    XmlSchema schema1 = ((XmlSchemaImport) o).getSchema();
-                    if (schema1 != null) {
-                        traverseSchemas(schema1, map);
-                    }
+        for (XmlSchemaExternal external : schema.getExternals()) {
+            if (external instanceof XmlSchemaImport) {
+                XmlSchema schema1 = external.getSchema();
+                if (schema1 != null) {
+                    traverseSchemas(schema1, map);
                 }
-                if (o instanceof XmlSchemaInclude) {
-                    XmlSchema schema1 = ((XmlSchemaInclude) o).getSchema();
-                    if (schema1 != null) {
-                        traverseSchemas(schema1, map);
-                    }
+            }
+            if (external instanceof XmlSchemaInclude) {
+                XmlSchema schema1 = external.getSchema();
+                if (schema1 != null) {
+                    traverseSchemas(schema1, map);
                 }
             }
         }
Index: modules/kernel/pom.xml
===================================================================
--- modules/kernel/pom.xml	(revision 1467549)
+++ modules/kernel/pom.xml	(working copy)
@@ -62,8 +62,8 @@
             <artifactId>wsdl4j</artifactId>
         </dependency>
         <dependency>
-            <groupId>org.apache.ws.commons.schema</groupId>
-            <artifactId>XmlSchema</artifactId>
+            <groupId>org.apache.ws.xmlschema</groupId>
+            <artifactId>xmlschema-core</artifactId>
         </dependency>
         <dependency>
             <groupId>org.apache.neethi</groupId>
@@ -71,10 +71,13 @@
         </dependency>
         <dependency>
             <groupId>org.apache.woden</groupId>
-            <artifactId>woden-core</artifactId>
-            <version>${woden.version}</version>
+            <artifactId>woden-impl-commons</artifactId>
         </dependency>
         <dependency>
+            <groupId>org.apache.woden</groupId>
+            <artifactId>woden-impl-dom</artifactId>
+        </dependency>
+        <dependency>
             <groupId>commons-logging</groupId>
             <artifactId>commons-logging</artifactId>
         </dependency>
Index: modules/fastinfoset/pom.xml
===================================================================
--- modules/fastinfoset/pom.xml	(revision 1467549)
+++ modules/fastinfoset/pom.xml	(working copy)
@@ -62,8 +62,8 @@
             <artifactId>commons-fileupload</artifactId>
         </dependency>
         <dependency>
-            <groupId>org.apache.ws.commons.schema</groupId>
-            <artifactId>XmlSchema</artifactId>
+            <groupId>org.apache.ws.xmlschema</groupId>
+            <artifactId>xmlschema-core</artifactId>
         </dependency>
         <dependency>
             <groupId>org.apache.axis2</groupId>
Index: modules/parent/pom.xml
===================================================================
--- modules/parent/pom.xml	(revision 1467549)
+++ modules/parent/pom.xml	(working copy)
@@ -70,7 +70,7 @@
         <axiom.version>1.2.15-SNAPSHOT</axiom.version>
         <neethi.version>3.0.3-SNAPSHOT</neethi.version>
         <woden.version>1.0-SNAPSHOT</woden.version>
-        <xmlschema.version>1.4.8-SNAPSHOT</xmlschema.version>
+        <xmlschema.version>2.0.3</xmlschema.version>
 
         <!-- Use released versions for these projects -->
         <ant.version>1.7.0</ant.version>
@@ -642,8 +642,8 @@
                 <version>${axiom.version}</version>
             </dependency>
             <dependency>
-                <groupId>org.apache.ws.commons.schema</groupId>
-                <artifactId>XmlSchema</artifactId>
+                <groupId>org.apache.ws.xmlschema</groupId>
+                <artifactId>xmlschema-core</artifactId>
                 <version>${xmlschema.version}</version>
             </dependency>
             <dependency>
@@ -752,10 +752,15 @@
             </dependency>
             <dependency>
                 <groupId>org.apache.woden</groupId>
-                <artifactId>woden-core</artifactId>
+                <artifactId>woden-impl-commons</artifactId>
                 <version>${woden.version}</version>
             </dependency>
             <dependency>
+                <groupId>org.apache.woden</groupId>
+                <artifactId>woden-impl-dom</artifactId>
+                <version>${woden.version}</version>
+            </dependency>
+            <dependency>
                 <groupId>javax.ws.rs</groupId>
                 <artifactId>jsr311-api</artifactId>
                 <version>${jsr311.api.version}</version>
Index: modules/json/test/org/apache/axis2/json/gson/GsonXMLStreamWriterTest.java
===================================================================
--- modules/json/test/org/apache/axis2/json/gson/GsonXMLStreamWriterTest.java	(revision 1467549)
+++ modules/json/test/org/apache/axis2/json/gson/GsonXMLStreamWriterTest.java	(working copy)
@@ -53,7 +53,7 @@
         String fileName = "test-resources/custom_schema/testSchema_1.xsd";
         InputStream is = new FileInputStream(fileName);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         List<XmlSchema> schemaList = new ArrayList<XmlSchema>();
         schemaList.add(schema);
         QName elementQName = new QName("http://www.w3schools.com", "response");
Index: modules/json/test/org/apache/axis2/json/gson/GsonXMLStreamReaderTest.java
===================================================================
--- modules/json/test/org/apache/axis2/json/gson/GsonXMLStreamReaderTest.java	(revision 1467549)
+++ modules/json/test/org/apache/axis2/json/gson/GsonXMLStreamReaderTest.java	(working copy)
@@ -50,7 +50,7 @@
         String fileName = "test-resources/custom_schema/testSchema_1.xsd";
         InputStream is = new FileInputStream(fileName);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         List<XmlSchema> schemaList = new ArrayList<XmlSchema>();
         schemaList.add(schema);
         QName elementQName = new QName("http://www.w3schools.com", "response");
Index: modules/json/test/org/apache/axis2/json/gson/factory/XmlNodeGeneratorTest.java
===================================================================
--- modules/json/test/org/apache/axis2/json/gson/factory/XmlNodeGeneratorTest.java	(revision 1467549)
+++ modules/json/test/org/apache/axis2/json/gson/factory/XmlNodeGeneratorTest.java	(working copy)
@@ -21,9 +21,7 @@
 
 import org.apache.ws.commons.schema.XmlSchema;
 import org.apache.ws.commons.schema.XmlSchemaCollection;
-import org.junit.After;
 import org.junit.Assert;
-import org.junit.Before;
 import org.junit.Test;
 
 import javax.xml.namespace.QName;
@@ -44,7 +42,7 @@
         String fileName = "test-resources/custom_schema/testSchema_2.xsd";
         InputStream is = new FileInputStream(fileName);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
 
         List<XmlSchema> schemaList = new ArrayList<XmlSchema>();
         schemaList.add(schema);
Index: modules/json/test/org/apache/axis2/json/gson/JSONMessageHandlerTest.java
===================================================================
--- modules/json/test/org/apache/axis2/json/gson/JSONMessageHandlerTest.java	(revision 1467549)
+++ modules/json/test/org/apache/axis2/json/gson/JSONMessageHandlerTest.java	(working copy)
@@ -31,7 +31,6 @@
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisOperationFactory;
 import org.apache.axis2.description.AxisService;
-import org.apache.axis2.description.WSDL2Constants;
 import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.axis2.engine.MessageReceiver;
 import org.apache.axis2.json.gson.factory.JsonConstant;
@@ -80,7 +79,7 @@
         String fileName = "test-resources/custom_schema/testSchema_2.xsd";
         InputStream is = new FileInputStream(fileName);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
 
 
         QName elementQName = new QName("http://test.json.axis2.apache.org" ,"echoPerson");
Index: modules/json/test/org/apache/axis2/json/gson/JsonFormatterTest.java
===================================================================
--- modules/json/test/org/apache/axis2/json/gson/JsonFormatterTest.java	(revision 1467549)
+++ modules/json/test/org/apache/axis2/json/gson/JsonFormatterTest.java	(working copy)
@@ -94,7 +94,7 @@
         String fileName = "test-resources/custom_schema/testSchema_1.xsd";
         InputStream is = new FileInputStream(fileName);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         QName elementQName = new QName("http://www.w3schools.com", "response");
         ConfigurationContext configCtxt = new ConfigurationContext(new AxisConfiguration());
         outMsgContext.setConfigurationContext(configCtxt);
Index: modules/json/src/org/apache/axis2/json/gson/factory/XmlNodeGenerator.java
===================================================================
--- modules/json/src/org/apache/axis2/json/gson/factory/XmlNodeGenerator.java	(revision 1467549)
+++ modules/json/src/org/apache/axis2/json/gson/factory/XmlNodeGenerator.java	(working copy)
@@ -23,14 +23,13 @@
 import org.apache.ws.commons.schema.XmlSchema;
 import org.apache.ws.commons.schema.XmlSchemaComplexType;
 import org.apache.ws.commons.schema.XmlSchemaElement;
-import org.apache.ws.commons.schema.XmlSchemaObjectCollection;
 import org.apache.ws.commons.schema.XmlSchemaParticle;
 import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaSequenceMember;
 import org.apache.ws.commons.schema.XmlSchemaSimpleType;
 import org.apache.ws.commons.schema.XmlSchemaType;
 
 import javax.xml.namespace.QName;
-import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
@@ -117,12 +116,9 @@
             XmlSchemaParticle particle = complexType.getParticle();
             if (particle instanceof XmlSchemaSequence) {
                 XmlSchemaSequence sequence = (XmlSchemaSequence)particle;
-                XmlSchemaObjectCollection objectCollection = sequence.getItems();
-                Iterator objectIterator = objectCollection.getIterator();
-                while (objectIterator.hasNext()) {
-                    Object obj = objectIterator.next();
-                    if (obj instanceof XmlSchemaElement) {
-                        processElement((XmlSchemaElement)obj , parentNode , schema);
+                for (XmlSchemaSequenceMember member : sequence.getItems()) {
+                    if (member instanceof XmlSchemaElement) {
+                        processElement((XmlSchemaElement)member , parentNode , schema);
                     }
                 }
             }
Index: modules/tool/axis2-ant-plugin/pom.xml
===================================================================
--- modules/tool/axis2-ant-plugin/pom.xml	(revision 1467549)
+++ modules/tool/axis2-ant-plugin/pom.xml	(working copy)
@@ -81,8 +81,8 @@
             <artifactId>neethi</artifactId>
         </dependency>
         <dependency>
-            <groupId>org.apache.ws.commons.schema</groupId>
-            <artifactId>XmlSchema</artifactId>
+            <groupId>org.apache.ws.xmlschema</groupId>
+            <artifactId>xmlschema-core</artifactId>
         </dependency>
         <dependency>
             <groupId>org.apache.geronimo.specs</groupId>
Index: modules/tool/axis2-idea-plugin/pom.xml
===================================================================
--- modules/tool/axis2-idea-plugin/pom.xml	(revision 1467549)
+++ modules/tool/axis2-idea-plugin/pom.xml	(working copy)
@@ -113,12 +113,12 @@
             <artifactId>xmlbeans</artifactId>
         </dependency>
         <dependency>
-            <groupId>org.apache.ws.commons.schema</groupId>
-            <artifactId>XmlSchema</artifactId>
+            <groupId>org.apache.ws.xmlschema</groupId>
+            <artifactId>xmlschema-core</artifactId>
         </dependency>
         <dependency>
             <groupId>org.apache.woden</groupId>
-            <artifactId>woden-core</artifactId>
+            <artifactId>woden-impl-commons</artifactId>
         </dependency>
         <dependency>
             <groupId>log4j</groupId>
Index: modules/integration/pom.xml
===================================================================
--- modules/integration/pom.xml	(revision 1467549)
+++ modules/integration/pom.xml	(working copy)
@@ -128,6 +128,11 @@
             <type>mar</type>
         </dependency>
         <dependency>
+            <groupId>org.apache.woden</groupId>
+            <artifactId>woden-impl-dom</artifactId>
+            <version>${woden.version}</version>
+        </dependency>
+        <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
             <scope>test</scope>
Index: modules/corba/src/org/apache/axis2/corba/deployer/CorbaConstants.java
===================================================================
--- modules/corba/src/org/apache/axis2/corba/deployer/CorbaConstants.java	(revision 1467549)
+++ modules/corba/src/org/apache/axis2/corba/deployer/CorbaConstants.java	(working copy)
@@ -58,6 +58,7 @@
     String DEFAULT_SCHEMA_NAMESPACE_PREFIX = "xs";
     String URI_2001_SCHEMA_XSD = "http://www.w3.org/2001/XMLSchema";
     String FORM_DEFAULT_UNQUALIFIED = "unqualified";
+    String FORM_DEFAULT_QUALIFIED = "qualified";
 
     String SCHEMA_TO_IDL_MAPPING_LITERAL = "SchemaToIDLMapping";
     String ANY_TYPE_NAME = "CORBA.Any";
Index: modules/corba/src/org/apache/axis2/corba/deployer/SchemaGenerator.java
===================================================================
--- modules/corba/src/org/apache/axis2/corba/deployer/SchemaGenerator.java	(revision 1467549)
+++ modules/corba/src/org/apache/axis2/corba/deployer/SchemaGenerator.java	(working copy)
@@ -20,19 +20,54 @@
 package org.apache.axis2.corba.deployer;
 
 import org.apache.axis2.corba.exceptions.SchemaGeneratorException;
-import org.apache.axis2.corba.idl.types.*;
+import org.apache.axis2.corba.idl.types.AbstractCollectionType;
+import org.apache.axis2.corba.idl.types.AnyType;
+import org.apache.axis2.corba.idl.types.ArrayType;
+import org.apache.axis2.corba.idl.types.CompositeDataType;
+import org.apache.axis2.corba.idl.types.DataType;
+import org.apache.axis2.corba.idl.types.EnumType;
+import org.apache.axis2.corba.idl.types.ExceptionType;
+import org.apache.axis2.corba.idl.types.FixedType;
+import org.apache.axis2.corba.idl.types.IDL;
+import org.apache.axis2.corba.idl.types.Interface;
+import org.apache.axis2.corba.idl.types.Member;
+import org.apache.axis2.corba.idl.types.Operation;
+import org.apache.axis2.corba.idl.types.PrimitiveDataType;
+import org.apache.axis2.corba.idl.types.Typedef;
+import org.apache.axis2.corba.idl.types.UnionType;
 import org.apache.axis2.corba.receivers.CorbaUtil;
 import org.apache.axis2.description.java2wsdl.DefaultNamespaceGenerator;
 import org.apache.axis2.description.java2wsdl.Java2WSDLConstants;
 import org.apache.axis2.description.java2wsdl.NamespaceGenerator;
 import org.apache.axis2.description.java2wsdl.TypeTable;
-import org.apache.ws.commons.schema.*;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaChoice;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.apache.ws.commons.schema.XmlSchemaComplexType;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.apache.ws.commons.schema.XmlSchemaEnumerationFacet;
+import org.apache.ws.commons.schema.XmlSchemaFacet;
+import org.apache.ws.commons.schema.XmlSchemaForm;
+import org.apache.ws.commons.schema.XmlSchemaFractionDigitsFacet;
+import org.apache.ws.commons.schema.XmlSchemaImport;
+import org.apache.ws.commons.schema.XmlSchemaObject;
+import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaSimpleType;
+import org.apache.ws.commons.schema.XmlSchemaSimpleTypeRestriction;
+import org.apache.ws.commons.schema.XmlSchemaTotalDigitsFacet;
 import org.apache.ws.commons.schema.utils.NamespaceMap;
 
 import javax.xml.namespace.QName;
 import java.math.BigDecimal;
 import java.net.URI;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
 
 public class SchemaGenerator implements CorbaConstants {
     private static int prefixCount = 1;
@@ -291,36 +326,36 @@
             schemaTypeName = new QName(targetNameSpace, simpleName, targetNamespacePrefix);
 
             if (dataType instanceof EnumType) {
-                XmlSchemaSimpleType simpleType = new XmlSchemaSimpleType(xmlSchema);
+                XmlSchemaSimpleType simpleType = new XmlSchemaSimpleType(xmlSchema, false);
                 XmlSchemaSimpleTypeRestriction restriction = new XmlSchemaSimpleTypeRestriction();
                 restriction.setBaseTypeName(typeTable.getSimpleSchemaTypeName("java.lang.String"));
                 simpleType.setContent(restriction);
                 simpleType.setName(simpleName);
 
-                XmlSchemaObjectCollection facets = restriction.getFacets();
+                List<XmlSchemaFacet> facets = restriction.getFacets();
                 EnumType enumType = (EnumType) dataType;
                 List enumMembers = enumType.getEnumMembers();
                 for (int i = 0; i < enumMembers.size(); i++) {
                     facets.add(new XmlSchemaEnumerationFacet(enumMembers.get(i), false));
                 }
 
-                XmlSchemaElement eltOuter = new XmlSchemaElement();
+                XmlSchemaElement eltOuter = new XmlSchemaElement(xmlSchema, false);
                 eltOuter.setName(simpleName);
-                eltOuter.setQName(schemaTypeName);
+                eltOuter.setSchemaTypeName(schemaTypeName);
 
                 xmlSchema.getItems().add(eltOuter);
-                xmlSchema.getElements().add(schemaTypeName, eltOuter);
+                xmlSchema.getElements().put(schemaTypeName, eltOuter);
                 eltOuter.setSchemaTypeName(simpleType.getQName());
 
                 xmlSchema.getItems().add(simpleType);
-                xmlSchema.getSchemaTypes().add(schemaTypeName, simpleType);
+                xmlSchema.getSchemaTypes().put(schemaTypeName, simpleType);
 
                 // adding this type to the table
                 typeTable.addComplexSchema(name, eltOuter.getQName());
             } else if (dataType instanceof UnionType) {
-                XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema);
+                XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema, false);
                 XmlSchemaChoice choice = new XmlSchemaChoice();
-                XmlSchemaObjectCollection items = choice.getItems();
+                List<XmlSchemaObject> items = choice.getItems();
 
                 UnionType unionType = (UnionType) dataType;
                 Member[] members = unionType.getMembers();
@@ -332,15 +367,15 @@
                 complexType.setParticle(choice);
                 complexType.setName(simpleName);
 
-                XmlSchemaElement eltOuter = new XmlSchemaElement();
+                XmlSchemaElement eltOuter = new XmlSchemaElement(xmlSchema, false);
                 eltOuter.setName(simpleName);
-                eltOuter.setQName(schemaTypeName);
+                eltOuter.setSchemaTypeName(schemaTypeName);
 
                 xmlSchema.getItems().add(eltOuter);
-                xmlSchema.getElements().add(schemaTypeName, eltOuter);
+                xmlSchema.getElements().put(schemaTypeName, eltOuter);
                 eltOuter.setSchemaTypeName(complexType.getQName());
                 xmlSchema.getItems().add(complexType);
-                xmlSchema.getSchemaTypes().add(schemaTypeName, complexType);
+                xmlSchema.getSchemaTypes().put(schemaTypeName, complexType);
 
                 typeTable.addComplexSchema(name, eltOuter.getQName());
             } else {
@@ -348,21 +383,21 @@
                     Typedef typedef = (Typedef) dataType;
                     DataType aliasType = typedef.getDataType();
                     if (aliasType instanceof FixedType) {
-                        XmlSchemaSimpleType simpleType = new XmlSchemaSimpleType(xmlSchema);
-                        XmlSchemaElement eltOuter = new XmlSchemaElement();
+                        XmlSchemaSimpleType simpleType = new XmlSchemaSimpleType(xmlSchema, false);
+                        XmlSchemaElement eltOuter = new XmlSchemaElement(xmlSchema, false);
                         eltOuter.setName(simpleName);
-                        eltOuter.setQName(schemaTypeName);
+                        eltOuter.setSchemaTypeName(schemaTypeName);
                         simpleType.setName(simpleName);
 
                         xmlSchema.getItems().add(eltOuter);
-                        xmlSchema.getElements().add(schemaTypeName, eltOuter);
+                        xmlSchema.getElements().put(schemaTypeName, eltOuter);
                         eltOuter.setSchemaTypeName(simpleType.getQName());
 
                         xmlSchema.getItems().add(simpleType);
-                        xmlSchema.getSchemaTypes().add(schemaTypeName, simpleType);
+                        xmlSchema.getSchemaTypes().put(schemaTypeName, simpleType);
 
                         typeTable.addComplexSchema(name, eltOuter.getQName());
-                        XmlSchemaElement elt1 = new XmlSchemaElement();
+                        XmlSchemaElement elt1 = new XmlSchemaElement(xmlSchema, false);
                         elt1.setName(name);
 
                         XmlSchemaSimpleTypeRestriction restriction = new XmlSchemaSimpleTypeRestriction();
@@ -376,39 +411,39 @@
 
                         simpleType.setContent(restriction);
                     } else {
-                        XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema);
+                        XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema, false);
                         XmlSchemaSequence sequence = new XmlSchemaSequence();
-                        XmlSchemaElement eltOuter = new XmlSchemaElement();
+                        XmlSchemaElement eltOuter = new XmlSchemaElement(xmlSchema, false);
                         eltOuter.setName(simpleName);
-                        eltOuter.setQName(schemaTypeName);
+                        eltOuter.setSchemaTypeName(schemaTypeName);
                         complexType.setParticle(sequence);
                         complexType.setName(simpleName);
 
                         xmlSchema.getItems().add(eltOuter);
-                        xmlSchema.getElements().add(schemaTypeName, eltOuter);
+                        xmlSchema.getElements().put(schemaTypeName, eltOuter);
                         eltOuter.setSchemaTypeName(complexType.getQName());
 
                         xmlSchema.getItems().add(complexType);
-                        xmlSchema.getSchemaTypes().add(schemaTypeName, complexType);
+                        xmlSchema.getSchemaTypes().put(schemaTypeName, complexType);
 
                         typeTable.addComplexSchema(name, eltOuter.getQName());
                         sequence.getItems().add(generateSchemaforFieldsandProperties(xmlSchema, aliasType, "item", false));
                     }
                 } else {
-                    XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema);
+                    XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema, false);
                     XmlSchemaSequence sequence = new XmlSchemaSequence();
-                    XmlSchemaElement eltOuter = new XmlSchemaElement();
+                    XmlSchemaElement eltOuter = new XmlSchemaElement(xmlSchema, false);
                     eltOuter.setName(simpleName);
-                    eltOuter.setQName(schemaTypeName);
+                    eltOuter.setSchemaTypeName(schemaTypeName);
                     complexType.setParticle(sequence);
                     complexType.setName(simpleName);
 
                     xmlSchema.getItems().add(eltOuter);
-                    xmlSchema.getElements().add(schemaTypeName, eltOuter);
+                    xmlSchema.getElements().put(schemaTypeName, eltOuter);
                     eltOuter.setSchemaTypeName(complexType.getQName());
 
                     xmlSchema.getItems().add(complexType);
-                    xmlSchema.getSchemaTypes().add(schemaTypeName, complexType);
+                    xmlSchema.getSchemaTypes().put(schemaTypeName, complexType);
 
                     typeTable.addComplexSchema(name, eltOuter.getQName());
 
@@ -445,29 +480,29 @@
             String targetNamespacePrefix = (String) targetNamespacePrefixMap.get(targetNameSpace);
             schemaTypeName = new QName(targetNameSpace, CorbaConstants.TYPECODE_TYPE_NAME, targetNamespacePrefix);
 
-            XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema);
+            XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema, false);
             XmlSchemaSequence sequence = new XmlSchemaSequence();
-            XmlSchemaElement eltOuter = new XmlSchemaElement();
+            XmlSchemaElement eltOuter = new XmlSchemaElement(xmlSchema, false);
             eltOuter.setName(CorbaConstants.TYPECODE_TYPE_NAME);
-            eltOuter.setQName(schemaTypeName);
+            eltOuter.setSchemaTypeName(schemaTypeName);
             complexType.setParticle(sequence);
             complexType.setName(CorbaConstants.TYPECODE_TYPE_NAME);
 
             xmlSchema.getItems().add(eltOuter);
-            xmlSchema.getElements().add(schemaTypeName, eltOuter);
+            xmlSchema.getElements().put(schemaTypeName, eltOuter);
             eltOuter.setSchemaTypeName(complexType.getQName());
 
             xmlSchema.getItems().add(complexType);
-            xmlSchema.getSchemaTypes().add(schemaTypeName, complexType);
+            xmlSchema.getSchemaTypes().put(schemaTypeName, complexType);
 
             typeTable.addComplexSchema(CorbaConstants.TYPECODE_TYPE_NAME, eltOuter.getQName());
 
-            XmlSchemaElement typeElement = new XmlSchemaElement();
+            XmlSchemaElement typeElement = new XmlSchemaElement(xmlSchema, false);
             typeElement.setName("definition");
             typeElement.setSchemaTypeName(typeTable.getSimpleSchemaTypeName(URI.class.getName()));
             sequence.getItems().add(typeElement);
 
-            XmlSchemaElement valueElement = new XmlSchemaElement();
+            XmlSchemaElement valueElement = new XmlSchemaElement(xmlSchema, false);
             valueElement.setName("typename");
             valueElement.setSchemaTypeName(typeTable.getSimpleSchemaTypeName(String.class.getName()));
             sequence.getItems().add(valueElement);
@@ -482,29 +517,29 @@
             String targetNamespacePrefix = (String) targetNamespacePrefixMap.get(targetNameSpace);
             schemaTypeName = new QName(targetNameSpace, CorbaConstants.ANY_TYPE_NAME, targetNamespacePrefix);
 
-            XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema);
+            XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema, false);
             XmlSchemaSequence sequence = new XmlSchemaSequence();
-            XmlSchemaElement eltOuter = new XmlSchemaElement();
+            XmlSchemaElement eltOuter = new XmlSchemaElement(xmlSchema, false);
             eltOuter.setName(CorbaConstants.ANY_TYPE_NAME);
-            eltOuter.setQName(schemaTypeName);
+            eltOuter.setSchemaTypeName(schemaTypeName);
             complexType.setParticle(sequence);
             complexType.setName(CorbaConstants.ANY_TYPE_NAME);
 
             xmlSchema.getItems().add(eltOuter);
-            xmlSchema.getElements().add(schemaTypeName, eltOuter);
+            xmlSchema.getElements().put(schemaTypeName, eltOuter);
             eltOuter.setSchemaTypeName(complexType.getQName());
 
             xmlSchema.getItems().add(complexType);
-            xmlSchema.getSchemaTypes().add(schemaTypeName, complexType);
+            xmlSchema.getSchemaTypes().put(schemaTypeName, complexType);
 
             typeTable.addComplexSchema(CorbaConstants.ANY_TYPE_NAME, eltOuter.getQName());
 
-            XmlSchemaElement typeElement = new XmlSchemaElement();
+            XmlSchemaElement typeElement = new XmlSchemaElement(xmlSchema, false);
             typeElement.setName("type");
             typeElement.setSchemaTypeName(typeTable.getComplexSchemaType(CorbaConstants.TYPECODE_TYPE_NAME));
             sequence.getItems().add(typeElement);
 
-            XmlSchemaElement valueElement = new XmlSchemaElement();
+            XmlSchemaElement valueElement = new XmlSchemaElement(xmlSchema, false);
             valueElement.setName("value");
             valueElement.setSchemaTypeName(typeTable.getSimpleSchemaTypeName(Object.class.getName()));
             sequence.getItems().add(valueElement);
@@ -546,7 +581,7 @@
             propertyTypeName = "base64Binary";
         }
 
-        XmlSchemaElement elt1 = new XmlSchemaElement();
+        XmlSchemaElement elt1 = new XmlSchemaElement(xmlSchema, false);
         elt1.setName(name);
 
         if (isArryType && (!propertyTypeName.equals("base64Binary"))){
@@ -566,7 +601,7 @@
 
             if (!((NamespaceMap) xmlSchema.getNamespaceContext()).values().
                     contains(typeTable.getComplexSchemaType(propertyTypeName).getNamespaceURI())) {
-                XmlSchemaImport importElement = new XmlSchemaImport();
+                XmlSchemaImport importElement = new XmlSchemaImport(xmlSchema);
                 importElement.setNamespace(
                         typeTable.getComplexSchemaType(propertyTypeName).getNamespaceURI());
                 xmlSchema.getItems().add(importElement);
@@ -647,7 +682,7 @@
                                               QName schemaTypeName,
                                               String paraName,
                                               boolean isArray) {
-        XmlSchemaElement elt1 = new XmlSchemaElement();
+        XmlSchemaElement elt1 = new XmlSchemaElement(getXmlSchema(schemaTargetNameSpace), false);
         elt1.setName(paraName);
         elt1.setSchemaTypeName(schemaTypeName);
         sequence.getItems().add(elt1);
@@ -663,14 +698,14 @@
         XmlSchema xmlSchema = getXmlSchema(schemaTargetNameSpace);
         QName elementName =
                 new QName(this.schemaTargetNameSpace, localPartName, this.schema_namespace_prefix);
-        XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema);
+        XmlSchemaComplexType complexType = new XmlSchemaComplexType(xmlSchema, false);
 
-        XmlSchemaElement globalElement = new XmlSchemaElement();
+        XmlSchemaElement globalElement = new XmlSchemaElement(xmlSchema, false);
         globalElement.setSchemaType(complexType);
         globalElement.setName(localPartName);
-        globalElement.setQName(elementName);
+//        globalElement.setQName(elementName);
         xmlSchema.getItems().add(globalElement);
-        xmlSchema.getElements().add(elementName, globalElement);
+        xmlSchema.getElements().put(elementName, globalElement);
 
         typeTable.addComplexSchema(localPartName, elementName);
 
@@ -727,7 +762,7 @@
     private void addImport(XmlSchema xmlSchema, QName schemaTypeName) {
         if (!((NamespaceMap) xmlSchema.getNamespaceContext()).values().
                 contains(schemaTypeName.getNamespaceURI())) {
-            XmlSchemaImport importElement = new XmlSchemaImport();
+            XmlSchemaImport importElement = new XmlSchemaImport(xmlSchema);
             importElement.setNamespace(schemaTypeName.getNamespaceURI());
             xmlSchema.getItems().add(importElement);
             ((NamespaceMap) xmlSchema.getNamespaceContext()).
@@ -753,17 +788,17 @@
 
     private XmlSchemaForm getAttrFormDefaultSetting() {
         if (FORM_DEFAULT_UNQUALIFIED.equals(getAttrFormDefault())) {
-            return new XmlSchemaForm(XmlSchemaForm.UNQUALIFIED);
+            return XmlSchemaForm.schemaValueOf(FORM_DEFAULT_UNQUALIFIED);
         } else {
-            return new XmlSchemaForm(XmlSchemaForm.QUALIFIED);
+            return XmlSchemaForm.schemaValueOf(FORM_DEFAULT_QUALIFIED);
         }
     }
 
     private XmlSchemaForm getElementFormDefaultSetting() {
         if (FORM_DEFAULT_UNQUALIFIED.equals(getElementFormDefault())) {
-            return new XmlSchemaForm(XmlSchemaForm.UNQUALIFIED);
+            return XmlSchemaForm.schemaValueOf(FORM_DEFAULT_UNQUALIFIED);
         } else {
-            return new XmlSchemaForm(XmlSchemaForm.QUALIFIED);
+            return XmlSchemaForm.schemaValueOf(FORM_DEFAULT_QUALIFIED);
         }
     }
 
Index: modules/adb-codegen/test/org/apache/axis2/schema/XMLSchemaTest.java
===================================================================
--- modules/adb-codegen/test/org/apache/axis2/schema/XMLSchemaTest.java	(revision 1467549)
+++ modules/adb-codegen/test/org/apache/axis2/schema/XMLSchemaTest.java	(working copy)
@@ -19,6 +19,13 @@
 
 package org.apache.axis2.schema;
 
+import junit.framework.TestCase;
+import org.apache.axis2.util.XMLPrettyPrinter;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.custommonkey.xmlunit.Diff;
+
+import javax.xml.transform.stream.StreamSource;
 import java.io.BufferedReader;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -26,18 +33,10 @@
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.List;
 
-import javax.xml.transform.stream.StreamSource;
-
-import junit.framework.TestCase;
-
-import org.apache.axis2.util.XMLPrettyPrinter;
-import org.apache.ws.commons.schema.XmlSchema;
-import org.apache.ws.commons.schema.XmlSchemaCollection;
-import org.custommonkey.xmlunit.Diff;
-
 public abstract class XMLSchemaTest extends TestCase {
 
     public final String XMLSchemaNameSpace = "xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"";
@@ -85,7 +84,7 @@
                 if (excludeList == null || !excludeList.contains(i)) {
                     InputStream is = new FileInputStream(file);
                     XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-                    XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+                    XmlSchema schema = schemaCol.read(new StreamSource(is));
                     schemas.add(schema);
                 }
             } else {
@@ -98,7 +97,7 @@
         File file = new File(SampleSchemasDirectory + "sampleSchema" + id + ".xsd");
         InputStream is = new FileInputStream(file);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         return schema;
     }
     
@@ -107,7 +106,7 @@
                 + ".xsd");
         InputStream is = new FileInputStream(file);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         return schema;
     }
      
@@ -129,7 +128,7 @@
     public String readXMLfromSchemaFile(String path) throws Exception {
         InputStream is = new FileInputStream(path);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         ByteArrayOutputStream stream = new ByteArrayOutputStream();
         schema.write(stream);
         is.close();
@@ -150,7 +149,7 @@
         fileWriter.close();        
     }
     
-    public String schemaToString(XmlSchema schema){
+    public String schemaToString(XmlSchema schema) throws UnsupportedEncodingException {
         ByteArrayOutputStream stream=new ByteArrayOutputStream();
         schema.write(stream);
         return stream.toString();
@@ -160,7 +159,7 @@
         File file = new File(path);
         InputStream is = new FileInputStream(file);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         return schema;
     }
     
Index: modules/adb-codegen/test/org/apache/axis2/schema/extension/SimpleExtensionTest.java
===================================================================
--- modules/adb-codegen/test/org/apache/axis2/schema/extension/SimpleExtensionTest.java	(revision 1467549)
+++ modules/adb-codegen/test/org/apache/axis2/schema/extension/SimpleExtensionTest.java	(working copy)
@@ -58,7 +58,8 @@
         OMFactory factory = OMAbstractFactory.getOMFactory();
         OMElement element = factory.createOMElement(new QName(
                 "http://apache.org/axis2/schema/extension", "SimpleAmmountElement"));
-        element.addAttribute("currency", "SLR", null);
+        element.addAttribute("currency", "SLR",
+                             factory.createOMNamespace("http://apache.org/axis2/schema/extension", null));
         element.setText("1000");
         SimpleAmmountElement ammountElement = SimpleAmmountElement.Factory.parse(element
                 .getXMLStreamReader());
@@ -81,7 +82,8 @@
         OMFactory factory = OMAbstractFactory.getOMFactory();
         OMElement element = factory.createOMElement(new QName(
                 "http://apache.org/axis2/schema/extension", "PaymentAmountElement"));
-        element.addAttribute("currency", "SLR", null);
+        element.addAttribute("currency", "SLR",
+                             factory.createOMNamespace("http://apache.org/axis2/schema/extension", null));
         element.setText("2000");
         PaymentAmountElement ammountElement = PaymentAmountElement.Factory.parse(element
                 .getXMLStreamReader());
@@ -154,7 +156,8 @@
         OMFactory factory = OMAbstractFactory.getOMFactory();
         OMElement element = factory.createOMElement(new QName(
                 "http://apache.org/axis2/schema/extension", "ReproStringTypeElement"));
-        element.addAttribute("lang", "EN", null);
+        element.addAttribute("lang", "EN",
+                             factory.createOMNamespace("http://apache.org/axis2/schema/extension", null));
         element.setText("Value");
        
         ReproStringTypeElement reproStringTypeElement = ReproStringTypeElement.Factory.parse(element
Index: modules/adb-codegen/src/org/apache/axis2/schema/ExtensionUtility.java
===================================================================
--- modules/adb-codegen/src/org/apache/axis2/schema/ExtensionUtility.java	(revision 1467549)
+++ modules/adb-codegen/src/org/apache/axis2/schema/ExtensionUtility.java	(working copy)
@@ -46,9 +46,9 @@
 import org.apache.ws.commons.schema.XmlSchemaImport;
 import org.apache.ws.commons.schema.XmlSchemaInclude;
 import org.apache.ws.commons.schema.XmlSchemaObject;
-import org.apache.ws.commons.schema.XmlSchemaObjectCollection;
 import org.apache.ws.commons.schema.XmlSchemaParticle;
 import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaSequenceMember;
 import org.apache.ws.commons.schema.XmlSchemaSimpleType;
 import org.apache.ws.commons.schema.XmlSchemaType;
 
@@ -356,10 +356,8 @@
                                    String opName,
                                    String qnameSuffix,
                                    TypeMapper typeMap) {
-        XmlSchemaObjectCollection xmlObjectCollection = complexType.getAttributes();
-        XmlSchemaObject item;
-        for (Iterator iter = xmlObjectCollection.getIterator(); iter.hasNext();) {
-            item = (XmlSchemaObject) iter.next();
+
+        for (XmlSchemaObject item : complexType.getAttributes()) {
             XmlSchemaAttribute xmlSchemaAttribute;
             if (item instanceof XmlSchemaAttribute) {
                 xmlSchemaAttribute = (XmlSchemaAttribute) item;
@@ -380,25 +378,21 @@
         if (schema != null) {
             xmlSchemaType = schema.getTypeByName(typeName);
             if (xmlSchemaType == null) {
-                // try to find in an import or an include
-                XmlSchemaObjectCollection includes = schema.getIncludes();
-                if (includes != null) {
-                    Iterator includesIter = includes.getIterator();
-                    Object object = null;
-                    while (includesIter.hasNext()) {
-                        object = includesIter.next();
-                        if (object instanceof XmlSchemaImport) {
-                            XmlSchema schema1 = ((XmlSchemaImport) object).getSchema();
-                            xmlSchemaType = getSchemaType(schema1,typeName);
-                        }
-                        if (object instanceof XmlSchemaInclude) {
-                            XmlSchema schema1 = ((XmlSchemaInclude) object).getSchema();
-                            xmlSchemaType = getSchemaType(schema1,typeName);
-                        }
-                        if (xmlSchemaType != null){
-                            break;
-                        }
+                // try to find in an import or an include) {
+
+                for (XmlSchemaObject object : schema.getExternals()) {
+
+                    if (object instanceof XmlSchemaImport) {
+                        XmlSchema schema1 = ((XmlSchemaImport) object).getSchema();
+                        xmlSchemaType = getSchemaType(schema1, typeName);
                     }
+                    if (object instanceof XmlSchemaInclude) {
+                        XmlSchema schema1 = ((XmlSchemaInclude) object).getSchema();
+                        xmlSchemaType = getSchemaType(schema1, typeName);
+                    }
+                    if (xmlSchemaType != null) {
+                        break;
+                    }
                 }
             }
         }
@@ -440,9 +434,8 @@
                                               Map<String,XmlSchema> schemaMap,
                                               String qnameSuffix) {
         if (particle instanceof XmlSchemaSequence) {
-            XmlSchemaObjectCollection items = ((XmlSchemaSequence) particle).getItems();
-            for (Iterator i = items.getIterator(); i.hasNext();) {
-                Object item = i.next();
+          List<XmlSchemaSequenceMember> items = ((XmlSchemaSequence) particle).getItems();
+            for (XmlSchemaSequenceMember item : items) {
                 // get each and every element in the sequence and
                 // traverse through them
                 if (item instanceof XmlSchemaElement) {
@@ -453,8 +446,8 @@
 
                     XmlSchemaType schemaType = xmlSchemaElement.getSchemaType();
                     String partName = null;
-                    if (xmlSchemaElement.getRefName() != null) {
-                        partName = xmlSchemaElement.getRefName().getLocalPart();
+                    if (xmlSchemaElement.getRef().getTargetQName() != null) {
+                        partName = xmlSchemaElement.getRef().getTargetQName().getLocalPart();
                     } else {
                         partName = xmlSchemaElement.getName();
                     }
Index: modules/adb-codegen/src/org/apache/axis2/schema/SchemaCompiler.java
===================================================================
--- modules/adb-codegen/src/org/apache/axis2/schema/SchemaCompiler.java	(revision 1467549)
+++ modules/adb-codegen/src/org/apache/axis2/schema/SchemaCompiler.java	(working copy)
@@ -35,7 +35,9 @@
 import org.apache.ws.commons.schema.XmlSchemaAnyAttribute;
 import org.apache.ws.commons.schema.XmlSchemaAttribute;
 import org.apache.ws.commons.schema.XmlSchemaAttributeGroup;
+import org.apache.ws.commons.schema.XmlSchemaAttributeGroupMember;
 import org.apache.ws.commons.schema.XmlSchemaAttributeGroupRef;
+import org.apache.ws.commons.schema.XmlSchemaAttributeOrGroupRef;
 import org.apache.ws.commons.schema.XmlSchemaChoice;
 import org.apache.ws.commons.schema.XmlSchemaCollection;
 import org.apache.ws.commons.schema.XmlSchemaComplexContent;
@@ -47,8 +49,9 @@
 import org.apache.ws.commons.schema.XmlSchemaElement;
 import org.apache.ws.commons.schema.XmlSchemaEnumerationFacet;
 import org.apache.ws.commons.schema.XmlSchemaExternal;
+import org.apache.ws.commons.schema.XmlSchemaFacet;
 import org.apache.ws.commons.schema.XmlSchemaGroup;
-import org.apache.ws.commons.schema.XmlSchemaGroupBase;
+import org.apache.ws.commons.schema.XmlSchemaGroupParticle;
 import org.apache.ws.commons.schema.XmlSchemaGroupRef;
 import org.apache.ws.commons.schema.XmlSchemaImport;
 import org.apache.ws.commons.schema.XmlSchemaInclude;
@@ -60,11 +63,10 @@
 import org.apache.ws.commons.schema.XmlSchemaMinInclusiveFacet;
 import org.apache.ws.commons.schema.XmlSchemaMinLengthFacet;
 import org.apache.ws.commons.schema.XmlSchemaObject;
-import org.apache.ws.commons.schema.XmlSchemaObjectCollection;
-import org.apache.ws.commons.schema.XmlSchemaObjectTable;
 import org.apache.ws.commons.schema.XmlSchemaParticle;
 import org.apache.ws.commons.schema.XmlSchemaPatternFacet;
 import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaSequenceMember;
 import org.apache.ws.commons.schema.XmlSchemaSimpleContent;
 import org.apache.ws.commons.schema.XmlSchemaSimpleContentExtension;
 import org.apache.ws.commons.schema.XmlSchemaSimpleContentRestriction;
@@ -81,7 +83,6 @@
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -102,21 +103,21 @@
     private static final Log log = LogFactory.getLog(SchemaCompiler.class);
 
     private CompilerOptions options;
-    private HashMap<QName,String> processedTypemap;
+    private HashMap<QName, String> processedTypemap;
     // have to keep a seperate group type map since same
     // name can be used to group and complextype
-    private HashMap<QName,String> processedGroupTypeMap;
+    private HashMap<QName, String> processedGroupTypeMap;
 
     //the list of processedElements for the outer elements
-    private HashMap<QName,String> processedElementMap;
+    private HashMap<QName, String> processedElementMap;
 
-    private HashMap<XmlSchemaElement,BeanWriterMetaInfoHolder> processedAnonymousComplexTypesMap;
+    private HashMap<XmlSchemaElement, BeanWriterMetaInfoHolder> processedAnonymousComplexTypesMap;
 
     //we need this map to keep the referenced elements. these elements need to be kept seperate
     //to avoid conflicts
-    private HashMap<QName,String> processedElementRefMap;
-    private HashMap<QName,String> simpleTypesMap;
-    private HashMap<QName,QName> changedTypeMap;
+    private HashMap<QName, String> processedElementRefMap;
+    private HashMap<QName, String> simpleTypesMap;
+    private HashMap<QName, QName> changedTypeMap;
 
     private HashSet<XmlSchemaSimpleType> changedSimpleTypeSet;
     private HashSet<XmlSchemaComplexType> changedComplexTypeSet;
@@ -125,7 +126,7 @@
     // this map is necessary to retain the metainformation of types. The reason why these
     // meta info 'bags' would be useful later is to cater for the extensions and restrictions
     // of types
-    private HashMap<QName,BeanWriterMetaInfoHolder> processedTypeMetaInfoMap;
+    private HashMap<QName, BeanWriterMetaInfoHolder> processedTypeMetaInfoMap;
 
     //
     private ArrayList<QName> processedElementList;
@@ -135,19 +136,19 @@
     private List<QName> nillableElementList;
     // writee reference
     private BeanWriter writer = null;
-    private Map<QName,String> baseSchemaTypeMap = null;
+    private Map<QName, String> baseSchemaTypeMap = null;
 
     //a map for keeping the already loaded schemas
     //the key is the targetnamespace and the value is the schema object
-    private Map<String,XmlSchema> loadedSchemaMap = new HashMap<String,XmlSchema>();
+    private Map<String, XmlSchema> loadedSchemaMap = new HashMap<String, XmlSchema>();
 
     // A map keeping the available schemas
     //the key is the targetnamespace and the value is the schema object
     //this map will be populated when multiple schemas
     //are fed to the schema compiler!
-    private Map<String,XmlSchema> availableSchemaMap = new HashMap<String,XmlSchema>();
+    private Map<String, XmlSchema> availableSchemaMap = new HashMap<String, XmlSchema>();
 
-    private Map<String,String> loadedSourceURI = new HashMap<String,String>();
+    private Map<String, String> loadedSourceURI = new HashMap<String, String>();
 
     // a list of externally identified QNames to be processed. This becomes
     // useful when  only a list of external elements need to be processed
@@ -164,7 +165,7 @@
      *         includes the Qname of the element as the key and a
      *         String representing the fully qualified class name
      */
-    public HashMap<QName,String> getProcessedElementMap() {
+    public HashMap<QName, String> getProcessedElementMap() {
         return processedElementMap;
     }
 
@@ -194,26 +195,26 @@
 
         Map<String, String> nsp2PackageMap = this.options.getNs2PackageMap();
 
-        if (nsp2PackageMap == null){
+        if (nsp2PackageMap == null) {
             nsp2PackageMap = new HashMap();
             this.options.setNs2PackageMap(nsp2PackageMap);
         }
 
-        if (!nsp2PackageMap.containsKey("")){
-            nsp2PackageMap.put("","axis2.apache.org");
+        if (!nsp2PackageMap.containsKey("")) {
+            nsp2PackageMap.put("", "axis2.apache.org");
         }
 
         //instantiate the maps
-        processedTypemap = new HashMap<QName,String>();
-        processedGroupTypeMap = new HashMap<QName,String>();
+        processedTypemap = new HashMap<QName, String>();
+        processedGroupTypeMap = new HashMap<QName, String>();
 
-        processedElementMap = new HashMap<QName,String>();
-        simpleTypesMap = new HashMap<QName,String>();
+        processedElementMap = new HashMap<QName, String>();
+        simpleTypesMap = new HashMap<QName, String>();
         processedElementList = new ArrayList<QName>();
-        processedAnonymousComplexTypesMap = new HashMap<XmlSchemaElement,BeanWriterMetaInfoHolder>();
-        changedTypeMap = new HashMap<QName,QName>();
-        processedTypeMetaInfoMap = new HashMap<QName,BeanWriterMetaInfoHolder>();
-        processedElementRefMap = new HashMap<QName,String>();
+        processedAnonymousComplexTypesMap = new HashMap<XmlSchemaElement, BeanWriterMetaInfoHolder>();
+        changedTypeMap = new HashMap<QName, QName>();
+        processedTypeMetaInfoMap = new HashMap<QName, BeanWriterMetaInfoHolder>();
+        processedElementRefMap = new HashMap<QName, String>();
         nillableElementList = new ArrayList<QName>();
 
         changedComplexTypeSet = new HashSet<XmlSchemaComplexType>();
@@ -265,14 +266,15 @@
                 //mapper namespace
                 for (XmlSchema schema : schemalist) {
                     nsp = schema.getTargetNamespace();
-                    if ((nsp != null) && !nsp.equals("")){
+                    if ((nsp != null) && !nsp.equals("")) {
                         break;
                     }
                     XmlSchema[] schemas = SchemaUtil.getAllSchemas(schema);
                     for (int j = 0; schemas != null && j < schemas.length; j++) {
                         nsp = schemas[j].getTargetNamespace();
-                        if (nsp != null)
+                        if (nsp != null) {
                             break;
+                        }
                     }
                 }
                 if (nsp == null) {
@@ -281,10 +283,11 @@
 
                 // if this name space exists in the ns2p list then we use it.
                 if ((options.getNs2PackageMap() != null)
-                        && (options.getNs2PackageMap().containsKey(nsp))) {
+                    && (options.getNs2PackageMap().containsKey(nsp))) {
                     writer.registerExtensionMapperPackageName(options.getNs2PackageMap().get(nsp));
                 } else {
-                    writer.registerExtensionMapperPackageName(nsp == null ? null : URLProcessor.makePackageName(nsp));
+                    writer.registerExtensionMapperPackageName(nsp == null ? null :
+                                                              URLProcessor.makePackageName(nsp));
                 }
             }
             // second round - call the schema compiler one by one
@@ -319,7 +322,8 @@
      * @param isPartofGroup
      * @throws SchemaCompilationException
      */
-    private void compile(XmlSchema schema, boolean isPartofGroup) throws SchemaCompilationException {
+    private void compile(XmlSchema schema, boolean isPartofGroup)
+            throws SchemaCompilationException {
 
         // some documents explicitly imports the schema of built in types. We don't actually need to compile
         // the built-in types. So check the target namespace here and ignore it.
@@ -337,7 +341,7 @@
                 }
                 // if this name space exists in the ns2p list then we use it.
                 if ((options.getNs2PackageMap() != null)
-                        && (options.getNs2PackageMap().containsKey(ns))) {
+                    && (options.getNs2PackageMap().containsKey(ns))) {
                     writer.registerExtensionMapperPackageName(options.getNs2PackageMap().get(ns));
                 } else {
                     writer.registerExtensionMapperPackageName(URLProcessor.makePackageName(ns));
@@ -355,7 +359,7 @@
             // but when importing import namesapce location is given as "".
             // this causese a problem in finding reference elements. see AXIS2-3029
             // kept the null entry as well to safe gaurd any thing which acess using null
-            if (schema.getTargetNamespace() == null){
+            if (schema.getTargetNamespace() == null) {
                 loadedSchemaMap.put("", schema);
             }
         }
@@ -370,74 +374,66 @@
             loadedSourceURI.put(key, key);
         }
 
-        XmlSchemaObjectCollection includes = schema.getIncludes();
-        if (includes != null) {
-            Iterator tempIterator = includes.getIterator();
-            while (tempIterator.hasNext()) {
-                Object o = tempIterator.next();
-                if (o instanceof XmlSchemaImport) {
-                    XmlSchemaImport schemaImport = (XmlSchemaImport)o;
-                    XmlSchema schema1 = schemaImport.getSchema();
-                    if (schema1 != null) {
-                        compile(schema1, isPartofGroup);
-                    } else if (schemaImport.getNamespace().equals(Constants.NS_URI_XML)) {
-                        // AXIS2-3229: some Web services (e.g. MS Exchange) assume that
-                        // http://www.w3.org/XML/1998/namespace is a known namespace and that
-                        // no schemaLocation is required when importing it. Load a local copy of
-                        // the schema in that case.
-                        schema1 = new XmlSchemaCollection().read(new InputSource(
-                                SchemaCompiler.class.getResource("namespace.xsd").toExternalForm()), null);
-                        schemaImport.setSchema(schema1);
-                        compile(schema1, isPartofGroup);
-                    } else if (!schemaImport.getNamespace().equals(Constants.URI_2001_SCHEMA_XSD)) {
-                        // Give the user a hint why the schema compilation fails...
-                        log.warn("No schemaLocation for import of " + schemaImport.getNamespace() + "; compilation may fail");
+        for (XmlSchemaObject object : schema.getExternals()) {
+
+            if (object instanceof XmlSchemaImport) {
+                XmlSchemaImport schemaImport = (XmlSchemaImport) object;
+                XmlSchema schema1 = schemaImport.getSchema();
+                if (schema1 != null) {
+                    compile(schema1, isPartofGroup);
+                } else if (schemaImport.getNamespace().equals(Constants.NS_URI_XML)) {
+                    // AXIS2-3229: some Web services (e.g. MS Exchange) assume that
+                    // http://www.w3.org/XML/1998/namespace is a known namespace and that
+                    // no schemaLocation is required when importing it. Load a local copy of
+                    // the schema in that case.
+                    schema1 = new XmlSchemaCollection().read(new InputSource(
+                            SchemaCompiler.class.getResource("namespace.xsd").toExternalForm()));
+                    schemaImport.setSchema(schema1);
+                    compile(schema1, isPartofGroup);
+                } else if (!schemaImport.getNamespace().equals(Constants.URI_2001_SCHEMA_XSD)) {
+                    // Give the user a hint why the schema compilation fails...
+                    log.warn("No schemaLocation for import of " + schemaImport.getNamespace() +
+                             "; compilation may fail");
+                }
+            }
+            if (object instanceof XmlSchemaInclude) {
+                XmlSchema schema1 = ((XmlSchemaInclude) object).getSchema();
+                if (schema1 != null) {
+                    if (schema1.getTargetNamespace() == null) {
+                        // the target namespace of an included shchema should be same
+                        // as the parent schema however if the schema uses the chemalon pattern
+                        // target namespace can be null. so set it here.
+                        // http://www.xfront.com/ZeroOneOrManyNamespaces.html#mixed
+                        schema1.setTargetNamespace(schema.getTargetNamespace());
                     }
+                    compile(schema1, isPartofGroup);
                 }
-                if (o instanceof XmlSchemaInclude) {
-                    XmlSchema schema1 = ((XmlSchemaInclude) o).getSchema();
-                    if (schema1 != null){
-                        if (schema1.getTargetNamespace() == null){
-                            // the target namespace of an included shchema should be same
-                            // as the parent schema however if the schema uses the chemalon pattern
-                            // target namespace can be null. so set it here.
-                            // http://www.xfront.com/ZeroOneOrManyNamespaces.html#mixed
-                            schema1.setTargetNamespace(schema.getTargetNamespace());
-                        }
-                        compile(schema1, isPartofGroup);
-                    }
 
-                }
             }
+
         }
 
         //select all the elements. We generate the code for types
         //only if the elements refer them!!! regardless of the fact that
         //we have a list of elementnames, we'll need to process all the elements
-        XmlSchemaObjectTable elements = schema.getElements();
-        Iterator xmlSchemaElement1Iterator = elements.getValues();
-        while (xmlSchemaElement1Iterator.hasNext()) {
+        for (XmlSchemaElement element : schema.getElements().values()) {
             //this is the set of outer elements so we need to generate classes
             //The outermost elements do not contain occurence counts (!) so we do not need
             //to check for arraytypes
-            processElement((XmlSchemaElement) xmlSchemaElement1Iterator.next(), schema);
+            processElement(element, schema);
         }
 
-        Iterator xmlSchemaElement2Iterator = elements.getValues();
-
         // re-iterate through the elements and write them one by one
         // if the mode is unpack this process will not really write the
         // classes but will accumilate the models for a final single shot
         // write
-        while (xmlSchemaElement2Iterator.hasNext()) {
+        for (XmlSchemaElement element : schema.getElements().values()) {
             //this is the set of outer elements so we need to generate classes
-            writeElement((XmlSchemaElement) xmlSchemaElement2Iterator.next());
+            writeElement(element);
         }
 
         if (options.isGenerateAll()) {
-            Iterator xmlSchemaTypes2Iterator = schema.getSchemaTypes().getValues();
-            while (xmlSchemaTypes2Iterator.hasNext()) {
-                XmlSchemaType schemaType = (XmlSchemaType) xmlSchemaTypes2Iterator.next();
+            for (XmlSchemaType schemaType : schema.getSchemaTypes().values()) {
                 if (this.isAlreadyProcessed(schemaType.getQName())) {
                     continue;
                 }
@@ -450,8 +446,8 @@
                 } else if (schemaType instanceof XmlSchemaSimpleType) {
                     //process simple type
                     processSimpleSchemaType((XmlSchemaSimpleType) schemaType,
-                            null,
-                            schema, null);
+                                            null,
+                                            schema, null);
                 }
             }
         }
@@ -471,8 +467,8 @@
     private void finalizeSchemaCompilation() throws SchemaCompilationException {
         //write the extension mapping class
         writer.writeExtensionMapper(
-                    processedTypeMetaInfoMap.values().toArray(
-                            new BeanWriterMetaInfoHolder[processedTypeMetaInfoMap.size()]));
+                processedTypeMetaInfoMap.values().toArray(
+                        new BeanWriterMetaInfoHolder[processedTypeMetaInfoMap.size()]));
 
 
         if (options.isWrapClasses()) {
@@ -534,31 +530,31 @@
             //this means the schema type actually returns a different QName
             if (changedTypeMap.containsKey(qName)) {
                 metainf.registerMapping(xsElt.getQName(),
-                        changedTypeMap.get(qName),
-                        className);
+                                        changedTypeMap.get(qName),
+                                        className);
             } else {
                 metainf.registerMapping(xsElt.getQName(),
-                        qName,
-                        className);
+                                        qName,
+                                        className);
             }
 
             // register the default value if present
-            if (xsElt.getDefaultValue() != null){
-                metainf.registerDefaultValue(xsElt.getQName(),xsElt.getDefaultValue());
+            if (xsElt.getDefaultValue() != null) {
+                metainf.registerDefaultValue(xsElt.getQName(), xsElt.getDefaultValue());
             }
 
             // register the fixed value if present
-            if (xsElt.getFixedValue() != null){
-                metainf.registerDefaultValue(xsElt.getQName(),xsElt.getFixedValue());
+            if (xsElt.getFixedValue() != null) {
+                metainf.registerDefaultValue(xsElt.getQName(), xsElt.getFixedValue());
                 metainf.setFixed(true);
             }
-            
+
             if (isBinary(xsElt)) {
                 metainf.addtStatus(xsElt.getQName(),
-                            SchemaConstants.BINARY_TYPE);
+                                   SchemaConstants.BINARY_TYPE);
             }
 
-        } else if (xsElt.getRefName() != null) {
+        } else if (xsElt.getRef().getTargetQName() != null) {
             // Since top level elements would not have references
             // and we only write toplevel elements, this should
             // not be a problem , atleast should not occur in a legal schema
@@ -566,8 +562,8 @@
             QName qName = xsElt.getSchemaTypeName();
             String className = findClassName(qName, isArray(xsElt));
             metainf.registerMapping(xsElt.getQName(),
-                    qName,
-                    className);
+                                    qName,
+                                    className);
 
 
         } else if (schemaType != null) {  //the named type should have been handled already
@@ -582,9 +578,9 @@
             //this means we did not find any schema type associated with the particular element.
             log.warn(SchemaCompilerMessages.getMessage("schema.elementWithNoType", xsElt.getQName().toString()));
             metainf.registerMapping(xsElt.getQName(),
-                    null,
-                    writer.getDefaultClassName(),
-                    SchemaConstants.ANY_TYPE);
+                                    null,
+                                    writer.getDefaultClassName(),
+                                    SchemaConstants.ANY_TYPE);
         }
 
         if (nillableElementList.contains(xsElt.getQName())) {
@@ -606,7 +602,9 @@
      * @param parentSchema
      * @throws SchemaCompilationException
      */
-    private void processElement(XmlSchemaElement xsElt, Map<QName,String> innerElementMap, List<QName> localNillableList, XmlSchema parentSchema) throws SchemaCompilationException {
+    private void processElement(XmlSchemaElement xsElt, Map<QName, String> innerElementMap,
+                                List<QName> localNillableList, XmlSchema parentSchema)
+            throws SchemaCompilationException {
         processElement(xsElt, false, innerElementMap, localNillableList, parentSchema);
     }
 
@@ -617,7 +615,8 @@
      * @param parentSchema
      * @throws SchemaCompilationException
      */
-    private void processElement(XmlSchemaElement xsElt, XmlSchema parentSchema) throws SchemaCompilationException {
+    private void processElement(XmlSchemaElement xsElt, XmlSchema parentSchema)
+            throws SchemaCompilationException {
         processElement(xsElt, true, null, null, parentSchema);
     }
 
@@ -629,7 +628,9 @@
      *                inner elements
      * @throws SchemaCompilationException
      */
-    private void processElement(XmlSchemaElement xsElt, boolean isOuter, Map<QName,String> innerElementMap, List<QName> localNillableList, XmlSchema parentSchema) throws SchemaCompilationException {
+    private void processElement(XmlSchemaElement xsElt, boolean isOuter,
+                                Map<QName, String> innerElementMap, List<QName> localNillableList,
+                                XmlSchema parentSchema) throws SchemaCompilationException {
 
         //if the element is null, which usually happens when the qname is not
         //proper, throw an exceptions
@@ -638,7 +639,7 @@
                     SchemaCompilerMessages.getMessage("schema.elementNull"));
         }
 
-       
+
         //The processing element logic seems to be quite simple. Look at the relevant schema type
         //for each and every element and process that accordingly.
         //this means that any unused type definitions would not be generated!
@@ -659,17 +660,19 @@
                     // this element already has a name. Which means we can directly
                     // register it
                     String className = findClassName(schemaType.getQName(),
-                            isArray(xsElt));
+                                                     isArray(xsElt));
 
                     innerElementMap.put(xsElt.getQName(), className);
 
                     // always store the class name in the element meta Info itself
                     // this details only needed by the unwrappig to set the complex type
                     if (options.isUseWrapperClasses() && PrimitiveTypeFinder.isPrimitive(className)) {
-                          className = PrimitiveTypeWrapper.getWrapper(className);
+                        className = PrimitiveTypeWrapper.getWrapper(className);
                     }
-                    schemaType.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY, className);
-                    xsElt.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY, className);
+                    schemaType.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY,
+                                           className);
+                    xsElt.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY,
+                                      className);
 
                     if (baseSchemaTypeMap.containsValue(className)) {
                         schemaType.addMetaInfo(
@@ -687,17 +690,19 @@
                     if (schemaType instanceof XmlSchemaComplexType) {
                         //set a name
                         schemaType.setName(generatedTypeName.getLocalPart());
-                        changedComplexTypeSet.add((XmlSchemaComplexType)schemaType);
+                        changedComplexTypeSet.add((XmlSchemaComplexType) schemaType);
                         // Must do this up front to support recursive types
-                        String fullyQualifiedClassName = writer.makeFullyQualifiedClassName(schemaType.getQName());
+                        String fullyQualifiedClassName = writer.
+                                makeFullyQualifiedClassName(schemaType.getQName());
                         processedTypemap.put(schemaType.getQName(), fullyQualifiedClassName);
 
-                        BeanWriterMetaInfoHolder metaInfHolder = processedAnonymousComplexTypesMap.get(xsElt);
+                        BeanWriterMetaInfoHolder metaInfHolder =
+                                processedAnonymousComplexTypesMap.get(xsElt);
                         metaInfHolder.setOwnQname(schemaType.getQName());
                         metaInfHolder.setOwnClassName(fullyQualifiedClassName);
 
                         writeComplexType((XmlSchemaComplexType) schemaType,
-                                metaInfHolder);
+                                         metaInfHolder);
                         //remove the reference from the anon list since we named the type
                         processedAnonymousComplexTypesMap.remove(xsElt);
                         String className = findClassName(schemaType.getQName(), isArray(xsElt));
@@ -712,17 +717,19 @@
                     } else if (schemaType instanceof XmlSchemaSimpleType) {
                         //set a name
                         schemaType.setName(generatedTypeName.getLocalPart());
-                        changedSimpleTypeSet.add((XmlSchemaSimpleType)schemaType);
+                        changedSimpleTypeSet.add((XmlSchemaSimpleType) schemaType);
                         // Must do this up front to support recursive types
-                        String fullyQualifiedClassName = writer.makeFullyQualifiedClassName(schemaType.getQName());
+                        String fullyQualifiedClassName = writer.
+                                makeFullyQualifiedClassName(schemaType.getQName());
                         processedTypemap.put(schemaType.getQName(), fullyQualifiedClassName);
 
-                        BeanWriterMetaInfoHolder metaInfHolder = processedAnonymousComplexTypesMap.get(xsElt);
+                        BeanWriterMetaInfoHolder metaInfHolder =
+                                processedAnonymousComplexTypesMap.get(xsElt);
                         metaInfHolder.setOwnQname(schemaType.getQName());
                         metaInfHolder.setOwnClassName(fullyQualifiedClassName);
 
                         writeSimpleType((XmlSchemaSimpleType) schemaType,
-                                metaInfHolder);
+                                        metaInfHolder);
                         //remove the reference from the anon list since we named the type
                         processedAnonymousComplexTypesMap.remove(xsElt);
                         String className = findClassName(schemaType.getQName(), isArray(xsElt));
@@ -741,43 +748,55 @@
                 this.processedElementList.add(xsElt.getQName());
             }
             //referenced name
-        } else if (xsElt.getRefName() != null) {
+        } else if (xsElt.getRef().getTargetQName() != null) {
 
-            if (xsElt.getRefName().equals(SchemaConstants.XSD_SCHEMA)) {
+            if (xsElt.getRef().getTargetQName().equals(SchemaConstants.XSD_SCHEMA)) {
                 innerElementMap.put(xsElt.getQName(), writer.getDefaultClassName());
                 return;
             }
             //process the referenced type. It could be thought that the referenced element replaces this
             //element
-            XmlSchema resolvedSchema = getParentSchema(parentSchema,xsElt.getRefName(),COMPONENT_ELEMENT);
-            if (resolvedSchema == null){
-                throw new SchemaCompilationException("can not find the element " + xsElt.getRefName()
-                 + " from the parent schema " + parentSchema.getTargetNamespace());
+            XmlSchema resolvedSchema = getParentSchema(parentSchema,
+                                                       xsElt.getRef().getTargetQName(),
+                                                       COMPONENT_ELEMENT);
+            if (resolvedSchema == null) {
+                throw new SchemaCompilationException("can not find the element " +
+                                                     xsElt.getRef().getTargetQName()
+                                                     + " from the parent schema " +
+                                                     parentSchema.getTargetNamespace());
             }
-            XmlSchemaElement referencedElement = resolvedSchema.getElementByName(xsElt.getRefName());
+            XmlSchemaElement referencedElement = resolvedSchema.
+                    getElementByName(xsElt.getRef().getTargetQName());
             if (referencedElement == null) {
                 throw new SchemaCompilationException(
-                        SchemaCompilerMessages.getMessage("schema.referencedElementNotFound", xsElt.getRefName().toString()));
+                        SchemaCompilerMessages.
+                                getMessage("schema.referencedElementNotFound",
+                                           xsElt.getRef().getTargetQName().toString()));
             }
 
             // here what we want is to set the schema type name for the element
             if ((referencedElement.getSchemaType() != null)
-                    && (referencedElement.getSchemaType().getQName() != null)){
+                && (referencedElement.getSchemaType().getQName() != null)) {
 
                 // i.e this element refers to an complex type name
                 if (!this.processedElementRefMap.containsKey(referencedElement.getQName())) {
                     if (this.baseSchemaTypeMap.containsKey(referencedElement.getSchemaTypeName())) {
                         this.processedElementRefMap.put(referencedElement.getQName(),
-                                this.baseSchemaTypeMap.get(referencedElement.getSchemaTypeName()));
+                                                        this.baseSchemaTypeMap.
+                                                                get(referencedElement.
+                                                                        getSchemaTypeName()));
                     } else {
                         XmlSchema resolvedTypeSchema = getParentSchema(resolvedSchema,
-                                referencedElement.getSchemaTypeName(),
-                                COMPONENT_TYPE);
+                                                                       referencedElement.
+                                                                               getSchemaTypeName(),
+                                                                       COMPONENT_TYPE);
                         XmlSchemaType xmlSchemaType = resolvedTypeSchema.getTypeByName(
                                 referencedElement.getSchemaTypeName().getLocalPart());
                         processSchema(referencedElement, xmlSchemaType, resolvedTypeSchema, true);
                         this.processedElementRefMap.put(referencedElement.getQName(),
-                                this.processedTypemap.get(referencedElement.getSchemaTypeName()));
+                                                        this.processedTypemap.
+                                                                get(referencedElement.
+                                                                        getSchemaTypeName()));
                     }
                 }
                 String javaClassName;
@@ -785,29 +804,34 @@
                     // here we have to do nothing since we do not generate a name
                 } else {
                     javaClassName = this.processedTypemap.get(referencedElement.getSchemaTypeName());
-                    referencedElement.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY,
-                            javaClassName);
+                    referencedElement.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.
+                                                          CLASSNAME_KEY,
+                                                  javaClassName);
                     xsElt.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY,
-                            javaClassName);
+                                      javaClassName);
                 }
             } else if (referencedElement.getSchemaType() != null) {
                 if (!this.processedElementRefMap.containsKey(referencedElement.getQName())) {
 
-                    processSchema(referencedElement, referencedElement.getSchemaType(), resolvedSchema, true);
+                    processSchema(referencedElement, referencedElement.getSchemaType(),
+                                  resolvedSchema, true);
                     // if this is an anonomous complex type we have to set this
                     this.processedElementRefMap.put(referencedElement.getQName(),
-                            this.processedTypemap.get(referencedElement.getSchemaTypeName()));
+                                                    this.processedTypemap.get(referencedElement.
+                                                            getSchemaTypeName()));
 
                 }
-                
-                String javaClassName = this.processedTypemap.get(referencedElement.getSchemaTypeName());
+
+                String javaClassName = this.processedTypemap.
+                        get(referencedElement.getSchemaTypeName());
                 referencedElement.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY,
-                        javaClassName);
+                                              javaClassName);
                 xsElt.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY,
-                        javaClassName);
-            } else if (referencedElement.getSchemaTypeName() != null){
+                                  javaClassName);
+            } else if (referencedElement.getSchemaTypeName() != null) {
                 QName schemaTypeName = referencedElement.getSchemaTypeName();
-                XmlSchema newResolvedSchema = getParentSchema(resolvedSchema, schemaTypeName, COMPONENT_TYPE);
+                XmlSchema newResolvedSchema = getParentSchema(resolvedSchema, schemaTypeName,
+                                                              COMPONENT_TYPE);
                 XmlSchemaType xmlSchemaType = newResolvedSchema.getTypeByName(schemaTypeName);
                 if (xmlSchemaType != null) {
                     if (!this.processedElementRefMap.containsKey(referencedElement.getQName())) {
@@ -815,17 +839,20 @@
                         processSchema(referencedElement, xmlSchemaType, newResolvedSchema, false);
                         // if this is an anonomous complex type we have to set this
                         this.processedElementRefMap.put(referencedElement.getQName(),
-                                this.processedTypemap.get(schemaTypeName));
+                                                        this.processedTypemap.get(schemaTypeName));
 
                     }
 
-                    String javaClassName = this.processedTypemap.get(referencedElement.getSchemaTypeName());
-                    referencedElement.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY,
-                            javaClassName);
+                    String javaClassName = this.processedTypemap.get(referencedElement.
+                            getSchemaTypeName());
+                    referencedElement.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.
+                                                          CLASSNAME_KEY,
+                                                  javaClassName);
                     xsElt.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY,
-                            javaClassName);
+                                      javaClassName);
                 } else {
-                    throw new SchemaCompilationException(" Can not find the schema type with name " + schemaTypeName);
+                    throw new SchemaCompilationException(" Can not find the schema type with name " +
+                                                         schemaTypeName);
                 }
 
             }
@@ -836,10 +863,10 @@
             //this specifically happens with xsd:anyType.
             QName schemaTypeName = xsElt.getSchemaTypeName();
 
-            XmlSchema resolvedSchema = getParentSchema(parentSchema,schemaTypeName,COMPONENT_TYPE);
+            XmlSchema resolvedSchema = getParentSchema(parentSchema, schemaTypeName, COMPONENT_TYPE);
             XmlSchemaType typeByName = null;
-            if (resolvedSchema != null){
-               typeByName = resolvedSchema.getTypeByName(schemaTypeName);
+            if (resolvedSchema != null) {
+                typeByName = resolvedSchema.getTypeByName(schemaTypeName);
             }
 
             if (typeByName != null) {
@@ -851,7 +878,7 @@
                     innerElementMap.put(xsElt.getQName(), className);
                     // set the class name to be used in unwrapping
                     xsElt.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY,
-                                className);
+                                      className);
                 } else {
                     this.processedElementList.add(xsElt.getQName());
                 }
@@ -862,7 +889,7 @@
                     innerElementMap.put(xsElt.getQName(), className);
                     // set the class name to be used in unwrapping
                     xsElt.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY,
-                                className);
+                                      className);
                 } else {
                     this.processedElementList.add(xsElt.getQName());
                 }
@@ -888,10 +915,12 @@
      */
     private QName generateTypeQName(QName referenceEltQName, XmlSchema parentSchema) {
         QName generatedTypeName = new QName(referenceEltQName.getNamespaceURI(),
-                referenceEltQName.getLocalPart() + getNextTypeSuffix(referenceEltQName.getLocalPart()));
+                                            referenceEltQName.getLocalPart() +
+                                            getNextTypeSuffix(referenceEltQName.getLocalPart()));
         while (parentSchema.getTypeByName(generatedTypeName) != null) {
             generatedTypeName = new QName(referenceEltQName.getNamespaceURI(),
-                    referenceEltQName.getLocalPart() + getNextTypeSuffix(referenceEltQName.getLocalPart()));
+                                          referenceEltQName.getLocalPart() +
+                                          getNextTypeSuffix(referenceEltQName.getLocalPart()));
         }
         return generatedTypeName;
     }
@@ -903,9 +932,9 @@
      */
     private boolean isAlreadyProcessed(QName qName) {
         return processedTypemap.containsKey(qName) ||
-                simpleTypesMap.containsKey(qName) ||
-                baseSchemaTypeMap.containsKey(qName) ||
-                processedGroupTypeMap.containsKey(qName);
+               simpleTypesMap.containsKey(qName) ||
+               baseSchemaTypeMap.containsKey(qName) ||
+               processedGroupTypeMap.containsKey(qName);
     }
 
 
@@ -951,7 +980,8 @@
             className = baseSchemaTypeMap.get(qName);
         } else {
             if (isSOAP_ENC(qName.getNamespaceURI())) {
-                throw new SchemaCompilationException(SchemaCompilerMessages.getMessage("schema.soapencoding.error", qName.toString()));
+                throw new SchemaCompilationException(SchemaCompilerMessages.
+                        getMessage("schema.soapencoding.error", qName.toString()));
 
             }
             // We seem to have failed in finding a class name for the
@@ -960,7 +990,7 @@
             //property file
             className = writer.getDefaultClassName();
             log.warn(SchemaCompilerMessages
-                    .getMessage("schema.typeMissing", qName.toString()));
+                             .getMessage("schema.typeMissing", qName.toString()));
         }
 
         if (isArray) {
@@ -981,8 +1011,9 @@
      *         false otherwise
      */
     public static boolean isSOAP_ENC(String s) {
-        if (s.equals(Constants.URI_SOAP11_ENC))
+        if (s.equals(Constants.URI_SOAP11_ENC)) {
             return true;
+        }
         return s.equals(Constants.URI_SOAP12_ENC);
     }
 
@@ -1003,22 +1034,25 @@
             if (complexType.getName() != null && !this.changedComplexTypeSet.contains(schemaType)) {
                 // here complex type may be in another shcema so we have to find the
                 // correct parent schema.
-                XmlSchema resolvedSchema = getParentSchema(parentSchema,complexType.getQName(),COMPONENT_TYPE);
-                if (resolvedSchema == null){
+                XmlSchema resolvedSchema = getParentSchema(parentSchema, complexType.getQName(),
+                                                           COMPONENT_TYPE);
+                if (resolvedSchema == null) {
                     throw new SchemaCompilationException("can not find the parent schema for the " +
-                            "complex type " + complexType.getQName() + " from the parent schema " +
-                    parentSchema.getTargetNamespace());
+                                                         "complex type " + complexType.getQName() +
+                                                         " from the parent schema " +
+                                                         parentSchema.getTargetNamespace());
                 } else {
-                   processNamedComplexSchemaType(complexType, resolvedSchema);
+                    processNamedComplexSchemaType(complexType, resolvedSchema);
                 }
             } else {
-                processAnonymousComplexSchemaType(xsElt, complexType, parentSchema, isWriteAnonComplexType);
+                processAnonymousComplexSchemaType(xsElt, complexType, parentSchema,
+                                                  isWriteAnonComplexType);
             }
         } else if (schemaType instanceof XmlSchemaSimpleType) {
             //process simple type
             processSimpleSchemaType((XmlSchemaSimpleType) schemaType,
-                    xsElt,
-                    parentSchema, null);
+                                    xsElt,
+                                    parentSchema, null);
         }
     }
 
@@ -1054,11 +1088,13 @@
             javaClassName = writer.makeFullyQualifiedClassName(generatedTypeName);
             processedTypemap.put(generatedTypeName, javaClassName);
             this.processedElementRefMap.put(elt.getQName(), javaClassName);
-            complexType.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY, javaClassName);
+            complexType.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY,
+                                    javaClassName);
         }
 
 
-        BeanWriterMetaInfoHolder metaInfHolder = processComplexType(elt.getQName(),complexType, parentSchema);
+        BeanWriterMetaInfoHolder metaInfHolder = processComplexType(elt.getQName(), complexType,
+                                                                    parentSchema);
 
         // here the only difference is that we generate the class
         // irrespective of where we need it or not
@@ -1080,10 +1116,11 @@
      * @param complexType
      */
     private void processNamedComplexSchemaType(XmlSchemaComplexType complexType,
-                                               XmlSchema parentSchema) throws SchemaCompilationException {
+                                               XmlSchema parentSchema)
+            throws SchemaCompilationException {
 
         if (processedTypemap.containsKey(complexType.getQName())
-                || baseSchemaTypeMap.containsKey(complexType.getQName())) {
+            || baseSchemaTypeMap.containsKey(complexType.getQName())) {
             return;
         }
 
@@ -1093,9 +1130,10 @@
 
         //register that in the schema metainfo bag
         complexType.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY,
-                fullyQualifiedClassName);
+                                fullyQualifiedClassName);
 
-        BeanWriterMetaInfoHolder metaInfHolder = processComplexType(complexType.getQName(),complexType, parentSchema);
+        BeanWriterMetaInfoHolder metaInfHolder = processComplexType(complexType.getQName(),
+                                                                    complexType, parentSchema);
         //add this information to the metainfo holder
         metaInfHolder.setOwnQname(complexType.getQName());
         metaInfHolder.setOwnClassName(fullyQualifiedClassName);
@@ -1113,10 +1151,12 @@
      * @param metaInfHolder
      * @throws SchemaCompilationException
      */
-    private String writeComplexType(XmlSchemaComplexType complexType, BeanWriterMetaInfoHolder metaInfHolder)
+    private String writeComplexType(XmlSchemaComplexType complexType,
+                                    BeanWriterMetaInfoHolder metaInfHolder)
             throws SchemaCompilationException {
         String javaClassName = writer.write(complexType.getQName(),
-                processedTypemap, processedGroupTypeMap, metaInfHolder, complexType.isAbstract());
+                                            processedTypemap, processedGroupTypeMap, metaInfHolder,
+                                            complexType.isAbstract());
         processedTypeMetaInfoMap.put(complexType.getQName(), metaInfHolder);
         return javaClassName;
     }
@@ -1124,16 +1164,18 @@
 
     /**
      * Writes complex Sequence,Choice, all elements
-     * @param qname complex type qname
+     *
+     * @param qname         complex type qname
      * @param metaInfHolder
-     * @return  written java class name
+     * @return written java class name
      * @throws SchemaCompilationException
      */
 
 
-    private String writeComplexParticle(QName qname,BeanWriterMetaInfoHolder metaInfHolder)
+    private String writeComplexParticle(QName qname, BeanWriterMetaInfoHolder metaInfHolder)
             throws SchemaCompilationException {
-       String javaClassName = writer.write(qname, processedTypemap, processedGroupTypeMap, metaInfHolder,false);
+        String javaClassName = writer.write(qname, processedTypemap, processedGroupTypeMap,
+                                            metaInfHolder, false);
         processedTypeMetaInfoMap.put(qname, metaInfHolder);
         return javaClassName;
     }
@@ -1145,7 +1187,8 @@
      * @param metaInfHolder
      * @throws SchemaCompilationException
      */
-    private void writeSimpleType(XmlSchemaSimpleType simpleType, BeanWriterMetaInfoHolder metaInfHolder)
+    private void writeSimpleType(XmlSchemaSimpleType simpleType,
+                                 BeanWriterMetaInfoHolder metaInfHolder)
             throws SchemaCompilationException {
         writer.write(simpleType, processedTypemap, processedGroupTypeMap, metaInfHolder);
         processedTypeMetaInfoMap.put(simpleType.getQName(), metaInfHolder);
@@ -1161,13 +1204,14 @@
             //Process the particle
             processParticle(parentElementQName, particle, metaInfHolder, parentSchema);
         }
-        
-        if(complexType.isMixed()){
-            throw new SchemaCompilationException("XSD complexType with mix content not supported in ADB");
+
+        if (complexType.isMixed()) {
+            throw new SchemaCompilationException("XSD complexType with mix content not " +
+                                                 "supported in ADB");
         }
 
         //process attributes - first look for the explicit attributes
-        processAttributes(complexType.getAttributes(),metaInfHolder,parentSchema);
+        processAttributes(complexType.getAttributes(), metaInfHolder, parentSchema);
 
         //process any attribute
         //somehow the xml schema parser does not seem to pickup the any attribute!!
@@ -1180,44 +1224,63 @@
         //process content ,either  complex or simple
         if (complexType.getContentModel() != null) {
             processContentModel(complexType.getContentModel(),
-                    metaInfHolder,
-                    parentSchema);
+                                metaInfHolder,
+                                parentSchema);
         }
         return metaInfHolder;
     }
 
-    private void processAttributes(XmlSchemaObjectCollection attributes,
+    private void processAttributes(List<XmlSchemaAttributeOrGroupRef> attributes,
                                    BeanWriterMetaInfoHolder metaInfHolder,
                                    XmlSchema parentSchema) throws SchemaCompilationException {
-        Iterator attribIterator = attributes.getIterator();
-        while (attribIterator.hasNext()) {
-            Object o = attribIterator.next();
-            if (o instanceof XmlSchemaAttribute) {
-                processAttribute((XmlSchemaAttribute) o, metaInfHolder, parentSchema);
-            } else if (o instanceof XmlSchemaAttributeGroupRef){
-                processAttributeGroupReference((XmlSchemaAttributeGroupRef)o,metaInfHolder,parentSchema);
+
+        for (XmlSchemaObject object : attributes) {
+            if (object instanceof XmlSchemaAttribute) {
+                processAttribute((XmlSchemaAttribute) object, metaInfHolder, parentSchema);
+            } else if (object instanceof XmlSchemaAttributeGroupRef) {
+                processAttributeGroupReference((XmlSchemaAttributeGroupRef) object, metaInfHolder,
+                                               parentSchema);
             }
         }
     }
 
+    private void processGroupAttributes(List<XmlSchemaAttributeGroupMember> attributes,
+                                        BeanWriterMetaInfoHolder metaInfHolder,
+                                        XmlSchema resolvedSchema)
+            throws SchemaCompilationException {
+        for (XmlSchemaAttributeGroupMember member : attributes) {
+            if (member instanceof XmlSchemaAttribute) {
+                processAttribute((XmlSchemaAttribute) member, metaInfHolder, resolvedSchema);
+            } else if (member instanceof XmlSchemaAttributeGroupRef) {
+                processAttributeGroupReference((XmlSchemaAttributeGroupRef) member, metaInfHolder,
+                                               resolvedSchema);
+            }
+        }
+    }
+
+
     private void processAttributeGroupReference(XmlSchemaAttributeGroupRef attributeGroupRef,
                                                 BeanWriterMetaInfoHolder metaInfHolder,
-                                                XmlSchema parentSchema) throws SchemaCompilationException {
+                                                XmlSchema parentSchema)
+            throws SchemaCompilationException {
 
-        QName attributeGroupRefName = attributeGroupRef.getRefName();
-        if (attributeGroupRefName != null){
-           XmlSchema resolvedSchema = getParentSchema(parentSchema,attributeGroupRefName,COMPONENT_ATTRIBUTE_GROUP);
+        QName attributeGroupRefName = attributeGroupRef.getRef().getTargetQName();
+        if (attributeGroupRefName != null) {
+            XmlSchema resolvedSchema = getParentSchema(parentSchema, attributeGroupRefName,
+                                                       COMPONENT_ATTRIBUTE_GROUP);
             if (resolvedSchema == null) {
                 throw new SchemaCompilationException("can not find the attribute group reference name " +
-                        attributeGroupRefName + " from the parent schema " + parentSchema.getTargetNamespace());
+                                                     attributeGroupRefName + " from the parent schema " +
+                                                     parentSchema.getTargetNamespace());
             } else {
                 XmlSchemaAttributeGroup xmlSchemaAttributeGroup =
-                        (XmlSchemaAttributeGroup) resolvedSchema.getAttributeGroups().getItem(attributeGroupRefName);
+                        resolvedSchema.getAttributeGroups().get(attributeGroupRefName);
                 if (xmlSchemaAttributeGroup != null) {
-                    processAttributes(xmlSchemaAttributeGroup.getAttributes(), metaInfHolder, resolvedSchema);
+                    processGroupAttributes(xmlSchemaAttributeGroup.getAttributes(), metaInfHolder,
+                                           resolvedSchema);
                 } else {
                     throw new SchemaCompilationException("Can not find an attribute group for group reference "
-                            + attributeGroupRefName.getLocalPart());
+                                                         + attributeGroupRefName.getLocalPart());
                 }
             }
 
@@ -1254,15 +1317,18 @@
 
             // to handle extension we need to attach the extended items to the base type
             // and create a new type
-            XmlSchemaComplexContentExtension extension = (XmlSchemaComplexContentExtension)content;
+            XmlSchemaComplexContentExtension extension = (XmlSchemaComplexContentExtension) content;
 
             //process the base type if it has not been processed yet
             if (!isAlreadyProcessed(extension.getBaseTypeName())) {
                 //pick the relevant basetype from the schema and process it
-                XmlSchema resolvedSchema = getParentSchema(parentSchema, extension.getBaseTypeName(), COMPONENT_TYPE);
+                XmlSchema resolvedSchema = getParentSchema(parentSchema, extension.getBaseTypeName(),
+                                                           COMPONENT_TYPE);
                 if (resolvedSchema == null) {
-                    throw new SchemaCompilationException("can not find the compley type " + extension.getBaseTypeName()
-                            + " from the parent type " + parentSchema.getTargetNamespace());
+                    throw new SchemaCompilationException("can not find the compley type " +
+                                                         extension.getBaseTypeName()
+                                                         + " from the parent type " +
+                                                         parentSchema.getTargetNamespace());
                 } else {
                     XmlSchemaType type = resolvedSchema.getTypeByName(extension.getBaseTypeName());
                     if (type instanceof XmlSchemaComplexType) {
@@ -1290,12 +1356,13 @@
 
             //process the particle of this node
             if (extension.getParticle() != null) {
-                processParticle(extension.getBaseTypeName(),extension.getParticle(), metaInfHolder, parentSchema);
+                processParticle(extension.getBaseTypeName(), extension.getParticle(), metaInfHolder,
+                                parentSchema);
             }
 
             // process attributes
             //process attributes - first look for the explicit attributes
-            processAttributes(extension.getAttributes(),metaInfHolder,parentSchema);
+            processAttributes(extension.getAttributes(), metaInfHolder, parentSchema);
 
             //process any attribute
             //somehow the xml schema parser does not seem to pickup the any attribute!!
@@ -1314,15 +1381,20 @@
                 //Note  - this is no array! so the array boolean is false
             }
         } else if (content instanceof XmlSchemaComplexContentRestriction) {
-            XmlSchemaComplexContentRestriction restriction = (XmlSchemaComplexContentRestriction) content;
+            XmlSchemaComplexContentRestriction restriction =
+                    (XmlSchemaComplexContentRestriction) content;
 
             //process the base type if it has not been processed yet
             if (!isAlreadyProcessed(restriction.getBaseTypeName())) {
                 //pick the relevant basetype from the schema and process it
-                XmlSchema resolvedSchema = getParentSchema(parentSchema, restriction.getBaseTypeName(), COMPONENT_TYPE);
+                XmlSchema resolvedSchema = getParentSchema(parentSchema,
+                                                           restriction.getBaseTypeName(),
+                                                           COMPONENT_TYPE);
                 if (resolvedSchema == null) {
-                    throw new SchemaCompilationException("can not find the complex type " + restriction.getBaseTypeName()
-                            + " from the parent type " + parentSchema.getTargetNamespace());
+                    throw new SchemaCompilationException("can not find the complex type " +
+                                                         restriction.getBaseTypeName()
+                                                         + " from the parent type " +
+                                                         parentSchema.getTargetNamespace());
                 } else {
                     XmlSchemaType type = resolvedSchema.getTypeByName(restriction.getBaseTypeName());
                     if (type instanceof XmlSchemaComplexType) {
@@ -1335,7 +1407,8 @@
                             throw new SchemaCompilationException("Unnamed complex type used in restriction");//Internationlize this
                         }
                     } else if (type instanceof XmlSchemaSimpleType) {
-                        throw new SchemaCompilationException("Not a valid restriction, complex content restriction base type cannot be a simple type.");
+                        throw new SchemaCompilationException("Not a valid restriction, " +
+                                                             "complex content restriction base type cannot be a simple type.");
                     }
                 }
             }
@@ -1343,10 +1416,11 @@
             copyMetaInfoHierarchy(metaInfHolder, restriction.getBaseTypeName(), parentSchema);
 
             //process the particle of this node
-            processParticle(restriction.getBaseTypeName(),restriction.getParticle(), metaInfHolder, parentSchema);
+            processParticle(restriction.getBaseTypeName(), restriction.getParticle(), metaInfHolder,
+                            parentSchema);
 
             //process attributes - first look for the explicit attributes
-            processAttributes(restriction.getAttributes(),metaInfHolder,parentSchema);
+            processAttributes(restriction.getAttributes(), metaInfHolder, parentSchema);
 
             //process any attribute
             //somehow the xml schema parser does not seem to pickup the any attribute!!
@@ -1358,7 +1432,8 @@
 
             if (!writer.getDefaultClassName().equals(className)) {
                 metaInfHolder.setRestriction(true);
-                metaInfHolder.setRestrictionClassName(findClassName(restriction.getBaseTypeName(), false));
+                metaInfHolder.setRestrictionClassName(findClassName(restriction.getBaseTypeName(),
+                                                                    false));
                 //Note  - this is no array! so the array boolean is false
             }
         }
@@ -1376,10 +1451,11 @@
                                        XmlSchema parentSchema)
             throws SchemaCompilationException {
 
-        XmlSchema resolvedSchema = getParentSchema(parentSchema,baseTypeName,COMPONENT_TYPE);
+        XmlSchema resolvedSchema = getParentSchema(parentSchema, baseTypeName, COMPONENT_TYPE);
         if (resolvedSchema == null) {
             throw new SchemaCompilationException("can not find type " + baseTypeName
-                    + " from the parent schema " + parentSchema.getTargetNamespace());
+                                                 + " from the parent schema " +
+                                                 parentSchema.getTargetNamespace());
         } else {
             XmlSchemaType type = resolvedSchema.getTypeByName(baseTypeName);
             BeanWriterMetaInfoHolder baseMetaInfoHolder =
@@ -1397,50 +1473,57 @@
                         if (content instanceof XmlSchemaComplexContent) {
                             XmlSchemaComplexContent complexContent =
                                     (XmlSchemaComplexContent) content;
-                            if (complexContent.getContent() instanceof XmlSchemaComplexContentExtension) {
+                            if (complexContent.getContent() instanceof
+                                    XmlSchemaComplexContentExtension) {
                                 XmlSchemaComplexContentExtension extension =
                                         (XmlSchemaComplexContentExtension) complexContent.getContent();
                                 //recursively call the copyMetaInfoHierarchy method
                                 copyMetaInfoHierarchy(baseMetaInfoHolder,
-                                        extension.getBaseTypeName(),
-                                        resolvedSchema);
+                                                      extension.getBaseTypeName(),
+                                                      resolvedSchema);
 
-                            } else if (complexContent.getContent() instanceof XmlSchemaComplexContentRestriction) {
+                            } else if (complexContent.getContent() instanceof
+                                    XmlSchemaComplexContentRestriction) {
 
                                 XmlSchemaComplexContentRestriction restriction =
                                         (XmlSchemaComplexContentRestriction) complexContent.getContent();
                                 //recursively call the copyMetaInfoHierarchy method
                                 copyMetaInfoHierarchy(baseMetaInfoHolder,
-                                        restriction.getBaseTypeName(),
-                                        resolvedSchema);
+                                                      restriction.getBaseTypeName(),
+                                                      resolvedSchema);
 
                             } else {
                                 throw new SchemaCompilationException(
-                                        SchemaCompilerMessages.getMessage("schema.unknowncontenterror"));
+                                        SchemaCompilerMessages.
+                                                getMessage("schema.unknowncontenterror"));
                             }
 
                         } else if (content instanceof XmlSchemaSimpleContent) {
 
                             XmlSchemaSimpleContent simpleContent = (XmlSchemaSimpleContent) content;
-                            if (simpleContent.getContent() instanceof XmlSchemaSimpleContentExtension) {
-                                XmlSchemaSimpleContentExtension extension = (XmlSchemaSimpleContentExtension) simpleContent
+                            if (simpleContent.getContent() instanceof
+                                    XmlSchemaSimpleContentExtension) {
+                                XmlSchemaSimpleContentExtension extension =
+                                        (XmlSchemaSimpleContentExtension) simpleContent
                                         .getContent();
                                 // recursively call the copyMetaInfoHierarchy
                                 // method
                                 copyMetaInfoHierarchy(baseMetaInfoHolder,
-                                        extension.getBaseTypeName(), resolvedSchema);
+                                                      extension.getBaseTypeName(), resolvedSchema);
 
-                            } else if (simpleContent.getContent() instanceof XmlSchemaSimpleContentRestriction) {
+                            } else if (simpleContent.getContent() instanceof
+                                    XmlSchemaSimpleContentRestriction) {
 
-                                XmlSchemaSimpleContentRestriction restriction = (XmlSchemaSimpleContentRestriction) simpleContent
+                                XmlSchemaSimpleContentRestriction restriction =
+                                        (XmlSchemaSimpleContentRestriction) simpleContent
                                         .getContent();
                                 // recursively call the copyMetaInfoHierarchy
                                 // method
                                 copyMetaInfoHierarchy(baseMetaInfoHolder,
-                                        restriction.getBaseTypeName(), resolvedSchema);
+                                                      restriction.getBaseTypeName(), resolvedSchema);
 
                             }
-                        
+
                         } else {
                             throw new SchemaCompilationException(
                                     SchemaCompilerMessages.getMessage("schema.unknowncontenterror"));
@@ -1457,7 +1540,7 @@
                     // code as union
                     if (baseMetaInfoHolder.isUnion()) {
                         metaInfHolder.setUnion(true);
-                        for (Map.Entry<QName,String> entry : baseMetaInfoHolder.getMemberTypes().entrySet()) {
+                        for (Map.Entry<QName, String> entry : baseMetaInfoHolder.getMemberTypes().entrySet()) {
                             metaInfHolder.addMemberType(entry.getKey(), entry.getValue());
                         }
                     }
@@ -1480,7 +1563,9 @@
      * @param metaInfHolder
      * @throws SchemaCompilationException
      */
-    private void processSimpleContent(XmlSchemaSimpleContent simpleContent, BeanWriterMetaInfoHolder metaInfHolder, XmlSchema parentSchema)
+    private void processSimpleContent(XmlSchemaSimpleContent simpleContent,
+                                      BeanWriterMetaInfoHolder metaInfHolder,
+                                      XmlSchema parentSchema)
             throws SchemaCompilationException {
         XmlSchemaContent content;
         content = simpleContent.getContent();
@@ -1490,10 +1575,13 @@
             //process the base type if it has not been processed yet
             if (!isAlreadyProcessed(extension.getBaseTypeName())) {
                 //pick the relevant basetype from the schema and process it
-                XmlSchema resolvedSchema = getParentSchema(parentSchema, extension.getBaseTypeName(), COMPONENT_TYPE);
+                XmlSchema resolvedSchema = getParentSchema(parentSchema, extension.getBaseTypeName(),
+                                                           COMPONENT_TYPE);
                 if (resolvedSchema == null) {
-                    throw new SchemaCompilationException("can not find type " + extension.getBaseTypeName()
-                            + " from the parent schema " + parentSchema.getTargetNamespace());
+                    throw new SchemaCompilationException("can not find type " +
+                                                         extension.getBaseTypeName()
+                                                         + " from the parent schema " +
+                                                         parentSchema.getTargetNamespace());
                 } else {
                     XmlSchemaType type = resolvedSchema.getTypeByName(extension.getBaseTypeName());
                     if (type instanceof XmlSchemaComplexType) {
@@ -1517,10 +1605,7 @@
             processSimpleExtensionBaseType(extension.getBaseTypeName(), metaInfHolder, parentSchema);
 
             //process attributes
-            XmlSchemaObjectCollection attribs = extension.getAttributes();
-            Iterator attribIterator = attribs.getIterator();
-            while (attribIterator.hasNext()) {
-                Object attr = attribIterator.next();
+            for (XmlSchemaAttributeOrGroupRef attr : extension.getAttributes()) {
                 if (attr instanceof XmlSchemaAttribute) {
                     processAttribute((XmlSchemaAttribute) attr, metaInfHolder, parentSchema);
 
@@ -1539,10 +1624,14 @@
             //process the base type if it has not been processed yet
             if (!isAlreadyProcessed(restriction.getBaseTypeName())) {
                 //pick the relevant basetype from the schema and process it
-                XmlSchema resolvedSchema = getParentSchema(parentSchema, restriction.getBaseTypeName(), COMPONENT_TYPE);
+                XmlSchema resolvedSchema = getParentSchema(parentSchema,
+                                                           restriction.getBaseTypeName(),
+                                                           COMPONENT_TYPE);
                 if (resolvedSchema == null) {
-                    throw new SchemaCompilationException("can not find type " + restriction.getBaseTypeName()
-                            + " from the parent schema " + parentSchema.getTargetNamespace());
+                    throw new SchemaCompilationException("can not find type " +
+                                                         restriction.getBaseTypeName()
+                                                         + " from the parent schema " +
+                                                         parentSchema.getTargetNamespace());
                 } else {
                     XmlSchemaType type = resolvedSchema.getTypeByName(restriction.getBaseTypeName());
 
@@ -1564,13 +1653,14 @@
             }
             //process restriction base type
             processSimpleRestrictionBaseType(restriction.getBaseTypeName(),
-                    restriction.getBaseTypeName(),
-                    metaInfHolder,
-                    parentSchema);
+                                             restriction.getBaseTypeName(),
+                                             metaInfHolder,
+                                             parentSchema);
             metaInfHolder.setSimple(true);
-            
-            if (!SchemaConstants.XSD_BOOLEAN.equals(restriction.getBaseTypeName())){
-                processFacets(restriction.getFacets(), restriction.getBaseTypeName(), metaInfHolder, parentSchema);
+
+            if (!SchemaConstants.XSD_BOOLEAN.equals(restriction.getBaseTypeName())) {
+                processFacets(restriction.getFacets(), restriction.getBaseTypeName(), metaInfHolder,
+                              parentSchema);
             }
         }
     }
@@ -1583,7 +1673,8 @@
      */
     public void processSimpleExtensionBaseType(QName extBaseType,
                                                BeanWriterMetaInfoHolder metaInfHolder,
-                                               XmlSchema parentSchema) throws SchemaCompilationException {
+                                               XmlSchema parentSchema)
+            throws SchemaCompilationException {
 
         //find the class name
         String className = findClassName(extBaseType, false);
@@ -1597,21 +1688,22 @@
             //this means the schema type actually returns a different QName
             if (changedTypeMap.containsKey(extBaseType)) {
                 metaInfHolder.registerMapping(extBaseType,
-                        changedTypeMap.get(extBaseType),
-                        className, SchemaConstants.ELEMENT_TYPE);
+                                              changedTypeMap.get(extBaseType),
+                                              className, SchemaConstants.ELEMENT_TYPE);
             } else {
                 metaInfHolder.registerMapping(extBaseType,
-                        extBaseType,
-                        className, SchemaConstants.ELEMENT_TYPE);
+                                              extBaseType,
+                                              className, SchemaConstants.ELEMENT_TYPE);
             }
             metaInfHolder.setSimple(true);
             // we have already process when it comes to this place
         } else if (processedTypemap.containsKey(extBaseType)) {
             //set the extension base class name
-            XmlSchema resolvedSchema = getParentSchema(parentSchema,extBaseType,COMPONENT_TYPE);
+            XmlSchema resolvedSchema = getParentSchema(parentSchema, extBaseType, COMPONENT_TYPE);
             if (resolvedSchema == null) {
                 throw new SchemaCompilationException("can not find the type " + extBaseType
-                        + " from the parent schema " + parentSchema.getTargetNamespace());
+                                                     + " from the parent schema " +
+                                                     parentSchema.getTargetNamespace());
             } else {
                 XmlSchemaType type = resolvedSchema.getTypeByName(extBaseType);
                 if (type instanceof XmlSchemaSimpleType) {
@@ -1622,16 +1714,15 @@
                     copyMetaInfoHierarchy(metaInfHolder, extBaseType, resolvedSchema);
                 } else if (type instanceof XmlSchemaComplexType) {
                     XmlSchemaComplexType complexType = (XmlSchemaComplexType) type;
-                        // do not set as a simple type since we want to
-                        // print the element names
-                        metaInfHolder.setExtension(true);
-                        metaInfHolder.setExtensionClassName(className);
-                        copyMetaInfoHierarchy(metaInfHolder, extBaseType, resolvedSchema);
-                        XmlSchemaContentModel typeContent =complexType.getContentModel();
-                        if(typeContent != null && typeContent instanceof XmlSchemaSimpleContent){
-                            metaInfHolder.setSimple(true);                            
-                        } 
-                        
+                    // do not set as a simple type since we want to
+                    // print the element names
+                    metaInfHolder.setExtension(true);
+                    metaInfHolder.setExtensionClassName(className);
+                    copyMetaInfoHierarchy(metaInfHolder, extBaseType, resolvedSchema);
+                    XmlSchemaContentModel typeContent = complexType.getContentModel();
+                    if (typeContent != null && typeContent instanceof XmlSchemaSimpleContent) {
+                        metaInfHolder.setSimple(true);
+                    }
                 }
             }
 
@@ -1642,7 +1733,7 @@
         //get the binary state and add that to the status map
         if (isBinary(extBaseType)) {
             metaInfHolder.addtStatus(extBaseType,
-                    SchemaConstants.BINARY_TYPE);
+                                     SchemaConstants.BINARY_TYPE);
         }
     }
 
@@ -1655,7 +1746,8 @@
     public void processSimpleRestrictionBaseType(QName qName,
                                                  QName resBaseType,
                                                  BeanWriterMetaInfoHolder metaInfHolder,
-                                                 XmlSchema parentSchema) throws SchemaCompilationException {
+                                                 XmlSchema parentSchema)
+            throws SchemaCompilationException {
 
         //find the class name
         String className = findClassName(resBaseType, false);
@@ -1664,12 +1756,12 @@
         if (baseSchemaTypeMap.containsKey(resBaseType)) {
             if (changedTypeMap.containsKey(resBaseType)) {
                 metaInfHolder.registerMapping(qName,
-                        changedTypeMap.get(resBaseType),
-                        className, SchemaConstants.ELEMENT_TYPE);
+                                              changedTypeMap.get(resBaseType),
+                                              className, SchemaConstants.ELEMENT_TYPE);
             } else {
                 metaInfHolder.registerMapping(qName,
-                        resBaseType,
-                        className, SchemaConstants.ELEMENT_TYPE);
+                                              resBaseType,
+                                              className, SchemaConstants.ELEMENT_TYPE);
             }
         } else if (processedTypemap.containsKey(resBaseType)) {
             //this is not a standared type
@@ -1689,34 +1781,28 @@
      * Process Facets.
      *
      * @param metaInfHolder
-     * @param facets 
+     * @param facets
      */
-    private void processFacets( XmlSchemaObjectCollection facets,QName restrictionName,
+    private void processFacets(List<XmlSchemaFacet> facets, QName restrictionName,
                                BeanWriterMetaInfoHolder metaInfHolder,
                                XmlSchema parentSchema) {
-        
-        Iterator facetIterator = facets.getIterator();
 
-        while (facetIterator.hasNext()) {
-            Object obj = facetIterator.next();
-
-            if (obj instanceof XmlSchemaPatternFacet) {
-                XmlSchemaPatternFacet pattern = (XmlSchemaPatternFacet) obj;
+        for (XmlSchemaFacet facet : facets) {
+            if (facet instanceof XmlSchemaPatternFacet) {
+                XmlSchemaPatternFacet pattern = (XmlSchemaPatternFacet) facet;
                 // some patterns contain \ so we have to replace them
                 String patternString = pattern.getValue().toString();
                 // replace backword slashes
                 patternString = patternString.replaceAll("\\\\", "\\\\\\\\");
-                patternString = patternString.replaceAll("\"","\\\\\"");
+                patternString = patternString.replaceAll("\"", "\\\\\"");
                 if ((metaInfHolder.getPatternFacet() != null) &&
-                        (metaInfHolder.getPatternFacet().trim().length() > 0)){
+                    (metaInfHolder.getPatternFacet().trim().length() > 0)) {
                     // i.e there is a pattern faceset
                     patternString = metaInfHolder.getPatternFacet().trim() + "|" + patternString;
                 }
                 metaInfHolder.setPatternFacet(patternString);
-            }
-
-            else if (obj instanceof XmlSchemaEnumerationFacet) {
-                XmlSchemaEnumerationFacet enumeration = (XmlSchemaEnumerationFacet) obj;
+            } else if (facet instanceof XmlSchemaEnumerationFacet) {
+                XmlSchemaEnumerationFacet enumeration = (XmlSchemaEnumerationFacet) facet;
                 if (restrictionName.equals(SchemaConstants.XSD_QNAME)) {
                     // we have to process the qname here and shoud find the local part and namespace uri
                     String value = enumeration.getValue().toString();
@@ -1731,45 +1817,29 @@
                     metaInfHolder.addEnumFacet(enumeration.getValue().toString());
                 }
 
-            }
-
-            else if (obj instanceof XmlSchemaLengthFacet) {
-                XmlSchemaLengthFacet length = (XmlSchemaLengthFacet) obj;
+            } else if (facet instanceof XmlSchemaLengthFacet) {
+                XmlSchemaLengthFacet length = (XmlSchemaLengthFacet) facet;
                 metaInfHolder.setLengthFacet(Integer.parseInt(length.getValue().toString()));
-            }
-
-            else if (obj instanceof XmlSchemaTotalDigitsFacet) {
-                XmlSchemaTotalDigitsFacet totalDigits = (XmlSchemaTotalDigitsFacet) obj;
+            } else if (facet instanceof XmlSchemaTotalDigitsFacet) {
+                XmlSchemaTotalDigitsFacet totalDigits = (XmlSchemaTotalDigitsFacet) facet;
                 metaInfHolder.setTotalDigitsFacet(totalDigits.getValue().toString());
-            }
-
-            else if (obj instanceof XmlSchemaMaxExclusiveFacet) {
-                XmlSchemaMaxExclusiveFacet maxEx = (XmlSchemaMaxExclusiveFacet) obj;
+            } else if (facet instanceof XmlSchemaMaxExclusiveFacet) {
+                XmlSchemaMaxExclusiveFacet maxEx = (XmlSchemaMaxExclusiveFacet) facet;
                 metaInfHolder.setMaxExclusiveFacet(maxEx.getValue().toString());
-            }
-
-            else if (obj instanceof XmlSchemaMinExclusiveFacet) {
-                XmlSchemaMinExclusiveFacet minEx = (XmlSchemaMinExclusiveFacet) obj;
+            } else if (facet instanceof XmlSchemaMinExclusiveFacet) {
+                XmlSchemaMinExclusiveFacet minEx = (XmlSchemaMinExclusiveFacet) facet;
                 metaInfHolder.setMinExclusiveFacet(minEx.getValue().toString());
-            }
-
-            else if (obj instanceof XmlSchemaMaxInclusiveFacet) {
-                XmlSchemaMaxInclusiveFacet maxIn = (XmlSchemaMaxInclusiveFacet) obj;
+            } else if (facet instanceof XmlSchemaMaxInclusiveFacet) {
+                XmlSchemaMaxInclusiveFacet maxIn = (XmlSchemaMaxInclusiveFacet) facet;
                 metaInfHolder.setMaxInclusiveFacet(maxIn.getValue().toString());
-            }
-
-            else if (obj instanceof XmlSchemaMinInclusiveFacet) {
-                XmlSchemaMinInclusiveFacet minIn = (XmlSchemaMinInclusiveFacet) obj;
+            } else if (facet instanceof XmlSchemaMinInclusiveFacet) {
+                XmlSchemaMinInclusiveFacet minIn = (XmlSchemaMinInclusiveFacet) facet;
                 metaInfHolder.setMinInclusiveFacet(minIn.getValue().toString());
-            }
-
-            else if (obj instanceof XmlSchemaMaxLengthFacet) {
-                XmlSchemaMaxLengthFacet maxLen = (XmlSchemaMaxLengthFacet) obj;
+            } else if (facet instanceof XmlSchemaMaxLengthFacet) {
+                XmlSchemaMaxLengthFacet maxLen = (XmlSchemaMaxLengthFacet) facet;
                 metaInfHolder.setMaxLengthFacet(Integer.parseInt(maxLen.getValue().toString()));
-            }
-
-            else if (obj instanceof XmlSchemaMinLengthFacet) {
-                XmlSchemaMinLengthFacet minLen = (XmlSchemaMinLengthFacet) obj;
+            } else if (facet instanceof XmlSchemaMinLengthFacet) {
+                XmlSchemaMinLengthFacet minLen = (XmlSchemaMinLengthFacet) facet;
                 metaInfHolder.setMinLengthFacet(Integer.parseInt(minLen.getValue().toString()));
             }
         }
@@ -1780,17 +1850,18 @@
      *
      * @param metainf
      */
-    private void processAnyAttribute(BeanWriterMetaInfoHolder metainf, XmlSchemaAnyAttribute anyAtt) {
+    private void processAnyAttribute(BeanWriterMetaInfoHolder metainf,
+                                     XmlSchemaAnyAttribute anyAtt) {
 
         //The best thing we can do here is to add a set of OMAttributes
         //since attributes do not have the notion of minoccurs/maxoccurs the
         //safest option here is to have an OMAttribute array
         QName qName = new QName(EXTRA_ATTRIBUTE_FIELD_NAME);
         metainf.registerMapping(qName,
-                null,
-                writer.getDefaultAttribArrayClassName(),//always generate an array of
-                //OMAttributes
-                SchemaConstants.ANY_TYPE);
+                                null,
+                                writer.getDefaultAttribArrayClassName(),//always generate an array of
+                                //OMAttributes
+                                SchemaConstants.ANY_TYPE);
         metainf.addtStatus(qName, SchemaConstants.ATTRIBUTE_TYPE);
         metainf.addtStatus(qName, SchemaConstants.ARRAY_TYPE);
 
@@ -1803,7 +1874,8 @@
      * @param att
      * @param metainf
      */
-    public void processAttribute(XmlSchemaAttribute att, BeanWriterMetaInfoHolder metainf, XmlSchema parentSchema)
+    public void processAttribute(XmlSchemaAttribute att, BeanWriterMetaInfoHolder metainf,
+                                 XmlSchema parentSchema)
             throws SchemaCompilationException {
 
         QName schemaTypeName = att.getSchemaTypeName();
@@ -1812,10 +1884,11 @@
                 if (baseSchemaTypeMap.containsKey(schemaTypeName)) {
 
                     metainf.registerMapping(att.getQName(), schemaTypeName,
-                            baseSchemaTypeMap.get(schemaTypeName).toString(), SchemaConstants.ATTRIBUTE_TYPE);
+                                            baseSchemaTypeMap.get(schemaTypeName).toString(),
+                                            SchemaConstants.ATTRIBUTE_TYPE);
 
                     // add optional attribute status if set
-                    String use = att.getUse().getValue();
+                    String use = att.getUse().toString();
                     if (USE_NONE.equals(use) || USE_OPTIONAL.equals(use)) {
                         metainf.addtStatus(att.getQName(), SchemaConstants.OPTIONAL_TYPE);
                     }
@@ -1826,19 +1899,22 @@
                             SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY,
                             className);
                     // set the default value
-                    if (att.getDefaultValue() != null){
-                        metainf.registerDefaultValue(att.getQName(),att.getDefaultValue());
-                    }                 
-                    if(att.getFixedValue() != null){
+                    if (att.getDefaultValue() != null) {
+                        metainf.registerDefaultValue(att.getQName(), att.getDefaultValue());
+                    }
+                    if (att.getFixedValue() != null) {
                         metainf.registerDefaultValue(att.getQName(), att.getFixedValue());
                         metainf.setFixed(true);
                     }
                     // after
                 } else {
-                    XmlSchema resolvedSchema = getParentSchema(parentSchema,schemaTypeName,COMPONENT_TYPE);
+                    XmlSchema resolvedSchema = getParentSchema(parentSchema, schemaTypeName,
+                                                               COMPONENT_TYPE);
                     if (resolvedSchema == null) {
-                        throw new SchemaCompilationException("can not find the type " + schemaTypeName +
-                                " from the parent schema " + parentSchema.getTargetNamespace());
+                        throw new SchemaCompilationException("can not find the type " +
+                                                             schemaTypeName +
+                                                             " from the parent schema " +
+                                                             parentSchema.getTargetNamespace());
                     } else {
                         XmlSchemaType type = resolvedSchema.getTypeByName(schemaTypeName);
                         if (type instanceof XmlSchemaSimpleType) {
@@ -1850,11 +1926,11 @@
                                     processSimpleSchemaType(simpleType, null, resolvedSchema, null);
                                 }
                                 metainf.registerMapping(att.getQName(),
-                                        schemaTypeName,
-                                        processedTypemap.get(schemaTypeName).toString(),
-                                        SchemaConstants.ATTRIBUTE_TYPE);
+                                                        schemaTypeName,
+                                                        processedTypemap.get(schemaTypeName).toString(),
+                                                        SchemaConstants.ATTRIBUTE_TYPE);
                                 // add optional attribute status if set
-                                String use = att.getUse().getValue();
+                                String use = att.getUse().toString();
                                 if (USE_NONE.equals(use) || USE_OPTIONAL.equals(use)) {
                                     metainf.addtStatus(att.getQName(), SchemaConstants.OPTIONAL_TYPE);
                                 }
@@ -1867,21 +1943,24 @@
                 // this attribute has a type but does not have a name, seems to be invalid
             }
 
-        } else if (att.getRefName() != null) {
+        } else if (att.getRef().getTargetQName() != null) {
 
-            XmlSchema resolvedSchema = getParentSchema(parentSchema,att.getRefName(),COMPONENT_ATTRIBUTE);
-            if (resolvedSchema == null){
-                throw new SchemaCompilationException("can not find the attribute " + att.getRefName() +
-                " from the parent schema " + parentSchema.getTargetNamespace());
+            XmlSchema resolvedSchema = getParentSchema(parentSchema, att.getRef().getTargetQName(),
+                                                       COMPONENT_ATTRIBUTE);
+            if (resolvedSchema == null) {
+                throw new SchemaCompilationException("can not find the attribute " +
+                                                     att.getRef().getTargetQName() +
+                                                     " from the parent schema " +
+                                                     parentSchema.getTargetNamespace());
             } else {
                 XmlSchemaAttribute xmlSchemaAttribute =
-                        (XmlSchemaAttribute) resolvedSchema.getAttributes().getItem(att.getRefName());
+                        resolvedSchema.getAttributes().get(att.getRef().getTargetQName());
                 if (xmlSchemaAttribute != null) {
                     // call recursively to process the schema
                     processAttribute(xmlSchemaAttribute, metainf, resolvedSchema);
                 } else {
                     throw new SchemaCompilationException("Attribute QName reference refer to an invalid attribute " +
-                            att.getRefName());
+                                                         att.getRef().getTargetQName());
                 }
             }
 
@@ -1896,10 +1975,13 @@
                     // try to get the schema for using qname
                     QName attributeSchemaQname = att.getSchemaTypeName();
                     if (attributeSchemaQname != null) {
-                        resolvedSchema = getParentSchema(parentSchema,attributeSchemaQname,COMPONENT_TYPE);
-                        if (resolvedSchema == null){
-                            throw new SchemaCompilationException("can not find the type " + attributeSchemaQname
-                              + " from the parent schema " + parentSchema.getTargetNamespace());
+                        resolvedSchema = getParentSchema(parentSchema, attributeSchemaQname,
+                                                         COMPONENT_TYPE);
+                        if (resolvedSchema == null) {
+                            throw new SchemaCompilationException("can not find the type " +
+                                                                 attributeSchemaQname
+                                                                 + " from the parent schema " +
+                                                                 parentSchema.getTargetNamespace());
                         } else {
                             attributeSimpleType = (XmlSchemaSimpleType)
                                     resolvedSchema.getTypeByName(attributeSchemaQname);
@@ -1915,20 +1997,22 @@
                             schemaTypeQName = attributeSimpleType.getQName();
                         } else {
                             schemaTypeQName = new QName(parentSchema.getTargetNamespace(),
-                                    attributeQName.getLocalPart() + getNextTypeSuffix(attributeQName.getLocalPart()));
+                                                        attributeQName.getLocalPart() +
+                                                        getNextTypeSuffix(attributeQName.getLocalPart()));
 
                         }
                     }
-                    if (!isAlreadyProcessed(schemaTypeQName)){
+                    if (!isAlreadyProcessed(schemaTypeQName)) {
                         // we have to process only if it has not processed
-                        processSimpleSchemaType(attributeSimpleType, null, resolvedSchema, schemaTypeQName);
+                        processSimpleSchemaType(attributeSimpleType, null, resolvedSchema,
+                                                schemaTypeQName);
                     }
                     metainf.registerMapping(att.getQName(),
-                            schemaTypeQName,
-                            processedTypemap.get(schemaTypeQName).toString(),
-                            SchemaConstants.ATTRIBUTE_TYPE);
+                                            schemaTypeQName,
+                                            processedTypemap.get(schemaTypeQName).toString(),
+                                            SchemaConstants.ATTRIBUTE_TYPE);
                     // add optional attribute status if set
-                    String use = att.getUse().getValue();
+                    String use = att.getUse().toString();
                     if (USE_NONE.equals(use) || USE_OPTIONAL.equals(use)) {
                         metainf.addtStatus(att.getQName(), SchemaConstants.OPTIONAL_TYPE);
                     }
@@ -1939,7 +2023,7 @@
 
             } else {
                 throw new SchemaCompilationException("Attribute QName reference refer to an invalid attribute " +
-                        attributeQName);
+                                                     attributeQName);
             }
 
         }
@@ -1947,9 +2031,10 @@
 
     /**
      * Process a particle- A particle may be a sequence,all or a choice
+     *
      * @param parentElementQName - this can either be parent element QName or parent Complex type qname
-     * @param particle - particle being processed
-     * @param metainfHolder -
+     * @param particle           - particle being processed
+     * @param metainfHolder      -
      * @param parentSchema
      * @throws SchemaCompilationException
      */
@@ -1961,88 +2046,92 @@
         if (particle instanceof XmlSchemaSequence) {
             XmlSchemaSequence xmlSchemaSequence = (XmlSchemaSequence) particle;
 
-            XmlSchemaObjectCollection items = xmlSchemaSequence.getItems();
+            List<XmlSchemaSequenceMember> items = xmlSchemaSequence.getItems();
+
             if ((xmlSchemaSequence.getMaxOccurs() > 1) && (parentElementQName != null)) {
                 // we have to process many sequence types
                 BeanWriterMetaInfoHolder beanWriterMetaInfoHolder = new BeanWriterMetaInfoHolder();
                 process(parentElementQName, items, beanWriterMetaInfoHolder, true, parentSchema);
                 beanWriterMetaInfoHolder.setParticleClass(true);
                 QName sequenceQName = new QName(parentElementQName.getNamespaceURI(),
-                         parentElementQName.getLocalPart() + "Sequence");
-                String javaClassName = writeComplexParticle(sequenceQName,beanWriterMetaInfoHolder);
+                                                parentElementQName.getLocalPart() + "Sequence");
+                String javaClassName = writeComplexParticle(sequenceQName, beanWriterMetaInfoHolder);
                 processedTypemap.put(sequenceQName, javaClassName);
 
                 // add this as an array to the original class
                 metainfHolder.registerMapping(sequenceQName,
-                        sequenceQName,
-                        findClassName(sequenceQName,true),
-                        SchemaConstants.ARRAY_TYPE);
+                                              sequenceQName,
+                                              findClassName(sequenceQName, true),
+                                              SchemaConstants.ARRAY_TYPE);
                 metainfHolder.setOrdered(true);
-                metainfHolder.registerQNameIndex(sequenceQName,metainfHolder.getOrderStartPoint() + 1);
+                metainfHolder.registerQNameIndex(sequenceQName, metainfHolder.getOrderStartPoint() + 1);
                 metainfHolder.setHasParticleType(true);
-                metainfHolder.addtStatus(sequenceQName,SchemaConstants.PARTICLE_TYPE_ELEMENT);
-                metainfHolder.addMaxOccurs(sequenceQName,xmlSchemaSequence.getMaxOccurs());
-                metainfHolder.addMinOccurs(sequenceQName,xmlSchemaSequence.getMinOccurs());
+                metainfHolder.addtStatus(sequenceQName, SchemaConstants.PARTICLE_TYPE_ELEMENT);
+                metainfHolder.addMaxOccurs(sequenceQName, xmlSchemaSequence.getMaxOccurs());
+                metainfHolder.addMinOccurs(sequenceQName, xmlSchemaSequence.getMinOccurs());
 
 
             } else {
                 if (options.isBackwordCompatibilityMode()) {
-                    process(parentElementQName,items, metainfHolder, false, parentSchema);
+                    process(parentElementQName, items, metainfHolder, false, parentSchema);
                 } else {
-                    process(parentElementQName,items, metainfHolder, true, parentSchema);
+                    process(parentElementQName, items, metainfHolder, true, parentSchema);
                 }
             }
 
         } else if (particle instanceof XmlSchemaAll) {
-            XmlSchemaObjectCollection items = ((XmlSchemaAll) particle).getItems();
-            process(parentElementQName,items, metainfHolder, false, parentSchema);
+            List<XmlSchemaElement> items = ((XmlSchemaAll) particle).getItems();
+            processSchemaAllItems(parentElementQName, items, metainfHolder, false, parentSchema);
         } else if (particle instanceof XmlSchemaChoice) {
             XmlSchemaChoice xmlSchemaChoice = (XmlSchemaChoice) particle;
-            XmlSchemaObjectCollection items = ((XmlSchemaChoice) particle).getItems();
+            List<XmlSchemaObject> items = ((XmlSchemaChoice) particle).getItems();
 
             if ((xmlSchemaChoice.getMaxOccurs() > 1)) {
                 // we have to process many sequence types
                 BeanWriterMetaInfoHolder beanWriterMetaInfoHolder = new BeanWriterMetaInfoHolder();
                 beanWriterMetaInfoHolder.setChoice(true);
-                process(parentElementQName,items, beanWriterMetaInfoHolder, false, parentSchema);
+                processChoiceItems(parentElementQName, items, beanWriterMetaInfoHolder, false,
+                                   parentSchema);
                 beanWriterMetaInfoHolder.setParticleClass(true);
                 QName choiceQName = new QName(parentElementQName.getNamespaceURI(),
-                         parentElementQName.getLocalPart() + "Choice");
-                String javaClassName = writeComplexParticle(choiceQName,beanWriterMetaInfoHolder);
+                                              parentElementQName.getLocalPart() + "Choice");
+                String javaClassName = writeComplexParticle(choiceQName, beanWriterMetaInfoHolder);
                 processedTypemap.put(choiceQName, javaClassName);
 
                 // add this as an array to the original class
                 metainfHolder.registerMapping(choiceQName,
-                        choiceQName,
-                        findClassName(choiceQName,true),
-                        SchemaConstants.ARRAY_TYPE);
+                                              choiceQName,
+                                              findClassName(choiceQName, true),
+                                              SchemaConstants.ARRAY_TYPE);
                 metainfHolder.setOrdered(true);
                 metainfHolder.setHasParticleType(true);
-                metainfHolder.registerQNameIndex(choiceQName,metainfHolder.getOrderStartPoint() + 1);
-                metainfHolder.addtStatus(choiceQName,SchemaConstants.PARTICLE_TYPE_ELEMENT);
-                metainfHolder.addMaxOccurs(choiceQName,xmlSchemaChoice.getMaxOccurs());
-                metainfHolder.addMinOccurs(choiceQName,xmlSchemaChoice.getMinOccurs());
+                metainfHolder.registerQNameIndex(choiceQName, metainfHolder.getOrderStartPoint() + 1);
+                metainfHolder.addtStatus(choiceQName, SchemaConstants.PARTICLE_TYPE_ELEMENT);
+                metainfHolder.addMaxOccurs(choiceQName, xmlSchemaChoice.getMaxOccurs());
+                metainfHolder.addMinOccurs(choiceQName, xmlSchemaChoice.getMinOccurs());
 
             } else {
                 metainfHolder.setChoice(true);
-                process(parentElementQName,items, metainfHolder, false, parentSchema);
+                processChoiceItems(parentElementQName, items, metainfHolder, false, parentSchema);
             }
 
 
-        } else if (particle instanceof XmlSchemaGroupRef){
+        } else if (particle instanceof XmlSchemaGroupRef) {
 
             XmlSchemaGroupRef xmlSchemaGroupRef = (XmlSchemaGroupRef) particle;
             QName groupQName = xmlSchemaGroupRef.getRefName();
             if (groupQName != null) {
                 if (!processedGroupTypeMap.containsKey(groupQName)) {
                     // processe the schema here
-                    XmlSchema resolvedParentSchema = getParentSchema(parentSchema,groupQName,COMPONENT_GROUP);
-                    if (resolvedParentSchema == null){
+                    XmlSchema resolvedParentSchema = getParentSchema(parentSchema, groupQName,
+                                                                     COMPONENT_GROUP);
+                    if (resolvedParentSchema == null) {
                         throw new SchemaCompilationException("can not find the group " + groupQName
-                         + " from the parent schema " + parentSchema.getTargetNamespace());
+                                                             + " from the parent schema " +
+                                                             parentSchema.getTargetNamespace());
                     } else {
-                        XmlSchemaGroup xmlSchemaGroup = (XmlSchemaGroup)
-                                resolvedParentSchema.getGroups().getItem(groupQName);
+                        XmlSchemaGroup xmlSchemaGroup =
+                                resolvedParentSchema.getGroups().get(groupQName);
                         processGroup(xmlSchemaGroup, groupQName, resolvedParentSchema);
                     }
                 }
@@ -2053,7 +2142,7 @@
 
             // add this as an array to the original class
             String groupClassName = processedGroupTypeMap.get(groupQName);
-            if (isArray){
+            if (isArray) {
                 groupClassName = groupClassName + "[]";
             }
             metainfHolder.registerMapping(groupQName, groupQName, groupClassName);
@@ -2065,13 +2154,12 @@
             metainfHolder.addMinOccurs(groupQName, xmlSchemaGroupRef.getMinOccurs());
             metainfHolder.setHasParticleType(true);
             metainfHolder.setOrdered(true);
-            metainfHolder.registerQNameIndex(groupQName,metainfHolder.getOrderStartPoint() + 1);
+            metainfHolder.registerQNameIndex(groupQName, metainfHolder.getOrderStartPoint() + 1);
 
         }
     }
 
     /**
-     *
      * @param parentElementQName - this could either be the complex type parentElementQName or element parentElementQName
      * @param items
      * @param metainfHolder
@@ -2080,137 +2168,118 @@
      * @throws SchemaCompilationException
      */
     private void process(QName parentElementQName,
-                         XmlSchemaObjectCollection items,
+                         List<XmlSchemaSequenceMember> items,
                          BeanWriterMetaInfoHolder metainfHolder,
                          boolean order,
                          XmlSchema parentSchema) throws SchemaCompilationException {
-        int count = items.getCount();
-        Map<XmlSchemaObject,Boolean> processedElementArrayStatusMap = new LinkedHashMap<XmlSchemaObject,Boolean>();
+
+        Map<XmlSchemaObject, Boolean> processedElementArrayStatusMap =
+                new LinkedHashMap<XmlSchemaObject, Boolean>();
         Map processedElementTypeMap = new LinkedHashMap(); // TODO: not sure what is the correct generic type here
         List<QName> localNillableList = new ArrayList<QName>();
 
-        Map<XmlSchemaObject,QName> particleQNameMap = new HashMap<XmlSchemaObject,QName>();
+        Map<XmlSchemaObject, QName> particleQNameMap = new HashMap<XmlSchemaObject, QName>();
 
         // this list is used to keep the details of the
         // elements within a choice withing sequence
         List<QName> innerChoiceElementList = new ArrayList<QName>();
 
-        Map<XmlSchemaObject,Integer> elementOrderMap = new HashMap<XmlSchemaObject,Integer>();
+        Map<XmlSchemaObject, Integer> elementOrderMap = new HashMap<XmlSchemaObject, Integer>();
 
         int sequenceCounter = 0;
-        for (int i = 0; i < count; i++) {
-            XmlSchemaObject item = items.getItem(i);
+        for (XmlSchemaSequenceMember member : items) {
+            XmlSchemaObject item = (XmlSchemaObject) member;
+            //recursively process the element
+            processElements(parentElementQName, item, processedElementArrayStatusMap,
+                            processedElementTypeMap, elementOrderMap, localNillableList,
+                            particleQNameMap, order, sequenceCounter, parentSchema);
+            sequenceCounter++;
+        }
 
-            if (item instanceof XmlSchemaElement) {
-                //recursively process the element
-                XmlSchemaElement xsElt = (XmlSchemaElement) item;
+        addProcessedItemsToMetaInfoHolder(processedElementArrayStatusMap, processedElementTypeMap,
+                                          innerChoiceElementList, elementOrderMap, localNillableList,
+                                          particleQNameMap, metainfHolder, order, parentSchema);
+    }
 
-                boolean isArray = isArray(xsElt);
-                processElement(xsElt, processedElementTypeMap, localNillableList, parentSchema); //we know for sure this is not an outer type
-                processedElementArrayStatusMap.put(xsElt, isArray);
-                if (order) {
-                    //we need to keep the order of the elements. So push the elements to another
-                    //hashmap with the order number
-                    elementOrderMap.put(xsElt, sequenceCounter);
-                }
+    private void processChoiceItems(QName parentElementQName,
+                                    List<XmlSchemaObject> items,
+                                    BeanWriterMetaInfoHolder metainfHolder,
+                                    boolean order,
+                                    XmlSchema parentSchema) throws SchemaCompilationException {
 
-                //handle xsd:any ! We place an OMElement (or an array of OMElements) in the generated class
-            } else if (item instanceof XmlSchemaAny) {
-                XmlSchemaAny any = (XmlSchemaAny) item;
-                processedElementTypeMap.put(new QName(ANY_ELEMENT_FIELD_NAME), any);
-                //any can also be inside a sequence
-                if (order) {
-                    elementOrderMap.put(any, new Integer(sequenceCounter));
-                }
-                //we do not register the array status for the any type
-                processedElementArrayStatusMap.put(any, isArray(any));
-            } else if (item instanceof XmlSchemaSequence) {
-                // we have to process many sequence types
+        Map<XmlSchemaObject, Boolean> processedElementArrayStatusMap =
+                new LinkedHashMap<XmlSchemaObject, Boolean>();
+        Map processedElementTypeMap = new LinkedHashMap(); // TODO: not sure what is the correct generic type here
+        List<QName> localNillableList = new ArrayList<QName>();
 
-                XmlSchemaSequence xmlSchemaSequence = (XmlSchemaSequence) item;
-                if (xmlSchemaSequence.getItems().getCount() > 0) {
-                    BeanWriterMetaInfoHolder beanWriterMetaInfoHolder = new BeanWriterMetaInfoHolder();
-                    process(parentElementQName, xmlSchemaSequence.getItems(), beanWriterMetaInfoHolder, true, parentSchema);
-                    beanWriterMetaInfoHolder.setParticleClass(true);
-                    String localName = parentElementQName.getLocalPart() + "Sequence";
-                    QName sequenceQName = new QName(parentElementQName.getNamespaceURI(),
-                            localName + getNextTypeSuffix(localName));
-                    String javaClassName = writeComplexParticle(sequenceQName, beanWriterMetaInfoHolder);
-                    processedTypemap.put(sequenceQName, javaClassName);
+        Map<XmlSchemaObject, QName> particleQNameMap = new HashMap<XmlSchemaObject, QName>();
 
-                    //put the partical to array
-                    Boolean isArray = xmlSchemaSequence.getMaxOccurs() > 1 ? Boolean.TRUE : Boolean.FALSE;
-                    processedElementArrayStatusMap.put(item, isArray);
-                    particleQNameMap.put(item, sequenceQName);
+        // this list is used to keep the details of the
+        // elements within a choice withing sequence
+        List<QName> innerChoiceElementList = new ArrayList<QName>();
 
-                    if (order) {
-                        elementOrderMap.put(item, new Integer(sequenceCounter));
-                    }
-                }
+        Map<XmlSchemaObject, Integer> elementOrderMap = new HashMap<XmlSchemaObject, Integer>();
 
-            } else if (item instanceof XmlSchemaChoice) {
-                // we have to process many sequence types
+        int sequenceCounter = 0;
+        for (XmlSchemaObject item : items) {
+            //recursively process the element
+            processElements(parentElementQName, item, processedElementArrayStatusMap,
+                            processedElementTypeMap, elementOrderMap, localNillableList,
+                            particleQNameMap, order, sequenceCounter, parentSchema);
+            sequenceCounter++;
+        }
+        addProcessedItemsToMetaInfoHolder(processedElementArrayStatusMap, processedElementTypeMap,
+                                          innerChoiceElementList, elementOrderMap, localNillableList,
+                                          particleQNameMap, metainfHolder, order, parentSchema);
 
-                XmlSchemaChoice xmlSchemaChoice = (XmlSchemaChoice) item;
-                if (xmlSchemaChoice.getItems().getCount() > 0) {
-                    BeanWriterMetaInfoHolder beanWriterMetaInfoHolder = new BeanWriterMetaInfoHolder();
-                    beanWriterMetaInfoHolder.setChoice(true);
-                    process(parentElementQName, xmlSchemaChoice.getItems(), beanWriterMetaInfoHolder, false, parentSchema);
-                    beanWriterMetaInfoHolder.setParticleClass(true);
-                    String localName = parentElementQName.getLocalPart() + "Choice";
-                    QName choiceQName = new QName(parentElementQName.getNamespaceURI(),
-                            localName + getNextTypeSuffix(localName));
-                    String javaClassName = writeComplexParticle(choiceQName, beanWriterMetaInfoHolder);
-                    processedTypemap.put(choiceQName, javaClassName);
+    }
 
-                    //put the partical to array
-                    Boolean isArray = xmlSchemaChoice.getMaxOccurs() > 1 ? Boolean.TRUE : Boolean.FALSE;
-                    processedElementArrayStatusMap.put(item, isArray);
-                    particleQNameMap.put(item, choiceQName);
 
-                    if (order) {
-                        elementOrderMap.put(item, new Integer(sequenceCounter));
-                    }
-                }
+    private void processSchemaAllItems(QName parentElementQName,
+                                       List<XmlSchemaElement> items,
+                                       BeanWriterMetaInfoHolder metainfHolder,
+                                       boolean order,
+                                       XmlSchema parentSchema) throws SchemaCompilationException {
 
-            } else if (item instanceof XmlSchemaGroupRef) {
+        Map<XmlSchemaObject, Boolean> processedElementArrayStatusMap =
+                new LinkedHashMap<XmlSchemaObject, Boolean>();
+        Map processedElementTypeMap = new LinkedHashMap(); // TODO: not sure what is the correct generic type here
+        List<QName> localNillableList = new ArrayList<QName>();
 
-                XmlSchemaGroupRef xmlSchemaGroupRef = (XmlSchemaGroupRef) item;
-                QName groupQName = xmlSchemaGroupRef.getRefName();
-                if (groupQName != null){
-                    if (!processedGroupTypeMap.containsKey(groupQName)){
-                        // processe the schema here
-                        XmlSchema resolvedParentSchema = getParentSchema(parentSchema,groupQName,COMPONENT_GROUP);
-                        if (resolvedParentSchema == null){
-                            throw new SchemaCompilationException("Can not find the group with the qname" +
-                                    groupQName + " from the parent schema " + parentSchema.getTargetNamespace());
-                        } else {
-                            XmlSchemaGroup xmlSchemaGroup =
-                                    (XmlSchemaGroup) resolvedParentSchema.getGroups().getItem(groupQName);
-                            if (xmlSchemaGroup != null){
-                                processGroup(xmlSchemaGroup, groupQName, resolvedParentSchema);
-                            }
-                        }
-                    }
+        Map<XmlSchemaObject, QName> particleQNameMap = new HashMap<XmlSchemaObject, QName>();
 
-                    Boolean isArray = xmlSchemaGroupRef.getMaxOccurs() > 1 ? Boolean.TRUE : Boolean.FALSE;
-                    processedElementArrayStatusMap.put(item,isArray);
-                    particleQNameMap.put(item,groupQName);
+        // this list is used to keep the details of the
+        // elements within a choice withing sequence
+        List<QName> innerChoiceElementList = new ArrayList<QName>();
 
-                    if (order){
-                        elementOrderMap.put(item, new Integer(sequenceCounter));
-                    }
+        Map<XmlSchemaObject, Integer> elementOrderMap = new HashMap<XmlSchemaObject, Integer>();
 
-                } else {
-                    throw new SchemaCompilationException("Referenced name is null");
-                }
-            } else {
-                //there may be other types to be handled here. Add them
-                //when we are ready
-            }
-          sequenceCounter++;
+        int sequenceCounter = 0;
+        for (XmlSchemaObject item : items) {
+            //recursively process the element
+            processElements(parentElementQName, item, processedElementArrayStatusMap,
+                            processedElementTypeMap, elementOrderMap, localNillableList,
+                            particleQNameMap, order, sequenceCounter, parentSchema);
+            sequenceCounter++;
         }
+        addProcessedItemsToMetaInfoHolder(processedElementArrayStatusMap, processedElementTypeMap,
+                                          innerChoiceElementList, elementOrderMap, localNillableList,
+                                          particleQNameMap, metainfHolder, order, parentSchema);
 
+    }
+
+
+    private void addProcessedItemsToMetaInfoHolder(
+            Map<XmlSchemaObject, Boolean> processedElementArrayStatusMap,
+            Map processedElementTypeMap,
+            List<QName> innerChoiceElementList,
+            Map<XmlSchemaObject, Integer> elementOrderMap,
+            List<QName> localNillableList,
+            Map<XmlSchemaObject, QName> particleQNameMap,
+            BeanWriterMetaInfoHolder metainfHolder,
+            boolean order,
+            XmlSchema parentSchema) throws SchemaCompilationException {
+
         // loop through the processed items and add them to the matainf object
         int startingItemNumberOrder = metainfHolder.getOrderStartPoint();
         for (XmlSchemaObject child : processedElementArrayStatusMap.keySet()) {
@@ -2220,44 +2289,48 @@
                 XmlSchemaElement elt = (XmlSchemaElement) child;
                 QName referencedQName = null;
 
-
                 if (elt.getQName() != null) {
                     referencedQName = elt.getQName();
-                    QName schemaTypeQName = elt.getSchemaType() != null ? elt.getSchemaType().getQName() : elt.getSchemaTypeName();
+                    QName schemaTypeQName = elt.getSchemaType() != null ?
+                                            elt.getSchemaType().getQName() : elt.getSchemaTypeName();
                     if (schemaTypeQName != null) {
                         String clazzName = (String) processedElementTypeMap.get(elt.getQName());
                         metainfHolder.registerMapping(referencedQName,
-                                schemaTypeQName,
-                                clazzName,
-                                processedElementArrayStatusMap.get(elt) ?
-                                        SchemaConstants.ARRAY_TYPE :
-                                        SchemaConstants.ELEMENT_TYPE);
-                        if (innerChoiceElementList.contains(referencedQName)){
-                            metainfHolder.addtStatus(referencedQName,SchemaConstants.INNER_CHOICE_ELEMENT);
+                                                      schemaTypeQName,
+                                                      clazzName,
+                                                      processedElementArrayStatusMap.get(elt) ?
+                                                      SchemaConstants.ARRAY_TYPE :
+                                                      SchemaConstants.ELEMENT_TYPE);
+                        if (innerChoiceElementList.contains(referencedQName)) {
+                            metainfHolder.addtStatus(referencedQName,
+                                                     SchemaConstants.INNER_CHOICE_ELEMENT);
                         }
                         // register the default value as well
-                        if (elt.getDefaultValue() != null){
-                           metainfHolder.registerDefaultValue(referencedQName,elt.getDefaultValue());
+                        if (elt.getDefaultValue() != null) {
+                            metainfHolder.registerDefaultValue(referencedQName, elt.getDefaultValue());
                         }
-                     // register the default value as well
-                        if (elt.getFixedValue() != null){
-                           metainfHolder.registerDefaultValue(referencedQName,elt.getFixedValue());
-                           metainfHolder.setFixed(true);
+                        // register the default value as well
+                        if (elt.getFixedValue() != null) {
+                            metainfHolder.registerDefaultValue(referencedQName, elt.getFixedValue());
+                            metainfHolder.setFixed(true);
                         }
                     }
                 }
 
-                if (elt.getRefName() != null) { //probably this is referenced
-                    referencedQName = elt.getRefName();
+                if (elt.getRef().getTargetQName() != null) { //probably this is referenced
+                    referencedQName = elt.getRef().getTargetQName();
                     boolean arrayStatus = processedElementArrayStatusMap.get(elt);
                     String clazzName = findRefClassName(referencedQName, arrayStatus);
                     if (clazzName == null) {
                         clazzName = findClassName(referencedQName, arrayStatus);
                     }
-                    XmlSchema resolvedParentSchema = getParentSchema(parentSchema,referencedQName,COMPONENT_ELEMENT);
+                    XmlSchema resolvedParentSchema = getParentSchema(parentSchema, referencedQName,
+                                                                     COMPONENT_ELEMENT);
                     if (resolvedParentSchema == null) {
-                        throw new SchemaCompilationException("Can not find the element " + referencedQName +
-                                " from the parent schema " + parentSchema.getTargetNamespace());
+                        throw new SchemaCompilationException("Can not find the element " +
+                                                             referencedQName +
+                                                             " from the parent schema " +
+                                                             parentSchema.getTargetNamespace());
                     } else {
                         XmlSchemaElement refElement = resolvedParentSchema.getElementByName(referencedQName);
 
@@ -2265,32 +2338,35 @@
                         // else throw an exception
                         if (refElement != null) {
                             metainfHolder.registerMapping(referencedQName,
-                                    refElement.getSchemaTypeName()
+                                                          refElement.getSchemaTypeName()
                                     , clazzName,
-                                    arrayStatus ?
-                                            SchemaConstants.ARRAY_TYPE :
-                                            SchemaConstants.ELEMENT_TYPE);
+                                                          arrayStatus ?
+                                                          SchemaConstants.ARRAY_TYPE :
+                                                          SchemaConstants.ELEMENT_TYPE);
                         } else {
                             if (referencedQName.equals(SchemaConstants.XSD_SCHEMA)) {
                                 metainfHolder.registerMapping(referencedQName,
-                                        null,
-                                        writer.getDefaultClassName(),
-                                        SchemaConstants.ANY_TYPE);
+                                                              null,
+                                                              writer.getDefaultClassName(),
+                                                              SchemaConstants.ANY_TYPE);
                             } else {
-                                throw new SchemaCompilationException(SchemaCompilerMessages.getMessage("schema.referencedElementNotFound", referencedQName.toString()));
+                                throw new SchemaCompilationException(SchemaCompilerMessages.
+                                        getMessage("schema.referencedElementNotFound",
+                                                   referencedQName.toString()));
                             }
                         }
                     }
                 }
 
                 if (referencedQName == null) {
-                    throw new SchemaCompilationException(SchemaCompilerMessages.getMessage("schema.emptyName"));
+                    throw new SchemaCompilationException(SchemaCompilerMessages.
+                            getMessage("schema.emptyName"));
                 }
 
                 //register the occurence counts
                 metainfHolder.addMaxOccurs(referencedQName, elt.getMaxOccurs());
                 // if the strict validation off then we consider all elements have minOccurs zero on it
-                if (this.options.isOffStrictValidation()){
+                if (this.options.isOffStrictValidation()) {
                     metainfHolder.addMinOccurs(referencedQName, 0);
                 } else {
                     metainfHolder.addMinOccurs(referencedQName, elt.getMinOccurs());
@@ -2299,7 +2375,8 @@
                 if (order) {
                     //record the order in the metainf holder
                     metainfHolder.registerQNameIndex(referencedQName,
-                            startingItemNumberOrder + elementOrderMap.get(elt));
+                                                     startingItemNumberOrder +
+                                                     elementOrderMap.get(elt));
                 }
 
                 //get the nillable state and register that on the metainf holder
@@ -2310,7 +2387,7 @@
                 //get the binary state and add that to the status map
                 if (isBinary(elt)) {
                     metainfHolder.addtStatus(elt.getQName(),
-                            SchemaConstants.BINARY_TYPE);
+                                             SchemaConstants.BINARY_TYPE);
                 }
                 // process the XMLSchemaAny
             } else if (child instanceof XmlSchemaAny) {
@@ -2324,13 +2401,14 @@
                 //this can be an array or a single element
                 boolean isArray = processedElementArrayStatusMap.get(any);
                 metainfHolder.registerMapping(anyElementFieldName,
-                        null,
-                        isArray ? writer.getDefaultClassArrayName() : writer.getDefaultClassName(),
-                        SchemaConstants.ANY_TYPE);
+                                              null,
+                                              isArray ? writer.getDefaultClassArrayName() : writer.
+                                                      getDefaultClassName(),
+                                              SchemaConstants.ANY_TYPE);
                 //if it's an array register an extra status flag with the system
                 if (isArray) {
                     metainfHolder.addtStatus(anyElementFieldName,
-                            SchemaConstants.ARRAY_TYPE);
+                                             SchemaConstants.ARRAY_TYPE);
                 }
                 metainfHolder.addMaxOccurs(anyElementFieldName, any.getMaxOccurs());
                 metainfHolder.addMinOccurs(anyElementFieldName, any.getMinOccurs());
@@ -2338,7 +2416,8 @@
                 if (order) {
                     //record the order in the metainf holder for the any
                     metainfHolder.registerQNameIndex(anyElementFieldName,
-                            startingItemNumberOrder + elementOrderMap.get(any));
+                                                     startingItemNumberOrder +
+                                                     elementOrderMap.get(any));
                 }
             } else if (child instanceof XmlSchemaSequence) {
                 XmlSchemaSequence xmlSchemaSequence = (XmlSchemaSequence) child;
@@ -2347,8 +2426,8 @@
 
                 // add this as an array to the original class
                 metainfHolder.registerMapping(sequenceQName,
-                        sequenceQName,
-                        findClassName(sequenceQName, isArray));
+                                              sequenceQName,
+                                              findClassName(sequenceQName, isArray));
                 if (isArray) {
                     metainfHolder.addtStatus(sequenceQName, SchemaConstants.ARRAY_TYPE);
                 }
@@ -2360,7 +2439,8 @@
                 if (order) {
                     //record the order in the metainf holder for the any
                     metainfHolder.registerQNameIndex(sequenceQName,
-                            startingItemNumberOrder + elementOrderMap.get(child));
+                                                     startingItemNumberOrder +
+                                                     elementOrderMap.get(child));
                 }
             } else if (child instanceof XmlSchemaChoice) {
                 XmlSchemaChoice xmlSchemaChoice = (XmlSchemaChoice) child;
@@ -2369,8 +2449,8 @@
 
                 // add this as an array to the original class
                 metainfHolder.registerMapping(choiceQName,
-                        choiceQName,
-                        findClassName(choiceQName, isArray));
+                                              choiceQName,
+                                              findClassName(choiceQName, isArray));
                 if (isArray) {
                     metainfHolder.addtStatus(choiceQName, SchemaConstants.ARRAY_TYPE);
                 }
@@ -2382,7 +2462,8 @@
                 if (order) {
                     //record the order in the metainf holder for the any
                     metainfHolder.registerQNameIndex(choiceQName,
-                            startingItemNumberOrder + elementOrderMap.get(child));
+                                                     startingItemNumberOrder +
+                                                     elementOrderMap.get(child));
                 }
             } else if (child instanceof XmlSchemaGroupRef) {
                 XmlSchemaGroupRef xmlSchemaGroupRef = (XmlSchemaGroupRef) child;
@@ -2391,12 +2472,12 @@
 
                 // add this as an array to the original class
                 String groupClassName = processedGroupTypeMap.get(groupQName);
-                if (isArray){
+                if (isArray) {
                     groupClassName = groupClassName + "[]";
                 }
                 metainfHolder.registerMapping(groupQName,
-                        groupQName,
-                        groupClassName);
+                                              groupQName,
+                                              groupClassName);
                 if (isArray) {
                     metainfHolder.addtStatus(groupQName, SchemaConstants.ARRAY_TYPE);
                 }
@@ -2408,20 +2489,145 @@
                 if (order) {
                     //record the order in the metainf holder for the any
                     metainfHolder.registerQNameIndex(groupQName,
-                            startingItemNumberOrder + elementOrderMap.get(child));
+                                                     startingItemNumberOrder +
+                                                     elementOrderMap.get(child));
                 }
             }
         }
 
         //set the ordered flag in the metainf holder
         metainfHolder.setOrdered(order);
+
     }
 
+    private void processElements(QName parentElementQName, XmlSchemaObject item,
+                                 Map<XmlSchemaObject, Boolean> processedElementArrayStatusMap,
+                                 Map processedElementTypeMap,
+                                 Map<XmlSchemaObject, Integer> elementOrderMap,
+                                 List<QName> localNillableList,
+                                 Map<XmlSchemaObject, QName> particleQNameMap,
+                                 boolean order, int sequenceCounter,
+                                 XmlSchema parentSchema) throws SchemaCompilationException {
+
+        if (item instanceof XmlSchemaElement) {
+            //recursively process the element
+            XmlSchemaElement xsElt = (XmlSchemaElement) item;
+
+            boolean isArray = isArray(xsElt);
+            processElement(xsElt, processedElementTypeMap, localNillableList, parentSchema); //we know for sure this is not an outer type
+            processedElementArrayStatusMap.put(xsElt, isArray);
+            if (order) {
+                //we need to keep the order of the elements. So push the elements to another
+                //hashmap with the order number
+                elementOrderMap.put(xsElt, sequenceCounter);
+            }
+
+            //handle xsd:any ! We place an OMElement (or an array of OMElements) in the generated class
+        } else if (item instanceof XmlSchemaAny) {
+            XmlSchemaAny any = (XmlSchemaAny) item;
+            processedElementTypeMap.put(new QName(ANY_ELEMENT_FIELD_NAME), any);
+            //any can also be inside a sequence
+            if (order) {
+                elementOrderMap.put(any, new Integer(sequenceCounter));
+            }
+            //we do not register the array status for the any type
+            processedElementArrayStatusMap.put(any, isArray(any));
+        } else if (item instanceof XmlSchemaSequence) {
+            // we have to process many sequence types
+
+            XmlSchemaSequence xmlSchemaSequence = (XmlSchemaSequence) item;
+            if (xmlSchemaSequence.getItems().size() > 0) {
+                BeanWriterMetaInfoHolder beanWriterMetaInfoHolder = new BeanWriterMetaInfoHolder();
+                process(parentElementQName, xmlSchemaSequence.getItems(), beanWriterMetaInfoHolder,
+                        true, parentSchema);
+                beanWriterMetaInfoHolder.setParticleClass(true);
+                String localName = parentElementQName.getLocalPart() + "Sequence";
+                QName sequenceQName = new QName(parentElementQName.getNamespaceURI(),
+                                                localName + getNextTypeSuffix(localName));
+                String javaClassName = writeComplexParticle(sequenceQName, beanWriterMetaInfoHolder);
+                processedTypemap.put(sequenceQName, javaClassName);
+
+                //put the partical to array
+                Boolean isArray = xmlSchemaSequence.getMaxOccurs() > 1 ? Boolean.TRUE : Boolean.FALSE;
+                processedElementArrayStatusMap.put(item, isArray);
+                particleQNameMap.put(item, sequenceQName);
+
+                if (order) {
+                    elementOrderMap.put(item, new Integer(sequenceCounter));
+                }
+            }
+
+        } else if (item instanceof XmlSchemaChoice) {
+            // we have to process many sequence types
+
+            XmlSchemaChoice xmlSchemaChoice = (XmlSchemaChoice) item;
+            if (xmlSchemaChoice.getItems().size() > 0) {
+                BeanWriterMetaInfoHolder beanWriterMetaInfoHolder = new BeanWriterMetaInfoHolder();
+                beanWriterMetaInfoHolder.setChoice(true);
+                processChoiceItems(parentElementQName, xmlSchemaChoice.getItems(),
+                                   beanWriterMetaInfoHolder, false, parentSchema);
+                beanWriterMetaInfoHolder.setParticleClass(true);
+                String localName = parentElementQName.getLocalPart() + "Choice";
+                QName choiceQName = new QName(parentElementQName.getNamespaceURI(),
+                                              localName + getNextTypeSuffix(localName));
+                String javaClassName = writeComplexParticle(choiceQName, beanWriterMetaInfoHolder);
+                processedTypemap.put(choiceQName, javaClassName);
+
+                //put the partical to array
+                Boolean isArray = xmlSchemaChoice.getMaxOccurs() > 1 ? Boolean.TRUE : Boolean.FALSE;
+                processedElementArrayStatusMap.put(item, isArray);
+                particleQNameMap.put(item, choiceQName);
+
+                if (order) {
+                    elementOrderMap.put(item, new Integer(sequenceCounter));
+                }
+            }
+
+        } else if (item instanceof XmlSchemaGroupRef) {
+
+            XmlSchemaGroupRef xmlSchemaGroupRef = (XmlSchemaGroupRef) item;
+            QName groupQName = xmlSchemaGroupRef.getRefName();
+            if (groupQName != null) {
+                if (!processedGroupTypeMap.containsKey(groupQName)) {
+                    // processe the schema here
+                    XmlSchema resolvedParentSchema = getParentSchema(parentSchema, groupQName,
+                                                                     COMPONENT_GROUP);
+                    if (resolvedParentSchema == null) {
+                        throw new SchemaCompilationException("Can not find the group with the qname" +
+                                                             groupQName + " from the parent schema " +
+                                                             parentSchema.getTargetNamespace());
+                    } else {
+                        XmlSchemaGroup xmlSchemaGroup =
+                                (XmlSchemaGroup) resolvedParentSchema.getGroups().get(groupQName);
+                        if (xmlSchemaGroup != null) {
+                            processGroup(xmlSchemaGroup, groupQName, resolvedParentSchema);
+                        }
+                    }
+                }
+
+                Boolean isArray = xmlSchemaGroupRef.getMaxOccurs() > 1 ? Boolean.TRUE : Boolean.FALSE;
+                processedElementArrayStatusMap.put(item, isArray);
+                particleQNameMap.put(item, groupQName);
+
+                if (order) {
+                    elementOrderMap.put(item, new Integer(sequenceCounter));
+                }
+
+            } else {
+                throw new SchemaCompilationException("Referenced name is null");
+            }
+        } else {
+            //there may be other types to be handled here. Add them
+            //when we are ready
+        }
+
+    }
+
+
     /**
-     *
      * @param xmlSchemaGroup
      * @param schemaGroupQName- we have to pass this since xml schema does not provide
-     * this properly
+     *                          this properly
      * @param parentSchema
      * @throws SchemaCompilationException
      */
@@ -2431,27 +2637,31 @@
                               XmlSchema parentSchema) throws SchemaCompilationException {
 
         // find the group base item
-        XmlSchemaGroupBase xmlSchemaGroupBase = xmlSchemaGroup.getParticle();
-        if (xmlSchemaGroupBase != null){
-            if (xmlSchemaGroupBase instanceof XmlSchemaSequence){
-                XmlSchemaSequence xmlSchemaSequence = (XmlSchemaSequence) xmlSchemaGroupBase;
-                if (xmlSchemaSequence.getItems().getCount() > 0) {
+        XmlSchemaGroupParticle xmlSchemaGroupParticle = xmlSchemaGroup.getParticle();
+        if (xmlSchemaGroupParticle != null) {
+            if (xmlSchemaGroupParticle instanceof XmlSchemaSequence) {
+                XmlSchemaSequence xmlSchemaSequence = (XmlSchemaSequence) xmlSchemaGroupParticle;
+                if (xmlSchemaSequence.getItems().size() > 0) {
                     BeanWriterMetaInfoHolder beanWriterMetaInfoHolder = new BeanWriterMetaInfoHolder();
-                    process(schemaGroupQName, xmlSchemaSequence.getItems(), beanWriterMetaInfoHolder, true, parentSchema);
+                    process(schemaGroupQName, xmlSchemaSequence.getItems(), beanWriterMetaInfoHolder,
+                            true, parentSchema);
                     beanWriterMetaInfoHolder.setParticleClass(true);
-                    String javaClassName = writeComplexParticle(schemaGroupQName, beanWriterMetaInfoHolder);
+                    String javaClassName = writeComplexParticle(schemaGroupQName,
+                                                                beanWriterMetaInfoHolder);
                     processedGroupTypeMap.put(schemaGroupQName, javaClassName);
 //                    processedTypemap.put(schemaGroupQName, javaClassName);
                 }
 
-            } else if (xmlSchemaGroupBase instanceof XmlSchemaChoice){
-                XmlSchemaChoice xmlSchemaChoice = (XmlSchemaChoice) xmlSchemaGroupBase;
-                if (xmlSchemaChoice.getItems().getCount() > 0) {
+            } else if (xmlSchemaGroupParticle instanceof XmlSchemaChoice) {
+                XmlSchemaChoice xmlSchemaChoice = (XmlSchemaChoice) xmlSchemaGroupParticle;
+                if (xmlSchemaChoice.getItems().size() > 0) {
                     BeanWriterMetaInfoHolder beanWriterMetaInfoHolder = new BeanWriterMetaInfoHolder();
                     beanWriterMetaInfoHolder.setChoice(true);
-                    process(schemaGroupQName, xmlSchemaChoice.getItems(), beanWriterMetaInfoHolder, false, parentSchema);
+                    processChoiceItems(schemaGroupQName, xmlSchemaChoice.getItems(),
+                                       beanWriterMetaInfoHolder, false, parentSchema);
                     beanWriterMetaInfoHolder.setParticleClass(true);
-                    String javaClassName = writeComplexParticle(schemaGroupQName, beanWriterMetaInfoHolder);
+                    String javaClassName = writeComplexParticle(schemaGroupQName,
+                                                                beanWriterMetaInfoHolder);
                     processedGroupTypeMap.put(schemaGroupQName, javaClassName);
 //                    processedTypemap.put(schemaGroupQName, javaClassName);
                 }
@@ -2466,7 +2676,7 @@
      */
     private boolean isBinary(XmlSchemaElement elt) {
         return elt.getSchemaType() != null &&
-                SchemaConstants.XSD_BASE64.equals(elt.getSchemaType().getQName());
+               SchemaConstants.XSD_BASE64.equals(elt.getSchemaType().getQName());
     }
 
     /**
@@ -2476,7 +2686,7 @@
      */
     private boolean isBinary(QName qName) {
         return qName != null &&
-                SchemaConstants.XSD_BASE64.equals(qName);
+               SchemaConstants.XSD_BASE64.equals(qName);
     }
 
     /**
@@ -2494,7 +2704,7 @@
         String fullyQualifiedClassName = null;
         if (simpleType.getQName() != null) {
             if (processedTypemap.containsKey(simpleType.getQName())
-                    || baseSchemaTypeMap.containsKey(simpleType.getQName())) {
+                || baseSchemaTypeMap.containsKey(simpleType.getQName())) {
                 return;
             }
 
@@ -2507,7 +2717,9 @@
 
             QName fakeQname;
             if (xsElt != null) {
-                fakeQname = new QName(xsElt.getQName().getNamespaceURI(), xsElt.getQName().getLocalPart() + getNextTypeSuffix(xsElt.getQName().getLocalPart()));
+                fakeQname = new QName(xsElt.getQName().getNamespaceURI(),
+                                      xsElt.getQName().getLocalPart() +
+                                      getNextTypeSuffix(xsElt.getQName().getLocalPart()));
                 // we have to set this otherwise the ours attribute would not set properly if refered to this simple
                 // type from any other element
                 xsElt.setSchemaTypeName(fakeQname);
@@ -2517,7 +2729,7 @@
                 fakeQname = qname;
             }
             if (processedTypemap.containsKey(fakeQname)
-                    || baseSchemaTypeMap.containsKey(fakeQname)) {
+                || baseSchemaTypeMap.containsKey(fakeQname)) {
                 return;
             }
             fullyQualifiedClassName = writer.makeFullyQualifiedClassName(fakeQname);
@@ -2529,7 +2741,7 @@
 
         //register that in the schema metainfo bag
         simpleType.addMetaInfo(SchemaConstants.SchemaCompilerInfoHolder.CLASSNAME_KEY,
-                fullyQualifiedClassName);
+                               fullyQualifiedClassName);
 
         BeanWriterMetaInfoHolder metaInfHolder = processSimpleType(simpleType, parentSchema);
         metaInfHolder.setSimple(true);
@@ -2538,7 +2750,8 @@
             this.processedAnonymousComplexTypesMap.put(xsElt, metaInfHolder);
             QName fakeQname;
             if (xsElt != null) {
-                fakeQname = new QName(xsElt.getQName().getNamespaceURI(), xsElt.getQName().getLocalPart());
+                fakeQname = new QName(xsElt.getQName().getNamespaceURI(),
+                                      xsElt.getQName().getLocalPart());
             } else {
                 fakeQname = qname;
                 simpleType.setName(fakeQname.getLocalPart());
@@ -2557,14 +2770,17 @@
         writeSimpleType(simpleType, metaInfHolder);
     }
 
-    private BeanWriterMetaInfoHolder processSimpleType(XmlSchemaSimpleType simpleType, XmlSchema parentSchema) throws SchemaCompilationException {
+    private BeanWriterMetaInfoHolder processSimpleType(XmlSchemaSimpleType simpleType,
+                                                       XmlSchema parentSchema)
+            throws SchemaCompilationException {
         BeanWriterMetaInfoHolder metaInfHolder = new BeanWriterMetaInfoHolder();
 
         // handle the restriction
         XmlSchemaSimpleTypeContent content = simpleType.getContent();
         QName parentSimpleTypeQname = simpleType.getQName();
         if (parentSimpleTypeQname == null) {
-            parentSimpleTypeQname = (QName) simpleType.getMetaInfoMap().get(SchemaConstants.SchemaCompilerInfoHolder.FAKE_QNAME);
+            parentSimpleTypeQname = (QName) simpleType.getMetaInfoMap().
+                    get(SchemaConstants.SchemaCompilerInfoHolder.FAKE_QNAME);
         }
         if (content != null) {
             if (content instanceof XmlSchemaSimpleTypeRestriction) {
@@ -2576,29 +2792,35 @@
                 if (baseSchemaTypeMap.containsKey(baseTypeName)) {
                     //process restriction base type
 
-                    processSimpleRestrictionBaseType(parentSimpleTypeQname, restriction.getBaseTypeName(), metaInfHolder, parentSchema);
+                    processSimpleRestrictionBaseType(parentSimpleTypeQname,
+                                                     restriction.getBaseTypeName(), metaInfHolder,
+                                                     parentSchema);
                     //process facets
-                    if (!SchemaConstants.XSD_BOOLEAN.equals(baseTypeName)){
-                        processFacets(restriction.getFacets(), restriction.getBaseTypeName(), metaInfHolder, parentSchema);
+                    if (!SchemaConstants.XSD_BOOLEAN.equals(baseTypeName)) {
+                        processFacets(restriction.getFacets(), restriction.getBaseTypeName(),
+                                      metaInfHolder, parentSchema);
                     }
                 } else {
                     //recurse
                     // this must be a xmlschema bug
                     // it should return the schematype for restriction.getBaseType():
-                    XmlSchema resolvedSchema = getParentSchema(parentSchema, baseTypeName, COMPONENT_TYPE);
+                    XmlSchema resolvedSchema = getParentSchema(parentSchema, baseTypeName,
+                                                               COMPONENT_TYPE);
                     if (resolvedSchema == null) {
                         throw new SchemaCompilationException("can not find the type " + baseTypeName +
-                                " from the parent schema " + parentSchema.getTargetNamespace());
+                                                             " from the parent schema " +
+                                                             parentSchema.getTargetNamespace());
                     } else {
                         XmlSchemaType restrictionBaseType = resolvedSchema.getTypeByName(baseTypeName);
                         if (restrictionBaseType instanceof XmlSchemaSimpleType) {
                             if ((restrictionBaseType != null) && (!isAlreadyProcessed(baseTypeName))) {
                                 processSimpleSchemaType((XmlSchemaSimpleType) restrictionBaseType,
-                                        null, resolvedSchema, null);
+                                                        null, resolvedSchema, null);
                             }
                             // process restriction
                             processSimpleRestrictionBaseType(parentSimpleTypeQname,
-                                    restriction.getBaseTypeName(), metaInfHolder, resolvedSchema);
+                                                             restriction.getBaseTypeName(),
+                                                             metaInfHolder, resolvedSchema);
                         }
                     }
 
@@ -2613,16 +2835,19 @@
                         if (baseSchemaTypeMap.containsKey(qname)) {
                             metaInfHolder.addMemberType(qname, baseSchemaTypeMap.get(qname));
                         } else {
-                            XmlSchema resolvedSchema = getParentSchema(parentSchema, qname, COMPONENT_TYPE);
+                            XmlSchema resolvedSchema = getParentSchema(parentSchema, qname,
+                                                                       COMPONENT_TYPE);
                             if (resolvedSchema == null) {
                                 throw new SchemaCompilationException("can not find the type " + qname +
-                                        " from the parent schema " + parentSchema.getTargetNamespace());
+                                                                     " from the parent schema " +
+                                                                     parentSchema.getTargetNamespace());
                             } else {
                                 XmlSchemaType type = resolvedSchema.getTypeByName(qname);
                                 if (type instanceof XmlSchemaSimpleType) {
                                     XmlSchemaSimpleType memberSimpleType = (XmlSchemaSimpleType) type;
                                     if (!isAlreadyProcessed(qname)) {
-                                        processSimpleSchemaType(memberSimpleType, null, resolvedSchema, null);
+                                        processSimpleSchemaType(memberSimpleType, null,
+                                                                resolvedSchema, null);
                                     }
                                     metaInfHolder.addMemberType(qname, processedTypemap.get(qname));
                                 } else {
@@ -2632,26 +2857,25 @@
                         }
                     }
                 } else {
-                    XmlSchemaObjectCollection xmlSchemaObjectCollection = simpleTypeUnion.getBaseTypes();
-                    XmlSchemaObject xmlSchemaObject;
                     QName childQname;
                     int i = 1;
-                    for (Iterator iter = xmlSchemaObjectCollection.getIterator(); iter.hasNext();) {
-                        xmlSchemaObject = (XmlSchemaObject) iter.next();
+                    for (XmlSchemaSimpleType xmlSchemaObject : simpleTypeUnion.getBaseTypes()) {
                         i++;
-                        if (xmlSchemaObject instanceof XmlSchemaSimpleType) {
-                            XmlSchemaSimpleType unionSimpleType = (XmlSchemaSimpleType) xmlSchemaObject;
-                            childQname = unionSimpleType.getQName();
-                            if (childQname == null) {
-                                // we create a fake Qname for all these simple types since most propably they don't have one
-                                childQname = new QName(parentSimpleTypeQname.getNamespaceURI(), parentSimpleTypeQname.getLocalPart() + getNextTypeSuffix(parentSimpleTypeQname.getLocalPart()));
-                            }
-                            // this is an inner simple type of the union so it shold not have
-                            // processed
-                            processSimpleSchemaType(unionSimpleType, null, parentSchema, childQname);
-                            metaInfHolder.addMemberType(childQname, processedTypemap.get(childQname));
+                        XmlSchemaSimpleType unionSimpleType = xmlSchemaObject;
+                        childQname = unionSimpleType.getQName();
+                        if (childQname == null) {
+                            // we create a fake Qname for all these simple types since most propably they don't have one
+                            childQname = new QName(parentSimpleTypeQname.getNamespaceURI(),
+                                                   parentSimpleTypeQname.getLocalPart() +
+                                                   getNextTypeSuffix(parentSimpleTypeQname.
+                                                           getLocalPart()));
                         }
+                        // this is an inner simple type of the union so it shold not have
+                        // processed
+                        processSimpleSchemaType(unionSimpleType, null, parentSchema, childQname);
+                        metaInfHolder.addMemberType(childQname, processedTypemap.get(childQname));
 
+
                     }
                 }
 
@@ -2663,14 +2887,19 @@
 
                 if (itemTypeQName != null) {
                     if (!isAlreadyProcessed(itemTypeQName)) {
-                        XmlSchema resolvedSchema = getParentSchema(parentSchema, itemTypeQName, COMPONENT_TYPE);
+                        XmlSchema resolvedSchema = getParentSchema(parentSchema, itemTypeQName,
+                                                                   COMPONENT_TYPE);
                         if (resolvedSchema == null) {
-                            throw new SchemaCompilationException("can not find the type " + itemTypeQName +
-                                    " from the parent type " + parentSchema.getTargetNamespace());
+                            throw new SchemaCompilationException("can not find the type " +
+                                                                 itemTypeQName +
+                                                                 " from the parent type " +
+                                                                 parentSchema.getTargetNamespace());
                         } else {
-                            XmlSchemaType simpleSchemaType = resolvedSchema.getTypeByName(itemTypeQName);
+                            XmlSchemaType simpleSchemaType = resolvedSchema.
+                                    getTypeByName(itemTypeQName);
                             if (simpleSchemaType instanceof XmlSchemaSimpleType) {
-                                processSimpleSchemaType((XmlSchemaSimpleType) simpleSchemaType, null, resolvedSchema, null);
+                                processSimpleSchemaType((XmlSchemaSimpleType) simpleSchemaType,
+                                                        null, resolvedSchema, null);
                             }
                         }
                     }
@@ -2679,7 +2908,8 @@
                     itemTypeQName = listSimpleType.getQName();
                     if (itemTypeQName == null) {
                         // we create a fake Qname for all these simple types since most propably they don't have one
-                        itemTypeQName = new QName(parentSimpleTypeQname.getNamespaceURI(), parentSimpleTypeQname.getLocalPart() + "_type0");
+                        itemTypeQName = new QName(parentSimpleTypeQname.getNamespaceURI(),
+                                                  parentSimpleTypeQname.getLocalPart() + "_type0");
                     }
                     processSimpleSchemaType(listSimpleType, null, parentSchema, itemTypeQName);
 
@@ -2718,27 +2948,29 @@
 
     }
 
-    HashMap<String,Integer> mapTypeCount = new HashMap<String,Integer>();
+    HashMap<String, Integer> mapTypeCount = new HashMap<String, Integer>();
+
     private String getNextTypeSuffix(String localName) {
         Integer typeCounter = mapTypeCount.get(localName);
         int count = 0;
         if (typeCounter != null) {
-            if(typeCounter.intValue() == Integer.MAX_VALUE) {
+            if (typeCounter.intValue() == Integer.MAX_VALUE) {
                 count = 0;
             } else {
                 count = typeCounter.intValue();
             }
         }
-        mapTypeCount.put(localName, count+1);
+        mapTypeCount.put(localName, count + 1);
         return ("_type" + count);
     }
 
     /**
      * returns the parent schema of the componet having QName compoentTypeQName.
      * withe the componet type.
-     * @param parentSchema - parent schema of the given componet
+     *
+     * @param parentSchema   - parent schema of the given componet
      * @param componentQName - qname of the componet, of which we want to get the parent schema
-     * @param componetType - type of the componet. this can either be type,element,attribute or attribute group
+     * @param componetType   - type of the componet. this can either be type,element,attribute or attribute group
      * @return parent schema.
      */
 
@@ -2749,25 +2981,26 @@
         // it is equals to the xsd schema namesapce
         // we do not have to do any thing.
         if ((componentQName == null) ||
-              (componentQName.getNamespaceURI() == null) ||
-                Constants.URI_2001_SCHEMA_XSD.equals(componentQName.getNamespaceURI())){
+            (componentQName.getNamespaceURI() == null) ||
+            Constants.URI_2001_SCHEMA_XSD.equals(componentQName.getNamespaceURI())) {
             return parentSchema;
         }
 
         List<XmlSchema> visitedSchemas = new ArrayList<XmlSchema>();
         visitedSchemas.add(parentSchema);
         XmlSchema newParentSchema = getParentSchemaFromIncludes(parentSchema,
-                componentQName,componetType,visitedSchemas);
-        if (newParentSchema == null){
+                                                                componentQName, componetType,
+                                                                visitedSchemas);
+        if (newParentSchema == null) {
             String targetNamespace = componentQName.getNamespaceURI();
-            if (loadedSchemaMap.containsKey(targetNamespace)){
+            if (loadedSchemaMap.containsKey(targetNamespace)) {
                 XmlSchema tempSchema = loadedSchemaMap.get(targetNamespace);
-                if (isComponetExists(tempSchema,componentQName,componetType)){
+                if (isComponetExists(tempSchema, componentQName, componetType)) {
                     newParentSchema = tempSchema;
                 }
-            } else if (availableSchemaMap.containsKey(targetNamespace)){
+            } else if (availableSchemaMap.containsKey(targetNamespace)) {
                 XmlSchema tempSchema = availableSchemaMap.get(targetNamespace);
-                if (isComponetExists(tempSchema,componentQName,componetType)){
+                if (isComponetExists(tempSchema, componentQName, componetType)) {
                     newParentSchema = tempSchema;
                 }
             }
@@ -2778,53 +3011,50 @@
     private XmlSchema getParentSchemaFromIncludes(XmlSchema parentSchema,
                                                   QName componentQName,
                                                   int componetType,
-                                                  List<XmlSchema> visitedSchemas) throws SchemaCompilationException {
+                                                  List<XmlSchema> visitedSchemas)
+            throws SchemaCompilationException {
 
         XmlSchema newParentSchema = null;
         if (isComponetExists(parentSchema, componentQName, componetType)) {
             newParentSchema = parentSchema;
         } else {
             // this componet must either be in a import or and include
-            XmlSchemaObjectCollection includes = parentSchema.getIncludes();
-            if (includes != null) {
-                Object externalComponet = null;
-                XmlSchema externalSchema = null;
-                for (Iterator iter = includes.getIterator(); iter.hasNext();) {
-                    externalComponet = iter.next();
-                    if (externalComponet instanceof XmlSchemaExternal) {
-                        externalSchema = ((XmlSchemaExternal) externalComponet).getSchema();
 
-                        // if this is an inline import without a schema location
-                        // xmlschema does not load the schema.
-                        // so we try to figure out it either from the available schemas
-                        // or from the laded schemas.
-                        if ((externalSchema == null) && externalComponet instanceof XmlSchemaImport){
-                            XmlSchemaImport xmlSchemaImport = (XmlSchemaImport) externalComponet;
-                            String importNamespce = xmlSchemaImport.getNamespace();
-                            if ((importNamespce != null) && !importNamespce.equals(Constants.URI_2001_SCHEMA_XSD)) {
-                                if (loadedSchemaMap.containsKey(importNamespce)) {
-                                    externalSchema = loadedSchemaMap.get(importNamespce);
-                                } else if (availableSchemaMap.containsKey(importNamespce)) {
-                                    XmlSchema tempSchema = availableSchemaMap.get(importNamespce);
-                                    compile(tempSchema);
-                                    externalSchema = tempSchema;
-                                }
-                            }
+            XmlSchema externalSchema = null;
+            for (XmlSchemaExternal externalComponent : parentSchema.getExternals()) {
+                externalSchema = externalComponent.getSchema();
+
+                // if this is an inline import without a schema location
+                // xmlschema does not load the schema.
+                // so we try to figure out it either from the available schemas
+                // or from the laded schemas.
+                if ((externalSchema == null) && externalComponent instanceof XmlSchemaImport) {
+                    XmlSchemaImport xmlSchemaImport = (XmlSchemaImport) externalComponent;
+                    String importNamespce = xmlSchemaImport.getNamespace();
+                    if ((importNamespce != null) && !importNamespce.
+                            equals(Constants.URI_2001_SCHEMA_XSD)) {
+                        if (loadedSchemaMap.containsKey(importNamespce)) {
+                            externalSchema = loadedSchemaMap.get(importNamespce);
+                        } else if (availableSchemaMap.containsKey(importNamespce)) {
+                            XmlSchema tempSchema = availableSchemaMap.get(importNamespce);
+                            compile(tempSchema);
+                            externalSchema = tempSchema;
                         }
-                        if (externalSchema != null) {
-                            // find the componet in the new external schema.
-                            if (!visitedSchemas.contains(externalSchema)){
-                                visitedSchemas.add(externalSchema);
-                                newParentSchema = getParentSchemaFromIncludes(externalSchema,
-                                        componentQName, componetType, visitedSchemas);
-                            }
-                        }
-                        if (newParentSchema != null) {
-                            // i.e we have found the schema
-                            break;
-                        }
                     }
                 }
+                if (externalSchema != null) {
+                    // find the componet in the new external schema.
+                    if (!visitedSchemas.contains(externalSchema)) {
+                        visitedSchemas.add(externalSchema);
+                        newParentSchema = getParentSchemaFromIncludes(externalSchema,
+                                                                      componentQName, componetType,
+                                                                      visitedSchemas);
+                    }
+                }
+                if (newParentSchema != null) {
+                    // i.e we have found the schema
+                    break;
+                }
             }
         }
         return newParentSchema;
@@ -2835,7 +3065,7 @@
                                      int componetType) {
         //first we need to check whether we checking the correct schema.
         if ((schema.getTargetNamespace() != null)
-                && (!schema.getTargetNamespace().equals(componentQName.getNamespaceURI()))) {
+            && (!schema.getTargetNamespace().equals(componentQName.getNamespaceURI()))) {
             return false;
         }
 
@@ -2850,22 +3080,22 @@
                 break;
             }
             case COMPONENT_ATTRIBUTE: {
-                isExists = (schema.getAttributes().getItem(componentQName) != null);
+                isExists = (schema.getAttributes().get(componentQName) != null);
                 break;
             }
             case COMPONENT_ATTRIBUTE_GROUP: {
-                isExists = (schema.getAttributeGroups().getItem(componentQName) != null);
+                isExists = (schema.getAttributeGroups().get(componentQName) != null);
                 break;
             }
             case COMPONENT_GROUP: {
-                isExists = (schema.getGroups().getItem(componentQName) != null);
+                isExists = (schema.getGroups().get(componentQName) != null);
                 break;
             }
         }
         return isExists;
     }
 
-    public Map<String, XmlSchema> getLoadedSchemaMap(){
+    public Map<String, XmlSchema> getLoadedSchemaMap() {
         return this.loadedSchemaMap;
     }
 }
Index: modules/adb-codegen/src/org/apache/axis2/schema/template/ADBBeanTemplate-bean.xsl
===================================================================
--- modules/adb-codegen/src/org/apache/axis2/schema/template/ADBBeanTemplate-bean.xsl	(revision 1467549)
+++ modules/adb-codegen/src/org/apache/axis2/schema/template/ADBBeanTemplate-bean.xsl	(working copy)
@@ -2161,6 +2161,7 @@
                             <xsl:variable name="particleClassType" select="@particleClassType"></xsl:variable>
 
                             <xsl:variable name="propQName">new javax.xml.namespace.QName("<xsl:value-of select="$namespace"/>","<xsl:value-of select="$propertyName"/>")</xsl:variable>
+                            <xsl:variable name="propQName2">new javax.xml.namespace.QName("","<xsl:value-of select="$propertyName"/>")</xsl:variable>
 
                            <xsl:choose>
                                 <xsl:when test="$unordered and not($choice and $hasParticleType)">  <!-- One property per iteration if unordered -->
@@ -2185,7 +2186,7 @@
                                          we have to sollow an excpetions : todo find a better solsution-->
                                          try{
                                     </xsl:if>
-                                    if (reader.isStartElement() <xsl:if test="$simple"> || reader.hasText()</xsl:if> <xsl:if test="not($simple) and not($particleClassType)">&amp;&amp; <xsl:value-of select="$propQName"/>.equals(reader.getName())</xsl:if>){
+                                    if (reader.isStartElement() <xsl:if test="$simple"> || reader.hasText()</xsl:if> <xsl:if test="not($simple) and not($particleClassType)">&amp;&amp; <xsl:value-of select="$propQName"/>.equals(reader.getName()) || <xsl:value-of select="$propQName2"/>.equals(reader.getName()) </xsl:if>){
                                 </xsl:otherwise>
                             </xsl:choose>
 
Index: modules/adb-codegen/pom.xml
===================================================================
--- modules/adb-codegen/pom.xml	(revision 1467549)
+++ modules/adb-codegen/pom.xml	(working copy)
@@ -47,8 +47,8 @@
             <version>${project.version}</version>
         </dependency>
         <dependency>
-            <groupId>org.apache.ws.commons.schema</groupId>
-            <artifactId>XmlSchema</artifactId>
+            <groupId>org.apache.ws.xmlschema</groupId>
+            <artifactId>xmlschema-core</artifactId>
         </dependency>
         <dependency>
             <groupId>commons-cli</groupId>
@@ -114,6 +114,7 @@
                         <exclude>**/*Util*.java</exclude>
                         <exclude>**/*PhaseResolvingTest.java</exclude>
                         <exclude>**/*UnionQNameTest.java</exclude>
+                        <exclude>**/*UnqualifiedTest.java</exclude>
                     </excludes>
                     <includes>
                         <include>**/*Test.java</include>
Index: modules/jibx/src/main/java/org/apache/axis2/jibx/CodeGenerationUtility.java
===================================================================
--- modules/jibx/src/main/java/org/apache/axis2/jibx/CodeGenerationUtility.java	(revision 1467549)
+++ modules/jibx/src/main/java/org/apache/axis2/jibx/CodeGenerationUtility.java	(working copy)
@@ -33,9 +33,9 @@
 import org.apache.axis2.wsdl.util.MessagePartInformationHolder;
 import org.apache.ws.commons.schema.XmlSchemaComplexType;
 import org.apache.ws.commons.schema.XmlSchemaElement;
-import org.apache.ws.commons.schema.XmlSchemaObjectCollection;
 import org.apache.ws.commons.schema.XmlSchemaParticle;
 import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaSequenceMember;
 import org.apache.ws.commons.schema.XmlSchemaSimpleType;
 import org.apache.ws.commons.schema.XmlSchemaSimpleTypeContent;
 import org.apache.ws.commons.schema.XmlSchemaSimpleTypeRestriction;
@@ -715,7 +715,7 @@
         boolean complex = false;
         if (type instanceof XmlSchemaComplexType) {
             XmlSchemaComplexType ctype = (XmlSchemaComplexType)type;
-            if (ctype.getAttributes().getCount() != 0) {
+            if (!ctype.getAttributes().isEmpty()) {
                 throw new RuntimeException("Cannot unwrap element " +
                         qname + ": attributes not allowed on type to be unwrapped");
             }
@@ -736,18 +736,18 @@
 
                 // add child param element matching each child of wrapper element
                 QName opName = msg.getAxisOperation().getName();
-                XmlSchemaObjectCollection items = sequence.getItems();
                 boolean first = true;
-                for (Iterator iter = items.getIterator(); iter.hasNext();) {
+                for (XmlSchemaSequenceMember member : sequence.getItems()) {
 
                     // check that child item obeys the unwrapping rules
-                    XmlSchemaParticle item = (XmlSchemaParticle)iter.next();
+                    XmlSchemaParticle item = (XmlSchemaParticle)member;
+
                     if (!(item instanceof XmlSchemaElement)) {
                         throw new RuntimeException("Cannot unwrap element " +
                                 qname + ": only element items allowed in sequence");
                     }
                     XmlSchemaElement element = (XmlSchemaElement)item;
-                    QName refname = element.getRefName();
+                    QName refname = element.getRef().getTargetQName();
                     QName typename = element.getSchemaTypeName();
                     if (refname == null && typename == null) {
                         throw new RuntimeException("Cannot unwrap element " +
Index: modules/transport/http/test/org/apache/axis2/transport/http/XMLSchemaTest.java
===================================================================
--- modules/transport/http/test/org/apache/axis2/transport/http/XMLSchemaTest.java	(revision 1467549)
+++ modules/transport/http/test/org/apache/axis2/transport/http/XMLSchemaTest.java	(working copy)
@@ -19,6 +19,13 @@
 
 package org.apache.axis2.transport.http;
 
+import junit.framework.TestCase;
+import org.apache.axis2.util.XMLPrettyPrinter;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.custommonkey.xmlunit.Diff;
+
+import javax.xml.transform.stream.StreamSource;
 import java.io.BufferedReader;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -26,17 +33,9 @@
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 
-import javax.xml.transform.stream.StreamSource;
-
-import junit.framework.TestCase;
-
-import org.apache.axis2.util.XMLPrettyPrinter;
-import org.apache.ws.commons.schema.XmlSchema;
-import org.apache.ws.commons.schema.XmlSchemaCollection;
-import org.custommonkey.xmlunit.Diff;
-
 public abstract class XMLSchemaTest extends TestCase {
 
     public final String XMLSchemaNameSpace = "xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"";
@@ -79,7 +78,7 @@
             while (file.exists()) {
                 InputStream is = new FileInputStream(file);
                 XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-                XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+                XmlSchema schema = schemaCol.read(new StreamSource(is));
                 schemas.add(schema);
                 i++;
                 file = new File(SampleSchemasDirectory + "sampleSchema" + i
@@ -93,7 +92,7 @@
                 + ".xsd");
         InputStream is = new FileInputStream(file);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         return schema;
     }
      
@@ -115,7 +114,7 @@
     public String readXMLfromSchemaFile(String path) throws Exception {
         InputStream is = new FileInputStream(path);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         ByteArrayOutputStream stream = new ByteArrayOutputStream();
         schema.write(stream);
         is.close();
@@ -136,7 +135,7 @@
         fileWriter.close();        
     }
     
-    public String schemaToString(XmlSchema schema){
+    public String schemaToString(XmlSchema schema) throws UnsupportedEncodingException {
         ByteArrayOutputStream stream=new ByteArrayOutputStream();
         schema.write(stream);
         return stream.toString();
@@ -146,7 +145,7 @@
         File file = new File(path);
         InputStream is = new FileInputStream(file);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         return schema;
     }
     
Index: modules/transport/xmpp/src/org/apache/axis2/transport/xmpp/XMPPSender.java
===================================================================
--- modules/transport/xmpp/src/org/apache/axis2/transport/xmpp/XMPPSender.java	(revision 1467549)
+++ modules/transport/xmpp/src/org/apache/axis2/transport/xmpp/XMPPSender.java	(working copy)
@@ -19,12 +19,6 @@
 
 package org.apache.axis2.transport.xmpp;
 
-import java.util.Iterator;
-import java.util.Map;
-import java.util.UUID;
-
-import javax.xml.namespace.QName;
-
 import org.apache.axiom.om.OMElement;
 import org.apache.axiom.soap.SOAP12Version;
 import org.apache.axiom.soap.SOAPVersion;
@@ -56,9 +50,9 @@
 import org.apache.ws.commons.schema.XmlSchemaAll;
 import org.apache.ws.commons.schema.XmlSchemaComplexType;
 import org.apache.ws.commons.schema.XmlSchemaElement;
-import org.apache.ws.commons.schema.XmlSchemaGroupBase;
 import org.apache.ws.commons.schema.XmlSchemaParticle;
 import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaSequenceMember;
 import org.apache.ws.commons.schema.XmlSchemaType;
 import org.jivesoftware.smack.Chat;
 import org.jivesoftware.smack.ChatManager;
@@ -68,6 +62,11 @@
 import org.jivesoftware.smack.filter.PacketTypeFilter;
 import org.jivesoftware.smack.packet.Message;
 
+import javax.xml.namespace.QName;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.UUID;
+
 public class XMPPSender extends AbstractHandler implements TransportSender {
 	static Log log = null;
 	
@@ -342,24 +341,40 @@
 		        XmlSchemaComplexType complexType = ((XmlSchemaComplexType)schemaType);
 		        XmlSchemaParticle particle = complexType.getParticle();
 		        if (particle instanceof XmlSchemaSequence || particle instanceof XmlSchemaAll) {
-		            XmlSchemaGroupBase xmlSchemaGroupBase = (XmlSchemaGroupBase)particle;
-		            Iterator iterator = xmlSchemaGroupBase.getItems().getIterator();
 
-		            while (iterator.hasNext()) {
-		                XmlSchemaElement innerElement = (XmlSchemaElement)iterator.next();
-		                QName qName = innerElement.getQName();
-		                if (qName == null && innerElement.getSchemaTypeName()
-		                        .equals(org.apache.ws.commons.schema.constants.Constants.XSD_ANYTYPE)) {
-		                    break;
-		                }
-		                long minOccurs = innerElement.getMinOccurs();
-		                boolean nillable = innerElement.isNillable();
-		                String name =
-		                        qName != null ? qName.getLocalPart() : innerElement.getName();
-		                String type = innerElement.getSchemaTypeName().toString();
-		                paramList.append(","+type +" " +name);
-		            }
-		        }
+                    if (particle instanceof XmlSchemaSequence) {
+                        XmlSchemaSequence sequence = (XmlSchemaSequence) particle;
+                        for (XmlSchemaSequenceMember member : sequence.getItems()) {
+                            XmlSchemaElement innerElement = (XmlSchemaElement) member;
+                            QName qName = innerElement.getQName();
+                            if (qName == null && innerElement.getSchemaTypeName()
+                                    .equals(org.apache.ws.commons.schema.constants.Constants.XSD_ANYTYPE)) {
+                                break;
+                            }
+                            long minOccurs = innerElement.getMinOccurs();
+                            boolean nillable = innerElement.isNillable();
+                            String name =
+                                    qName != null ? qName.getLocalPart() : innerElement.getName();
+                            String type = innerElement.getSchemaTypeName().toString();
+                            paramList.append(","+type +" " +name);
+                        }
+                    }  else {
+                        XmlSchemaAll xmlSchemaAll = (XmlSchemaAll) particle;
+                        for (XmlSchemaElement innerElement : xmlSchemaAll.getItems()) {
+                            QName qName = innerElement.getQName();
+                            if (qName == null && innerElement.getSchemaTypeName()
+                                    .equals(org.apache.ws.commons.schema.constants.Constants.XSD_ANYTYPE)) {
+                                break;
+                            }
+                            long minOccurs = innerElement.getMinOccurs();
+                            boolean nillable = innerElement.isNillable();
+                            String name =
+                                    qName != null ? qName.getLocalPart() : innerElement.getName();
+                            String type = innerElement.getSchemaTypeName().toString();
+                            paramList.append("," + type + " " + name);
+                        }
+                    }
+                }
 		   }	            	
 		}
 		//remove first ","
Index: modules/java2wsdl/pom.xml
===================================================================
--- modules/java2wsdl/pom.xml	(revision 1467549)
+++ modules/java2wsdl/pom.xml	(working copy)
@@ -58,8 +58,8 @@
 
         <!--added this to support to keep WSDL information in AxisService-->
         <dependency>
-            <groupId>org.apache.ws.commons.schema</groupId>
-            <artifactId>XmlSchema</artifactId>
+            <groupId>org.apache.ws.xmlschema</groupId>
+            <artifactId>xmlschema-core</artifactId>
         </dependency>
         <dependency>
             <groupId>org.apache.geronimo.specs</groupId>
Index: modules/codegen/test/org/apache/axis2/wsdl/codegen/XMLSchemaTest.java
===================================================================
--- modules/codegen/test/org/apache/axis2/wsdl/codegen/XMLSchemaTest.java	(revision 1467549)
+++ modules/codegen/test/org/apache/axis2/wsdl/codegen/XMLSchemaTest.java	(working copy)
@@ -19,6 +19,13 @@
 
 package org.apache.axis2.wsdl.codegen;
 
+import junit.framework.TestCase;
+import org.apache.axis2.util.XMLPrettyPrinter;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.custommonkey.xmlunit.Diff;
+
+import javax.xml.transform.stream.StreamSource;
 import java.io.BufferedReader;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -26,17 +33,9 @@
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 
-import javax.xml.transform.stream.StreamSource;
-
-import junit.framework.TestCase;
-
-import org.apache.axis2.util.XMLPrettyPrinter;
-import org.apache.ws.commons.schema.XmlSchema;
-import org.apache.ws.commons.schema.XmlSchemaCollection;
-import org.custommonkey.xmlunit.Diff;
-
 public abstract class XMLSchemaTest extends TestCase {
 
     public final String XMLSchemaNameSpace = "xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"";
@@ -79,7 +78,7 @@
             while (file.exists()) {
                 InputStream is = new FileInputStream(file);
                 XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-                XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+                XmlSchema schema = schemaCol.read(new StreamSource(is));
                 schemas.add(schema);
                 i++;
                 file = new File(SampleSchemasDirectory + "sampleSchema" + i
@@ -93,7 +92,7 @@
                 + ".xsd");
         InputStream is = new FileInputStream(file);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         return schema;
     }
      
@@ -115,7 +114,7 @@
     public String readXMLfromSchemaFile(String path) throws Exception {
         InputStream is = new FileInputStream(path);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         ByteArrayOutputStream stream = new ByteArrayOutputStream();
         schema.write(stream);
         is.close();
@@ -136,7 +135,7 @@
         fileWriter.close();        
     }
     
-    public String schemaToString(XmlSchema schema){
+    public String schemaToString(XmlSchema schema) throws UnsupportedEncodingException {
         ByteArrayOutputStream stream=new ByteArrayOutputStream();
         schema.write(stream);
         return stream.toString();
@@ -146,7 +145,7 @@
         File file = new File(path);
         InputStream is = new FileInputStream(file);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        XmlSchema schema = schemaCol.read(new StreamSource(is), null);
+        XmlSchema schema = schemaCol.read(new StreamSource(is));
         return schema;
     }
     
Index: modules/codegen/test/org/apache/axis2/wsdl/codegen/extension/SchemaUnwrapperExtensionTest.java
===================================================================
--- modules/codegen/test/org/apache/axis2/wsdl/codegen/extension/SchemaUnwrapperExtensionTest.java	(revision 1467549)
+++ modules/codegen/test/org/apache/axis2/wsdl/codegen/extension/SchemaUnwrapperExtensionTest.java	(working copy)
@@ -186,6 +186,6 @@
     private XmlSchema loadSchema(String schemaLocation) throws FileNotFoundException {
         InputStream is = new FileInputStream(schemaLocation);
         XmlSchemaCollection schemaCol = new XmlSchemaCollection();
-        return schemaCol.read(new StreamSource(is), null);
+        return schemaCol.read(new StreamSource(is));
     }
 }
Index: modules/codegen/test/org/apache/axis2/wsdl/codegen/extension/WSDLValidatorExtensionTest.java
===================================================================
--- modules/codegen/test/org/apache/axis2/wsdl/codegen/extension/WSDLValidatorExtensionTest.java	(revision 1467549)
+++ modules/codegen/test/org/apache/axis2/wsdl/codegen/extension/WSDLValidatorExtensionTest.java	(working copy)
@@ -20,10 +20,6 @@
 
 package org.apache.axis2.wsdl.codegen.extension;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Map;
-
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.util.CommandLineOption;
 import org.apache.axis2.wsdl.codegen.CodeGenConfiguration;
@@ -32,13 +28,17 @@
 import org.apache.ws.commons.schema.XmlSchema;
 import org.junit.Test;
 
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
 public class WSDLValidatorExtensionTest extends XMLSchemaTest {
 
     @Test
     public void testWSDLValidation() throws Exception {
         XmlSchema schema = loadSingleSchemaFile(SampleSchemasDirectory + "schemaIncludes.xsd");
-        if (schema.getIncludes().getCount() != 0 && schema.getElements().getCount() == 0
-                && schema.getSchemaTypes().getCount() == 0 && schema.getGroups().getCount() == 0
+        if (!schema.getExternals().isEmpty() && schema.getElements().isEmpty()
+                && schema.getSchemaTypes().isEmpty() && schema.getGroups().isEmpty()
                 && schema.getTargetNamespace() == null) {
             try {
                 AxisService service = new AxisService();
Index: modules/codegen/src/org/apache/axis2/wsdl/codegen/schema/AxisServiceTopElementSchemaGenerator.java
===================================================================
--- modules/codegen/src/org/apache/axis2/wsdl/codegen/schema/AxisServiceTopElementSchemaGenerator.java	(revision 1467549)
+++ modules/codegen/src/org/apache/axis2/wsdl/codegen/schema/AxisServiceTopElementSchemaGenerator.java	(working copy)
@@ -29,7 +29,7 @@
 import org.apache.ws.commons.schema.XmlSchemaElement;
 import org.apache.ws.commons.schema.XmlSchemaImport;
 import org.apache.ws.commons.schema.XmlSchemaInclude;
-import org.apache.ws.commons.schema.XmlSchemaObjectCollection;
+import org.apache.ws.commons.schema.XmlSchemaObject;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 
@@ -213,26 +213,20 @@
             xmlSchemaElement = schema.getElementByName(elementQName);
             if (xmlSchemaElement == null) {
                 // try to find in an import or an include
-                XmlSchemaObjectCollection includes = schema.getIncludes();
-                if (includes != null) {
-                    Iterator includesIter = includes.getIterator();
-                    Object object;
-                    while (includesIter.hasNext()) {
-                        object = includesIter.next();
-                        if (object instanceof XmlSchemaImport) {
-                            org.apache.ws.commons.schema.XmlSchema schema1 =
-                                    ((XmlSchemaImport) object).getSchema();
-                            xmlSchemaElement = getSchemaElement(schema1,elementQName);
-                        }
-                        if (object instanceof XmlSchemaInclude) {
-                            org.apache.ws.commons.schema.XmlSchema schema1 =
-                                    ((XmlSchemaInclude) object).getSchema();
-                            xmlSchemaElement = getSchemaElement(schema1,elementQName);
-                        }
-                        if (xmlSchemaElement != null){
-                            break;
-                        }
+                for (XmlSchemaObject object : schema.getExternals()) {
+                    if (object instanceof XmlSchemaImport) {
+                        org.apache.ws.commons.schema.XmlSchema schema1 =
+                                ((XmlSchemaImport) object).getSchema();
+                        xmlSchemaElement = getSchemaElement(schema1, elementQName);
                     }
+                    if (object instanceof XmlSchemaInclude) {
+                        org.apache.ws.commons.schema.XmlSchema schema1 =
+                                ((XmlSchemaInclude) object).getSchema();
+                        xmlSchemaElement = getSchemaElement(schema1, elementQName);
+                    }
+                    if (xmlSchemaElement != null) {
+                        break;
+                    }
                 }
             }
         }
Index: modules/codegen/src/org/apache/axis2/wsdl/codegen/extension/SchemaUnwrapperExtension.java
===================================================================
--- modules/codegen/src/org/apache/axis2/wsdl/codegen/extension/SchemaUnwrapperExtension.java	(revision 1467549)
+++ modules/codegen/src/org/apache/axis2/wsdl/codegen/extension/SchemaUnwrapperExtension.java	(working copy)
@@ -46,9 +46,9 @@
 import org.apache.ws.commons.schema.XmlSchemaImport;
 import org.apache.ws.commons.schema.XmlSchemaInclude;
 import org.apache.ws.commons.schema.XmlSchemaObject;
-import org.apache.ws.commons.schema.XmlSchemaObjectCollection;
 import org.apache.ws.commons.schema.XmlSchemaParticle;
 import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaSequenceMember;
 import org.apache.ws.commons.schema.XmlSchemaSimpleType;
 import org.apache.ws.commons.schema.XmlSchemaType;
 
@@ -232,11 +232,9 @@
                                    List partNameList,
                                    String qnameSuffix) {
         QName opName = message.getAxisOperation().getName();
-        XmlSchemaObjectCollection xmlObjectCollection = complexType.getAttributes();
-        XmlSchemaObject item;
+
         XmlSchemaAttribute xmlSchemaAttribute;
-        for (Iterator iter = xmlObjectCollection.getIterator(); iter.hasNext();) {
-            item = (XmlSchemaObject) iter.next();
+        for (XmlSchemaObject item : complexType.getAttributes()) {
             if (item instanceof XmlSchemaAttribute) {
                 xmlSchemaAttribute = (XmlSchemaAttribute) item;
                 String partName = xmlSchemaAttribute.getName();
@@ -297,24 +295,18 @@
             xmlSchemaType = schema.getTypeByName(typeName);
             if (xmlSchemaType == null) {
                 // try to find in an import or an include
-                XmlSchemaObjectCollection includes = schema.getIncludes();
-                if (includes != null) {
-                    Iterator includesIter = includes.getIterator();
-                    Object object = null;
-                    while (includesIter.hasNext()) {
-                        object = includesIter.next();
-                        if (object instanceof XmlSchemaImport) {
-                            XmlSchema schema1 = ((XmlSchemaImport) object).getSchema();
-                            xmlSchemaType = getSchemaType(schema1, typeName);
-                        }
-                        if (object instanceof XmlSchemaInclude) {
-                            XmlSchema schema1 = ((XmlSchemaInclude) object).getSchema();
-                            xmlSchemaType = getSchemaType(schema1, typeName);
-                        }
-                        if (xmlSchemaType != null) {
-                            break;
-                        }
+                for (XmlSchemaObject object : schema.getExternals()) {
+                    if (object instanceof XmlSchemaImport) {
+                        XmlSchema schema1 = ((XmlSchemaImport) object).getSchema();
+                        xmlSchemaType = getSchemaType(schema1, typeName);
                     }
+                    if (object instanceof XmlSchemaInclude) {
+                        XmlSchema schema1 = ((XmlSchemaInclude) object).getSchema();
+                        xmlSchemaType = getSchemaType(schema1, typeName);
+                    }
+                    if (xmlSchemaType != null) {
+                        break;
+                    }
                 }
             }
         }
@@ -332,14 +324,14 @@
             QName opName = message.getAxisOperation().getName();
 
             XmlSchemaSequence sequence = (XmlSchemaSequence) schemaParticle;
-            XmlSchemaObjectCollection items = sequence.getItems();
+            List<XmlSchemaSequenceMember> items = sequence.getItems();
 
             // if this is an empty sequence, return
-            if (items.getCount() == 0) {
+            if (items.isEmpty()) {
                 return;
             }
-            for (Iterator i = items.getIterator(); i.hasNext();) {
-                Object item = i.next();
+            for (XmlSchemaSequenceMember item : items) {
+
                 // get each and every element in the sequence and
                 // traverse through them
                 if (item instanceof XmlSchemaElement) {
@@ -347,8 +339,8 @@
                     XmlSchemaElement xmlSchemaElement = (XmlSchemaElement) item;
                     XmlSchemaType schemaType = xmlSchemaElement.getSchemaType();
                     String partName = null;
-                    if (xmlSchemaElement.getRefName() != null) {
-                        partName = xmlSchemaElement.getRefName().getLocalPart();
+                    if (xmlSchemaElement.getRef().getTargetQName() != null) {
+                        partName = xmlSchemaElement.getRef().getTargetQName().getLocalPart();
                     } else {
                         partName = xmlSchemaElement.getName();
                     }
Index: modules/codegen/src/org/apache/axis2/wsdl/codegen/extension/JAXWSWapperExtension.java
===================================================================
--- modules/codegen/src/org/apache/axis2/wsdl/codegen/extension/JAXWSWapperExtension.java	(revision 1467549)
+++ modules/codegen/src/org/apache/axis2/wsdl/codegen/extension/JAXWSWapperExtension.java	(working copy)
@@ -35,9 +35,10 @@
 import org.apache.ws.commons.schema.XmlSchemaElement;
 import org.apache.ws.commons.schema.XmlSchemaImport;
 import org.apache.ws.commons.schema.XmlSchemaInclude;
-import org.apache.ws.commons.schema.XmlSchemaObjectCollection;
+import org.apache.ws.commons.schema.XmlSchemaObject;
 import org.apache.ws.commons.schema.XmlSchemaParticle;
 import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaSequenceMember;
 import org.apache.ws.commons.schema.XmlSchemaType;
 
 import javax.xml.namespace.QName;
@@ -189,24 +190,18 @@
             xmlSchemaType = schema.getTypeByName(typeName);
             if (xmlSchemaType == null) {
                 // try to find in an import or an include
-                XmlSchemaObjectCollection includes = schema.getIncludes();
-                if (includes != null) {
-                    Iterator includesIter = includes.getIterator();
-                    Object object = null;
-                    while (includesIter.hasNext()) {
-                        object = includesIter.next();
-                        if (object instanceof XmlSchemaImport) {
-                            XmlSchema schema1 = ((XmlSchemaImport) object).getSchema();
-                            xmlSchemaType = getSchemaType(schema1, typeName);
-                        }
-                        if (object instanceof XmlSchemaInclude) {
-                            XmlSchema schema1 = ((XmlSchemaInclude) object).getSchema();
-                            xmlSchemaType = getSchemaType(schema1, typeName);
-                        }
-                        if (xmlSchemaType != null) {
-                            break;
-                        }
+                for (XmlSchemaObject object : schema.getExternals()) {
+                    if (object instanceof XmlSchemaImport) {
+                        XmlSchema schema1 = ((XmlSchemaImport) object).getSchema();
+                        xmlSchemaType = getSchemaType(schema1, typeName);
                     }
+                    if (object instanceof XmlSchemaInclude) {
+                        XmlSchema schema1 = ((XmlSchemaInclude) object).getSchema();
+                        xmlSchemaType = getSchemaType(schema1, typeName);
+                    }
+                    if (xmlSchemaType != null) {
+                        break;
+                    }
                 }
             }
         }
@@ -222,8 +217,7 @@
         if (schemaType instanceof XmlSchemaComplexType) {
             XmlSchemaComplexType cmplxType = (XmlSchemaComplexType) schemaType;
 
-            XmlSchemaObjectCollection xmlObjectCollection = cmplxType.getAttributes();
-            if (xmlObjectCollection.getCount() != 0)
+            if (!cmplxType.getAttributes().isEmpty())
                 return false;
 
             if (cmplxType.getContentModel() == null) {
@@ -261,15 +255,14 @@
             QName opName = ((AxisOperation) message.getParent()).getName();
 
             XmlSchemaSequence sequence = (XmlSchemaSequence) schemaParticle;
-            XmlSchemaObjectCollection items = sequence.getItems();
+            List<XmlSchemaSequenceMember> items = sequence.getItems();
 
             // if this is an empty sequence, return
-            if (items.getCount() == 0) {
+            if (items.isEmpty()) {
 /*be carefull */
                 return true;
             }
-            for (Iterator i = items.getIterator(); i.hasNext();) {
-                Object item = i.next();
+            for (XmlSchemaSequenceMember item : items) {
                 // get each and every element in the sequence and
                 // traverse through them
                 if (item instanceof XmlSchemaElement) {
@@ -280,8 +273,8 @@
 //                    }
                     XmlSchemaType schemaType = xmlSchemaElement.getSchemaType();
                     String partName = null;
-                    if (xmlSchemaElement.getRefName() != null) {
-                        partName = xmlSchemaElement.getRefName().getLocalPart();
+                    if (xmlSchemaElement.getRef().getTargetQName() != null) {
+                        partName = xmlSchemaElement.getRef().getTargetQName().getLocalPart();
                     } else {
                         partName = xmlSchemaElement.getName();
                     }
Index: modules/codegen/src/org/apache/axis2/wsdl/codegen/extension/WSDLValidatorExtension.java
===================================================================
--- modules/codegen/src/org/apache/axis2/wsdl/codegen/extension/WSDLValidatorExtension.java	(revision 1467549)
+++ modules/codegen/src/org/apache/axis2/wsdl/codegen/extension/WSDLValidatorExtension.java	(working copy)
@@ -38,12 +38,12 @@
 
         for (int i = 0; i < schemaList.size(); i++) {
             XmlSchema s = (XmlSchema)schemaList.get(i);
-            if (s.getIncludes().getCount() != 0) {
+            if (!s.getExternals().isEmpty()) {
                 //there are some included - now see whether there are any
                 //elements or types declared!
-                if (s.getElements().getCount() == 0 &&
-                        s.getSchemaTypes().getCount() == 0 &&
-                        s.getGroups().getCount() == 0 &&
+                if (s.getElements().isEmpty()&&
+                        s.getSchemaTypes().isEmpty() &&
+                        s.getGroups().isEmpty() &&
                         s.getTargetNamespace() == null) {
                     // if there's no targetNamespace there's probably no name, but try it anyway
                     throw new CodeGenerationException(
Index: modules/xmlbeans/src/org/apache/axis2/xmlbeans/CodeGenerationUtility.java
===================================================================
--- modules/xmlbeans/src/org/apache/axis2/xmlbeans/CodeGenerationUtility.java	(revision 1467549)
+++ modules/xmlbeans/src/org/apache/axis2/xmlbeans/CodeGenerationUtility.java	(working copy)
@@ -62,6 +62,7 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.StringWriter;
+import java.io.UnsupportedEncodingException;
 import java.io.Writer;
 import java.net.URL;
 import java.util.ArrayList;
@@ -703,10 +704,11 @@
          *
          * @param schema
          */
-        private InputStream getSchemaAsInputStream(XmlSchema schema){
-         ByteArrayOutputStream baos = new ByteArrayOutputStream();
-         schema.write(baos);
-         return new ByteArrayInputStream(baos.toByteArray());
+        private InputStream getSchemaAsInputStream(XmlSchema schema)
+                throws UnsupportedEncodingException {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            schema.write(baos);
+            return new ByteArrayInputStream(baos.toByteArray());
         }
     }
 
