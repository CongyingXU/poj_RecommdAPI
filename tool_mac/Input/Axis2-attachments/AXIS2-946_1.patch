Index: BeanWriterMetaInfoHolder.java
===================================================================
--- BeanWriterMetaInfoHolder.java	(revision 425831)
+++ BeanWriterMetaInfoHolder.java	(working copy)
@@ -38,7 +38,9 @@
     protected boolean choice = false;
 
     protected boolean extension = false;
+    protected boolean restriction = false;
     private String extensionClassName = "";
+    private String restrictionClassName = "";
     protected Map elementToSchemaQNameMap = new LinkedHashMap();
     protected Map elementToJavaClassMap = new LinkedHashMap();
     protected Map specialTypeFlagMap = new LinkedHashMap();
@@ -147,7 +149,39 @@
         this.extension = extension;
     }
 
+    public String getRestrictionClassName() {
+        return restrictionClassName;
+    }
+    
     /**
+     * Sets the restriction base class name. Valid only when the isRestriction
+     * returns true.
+     *
+     * @param restrictionClassName
+     */
+    public void setRestrictionClassName(String restrictionClassName) {
+        this.restrictionClassName = restrictionClassName;
+    }
+    
+    /**
+     * Gets the restriction status.
+     *
+     * @return Returns boolean.
+     */
+    public boolean isRestriction() {
+        return restriction;
+    }
+    
+    /**
+     * Sets the restriction status.
+     *
+     * @param restriction
+     */
+    public void setRestriction(boolean restriction) {
+        this.restriction = restriction;
+    }
+    
+    /**
      * Gets the ordered status.
      *
      * @return Returns boolean.
Index: template/ADBBeanTemplate.xsl
===================================================================
--- template/ADBBeanTemplate.xsl	(revision 425831)
+++ template/ADBBeanTemplate.xsl	(working copy)
@@ -41,6 +41,7 @@
         <xsl:variable name="originalName" select="@originalName"/>
         <xsl:variable name="nsprefix" select="@nsprefix"/>
         <xsl:variable name="extension" select="@extension"/>
+        <xsl:variable name="restriction" select="@restriction"/>
         <xsl:variable name="mapperClass" select="@mapperClass"/>
     <!-- write the class header. this should be done only when unwrapped -->
 
@@ -57,7 +58,7 @@
             *  <xsl:value-of select="$name"/> bean class
             */
         </xsl:if>
-        public <xsl:if test="not(@unwrapped) or (@skip-write)">static</xsl:if> class <xsl:value-of select="$name"/> <xsl:if test="$extension"> extends <xsl:value-of select="$extension"/></xsl:if>
+        public <xsl:if test="not(@unwrapped) or (@skip-write)">static</xsl:if> class <xsl:value-of select="$name"/> <xsl:if test="$extension"> extends <xsl:value-of select="$extension"/></xsl:if> <xsl:if test="$restriction"> extends <xsl:value-of select="$restriction"/></xsl:if>
         implements org.apache.axis2.databinding.ADBBean{
         <xsl:choose>
             <xsl:when test="@type">/* This type was generated from the piece of schema that had
@@ -99,75 +100,77 @@
             <xsl:variable name="varName">local<xsl:value-of select="$javaName"/></xsl:variable>
             <xsl:variable name="settingTracker">local<xsl:value-of select="$javaName"/>Tracker</xsl:variable>
 
-
-            /**
-            * field for <xsl:value-of select="$javaName"/>
-            <xsl:if test="@attribute">* This was an Attribute!</xsl:if>
-            <xsl:if test="@array">* This was an Array!</xsl:if>
-            */
-
-            protected <xsl:value-of select="$propertyType"/><xsl:text> </xsl:text><xsl:value-of select="$varName" /> ;
-           <!-- Generate a tracker only if the min occurs is zero, which means if the user does
-                not bother to set that value, we do not send it -->
-           <xsl:if test="$min=0 or $choice">
-           /*  This tracker boolean wil be used to detect whether the user called the set method
-               for this attribute. It will be used to determine whether to include this field
-               in the serialized XML
-           */
-           protected boolean <xsl:value-of select="$settingTracker"/> = false ;
-           </xsl:if>
-
+			<xsl:choose>
+            <xsl:when test="@removed">
+           
            /**
            * Auto generated getter method
-           * @return <xsl:value-of select="$propertyType"/>
+           * Overridden from <xsl:value-of select="$restriction"/>
+           *
+           * @throws RuntimeException
            */
            public  <xsl:value-of select="$propertyType"/><xsl:text> </xsl:text>get<xsl:value-of select="$javaName"/>(){
-               return <xsl:value-of select="$varName"/>;
+               throw new java.lang.RuntimeException();
            }
+           
+           /**
+           * Auto generated setter method
+           * Overridden from <xsl:value-of select="$restriction"/>
+           *
+           * @param param <xsl:value-of select="$javaName"/>
+           * @throws RuntimeException
+           */
+           public void set<xsl:value-of select="$javaName"/>(<xsl:value-of select="$propertyType"/> param){
+           	   throw new java.lang.RuntimeException();
+           }
+               
+           </xsl:when>
+           <xsl:otherwise>
+               <xsl:choose>
+                  <xsl:when test="(@restricted) and (@occuranceChanged) and (not(@typeChanged))">
+               		 <xsl:variable name="basePropertyType"><xsl:value-of select="@arrayBaseType"/></xsl:variable>
 
-           <!-- When generating the setters, we have to cater differently for the array!-->
-            <xsl:choose>
-               <xsl:when test="@array">
-                   <xsl:variable name="basePropertyType"><xsl:value-of select="@arrayBaseType"/></xsl:variable>
 
-
-                   <!-- generate the validator Method, this is specifiacally for validating the arrays-->
-                  /**
-                   * validate the array for <xsl:value-of select="$javaName"/>
-                   */
-                  protected void validate<xsl:value-of select="$javaName"/>(<xsl:value-of select="$propertyType"/> param){
+                     <!-- generate the validator Method, this is specifiacally for validating the arrays-->
+                     /**
+                     * Validate the array for <xsl:value-of select="$javaName"/>
+                     * Overridden from <xsl:value-of select="$restriction"/>
+                     */
+                     protected void validate<xsl:value-of select="$javaName"/>(<xsl:value-of select="$propertyType"/> param){
                      <xsl:if test="not(@unbound)">
                           if (param.length &gt; <xsl:value-of select="@maxOccurs"/>){
                             throw new java.lang.RuntimeException();
                           }
-                      </xsl:if>
-                      <xsl:if test="$min!=0">
+                     </xsl:if>
+                     <xsl:if test="$min!=0">
                           if (param.length &lt; <xsl:value-of select="$min"/>){
                             throw new java.lang.RuntimeException();
                           }
-                      </xsl:if>
-                  }
+                     </xsl:if>
+                     }
 
 
-                 /**
-                  * Auto generated setter method
-                  * @param param <xsl:value-of select="$javaName"/>
-                  */
-                  public void set<xsl:value-of select="$javaName"/>(<xsl:value-of select="$propertyType"/> param){
-                   <!-- call the validator-->
-                   validate<xsl:value-of select="$javaName"/>(param);
+                     /**
+                     * Auto generated setter method
+                     * Overridden from <xsl:value-of select="$restriction"/>
+                     *
+                     * @param param <xsl:value-of select="$javaName"/>
+                     */
+                     public void set<xsl:value-of select="$javaName"/>(<xsl:value-of select="$propertyType"/> param){
+                     <!-- call the validator-->
+                  		  validate<xsl:value-of select="$javaName"/>(param);
 
-                   <xsl:if test="$choice">
-                       clearAllSettingTrackers();
-                   </xsl:if>
-                   <xsl:if test="$min=0 or $choice">
-                       <!-- the updating of setting tracker for null values should
-                            happen if the attribute is marked as nillable. Else
-                            the user can set a null value and it is never marked
-                            as set
-                       -->
-                       <xsl:choose>
-                          <xsl:when test="not(@nillable) and not(@primitive)">
+                     <xsl:if test="$choice">
+                          clearAllSettingTrackers();
+                     </xsl:if>
+                     <xsl:if test="$min=0 or $choice">
+                        <!-- the updating of setting tracker for null values should
+                             happen if the attribute is marked as nillable. Else
+                             the user can set a null value and it is never marked
+                             as set
+                        -->
+                        <xsl:choose>
+                           <xsl:when test="not(@nillable) and not(@primitive)">
                               if (param !=null){
                               //update the setting tracker
                               <xsl:value-of select="$settingTracker"/> = true;
@@ -177,70 +180,165 @@
                                //update the setting tracker
                               <xsl:value-of select="$settingTracker"/> = true;
                            </xsl:otherwise>
-                       </xsl:choose>
-                   </xsl:if>
-                  this.<xsl:value-of select="$varName"/>=param;
-                  }
+                        </xsl:choose>
+                     </xsl:if>
+                          this.<xsl:value-of select="$varName"/>=param;
+                     }
+                  </xsl:when>
+                  <xsl:otherwise>
+               
+            		/**
+            		* field for <xsl:value-of select="$javaName"/>
+            		<xsl:if test="@attribute">
+            		* This was an Attribute!</xsl:if>
+            		<xsl:if test="@array">
+            		* This was an Array!</xsl:if>
+            		<xsl:if test="@typeChanged">
+            		* Type of this field is a subtype of its original.</xsl:if>
+            		<xsl:if test="(@rewrite) and (@occuranceChanged)">
+            		* This field was an array in <xsl:value-of select="$restriction"/>.</xsl:if> 
+            		*/
 
-                   <!--
+            		protected <xsl:value-of select="$propertyType"/><xsl:text> </xsl:text><xsl:value-of select="$varName" /> ;
+           			<!-- Generate a tracker only if the min occurs is zero, which means if the user does
+               		not bother to set that value, we do not send it -->
+           			<xsl:if test="$min=0 or $choice">
+           			/*  This tracker boolean wil be used to detect whether the user called the set method
+              		*   for this attribute. It will be used to determine whether to include this field
+               		*   in the serialized XML
+           			*/
+           			protected boolean <xsl:value-of select="$settingTracker"/> = false ;
+           			</xsl:if>
 
-                       we special case the 'array' scenario and generate a
-                       convenience method for adding elements one by one to
-                       the array. The current implementation is somewhat
-                       inefficient but gets the job done.Since a primitive
-                       cannot be treated as an object it has to be ignored!
+           			/**
+           			* Auto generated getter method
+           			* @return <xsl:value-of select="$propertyType"/>
+           			*/
+           			public  <xsl:value-of select="$propertyType"/><xsl:text> </xsl:text>get<xsl:value-of select="$javaName"/>(){
+               			return <xsl:value-of select="$varName"/>;
+           			}
 
-                 -->
-                 <xsl:if test="not(@primitive)">
-                 /**
-                 * Auto generated add method for the array for convenience
-                 * @param param <xsl:value-of select="$basePropertyType"/>
-                 */
-                 public void add<xsl:value-of select="$javaName"/>(<xsl:value-of select="$basePropertyType"/> param){
-                   if (<xsl:value-of select="$varName"/> == null){
-                       <xsl:value-of select="$varName"/> = new <xsl:value-of select="$propertyType"/>{};
-                   }
+           			<!-- When generating the setters, we have to cater differently for the array!-->
+            		<xsl:choose>
+               			<xsl:when test="@array">
+                   		<xsl:variable name="basePropertyType"><xsl:value-of select="@arrayBaseType"/></xsl:variable>
 
-                    <xsl:if test="$choice">
-                           clearAllSettingTrackers();
-                    </xsl:if>
-                    <xsl:if test="$min=0 or $choice">
-                         //update the setting tracker
-                         <xsl:value-of select="$settingTracker"/> = true;
-                    </xsl:if>
 
-                   java.util.List list =
+                   		<!-- generate the validator Method, this is specifiacally for validating the arrays-->
+                  		/**
+                   		* validate the array for <xsl:value-of select="$javaName"/>
+                   		*/
+                  		protected void validate<xsl:value-of select="$javaName"/>(<xsl:value-of select="$propertyType"/> param){
+                     	<xsl:if test="not(@unbound)">
+                          if (param.length &gt; <xsl:value-of select="@maxOccurs"/>){
+                            throw new java.lang.RuntimeException();
+                          }
+                      	</xsl:if>
+                      	<xsl:if test="$min!=0">
+                          if (param.length &lt; <xsl:value-of select="$min"/>){
+                            throw new java.lang.RuntimeException();
+                          }
+                      	</xsl:if>
+                  		}
+
+
+                 		/**
+                  		* Auto generated setter method
+                  		* @param param <xsl:value-of select="$javaName"/>
+                  		*/
+                  		public void set<xsl:value-of select="$javaName"/>(<xsl:value-of select="$propertyType"/> param){
+                  		<!-- call the validator-->
+                   			validate<xsl:value-of select="$javaName"/>(param);
+
+                   		<xsl:if test="$choice">
+                       		clearAllSettingTrackers();
+                   		</xsl:if>
+                   		<xsl:if test="$min=0 or $choice">
+                       		<!-- the updating of setting tracker for null values should
+                            	 happen if the attribute is marked as nillable. Else
+                                 the user can set a null value and it is never marked
+                                 as set
+                       		-->
+                       		<xsl:choose>
+                          		<xsl:when test="not(@nillable) and not(@primitive)">
+                              	if (param !=null){
+                              	//update the setting tracker
+                              	<xsl:value-of select="$settingTracker"/> = true;
+                               	}
+                           		</xsl:when>
+                           		<xsl:otherwise>
+                               	//update the setting tracker
+                              	<xsl:value-of select="$settingTracker"/> = true;
+                           		</xsl:otherwise>
+                       		</xsl:choose>
+                   		</xsl:if>
+                  				this.<xsl:value-of select="$varName"/>=param;
+                  		}
+
+                   		<!--
+
+                       	we special case the 'array' scenario and generate a
+                       	convenience method for adding elements one by one to
+                       	the array. The current implementation is somewhat
+                       	inefficient but gets the job done.Since a primitive
+                       	cannot be treated as an object it has to be ignored!
+
+                 		-->
+                 		<xsl:if test="not(@primitive)">
+                 		/**
+                 		* Auto generated add method for the array for convenience
+                 		* @param param <xsl:value-of select="$basePropertyType"/>
+                 		*/
+                 		public void add<xsl:value-of select="$javaName"/>(<xsl:value-of select="$basePropertyType"/> param){
+                   			if (<xsl:value-of select="$varName"/> == null){
+                       		<xsl:value-of select="$varName"/> = new <xsl:value-of select="$propertyType"/>{};
+                   			}
+
+                    	<xsl:if test="$choice">
+                           	clearAllSettingTrackers();
+                    	</xsl:if>
+                    	<xsl:if test="$min=0 or $choice">
+                         	//update the setting tracker
+                        	<xsl:value-of select="$settingTracker"/> = true;
+                    	</xsl:if>
+
+                   		java.util.List list =
                         org.apache.axis2.databinding.utils.ConverterUtil.toList(<xsl:value-of select="$varName"/>);
-                   list.add(param);
-                   this.<xsl:value-of select="$varName"/> =
-                     (<xsl:value-of select="$propertyType"/>)list.toArray(
+                   		list.add(param);
+                   		this.<xsl:value-of select="$varName"/> =
+                     	(<xsl:value-of select="$propertyType"/>)list.toArray(
                         new <xsl:value-of select="$basePropertyType"/>[list.size()]);
 
-                 }
-                 </xsl:if>
-                     <!-- end of special casing for the array-->
+                 		}
+                 		</xsl:if>
+                     	<!-- end of special casing for the array-->
 
-               </xsl:when>
-                <!-- Non array setter method-->
-                <xsl:otherwise>
-                    /**
-                   * Auto generated setter method
-                   * @param param <xsl:value-of select="$javaName"/>
-                   */
-                   public void set<xsl:value-of select="$javaName"/>(<xsl:value-of select="$propertyType"/> param){
-                    <xsl:if test="$choice">
-                        clearAllSettingTrackers();
-                    </xsl:if>
-                    <xsl:if test="$min=0 or $choice">
-                    //update the setting tracker
-                    <xsl:value-of select="$settingTracker"/> = true;
-                    </xsl:if>
-                   this.<xsl:value-of select="$varName"/>=param;
-                   }
-                </xsl:otherwise>
+               			</xsl:when>
+                		<!-- Non array setter method-->
+                		<xsl:otherwise>
+                    	/**
+                   		* Auto generated setter method
+                   		* @param param <xsl:value-of select="$javaName"/>
+                   		*/
+                   		public void set<xsl:value-of select="$javaName"/>(<xsl:value-of select="$propertyType"/> param){
+                    	<xsl:if test="$choice">
+                        	clearAllSettingTrackers();
+                    	</xsl:if>
+                    	<xsl:if test="$min=0 or $choice">
+                    		//update the setting tracker
+                    	<xsl:value-of select="$settingTracker"/> = true;
+                    	</xsl:if>
+                   			this.<xsl:value-of select="$varName"/>=param;
+                   		}
+                		</xsl:otherwise>
+            		</xsl:choose>
+			
+				  </xsl:otherwise>
+               </xsl:choose>
+            
+			</xsl:otherwise>
             </xsl:choose>
 
-
              <!-- end of xsl:if for not(@inherited) -->
             </xsl:if>
 
Index: SchemaCompiler.java
===================================================================
--- SchemaCompiler.java	(revision 425831)
+++ SchemaCompiler.java	(working copy)
@@ -836,7 +836,7 @@
         if (content instanceof XmlSchemaComplexContent){
             processComplexContent((XmlSchemaComplexContent)content,metaInfHolder,parentSchema);
         }else if (content instanceof XmlSchemaSimpleContent){
-            processSimpleContent((XmlSchemaSimpleContent)content,metaInfHolder);
+            processSimpleContent((XmlSchemaSimpleContent)content,metaInfHolder,parentSchema);
         }
     }
 
@@ -893,9 +893,38 @@
             //Note  - this is no array! so the array boolean is false
 
         }else if (content instanceof XmlSchemaComplexContentRestriction){
-            //todo handle complex restriction here
-            throw new SchemaCompilationException(
-                    SchemaCompilerMessages.getMessage("schema.unsupportedcontenterror","Complex Content"));
+        	// to handle extension we need to attach the extended items to the base type
+            // and create a new type
+            XmlSchemaComplexContentRestriction restriction = (XmlSchemaComplexContentRestriction)
+                    content;
+
+            //process the base type if it has not been processed yet
+            if (!isAlreadyProcessed(restriction.getBaseTypeName())){
+                //pick the relevant basetype from the schema and process it
+                XmlSchemaType type=  parentSchema.getTypeByName(restriction.getBaseTypeName());
+                if (type instanceof XmlSchemaComplexType) {
+                    XmlSchemaComplexType complexType = (XmlSchemaComplexType) type;
+                    if (complexType.getName() != null) {
+                        processNamedComplexSchemaType(complexType,parentSchema);
+                    } else {
+                        //this is not possible. The restriction should always
+                        //have a name
+                        throw new SchemaCompilationException("Unnamed complex type used in restriction");//Internationlize this
+                    }
+                } else if (type instanceof XmlSchemaSimpleType) {
+                    
+                	throw new SchemaCompilationException("Not a valid restriction, complex content restriction base type cannot be a simple type.");
+                }
+            }
+
+            copyMetaInfoHierarchy(metaInfHolder,restriction.getBaseTypeName(),parentSchema);
+
+            //process the particle of this node
+            processParticle(restriction.getParticle(),metaInfHolder,parentSchema);
+
+            metaInfHolder.setRestriction(true);
+            metaInfHolder.setRestrictionClassName(findClassName(restriction.getBaseTypeName(),false));
+            //Note  - this is no array! so the array boolean is false
         }
     }
 
@@ -970,14 +999,54 @@
      * @param metaInfHolder
      * @throws SchemaCompilationException
      */
-    private void processSimpleContent(XmlSchemaSimpleContent simpleContent,BeanWriterMetaInfoHolder metaInfHolder)
+    private void processSimpleContent(XmlSchemaSimpleContent simpleContent,BeanWriterMetaInfoHolder metaInfHolder,XmlSchema parentSchema)
             throws SchemaCompilationException{
         XmlSchemaContent content;
         content = simpleContent.getContent();
         if (content instanceof XmlSchemaSimpleContentExtension){
-            //todo - handle simple type extension here
-            throw new SchemaCompilationException(
-                    SchemaCompilerMessages.getMessage("schema.unsupportedcontenterror","Simple Content Extension"));
+        	XmlSchemaSimpleContentExtension extension = (XmlSchemaSimpleContentExtension)content;
+
+        	//process the base type if it has not been processed yet
+        	if (!isAlreadyProcessed(extension.getBaseTypeName())){
+        		//pick the relevant basetype from the schema and process it
+        		XmlSchemaType type=  parentSchema.getTypeByName(extension.getBaseTypeName());
+        		if (type instanceof XmlSchemaComplexType) {
+        			XmlSchemaComplexType complexType = (XmlSchemaComplexType) type;
+        			if (complexType.getName() != null) {
+        				processNamedComplexSchemaType(complexType,parentSchema);
+        			} else {
+        				//this is not possible. The extension should always
+        				//have a name
+        				throw new SchemaCompilationException("Unnamed complex type used in extension");//Internationlize this
+        			}
+        		} else if (type instanceof XmlSchemaSimpleType) {
+        			//process simple type
+        			processSimpleSchemaType((XmlSchemaSimpleType)type,null);
+        		}
+        	}
+        	
+        	//process extension base type
+        	ProcessSimpleExtensionbaseType(extension.getBaseTypeName(),metaInfHolder);
+        	
+        	//process attributes 
+            XmlSchemaObjectCollection attribs = extension.getAttributes();
+            Iterator attribIterator = attribs.getIterator();
+            while (attribIterator.hasNext()) {
+                Object attr = attribIterator.next();
+                if (attr instanceof XmlSchemaAttribute) {
+                    processAttribute((XmlSchemaAttribute) attr, metaInfHolder);
+
+                }
+            }
+            
+            //process any attribute
+            XmlSchemaAnyAttribute anyAtt = extension.getAnyAttribute();
+            if (anyAtt != null) {
+                processAnyAttribute(metaInfHolder,anyAtt);
+            }
+            
+            
+        	
         }else if (content instanceof XmlSchemaSimpleContentRestriction){
             //todo - Handle simple type restriction here
             throw new SchemaCompilationException(
@@ -986,6 +1055,23 @@
         }
     }
 
+    public void ProcessSimpleExtensionbaseType(QName extBaseType,BeanWriterMetaInfoHolder metaInfHolder) {
+    	
+        //find the class name
+        String className = findClassName(extBaseType, false);
+
+        //this means the schema type actually returns a different QName
+        if (changedTypeMap.containsKey(extBaseType)) {
+        	metaInfHolder.registerMapping(extBaseType,
+                    (QName) changedTypeMap.get(extBaseType),
+                    className,SchemaConstants.ELEMENT_TYPE);
+        } else {
+        	metaInfHolder.registerMapping(extBaseType,
+        			extBaseType,
+                    className,SchemaConstants.ELEMENT_TYPE);
+        }
+    }
+    
     /**
      * Handle any attribute
      * @param metainf
Index: writer/JavaBeanWriter.java
===================================================================
--- writer/JavaBeanWriter.java	(revision 425831)
+++ writer/JavaBeanWriter.java	(working copy)
@@ -469,6 +469,11 @@
                     .getExtensionClassName(), rootElt);
 
         }
+        if (metainf.isRestriction()) {
+            XSLTUtils.addAttribute(model, "restriction", metainf
+                    .getRestrictionClassName(), rootElt);
+
+        }
         //add the mapper class name
         XSLTUtils.addAttribute(model, "mapperClass", getFullyQualifiedMapperClassName(), rootElt);
 
@@ -525,18 +530,33 @@
                                     Document model, Element rootElt, ArrayList propertyNames,
                                     Map typeMap, boolean isInherited) throws SchemaCompilationException {
         // go in the loop and add the part elements
-        QName[] qNames;
+    	QName[] qName;
+    	String javaClassNameForElement;
+        ArrayList missingQNames = new ArrayList();
+        ArrayList qNames = new ArrayList();
+        
+        BeanWriterMetaInfoHolder parentMetaInf = metainf.getParent();
+        
         if (metainf.isOrdered()) {
-            qNames = metainf.getOrderedQNameArray();
+            qName = metainf.getOrderedQNameArray();
         } else {
-            qNames = metainf.getQNameArray();
+            qName= metainf.getQNameArray();
         }
+        
+        for (int i = 0; i < qName.length; i++) {
+        	qNames.add(qName[i]);
+        }
+        //adding missing QNames to the end, including elements & attributes.
+        if (metainf.isRestriction()) {
+        	addMissingQNames(metainf, qNames, missingQNames);
+        }
+        QName name;
 
-        QName name;
-        for (int i = 0; i < qNames.length; i++) {
+        for (int i = 0; i < qNames.size(); i++) {
+        	name = (QName) qNames.get(i);
             Element property = XSLTUtils.addChildElement(model, "property",
                     rootElt);
-            name = qNames[i];
+            name = (QName)qNames.get(i);
             String xmlName = name.getLocalPart();
             XSLTUtils.addAttribute(model, "name", xmlName, property);
             XSLTUtils.addAttribute(model, "nsuri", name.getNamespaceURI(),
@@ -544,13 +564,23 @@
             String javaName = makeUniqueJavaClassName(propertyNames, xmlName);
             XSLTUtils.addAttribute(model, "javaname", javaName, property);
 
-            String javaClassNameForElement = metainf.getClassNameForQName(name);
-
+            if (metainf.isRestriction() && missingQNames.contains(name)) {
+            	javaClassNameForElement = parentMetaInf.getClassNameForQName(name);
+            }
+            else {
+            	javaClassNameForElement = metainf.getClassNameForQName(name);
+            }
+            
             if (javaClassNameForElement == null) {
                 throw new SchemaCompilationException(SchemaCompilerMessages
                         .getMessage("schema.typeMissing"));
             }
-
+            
+            if (metainf.isRestriction() && typeChanged(name, missingQNames, metainf)) {
+            	XSLTUtils.addAttribute(model, "typeChanged", "yes", property);
+            	//XSLTUtils.addAttribute(model, "restricted", "yes", property);
+            }
+            
             XSLTUtils.addAttribute(model, "type", javaClassNameForElement,
                     property);
 
@@ -590,6 +620,11 @@
             XSLTUtils.addAttribute(model, "shorttypename", shortTypeName,
                     property);
 
+            if (metainf.isRestriction() && missingQNames.contains(name)) {
+            	//XSLTUtils.addAttribute(model, "restricted", "yes", property);
+            	XSLTUtils.addAttribute(model, "removed", "yes", property);
+            }
+            
             if (isInherited) {
                 XSLTUtils.addAttribute(model, "inherited", "yes", property);
             }
@@ -606,6 +641,18 @@
             long minOccurs = metainf.getMinOccurs(name);
             XSLTUtils
                     .addAttribute(model, "minOccurs", minOccurs + "", property);
+            
+            //in the case the original element is an array but the derived one is not.
+            if (metainf.isRestriction() && !missingQNames.contains(name) &&
+               (parentMetaInf.getArrayStatusForQName(name) && !metainf.getArrayStatusForQName(name))) {
+            	XSLTUtils.addAttribute(model, "rewrite", "yes", property);
+            	XSLTUtils.addAttribute(model, "occuranceChanged", "yes", property);
+            }
+            else if (metainf.isRestriction() && !missingQNames.contains(name) &&
+            		(minOccursChanged(name, missingQNames, metainf) || maxOccursChanged(name, missingQNames, metainf))) {
+            	XSLTUtils.addAttribute(model, "restricted", "yes", property);
+            	XSLTUtils.addAttribute(model, "occuranceChanged", "yes", property);
+            }
 
             if (metainf.getArrayStatusForQName(name)) {
 
@@ -627,6 +674,162 @@
         }
     }
 
+    private void addMissingQNames(BeanWriterMetaInfoHolder metainf, ArrayList qName, ArrayList missingQNames) {
+    	
+    	QName[] qNames;
+        QName[] pQNames;
+        //ArrayList missingQNames = new ArrayList();
+            		
+        BeanWriterMetaInfoHolder parentMetaInf = metainf.getParent();
+        
+        if (metainf.isOrdered()) {
+            qNames = metainf.getOrderedQNameArray();
+        } else {
+            qNames = metainf.getQNameArray();
+        }
+        
+        if (parentMetaInf.isOrdered()) {
+            pQNames = parentMetaInf.getOrderedQNameArray();
+        } else {
+            pQNames = parentMetaInf.getQNameArray();
+        }
+        
+        
+        for (int i=0; i < pQNames.length; i++) {
+       		if (qNameNotFound(pQNames[i], metainf)) {
+       			missingQNames.add(pQNames[i]);
+       		}
+       	}
+       	//adding missing QNames to the end of list.
+        if (!missingQNames.isEmpty()) {
+       		for (int i=0; i < missingQNames.size(); i++) {
+       			qName.add(missingQNames.get(i));
+       		}
+       	}
+        //return qName;
+    }
+    
+    private boolean qNameNotFound(QName qname, BeanWriterMetaInfoHolder metainf) {
+    	
+    	boolean found = false;
+    	QName[] qNames;
+    	
+    	if (metainf.isOrdered()) {
+        	qNames = metainf.getOrderedQNameArray();
+        } else {
+        	qNames = metainf.getQNameArray();
+        }
+        
+        for (int j = 0; j < qNames.length; j++) {
+        	if (qname.getLocalPart().equals(qNames[j].getLocalPart())) {
+        			found = true;
+        	}
+        }
+        return !found;
+    }
+    
+    private boolean typeChanged(QName qname, ArrayList missingQNames, BeanWriterMetaInfoHolder metainf) {
+    	
+    	boolean typeChanged = false;
+    	QName[] pQNames;
+    	
+    	BeanWriterMetaInfoHolder parentMetainf = metainf.getParent(); 
+        
+    	if (!missingQNames.contains(qname)) {
+    		
+    		if (parentMetainf.isOrdered()) {
+    			pQNames = parentMetainf.getOrderedQNameArray();
+    		} else {
+    			pQNames = parentMetainf.getQNameArray();
+    		}
+    		
+    		for (int j = 0; j < pQNames.length; j++) {
+    			if (qname.getLocalPart().equals(pQNames[j].getLocalPart())) {
+    				
+    				String javaClassForParentElement = parentMetainf.getClassNameForQName(pQNames[j]);
+    				String javaClassForElement = metainf.getClassNameForQName(qname);
+    				
+    				if (!javaClassForParentElement.equals(javaClassForElement)) {
+    					if (javaClassForParentElement.endsWith("[]")) {
+    						if ((javaClassForParentElement.substring(0,javaClassForParentElement.indexOf('['))).equals(javaClassForElement)) {
+    						continue;
+    						}
+    					}
+    					else if (javaClassForElement.endsWith("[]")) {
+    						if ((javaClassForElement.substring(0,javaClassForElement.indexOf('['))).equals(javaClassForParentElement)) {
+    							continue;
+    						}
+    					}
+    					else {
+    						typeChanged = true;
+    					}
+    				}
+    			}
+    		}
+    	}
+        return typeChanged;
+    }
+    
+    private boolean minOccursChanged(QName qname, ArrayList missingQNames, BeanWriterMetaInfoHolder metainf) throws SchemaCompilationException {
+    	
+    	boolean minChanged = false;
+    	QName[] pQNames;
+    	
+    	BeanWriterMetaInfoHolder parentMetainf = metainf.getParent(); 
+        	
+    	if (!missingQNames.contains(qname)) {
+    		
+    		if (parentMetainf.isOrdered()) {
+    			pQNames = parentMetainf.getOrderedQNameArray();
+    		} else {
+    			pQNames = parentMetainf.getQNameArray();
+    		}
+    		
+    		for (int j = 0; j < pQNames.length; j++) {
+    			if (qname.getLocalPart().equals(pQNames[j].getLocalPart())) {
+    				
+    				if (metainf.getMinOccurs(qname) > parentMetainf.getMinOccurs(pQNames[j])) {
+    					minChanged = true;
+    				}
+    				else if(metainf.getMinOccurs(qname) < parentMetainf.getMinOccurs(pQNames[j])) {
+    					throw new SchemaCompilationException(SchemaCompilerMessages.getMessage("minOccurs Wrong!")); 
+    				}
+    				
+    			}
+    		}
+    	}
+        return minChanged;
+    }
+    
+    private boolean maxOccursChanged(QName qname, ArrayList missingQNames, BeanWriterMetaInfoHolder metainf) throws SchemaCompilationException {
+    	
+    	boolean maxChanged = false;
+    	QName[] pQNames;
+    	
+    	BeanWriterMetaInfoHolder parentMetainf = metainf.getParent();
+    	
+    	if (!missingQNames.contains(qname)) {	
+    		if (parentMetainf.isOrdered()) {
+    			pQNames = parentMetainf.getOrderedQNameArray();
+    		} else {
+    			pQNames = parentMetainf.getQNameArray();
+    		}
+    		
+    		for (int j = 0; j < pQNames.length; j++) {
+    			if (qname.getLocalPart().equals(pQNames[j].getLocalPart())) {
+    				
+    				if (metainf.getMaxOccurs(qname) < parentMetainf.getMaxOccurs(pQNames[j])) {
+    					maxChanged = true;
+    				}
+    				else if(metainf.getMaxOccurs(qname) > parentMetainf.getMaxOccurs(pQNames[j])) {
+    					throw new SchemaCompilationException(SchemaCompilerMessages.getMessage("maxOccurs Wrong!")); 
+    				}
+    			}
+    		}
+    	}
+        return maxChanged;
+    }
+    
     /**
      * Test whether the given class name matches the default
      * 
@@ -899,4 +1102,7 @@
 
 
     }
+    
 }
+
+
