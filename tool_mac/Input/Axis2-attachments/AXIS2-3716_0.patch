Index: /Users/nmm42/devel/apache/axis2/modules/kernel/src/org/apache/axis2/util/threadpool/ThreadPool.java
===================================================================
--- /Users/nmm42/devel/apache/axis2/modules/kernel/src/org/apache/axis2/util/threadpool/ThreadPool.java	(revision 645809)
+++ /Users/nmm42/devel/apache/axis2/modules/kernel/src/org/apache/axis2/util/threadpool/ThreadPool.java	(working copy)
@@ -25,7 +25,8 @@
 import edu.emory.mathcs.backport.java.util.concurrent.SynchronousQueue;
 import edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor;
 import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
-import org.apache.axis2.AxisFault;
+import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
+
 import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.java.security.AccessController;
 import org.apache.commons.logging.Log;
@@ -43,7 +44,7 @@
 public class ThreadPool implements ThreadFactory {
     private static final Log log = LogFactory.getLog(ThreadPool.class);
     protected static long SLEEP_INTERVAL = 1000;
-    private static boolean shutDown;
+    private AtomicBoolean shutDown;
     protected ThreadPoolExecutor executor;
 
     //integers that define the pool size, with the default values set.
@@ -51,6 +52,7 @@
     private int maxPoolSize = Integer.MAX_VALUE;
 
     public ThreadPool() {
+    	shutDown = new AtomicBoolean(false);
         setExecutor(createDefaultExecutor("Axis2 Task", Thread.NORM_PRIORITY, true));
     }
 
@@ -57,6 +59,7 @@
     public ThreadPool(int corePoolSize, int maxPoolSize) {
         this.corePoolSize = corePoolSize;
         this.maxPoolSize = maxPoolSize;
+        shutDown = new AtomicBoolean(false);
         setExecutor(createDefaultExecutor("Axis2 Task", Thread.NORM_PRIORITY, true));
     }
 
@@ -69,7 +72,7 @@
     }
 
     public void execute(Runnable worker) {
-        if (shutDown) {
+        if (shutDown.get()) {
             throw new RuntimeException(Messages.getMessage("threadpoolshutdown"));
         }
         executor.execute(worker);
@@ -86,16 +89,103 @@
     }
 
     /**
+     * Sets the core number of threads.  This overrides any value set
+     * in the constructor.  If the new value is smaller than the
+     * current value, excess existing threads will be terminated when
+     * they next become idle. If larger, new threads will, if needed,
+     * be started to execute any queued tasks.
+     *
+     * @param corePoolSize the new core size
+     * @throws IllegalArgumentException if <tt>corePoolSize</tt>
+     * less than zero
+     * @see #getCorePoolSize
+     */
+    public void setCorePoolSize(int corePoolSize) {
+    	this.executor.setCorePoolSize(corePoolSize);
+    }
+    
+    /**
+     * Returns the core number of threads.
+     *
+     * @return the core number of threads
+     * @see #setCorePoolSize
+     */
+    public int getCorePoolSize() {
+    	return this.executor.getCorePoolSize();
+    }
+    
+    /**
+     * Sets the maximum allowed number of threads. This overrides any
+     * value set in the constructor. If the new value is smaller than
+     * the current value, excess existing threads will be
+     * terminated when they next become idle.
+     *
+     * @param maximumPoolSize the new maximum
+     * @throws IllegalArgumentException if maximumPoolSize less than zero or
+     * the {@link #getCorePoolSize core pool size}
+     * @see #getMaximumPoolSize
+     */
+    public void setMaximumPoolSize(int maximumPoolSize) {
+    	this.executor.setMaximumPoolSize(maximumPoolSize);
+    }
+    
+    /**
+     * Returns the maximum allowed number of threads.
+     *
+     * @return the maximum allowed number of threads
+     * @see #setMaximumPoolSize
+     */
+    public int getMaximumPoolSize() {
+    	return this.executor.getMaximumPoolSize();
+    }
+    
+    /**
+     * Returns the current number of threads in the pool.
+     *
+     * @return the number of threads
+     */
+    public int getPoolSize() {
+    	return this.executor.getPoolSize();
+    }
+    
+    /**
+     * Sets the time limit for which threads may remain idle before
+     * being terminated.  If there are more than the core number of
+     * threads currently in the pool, after waiting this amount of
+     * time without processing a task, excess threads will be
+     * terminated.  This overrides any value set in the constructor.
+     * @param time the time to wait.  A time value of zero will cause
+     * excess threads to terminate immediately after executing tasks.
+     * @param unit  the time unit of the time argument
+     * @throws IllegalArgumentException if time less than zero
+     * @see #getKeepAliveTime
+     */
+    public void setKeepAliveTime(long time, TimeUnit unit) {
+    	this.executor.setKeepAliveTime(time, unit);
+    }
+
+    /**
+     * Returns the thread keep-alive time, which is the amount of time
+     * which threads in excess of the core pool size may remain
+     * idle before being terminated.
+     *
+     * @param unit the desired time unit of the result
+     * @return the time limit
+     * @see #setKeepAliveTime
+     */
+    public long getKeepAliveTime(TimeUnit unit) {
+    	return this.executor.getKeepAliveTime(unit);
+    }
+    
+    /**
      * This is the recommended shutdown method for the thread pool
      * This will wait till all the workers that are already handed over to the
      * thread pool get executed.
-     *
-     * @throws org.apache.axis2.AxisFault
+     * <p>
+     * Invocation has no additional effect if already shut down.
      */
-    public void safeShutDown() throws AxisFault {
-        synchronized (this) {
-            shutDown = true;
-        }
+    public void safeShutDown() {
+    	this.shutDown.set(true);
 
         executor.shutdown();
     }
