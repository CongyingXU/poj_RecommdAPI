Index: /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/MIMEBodyPartInputStream.java
===================================================================
--- /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/MIMEBodyPartInputStream.java	(revision 394993)
+++ /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/MIMEBodyPartInputStream.java	(working copy)
@@ -47,7 +47,7 @@
         }
         // read the next value from stream
         int value = inStream.read();
-
+        
         // A problem occured because all the mime parts tends to have a /r/n at
         // the end. Making it hard to transform them to correct DataSources.
         // This logic introduced to handle it
Index: /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/MIMEHelper.java
===================================================================
--- /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/MIMEHelper.java	(revision 394993)
+++ /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/MIMEHelper.java	(working copy)
@@ -16,15 +16,6 @@
 
 package org.apache.axiom.attachments;
 
-import org.apache.axiom.om.OMException;
-import org.apache.axiom.om.impl.MTOMConstants;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-import javax.activation.DataHandler;
-import javax.mail.MessagingException;
-import javax.mail.internet.ContentType;
-import javax.mail.internet.ParseException;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -32,6 +23,16 @@
 import java.util.HashMap;
 import java.util.Set;
 
+import javax.activation.DataHandler;
+import javax.mail.MessagingException;
+import javax.mail.internet.ContentType;
+import javax.mail.internet.ParseException;
+
+import org.apache.axiom.om.OMException;
+import org.apache.axiom.om.impl.MTOMConstants;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
 public class MIMEHelper {
 
     /**
@@ -63,7 +64,7 @@
      * Parts. This Map will be keyed using the content-ID's
      */
     HashMap bodyPartsMap;
-
+    
     /**
      * <code>partIndex</code>- Number of Mime parts parsed
      */
@@ -68,6 +69,15 @@
      * <code>partIndex</code>- Number of Mime parts parsed
      */
     int partIndex = 0;
+    
+    /** Container to hold streams for direct access */
+    IncomingAttachmentStreams streams = null;
+    
+    /** <code>boolean</code> Indicating if any streams have been directly requested */
+    boolean streamsRequested = false;
+    
+    /** <code>boolean</code> Indicating if any data handlers have been directly requested */
+    boolean partsRequested = false;
 
     /**
      * <code>endOfStreamReached</code> flag which is to be set by
@@ -152,6 +162,13 @@
                 throw new OMException("Stream Error" + e1.toString(), e1);
             }
         }
+        
+        // Read the SOAP part and cache it
+        getPart(getSOAPPartContentID());
+        
+        // Now reset partsRequested. SOAP part is a special case which is always 
+        // read beforehand, regardless of request.
+        partsRequested = false;
     }
 
     /**
@@ -251,8 +268,8 @@
      * @return The DataHandler of the mime part referred by the Content-Id
      * @throws OMException
      */
-    public DataHandler getDataHandler(String blobContentID) throws OMException {
-
+    public DataHandler getDataHandler(String blobContentID) throws OMException, IllegalStateException {
+    	
         try {
             return getPart(blobContentID).getDataHandler();
         } catch (MessagingException e) {
@@ -263,6 +280,30 @@
     }
 
     /**
+     * Stream based access
+     * 
+     * @return The stream container of type <code>IncomingAttachmentStreams</code>
+     * @throws IllegalStateException if application has alreadt started using Part's directly
+     */
+    public IncomingAttachmentStreams getIncomingAttachmentStreams() throws IllegalStateException {
+    	if (partsRequested) {
+    		throw new IllegalStateException("The attachments stream can only be accessed once; either by using the IncomingAttachmentStreams class or by getting a collection of AttachmentPart objects. They cannot both be called within the life time of the same service request.");
+    	}
+
+    	streamsRequested = true;
+
+    	if (this.streams == null) {
+       		BoundaryDelimitedStream boundaryDelimitedStream =
+                new BoundaryDelimitedStream(pushbackInStream,
+                        boundary, 1024);
+
+       		this.streams = new MultipartAttachmentStreams(boundaryDelimitedStream);
+    	}
+
+    	return this.streams;
+    }
+    
+    /**
      * Checks whether the MIME part is already parsed by checking the
      * parts HashMap. If it is not parsed yet then call the getNextPart()
      * till the required part is found.
@@ -358,6 +399,13 @@
      * @throws OMException if Stream ends while reading the next part...
      */
     private Part getPart() throws OMException {
+
+    	if (streamsRequested) {
+    		throw new IllegalStateException("The attachments stream can only be accessed once; either by using the IncomingAttachmentStreams class or by getting a collection of AttachmentPart objects. They cannot both be called within the life time of the same service request.");
+    	}
+    	
+    	partsRequested = true;
+    	
         // endOfStreamReached will be set to true if the message ended in MIME
         // Style having "--" suffix with the last mime boundary
         if (endOfStreamReached) {
@@ -402,6 +450,7 @@
                                                          boundary, this);
                 part = new PartOnMemory(partStream);
             }
+            
             // This will take care if stream ended without having MIME
             // message terminator
             if (part.getSize() <= 0) {
@@ -408,6 +457,7 @@
                 throw new OMException(
                         "Referenced MIME part not found.End of Stream reached.");
             }
+
         } catch (MessagingException e) {
             throw new OMException(e);
         }
Index: /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/Part.java
===================================================================
--- /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/Part.java	(revision 394993)
+++ /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/Part.java	(working copy)
@@ -37,6 +37,8 @@
     
     public DataHandler getDataHandler() throws MessagingException ;
     
+    public void addHeader(String arg0, String arg1) throws MessagingException ;
+    
     public String getHeader(String arg0) throws MessagingException ;
     
     public Enumeration getAllHeaders() throws MessagingException ;
Index: /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/PartOnFile.java
===================================================================
--- /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/PartOnFile.java	(revision 394993)
+++ /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/PartOnFile.java	(working copy)
@@ -16,11 +16,6 @@
 
 package org.apache.axiom.attachments;
 
-import org.apache.axiom.om.OMException;
-
-import javax.activation.DataHandler;
-import javax.activation.FileDataSource;
-import javax.mail.MessagingException;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -28,7 +23,14 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.Enumeration;
-import java.util.HashMap;
+import java.util.Hashtable;
+
+import javax.activation.DataHandler;
+import javax.activation.FileDataSource;
+import javax.mail.Header;
+import javax.mail.MessagingException;
+
+import org.apache.axiom.om.OMException;
 
 public class PartOnFile implements Part {
 
@@ -40,7 +42,7 @@
 
     String contentID;
 
-    HashMap headers;
+    Hashtable headers;
 
     public PartOnFile(PushbackFilePartInputStream inStream, String repoDir) {
         super();
@@ -45,7 +47,7 @@
     public PartOnFile(PushbackFilePartInputStream inStream, String repoDir) {
         super();
 
-        headers = new HashMap();
+        headers = new Hashtable();
 
         if (repoDir == null) {
             repoDir = ".";
@@ -104,18 +106,22 @@
     private void putToMap(StringBuffer header) {
         String headerString = header.toString();
         int delimiter = headerString.indexOf(":");
-        headers.put(headerString.substring(0, delimiter).trim(), headerString
-                .substring(delimiter + 1, headerString.length()).trim());
+        
+        String name = headerString.substring(0, delimiter).trim();
+        String value= headerString.substring(delimiter + 1, headerString.length()).trim();
+
+        Header headerObj = new Header(name, value);
+        headers.put(name, headerObj);
     }
 
     public String getContentID() {
-        String cID = (String) headers.get("Content-ID");
+        Header cID = (Header) headers.get("Content-ID");
         if (cID == null) {
-            cID = (String) headers.get("Content-Id");
+            cID = (Header) headers.get("Content-Id");
             if (cID == null) {
-                cID = (String) headers.get("Content-id");
+                cID = (Header) headers.get("Content-id");
                 if (cID == null) {
-                    cID = (String) headers.get("content-id");
+                    cID = (Header) headers.get("content-id");
                 }
             }
 
@@ -120,7 +126,7 @@
             }
 
         }
-        return cID;
+        return (String) cID.getValue();
     }
 
     public int getSize() throws MessagingException {
@@ -161,24 +167,27 @@
     }
 
     public String getHeader(String arg0) throws MessagingException {
-        String header;
-        header = (String) headers.get(arg0);
-        return header;
+    	return (String) ((Header) headers.get(arg0)).getValue();
+    }
+
+    public void addHeader(String arg0, String arg1) throws MessagingException {
+    	Header headerObj = new Header(arg0, arg1);
+        headers.put(arg0, headerObj);
     }
 
     public Enumeration getAllHeaders() throws MessagingException {
-        return null;
+        return headers.elements();
     }
 
     public String getContentType() throws MessagingException {
-        String cType = (String) headers.get("Content-Type");
+        Header cType = (Header) headers.get("Content-Type");
         if (cType == null) {
-            cType = (String) headers.get("Content-type");
+            cType = (Header) headers.get("Content-type");
             if (cType == null) {
-                cType = (String) headers.get("content-type");
+                cType = (Header) headers.get("content-type");
             }
         }
-        return cType;
+        return (String) cType.getValue();
     }
 
 }
\ No newline at end of file
Index: /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/PartOnMemory.java
===================================================================
--- /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/PartOnMemory.java	(revision 394993)
+++ /home/deepak/workspace/axiom/src/org/apache/axiom/attachments/PartOnMemory.java	(working copy)
@@ -51,6 +51,10 @@
         return part.getDataHandler();
     }
 
+    public void addHeader(String arg0, String arg1) throws MessagingException {
+        part.addHeader(arg0, arg1);
+    }
+
     public String getHeader(String arg0) throws MessagingException {
        return part.getHeader(arg0)[0];
     }
Index: /home/deepak/workspace/axiom/test/org/apache/axiom/attachments/MIMEHelperTest.java
===================================================================
--- /home/deepak/workspace/axiom/test/org/apache/axiom/attachments/MIMEHelperTest.java	(revision 394993)
+++ /home/deepak/workspace/axiom/test/org/apache/axiom/attachments/MIMEHelperTest.java	(working copy)
@@ -16,10 +16,27 @@
 
 package org.apache.axiom.attachments;
 
-import junit.framework.TestCase;
+import java.awt.Image;
+import java.io.FileInputStream;
+import java.io.InputStream;
+
+import javax.activation.DataHandler;
+import javax.imageio.ImageIO;
+
+import org.apache.axiom.attachments.utils.ImageDataSource;
+import org.apache.axiom.om.AbstractTestCase;
+
+public class MIMEHelperTest extends AbstractTestCase {
+
+    public MIMEHelperTest(String testName) {
+        super(testName);
+    }
 
-public class MIMEHelperTest extends TestCase {
+    String inMimeFileName = "mtom/MTOMAttachmentStream.bin";
+    String img1FileName = "mtom/img/test.jpg";
+    String img2FileName = "mtom/img/test2.jpg";
 
+    String contentTypeString = "multipart/related; boundary=MIMEBoundaryurn:uuid:A3ADBAEE51A1A87B2A11443668160701; type=\"application/xop+xml\"; start=\"<0.urn:uuid:A3ADBAEE51A1A87B2A11443668160702@apache.org>\"; start-info=\"application/soap+xml\"; charset=UTF-8;action=\"mtomSample\"";
 
     public void testMIMEHelper() {
     }
@@ -27,10 +44,140 @@
     public void testGetAttachmentSpecType() {
     }
 
-    public void testGetSOAPPartInputStream() {
+    public void testSimultaneousStreamAccess() throws Exception {
+        InputStream inStream; 
+        MIMEHelper mimeHelper; 
+
+        inStream = new FileInputStream(getTestResourceFile(inMimeFileName));
+        mimeHelper = new MIMEHelper(inStream, contentTypeString);
+
+        mimeHelper.getDataHandler("2.urn:uuid:A3ADBAEE51A1A87B2A11443668160994@apache.org");
+        
+        // This should throw an error
+        try {
+        	mimeHelper.getIncomingAttachmentStreams();
+        	fail("No exception caught when attempting to access datahandler and stream at the same time");
+        } catch (IllegalStateException ise) {
+        	// Nothing
+        }
+        
+        inStream.close();
+        
+        // Try the other way around.
+        inStream = new FileInputStream(getTestResourceFile(inMimeFileName));
+        mimeHelper = new MIMEHelper(inStream, contentTypeString);
+
+        mimeHelper.getIncomingAttachmentStreams();
+
+        // These should NOT throw error even though they are using part based access
+        try {
+            assertEquals("application/xop+xml; charset=UTF-8; type=\"application/soap+xml\";", mimeHelper.getSOAPPartContentType());
+        } catch (IllegalStateException ise) {
+        	fail("No exception expected when requesting SOAP part data");
+        	ise.printStackTrace();
+        }
+
+        try {
+            mimeHelper.getSOAPPartInputStream();
+        } catch (IllegalStateException ise) {
+        	fail("No exception expected when requesting SOAP part data");
+        }
+        
+        // These should throw an error
+        try {
+            mimeHelper.getDataHandler("2.urn:uuid:A3ADBAEE51A1A87B2A11443668160994@apache.org");
+        	fail("No exception caught when attempting to access stream and datahandler at the same time");
+        } catch (IllegalStateException ise) {
+        	// Nothing
+        }
+        
+        // Additionally, we also need to ensure mutual exclusion if someone 
+        // tries to access part data directly 
+
+        try {
+            mimeHelper.getAllContentIDs();
+        	fail("No exception caught when attempting to access stream and contentids list at the same time");
+        } catch (IllegalStateException ise) {
+        	// Nothing
+        }
+        
+        try {
+            mimeHelper.getPart("2.urn:uuid:A3ADBAEE51A1A87B2A11443668160994@apache.org");
+        	fail("No exception caught when attempting to access stream and part at the same time");
+        } catch (IllegalStateException ise) {
+        	// Nothing
+        }
+    }
+
+    public void testGetInputAttachhmentStreams() throws Exception {
+
+        Image expectedImage;
+        IncomingAttachmentInputStream dataIs;
+        ImageDataSource dataSource;
+        InputStream expectedDataIs;
+    	
+        InputStream inStream = new FileInputStream(getTestResourceFile(inMimeFileName));
+        MIMEHelper mimeHelper = new MIMEHelper(inStream, contentTypeString);
+
+        // Since SOAP part operated independently of other streams, access it 
+        // directly, and then get to the streams. If this sequence throws an 
+        // error, something is wrong with the stream handling code.
+        InputStream is = mimeHelper.getSOAPPartInputStream();
+        while (is.read() != -1);
+        
+        // Get the inputstream container
+        IncomingAttachmentStreams ias = mimeHelper.getIncomingAttachmentStreams();
+
+        dataIs = ias.getNextStream();
+        expectedImage = ImageIO.read(new FileInputStream(getTestResourceFile(img1FileName)));
+        dataSource = new ImageDataSource("test1.jpg", expectedImage);
+        expectedDataIs = dataSource.getInputStream();
+        compareStreams(dataIs, expectedDataIs);
+
+        dataIs = ias.getNextStream();
+        expectedImage = ImageIO.read(new FileInputStream(getTestResourceFile(img2FileName)));
+        dataSource = new ImageDataSource("test2.jpg", expectedImage);
+        expectedDataIs = dataSource.getInputStream();
+        compareStreams(dataIs, expectedDataIs);
+        
+        // Confirm that no more streams are left
+        assertEquals(null, ias.getNextStream());
+
+        // After all is done, we should *still* be able to access and 
+        // re-consume the SOAP part stream, as it should be cached.. can we?
+        is = mimeHelper.getSOAPPartInputStream();
+        while (is.read() != -1);
     }
 
-    public void testGetDataHandler() {
+    private void compareStreams(InputStream data, InputStream expected) throws Exception {
+        // Compare data across streams
+        int i = 0, expectedData = 0;
+        
+        while ((i = data.read()) != -1 && (expectedData = expected.read()) != -1) {
+        	if (i != expectedData) {
+        		fail("Data streams do not match: " + i + " != " + expectedData);
+        	}
+        }
+        
+        // Ensure that *both* streams have ended
+        if ((i == -1 && expected.read() != -1) || (expectedData == -1 && i != -1)) {
+        	fail("Data streams do not match: " + i + " != " + expectedData);
+        }
     }
 
-}
\ No newline at end of file
+    public void testGetDataHandler() throws Exception {
+
+        InputStream inStream = new FileInputStream(getTestResourceFile(inMimeFileName));
+        MIMEHelper mimeHelper = new MIMEHelper(inStream, contentTypeString);
+        
+        DataHandler dh = mimeHelper.getDataHandler("2.urn:uuid:A3ADBAEE51A1A87B2A11443668160994@apache.org");
+        InputStream dataIs = dh.getDataSource().getInputStream();
+
+        Image expectedImage = ImageIO.read(new FileInputStream(getTestResourceFile(img2FileName)));
+        ImageDataSource dataSource = new ImageDataSource("test.jpg", expectedImage);
+        InputStream expectedDataIs = dataSource.getInputStream();
+
+        // Compare data across streams
+        compareStreams(dataIs, expectedDataIs);
+    }
+}
