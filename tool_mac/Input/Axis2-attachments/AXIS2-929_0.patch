Index: xdocs/1_0/OMTutorial.html
===================================================================
--- xdocs/1_0/OMTutorial.html	(revision 425298)
+++ xdocs/1_0/OMTutorial.html	(working copy)
@@ -413,7 +413,7 @@
 root.addChild(elt1);</pre>
 
 <p>Serilization of the root element produces the following XML</p>
-<pre class="xml">&lt;x:root xmlns:x="bar" xmlns:y="bar1"&gt;&lt;x:foo&gt;&lt;y:yuck&gt;blah&lt;/y:yuck&gt;&lt;/x:foo&gt;&lt;/x:root&gt;</pre>
+<pre class="xml">&lt;x:root xmlns:x="bar"&gt;&lt;x:foo&gt;&lt;y:yuck xmlns:y="bar1"&gt;blah&lt;/y:yuck&gt;&lt;/x:foo&gt;&lt;/x:root&gt;</pre>
 <a name="traversing"></a>
 
 <h3>Traversing</h3>
@@ -496,7 +496,7 @@
 </div>
 <pre class="code">XMLStreamWriter writer = XMLOutputFactory.newInstance().createXMLStreamWriter(System.out);
 //dump the output to console with caching
-envelope.serialize(writer); 
+root.serialize(writer); 
 writer.flush();</pre>
 or simply
 <pre class="code"> System.out.println(root.toStringWithConsume()); </pre>
@@ -507,7 +507,7 @@
 accurately figure out the namespaces. The example is from Code Listing 6
 which creates a small OM programmatically. Serialization of the root element
 produces the following,</p>
-<pre class="xml">&lt;x:root xmlns:x="bar" xmlns:y="bar1"&gt;&lt;x:foo&gt;&lt;y:yuck&gt;blah&lt;/y:yuck&gt;&lt;/x:foo&gt;&lt;/x:root&gt;</pre>
+<pre class="xml">&lt;x:root xmlns:x="bar"&gt;&lt;x:foo&gt;&lt;y:yuck xmlns:y="bar1"&gt;blah&lt;/y:yuck&gt;&lt;/x:foo&gt;&lt;/x:root&gt;</pre>
 
 <p>However serialization of only the foo element produces the following</p>
 <pre class="xml">&lt;x:foo xmlns:x="bar"&gt;&lt;y:yuck xmlns:y="bar1"&gt;blah&lt;/y:yuck&gt;&lt;/x:foo&gt;</pre>
@@ -526,6 +526,7 @@
 </div>
 <pre class="code">//create the parser
 XMLStreamReader parser = XMLInputFactory.newInstance().createXMLStreamReader(new FileInputStream(file));
+
 //create the builder
 StAXOMBuilder builder = new StAXOMBuilder(parser);
 
@@ -615,7 +616,7 @@
 <p>Although the serializer acts correctly in every situation, the code that
 it produces may not be efficient all the time. Take the following case where
 a similar Code Listing to Code Listing 6 is used, but with two elements
-having the same namespace. Note that the newly added items are in bold.</p>
+having the same namespace. Note that the newly added items are with the comment.</p>
 
 <div align="left">
 <p><b>Code Listing 11</b></p>
@@ -626,28 +627,38 @@
 OMNamespace ns2 = root.declareNamespace("bar1","y");
 OMElement elt1 = factory.createOMElement("foo",ns1);
 OMElement elt2 = factory.createOMElement("yuck",ns2);
-<b>OMElement elt3 = factory.createOMElement("yuck",ns2);</b>
+OMElement elt3 = factory.createOMElement("yuck",ns2);	// new code
 OMText txt1 = factory.createText(elt2,"blah");
-<b>OMText txt2 = factory.createText(elt3,"blahblah");
-elt3.addchild(txt2);</b>
+OMText txt2 = factory.createText(elt3,"blahblah");	// new code
+elt3.addchild(txt2);	// new code
 elt2.addChild(txt1);
 elt1.addChild(elt2);
-<b>elt1.addChild(elt3);</b>
+elt1.addChild(elt3);	// new code
 root.addChild(elt1);</pre>
 
-<p>Serialization of the root element provides the following XML</p>
+<p>Earlier Serialization of the root element provides the following XML</p>
 <pre class="xml">&lt;x:root xmlns:x="bar" xmlns:y="bar1"&gt;&lt;x:foo&gt;&lt;y:yuck&gt;blahblah&lt;/y:yuck&gt;&lt;y:yuck&gt;blah&lt;/y:yuck&gt;&lt;/x:foo&gt;&lt;/x:root&gt;</pre>
 
 <p>However if the serialization is carried on the foo element then the
 following XML is produced</p>
-<pre class="xml">&lt;x:foo xmlns:x="bar" &gt;&lt;y:yuck " xmlns:y="bar1"&gt;blahblah&lt;/y:yuck&gt;&lt;y:yuck " xmlns:y="bar1"&gt;blah&lt;/y:yuck&gt;&lt;/x:foo&gt;</pre>
+<pre class="xml">&lt;x:foo xmlns:x="bar" &gt;&lt;y:yuck xmlns:y="bar1"&gt;blahblah&lt;/y:yuck&gt;&lt;y:yuck xmlns:y="bar1"&gt;blah&lt;/y:yuck&gt;&lt;/x:foo&gt;</pre>
 
-<p>Note that the same Namespace is serialized twice. This XML is semantically
+<p>Note the code that the same Namespace is serialized twice. This XML is semantically
 correct but the same semantics could have been achieved by placing the y
 namespace declaration on the parent element. This behavior is due to the
 nature of the serialization where it tries to be accurate but not optimal. It
 is deliberately kept unchanged since such optimizations slow down the common
 case.</p>
+
+<p><b>Note This does not exist now. Earlier problem with two elements
+having the same namespace is now not exists</b></p>
+<p>Now the Serialization of the root element provides the following XML</p>
+<pre class="xml">&lt;x:root xmlns:x="bar"&gt;&lt;x:foo&gt;&lt;y:yuck xmlns:y="bar1"&gt;blahblah&lt;/y:yuck&gt;&lt;y:yuck xmlns:y="bar1"&gt;blah&lt;/y:yuck&gt;&lt;/x:foo&gt;&lt;/x:root&gt;</pre>
+
+<p>And if the serialization is carried on the foo element then the
+following XML is produced</p>
+<pre class="xml">&lt;x:foo xmlns:x="bar" &gt;&lt;y:yuck xmlns:y="bar1"&gt;blahblah&lt;/y:yuck&gt;&lt;y:yuck xmlns:y="bar1"&gt;blah&lt;/y:yuck&gt;&lt;/x:foo&gt;</pre>
+
 <a name="summary"></a>
 
 <h2>Summary</h2>
@@ -681,7 +692,9 @@
         try {
             //create the parser
             XMLStreamReader parser = XMLInputFactory.newInstance().createXMLStreamReader(new FileInputStream(args[0]));
-            //get the root element (in this case the envelope)
+            //create the builder
+            StAXOMBuilder builder = new StAXOMBuilder(parser);
+            //get the root element (in this case If its SOAP File then the envelope)
             OMElement documentElement = builder.getDocumentElement();
 
             //dump the out put to console with caching
