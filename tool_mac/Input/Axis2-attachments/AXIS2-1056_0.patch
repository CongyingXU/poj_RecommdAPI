Index: src/org/apache/ws/java2wsdl/utils/Java2WSDLOptionsValidator.java
===================================================================
--- src/org/apache/ws/java2wsdl/utils/Java2WSDLOptionsValidator.java	(revision 433544)
+++ src/org/apache/ws/java2wsdl/utils/Java2WSDLOptionsValidator.java	(working copy)
@@ -39,6 +39,9 @@
                 Java2WSDLConstants.ELEMENT_FORM_DEFAULT_OPTION.equalsIgnoreCase(optionType) ||
                 Java2WSDLConstants.ATTR_FORM_DEFAULT_OPTION_LONG.equalsIgnoreCase(optionType) ||
                 Java2WSDLConstants.ELEMENT_FORM_DEFAULT_OPTION_LONG.equalsIgnoreCase(optionType) ||
+                Java2WSDLConstants.ELEMENT_FORM_DEFAULT_OPTION.equalsIgnoreCase(optionType) ||
+                Java2WSDLConstants.EXTRA_CLASSES_DEFAULT_OPTION_LONG.equalsIgnoreCase(optionType) ||
+                Java2WSDLConstants.EXTRA_CLASSES_DEFAULT_OPTION.equalsIgnoreCase(optionType) ||
 
                 Java2WSDLConstants.CLASSNAME_OPTION_LONG.equalsIgnoreCase(optionType) ||
                 Java2WSDLConstants.OUTPUT_FILENAME_OPTION_LONG.equalsIgnoreCase(optionType) ||
Index: src/org/apache/ws/java2wsdl/Java2WSDLBuilder.java
===================================================================
--- src/org/apache/ws/java2wsdl/Java2WSDLBuilder.java	(revision 433544)
+++ src/org/apache/ws/java2wsdl/Java2WSDLBuilder.java	(working copy)
@@ -5,6 +5,7 @@
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.List;
 /*
 * Copyright 2004,2005 The Apache Software Foundation.
 *
@@ -43,6 +44,7 @@
     private String style = Java2WSDLConstants.DOCUMENT;
     private String use = Java2WSDLConstants.LITERAL;
     private String locationUri = Java2WSDLConstants.DEFAULT_LOCATION_URL;
+    private ArrayList extraClasses;
 
     public String getSchemaTargetNamespace() {
         return schemaTargetNamespace;
@@ -146,6 +148,7 @@
         sg.setExcludeMethods(excludeOpeartion);
         sg.setAttrFormDefault(getAttrFormDefault());
         sg.setElementFormDefault(getElementFormDefault());
+        sg.setExtraClasses(getExtraClasses());
         Collection schemaCollection = sg.generateSchema();
         Java2OMBuilder java2OMBuilder = new Java2OMBuilder(sg.getMethods(),
                 schemaCollection,
@@ -177,5 +180,13 @@
     public void setElementFormDefault(String elementFormDefault) {
         this.elementFormDefault = elementFormDefault;
     }
+
+    public ArrayList getExtraClasses() {
+        return extraClasses;
+    }
+
+    public void setExtraClasses(ArrayList extraClasses) {
+        this.extraClasses = extraClasses;
+    }
 }
 
Index: src/org/apache/ws/java2wsdl/Java2OMBuilder.java
===================================================================
--- src/org/apache/ws/java2wsdl/Java2OMBuilder.java	(revision 433544)
+++ src/org/apache/ws/java2wsdl/Java2OMBuilder.java	(working copy)
@@ -136,13 +136,12 @@
     private void generateTypes(OMFactory fac, OMElement defintions)
             throws Exception {
         OMElement wsdlTypes = fac.createOMElement("types", wsdl);
-        StringWriter writer = new StringWriter();
-
-        // wrap the Schema elements with this start and end tags to create a
+                // wrap the Schema elements with this start and end tags to create a
         // document root
         // under which the schemas can fall into
 
         for (Iterator iterator = schemaCollection.iterator(); iterator.hasNext();) {
+            StringWriter writer = new StringWriter();
             XmlSchema xmlSchema = (XmlSchema) iterator.next();
             xmlSchema.write(writer);
             String schemaString = writer.toString();
Index: src/org/apache/ws/java2wsdl/SchemaGenerator.java
===================================================================
--- src/org/apache/ws/java2wsdl/SchemaGenerator.java	(revision 433544)
+++ src/org/apache/ws/java2wsdl/SchemaGenerator.java	(working copy)
@@ -78,6 +78,8 @@
     private String elementFormDefault = null;
 
     private ArrayList excludeMethods = new ArrayList();
+    
+    private ArrayList extraClasses = null;
 
     public SchemaGenerator(ClassLoader loader, String className,
                            String schematargetNamespace, String schematargetNamespacePrefix)
@@ -101,7 +103,6 @@
         } else {
             this.schema_namespace_prefix = SCHEMA_NAMESPACE_PRFIX;
         }
-        //initializeSchemaMap(this.schemaTargetNameSpace, this.schema_namespace_prefix);
     }
 
     /**
@@ -120,8 +121,13 @@
         //it can posible to add the classLoader as well
         jam_service_parms.addClassLoader(classLoader);
         jam_service_parms.includeClass(className);
+        
+        for ( int count = 0 ; count < getExtraClasses().size() ; ++count )
+        {
+            jam_service_parms.includeClass((String)getExtraClasses().get(count));
+        }
         JamService service = factory.createService(jam_service_parms);
-
+        QName extraSchemaTypeName = null;
         JamClassIterator jClassIter = service.getClasses();
         //all most all the time the ittr will have only one class in it
         while (jClassIter.hasNext()) {
@@ -129,71 +135,83 @@
             // serviceName = jclass.getSimpleName();
             //todo in the future , when we support annotation we can use this
             //JAnnotation[] annotations = jclass.getAnnotations();
-
-            /**
-             * Schema genertaion done in two stage 1. Load all the methods and
-             * create type for methods parameters (if the parameters are Bean
-             * then it will create Complex types for those , and if the
-             * parameters are simple type which decribe in SimpleTypeTable
-             * nothing will happen) 2. In the next stage for all the methods
-             * messages and port types will be creteated
-             */
-            methods = jclass.getDeclaredMethods();
-            //short the elements in the array
-            Arrays.sort(methods);
-
-            // since we do not support overload
-            HashMap uniqueMethods = new HashMap();
-            XmlSchemaComplexType methodSchemaType;
-            XmlSchemaSequence sequence = null;
-
-            for (int i = 0; i < methods.length; i++) {
-                JMethod jMethod = methods[i];
-                String methodName = methods[i].getSimpleName();
-                // no need to think abt this method , since that is system
-                // config method
-                if (excludeMethods.contains(jMethod.getSimpleName())) {
-                    continue;
+            
+            if ( jclass.getQualifiedName().equals(className) )
+            {
+                /**
+                 * Schema genertaion done in two stage 1. Load all the methods and
+                 * create type for methods parameters (if the parameters are Bean
+                 * then it will create Complex types for those , and if the
+                 * parameters are simple type which decribe in SimpleTypeTable
+                 * nothing will happen) 2. In the next stage for all the methods
+                 * messages and port types will be creteated
+                 */
+                methods = jclass.getDeclaredMethods();
+                //short the elements in the array
+                Arrays.sort(methods);
+    
+                // since we do not support overload
+                HashMap uniqueMethods = new HashMap();
+                XmlSchemaComplexType methodSchemaType;
+                XmlSchemaSequence sequence = null;
+    
+                for (int i = 0; i < methods.length; i++) {
+                    JMethod jMethod = methods[i];
+                    String methodName = methods[i].getSimpleName();
+                    // no need to think abt this method , since that is system
+                    // config method
+                    if (excludeMethods.contains(jMethod.getSimpleName())) {
+                        continue;
+                    }
+    
+                    if (uniqueMethods.get(jMethod.getSimpleName()) != null) {
+                        throw new Exception(
+                                " Sorry we don't support methods overloading !!!! ");
+                    }
+    
+                    if (!jMethod.isPublic()) {
+                        // no need to generate Schema for non public methods
+                        continue;
+                    }
+                    uniqueMethods.put(jMethod.getSimpleName(), jMethod);
+                    //create the schema type for the method wrapper
+    
+                    uniqueMethods.put(jMethod.getSimpleName(), jMethod);
+                    JParameter [] paras = jMethod.getParameters();
+                    String parameterNames [] = null;
+                    if (paras.length > 0) {
+                        parameterNames = methodTable.getParameterNames(methodName);
+                        sequence = new XmlSchemaSequence();
+    
+                        methodSchemaType = createSchemaTypeForMethodPart(jMethod.getSimpleName());
+                        methodSchemaType.setParticle(sequence);
+                    }
+    
+                    for (int j = 0; j < paras.length; j++) {
+                        JParameter methodParameter = paras[j];
+                        JClass paraType = methodParameter.getType();
+                        generateSchemaForType(sequence, paraType,
+                                (parameterNames != null && parameterNames[j] != null) ? parameterNames[j] : methodParameter.getSimpleName());
+                    }
+                    // for its return type
+                    JClass returnType = jMethod.getReturnType();
+    
+                    if (!returnType.isVoidType()) {
+                        methodSchemaType = createSchemaTypeForMethodPart(jMethod.getSimpleName() + RESPONSE);
+                        sequence = new XmlSchemaSequence();
+                        methodSchemaType.setParticle(sequence);
+                        generateSchemaForType(sequence, returnType, "return");
+                    }
                 }
-
-                if (uniqueMethods.get(jMethod.getSimpleName()) != null) {
-                    throw new Exception(
-                            " Sorry we don't support methods overloading !!!! ");
+            }
+            else
+            {
+                //generate the schema type for extra classes
+                extraSchemaTypeName = typeTable.getSimpleSchemaTypeName(jclass.getQualifiedName());
+                if (extraSchemaTypeName == null) 
+                {
+                    extraSchemaTypeName = generateSchema(jclass);
                 }
-
-                if (!jMethod.isPublic()) {
-                    // no need to generate Schema for non public methods
-                    continue;
-                }
-                uniqueMethods.put(jMethod.getSimpleName(), jMethod);
-                //create the schema type for the method wrapper
-
-                uniqueMethods.put(jMethod.getSimpleName(), jMethod);
-                JParameter [] paras = jMethod.getParameters();
-                String parameterNames [] = null;
-                if (paras.length > 0) {
-                    parameterNames = methodTable.getParameterNames(methodName);
-                    sequence = new XmlSchemaSequence();
-
-                    methodSchemaType = createSchemaTypeForMethodPart(jMethod.getSimpleName());
-                    methodSchemaType.setParticle(sequence);
-                }
-
-                for (int j = 0; j < paras.length; j++) {
-                    JParameter methodParameter = paras[j];
-                    JClass paraType = methodParameter.getType();
-                    generateSchemaForType(sequence, paraType,
-                            (parameterNames != null && parameterNames[j] != null) ? parameterNames[j] : methodParameter.getSimpleName());
-                }
-                // for its return type
-                JClass returnType = jMethod.getReturnType();
-
-                if (!returnType.isVoidType()) {
-                    methodSchemaType = createSchemaTypeForMethodPart(jMethod.getSimpleName() + RESPONSE);
-                    sequence = new XmlSchemaSequence();
-                    methodSchemaType.setParticle(sequence);
-                    generateSchemaForType(sequence, returnType, "return");
-                }
             }
         }
         return schemaMap.values();
@@ -453,4 +471,16 @@
         }
     }
 
+    public ArrayList getExtraClasses() {
+        if ( extraClasses == null )
+        {
+            extraClasses = new ArrayList();
+        }
+        return extraClasses;
+    }
+
+    public void setExtraClasses(ArrayList extraClasses) {
+        this.extraClasses = extraClasses;
+    }
+
 }
Index: src/org/apache/ws/java2wsdl/Java2WSDLCodegenEngine.java
===================================================================
--- src/org/apache/ws/java2wsdl/Java2WSDLCodegenEngine.java	(revision 433544)
+++ src/org/apache/ws/java2wsdl/Java2WSDLCodegenEngine.java	(working copy)
@@ -10,6 +10,7 @@
 import java.net.URLClassLoader;
 import java.util.ArrayList;
 import java.util.Map;
+import java.util.Vector;
 /*
 * Copyright 2004,2005 The Apache Software Foundation.
 *
@@ -33,35 +34,51 @@
 
     public Java2WSDLCodegenEngine(Map optionsMap) throws Exception {
         //create a new  Java2WSDLBuilder and populate it
-        File outputFolder;
+        Java2WSDLCommandLineOption option = loadOption(Java2WSDLConstants.CLASSNAME_OPTION, Java2WSDLConstants.CLASSNAME_OPTION_LONG, optionsMap);
+        String className = option == null ? null : option.getOptionValue();
 
+        if (className == null || className.equals("")) {
+            throw new Exception("class name must be present!");
+        }
+
+        //Now we are done with loading the basic values - time to create the builder
+        java2WsdlBuilder = new Java2WSDLBuilder(resolveOutputStream(className, optionsMap),
+                                                className,
+                                                resolveClassLoader(optionsMap));
+        
+        configureJava2WSDLBuilder(optionsMap, className);
+    }
+
+    public void generate() throws Exception {
+        try {
+            java2WsdlBuilder.generateWSDL();
+        } catch (Exception e) {
+            throw new Exception(e);
+        }
+    }
+
+    private FileOutputStream resolveOutputStream(String className, Map optionsMap) throws Exception
+    {
         Java2WSDLCommandLineOption option = loadOption(Java2WSDLConstants.OUTPUT_LOCATION_OPTION,
-                Java2WSDLConstants.OUTPUT_LOCATION_OPTION_LONG, optionsMap);
+                                                       Java2WSDLConstants.OUTPUT_LOCATION_OPTION_LONG, optionsMap);
         String outputFolderName = option == null ? System.getProperty("user.dir") : option.getOptionValue();
 
-
+        File outputFolder;
         outputFolder = new File(outputFolderName);
         if (!outputFolder.exists()) {
             outputFolder.mkdirs();
         } else if (!outputFolder.isDirectory()) {
             throw new Exception("The specivied location " + outputFolderName + "is not a folder");
         }
-
-        option = loadOption(Java2WSDLConstants.CLASSNAME_OPTION, Java2WSDLConstants.CLASSNAME_OPTION_LONG, optionsMap);
-        String className = option == null ? null : option.getOptionValue();
-
-        if (className == null || className.equals("")) {
-            throw new Exception("class name must be present!");
-        }
-
+        
         option = loadOption(Java2WSDLConstants.OUTPUT_FILENAME_OPTION,
-                Java2WSDLConstants.OUTPUT_FILENAME_OPTION_LONG, optionsMap);
+                            Java2WSDLConstants.OUTPUT_FILENAME_OPTION_LONG, optionsMap);
         String outputFileName = option == null ? null : option.getOptionValue();
         //derive a file name from the class name if the filename is not specified
         if (outputFileName == null) {
             outputFileName = Java2WSDLUtils.getSimpleClassName(className) + WSDL_FILENAME_SUFFIX;
         }
-
+    
         //first create a file in the given location
         File outputFile = new File(outputFolder, outputFileName);
         FileOutputStream out;
@@ -73,10 +90,15 @@
         } catch (IOException e) {
             throw new Exception(e);
         }
-
-        //if the class path is present, create a URL class loader with those
+        
+        return out;
+    }
+    
+    private ClassLoader resolveClassLoader(Map optionsMap) throws Exception
+    {
+        // if the class path is present, create a URL class loader with those
         //class path entries present. if not just take the  TCCL
-        option = loadOption(Java2WSDLConstants.CLASSPATH_OPTION,
+        Java2WSDLCommandLineOption option = loadOption(Java2WSDLConstants.CLASSPATH_OPTION,
                 Java2WSDLConstants.CLASSPATH_OPTION_LONG, optionsMap);
 
         ClassLoader classLoader;
@@ -105,14 +127,14 @@
         } else {
             classLoader = Thread.currentThread().getContextClassLoader();
         }
+        
+        return classLoader;
+    }
 
-        //Now we are done with loading the basic values - time to create the builder
-        java2WsdlBuilder = new Java2WSDLBuilder(out,
-                className,
-                classLoader);
-
+    private void configureJava2WSDLBuilder(Map optionsMap, String className) throws Exception
+    {
         //set the other parameters to the builder
-        option = loadOption(Java2WSDLConstants.SCHEMA_TARGET_NAMESPACE_OPTION,
+        Java2WSDLCommandLineOption option = loadOption(Java2WSDLConstants.SCHEMA_TARGET_NAMESPACE_OPTION,
                 Java2WSDLConstants.SCHEMA_TARGET_NAMESPACE_OPTION_LONG, optionsMap);
         java2WsdlBuilder.setSchemaTargetNamespace(option == null ? null : option.getOptionValue());
 
@@ -158,18 +180,11 @@
                 Java2WSDLConstants.ELEMENT_FORM_DEFAULT_OPTION_LONG, optionsMap);
         java2WsdlBuilder.setElementFormDefault(option == null ? null : option.getOptionValue());
         
-
-
+        option = loadOption(Java2WSDLConstants.EXTRA_CLASSES_DEFAULT_OPTION,
+                            Java2WSDLConstants.EXTRA_CLASSES_DEFAULT_OPTION_LONG, optionsMap);
+        java2WsdlBuilder.setExtraClasses(option == null ? new ArrayList() : option.getOptionValues());
     }
-
-    public void generate() throws Exception {
-        try {
-            java2WsdlBuilder.generateWSDL();
-        } catch (Exception e) {
-            throw new Exception(e);
-        }
-    }
-
+    
      /**
      * @param shortOption
      * @param longOption
Index: src/org/apache/ws/java2wsdl/Java2WSDLConstants.java
===================================================================
--- src/org/apache/ws/java2wsdl/Java2WSDLConstants.java	(revision 433544)
+++ src/org/apache/ws/java2wsdl/Java2WSDLConstants.java	(working copy)
@@ -99,6 +99,7 @@
     String LOCATION_OPTION = "l";
     String ATTR_FORM_DEFAULT_OPTION = "afd";
     String ELEMENT_FORM_DEFAULT_OPTION = "efd";
+    String EXTRA_CLASSES_DEFAULT_OPTION = "xc";
 
     //long option constants
     String OUTPUT_LOCATION_OPTION_LONG = "output";
@@ -116,6 +117,7 @@
     String AXIS2_NAMESPACE_PREFIX = "ns1";
     String ATTR_FORM_DEFAULT_OPTION_LONG = "attributeFormDefault";
     String ELEMENT_FORM_DEFAULT_OPTION_LONG = "elementFormDefault";
+    String EXTRA_CLASSES_DEFAULT_OPTION_LONG = "extraClasses";
 
     public static final String SOLE_INPUT = "SOLE_INPUT";
 
Index: src/org/apache/ws/java2wsdl/Java2WSDL.java
===================================================================
--- src/org/apache/ws/java2wsdl/Java2WSDL.java	(revision 433544)
+++ src/org/apache/ws/java2wsdl/Java2WSDL.java	(working copy)
@@ -45,8 +45,11 @@
         System.out.println("-st <binding style> : style for the WSDL");
         System.out.println("-u <binding use> : use for the WSDL");
         System.out.println("-l <soap address> : address of the port for the WSDL");
-        System.out.println("-efd <unqualified> : Setting for elementFormDefault (defaults to qualified)");
-        System.out.println("-afd <unqualified> : Setting for attributeFormDefault (defaults to qualified)");
+        System.out.println("-efd <qualified/unqualified> : Setting for elementFormDefault (defaults to qualified)");
+        System.out.println("-afd <qualified/unqualified> : Setting for attributeFormDefault (defaults to qualified)");
+        System.out.println("-xc <extra class> : Extra class for which schematype must be generated.  " +
+                           "\t\tUse as : -xc class1 -xc class2 ...");
+        
         System.exit(0);
     }
 
