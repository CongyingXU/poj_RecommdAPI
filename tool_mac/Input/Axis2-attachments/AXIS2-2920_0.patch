Index: modules/codegen/src/org/apache/axis2/wsdl/codegen/codegen-config.properties
===================================================================
--- modules/codegen/src/org/apache/axis2/wsdl/codegen/codegen-config.properties	(revision 554320)
+++ modules/codegen/src/org/apache/axis2/wsdl/codegen/codegen-config.properties	(working copy)
@@ -26,6 +26,7 @@
 # Note the last extension - It includes a check to figure out whether proper databinding has taken place
 # This extension should appear AFTER all the databinding extensions inorder to function properly
 codegen.extension=org.apache.axis2.wsdl.codegen.extension.PackageFinder,\
+org.apache.axis2.wsdl.codegen.extension.JAXWSWapperExtension,\
   org.apache.axis2.wsdl.codegen.extension.SchemaUnwrapperExtension,\
   org.apache.axis2.wsdl.codegen.extension.JaxMeExtension, \
   org.apache.axis2.wsdl.codegen.extension.XMLBeansExtension, \
@@ -78,12 +79,12 @@
 # Language types - these are the language types that the code generator understands. Again this is the name of the
 # language that should be passed from the tool as well
 #
-codegen.languages=java,c
+codegen.languages=java,c,jax-ws
 # Emitter class is the  major code generator class that should be changed according to the language.
 # The emiiters need to implement the org.apache.axis2.wsdl.codegen.emitter.Emitter interface
 # Note - The emitters should appear in the lexical order of the languages. So the language java in the above
 # list corresponds to the org.apache.axis2.wsdl.codegen.emitter.JavaEmitter
-codegen.emitters=org.apache.axis2.wsdl.codegen.emitter.AxisServiceBasedMultiLanguageEmitter,org.apache.axis2.wsdl.codegen.emitter.CEmitter
+codegen.emitters=org.apache.axis2.wsdl.codegen.emitter.AxisServiceBasedMultiLanguageEmitter,org.apache.axis2.wsdl.codegen.emitter.CEmitter,org.apache.axis2.wsdl.codegen.emitter.jaxws.JAXWS20Emitter
 # Default language, this is the default language that would be picked when no language is specified. it should be
 # one of the languages specified above
 codegen.languages.default=java
@@ -136,3 +137,14 @@
 # file extension for generated source files from this language
 c.filename.extension=c
 
+jax-ws.callback.template=org.apache.axis2.wsdl.codegen.writer.CallbackHandlerWriter,/org/apache/axis2/wsdl/template/java/CallbackHandlerTemplate.xsl
+jax-ws.exception.template=org.apache.axis2.wsdl.codegen.writer.ExceptionWriter,/org/apache/axis2/wsdl/template/java/JaxwsExceptionTemplate.xsl
+jax-ws.skeleton.template=org.apache.axis2.wsdl.codegen.writer.SkeletonWriter,/org/apache/axis2/wsdl/template/java/JaxwsServiceClassTemplate.xsl
+jax-ws.skeleton.interface.template=org.apache.axis2.wsdl.codegen.writer.SkeletonInterfaceWriter,/org/apache/axis2/wsdl/template/java/JaxwsServiceEndpointInterfaceTemplate.xsl
+jax-ws.testclass.template=org.apache.axis2.wsdl.codegen.writer.TestClassWriter,/org/apache/axis2/wsdl/template/java/TestClassTemplate.xsl
+jax-ws.service.template=org.apache.axis2.wsdl.codegen.writer.ServiceXMLWriter,/org/apache/axis2/wsdl/template/general/ServiceXMLTemplate.xsl
+jax-ws.antbuild.jaxbri.template=org.apache.axis2.wsdl.codegen.writer.AntBuildWriter,/org/apache/axis2/wsdl/template/general/jaxbriAntBuildTemplate.xsl
+jax-ws.antbuild.none.template=org.apache.axis2.wsdl.codegen.writer.AntBuildWriter,/org/apache/axis2/wsdl/template/general/defaultAntBuildTemplate.xsl
+# file extension for generated files from this language
+jax-ws.filename.extension=java
+
Index: modules/codegen/src/org/apache/axis2/wsdl/codegen/emitter/jaxws/JAXWSEmitter.java
===================================================================
--- modules/codegen/src/org/apache/axis2/wsdl/codegen/emitter/jaxws/JAXWSEmitter.java	(revision 0)
+++ modules/codegen/src/org/apache/axis2/wsdl/codegen/emitter/jaxws/JAXWSEmitter.java	(revision 0)
@@ -0,0 +1,212 @@
+package org.apache.axis2.wsdl.codegen.emitter.jaxws;
+
+import org.w3c.dom.Document;
+import org.apache.axis2.wsdl.codegen.writer.FileWriter;
+import org.apache.axis2.wsdl.codegen.writer.SkeletonInterfaceWriter;
+import org.apache.axis2.wsdl.codegen.writer.ExceptionWriter;
+import org.apache.axis2.wsdl.codegen.writer.SkeletonWriter;
+import org.apache.axis2.wsdl.codegen.emitter.AxisServiceBasedMultiLanguageEmitter;
+import org.apache.axis2.wsdl.codegen.CodeGenerationException;
+import org.apache.axis2.wsdl.codegen.CodeGenConfiguration;
+import org.apache.axis2.wsdl.util.XSLTIncludeResolver;
+import org.apache.axis2.wsdl.databinding.TypeMapper;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.WSDL2Constants;
+
+import java.util.Iterator;
+import java.util.Map;
+import java.util.HashMap;
+
+public abstract class JAXWSEmitter extends AxisServiceBasedMultiLanguageEmitter {
+
+    protected final static String TYPE_SUFFIX = "Type";
+    protected final static String SERVICE_SUFFIX = "Service";
+    protected final static String EXCEPTION_SUFFIX = "Exception";
+
+    protected String portTypeName;
+    protected String serviceName;
+    protected String packageName;
+    protected String targetNS;
+
+    public void setCodeGenConfiguration(CodeGenConfiguration configuration) {
+        super.setCodeGenConfiguration(configuration);
+        portTypeName = (String) axisService.getParameterValue(WSDL2Constants.INTERFACE_LOCAL_NAME);
+        serviceName = axisService.getName();
+        targetNS = codeGenConfiguration.getTargetNamespace();
+        packageName = codeGenConfiguration.getPackageName();
+    }
+
+    public void emitSkeleton() throws CodeGenerationException {
+
+        try {
+
+            Map originalMap = getNewCopy(this.mapper.getAllMappedNames());
+            // we are going to generate following files seperately per service
+            for (Iterator axisServicesIter = this.axisServices.iterator();
+                 axisServicesIter.hasNext();) {
+                this.axisService = (AxisService) axisServicesIter.next();
+                this.axisBinding =
+                        axisService.getEndpoint(axisService.getEndpointName()).getBinding();
+
+                // see the comment at updateMapperClassnames for details and reasons for
+                // calling this method
+                if (mapper.isObjectMappingPresent()) {
+                    copyMap(originalMap, this.mapper.getAllMappedNames());
+                    updateMapperForMessageReceiver();
+                } else {
+                    copyToFaultMap();
+                }
+
+                //handle faults
+                generateAndPopulateFaultNames();
+
+                //write the Service Endpoint Interface
+                writeServiceEndpointInterface();
+
+                //write the Exceptions
+                writeExceptions();
+
+                //write the Service Class
+                writeServiceClass();
+            }
+
+            // save back type map
+            if (this.mapper.isObjectMappingPresent()) {
+                copyMap(originalMap, this.mapper.getAllMappedNames());
+            }
+
+            // write service xml
+            // if asked
+            if (codeGenConfiguration.isGenerateDeployementDescriptor()) {
+                writeServiceXml();
+            }
+
+            //write the ant build
+            //we skip this for the flattened case
+            if (!codeGenConfiguration.isFlattenFiles()) {
+                writeAntBuild();
+            }
+
+
+        } catch (CodeGenerationException cgExp) {
+            throw cgExp;
+        } catch (Exception e) {
+            throw new CodeGenerationException(e);
+        }
+    }
+
+    /**
+     * Write the service endpoint interface
+     *
+     * @throws Exception
+     */
+    protected void writeServiceEndpointInterface() throws Exception {
+
+        Document skeletonModel = createDOMDocumentForSEI();
+        debugLogDocument("Document for Service Endpoint Interface:", skeletonModel);
+        FileWriter skeletonInterfaceWriter = new SkeletonInterfaceWriter(
+                codeGenConfiguration.isFlattenFiles() ?
+                        getOutputDirectory(codeGenConfiguration.getOutputLocation(), null) :
+                        getOutputDirectory(codeGenConfiguration.getOutputLocation(),
+                                codeGenConfiguration.getSourceLocation())
+                , this.codeGenConfiguration.getOutputLanguage());
+
+        writeFile(skeletonModel, skeletonInterfaceWriter);
+    }
+
+    /**
+     * Writes the exception calsses.
+     */
+    protected void writeExceptions() throws Exception {
+        String key;
+        Iterator iterator = fullyQualifiedFaultClassNameMap.keySet().iterator();
+        while (iterator.hasNext()) {
+            key = (String) iterator.next();
+
+
+            Document skeletonModel = createDOMDocumentForException(key);
+            debugLogDocument("Document for Exception Class:", skeletonModel);
+            ExceptionWriter exceptionWriter =
+                    new ExceptionWriter(
+                            codeGenConfiguration.isFlattenFiles() ?
+                                    getOutputDirectory(codeGenConfiguration.getOutputLocation(),
+                                            null) :
+                                    getOutputDirectory(codeGenConfiguration.getOutputLocation(),
+                                            codeGenConfiguration.getSourceLocation()),
+                            codeGenConfiguration.getOutputLanguage());
+
+            writeFile(skeletonModel, exceptionWriter);
+        }
+    }
+
+    /**
+     * Write the service class
+     *
+     * @throws Exception
+     */
+    protected void writeServiceClass() throws Exception {
+        Document skeletonModel = createDOMDocumentForServiceClass();
+        debugLogDocument("Document for Service Endpoint Interface:", skeletonModel);
+        FileWriter skeletonInterfaceWriter = new SkeletonWriter(
+                codeGenConfiguration.isFlattenFiles() ?
+                        getOutputDirectory(codeGenConfiguration.getOutputLocation(), null) :
+                        getOutputDirectory(codeGenConfiguration.getOutputLocation(),
+                                codeGenConfiguration.getSourceLocation())
+                , this.codeGenConfiguration.getOutputLanguage());
+
+        writeFile(skeletonModel, skeletonInterfaceWriter);
+    }
+
+    /**
+     * Creates the XML model for the Service Endpoint interface
+     *
+     * @return DOM Document
+     */
+    protected abstract Document createDOMDocumentForSEI();
+
+    /**
+     * Creates the XML model for the Service Class
+     *
+     * @return DOM Document
+     */
+    protected abstract Document createDOMDocumentForServiceClass();
+
+    /**
+     * Creates the XML model for a Exception Class
+     *
+     * @param key String
+     * @return DOM Document
+     */
+    protected abstract Document createDOMDocumentForException(String key);
+
+    //Util methods
+    public String extratClassName(String fullyQualifiedName) {
+        if (fullyQualifiedName == null) {
+            return "";
+        }
+
+        String className = fullyQualifiedName.substring(fullyQualifiedName.lastIndexOf('.'),
+                fullyQualifiedName.length());
+
+        if (className.charAt(0) == '.') {
+            return className.substring(1);
+        }
+
+        return className;
+    }
+
+    protected String getFullyQualifiedName(String className, String packageName) {
+//        className = makeJavaClassName(className);
+        return packageName + "." + className;
+    }
+
+    protected String resolveNameCollision(String className, String packageName, String suffix) {
+        className = makeJavaClassName(className);
+        String fullQualifiedName = getFullyQualifiedName(className, packageName);
+        Map map = mapper.getAllMappedNames();
+        if (map.containsValue(fullQualifiedName)) {
+            return className + suffix;
+        }
+        return className;
+    }
+}
Index: modules/codegen/src/org/apache/axis2/wsdl/codegen/emitter/jaxws/JAXWS20Emitter.java
===================================================================
--- modules/codegen/src/org/apache/axis2/wsdl/codegen/emitter/jaxws/JAXWS20Emitter.java	(revision 0)
+++ modules/codegen/src/org/apache/axis2/wsdl/codegen/emitter/jaxws/JAXWS20Emitter.java	(revision 0)
@@ -0,0 +1,171 @@
+package org.apache.axis2.wsdl.codegen.emitter.jaxws;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.apache.axis2.description.WSDL2Constants;
+import org.apache.axis2.util.JavaUtils;
+import org.apache.woden.internal.util.dom.DOM2Writer;
+
+import javax.xml.namespace.QName;
+import java.util.Iterator;
+
+public class JAXWS20Emitter extends JAXWSEmitter {
+
+    /**
+     * Creates the XML model for the Service Endpoint interface
+     *
+     * @return DOM Document
+     */
+    protected Document createDOMDocumentForSEI() {
+        Document doc = getEmptyDocument();
+        Element rootElement = doc.createElement("javaConstruct");
+
+        Element importList = doc.createElement("importList");
+        rootElement.appendChild(importList);
+
+        portTypeName = resolveNameCollision(portTypeName, packageName, TYPE_SUFFIX);
+
+        addAttribute(doc, "package", packageName, rootElement);
+        addAttribute(doc, "targetNamespace", targetNS, rootElement);
+        addAttribute(doc, "name", portTypeName, rootElement);
+
+        Element annotationElement = AnnotationElementBuilder.buildWebServiceAnnotationElement(portTypeName, targetNS,
+                "", doc);
+        rootElement.appendChild(annotationElement);
+
+        loadOperations(doc, rootElement, null);
+
+        //attach a list of faults
+        rootElement.appendChild(getUniqueListofFaults(doc));
+        doc.appendChild(rootElement);
+        //////////////////////////////////////////////////////////
+//        System.out.println(DOM2Writer.nodeToString(rootElement));
+        ////////////////////////////////////////////////////////////
+        return doc;
+
+    }
+
+    /**
+     * Creates the XML model for the Service Class
+     *
+     * @return DOM Document
+     */
+    protected Document createDOMDocumentForServiceClass() {
+        Document doc = getEmptyDocument();
+        Element rootElement = doc.createElement("javaConstruct");
+
+        Element importList = doc.createElement("importList");
+        rootElement.appendChild(importList);
+
+        String capitalizedServiceName = serviceName.toUpperCase();
+        String wsdlLocation = "Needs to be fixed";
+
+        serviceName = resolveNameCollision(serviceName, packageName, TYPE_SUFFIX);
+
+        addAttribute(doc, "package", packageName, rootElement);
+        addAttribute(doc, "targetNamespace", targetNS, rootElement);
+        addAttribute(doc, "name", serviceName, rootElement);
+        addAttribute(doc, "wsdlLocation", wsdlLocation, rootElement);
+        addAttribute(doc, "capitalizedServiceName", capitalizedServiceName, rootElement);
+
+        //Adding annotations -- tempory solution  hardcoded solution
+//        Element importElement;
+//        importElement = doc.createElement("import");
+//        addAttribute(doc, "value", "java.net.URL", importElement);
+//        importList.appendChild(importElement);
+
+        Element annotationElement = AnnotationElementBuilder.buildWebServiceClientAnnotationElement(serviceName,
+                targetNS, wsdlLocation, doc);
+        rootElement.appendChild(annotationElement);
+
+        //Building portType Elements -- think of a suitable solution
+        for (Iterator portIterator = axisService.getEndpoints().keySet().iterator(); portIterator.hasNext();) {
+            String portName = (String) portIterator.next();
+
+            Element portElement = doc.createElement("port");
+            addAttribute(doc, "portName", portName, portElement);
+            addAttribute(doc, "portTypeName", portTypeName, portElement);
+
+            Element endPointAnnoElement = AnnotationElementBuilder.buildWebEndPointAnnotationElement(portName, doc);
+            portElement.appendChild(endPointAnnoElement);
+
+            rootElement.appendChild(portElement);
+        }
+
+        //attach a list of faults
+        rootElement.appendChild(getUniqueListofFaults(doc));
+        doc.appendChild(rootElement);
+        //////////////////////////////////////////////////////////
+//        System.out.println(DOM2Writer.nodeToString(rootElement));
+        ////////////////////////////////////////////////////////////
+        return doc;
+    }
+
+    /**
+     * Creates the XML model for a Exception Class
+     *
+     * @param key String
+     * @return DOM Document
+     */
+    protected Document createDOMDocumentForException(String key) {
+        Document doc = getEmptyDocument();
+        Element faultElement;
+
+        faultElement = doc.createElement("javaConstruct");
+        Element importList = doc.createElement("importList");
+        faultElement.appendChild(importList);
+
+        addAttribute(doc, "package", packageName, faultElement);
+        addAttribute(doc, "targetNamespace", targetNS, faultElement);
+
+        String exceptionClassName = (String) faultClassNameMap.get(key);
+        exceptionClassName = resolveNameCollision(exceptionClassName, packageName, EXCEPTION_SUFFIX);
+        addAttribute(doc, "name",exceptionClassName, faultElement);
+//            addAttribute(doc, "shortName",
+//                    (String) faultClassNameMap.get(key) + "Exception",
+//                    faultElement);
+
+        //the type represents the type that will be wrapped by this
+        //name
+        String typeMapping =
+                this.mapper.getTypeMappingName((QName) faultElementQNameMap.get(key));
+        String shortType = extratClassName(typeMapping);
+
+        addAttribute(doc, "type", (typeMapping == null)
+                ? ""
+                : typeMapping, faultElement);
+
+        addAttribute(doc, "shortType", (shortType == null)
+                ? ""
+                : shortType, faultElement);
+
+        Element importElement;
+        importElement = doc.createElement("import");
+        addAttribute(doc, "value", typeMapping, importElement);
+        importList.appendChild(importElement);
+
+//            String attribValue = (String) instantiatableMessageClassNames.
+//                    get(key);
+//            addAttribute(doc, "instantiatableType",
+//                    attribValue == null ? "" : attribValue,
+//                    faultElement);
+
+        // add an extra attribute to say whether the type mapping is
+        // the default
+        if (mapper.getDefaultMappingName().equals(typeMapping)) {
+            addAttribute(doc, "default", "yes", faultElement);
+        }
+
+        addAttribute(doc, "value", getParamInitializer(typeMapping),
+                faultElement);
+
+        Element annotationElement = AnnotationElementBuilder.buildWebFaultAnnotationElement(typeMapping,
+                codeGenConfiguration.getTargetNamespace(), doc);
+        faultElement.appendChild(annotationElement);
+        doc.appendChild(faultElement);
+        //////////////////////////////////////////////////////////
+//        System.out.println(DOM2Writer.nodeToString(faultElement));
+        ////////////////////////////////////////////////////////////
+        return doc;
+    }
+}
\ No newline at end of file
Index: modules/codegen/src/org/apache/axis2/wsdl/codegen/emitter/jaxws/AnnotationElementBuilder.java
===================================================================
--- modules/codegen/src/org/apache/axis2/wsdl/codegen/emitter/jaxws/AnnotationElementBuilder.java	(revision 0)
+++ modules/codegen/src/org/apache/axis2/wsdl/codegen/emitter/jaxws/AnnotationElementBuilder.java	(revision 0)
@@ -0,0 +1,81 @@
+package org.apache.axis2.wsdl.codegen.emitter.jaxws;
+
+import org.w3c.dom.Element;
+import org.w3c.dom.Document;
+import org.apache.axis2.util.XSLTUtils;
+
+public class AnnotationElementBuilder {
+
+    static Element buildWebServiceAnnotationElement(String name, String targetNS, String wsdlLocation,
+                                                    Document doc) {
+
+        Element annotationElement = doc.createElement("annotation");
+        XSLTUtils.addAttribute(doc, "name", "javax.jws.WebService", annotationElement);
+
+        Element paramElement = doc.createElement("param");
+        XSLTUtils.addAttribute(doc, "type", "name", paramElement);
+        XSLTUtils.addAttribute(doc, "value", name, paramElement);
+        annotationElement.appendChild(paramElement);
+
+        paramElement = doc.createElement("param");
+        XSLTUtils.addAttribute(doc, "type", "targetNamespace", paramElement);
+        XSLTUtils.addAttribute(doc, "value", targetNS, paramElement);
+        annotationElement.appendChild(paramElement);
+
+        return annotationElement;
+    }
+
+    static Element buildWebFaultAnnotationElement(String name, String targetNS, Document doc) {
+        Element annotationElement = doc.createElement("annotation");
+        XSLTUtils.addAttribute(doc, "name", "javax.xml.ws.WebFault", annotationElement);
+
+        Element paramElement = doc.createElement("param");
+        XSLTUtils.addAttribute(doc, "type", "name", paramElement);
+        XSLTUtils.addAttribute(doc, "value", name, paramElement);
+        annotationElement.appendChild(paramElement);
+
+        paramElement = doc.createElement("param");
+        XSLTUtils.addAttribute(doc, "type", "targetNamespace", paramElement);
+        XSLTUtils.addAttribute(doc, "value", targetNS, paramElement);
+        annotationElement.appendChild(paramElement);
+
+        return annotationElement;
+    }
+
+    static Element buildWebServiceClientAnnotationElement(String name, String targetNS, String wsdlLocation,
+                                                          Document doc) {
+
+        Element annotationElement = doc.createElement("annotation");
+        XSLTUtils.addAttribute(doc, "name", "javax.xml.ws.WebServiceClient", annotationElement);
+
+        Element paramElement = doc.createElement("param");
+        XSLTUtils.addAttribute(doc, "type", "name", paramElement);
+        XSLTUtils.addAttribute(doc, "value", name, paramElement);
+        annotationElement.appendChild(paramElement);
+
+        paramElement = doc.createElement("param");
+        XSLTUtils.addAttribute(doc, "type", "targetNamespace", paramElement);
+        XSLTUtils.addAttribute(doc, "value", targetNS, paramElement);
+        annotationElement.appendChild(paramElement);
+
+        paramElement = doc.createElement("param");
+        XSLTUtils.addAttribute(doc, "type", "wsdlLocation", paramElement);
+        XSLTUtils.addAttribute(doc, "value", wsdlLocation, paramElement);
+        annotationElement.appendChild(paramElement);
+
+        return annotationElement;
+    }
+
+    static Element buildWebEndPointAnnotationElement(String name, Document doc) {
+        Element annotationElement = doc.createElement("annotation");
+        XSLTUtils.addAttribute(doc, "name", "javax.xml.ws.WebEndpoint", annotationElement);
+
+        Element paramElement = doc.createElement("param");
+        XSLTUtils.addAttribute(doc, "type", "name", paramElement);
+        XSLTUtils.addAttribute(doc, "value", name, paramElement);
+        annotationElement.appendChild(paramElement);
+
+        return annotationElement;
+    }
+}
+
Index: modules/codegen/src/org/apache/axis2/wsdl/codegen/emitter/AxisServiceBasedMultiLanguageEmitter.java
===================================================================
--- modules/codegen/src/org/apache/axis2/wsdl/codegen/emitter/AxisServiceBasedMultiLanguageEmitter.java	(revision 554320)
+++ modules/codegen/src/org/apache/axis2/wsdl/codegen/emitter/AxisServiceBasedMultiLanguageEmitter.java	(working copy)
@@ -528,7 +528,7 @@
         }
     }
 
-    private Map getNewCopy(Map copyFormMap) {
+    public Map getNewCopy(Map copyFormMap) {
         Map copyToMap = new HashMap();
         Object key;
         for (Iterator iter = copyFormMap.keySet().iterator(); iter.hasNext();) {
@@ -538,7 +538,7 @@
         return copyToMap;
     }
 
-    private void copyMap(Map copyFormMap, Map copyToMap) {
+    public void copyMap(Map copyFormMap, Map copyToMap) {
         Object key;
         for (Iterator iter = copyFormMap.keySet().iterator(); iter.hasNext();) {
             key = iter.next();
Index: modules/codegen/src/org/apache/axis2/wsdl/template/java/JaxwsServiceEndpointInterfaceTemplate.xsl
===================================================================
--- modules/codegen/src/org/apache/axis2/wsdl/template/java/JaxwsServiceEndpointInterfaceTemplate.xsl	(revision 0)
+++ modules/codegen/src/org/apache/axis2/wsdl/template/java/JaxwsServiceEndpointInterfaceTemplate.xsl	(revision 0)
@@ -0,0 +1,76 @@
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+    <xsl:output method="text"/>
+
+    <xsl:variable name="targetNs" select="/javaConstruct/@targetNamespace"/>
+
+    <xsl:template match="javaConstruct">package <xsl:value-of select="@package"/>;
+<xsl:for-each select="importList/import">
+import <xsl:value-of select="@value"/>;</xsl:for-each>
+<xsl:text>
+</xsl:text>
+/**
+ * <xsl:value-of select="@name"/>.java
+ *
+ * This class was generated by Apache Axis2.
+ * Apache Axis2 {version} - {date} {time}
+ *
+ */
+<xsl:for-each select="annotation">
+    <xsl:variable name="annoparamcount" select="count(param)"/>
+@<xsl:value-of select="@name"/>(<xsl:for-each select="param">
+        <xsl:choose>
+            <xsl:when test="$annoparamcount = position()">
+                <xsl:value-of select="@type"/>
+                <xsl:text>=</xsl:text>"<xsl:value-of select="@value"/>"</xsl:when>
+            <xsl:otherwise>
+                <xsl:value-of select="@type"/>
+                <xsl:text>=</xsl:text>"<xsl:value-of select="@value"/>",<xsl:text> </xsl:text>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:for-each>)</xsl:for-each>
+public interface <xsl:value-of select="@name"/>{
+<xsl:apply-templates/>
+}
+    </xsl:template>
+
+    <xsl:template match="method">
+    <xsl:variable name="outparamcount" select="count(output/param)"/>
+    /**<xsl:for-each select="input/param">
+    * @param <xsl:value-of select="@name"/></xsl:for-each><xsl:if test="$outparamcount != 0">
+    * @return
+    *    <xsl:value-of select="output/param/@shorttype"/></xsl:if><xsl:for-each select="fault/param[@type!='']">
+    * @throws <xsl:value-of select="@name"/></xsl:for-each>
+    */
+    @javax.jws.WebMethod
+    <xsl:choose>
+        <xsl:when test="$outparamcount = 0">@javax.jws.Oneway</xsl:when>
+        <xsl:otherwise>@javax.jws.WebResult(targetNamespace = "<xsl:value-of select="$targetNs"/>")</xsl:otherwise>
+    </xsl:choose>
+    public <xsl:choose>
+                <xsl:when test="$outparamcount = 0">void </xsl:when>
+                <xsl:otherwise><xsl:value-of select="output/param/@type"/><xsl:text> </xsl:text></xsl:otherwise>
+           </xsl:choose>
+    <xsl:value-of select="@name"/>(<xsl:variable name="inparamcount" select="count(input/param)"/>
+    <xsl:for-each select="input/param">
+        @javax.jws.WebParam(name = "<xsl:value-of select="@name"/>", targetNamespace = "<xsl:value-of select="$targetNs"/>")
+        <xsl:choose>
+            <xsl:when test="$inparamcount = position()">
+                <xsl:value-of select="@type"/>
+                <xsl:text> </xsl:text>
+                <xsl:value-of select="@name"/>
+            </xsl:when>
+            <xsl:otherwise>
+                <xsl:value-of select="@type"/>
+                <xsl:text> </xsl:text>
+                <xsl:value-of select="@name"/>,<xsl:text> </xsl:text>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:for-each>)<!--<xsl:for-each select="fault/param[@type!='']">
+               <xsl:if test="position()=1">
+        throws </xsl:if>
+               <xsl:if test="position()>1">,</xsl:if><xsl:value-of select="@name"/>
+           </xsl:for-each>-->;
+    </xsl:template>
+
+</xsl:stylesheet>
Index: modules/codegen/src/org/apache/axis2/wsdl/template/java/JaxwsServiceClassTemplate.xsl
===================================================================
--- modules/codegen/src/org/apache/axis2/wsdl/template/java/JaxwsServiceClassTemplate.xsl	(revision 0)
+++ modules/codegen/src/org/apache/axis2/wsdl/template/java/JaxwsServiceClassTemplate.xsl	(revision 0)
@@ -0,0 +1,83 @@
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+    <xsl:output method="text"/>
+
+    <xsl:variable name="targetNs" select="/javaConstruct/@targetNamespace"/>
+    <xsl:variable name="serviceName" select="/javaConstruct/@name"/>
+    <xsl:variable name="capitalizedServiceName" select="/javaConstruct/@capitalizedServiceName"/>
+    <xsl:variable name="wsdlLocation" select="/javaConstruct/@wsdlLocation"/>
+
+    <xsl:template match="javaConstruct">package <xsl:value-of select="@package"/>;
+
+import java.net.URL;
+import javax.xml.namespace.QName;
+import java.net.MalformedURLException;
+import javax.xml.ws.Service;<!--<xsl:for-each select="importList/import">-->
+<!--import <xsl:value-of select="@value"/>;</xsl:for-each>-->
+/**
+ * <xsl:value-of select="@name"/>.java
+ *
+ * This class was generated by Apache Axis2.
+ * Apache Axis2 {version} - {date} {time}
+ *
+ */
+<xsl:for-each select="annotation">
+    <xsl:variable name="annoparamcount" select="count(param)"/>
+@<xsl:value-of select="@name"/>(<xsl:for-each select="param">
+        <xsl:choose>
+            <xsl:when test="$annoparamcount = position()">
+                <xsl:value-of select="@type"/>
+                <xsl:text>=</xsl:text>"<xsl:value-of select="@value"/>"</xsl:when>
+            <xsl:otherwise>
+                <xsl:value-of select="@type"/>
+                <xsl:text>=</xsl:text>"<xsl:value-of select="@value"/>",<xsl:text> </xsl:text>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:for-each>)</xsl:for-each>
+public class <xsl:value-of select="$serviceName"/> extends Service {
+
+    public final static URL <xsl:value-of select="$capitalizedServiceName"/>_WSDL_LOCATION;
+
+    static {
+        URL url = null;
+
+        try {
+            url = new URL("<xsl:value-of select="$wsdlLocation"/>");
+        } catch (MalformedURLException e) {
+            e.printStackTrace();
+        }
+        <xsl:value-of select="$capitalizedServiceName"/>_WSDL_LOCATION = url;
+    }
+
+    public <xsl:value-of select="$serviceName"/>() {
+        super(<xsl:value-of select="$capitalizedServiceName"/>_WSDL_LOCATION,
+            new QName("<xsl:value-of select="$targetNs"/>","<xsl:value-of select="$serviceName"/>"));
+    }
+
+    public <xsl:value-of select="$serviceName"/>(URL wsdlLocation, QName serviceName) {
+        super(wsdlLocation, serviceName);
+    }
+    <xsl:for-each select="/javaConstruct/port">
+    /**
+     * @return
+     *   returns <xsl:value-of select="@portTypeName"/>
+     */<xsl:for-each select="annotation">
+    <xsl:variable name="annoparamcount" select="count(param)"/>
+    @<xsl:value-of select="@name"/>(<xsl:for-each select="param">
+        <xsl:choose>
+            <xsl:when test="$annoparamcount = position()">
+                <xsl:value-of select="@type"/>
+                <xsl:text>=</xsl:text>"<xsl:value-of select="@value"/>"</xsl:when>
+            <xsl:otherwise>
+                <xsl:value-of select="@type"/>
+                <xsl:text>=</xsl:text>"<xsl:value-of select="@value"/>",<xsl:text> </xsl:text>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:for-each>)</xsl:for-each>
+    public <xsl:value-of select="@portTypeName"/> get<xsl:value-of select="@portName"/>() {
+        return (<xsl:value-of select="@portTypeName"/>)super.getPort(new QName("<xsl:value-of select="$targetNs"/>","<xsl:value-of select="@portName"/>"),
+                <xsl:value-of select="@portTypeName"/>.class);
+    }</xsl:for-each>        
+}
+    </xsl:template>
+</xsl:stylesheet>
Index: modules/codegen/src/org/apache/axis2/wsdl/template/java/JaxwsExceptionTemplate.xsl
===================================================================
--- modules/codegen/src/org/apache/axis2/wsdl/template/java/JaxwsExceptionTemplate.xsl	(revision 0)
+++ modules/codegen/src/org/apache/axis2/wsdl/template/java/JaxwsExceptionTemplate.xsl	(revision 0)
@@ -0,0 +1,101 @@
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+    <xsl:output method="text"/>
+
+    <xsl:variable name="targetNs" select="/javaConstruct/@targetNamespace"/>
+
+    <xsl:template match="javaConstruct">package <xsl:value-of select="@package"/>;
+<xsl:for-each select="importList/import">
+import <xsl:value-of select="@value"/>;</xsl:for-each>
+<xsl:text>
+</xsl:text>
+/**
+ * <xsl:value-of select="@name"/>.java
+ *
+ * This class was generated by Apache Axis2.
+ * Apache Axis2 {version} - {date} {time}
+ *
+ */
+<xsl:for-each select="annotation">
+    <xsl:variable name="annoparamcount" select="count(param)"/>
+@<xsl:value-of select="@name"/>(<xsl:for-each select="param">
+        <xsl:choose>
+            <xsl:when test="$annoparamcount = position()">
+                <xsl:value-of select="@type"/>
+                <xsl:text>=</xsl:text>"<xsl:value-of select="@value"/>"</xsl:when>
+            <xsl:otherwise>
+                <xsl:value-of select="@type"/>
+                <xsl:text>=</xsl:text>"<xsl:value-of select="@value"/>",<xsl:text> </xsl:text>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:for-each>)</xsl:for-each>
+public class <xsl:value-of select="@name"/> extends Exception{
+
+    /**
+     * Java type that goes as soapenv:Fault detail element.
+     */
+    private <xsl:value-of select="@shortType"/> faultInfo;
+
+    /**
+     * @param faultInfo
+     * @param message
+     */
+    public <xsl:value-of select="@name"/>(String message, <xsl:value-of select="@shortType"/> faultInfo) {
+        super(message);
+        this.faultInfo = faultInfo;
+    }
+
+    /**
+     * @param faultInfo
+     * @param message
+     * @param cause
+     */
+    public <xsl:value-of select="@name"/>(String message, <xsl:value-of select="@shortType"/> faultInfo, Throwable cause) {
+        super(message, cause);
+        this.faultInfo = faultInfo;
+    }
+
+    /**
+     * @return
+     *   returns fault bean: <xsl:value-of select="@shortType"/>
+     */
+    public <xsl:value-of select="@shortType"/> getFaultInfo() {
+        return faultInfo;
+    }
+}
+    </xsl:template>
+
+   <!-- <xsl:template match="method">
+    <xsl:variable name="outparamcount" select="count(output/param)"/>
+    @javax.jws.WebMethod
+    <xsl:choose>
+        <xsl:when test="$outparamcount = 0">@javax.jws.Oneway</xsl:when>
+        <xsl:otherwise>@javax.jws.WebResult(targetNamespace = "<xsl:value-of select="$targetNs"/>")</xsl:otherwise>
+    </xsl:choose>
+    public <xsl:choose>
+                <xsl:when test="$outparamcount = 0">void </xsl:when>
+                <xsl:otherwise><xsl:value-of select="output/param/@type"/><xsl:text> </xsl:text></xsl:otherwise>
+           </xsl:choose>
+    <xsl:value-of select="@name"/>(<xsl:variable name="inparamcount" select="count(input/param)"/>
+    <xsl:for-each select="input/param">
+        @javax.jws.WebParam(name = "<xsl:value-of select="@name"/>", targetNamespace = "<xsl:value-of select="$targetNs"/>")
+        <xsl:choose>
+            <xsl:when test="$inparamcount = position()">
+                <xsl:value-of select="@type"/>
+                <xsl:text> </xsl:text>
+                <xsl:value-of select="@name"/>
+            </xsl:when>
+            <xsl:otherwise>
+                <xsl:value-of select="@type"/>
+                <xsl:text> </xsl:text>
+                <xsl:value-of select="@name"/>,<xsl:text> </xsl:text>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:for-each>)--><!--<xsl:for-each select="fault/param[@type!='']">
+               <xsl:if test="position()=1">
+        throws </xsl:if>
+               <xsl:if test="position()>1">,</xsl:if><xsl:value-of select="@name"/>
+           </xsl:for-each>--><!--;
+    </xsl:template>-->
+
+</xsl:stylesheet>
