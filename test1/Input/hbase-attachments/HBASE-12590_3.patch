diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/TableInputFormatBase.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/TableInputFormatBase.java
index 6560b41..390d54c 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/TableInputFormatBase.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/TableInputFormatBase.java
@@ -30,6 +30,7 @@ import javax.naming.NamingException;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hbase.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.classification.InterfaceStability;
 import org.apache.hadoop.hbase.HConstants;
@@ -227,7 +228,24 @@ extends InputFormat<ImmutableBytesWritable, Result> {
         }
       }
     }
-    return splits;
+    //The default value of "hbase.mapreduce.input.autobalance" is false, which means not enabled.
+    String enableAutoBalance=context.getConfiguration().get("hbase.mapreduce.input.autobalance",
+            "false");
+    if (enableAutoBalance.equals("TRUE") || enableAutoBalance.equals("true")) {
+      long totalRegionSize=0;
+      for (int i = 0; i < splits.size(); i++){
+        TableSplit ts = (TableSplit)splits.get(i);
+        totalRegionSize += ts.getLength();
+      }
+      long averageRegionSize = totalRegionSize / splits.size();
+      // the averageRegionSize must be positive.
+      if (averageRegionSize == 0) {
+          averageRegionSize = 1;
+      }
+      return getAutoBalanceSplits(splits, context, averageRegionSize);
+    } else{
+      return splits;
+    }
   }
 
   public String reverseDNS(InetAddress ipAddress) throws NamingException, UnknownHostException {
@@ -250,6 +268,124 @@ extends InputFormat<ImmutableBytesWritable, Result> {
   }
 
   /**
+   * Calculates the number of MapReduce input splits for the map tasks. The number of
+   * MapReduce input splits depends on the average region size and the "data skew ratio" user set in
+   * configuration.
+   *
+   * @param list  The list of input splits before balance.
+   * @param context  The current job context.
+   * @param average  The average size of all regions .
+   * @return The list of input splits.
+   * @throws IOException When creating the list of splits fails.
+   * @see org.apache.hadoop.mapreduce.InputFormat#getSplits(
+   *   org.apache.hadoop.mapreduce.JobContext)
+   */
+  public List<InputSplit> getAutoBalanceSplits(List<InputSplit> list, JobContext context,
+                                               long average) throws IOException {
+    List<InputSplit> resultList = new ArrayList<InputSplit>();
+    Configuration conf = context.getConfiguration();
+    //The default data skew ratio is 3
+    long dataSkewRatio = Long.parseLong(conf.get("hbase.mapreduce.input.ratio", "3"));
+    long dataSkewThreshold = dataSkewRatio * average;
+    int count = 0;
+    while (count < list.size()) {
+      TableSplit ts = (TableSplit)list.get(count);
+      String regionLocation = ts.getRegionLocation();
+      long regionSize = ts.getLength();
+      if (regionSize >= dataSkewThreshold) {
+        // if the current region size is large than the data skew threshold,
+        // split the region into two MapReduce input splits.
+        byte[] splitKey = getSplitKey(ts.getStartRow(), ts.getEndRow());
+         //Set the size of child TableSplit as 1/2 of the region size. The exact size of the
+         // Mapreduce input splits is not far off.
+        TableSplit t1 = new TableSplit(table.getName(), ts.getStartRow(), splitKey, regionLocation,
+                regionSize / 2);
+        TableSplit t2 = new TableSplit(table.getName(), splitKey, ts.getEndRow(), regionLocation,
+                regionSize - regionSize / 2);
+        resultList.add(t1);
+        resultList.add(t2);
+        count++;
+      } else if (regionSize >= average) {
+        // if the region size between average size and data skew threshold size,
+        // make this region as one MapReduce input split.
+        resultList.add(ts);
+        count++;
+      } else {
+        // if the total size of several small continuous regions less than the average region size,
+        // combine them into one MapRedecue input split.
+        long totalSize = regionSize;
+        byte[] splitStartKey = ts.getStartRow();
+        byte[] splitEndKey = ts.getEndRow();
+        count++;
+        for (; count < list.size(); count++) {
+          TableSplit nextRegion = (TableSplit)list.get(count);
+          long nextRegionSize = nextRegion.getLength();
+          if (totalSize + nextRegionSize <= dataSkewThreshold) {
+            totalSize = totalSize + nextRegionSize;
+            splitEndKey = nextRegion.getEndRow();
+          } else {
+            break;
+          }
+        }
+        TableSplit t = new TableSplit(table.getName(), splitStartKey, splitEndKey,
+                regionLocation, totalSize);
+        resultList.add(t);
+      }
+    }
+    return resultList;
+  }
+
+  /**
+   * select a split point in the region. Here are some example of the selection.
+   * startKey: aaabcdefg  endKey: aaafff    split point: aaad
+   * startKey: 111000  endKey: 1125790    split point: 112
+   * startKey: 1110  endKey: 1120    split point: 111W
+   *
+   * @param startKey Start key of the region
+   * @param endKey End key of the region
+   * @return The split point in the region.
+   * @throws IOException when calculating the split key fails.
+   */
+  private byte[] getSplitKey(byte[] startKey, byte[] endKey) throws IOException {
+    String startRow = new String(startKey) + "  ";
+    String endRow = new String(endKey) + "  ";
+    int keyLength = (startRow.length() > endRow.length()) ? startRow.length() : endRow.length();
+    char[] charArray = new char[keyLength];
+    int resultLength = 0;
+    for (int i = 0; i < keyLength; i++) {
+      if (!(startRow.charAt(i) == endRow.charAt(i))) {
+        char tempChar1 = startRow.charAt(i);
+        char tempChar2 = endRow.charAt(i);
+        if (tempChar2 - tempChar1 == 1) {
+          char nextChar1 = startRow.charAt(i + 1);
+          char nextChar2 = endRow.charAt(i + 1);
+          if (nextChar2 != ' ') {
+            charArray[i] = tempChar2;
+            charArray[i + 1] = ' ';
+          } else {
+            charArray[i] = tempChar1;
+            int def = '~' - nextChar1;
+            charArray[i + 1] = (char) (nextChar1 + def / 2);
+          }
+          resultLength = i + 2;
+        } else {
+          charArray[i] = (char) (tempChar1 + (tempChar2 - tempChar1) / 2);
+          resultLength = i + 1;
+        }
+        break;
+      } else {
+        charArray[i] = endRow.charAt(i);
+      }
+    }
+    char[] resultChar = new char[resultLength];
+    for (int i = 0; i < resultLength; i++) {
+      resultChar[i] = charArray[i];
+    }
+    String result = new String(resultChar);
+    return Bytes.toBytes(result);
+  }
+
+  /**
    *
    *
    * Test if the given region is to be included in the InputSplit while splitting
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/mapreduce/TestTableInputFormatScan1.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/mapreduce/TestTableInputFormatScan1.java
index 47cb834..ecf024b 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/mapreduce/TestTableInputFormatScan1.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/mapreduce/TestTableInputFormatScan1.java
@@ -97,4 +97,22 @@ public class TestTableInputFormatScan1 extends TestTableInputFormatScanBase {
     testScan(null, "opp", "opo");
   }
 
+  /**
+   * Tests a MR scan using specific number of mappers. The test table has 25 regions,
+   * and all region sizes are set as 0 as default. The average region size is 1 (the smallest
+   * positive). When we set hbase.mapreduce.input.ratio as -1, all regions will be cut into two
+   * MapRedcue input splits, the number of MR input splits should be 50; when we set hbase
+   * .mapreduce.input.ratio as 100, the sum of all region sizes is less then the average region
+   * size, all regions will be combined into 1 MapRedcue input split.
+   *
+   * @throws IOException
+   * @throws ClassNotFoundException
+   * @throws InterruptedException
+   */
+  @Test
+  public void testGetSplits() throws IOException, InterruptedException, ClassNotFoundException {
+      testNumOfSplits("-1", 50);
+      testNumOfSplits("100", 1);
+    }
+
 }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/mapreduce/TestTableInputFormatScanBase.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/mapreduce/TestTableInputFormatScanBase.java
index 750ea39..17ce8cc 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/mapreduce/TestTableInputFormatScanBase.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/mapreduce/TestTableInputFormatScanBase.java
@@ -22,6 +22,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.Map;
 import java.util.NavigableMap;
 
@@ -37,12 +38,15 @@ import org.apache.hadoop.hbase.client.Scan;
 import org.apache.hadoop.hbase.io.ImmutableBytesWritable;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.io.NullWritable;
+import org.apache.hadoop.mapreduce.InputSplit;
 import org.apache.hadoop.mapreduce.Job;
 import org.apache.hadoop.mapreduce.Reducer;
 import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
 import org.junit.AfterClass;
+import org.junit.Assert;
 import org.junit.BeforeClass;
 
+
 /**
  * <p>
  * Tests various scan start and stop row scenarios. This is set in a scan and
@@ -240,5 +244,34 @@ public abstract class TestTableInputFormatScanBase {
     LOG.info("After map/reduce completion - job " + jobName);
   }
 
+
+  /**
+   * Tests a MR scan using data skew auto-balance
+   *
+   * @throws IOException
+   * @throws ClassNotFoundException
+   * @throws InterruptedException
+   */
+  public void testNumOfSplits(String ratio, int expectedNumOfSplits) throws IOException,
+          InterruptedException,
+          ClassNotFoundException {
+    String jobName = "TestJobForNumOfSplits";
+    LOG.info("Before map/reduce startup - job " + jobName);
+    Configuration c = new Configuration(TEST_UTIL.getConfiguration());
+    Scan scan = new Scan();
+    scan.addFamily(INPUT_FAMILY);
+    c.set("hbase.mapreduce.input.autobalance", "true");
+    c.set("hbase.mapreduce.input.ratio", ratio);
+    c.set(KEY_STARTROW, "");
+    c.set(KEY_LASTROW, "");
+    Job job = new Job(c, jobName);
+    TableMapReduceUtil.initTableMapperJob(Bytes.toString(TABLE_NAME), scan, ScanMapper.class,
+            ImmutableBytesWritable.class, ImmutableBytesWritable.class, job);
+    TableInputFormat tif = new TableInputFormat();
+    tif.setConf(job.getConfiguration());
+    Assert.assertEquals(new String(TABLE_NAME), new String(table.getTableName()));
+    List<InputSplit> splits = tif.getSplits(job);
+    Assert.assertEquals(expectedNumOfSplits, splits.size());
+  }
 }
 
