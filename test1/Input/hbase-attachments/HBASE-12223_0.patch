diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/MultiTableInputFormatBase.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/MultiTableInputFormatBase.java
index 1bae235..960daf2 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/MultiTableInputFormatBase.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/MultiTableInputFormatBase.java
@@ -19,8 +19,12 @@ package org.apache.hadoop.hbase.mapreduce;
 
 import java.io.IOException;
 import java.text.MessageFormat;
-import java.util.ArrayList;
 import java.util.List;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Iterator;
+
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -29,7 +33,6 @@ import org.apache.hadoop.hbase.classification.InterfaceStability;
 import org.apache.hadoop.hbase.HRegionInfo;
 import org.apache.hadoop.hbase.HRegionLocation;
 import org.apache.hadoop.hbase.TableName;
-import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.client.Connection;
 import org.apache.hadoop.hbase.client.ConnectionFactory;
 import org.apache.hadoop.hbase.client.HTable;
@@ -130,66 +133,75 @@ public abstract class MultiTableInputFormatBase extends
     if (scans.isEmpty()) {
       throw new IOException("No scans were provided.");
     }
-    List<InputSplit> splits = new ArrayList<InputSplit>();
 
+    HashMap<String, List<Scan>> tableMaps = new HashMap<String, List<Scan>>();
     for (Scan scan : scans) {
-      byte[] tableNameBytes = scan.getAttribute(Scan.SCAN_ATTRIBUTES_TABLE_NAME);
-      if (tableNameBytes == null)
-        throw new IOException("A scan object did not have a table name");
+      String tableNameStr = Bytes.toString(scan.getAttribute(Scan.SCAN_ATTRIBUTES_TABLE_NAME));
+      if (tableMaps.containsKey(tableNameStr)) {
+        tableMaps.get(tableNameStr).add(scan);
+      } else {
+        ArrayList<Scan> scanList = new ArrayList<Scan>();
+        scanList.add(scan);
+        tableMaps.put(tableNameStr, scanList);
+      }
+    }
 
-      TableName tableName = TableName.valueOf(tableNameBytes);
+    List<InputSplit> splits = new ArrayList<InputSplit>();
+    Iterator iter = tableMaps.entrySet().iterator();
+    while (iter.hasNext()) {
+      Map.Entry<String, List<Scan>> entry = (Map.Entry<String, List<Scan>>) iter.next();
+      String tableNameStr = entry.getKey();
+      List<Scan> scanList = entry.getValue();
+      TableName tableName = TableName.valueOf(Bytes.toBytes(tableNameStr));
       Table table = null;
       RegionLocator regionLocator = null;
       Connection conn = null;
-      try {
+
+      try{
         conn = ConnectionFactory.createConnection(context.getConfiguration());
         table = conn.getTable(tableName);
         regionLocator = conn.getRegionLocator(tableName);
         regionLocator = (RegionLocator) table;
+        RegionSizeCalculator sizeCalculator = new RegionSizeCalculator((HTable) table);
         Pair<byte[][], byte[][]> keys = regionLocator.getStartEndKeys();
-        if (keys == null || keys.getFirst() == null ||
-            keys.getFirst().length == 0) {
-          throw new IOException("Expecting at least one region for table : "
-              + tableName.getNameAsString());
-        }
-        int count = 0;
+        for (Scan scan : scanList) {
+          if (tableNameStr == null)
+            throw new IOException("A scan object did not have a table name");
+          if (keys == null || keys.getFirst() == null || keys.getFirst().length == 0) {
+            throw new IOException("Expecting at least one region for table : "
+                    + tableNameStr);
+          }
+          int count = 0;
 
-        byte[] startRow = scan.getStartRow();
-        byte[] stopRow = scan.getStopRow();
+          byte[] startRow = scan.getStartRow();
+          byte[] stopRow = scan.getStopRow();
 
-        RegionSizeCalculator sizeCalculator = new RegionSizeCalculator((HTable) table);
+          for (int i = 0; i < keys.getFirst().length; i++) {
+            if (!includeRegionInSplit(keys.getFirst()[i], keys.getSecond()[i])) {
+              continue;
+            }
 
-        for (int i = 0; i < keys.getFirst().length; i++) {
-          if (!includeRegionInSplit(keys.getFirst()[i], keys.getSecond()[i])) {
-            continue;
-          }
-          HRegionLocation hregionLocation = regionLocator.getRegionLocation(
-              keys.getFirst()[i], false);
-          String regionHostname = hregionLocation.getHostname();
-          HRegionInfo regionInfo = hregionLocation.getRegionInfo();
+            if ((startRow.length == 0 || keys.getSecond()[i].length == 0 || Bytes.compareTo(startRow,
+                    keys.getSecond()[i]) < 0) && (stopRow.length == 0 || Bytes.compareTo(stopRow,
+                    keys.getFirst()[i]) > 0)) {
+              byte[] splitStart = startRow.length == 0 || Bytes.compareTo(keys.getFirst()[i],
+                      startRow) >= 0 ? keys.getFirst()[i] : startRow;
+              byte[] splitStop = (stopRow.length == 0 || Bytes.compareTo(keys.getSecond()[i],
+                      stopRow) <= 0) && keys.getSecond()[i].length > 0 ? keys.getSecond()[i] : stopRow;
 
-          // determine if the given start and stop keys fall into the range
-          if ((startRow.length == 0 || keys.getSecond()[i].length == 0 ||
-              Bytes.compareTo(startRow, keys.getSecond()[i]) < 0) &&
-              (stopRow.length == 0 ||
-                  Bytes.compareTo(stopRow, keys.getFirst()[i]) > 0)) {
-            byte[] splitStart =
-                startRow.length == 0 ||
-                    Bytes.compareTo(keys.getFirst()[i], startRow) >= 0 ? keys
-                    .getFirst()[i] : startRow;
-            byte[] splitStop =
-                (stopRow.length == 0 || Bytes.compareTo(keys.getSecond()[i],
-                    stopRow) <= 0) && keys.getSecond()[i].length > 0 ? keys
-                    .getSecond()[i] : stopRow;
+              HRegionLocation hregionLocation = regionLocator.getRegionLocation(keys.getFirst()[i], false);
+              String regionHostname = hregionLocation.getHostname();
+              HRegionInfo regionInfo = hregionLocation.getRegionInfo();
+              long regionSize = sizeCalculator.getRegionSize(regionInfo.getRegionName());
 
-            long regionSize = sizeCalculator.getRegionSize(regionInfo.getRegionName());
-            TableSplit split =
-                new TableSplit(table.getName(),
-                    scan, splitStart, splitStop, regionHostname, regionSize);
+              TableSplit split = new TableSplit(table.getName(),
+                      scan, splitStart, splitStop, regionHostname, regionSize);
 
-            splits.add(split);
-            if (LOG.isDebugEnabled())
-              LOG.debug("getSplits: split -> " + (count++) + " -> " + split);
+              splits.add(split);
+
+              if (LOG.isDebugEnabled())
+                LOG.debug("getSplits: split -> " + (count++) + " -> " + split);
+            }
           }
         }
       } finally {
@@ -198,6 +210,7 @@ public abstract class MultiTableInputFormatBase extends
         if (null != conn) conn.close();
       }
     }
+
     return splits;
   }
 
