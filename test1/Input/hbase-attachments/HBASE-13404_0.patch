From a6ad41541c17a21fa7a13a87a919209f122e6c85 Mon Sep 17 00:00:00 2001
From: "Apekshit(Appy) Sharma" <appy@cloudera.com>
Date: Fri, 3 Apr 2015 18:05:36 -0700
Subject: [PATCH] -a

---
 .../java/org/apache/hadoop/hbase/util/Bytes.java   | 159 +++++++++++++++------
 .../org/apache/hadoop/hbase/util/TestBytes.java    |  41 ++++--
 2 files changed, 149 insertions(+), 51 deletions(-)

diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Bytes.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Bytes.java
index 8096178..a333161 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Bytes.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Bytes.java
@@ -1308,65 +1308,71 @@ public class Bytes implements Comparable<Bytes> {
   /**
    * @param vint Integer to make a vint of.
    * @return Vint as bytes array.
+   * @deprecated Use {@link #vintToBytes(int)} ()} instead.
    */
+  @Deprecated
   public static byte [] vintToBytes(final long vint) {
-    long i = vint;
-    int size = WritableUtils.getVIntSize(i);
-    byte [] result = new byte[size];
-    int offset = 0;
-    if (i >= -112 && i <= 127) {
-      result[offset] = (byte) i;
-      return result;
-    }
-
-    int len = -112;
-    if (i < 0) {
-      i ^= -1L; // take one's complement'
-      len = -120;
-    }
-
-    long tmp = i;
-    while (tmp != 0) {
-      tmp = tmp >> 8;
-      len--;
-    }
-
-    result[offset++] = (byte) len;
+    return vintToBytes((int) vint);
+  }
 
-    len = (len < -120) ? -(len + 120) : -(len + 112);
+ /**
+   * Put vint as zero-compressed encoded int into the specified byte array position.
+   * @param bytes the byte array
+   * @param offset position in the array
+   * @param vint int to write out
+   * @return incremented offset
+   * @throws IllegalArgumentException if the byte array given doesn't have
+   * enough room at the offset specified.
+   */
+  public static int putAsVInt(byte[] bytes, final int offset, final int vint) {
+    return putAsVLong(bytes, offset, (long) vint);
+  }
 
-    for (int idx = len; idx != 0; idx--) {
-      int shiftbits = (idx - 1) * 8;
-      long mask = 0xFFL << shiftbits;
-      result[offset++] = (byte)((i & mask) >> shiftbits);
-    }
+  /**
+   * @param vint Integer to make a vint of.
+   * @return Vint as bytes array.
+   */
+  public static byte [] vintToBytes(final int vint) {
+    long i = vint;
+    int size = WritableUtils.getVIntSize(i);
+    byte[] result = new byte[size];
+    putAsVInt(result, 0, vint);
     return result;
   }
 
   /**
    * @param buffer buffer to convert
    * @return vint bytes as an integer.
+   * @deprecated Use {@link #readAsVInt(byte[])} (int)} ()} instead.
    */
+  @Deprecated
   public static long bytesToVint(final byte [] buffer) {
-    int offset = 0;
-    byte firstByte = buffer[offset++];
-    int len = WritableUtils.decodeVIntSize(firstByte);
-    if (len == 1) {
-      return firstByte;
-    }
-    long i = 0;
-    for (int idx = 0; idx < len-1; idx++) {
-      byte b = buffer[offset++];
-      i = i << 8;
-      i = i | (b & 0xFF);
-    }
-    return (WritableUtils.isNegativeVInt(firstByte) ? ~i : i);
+    return readAsVInt(buffer);
   }
 
   /**
-   * Reads a zero-compressed encoded long from input buffer and returns it.
+   * Reads a zero-compressed encoded int from input buffer and returns it.
+   * @param buffer Binary array
+   * @return deserialized int from buffer.
+   */
+  public static int readAsVInt(final byte [] buffer) {
+    return readAsVInt(buffer, 0);
+  }
+
+  /**
+   * Reads a zero-compressed encoded int from input buffer and returns it.
    * @param buffer Binary array
    * @param offset Offset into array at which vint begins.
+   * @return deserialized int from buffer.
+   */
+  public static int readAsVInt(final byte [] buffer, final int offset) {
+    return (int) readAsVLong(buffer, offset);
+  }
+
+  /**
+   * Reads a zero-compressed encoded long from input buffer and returns it.
+   * @param buffer Binary array
+   * @param offset Offset into array at which vlong begins.
    * @throws java.io.IOException e
    * @return deserialized long from buffer.
    * @deprecated Use {@link #readAsVLong()} instead.
@@ -1377,10 +1383,19 @@ public class Bytes implements Comparable<Bytes> {
     return readAsVLong(buffer, offset);
   }
 
+ /**
+   * Reads a zero-compressed encoded long from input buffer and returns it.
+   * @param buffer Binary array
+   * @return deserialized long from buffer.
+   */
+  public static long readAsVLong(final byte [] buffer) {
+    return readAsVLong(buffer, 0);
+  }
+
   /**
    * Reads a zero-compressed encoded long from input buffer and returns it.
    * @param buffer Binary array
-   * @param offset Offset into array at which vint begins.
+   * @param offset Offset into array at which vlong begins.
    * @return deserialized long from buffer.
    */
   public static long readAsVLong(final byte [] buffer, final int offset) {
@@ -1398,6 +1413,64 @@ public class Bytes implements Comparable<Bytes> {
     return (WritableUtils.isNegativeVInt(firstByte) ? ~i : i);
   }
 
+ /**
+   * Put vlong as zero-compressed encoded long into the specified byte array position.
+   * @param bytes the byte array
+   * @param offset position in the array
+   * @param vlong long to write out
+   * @return incremented offset
+   * @throws IllegalArgumentException if the byte array given doesn't have
+   * enough room at the offset specified.
+   */
+  public static int putAsVLong(byte[] bytes, final int offset, final long vlong) {
+    long vl = vlong;
+    int size = WritableUtils.getVIntSize(vl);
+    if (bytes.length - offset < size) {
+      throw new IllegalArgumentException("Not enough room to put a vlong at"
+          + " offset " + offset + " in a " + bytes.length + " byte array."
+          + " Size of vlong is " + size);
+    }
+    int byte_offset = offset;
+    if (vl >= -112 && vl <= 127) {
+      bytes[byte_offset++] = (byte) vl;
+      return byte_offset;
+    }
+
+    int len = -112;
+    if (vl < 0) {
+      vl ^= -1L; // take one's complement'
+      len = -120;
+    }
+
+    long tmp = vl;
+    while (tmp != 0) {
+      tmp = tmp >> 8;
+      len--;
+    }
+
+    bytes[byte_offset++] = (byte) len;
+
+    len = (len < -120) ? -(len + 120) : -(len + 112);
+
+    for (int idx = len; idx != 0; idx--) {
+      int shiftbits = (idx - 1) * 8;
+      long mask = 0xFFL << shiftbits;
+      bytes[byte_offset++] = (byte)((vl & mask) >> shiftbits);
+    }
+    return byte_offset;
+  }
+
+  /**
+   * @param vlong Long to make a vlong of.
+   * @return vlong as bytes array.
+   */
+  public static byte [] vlongToBytes(final long vlong) {
+    int size = WritableUtils.getVIntSize(vlong);
+    byte[] result = new byte[size];
+    putAsVLong(result, 0, vlong);
+    return result;
+  }
+
   /**
    * @param left left operand
    * @param right right operand
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestBytes.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestBytes.java
index eb5e453..f90906d 100644
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestBytes.java
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestBytes.java
@@ -214,16 +214,41 @@ public class TestBytes extends TestCase {
     assertEquals(7, target.limit());
   }
 
-  public void testReadAsVLong() throws Exception {
+  public void testVInt() throws Exception {
+    int [] ints = {-1, 123, Integer.MIN_VALUE, Integer.MAX_VALUE};
+    for (int i = 0; i < ints.length; i++) {
+      {
+        // vint written by vintToBytes() is readable.
+        byte[] int_bytes_no_offset = Bytes.vintToBytes(ints[i]);
+        assertEquals(ints[i], Bytes.readAsVInt(int_bytes_no_offset));
+        assertEquals(ints[i], Bytes.readAsVInt(int_bytes_no_offset, 0));
+      }
+
+      {
+        // vint written by putAsVInt() is readable.
+        byte[] int_bytes_with_offset = new byte[20];
+        Bytes.putAsVInt(int_bytes_with_offset, 5, ints[i]);
+        assertEquals(ints[i], Bytes.readAsVInt(int_bytes_with_offset, 5));
+      }
+    }
+  }
+
+  public void testVLong() throws Exception {
     long [] longs = {-1l, 123l, Long.MIN_VALUE, Long.MAX_VALUE};
     for (int i = 0; i < longs.length; i++) {
-      ByteArrayOutputStream baos = new ByteArrayOutputStream();
-      DataOutputStream output = new DataOutputStream(baos);
-      WritableUtils.writeVLong(output, longs[i]);
-      byte[] long_bytes_no_offset = baos.toByteArray();
-      assertEquals(longs[i], Bytes.readAsVLong(long_bytes_no_offset, 0));
-      byte[] long_bytes_with_offset = bytesWithOffset(long_bytes_no_offset);
-      assertEquals(longs[i], Bytes.readAsVLong(long_bytes_with_offset, 1));
+      {
+        // vlong written by vlongToBytes() is readable.
+        byte[] long_bytes_no_offset = Bytes.vlongToBytes(longs[i]);
+        assertEquals(longs[i], Bytes.readAsVLong(long_bytes_no_offset));
+        assertEquals(longs[i], Bytes.readAsVLong(long_bytes_no_offset, 0));
+      }
+
+      {
+        // vlong written by putAsVLong() is readable.
+        byte[] long_bytes_with_offset = new byte[20];
+        Bytes.putAsVLong(long_bytes_with_offset, 5, longs[i]);
+        assertEquals(longs[i], Bytes.readAsVLong(long_bytes_with_offset, 5));
+      }
     }
   }
 
-- 
1.9.5 (Apple Git-50.3)

