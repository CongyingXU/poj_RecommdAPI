diff --git hbase-client/src/main/java/org/apache/hadoop/hbase/filter/FilterList.java hbase-client/src/main/java/org/apache/hadoop/hbase/filter/FilterList.java
index 901e567..be7d230 100644
--- hbase-client/src/main/java/org/apache/hadoop/hbase/filter/FilterList.java
+++ hbase-client/src/main/java/org/apache/hadoop/hbase/filter/FilterList.java
@@ -65,7 +65,7 @@ final public class FilterList extends Filter {
 
   private static final int MAX_LOG_FILTERS = 5;
   private Operator operator = Operator.MUST_PASS_ALL;
-  private List<Filter> filters = new ArrayList<Filter>();
+  private final List<Filter> filters;
   private Filter seekHintFilter = null;
 
   /** Reference Cell used by {@link #transformCell(Cell)} for validation purpose. */
@@ -83,15 +83,11 @@ final public class FilterList extends Filter {
   /**
    * Constructor that takes a set of {@link Filter}s. The default operator
    * MUST_PASS_ALL is assumed.
-   *
+   * All filters are cloned to internal list.
    * @param rowFilters list of filters
    */
   public FilterList(final List<Filter> rowFilters) {
-    if (rowFilters instanceof ArrayList) {
-      this.filters = rowFilters;
-    } else {
-      this.filters = new ArrayList<Filter>(rowFilters);
-    }
+    this.filters = new ArrayList<>(rowFilters);
   }
 
   /**
@@ -100,7 +96,7 @@ final public class FilterList extends Filter {
    * @param rowFilters
    */
   public FilterList(final Filter... rowFilters) {
-    this.filters = new ArrayList<Filter>(Arrays.asList(rowFilters));
+    this.filters = new ArrayList<>(Arrays.asList(rowFilters));
   }
 
   /**
@@ -110,6 +106,7 @@ final public class FilterList extends Filter {
    */
   public FilterList(final Operator operator) {
     this.operator = operator;
+    this.filters = new ArrayList<>();
   }
 
   /**
@@ -119,7 +116,7 @@ final public class FilterList extends Filter {
    * @param rowFilters Set of row filters.
    */
   public FilterList(final Operator operator, final List<Filter> rowFilters) {
-    this.filters = new ArrayList<Filter>(rowFilters);
+    this.filters = new ArrayList<>(rowFilters);
     this.operator = operator;
   }
 
@@ -130,7 +127,7 @@ final public class FilterList extends Filter {
    * @param rowFilters Filters to use
    */
   public FilterList(final Operator operator, final Filter... rowFilters) {
-    this.filters = new ArrayList<Filter>(Arrays.asList(rowFilters));
+    this.filters = new ArrayList<>(Arrays.asList(rowFilters));
     this.operator = operator;
   }
 
@@ -152,6 +149,14 @@ final public class FilterList extends Filter {
     return filters;
   }
 
+  public int size() {
+    return filters.size();
+  }
+
+  public boolean isEmpty() {
+    return filters.isEmpty();
+  }
+
   /**
    * Add a filter.
    *
@@ -177,7 +182,10 @@ final public class FilterList extends Filter {
 
   @Override
   public boolean filterRowKey(byte[] rowKey, int offset, int length) throws IOException {
-    boolean flag = (this.operator == Operator.MUST_PASS_ONE) ? true : false;
+    if (isEmpty()) {
+      return false;
+    }
+    boolean flag = this.operator == Operator.MUST_PASS_ONE;
     int listize = filters.size();
     for (int i = 0; i < listize; i++) {
       Filter filter = filters.get(i);
@@ -198,7 +206,10 @@ final public class FilterList extends Filter {
 
   @Override
   public boolean filterRowKey(Cell firstRowCell) throws IOException {
-    boolean flag = (this.operator == Operator.MUST_PASS_ONE) ? true : false;
+    if (isEmpty()) {
+      return false;
+    }
+    boolean flag = this.operator == Operator.MUST_PASS_ONE;
     int listize = filters.size();
     for (int i = 0; i < listize; i++) {
       Filter filter = filters.get(i);
@@ -217,6 +228,9 @@ final public class FilterList extends Filter {
 
   @Override
   public boolean filterAllRemaining() throws IOException {
+    if (isEmpty()) {
+      return false;
+    }
     int listize = filters.size();
     for (int i = 0; i < listize; i++) {
       if (filters.get(i).filterAllRemaining()) {
@@ -234,6 +248,9 @@ final public class FilterList extends Filter {
 
   @Override
   public Cell transformCell(Cell c) throws IOException {
+    if (isEmpty()) {
+      return c;
+    }
     if (!CellUtil.equals(c, referenceCell)) {
       throw new IllegalStateException("Reference Cell: " + this.referenceCell + " does not match: "
           + c);
@@ -245,6 +262,9 @@ final public class FilterList extends Filter {
   @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="SF_SWITCH_FALLTHROUGH",
     justification="Intentional")
   public ReturnCode filterKeyValue(Cell c) throws IOException {
+    if (isEmpty()) {
+      return ReturnCode.INCLUDE;
+    }
     this.referenceCell = c;
 
     // Accumulates successive transformation of every filter that includes the Cell:
@@ -358,6 +378,9 @@ final public class FilterList extends Filter {
 
   @Override
   public boolean filterRow() throws IOException {
+    if (isEmpty()) {
+      return false;
+    }
     int listize = filters.size();
     for (int i = 0; i < listize; i++) {
       Filter filter = filters.get(i);
@@ -433,6 +456,9 @@ final public class FilterList extends Filter {
 
   @Override
   public Cell getNextCellHint(Cell currentCell) throws IOException {
+    if (isEmpty()) {
+      return null;
+    }
     Cell keyHint = null;
     if (operator == Operator.MUST_PASS_ALL) {
       keyHint = seekHintFilter.getNextCellHint(currentCell);
@@ -450,15 +476,13 @@ final public class FilterList extends Filter {
         // If we ever don't have a hint and this is must-pass-one, then no hint
         return null;
       }
-      if (curKeyHint != null) {
-        // If this is the first hint we find, set it
-        if (keyHint == null) {
-          keyHint = curKeyHint;
-          continue;
-        }
-        if (CellComparator.COMPARATOR.compare(keyHint, curKeyHint) > 0) {
-          keyHint = curKeyHint;
-        }
+      // If this is the first hint we find, set it
+      if (keyHint == null) {
+        keyHint = curKeyHint;
+        continue;
+      }
+      if (CellComparator.COMPARATOR.compare(keyHint, curKeyHint) > 0) {
+        keyHint = curKeyHint;
       }
     }
     return keyHint;
@@ -466,6 +490,9 @@ final public class FilterList extends Filter {
 
   @Override
   public boolean isFamilyEssential(byte[] name) throws IOException {
+    if (isEmpty()) {
+      return true;
+    }
     int listize = filters.size();
     for (int i = 0; i < listize; i++) {
       if (filters.get(i).isFamilyEssential(name)) {
diff --git hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java
index f7d3a5e..6981a48 100644
--- hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java
+++ hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java
@@ -5437,25 +5437,19 @@ public class TestFromClientSide {
         scanResults.add(r);
       }
     }
-    
+    assertEquals(1, scanResults.size());
     Get g = new Get(Bytes.toBytes("row"));
     g.setFilter(new FilterList());
     Result getResult = table.get(g);
-    if (scanResults.isEmpty()) {
-      assertTrue(getResult.isEmpty());
-    } else if(scanResults.size() == 1) {
-      Result scanResult = scanResults.get(0);
-      assertEquals(scanResult.rawCells().length, getResult.rawCells().length);
-      for (int i = 0; i != scanResult.rawCells().length; ++i) {
-        Cell scanCell = scanResult.rawCells()[i];
-        Cell getCell = getResult.rawCells()[i];
-        assertEquals(0, Bytes.compareTo(CellUtil.cloneRow(scanCell), CellUtil.cloneRow(getCell)));
-        assertEquals(0, Bytes.compareTo(CellUtil.cloneFamily(scanCell), CellUtil.cloneFamily(getCell)));
-        assertEquals(0, Bytes.compareTo(CellUtil.cloneQualifier(scanCell), CellUtil.cloneQualifier(getCell)));
-        assertEquals(0, Bytes.compareTo(CellUtil.cloneValue(scanCell), CellUtil.cloneValue(getCell)));
-      }
-    } else {
-      fail("The result retrieved from SCAN and Get should be same");
+    Result scanResult = scanResults.get(0);
+    assertEquals(scanResult.rawCells().length, getResult.rawCells().length);
+    for (int i = 0; i != scanResult.rawCells().length; ++i) {
+      Cell scanCell = scanResult.rawCells()[i];
+      Cell getCell = getResult.rawCells()[i];
+      assertEquals(0, Bytes.compareTo(CellUtil.cloneRow(scanCell), CellUtil.cloneRow(getCell)));
+      assertEquals(0, Bytes.compareTo(CellUtil.cloneFamily(scanCell), CellUtil.cloneFamily(getCell)));
+      assertEquals(0, Bytes.compareTo(CellUtil.cloneQualifier(scanCell), CellUtil.cloneQualifier(getCell)));
+      assertEquals(0, Bytes.compareTo(CellUtil.cloneValue(scanCell), CellUtil.cloneValue(getCell)));
     }
   }
 
