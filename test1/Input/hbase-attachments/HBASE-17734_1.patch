From bf6923e679742e98b4d4db36b7a1adbfbebdc6fc Mon Sep 17 00:00:00 2001
From: ChiaPing Tsai <chia7712@gmail.com>
Date: Sun, 5 Mar 2017 08:27:20 +0800
Subject: [PATCH] HBASE-17734 Guard against possibly coping the qualifier in
 the ScanDeleteTracker

---
 .../querymatcher/ScanDeleteTracker.java            | 28 ++++++++++------------
 .../visibility/VisibilityScanDeleteTracker.java    | 18 +++++++-------
 2 files changed, 22 insertions(+), 24 deletions(-)

diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanDeleteTracker.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanDeleteTracker.java
index 450a30e..c7b9a1d 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanDeleteTracker.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanDeleteTracker.java
@@ -48,9 +48,7 @@ public class ScanDeleteTracker implements DeleteTracker {
   protected boolean hasFamilyStamp = false;
   protected long familyStamp = 0L;
   protected SortedSet<Long> familyVersionStamps = new TreeSet<Long>();
-  protected byte[] deleteBuffer = null;
-  protected int deleteOffset = 0;
-  protected int deleteLength = 0;
+  protected Cell deleteCell = null;
   protected byte deleteType = 0;
   protected long deleteTimestamp = 0L;
 
@@ -74,16 +72,14 @@ public class ScanDeleteTracker implements DeleteTracker {
         return;
       }
 
-      if (deleteBuffer != null && type < deleteType) {
+      if (deleteCell != null && type < deleteType) {
         // same column, so ignore less specific delete
-        if (CellUtil.matchingQualifier(cell, deleteBuffer, deleteOffset, deleteLength)) {
+        if (CellUtil.matchingQualifier(cell, deleteCell)) {
           return;
         }
       }
       // new column, or more general delete type
-      deleteBuffer = cell.getQualifierArray();
-      deleteOffset = cell.getQualifierOffset();
-      deleteLength = cell.getQualifierLength();
+      deleteCell = cell;
       deleteType = type;
       deleteTimestamp = timestamp;
     }
@@ -106,8 +102,8 @@ public class ScanDeleteTracker implements DeleteTracker {
       return DeleteResult.FAMILY_VERSION_DELETED;
     }
 
-    if (deleteBuffer != null) {
-      int ret = -(CellComparator.compareQualifiers(cell, deleteBuffer, deleteOffset, deleteLength));
+    if (deleteCell != null) {
+      int ret = -(CellComparator.compareQualifiers(cell, deleteCell));
       if (ret == 0) {
         if (deleteType == KeyValue.Type.DeleteColumn.getCode()) {
           return DeleteResult.COLUMN_DELETED;
@@ -121,13 +117,15 @@ public class ScanDeleteTracker implements DeleteTracker {
         assert timestamp < deleteTimestamp;
 
         // different timestamp, let's clear the buffer.
-        deleteBuffer = null;
+        deleteCell = null;
       } else if (ret < 0) {
         // Next column case.
-        deleteBuffer = null;
+        deleteCell = null;
       } else {
         throw new IllegalStateException("isDelete failed: deleteBuffer="
-            + Bytes.toStringBinary(deleteBuffer, deleteOffset, deleteLength) + ", qualifier="
+            + Bytes.toStringBinary(deleteCell.getQualifierArray(),
+                    deleteCell.getQualifierOffset(), deleteCell.getQualifierLength())
+            + ", qualifier="
             + Bytes.toStringBinary(cell.getQualifierArray(), cell.getQualifierOffset(),
               cell.getQualifierLength())
             + ", timestamp=" + timestamp + ", comparison result: " + ret);
@@ -139,7 +137,7 @@ public class ScanDeleteTracker implements DeleteTracker {
 
   @Override
   public boolean isEmpty() {
-    return deleteBuffer == null && !hasFamilyStamp && familyVersionStamps.isEmpty();
+    return deleteCell == null && !hasFamilyStamp && familyVersionStamps.isEmpty();
   }
 
   @Override
@@ -148,7 +146,7 @@ public class ScanDeleteTracker implements DeleteTracker {
     hasFamilyStamp = false;
     familyStamp = 0L;
     familyVersionStamps.clear();
-    deleteBuffer = null;
+    deleteCell = null;
   }
 
   @Override
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityScanDeleteTracker.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityScanDeleteTracker.java
index 4e27bbf..2595fe0 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityScanDeleteTracker.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityScanDeleteTracker.java
@@ -87,8 +87,8 @@ public class VisibilityScanDeleteTracker extends ScanDeleteTracker {
       return;
     }
     // new column, or more general delete type
-    if (deleteBuffer != null) {
-      if (!(CellUtil.matchingQualifier(delCell, deleteBuffer, deleteOffset, deleteLength))) {
+    if (deleteCell != null) {
+      if (!(CellUtil.matchingQualifier(delCell, deleteCell))) {
         // A case where there are deletes for a column qualifier but there are
         // no corresponding puts for them. Rare case.
         visibilityTagsDeleteColumns = null;
@@ -104,9 +104,7 @@ public class VisibilityScanDeleteTracker extends ScanDeleteTracker {
         visiblityTagsDeleteColumnVersion = null;
       }
     }
-    deleteBuffer = delCell.getQualifierArray();
-    deleteOffset = delCell.getQualifierOffset();
-    deleteLength = delCell.getQualifierLength();
+    deleteCell = delCell;
     deleteType = type;
     deleteTimestamp = timestamp;
     extractDeleteCellVisTags(delCell, KeyValue.Type.codeToType(type));
@@ -243,8 +241,8 @@ public class VisibilityScanDeleteTracker extends ScanDeleteTracker {
           }
         }
       }
-      if (deleteBuffer != null) {
-        int ret = CellComparator.compareQualifiers(cell, deleteBuffer, deleteOffset, deleteLength);
+      if (deleteCell != null) {
+        int ret = CellComparator.compareQualifiers(cell, deleteCell);
         if (ret == 0) {
           if (deleteType == KeyValue.Type.DeleteColumn.getCode()) {
             if (visibilityTagsDeleteColumns != null) {
@@ -304,13 +302,15 @@ public class VisibilityScanDeleteTracker extends ScanDeleteTracker {
           }
         } else if (ret > 0) {
           // Next column case.
-          deleteBuffer = null;
+          deleteCell = null;
           // Can nullify this because we are moving to the next column
           visibilityTagsDeleteColumns = null;
           visiblityTagsDeleteColumnVersion = null;
         } else {
           throw new IllegalStateException("isDeleted failed: deleteBuffer="
-              + Bytes.toStringBinary(deleteBuffer, deleteOffset, deleteLength) + ", qualifier="
+              + Bytes.toStringBinary(deleteCell.getQualifierArray(),
+                    deleteCell.getQualifierOffset(), deleteCell.getQualifierLength())
+              + ", qualifier="
               + Bytes.toStringBinary(cell.getQualifierArray(), cell.getQualifierOffset(),
                   cell.getQualifierLength())
               + ", timestamp=" + timestamp + ", comparison result: " + ret);
-- 
2.9.3

