diff --git hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
index ce246d8..95f3bb0 100644
--- hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
+++ hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
@@ -77,7 +77,6 @@ import org.apache.hadoop.hbase.CompoundConfiguration;
 import org.apache.hadoop.hbase.DoNotRetryIOException;
 import org.apache.hadoop.hbase.DroppedSnapshotException;
 import org.apache.hadoop.hbase.HBaseConfiguration;
-import org.apache.hadoop.hbase.HBaseIOException;
 import org.apache.hadoop.hbase.HColumnDescriptor;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HConstants.OperationStatusCode;
@@ -1785,27 +1784,27 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
      * We are trying to remove / relax the region read lock for compaction.
      * Let's see what are the potential race conditions among the operations (user scan,
      * region split, region close and region bulk load).
-     * 
+     *
      *  user scan ---> region read lock
      *  region split --> region close first --> region write lock
      *  region close --> region write lock
      *  region bulk load --> region write lock
-     *  
+     *
      * read lock is compatible with read lock. ---> no problem with user scan/read
      * region bulk load does not cause problem for compaction (no consistency problem, store lock
      *  will help the store file accounting).
      * They can run almost concurrently at the region level.
-     * 
+     *
      * The only remaining race condition is between the region close and compaction.
      * So we will evaluate, below, how region close intervenes with compaction if compaction does
      * not acquire region read lock.
-     * 
+     *
      * Here are the steps for compaction:
      * 1. obtain list of StoreFile's
      * 2. create StoreFileScanner's based on list from #1
      * 3. perform compaction and save resulting files under tmp dir
      * 4. swap in compacted files
-     * 
+     *
      * #1 is guarded by store lock. This patch does not change this --> no worse or better
      * For #2, we obtain smallest read point (for region) across all the Scanners (for both default
      * compactor and stripe compactor).
@@ -1817,7 +1816,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
      * This will not conflict with compaction.
      * For #3, it can be performed in parallel to other operations.
      * For #4 bulk load and compaction don't conflict with each other on the region level
-     *   (for multi-family atomicy). 
+     *   (for multi-family atomicy).
      * Region close and compaction are guarded pretty well by the 'writestate'.
      * In HRegion#doClose(), we have :
      * synchronized (writestate) {
@@ -2204,7 +2203,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
         for (Store store: storesToFlush) {
           LOG.info("Flushing Column Family: " + store.getColumnFamilyName()
               + " which was occupying "
-              + StringUtils.byteDesc(store.getMemStoreSize()) + " of memstore.");
+              + StringUtils.byteDesc(store.getFlushableSize()) + " of memstore.");
         }
       }
     }
@@ -2903,8 +2902,8 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
           }
           initialized = true;
         }
-        long addedSize = doMiniBatchMutation(batchOp);
-        long newSize = this.addAndGetGlobalMemstoreSize(addedSize);
+        doMiniBatchMutation(batchOp);
+        long newSize = this.getMemstoreSize();
         if (isFlushSize(newSize)) {
           requestFlush();
         }
@@ -2986,6 +2985,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
     int noOfPuts = 0, noOfDeletes = 0;
     WALKey walKey = null;
     long mvccNum = 0;
+    long addedSize = 0;
     try {
       // ------------------------------------
       // STEP 1. Try to acquire as many locks as we can, and ensure
@@ -3140,7 +3140,6 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
       // visible to scanners till we update the MVCC. The MVCC is
       // moved only when the sync is complete.
       // ----------------------------------
-      long addedSize = 0;
       for (int i = firstIndex; i < lastIndexExclusive; i++) {
         if (batchOp.retCodeDetails[i].getOperationStatusCode()
             != OperationStatusCode.NOT_RUN) {
@@ -3302,8 +3301,11 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
       if (doRollBackMemstore) {
         rollbackMemstore(memstoreCells);
         if (writeEntry != null) mvcc.cancelMemstoreInsert(writeEntry);
-      } else if (writeEntry != null) {
-        mvcc.completeMemstoreInsertWithSeqNum(writeEntry, walKey);
+      } else {
+        if (writeEntry != null) {
+          mvcc.completeMemstoreInsertWithSeqNum(writeEntry, walKey);
+        }
+        this.addAndGetGlobalMemstoreSize(addedSize);
       }
 
       if (locked) {
