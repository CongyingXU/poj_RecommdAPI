Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlerPortTypeImpl.java
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlerPortTypeImpl.java	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlerPortTypeImpl.java	(revision 0)
@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.sample.headershandler;
+
+import java.util.concurrent.Future;
+
+import javax.annotation.Resource;
+import javax.jws.HandlerChain;
+import javax.jws.WebService;
+import javax.xml.ws.AsyncHandler;
+import javax.xml.ws.WebServiceContext;
+
+import org.test.headershandler.HeadersHandlerResponse;
+
+
+@WebService(serviceName="HeadersHandlerService",endpointInterface="org.apache.axis2.jaxws.sample.headershandler.HeadersHandlerPortType")
+@HandlerChain(file = "HeadersHandlers.xml", name = "")
+public class HeadersHandlerPortTypeImpl implements HeadersHandlerPortType {
+
+    private WebServiceContext ctx;
+    
+    /* (non-Javadoc)
+     * @see org.apache.axis2.jaxws.sample.headershandler.HeadersHandlerPortType#headersHandler(int, int)
+     */
+    public int headersHandler(int arg0, int arg1) throws HeadersHandlerFault_Exception {
+        return (int) (arg0 + arg1);
+    }
+
+    public Future<?> headersHandlerAsync(int arg0, int arg1, AsyncHandler<HeadersHandlerResponse> asyncHandler) {
+        return null;
+    }
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.sample.headershandler.HeadersHandlerPortType#oneWayInt(int)
+	 */
+	public void oneWayInt(int arg0) {
+        return;
+	}
+    
+    @Resource
+    public void setCtx(WebServiceContext ctx) {
+        this.ctx = ctx;
+    }
+
+}
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientLogicalHandler.java
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientLogicalHandler.java	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientLogicalHandler.java	(revision 0)
@@ -0,0 +1,210 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.sample.headershandler;
+
+import java.io.ByteArrayOutputStream;
+import java.io.StringBufferInputStream;
+import java.util.List;
+import java.util.Map;
+import java.util.StringTokenizer;
+
+import javax.xml.namespace.QName;
+import javax.xml.soap.SOAPFactory;
+import javax.xml.transform.OutputKeys;
+import javax.xml.transform.Source;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.stream.StreamResult;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.ws.LogicalMessage;
+import javax.xml.ws.ProtocolException;
+import javax.xml.ws.WebServiceException;
+import javax.xml.ws.handler.MessageContext;
+
+import org.apache.axis2.Constants;
+import org.apache.axis2.jaxws.handler.LogicalMessageContext;
+
+public class HeadersClientLogicalHandler implements
+        javax.xml.ws.handler.LogicalHandler<LogicalMessageContext> {
+
+	private HandlerTracker tracker = new HandlerTracker(HeadersClientLogicalHandler.class.getSimpleName());
+	private TestHeaders headerUtil = new TestHeaders(this.getClass());
+	
+    public void close(MessageContext messagecontext) {
+    	tracker.close();
+    }
+
+    public boolean handleFault(LogicalMessageContext messagecontext) {
+    	Boolean outbound = (Boolean) messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
+    	tracker.handleFault(outbound);
+    	if (!outbound) {
+    	    // this is the third client inbound hit
+    	    
+    	    // calling getPayload just to exercise the code:
+    	    messagecontext.getMessage().getPayload();
+    	}
+        return true;
+    }
+
+    public boolean handleMessage(LogicalMessageContext messagecontext) {
+        Boolean outbound = (Boolean) messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
+        tracker.handleMessage(outbound);
+        if (outbound) { // outbound request on the client
+
+        	// this is the first client outbound handler hit
+        	
+            // turn off special property that logs ability to use
+            // both SOAPHeadersAdapter and SAAJ in a single handler method:
+            messagecontext.put(org.apache.axis2.jaxws.handler.Constants.JAXWS_HANDLER_TRACKER, false);
+            
+        	// let's check for all the headers we expect, remove a few, and manipulate the message payload
+        	
+        	Map<QName, List<String>> requestHeaders = (Map<QName, List<String>>)messagecontext.get(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        	headerUtil.confirmHeadersAdapterList(Constants.JAXWS_OUTBOUND_SOAP_HEADERS, requestHeaders, 2);
+
+        	// expecting four header elements under two different QNames
+
+        	List<String> list1 = requestHeaders.get(TestHeaders.ACOH1_HEADER_QNAME);
+        	headerUtil.confirmList(TestHeaders.ACOH1_HEADER_QNAME, list1, 2);
+        	String acoh1 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL1);
+        	headerUtil.compareHeaderStrings(acoh1, list1.get(0));
+        	tracker.checkHeader(list1.get(0));
+        	// also:
+        	String acoh2 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL2);
+        	headerUtil.compareHeaderStrings(acoh2, list1.get(1));
+        	tracker.checkHeader(list1.get(1));
+        	
+        	List<String> list2 = requestHeaders.get(TestHeaders.ACOH2_HEADER_QNAME);
+        	headerUtil.confirmList(TestHeaders.ACOH2_HEADER_QNAME, list2, 2);
+        	String acoh3 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL3);
+        	headerUtil.compareHeaderStrings(acoh3, list2.get(0));
+        	tracker.checkHeader(list2.get(0));
+        	// also:
+        	String acoh4 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL4);
+        	headerUtil.compareHeaderStrings(acoh4, list2.get(1));
+        	tracker.checkHeader(list2.get(1));
+
+        	// remove header from list 1
+        	list1.remove(0);
+        	tracker.removedHeader(acoh1);
+        	// list1 is not a "live" list, so we need to put it back in
+        	requestHeaders.put(TestHeaders.ACOH1_HEADER_QNAME, list1);
+        	// remove all of list 2
+        	tracker.removedHeader(acoh3);
+        	tracker.removedHeader(acoh4);
+        	requestHeaders.remove(TestHeaders.ACOH2_HEADER_QNAME);
+        	
+        	// the requestHeaders object is a "live" list, so no need to do this:
+        	//messagecontext.put(Constants.JAXWS_OUTBOUND_SOAP_HEADERS, requestHeaders);
+
+        	// The 'get' on the requestHeaders map triggers a toString() on the underlying OM structure for the header element.
+        	// We want to make sure the parser was not closed prematurely, so...we do a getPayload() below on the message.
+        	// This causes a parse and build up of SAAJ, confirming the parser was not prematurely closed.
+
+        	// manipulate the payload just to be thorough
+        	LogicalMessage msg = messagecontext.getMessage();
+        	String st = getStringFromSourcePayload(msg.getPayload());
+        	String txt = String.valueOf(Integer.valueOf(getFirstArg(st)) - 1);
+        	st = replaceFirstArg(st, txt);
+        	msg.setPayload(new StreamSource(new StringBufferInputStream(st)));
+
+        } else {
+        	// TODO implement some inbound stuff
+        	
+        	// this is the third client inbound hit
+
+            LogicalMessage msg = messagecontext.getMessage();
+            String st = getStringFromSourcePayload(msg.getPayload());
+
+            if (st.contains("33")) {
+            
+                Map<QName, List<String>> requestHeaders = (Map<QName, List<String>>)messagecontext.get(Constants.JAXWS_INBOUND_SOAP_HEADERS);
+                headerUtil.confirmHeadersAdapterList(Constants.JAXWS_INBOUND_SOAP_HEADERS, requestHeaders, 1);
+
+                // expecting two header elements under two QNames
+
+                /*
+                 * these headers need to be removed because this is a return path taken by a 
+                 * server handler that returned 'false' from a handleMessage call.  This means the original
+                 * outbound message was returned as-is, and JAXB will get confused if we leave
+                 * header elements on the Envelope.
+                 */
+
+                List<String> list2 = requestHeaders.get(TestHeaders.ACOH2_HEADER_QNAME);
+                headerUtil.confirmList(TestHeaders.ACOH2_HEADER_QNAME, list2, 2);
+                String acoh3 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL3);
+                headerUtil.compareHeaderStrings(acoh3, list2.get(0));
+                tracker.checkHeader(list2.get(0));
+                String acoh4 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL4);
+                headerUtil.compareHeaderStrings(acoh4, list2.get(1));
+                tracker.checkHeader(list2.get(1));
+
+                // remove list1
+                requestHeaders.remove(TestHeaders.ACOH2_HEADER_QNAME);
+                tracker.removedHeader(acoh3);
+                tracker.removedHeader(acoh4);
+                
+                // currently, the server runtime is returning the original client outbound message (see JAXWS 9.3.2.1), but
+                // once we exit this handler, the message will be passed to JAXB, and it won't like it because it's not
+                // the WSDL-specified response message.  In the interest of testing, however, let's do this, and make sure
+                // the junit test handles it and checks the calls into the handler flow anyway:
+                throw new WebServiceException("I don't like 33");
+
+            }
+        	
+        }
+        return true;
+    }
+
+    private static String getFirstArg(String payloadString) {
+        StringTokenizer st = new StringTokenizer(payloadString, ">");
+        st.nextToken(); // skip first token.
+        st.nextToken(); // skip second
+        String tempString = st.nextToken();
+        String returnString = new StringTokenizer(tempString, "<").nextToken();
+        return returnString;
+    }
+
+    private static String replaceFirstArg(String payloadString, String newArg) {
+        String firstArg = getFirstArg(payloadString);
+        payloadString = payloadString.replaceFirst(firstArg, newArg);
+        return payloadString;
+    }
+
+    private static String getStringFromSourcePayload(Source payload) {
+        try {
+
+            TransformerFactory factory = TransformerFactory.newInstance();
+            Transformer trans = factory.newTransformer();
+
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            StreamResult result = new StreamResult(baos);
+
+            trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
+            trans.transform(payload, result);
+
+            return new String(baos.toByteArray());
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+
+    }
+
+}
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientHandlers.xml
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientHandlers.xml	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientHandlers.xml	(revision 0)
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one
+  ~ or more contributor license agreements. See the NOTICE file
+  ~ distributed with this work for additional information
+  ~ regarding copyright ownership. The ASF licenses this file
+  ~ to you under the Apache License, Version 2.0 (the
+  ~ "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing,
+  ~ software distributed under the License is distributed on an
+  ~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  ~ KIND, either express or implied. See the License for the
+  ~ specific language governing permissions and limitations
+  ~ under the License.
+  -->
+
+<jws:handler-chains xmlns:jws="http://java.sun.com/xml/ns/javaee">
+
+	<jws:handler-chain name="HeadersClientHandlerChain">
+		<jws:handler>
+			<jws:handler-class>org.apache.axis2.jaxws.sample.headershandler.HeadersClientProtocolHandler</jws:handler-class>
+		</jws:handler>
+		<jws:handler>
+			<jws:handler-class>org.apache.axis2.jaxws.sample.headershandler.HeadersClientLogicalHandler</jws:handler-class>
+		</jws:handler>
+		<jws:handler>
+			<jws:handler-class>org.apache.axis2.jaxws.sample.headershandler.HeadersClientProtocolHandler2</jws:handler-class>
+		</jws:handler>
+	</jws:handler-chain>
+	
+</jws:handler-chains>
+
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlers.xml
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlers.xml	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlers.xml	(revision 0)
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one
+  ~ or more contributor license agreements. See the NOTICE file
+  ~ distributed with this work for additional information
+  ~ regarding copyright ownership. The ASF licenses this file
+  ~ to you under the Apache License, Version 2.0 (the
+  ~ "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing,
+  ~ software distributed under the License is distributed on an
+  ~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  ~ KIND, either express or implied. See the License for the
+  ~ specific language governing permissions and limitations
+  ~ under the License.
+  -->
+
+<jws:handler-chains xmlns:jws="http://java.sun.com/xml/ns/javaee">
+
+	<jws:handler-chain name="HeadersHandlerChain">
+		<jws:handler>
+			<jws:handler-class>org.apache.axis2.jaxws.sample.headershandler.HeadersServerProtocolHandler</jws:handler-class>
+		</jws:handler>
+		<jws:handler>
+			<jws:handler-class>org.apache.axis2.jaxws.sample.headershandler.HeadersServerLogicalHandler</jws:handler-class>
+		</jws:handler>
+	</jws:handler-chain>
+	
+</jws:handler-chains>
+
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/TestHeaders.java
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/TestHeaders.java	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/TestHeaders.java	(revision 0)
@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.sample.headershandler;
+
+import java.util.List;
+import java.util.Map;
+
+import javax.xml.namespace.QName;
+import javax.xml.soap.SOAPElement;
+import javax.xml.soap.SOAPException;
+import javax.xml.soap.SOAPFactory;
+import javax.xml.ws.WebServiceException;
+
+public class TestHeaders {
+	
+	/*
+	 * These are just some standard small SOAP headers to be used by the the HeadersHandler sample app and handlers
+	 * 
+	 * If more strenuous tests are required, such as a very large header, or some non-XML-safe strings, they can be
+	 * added here.  The purpose of having these constants is so multiple handlers can use the constant to add/remove/manipulate
+	 * headers without hard-coding the data.
+	 * 
+	 */
+	
+	private static String LARGE_STRING = "";
+	static {
+		// 100k string
+		for (int i = 0; i < 10000; i++) {
+			LARGE_STRING += "LongString";  // 10 chars * Integer.MAX_VALUE is pretty big.
+		}
+	}
+	
+	
+	// app client outbound header 1 (ACOH1)
+	private static final String identifierACOH1 = "acoh1";
+	private static final String identifierACOH1namespaceURI = "http://"+identifierACOH1+"ns";
+	private static final String identifierACOH1prefix = identifierACOH1+"pre";
+    public static final QName ACOH1_HEADER_QNAME = new QName(identifierACOH1namespaceURI, identifierACOH1, identifierACOH1prefix);
+    
+	// app client outbound header 2 (ACOH2)
+	private static final String identifierACOH2 = "acoh2";
+	private static final String identifierACOH2namespaceURI = "http://"+identifierACOH2+"ns";
+	private static final String identifierACOH2prefix = identifierACOH2+"pre";
+    public static final QName ACOH2_HEADER_QNAME = new QName(identifierACOH2namespaceURI, identifierACOH2, identifierACOH2prefix);
+    
+	// app client outbound header 3 (ACOH3)
+	private static final String identifierACOH3 = "acoh3";
+	private static final String identifierACOH3namespaceURI = "http://"+identifierACOH3+"ns";
+	private static final String identifierACOH3prefix = identifierACOH3+"pre";
+    public static final QName ACOH3_HEADER_QNAME = new QName(identifierACOH3namespaceURI, identifierACOH3, identifierACOH3prefix);
+    
+	// app client outbound header 4 (ACOH4)
+	private static final String identifierACOH4 = "acoh4";
+	private static final String identifierACOH4namespaceURI = "http://"+identifierACOH4+"ns";
+	private static final String identifierACOH4prefix = identifierACOH4+"pre";
+    public static final QName ACOH4_HEADER_QNAME = new QName(identifierACOH4namespaceURI, identifierACOH4, identifierACOH4prefix);
+	
+	// client outbound soap handler 1 (COSH1)
+	private static final String identifierCOSH1 = "cosh1";
+	private static final String identifierCOSH1namespaceURI = "http://"+identifierCOSH1+"ns";
+	private static final String identifierCOSH1prefix = identifierCOSH1+"pre";
+    public static final QName COSH1_HEADER_QNAME = new QName(identifierCOSH1namespaceURI, identifierCOSH1, identifierCOSH1prefix);
+
+    // some content
+    public static final String CONTENT_SMALL1 = "small content 1";
+    public static final String CONTENT_SMALL2 = "small content 2";
+    public static final String CONTENT_SMALL3 = "small content 3";
+    public static final String CONTENT_SMALL4 = "small content 4";
+    public static final String CONTENT_SMALL5 = "small content 5";
+    public static final String CONTENT_SMALL6 = "small content 6";
+    public static final String CONTENT_LARGE = LARGE_STRING;
+    public static final String CONTENT_OTHER = "other content";
+
+    private String className = "";
+    
+    /**
+     * 
+     * @param clazz the currently executing handler class
+     */
+    public TestHeaders(Class clazz) {
+    	className = clazz.getSimpleName();
+    }
+    
+    /**
+     * Utility method so handlers can easily confirm the map of headers under the message context is as expected.
+     * 
+     * @param className - for logging purposes, pass the name of the handler class currently executing
+     * @param key - for logging purposes, pass the key of the list - Constants.JAXWS_INBOUND_SOAP_HEADERS or Constants.JAXWS_OUTBOUND_SOAP_HEADERS
+     * @param list - the list itself
+     * @param expectedSize - the expected size of the map being passed
+     * @throws Exception
+     */
+    public void confirmHeadersAdapterList(String key, Map<QName, List<String>> map, int expectedSize) throws WebServiceException {
+		if (map == null) {
+			throw new WebServiceException(className + ": Expected to find JAXWS SOAP Headers by way of SOAPMessageContext.get(" +
+					key+"), but none was found.  This probably means something is" +
+					" wrong with the way SOAPHeadersAdapter is \"installed\" or used.");
+		} else if (map.size() != expectedSize) {
+			throw new WebServiceException(className + ": List of requestHeaders does not match expected size of "+expectedSize+".  " +
+			"Actual size was " + map.size() + ".  This probably means something is wrong with the way SOAPHeadersAdapter " +
+			"is \"installed\" or used.");
+		}
+    }
+    
+    /**
+     * Utility method so handlers can easily confirm the list of headers under a given QName is as expected.
+     * 
+     * @param className - for logging purposes, pass the name of the handler class currently executing
+     * @param qnameKeyForList - for logging purposes, pass the QName key of the list
+     * @param list - the list itself
+     * @param expectedSize - the expected size of the list being passed
+     * @throws Exception
+     */
+    public void confirmList(QName qnameKeyForList, List<String> list, int expectedSize) throws WebServiceException {
+		if (list == null) {
+			throw new WebServiceException(className + ": List of headers under QName " + qnameKeyForList + " is missing.");
+		} else if (list.size() != expectedSize) {
+			throw new WebServiceException(className + ": List of headers under QName " + qnameKeyForList + " expected size " +
+					"was " + expectedSize + ", but actual size was " + list.size() + ".");
+		}
+    }
+    
+    public void compareHeaderStrings(String xmlHeader1, String xmlHeader2) throws WebServiceException {
+    	if ((xmlHeader1 == null) || (xmlHeader2 == null) || (!xmlHeader1.equals(xmlHeader2))) {
+			throw new WebServiceException(className + ": Expected outbound header element was not found.");
+		}
+    }
+    
+    // callers should use the QName objects and CONTENT_* Strings defined in this class as params
+    public static String createHeaderXMLString(QName qname, String textContent) throws WebServiceException {
+    	try {
+    		SOAPFactory sf = SOAPFactory.newInstance();
+    		SOAPElement e = sf.createElement(qname);
+    		e.addTextNode(textContent);
+    		return e.toString();
+    	} catch (SOAPException e) {
+    		throw new WebServiceException(e);
+    	}
+    }
+    
+    // callers should use the QName objects and CONTENT_* Strings defined in this class as params
+    public static SOAPElement createHeaderSOAPElement(QName qname, String textContent) throws WebServiceException {
+    	try {
+    		SOAPFactory sf = SOAPFactory.newInstance();
+    		SOAPElement e = sf.createElement(qname);
+    		e.addTextNode(textContent);
+    		return e;
+    	} catch (SOAPException e) {
+    		throw new WebServiceException(e);
+    	}
+    }
+    
+}
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientProtocolHandler2.java
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientProtocolHandler2.java	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientProtocolHandler2.java	(revision 0)
@@ -0,0 +1,125 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.sample.headershandler;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+import javax.xml.soap.SOAPBody;
+import javax.xml.soap.SOAPMessage;
+import javax.xml.ws.WebServiceException;
+import javax.xml.ws.handler.MessageContext;
+import javax.xml.ws.handler.soap.SOAPMessageContext;
+
+import org.apache.axis2.Constants;
+
+public class HeadersClientProtocolHandler2 implements
+        javax.xml.ws.handler.soap.SOAPHandler<SOAPMessageContext> {
+
+	private HandlerTracker tracker = new HandlerTracker(HeadersClientProtocolHandler2.class.getSimpleName());
+	private TestHeaders headerUtil = new TestHeaders(this.getClass());
+	
+    public void close(MessageContext messagecontext) {
+    	tracker.close();
+    }
+
+    public boolean handleFault(SOAPMessageContext messagecontext) {
+    	Boolean outbound = (Boolean) messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
+    	tracker.handleFault(outbound);
+    	if (!outbound) {
+            // this is the first client inbound handler hit
+            
+            Map<QName, List<String>> requestHeaders = (Map<QName, List<String>>)messagecontext.get(Constants.JAXWS_INBOUND_SOAP_HEADERS);
+            headerUtil.confirmHeadersAdapterList(Constants.JAXWS_INBOUND_SOAP_HEADERS, requestHeaders, 1);
+
+            // expecting one header element
+            
+            List<String> list1 = requestHeaders.get(TestHeaders.ACOH3_HEADER_QNAME);
+            headerUtil.confirmList(TestHeaders.ACOH3_HEADER_QNAME, list1, 1);
+            String acoh5 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH3_HEADER_QNAME, TestHeaders.CONTENT_LARGE);
+            headerUtil.compareHeaderStrings(acoh5, list1.get(0));
+            tracker.checkHeader(list1.get(0));
+            
+            tracker.removedHeader(acoh5);
+            requestHeaders.remove(TestHeaders.ACOH3_HEADER_QNAME);
+    	}
+        return true;
+    }
+
+    public Set getHeaders() {
+    	tracker.getHeaders();
+        return null;
+    }
+
+    public boolean handleMessage(SOAPMessageContext messagecontext) {
+        Boolean outbound = (Boolean) messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
+        tracker.handleMessage(outbound);
+        if (outbound) {
+
+        	// this is the third client outbound handler hit
+
+        	Map<QName, List<String>> requestHeaders = (Map<QName, List<String>>)messagecontext.get(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        	headerUtil.confirmHeadersAdapterList(Constants.JAXWS_OUTBOUND_SOAP_HEADERS, requestHeaders, 2);
+
+        	// expecting two header elements under two different QNames
+        	
+        	List<String> list1 = requestHeaders.get(TestHeaders.ACOH1_HEADER_QNAME);
+        	headerUtil.confirmList(TestHeaders.ACOH1_HEADER_QNAME, list1, 1);
+        	String acoh1 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL2);
+        	headerUtil.compareHeaderStrings(acoh1, list1.get(0));
+        	tracker.checkHeader(list1.get(0));
+
+        	List<String> list2 = requestHeaders.get(TestHeaders.ACOH3_HEADER_QNAME);
+        	headerUtil.confirmList(TestHeaders.ACOH3_HEADER_QNAME, list2, 1);
+        	String acoh2 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH3_HEADER_QNAME, TestHeaders.CONTENT_LARGE);
+        	headerUtil.compareHeaderStrings(acoh2, list2.get(0));
+        	tracker.checkHeader(list2.get(0));
+
+        }
+        else {  // client inbound response
+        	
+        	// this is the first client inbound handler hit
+        	
+        	Map<QName, List<String>> requestHeaders = (Map<QName, List<String>>)messagecontext.get(Constants.JAXWS_INBOUND_SOAP_HEADERS);
+        	headerUtil.confirmHeadersAdapterList(Constants.JAXWS_INBOUND_SOAP_HEADERS, requestHeaders, 1);
+
+        	// expecting one header element
+        	
+        	List<String> list1 = requestHeaders.get(TestHeaders.ACOH3_HEADER_QNAME);
+        	headerUtil.confirmList(TestHeaders.ACOH3_HEADER_QNAME, list1, 1);
+        	String acoh5 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH3_HEADER_QNAME, TestHeaders.CONTENT_LARGE);
+        	headerUtil.compareHeaderStrings(acoh5, list1.get(0));
+        	tracker.checkHeader(list1.get(0));
+        	
+        	// add header
+        	String acoh3 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL3);
+        	List<String> acoh2list = new ArrayList<String>();
+        	acoh2list.add(acoh3);
+        	requestHeaders.put(TestHeaders.ACOH2_HEADER_QNAME, acoh2list);
+        	messagecontext.put(Constants.JAXWS_INBOUND_SOAP_HEADERS, requestHeaders);
+        	tracker.addHeader(acoh3.toString());
+        }
+        return true;
+    }
+
+}
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/META-INF/HeadersHandler.wsdl
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/META-INF/HeadersHandler.wsdl	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/META-INF/HeadersHandler.wsdl	(revision 0)
@@ -0,0 +1,123 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one
+  ~ or more contributor license agreements. See the NOTICE file
+  ~ distributed with this work for additional information
+  ~ regarding copyright ownership. The ASF licenses this file
+  ~ to you under the Apache License, Version 2.0 (the
+  ~ "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing,
+  ~ software distributed under the License is distributed on an
+  ~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  ~ KIND, either express or implied. See the License for the
+  ~ specific language governing permissions and limitations
+  ~ under the License.
+  -->
+
+
+<definitions name="HeadersHandler" targetNamespace="http://org/test/headershandler"
+	xmlns:tns="http://org/test/headershandler" xmlns="http://schemas.xmlsoap.org/wsdl/"
+	xmlns:xsd="http://www.w3.org/2001/XMLSchema"
+	xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/">
+
+
+	<types>
+		<xsd:schema xmlns="http://www.w3.org/2001/XMLSchema"
+			elementFormDefault="qualified" targetNamespace="http://org/test/headershandler">
+			<element name="myHeader" type="xsd:string" />
+			
+			<element name="headersHandlerResponse">
+				<complexType>
+					<sequence>
+						<element name="return" type="xsd:int" />
+					</sequence>
+				</complexType>
+			</element>
+
+			<element name="headersHandler">
+				<complexType>
+					<sequence>
+						<element name="arg0" type="xsd:int" />
+						<element name="arg1" type="xsd:int" />
+					</sequence>
+				</complexType>
+			</element>
+
+			<element name="HeadersHandlerFault">
+				<complexType>
+					<sequence>
+						<element name="faultInfo" type="xsd:string" />
+						<element name="message" type="xsd:string" />
+					</sequence>
+				</complexType>
+			</element>
+
+			<element name="oneWayInt">
+				<complexType>
+					<sequence>
+						<element name="arg0" type="xsd:int" />
+					</sequence>
+				</complexType>
+			</element>
+
+		</xsd:schema>
+	</types>
+
+	<message name="headersHandler">
+		<part name="parameters" element="tns:headersHandler" />
+	</message>
+	<message name="headersHandlerResponse">
+		<part name="result" element="tns:headersHandlerResponse" />
+	</message>
+	<message name="headersHandlerFault">
+		<part name="HeadersHandlerFault" element="tns:HeadersHandlerFault" />
+	</message>
+	<message name="oneWayInt">
+		<part name="parameters" element="tns:oneWayInt" />
+	</message>
+
+	<portType name="HeadersHandlerPortType">
+		<operation name="headersHandler">
+			<input message="tns:headersHandler" name="add" />
+			<output message="tns:headersHandlerResponse" name="addResponse" />
+			<fault name="headersHandlerFault" message="tns:headersHandlerFault" />
+		</operation>
+		<operation name="oneWayInt">
+			<input message="tns:oneWayInt" />
+		</operation>
+	</portType>
+	<binding name="HeadersHandlerBinding" type="tns:HeadersHandlerPortType">
+		<soap:binding transport="http://schemas.xmlsoap.org/soap/http"
+			style="document" />
+		<operation name="headersHandler">
+			
+			<input>
+				<soap:body use="literal" />
+			</input>
+			<output>
+				<soap:body use="literal" />
+			</output>
+			<fault name="headersHandlerFault">
+				<soap:fault name="headersHandlerFault" use="literal" />
+			</fault>
+		</operation>
+		<operation name="oneWayInt">
+			
+			<input>
+				<soap:body use="literal" />
+			</input>
+		</operation>
+	</binding>
+	<service name="HeadersHandlerService">
+		<port name="HeadersHandlerPort" binding="tns:HeadersHandlerBinding">
+			<soap:address
+				location="http://localhost:9080/HeadersHandler/HeadersHandlerImplService" />
+		</port>
+	</service>
+</definitions>
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlerPortType.java
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlerPortType.java	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlerPortType.java	(revision 0)
@@ -0,0 +1,99 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.sample.headershandler;
+
+import java.util.concurrent.Future;
+
+import javax.jws.HandlerChain;
+import javax.jws.Oneway;
+import javax.jws.WebMethod;
+import javax.jws.WebParam;
+import javax.jws.WebResult;
+import javax.jws.WebService;
+import javax.xml.ws.AsyncHandler;
+import javax.xml.ws.RequestWrapper;
+import javax.xml.ws.ResponseWrapper;
+
+import org.test.headershandler.HeadersHandlerResponse;
+
+
+
+/**
+ * This class was generated by the JAXWS SI.
+ * JAX-WS RI 2.0_01-b15-fcs
+ * Generated source version: 2.0
+ * 
+ */
+@WebService(name = "HeadersHandlerPortType", targetNamespace = "http://org/test/headershandler")
+@HandlerChain(file="HeadersClientHandlers.xml")
+public interface HeadersHandlerPortType {
+
+
+    /**
+     * 
+     * @param arg1
+     * @param arg0
+     * @return
+     *     returns int
+     * @throws HeadersHandlerFault_Exception
+     */
+    @WebMethod
+    @WebResult(targetNamespace = "http://org/test/headershandler")
+    @RequestWrapper(localName = "headersHandler", targetNamespace = "http://org/test/headershandler", className = "org.test.headershandler.HeadersHandler")
+    @ResponseWrapper(localName = "headersHandlerResponse", targetNamespace = "http://org/test/headershandler", className = "org.test.headershandler.HeadersHandlerResponse")
+    public int headersHandler(
+        @WebParam(name = "arg0", targetNamespace = "http://org/test/headershandler")
+        int arg0,
+        @WebParam(name = "arg1", targetNamespace = "http://org/test/headershandler")
+        int arg1)
+        throws HeadersHandlerFault_Exception
+    ;
+
+    /**
+     * 
+     * @param asyncHandler
+     * @param arg0
+     * @return
+     *     returns java.util.concurrent.Future<? extends java.lang.Object>
+     */
+    @WebMethod
+    @RequestWrapper(localName = "headersHandler", targetNamespace = "http://org/test/headershandler", className = "org.test.headershandler.HeadersHandler")
+    @ResponseWrapper(localName = "headersHandlerResponse", targetNamespace = "http://org/test/headershandler", className = "org.test.headershandler.HeadersHandlerResponse")
+    public Future<?> headersHandlerAsync(
+            @WebParam(name = "arg0", targetNamespace = "http://org/test/headershandler")
+            int arg0,
+            @WebParam(name = "arg1", targetNamespace = "http://org/test/headershandler")
+            int arg1,
+        @WebParam(name = "asyncHandler", targetNamespace = "")
+        AsyncHandler<HeadersHandlerResponse> asyncHandler);
+
+    
+    /**
+     * 
+     * @param arg0
+     */
+    @WebMethod
+    @Oneway
+    @RequestWrapper(localName = "oneWayInt", targetNamespace = "http://org/test/headershandler", className = "org.test.headershandler.OneWayInt")
+    public void oneWayInt(
+        @WebParam(name = "arg0", targetNamespace = "http://org/test/headershandler")
+        int arg0);
+
+}
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersServerProtocolHandler.java
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersServerProtocolHandler.java	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersServerProtocolHandler.java	(revision 0)
@@ -0,0 +1,167 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.sample.headershandler;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+import javax.xml.soap.SOAPException;
+import javax.xml.soap.SOAPHeader;
+import javax.xml.ws.WebServiceException;
+import javax.xml.ws.handler.MessageContext;
+import javax.xml.ws.handler.soap.SOAPMessageContext;
+
+import org.apache.axis2.Constants;
+import org.w3c.dom.Node;
+
+public class HeadersServerProtocolHandler implements
+        javax.xml.ws.handler.soap.SOAPHandler<SOAPMessageContext> {
+
+	private HandlerTracker tracker = new HandlerTracker(HeadersServerProtocolHandler.class.getSimpleName());
+	private TestHeaders headerUtil = new TestHeaders(this.getClass());
+	
+    public void close(MessageContext messagecontext) {
+    	tracker.close();
+    }
+
+    public boolean handleFault(SOAPMessageContext messagecontext) {
+    	Boolean outbound = (Boolean) messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
+    	tracker.handleFault(outbound);
+    	if (outbound) {
+    	    
+    	    Map<QName, List<String>> requestHeaders = (Map<QName, List<String>>)messagecontext.get(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+    	    headerUtil.confirmHeadersAdapterList(Constants.JAXWS_OUTBOUND_SOAP_HEADERS, requestHeaders, 0);
+
+    	    // add header
+    	    String acoh3 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH3_HEADER_QNAME, TestHeaders.CONTENT_LARGE);
+    	    List<String> acoh3list = new ArrayList<String>();
+    	    acoh3list.add(acoh3);
+    	    requestHeaders.put(TestHeaders.ACOH3_HEADER_QNAME, acoh3list);
+    	    messagecontext.put(Constants.JAXWS_OUTBOUND_SOAP_HEADERS, requestHeaders);
+    	    tracker.addHeader(acoh3.toString());
+    	}
+        return true;
+    }
+
+    public Set getHeaders() {
+    	tracker.getHeaders();
+        return null;
+    }
+
+    public boolean handleMessage(SOAPMessageContext messagecontext) {
+        Boolean outbound = (Boolean) messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
+        tracker.handleMessage(outbound);
+        if (outbound) {  // server outbound response
+        	
+        	// this is the second server outbound handler hit
+            Map<QName, List<String>> requestHeaders = (Map<QName, List<String>>)messagecontext.get(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+            
+            // if the message object contains "33", it means we reversed directions in the "next inbound" server handler
+            // For testing purposes, we add a header here that would have been added by the previous handler in the flow.
+            try {
+                if (messagecontext.getMessage().getSOAPBody().getChildElements().next().toString().contains("33")) {
+                    String acoh1 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL1);
+                    List<String> acoh1list = new ArrayList<String>();
+                    acoh1list.add(acoh1);
+                    requestHeaders.put(TestHeaders.ACOH1_HEADER_QNAME, acoh1list);
+                    messagecontext.put(Constants.JAXWS_OUTBOUND_SOAP_HEADERS, requestHeaders);
+                    tracker.addHeader(acoh1.toString());
+                }
+            } catch (SOAPException e) {
+                throw new WebServiceException(e);
+            }
+
+        	
+        	// expecting one header element
+        	
+        	headerUtil.confirmHeadersAdapterList(Constants.JAXWS_OUTBOUND_SOAP_HEADERS, requestHeaders, 1);
+        	
+        	List<String> list1 = requestHeaders.get(TestHeaders.ACOH1_HEADER_QNAME);
+        	headerUtil.confirmList(TestHeaders.ACOH1_HEADER_QNAME, list1, 1);
+        	String acoh1 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL1);
+        	headerUtil.compareHeaderStrings(acoh1, list1.get(0));
+        	tracker.checkHeader(list1.get(0));
+        	
+        	// remove header
+        	tracker.removedHeader(acoh1);
+        	requestHeaders.remove(TestHeaders.ACOH1_HEADER_QNAME);
+        	
+        	// add header
+        	String acoh5 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH3_HEADER_QNAME, TestHeaders.CONTENT_LARGE);
+        	List<String> acoh4list = new ArrayList<String>();
+        	acoh4list.add(acoh5);
+        	requestHeaders.put(TestHeaders.ACOH3_HEADER_QNAME, acoh4list);
+        	messagecontext.put(Constants.JAXWS_OUTBOUND_SOAP_HEADERS, requestHeaders);
+        	tracker.addHeader(acoh5.toString());
+        	
+        }
+        else {  // server inbound request
+
+        	// this is the first server inbound handler hit
+        	
+        	Map<QName, List<String>> requestHeaders = (Map<QName, List<String>>)messagecontext.get(Constants.JAXWS_INBOUND_SOAP_HEADERS);
+        	headerUtil.confirmHeadersAdapterList(Constants.JAXWS_INBOUND_SOAP_HEADERS, requestHeaders, 2);
+
+        	// expecting two header elements under two different QNames
+        	
+        	List<String> list1 = requestHeaders.get(TestHeaders.ACOH1_HEADER_QNAME);
+        	headerUtil.confirmList(TestHeaders.ACOH1_HEADER_QNAME, list1, 1);
+        	String acoh1 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL2);
+        	headerUtil.compareHeaderStrings(acoh1, list1.get(0));
+        	tracker.checkHeader(list1.get(0));
+
+        	List<String> list2 = requestHeaders.get(TestHeaders.ACOH3_HEADER_QNAME);
+        	headerUtil.confirmList(TestHeaders.ACOH3_HEADER_QNAME, list2, 1);
+        	String acoh2 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH3_HEADER_QNAME, TestHeaders.CONTENT_LARGE);
+        	headerUtil.compareHeaderStrings(acoh2, list2.get(0));
+        	tracker.checkHeader(list2.get(0));
+
+        	// TODO: Would very much like to remove a header using regular SOAP api, but when I attempt this, I get
+        	// an exception later in the runtime (not here):
+        	// "Can't find bundle for base name org.apache.axiom.om.impl.dom.msg.DOMMessages, locale en_US"
+        	
+//        	try {
+//        		SOAPHeader soapHeader = messagecontext.getMessage().getSOAPHeader();
+//        		Node firstChild = messagecontext.getMessage().getSOAPHeader().getFirstChild();
+//        		soapHeader.removeChild(firstChild);
+//        	} catch (SOAPException e) {
+//        		throw new WebServiceException(this.getClass().getSimpleName() + ": " + e.getMessage());
+//        	}
+        	
+        	// instead, we'll do it the new way and forego the above attempt
+        	tracker.removedHeader(acoh1);
+        	requestHeaders.remove(TestHeaders.ACOH1_HEADER_QNAME);
+        	
+        	// add a header
+        	String acoh4 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH4_HEADER_QNAME, TestHeaders.CONTENT_SMALL4);
+        	List<String> acoh4list = new ArrayList<String>();
+        	acoh4list.add(acoh4);
+        	requestHeaders.put(TestHeaders.ACOH4_HEADER_QNAME, acoh4list);
+        	messagecontext.put(Constants.JAXWS_INBOUND_SOAP_HEADERS, requestHeaders);
+        	tracker.addHeader(acoh4.toString());
+        	
+        }
+        return true;
+    }
+
+}
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlerFault_Exception.java
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlerFault_Exception.java	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlerFault_Exception.java	(revision 0)
@@ -0,0 +1,74 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.sample.headershandler;
+
+import org.test.headershandler.HeadersHandlerFault;
+
+import javax.xml.ws.WebFault;
+
+
+/**
+ * This class was generated by the JAXWS SI.
+ * JAX-WS RI 2.0_01-b15-fcs
+ * Generated source version: 2.0
+ * 
+ */
+@WebFault(faultBean="", name = "HeadersHandlerFault", targetNamespace = "http://duke/org")
+public class HeadersHandlerFault_Exception
+    extends Exception
+{
+
+    /**
+     * Java type that goes as soapenv:Fault detail element.
+     * 
+     */
+    private HeadersHandlerFault faultInfo;
+
+    /**
+     * 
+     * @param faultInfo
+     * @param message
+     */
+    public HeadersHandlerFault_Exception(String message, HeadersHandlerFault faultInfo) {
+        super(message);
+        this.faultInfo = faultInfo;
+    }
+
+    /**
+     * 
+     * @param faultInfo
+     * @param message
+     * @param cause
+     */
+    public HeadersHandlerFault_Exception(String message, HeadersHandlerFault faultInfo, Throwable cause) {
+        super(message, cause);
+        this.faultInfo = faultInfo;
+    }
+
+    /**
+     * 
+     * @return
+     *     returns fault bean: duke.org.HeadersHandlerFault
+     */
+    public HeadersHandlerFault getFaultInfo() {
+        return faultInfo;
+    }
+
+}
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientTrackerHandler.java
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientTrackerHandler.java	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientTrackerHandler.java	(revision 0)
@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.sample.headershandler;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+import javax.xml.soap.SOAPException;
+import javax.xml.ws.ProtocolException;
+import javax.xml.ws.handler.MessageContext;
+import javax.xml.ws.handler.soap.SOAPMessageContext;
+
+import org.apache.axis2.Constants;
+
+public class HeadersClientTrackerHandler implements
+        javax.xml.ws.handler.soap.SOAPHandler<SOAPMessageContext> {
+    
+    public void close(MessageContext messagecontext) {
+    }
+
+    public boolean handleFault(SOAPMessageContext messagecontext) {
+        return true;
+    }
+
+    public Set getHeaders() {
+        return null;
+    }
+
+    public boolean handleMessage(SOAPMessageContext messagecontext) {
+        Boolean outbound = (Boolean) messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
+        if (outbound) {
+
+            // this is the first client outbound handler hit
+            
+            Map<QName, List<String>> requestHeaders = (Map<QName, List<String>>)messagecontext.get(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+
+            // this should generate an exception.  We have protection built in to prevent using both
+            // the SOAPHeadersAdapter and SAAJ in the same handler method
+            
+            List<String> list1 = requestHeaders.get(TestHeaders.ACOH1_HEADER_QNAME);
+
+            try {
+                messagecontext.getMessage().getSOAPHeader();
+            } catch (SOAPException e) {
+                throw new ProtocolException(e);
+            }
+
+        }
+        else {  // client inbound response
+        }
+        return true;
+    }
+
+}
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HandlerTracker.java
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HandlerTracker.java	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HandlerTracker.java	(revision 0)
@@ -0,0 +1,134 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.sample.headershandler;
+
+import java.io.FileWriter;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+
+public class HandlerTracker {
+
+    private static final String filelogname = "HeadersHandlerTests.log";
+    
+    private String classname;
+    
+    private static final String CLOSE = "CLOSE";
+    private static final String GET_HEADERS = "GET_HEADERS";
+    private static final String HANDLE_FAULT_INBOUND = "HANDLE_FAULT_INBOUND";
+    private static final String HANDLE_MESSAGE_INBOUND = "HANDLE_MESSAGE_INBOUND";
+    private static final String HANDLE_FAULT_OUTBOUND = "HANDLE_FAULT_OUTBOUND";
+    private static final String HANDLE_MESSAGE_OUTBOUND = "HANDLE_MESSAGE_OUTBOUND";
+    private static final String POST_CONSTRUCT = "POST_CONSTRUCT";
+    private static final String PRE_DESTROY = "PRE_DESTROY";
+    private static final String ADDED_HEADER = "ADDED_HEADER";
+    private static final String CHECKED_HEADER = "CHECKED_HEADER";
+    private static final String REMOVED_HEADER = "REMOVED_HEADER";
+    
+    // should pass classname for "name"
+    public HandlerTracker(String name) {
+        classname = name;
+    }
+    
+    public void postConstruct() {
+        log_to_file(POST_CONSTRUCT);
+    }
+    
+    public void preDestroy() {
+        log_to_file(PRE_DESTROY);
+    }
+    
+    public void close() {
+        log_to_file(CLOSE);
+    }
+
+    public void getHeaders() {
+        log_to_file(GET_HEADERS);
+    }
+    
+    public void addHeader(String xmlHeader) {
+    	log_to_file(ADDED_HEADER + " " + xmlHeader);
+    }
+    
+    public void checkHeader(String xmlHeader) {
+    	log_to_file(CHECKED_HEADER + " " + xmlHeader);
+    }
+    
+    public void removedHeader(String xmlHeader) {
+    	log_to_file(REMOVED_HEADER + " " + xmlHeader);
+    }
+    
+    public void handleFault(boolean outbound) {
+        if (outbound) {
+            log_to_file(HANDLE_FAULT_OUTBOUND);
+        } else {
+            log_to_file(HANDLE_FAULT_INBOUND);
+        }
+    }
+
+    public void handleMessage(boolean outbound) {
+        if (outbound) {
+            log_to_file(HANDLE_MESSAGE_OUTBOUND);
+        } else {
+            log_to_file(HANDLE_MESSAGE_INBOUND);
+        }
+    }
+    
+    public void log(String msg, boolean outbound) {
+        log_to_file(msg + " " + (outbound ? "OUTBOUND" : "INBOUND"));
+    }
+    
+    /*
+     * we have to open and close the file every time we write
+     * as other handler method calls may be interleaved with this one
+     */
+    private void log_to_file(String msg) {
+        try {
+            FileWriter fw = new FileWriter(filelogname, true);
+            fw.write(classname + " " + msg + "\n");
+            fw.flush();
+            fw.close();
+        } catch (Exception e) {
+        }
+    }
+    
+    public void log_exception_to_file(String filename, Throwable e) {
+    	try {
+    		FileWriter fw = new FileWriter(filename, true);
+    		StringWriter sw = new StringWriter();
+    	    PrintWriter pw = new PrintWriter(sw);
+    	    e.printStackTrace(pw);
+    	    fw.write(sw.toString());
+    	    fw.flush();
+    	    fw.close();
+    	} catch (Exception ex) {
+    	}
+    }
+    
+    public void log_to_my_file(String filename, String msg) {
+    	try {
+    		FileWriter fw = new FileWriter(filename, true);
+    	    fw.write(msg);
+    	    fw.flush();
+    	    fw.close();
+    	} catch (Exception ex) {
+    	}
+    }
+    
+}
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientProtocolHandler.java
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientProtocolHandler.java	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersClientProtocolHandler.java	(revision 0)
@@ -0,0 +1,136 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.sample.headershandler;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+import javax.xml.ws.handler.MessageContext;
+import javax.xml.ws.handler.soap.SOAPMessageContext;
+
+import org.apache.axis2.Constants;
+
+public class HeadersClientProtocolHandler implements
+        javax.xml.ws.handler.soap.SOAPHandler<SOAPMessageContext> {
+
+	private HandlerTracker tracker = new HandlerTracker(HeadersClientProtocolHandler.class.getSimpleName());
+	private TestHeaders headerUtil = new TestHeaders(this.getClass());
+	
+    public void close(MessageContext messagecontext) {
+    	tracker.close();
+    }
+
+    public boolean handleFault(SOAPMessageContext messagecontext) {
+    	Boolean outbound = (Boolean) messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
+    	tracker.handleFault(outbound);
+    	if (!outbound) {
+    	    // this is the second client inbound handler hit
+        
+    	    // expecting 0 headers
+    	    
+    	    Map<QName, List<String>> requestHeaders = (Map<QName, List<String>>)messagecontext.get(Constants.JAXWS_INBOUND_SOAP_HEADERS);
+    	    headerUtil.confirmHeadersAdapterList(Constants.JAXWS_INBOUND_SOAP_HEADERS, requestHeaders, 0);
+    	}
+        return true;
+    }
+
+    public Set getHeaders() {
+    	tracker.getHeaders();
+        return null;
+    }
+
+    public boolean handleMessage(SOAPMessageContext messagecontext) {
+        Boolean outbound = (Boolean) messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
+        tracker.handleMessage(outbound);
+        if (outbound) {
+
+        	// this is the second client outbound handler hit
+        	
+        	Map<QName, List<String>> requestHeaders = (Map<QName, List<String>>)messagecontext.get(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        	headerUtil.confirmHeadersAdapterList(Constants.JAXWS_OUTBOUND_SOAP_HEADERS, requestHeaders, 1);
+
+        	// expecting one header element
+        	
+        	List<String> list1 = requestHeaders.get(TestHeaders.ACOH1_HEADER_QNAME);
+        	headerUtil.confirmList(TestHeaders.ACOH1_HEADER_QNAME, list1, 1);
+        	String acoh1 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL2);
+        	headerUtil.compareHeaderStrings(acoh1, list1.get(0));
+        	tracker.checkHeader(list1.get(0));
+
+        	/*
+        	 * TODO:  would rather do the below type of testing so a header is added by some means other than
+        	 * SOAPHeadersAdapter, but Axis2 SAAJ implementation appears be be lacking some basic support here.
+        	 * Under Axis2 SAAJ, a header is inserted that has no text node underneath:  <ns:blarg someheader />
+        	 */
+        	//  SOAPElement acoh2 = TestHeaders.createHeaderSOAPElement(TestHeaders.ACOH3_HEADER_QNAME, TestHeaders.CONTENT_LARGE);
+        	//  messagecontext.getMessage().getSOAPHeader().addChildElement(acoh2);
+
+        	/*
+        	 * TODO: instead, we'll do this:
+        	 */
+        	String acoh2 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH3_HEADER_QNAME, TestHeaders.CONTENT_LARGE);
+        	List<String> acoh2list = new ArrayList<String>();
+        	acoh2list.add(acoh2);
+        	requestHeaders.put(TestHeaders.ACOH3_HEADER_QNAME, acoh2list);
+        	messagecontext.put(Constants.JAXWS_OUTBOUND_SOAP_HEADERS, requestHeaders);
+        	tracker.addHeader(acoh2.toString());
+
+        }
+        else {  // client inbound response
+        	
+        	// this is the second client inbound handler hit
+
+        	Map<QName, List<String>> requestHeaders = (Map<QName, List<String>>)messagecontext.get(Constants.JAXWS_INBOUND_SOAP_HEADERS);
+        	headerUtil.confirmHeadersAdapterList(Constants.JAXWS_INBOUND_SOAP_HEADERS, requestHeaders, 2);
+
+        	// expecting two header elements under two QNames
+        	
+        	List<String> list1 = requestHeaders.get(TestHeaders.ACOH3_HEADER_QNAME);
+        	headerUtil.confirmList(TestHeaders.ACOH3_HEADER_QNAME, list1, 1);
+        	String acoh5 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH3_HEADER_QNAME, TestHeaders.CONTENT_LARGE);
+        	headerUtil.compareHeaderStrings(acoh5, list1.get(0));
+        	tracker.checkHeader(list1.get(0));
+        	
+        	List<String> list2 = requestHeaders.get(TestHeaders.ACOH2_HEADER_QNAME);
+        	headerUtil.confirmList(TestHeaders.ACOH2_HEADER_QNAME, list2, 1);
+        	String acoh3 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL3);
+        	headerUtil.compareHeaderStrings(acoh3, list2.get(0));
+        	tracker.checkHeader(list2.get(0));
+        	
+        	// remove list1
+        	requestHeaders.remove(TestHeaders.ACOH3_HEADER_QNAME);
+        	tracker.removedHeader(acoh5);
+        	
+        	// add header to list2
+        	String acoh4 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL4);
+        	list2.add(acoh4);
+        	tracker.addHeader(acoh4);
+        	
+        	// list2 is not a "live" list, so...
+        	requestHeaders.put(TestHeaders.ACOH2_HEADER_QNAME, list2);
+
+        }
+        return true;
+    }
+
+}
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlerService.java
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlerService.java	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersHandlerService.java	(revision 0)
@@ -0,0 +1,78 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.sample.headershandler;
+
+import javax.xml.namespace.QName;
+import javax.xml.ws.Service;
+import javax.xml.ws.WebEndpoint;
+import javax.xml.ws.WebServiceClient;
+import java.io.File;
+import java.net.MalformedURLException;
+import java.net.URL;
+
+/**
+ * This class was generated by the JAXWS SI.
+ * JAX-WS RI 2.0_01-b15-fcs
+ * Generated source version: 2.0
+ * 
+ */
+@WebServiceClient(name = "HeadersHandlerService", targetNamespace = "http://org/test/headershandler", wsdlLocation = "HeadersHandler1.wsdl")
+public class HeadersHandlerService
+    extends Service
+{
+
+    private final static URL HEADERSSERVICE_WSDL_LOCATION;
+    private static String wsdlLocation="/test/org/apache/axis2/jaxws/sample/headershandler/META-INF/HeadersHandler.wsdl";
+    static {
+        URL url = null;
+        try {
+        	try{
+	        	String baseDir = new File(System.getProperty("basedir",".")).getCanonicalPath();
+	        	wsdlLocation = new File(baseDir + wsdlLocation).getAbsolutePath();
+        	}catch(Exception e){
+        		e.printStackTrace();
+        	}
+        	File file = new File(wsdlLocation);
+        	url = file.toURL();
+        } catch (MalformedURLException e) {
+            e.printStackTrace();
+        }
+        HEADERSSERVICE_WSDL_LOCATION = url;
+    }
+
+    public HeadersHandlerService(URL wsdlLocation, QName serviceName) {
+        super(wsdlLocation, serviceName);
+    }
+
+    public HeadersHandlerService() {
+        super(HEADERSSERVICE_WSDL_LOCATION, new QName("http://org/test/headershandler", "HeadersHandlerService"));
+    }
+
+    /**
+     * 
+     * @return
+     *     returns HeadersHandlerPortType
+     */
+    @WebEndpoint(name = "HeadersHandlerPort")
+    public HeadersHandlerPortType getHeadersHandlerPort() {
+        return (HeadersHandlerPortType)super.getPort(new QName("http://org/test/headershandler", "HeadersHandlerPort"), HeadersHandlerPortType.class);
+    }
+
+}
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersServerLogicalHandler.java
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersServerLogicalHandler.java	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/headershandler/HeadersServerLogicalHandler.java	(revision 0)
@@ -0,0 +1,187 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.sample.headershandler;
+
+import java.io.ByteArrayOutputStream;
+import java.io.StringBufferInputStream;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.StringTokenizer;
+
+import javax.xml.namespace.QName;
+import javax.xml.transform.OutputKeys;
+import javax.xml.transform.Source;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.stream.StreamResult;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.ws.LogicalMessage;
+import javax.xml.ws.ProtocolException;
+import javax.xml.ws.handler.MessageContext;
+
+import org.apache.axis2.Constants;
+import org.apache.axis2.jaxws.handler.LogicalMessageContext;
+
+public class HeadersServerLogicalHandler implements
+        javax.xml.ws.handler.LogicalHandler<LogicalMessageContext> {
+
+	private HandlerTracker tracker = new HandlerTracker(HeadersServerLogicalHandler.class.getSimpleName());
+	private TestHeaders headerUtil = new TestHeaders(this.getClass());
+	
+    public void close(MessageContext messagecontext) {
+    	tracker.close();
+    }
+
+    public boolean handleFault(LogicalMessageContext messagecontext) {
+    	Boolean outbound = (Boolean) messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
+    	tracker.handleFault(outbound);
+        return true;
+    }
+
+    public boolean handleMessage(LogicalMessageContext messagecontext) {
+        Boolean outbound = (Boolean) messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
+        tracker.handleMessage(outbound);
+        if (outbound) { // outbound response on the server
+
+        	// this is the first server outbound handler hit
+        	
+            // turn off special property that logs ability to use
+            // both SOAPHeadersAdapter and SAAJ in a single handler method:
+            messagecontext.put(org.apache.axis2.jaxws.handler.Constants.JAXWS_HANDLER_TRACKER, false);
+            
+        	Map<QName, List<String>> requestHeaders = (Map<QName, List<String>>)messagecontext.get(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        	
+        	// add a header
+        	String acoh1 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL1);
+        	List<String> acoh1list = new ArrayList<String>();
+        	acoh1list.add(acoh1);
+        	requestHeaders.put(TestHeaders.ACOH1_HEADER_QNAME, acoh1list);
+        	messagecontext.put(Constants.JAXWS_INBOUND_SOAP_HEADERS, requestHeaders);
+        	tracker.addHeader(acoh1.toString());
+        	
+        	// manipulate the payload just to be thorough (the response element happens
+        	// to be in the same place as arg0, so using the same methods as inbound)
+
+        	LogicalMessage msg = messagecontext.getMessage();
+        	String st = getStringFromSourcePayload(msg.getPayload());
+        	String txt = String.valueOf(Integer.valueOf(getFirstArg(st)) - 1);
+        	st = replaceFirstArg(st, txt);
+        	msg.setPayload(new StreamSource(new StringBufferInputStream(st)));
+
+        } else {  // inbound request on the server
+        	
+        	// this is the second server inbound hit
+            
+            // turn off special property that logs ability to use
+            // both SOAPHeadersAdapter and SAAJ in a single handler method:
+            messagecontext.put(org.apache.axis2.jaxws.handler.Constants.JAXWS_HANDLER_TRACKER, false);
+        	
+        	// let's check for all the headers we expect, remove them, and manipulate the message payload
+        	
+        	Map<QName, List<String>> requestHeaders = (Map<QName, List<String>>)messagecontext.get(Constants.JAXWS_INBOUND_SOAP_HEADERS);
+        	headerUtil.confirmHeadersAdapterList(Constants.JAXWS_INBOUND_SOAP_HEADERS, requestHeaders, 2);
+
+        	// expecting two header elements under two different QNames
+        	
+        	List<String> list1 = requestHeaders.get(TestHeaders.ACOH3_HEADER_QNAME);
+        	headerUtil.confirmList(TestHeaders.ACOH3_HEADER_QNAME, list1, 1);
+        	String acoh1 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH3_HEADER_QNAME, TestHeaders.CONTENT_LARGE);
+        	headerUtil.compareHeaderStrings(acoh1, list1.get(0));
+        	tracker.checkHeader(list1.get(0));
+
+        	List<String> list2 = requestHeaders.get(TestHeaders.ACOH4_HEADER_QNAME);
+        	headerUtil.confirmList(TestHeaders.ACOH4_HEADER_QNAME, list2, 1);
+        	String acoh4 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH4_HEADER_QNAME, TestHeaders.CONTENT_SMALL4);
+        	headerUtil.compareHeaderStrings(acoh4, list2.get(0));
+        	tracker.checkHeader(list2.get(0));
+
+        	// remove the headers before continuing
+        	tracker.removedHeader(acoh1);
+        	requestHeaders.remove(TestHeaders.ACOH3_HEADER_QNAME);
+        	
+        	// manipulate the payload between header removals just to be thorough
+        	
+        	/*
+        	 * NOTE: This is an important test!  The get of a header from the SOAPHeadersAdapter triggers a
+        	 * parse of the header OM element, which previously marked the parser as 'done'.  This caused the
+        	 * below getPayload() to throw an OMException.  This only occurred on server inbound in this
+        	 * scenario, so this implementation MUST REMAIN.  See top of XMLStringBlockImpl._getBOFromReader
+        	 * for the fix.
+        	 */
+        	
+        	LogicalMessage msg = messagecontext.getMessage();
+        	String st = getStringFromSourcePayload(msg.getPayload());
+        	String txt = String.valueOf(Integer.valueOf(getFirstArg(st)) - 1);
+        	st = replaceFirstArg(st, txt);
+        	msg.setPayload(new StreamSource(new StringBufferInputStream(st)));
+        	
+        	tracker.removedHeader(acoh4);
+        	requestHeaders.remove(TestHeaders.ACOH4_HEADER_QNAME);
+
+        	if (st.contains("66")) {
+        	    // test flow reversal and handleFault method ability to access/set headers
+        	    throw new ProtocolException("I don't like 66");
+        	} else if (st.contains("33")) {
+        	    // test flow reversal, without handleFault flow
+        	    return false;
+        	}
+        	
+        }
+        return true;
+    }
+
+    private static String getFirstArg(String payloadString) {
+        StringTokenizer st = new StringTokenizer(payloadString, ">");
+        st.nextToken(); // skip first token.
+        st.nextToken(); // skip second
+        String tempString = st.nextToken();
+        String returnString = new StringTokenizer(tempString, "<").nextToken();
+        return returnString;
+    }
+
+    private static String replaceFirstArg(String payloadString, String newArg) {
+        String firstArg = getFirstArg(payloadString);
+        payloadString = payloadString.replaceFirst(firstArg, newArg);
+        return payloadString;
+    }
+    
+    private static String getStringFromSourcePayload(Source payload) {
+        try {
+
+            TransformerFactory factory = TransformerFactory.newInstance();
+            Transformer trans = factory.newTransformer();
+
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            StreamResult result = new StreamResult(baos);
+
+            trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
+            trans.transform(payload, result);
+
+            HandlerTracker tracker = new HandlerTracker(HeadersServerLogicalHandler.class.getSimpleName());
+            
+            return new String(baos.toByteArray());
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+
+    }
+
+}
Index: modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/HeadersHandlerTests.java
===================================================================
--- modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/HeadersHandlerTests.java	(revision 0)
+++ modules/jaxws-integration/test/org/apache/axis2/jaxws/sample/HeadersHandlerTests.java	(revision 0)
@@ -0,0 +1,741 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.jaxws.sample;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Future;
+
+import javax.xml.namespace.QName;
+import javax.xml.soap.SOAPFactory;
+import javax.xml.ws.AsyncHandler;
+import javax.xml.ws.BindingProvider;
+import javax.xml.ws.Response;
+import javax.xml.ws.WebServiceException;
+import javax.xml.ws.handler.Handler;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+import org.apache.axis2.jaxws.TestLogger;
+
+import org.apache.axis2.Constants;
+import org.apache.axis2.jaxws.framework.AbstractTestCase;
+import org.apache.axis2.jaxws.sample.headershandler.HeadersClientTrackerHandler;
+import org.apache.axis2.jaxws.sample.headershandler.HeadersHandlerPortType;
+import org.apache.axis2.jaxws.sample.headershandler.HeadersHandlerService;
+import org.apache.axis2.jaxws.sample.headershandler.TestHeaders;
+import org.test.headershandler.HeadersHandlerResponse;
+
+/**
+ * @author rott
+ *
+ */
+public class HeadersHandlerTests extends AbstractTestCase {
+
+    String axisEndpoint = "http://localhost:6060/axis2/services/HeadersHandlerService.HeadersHandlerPortTypeImplPort";
+    
+    private static final String filelogname = "HeadersHandlerTests.log";
+
+    public static Test suite() {
+        return getTestSetup(new TestSuite(HeadersHandlerTests.class));
+    }
+    
+    protected void setUp() throws Exception {
+        deleteFile();
+        super.setUp();
+    }
+
+    protected void tearDown() throws Exception {
+        //deleteFile();
+        super.tearDown();
+    }
+
+    private void deleteFile() throws Exception {
+        File file = new File(filelogname);
+        file.delete();  // yes, delete for each retrieval, which should only happen once per test
+    }
+
+
+
+    public void testHeadersHandler() {
+        try {
+            TestLogger.logger.debug("----------------------------------");
+            TestLogger.logger.debug("test: " + getName());
+
+            HeadersHandlerService service = new HeadersHandlerService();
+            HeadersHandlerPortType proxy = service.getHeadersHandlerPort();
+            BindingProvider p = (BindingProvider) proxy;
+            Map<String, Object> requestCtx = p.getRequestContext();
+            
+            requestCtx.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, axisEndpoint);
+            
+            /*
+             * add several headers by way of HeadersAdapter property
+             */
+            String acoh1, acoh2, acoh3, acoh4, acoh5, acoh6;
+            SOAPFactory sf = SOAPFactory.newInstance();
+        	try {
+            	Map<QName, List<String>> requestHeaders = new HashMap<QName, List<String>>();
+            	
+            	// QName used here should match the key for the list set on the requestCtx
+            	acoh1 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL1);
+            	
+            	// QName used here should match the key for the list set on the requestCtx
+            	acoh2 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL2);
+            	
+            	// QName used here should match the key for the list set on the requestCtx
+            	acoh3 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL3);
+            	
+            	// QName used here should match the key for the list set on the requestCtx
+            	acoh4 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL4);
+            	
+            	// create additional header strings that will need to be checked:
+        		acoh5 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH3_HEADER_QNAME, TestHeaders.CONTENT_LARGE);
+        		acoh6 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH4_HEADER_QNAME, TestHeaders.CONTENT_SMALL4);
+            	
+            	List<String> list1 = new ArrayList<String>();
+            	list1.add(acoh1);
+            	list1.add(acoh2);
+            	
+            	List<String> list2 = new ArrayList<String>();
+            	list2.add(acoh3);
+            	list2.add(acoh4);
+            	
+            	requestHeaders.put(TestHeaders.ACOH1_HEADER_QNAME, list1);
+            	requestHeaders.put(TestHeaders.ACOH2_HEADER_QNAME, list2);
+            	requestCtx.put(Constants.JAXWS_OUTBOUND_SOAP_HEADERS, requestHeaders);
+        	} catch (Throwable e) {
+        		fail(e.getMessage());
+        		return;
+        	}
+        	
+        	// some handlers decrement the value, so we can confirm SOAP body manipulation does not corrupt the headers
+        	int numOfHandlerHitsInFlow = 3;
+            
+            int intParam1 = 10;
+            int intParam2 = 10;
+            int total = proxy.headersHandler(intParam1, intParam2);
+            
+            assertEquals("Return value should be " + (intParam1 + intParam2 - numOfHandlerHitsInFlow) + " but was " + total ,
+                         (intParam1 + intParam2 - numOfHandlerHitsInFlow),
+                         total);
+            TestLogger.logger.debug("Total (after handler manipulation) = " + total);
+            
+            /*
+             * I tried to give enough info below in the expected_calls list so you can tell what's
+             * being tested without having to look at handler code.  All header manipulation is
+             * done by SOAPHeadersAdapter.
+             * 
+             * TODO: I would very much like to have done some other means of
+             * header manipulation, but the Axis2 SAAJ module is lacking necessary implementation
+             * to do this with any reliability.
+             */
+            
+            String log = readLogFile();
+            String expected_calls =
+            		// client outbound
+                      "HeadersClientLogicalHandler HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh1+"\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh2+"\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh3+"\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh4+"\n"
+                    + "HeadersClientLogicalHandler REMOVED_HEADER "+acoh1+"\n"
+                    + "HeadersClientLogicalHandler REMOVED_HEADER "+acoh3+"\n"
+                    + "HeadersClientLogicalHandler REMOVED_HEADER "+acoh4+"\n"   // message manipulated after this action
+                    + "HeadersClientProtocolHandler HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersClientProtocolHandler CHECKED_HEADER "+acoh2+"\n"                   
+                    + "HeadersClientProtocolHandler ADDED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler2 HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersClientProtocolHandler2 CHECKED_HEADER "+acoh2+"\n"
+                    + "HeadersClientProtocolHandler2 CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler GET_HEADERS\n"
+                    + "HeadersClientProtocolHandler2 GET_HEADERS\n"
+                    // server inbound
+                    + "HeadersServerProtocolHandler GET_HEADERS\n"
+                    + "HeadersServerProtocolHandler HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersServerProtocolHandler CHECKED_HEADER "+acoh2+"\n"
+                    + "HeadersServerProtocolHandler CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersServerProtocolHandler REMOVED_HEADER "+acoh2+"\n"
+                    + "HeadersServerProtocolHandler ADDED_HEADER "+acoh6+"\n"
+                    + "HeadersServerLogicalHandler HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersServerLogicalHandler CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersServerLogicalHandler CHECKED_HEADER "+acoh6+"\n"
+                    + "HeadersServerLogicalHandler REMOVED_HEADER "+acoh5+"\n"   // message manipulated after this action
+                    + "HeadersServerLogicalHandler REMOVED_HEADER "+acoh6+"\n"
+                    // server outbound
+                    + "HeadersServerLogicalHandler HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersServerLogicalHandler ADDED_HEADER "+acoh1+"\n"   // message manipulated after this action
+                    + "HeadersServerProtocolHandler HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersServerProtocolHandler CHECKED_HEADER "+acoh1+"\n"
+                    + "HeadersServerProtocolHandler REMOVED_HEADER "+acoh1+"\n"
+                    + "HeadersServerProtocolHandler ADDED_HEADER "+acoh5+"\n"
+                    + "HeadersServerLogicalHandler CLOSE\n"
+                    + "HeadersServerProtocolHandler CLOSE\n"
+                    // client inbound
+                    + "HeadersClientProtocolHandler2 HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersClientProtocolHandler2 CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler2 ADDED_HEADER "+acoh3+"\n"
+                    + "HeadersClientProtocolHandler HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersClientProtocolHandler CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler CHECKED_HEADER "+acoh3+"\n"
+                    + "HeadersClientProtocolHandler REMOVED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler ADDED_HEADER "+acoh4+"\n"
+                    + "HeadersClientLogicalHandler HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersClientProtocolHandler2 CLOSE\n"
+                    + "HeadersClientProtocolHandler CLOSE\n"
+                    + "HeadersClientLogicalHandler CLOSE\n";
+            
+            assertEquals(expected_calls, log);
+            
+        } catch (Exception e) {
+            e.printStackTrace();
+            TestLogger.logger.debug("ERROR", e);
+            fail(e.getMessage());
+        }
+        TestLogger.logger.debug("----------------------------------");
+    }
+    
+    public void testHeadersHandlerAsyncCallback() {
+        try {
+            TestLogger.logger.debug("----------------------------------");
+            TestLogger.logger.debug("test: " + getName());
+
+            HeadersHandlerService service = new HeadersHandlerService();
+            HeadersHandlerPortType proxy = service.getHeadersHandlerPort();
+            BindingProvider p = (BindingProvider) proxy;
+            Map<String, Object> requestCtx = p.getRequestContext();
+            
+            requestCtx.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, axisEndpoint);
+            
+            /*
+             * add several headers by way of HeadersAdapter property
+             */
+            String acoh1, acoh2, acoh3, acoh4, acoh5, acoh6;
+            SOAPFactory sf = SOAPFactory.newInstance();
+            try {
+                Map<QName, List<String>> requestHeaders = new HashMap<QName, List<String>>();
+                
+                // QName used here should match the key for the list set on the requestCtx
+                acoh1 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL1);
+                
+                // QName used here should match the key for the list set on the requestCtx
+                acoh2 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL2);
+                
+                // QName used here should match the key for the list set on the requestCtx
+                acoh3 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL3);
+                
+                // QName used here should match the key for the list set on the requestCtx
+                acoh4 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL4);
+                
+                // create additional header strings that will need to be checked:
+                acoh5 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH3_HEADER_QNAME, TestHeaders.CONTENT_LARGE);
+                acoh6 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH4_HEADER_QNAME, TestHeaders.CONTENT_SMALL4);
+                
+                List<String> list1 = new ArrayList<String>();
+                list1.add(acoh1);
+                list1.add(acoh2);
+                
+                List<String> list2 = new ArrayList<String>();
+                list2.add(acoh3);
+                list2.add(acoh4);
+                
+                requestHeaders.put(TestHeaders.ACOH1_HEADER_QNAME, list1);
+                requestHeaders.put(TestHeaders.ACOH2_HEADER_QNAME, list2);
+                requestCtx.put(Constants.JAXWS_OUTBOUND_SOAP_HEADERS, requestHeaders);
+            } catch (Throwable e) {
+                fail(e.getMessage());
+                return;
+            }
+            
+            // some handlers decrement the value, so we can confirm SOAP body manipulation does not corrupt the headers
+            int numOfHandlerHitsInFlow = 3;
+            
+            int intParam1 = 10;
+            int intParam2 = 10;
+            
+            HeadersHandlerAsyncCallback callback = new HeadersHandlerAsyncCallback();
+            Future<?> future = proxy.headersHandlerAsync(intParam1, intParam2, callback);
+
+            while (!future.isDone()) {
+                Thread.sleep(1000);
+                TestLogger.logger.debug("Async invocation incomplete");
+            }
+
+            int total = callback.getResponseValue();
+            
+            
+            assertEquals("Return value should be " + (intParam1 + intParam2 - numOfHandlerHitsInFlow) + " but was " + total ,
+                         (intParam1 + intParam2 - numOfHandlerHitsInFlow),
+                         total);
+            TestLogger.logger.debug("Total (after handler manipulation) = " + total);
+            
+            /*
+             * I tried to give enough info below in the expected_calls list so you can tell what's
+             * being tested without having to look at handler code.  All header manipulation is
+             * done by SOAPHeadersAdapter.
+             * 
+             * TODO: I would very much like to have done some other means of
+             * header manipulation, but the Axis2 SAAJ module is lacking necessary implementation
+             * to do this with any reliability.
+             */
+            
+            String log = readLogFile();
+            String expected_calls =
+                    // client outbound
+                      "HeadersClientLogicalHandler HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh1+"\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh2+"\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh3+"\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh4+"\n"
+                    + "HeadersClientLogicalHandler REMOVED_HEADER "+acoh1+"\n"
+                    + "HeadersClientLogicalHandler REMOVED_HEADER "+acoh3+"\n"
+                    + "HeadersClientLogicalHandler REMOVED_HEADER "+acoh4+"\n"   // message manipulated after this action
+                    + "HeadersClientProtocolHandler HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersClientProtocolHandler CHECKED_HEADER "+acoh2+"\n"                   
+                    + "HeadersClientProtocolHandler ADDED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler2 HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersClientProtocolHandler2 CHECKED_HEADER "+acoh2+"\n"
+                    + "HeadersClientProtocolHandler2 CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler GET_HEADERS\n"
+                    + "HeadersClientProtocolHandler2 GET_HEADERS\n"
+                    // server inbound
+                    + "HeadersServerProtocolHandler GET_HEADERS\n"
+                    + "HeadersServerProtocolHandler HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersServerProtocolHandler CHECKED_HEADER "+acoh2+"\n"
+                    + "HeadersServerProtocolHandler CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersServerProtocolHandler REMOVED_HEADER "+acoh2+"\n"
+                    + "HeadersServerProtocolHandler ADDED_HEADER "+acoh6+"\n"
+                    + "HeadersServerLogicalHandler HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersServerLogicalHandler CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersServerLogicalHandler CHECKED_HEADER "+acoh6+"\n"
+                    + "HeadersServerLogicalHandler REMOVED_HEADER "+acoh5+"\n"   // message manipulated after this action
+                    + "HeadersServerLogicalHandler REMOVED_HEADER "+acoh6+"\n"
+                    // server outbound
+                    + "HeadersServerLogicalHandler HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersServerLogicalHandler ADDED_HEADER "+acoh1+"\n"   // message manipulated after this action
+                    + "HeadersServerProtocolHandler HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersServerProtocolHandler CHECKED_HEADER "+acoh1+"\n"
+                    + "HeadersServerProtocolHandler REMOVED_HEADER "+acoh1+"\n"
+                    + "HeadersServerProtocolHandler ADDED_HEADER "+acoh5+"\n"
+                    + "HeadersServerLogicalHandler CLOSE\n"
+                    + "HeadersServerProtocolHandler CLOSE\n"
+                    // client inbound
+                    + "HeadersClientProtocolHandler2 HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersClientProtocolHandler2 CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler2 ADDED_HEADER "+acoh3+"\n"
+                    + "HeadersClientProtocolHandler HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersClientProtocolHandler CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler CHECKED_HEADER "+acoh3+"\n"
+                    + "HeadersClientProtocolHandler REMOVED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler ADDED_HEADER "+acoh4+"\n"
+                    + "HeadersClientLogicalHandler HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersClientProtocolHandler2 CLOSE\n"
+                    + "HeadersClientProtocolHandler CLOSE\n"
+                    + "HeadersClientLogicalHandler CLOSE\n";
+            
+            assertEquals(expected_calls, log);
+            
+        } catch (Exception e) {
+            e.printStackTrace();
+            fail(e.getMessage());
+        }
+        TestLogger.logger.debug("----------------------------------");
+    }
+    
+    public void testHeadersHandlerServerInboundFault() {
+        TestLogger.logger.debug("----------------------------------");
+        TestLogger.logger.debug("test: " + getName());
+
+        HeadersHandlerService service = new HeadersHandlerService();
+        HeadersHandlerPortType proxy = service.getHeadersHandlerPort();
+        BindingProvider p = (BindingProvider) proxy;
+        Map<String, Object> requestCtx = p.getRequestContext();
+
+        requestCtx.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, axisEndpoint);
+
+        /*
+         * add several headers by way of HeadersAdapter property
+         */
+        String acoh1, acoh2, acoh3, acoh4, acoh5, acoh6;
+        SOAPFactory sf;
+        try {
+            sf = SOAPFactory.newInstance();
+        } catch (Exception e) {
+            e.printStackTrace();
+            fail(e.getMessage());
+            return;
+        }
+
+        Map<QName, List<String>> requestHeaders = new HashMap<QName, List<String>>();
+
+        // QName used here should match the key for the list set on the requestCtx
+        acoh1 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL1);
+
+        // QName used here should match the key for the list set on the requestCtx
+        acoh2 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL2);
+
+        // QName used here should match the key for the list set on the requestCtx
+        acoh3 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL3);
+
+        // QName used here should match the key for the list set on the requestCtx
+        acoh4 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL4);
+
+        // create additional header strings that will need to be checked:
+        acoh5 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH3_HEADER_QNAME, TestHeaders.CONTENT_LARGE);
+        acoh6 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH4_HEADER_QNAME, TestHeaders.CONTENT_SMALL4);
+
+        List<String> list1 = new ArrayList<String>();
+        list1.add(acoh1);
+        list1.add(acoh2);
+
+        List<String> list2 = new ArrayList<String>();
+        list2.add(acoh3);
+        list2.add(acoh4);
+
+        requestHeaders.put(TestHeaders.ACOH1_HEADER_QNAME, list1);
+        requestHeaders.put(TestHeaders.ACOH2_HEADER_QNAME, list2);
+        requestCtx.put(Constants.JAXWS_OUTBOUND_SOAP_HEADERS, requestHeaders);
+
+        // some handlers decrement the value, so we can confirm SOAP body manipulation does not corrupt the headers
+        int numOfHandlerHitsInFlow = 3;
+
+        int intParam1 = 10;
+        int intParam2 = 66;
+            
+        try {
+            int total = proxy.headersHandler(intParam1, intParam2);
+            fail("headersHandler should have caused an exception, but did not.");
+            
+            /*
+             * I tried to give enough info below in the expected_calls list so you can tell what's
+             * being tested without having to look at handler code.  All header manipulation is
+             * done by SOAPHeadersAdapter.
+             * 
+             * TODO: I would very much like to have done some other means of
+             * header manipulation, but the Axis2 SAAJ module is lacking necessary implementation
+             * to do this with any reliability.
+             */
+            
+        } catch (Exception e) {
+            
+            String log = readLogFile();
+            String expected_calls =
+                    // client outbound
+                      "HeadersClientLogicalHandler HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh1+"\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh2+"\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh3+"\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh4+"\n"
+                    + "HeadersClientLogicalHandler REMOVED_HEADER "+acoh1+"\n"
+                    + "HeadersClientLogicalHandler REMOVED_HEADER "+acoh3+"\n"
+                    + "HeadersClientLogicalHandler REMOVED_HEADER "+acoh4+"\n"   // message manipulated after this action
+                    + "HeadersClientProtocolHandler HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersClientProtocolHandler CHECKED_HEADER "+acoh2+"\n"                   
+                    + "HeadersClientProtocolHandler ADDED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler2 HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersClientProtocolHandler2 CHECKED_HEADER "+acoh2+"\n"
+                    + "HeadersClientProtocolHandler2 CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler GET_HEADERS\n"
+                    + "HeadersClientProtocolHandler2 GET_HEADERS\n"
+                    // server inbound
+                    + "HeadersServerProtocolHandler GET_HEADERS\n"
+                    + "HeadersServerProtocolHandler HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersServerProtocolHandler CHECKED_HEADER "+acoh2+"\n"
+                    + "HeadersServerProtocolHandler CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersServerProtocolHandler REMOVED_HEADER "+acoh2+"\n"
+                    + "HeadersServerProtocolHandler ADDED_HEADER "+acoh6+"\n"
+                    + "HeadersServerLogicalHandler HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersServerLogicalHandler CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersServerLogicalHandler CHECKED_HEADER "+acoh6+"\n"
+                    + "HeadersServerLogicalHandler REMOVED_HEADER "+acoh5+"\n"   // message manipulated after this action
+                    + "HeadersServerLogicalHandler REMOVED_HEADER "+acoh6+"\n"   // throws protocol exception
+                    // server outbound
+                    + "HeadersServerProtocolHandler HANDLE_FAULT_OUTBOUND\n"
+                    + "HeadersServerProtocolHandler ADDED_HEADER "+acoh5+"\n"
+                    + "HeadersServerLogicalHandler CLOSE\n"
+                    + "HeadersServerProtocolHandler CLOSE\n"
+                    // client inbound
+                    + "HeadersClientProtocolHandler2 HANDLE_FAULT_INBOUND\n"
+                    + "HeadersClientProtocolHandler2 CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler2 REMOVED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler HANDLE_FAULT_INBOUND\n"
+                    + "HeadersClientLogicalHandler HANDLE_FAULT_INBOUND\n"   // getPayload called, just to exercise underlying code
+                    + "HeadersClientProtocolHandler2 CLOSE\n"
+                    + "HeadersClientProtocolHandler CLOSE\n"
+                    + "HeadersClientLogicalHandler CLOSE\n";
+            
+            assertEquals(expected_calls, log);
+            assertEquals("I don't like 66", e.getMessage());
+            
+        }
+        TestLogger.logger.debug("----------------------------------");
+    }
+    
+    
+    /*
+     * TODO: test is currently disabled due to exception:
+     * 
+     * Caused by: java.net.SocketException: Broken pipe
+     * at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:103)
+     * at java.net.SocketOutputStream.write(SocketOutputStream.java:147)
+     * at org.apache.http.impl.io.AbstractSessionOutputBuffer.write(AbstractSessionOutputBuffer.java:109)
+     * at org.apache.http.impl.io.ChunkedOutputStream.flushCacheWithAppend(ChunkedOutputStream.java:117)
+     * at org.apache.http.impl.io.ChunkedOutputStream.write(ChunkedOutputStream.java:166)
+     * at org.apache.axis2.transport.http.server.AxisHttpResponseImpl$AutoCommitOutputStream.write(AxisHttpResponseImpl.java:231)
+     * at com.ctc.wstx.io.UTF8Writer.write(UTF8Writer.java:139)
+     * at com.ctc.wstx.sw.BufferingXmlWriter.flushBuffer(BufferingXmlWriter.java:1103)
+     * at com.ctc.wstx.sw.BufferingXmlWriter.flush(BufferingXmlWriter.java:213)
+     * at com.ctc.wstx.sw.BaseStreamWriter.flush(BaseStreamWriter.java:311)
+     * ... 12 more
+     * 
+     * Currently, the server side returns the inbound message when a handler.handleMessage
+     * method returns 'false'.  This may be a misinterpretation of the jaxws spec.
+     * When the response flow is fixed, remove this comment, and remove the '_' from the
+     * test method name to enable it.
+     */
+    public void _testHeadersHandlerServerInboundFlowReversal() {
+        TestLogger.logger.debug("----------------------------------");
+        TestLogger.logger.debug("test: " + getName());
+
+        HeadersHandlerService service = new HeadersHandlerService();
+        HeadersHandlerPortType proxy = service.getHeadersHandlerPort();
+        BindingProvider p = (BindingProvider) proxy;
+        Map<String, Object> requestCtx = p.getRequestContext();
+
+        requestCtx.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, axisEndpoint);
+
+        /*
+         * add several headers by way of HeadersAdapter property
+         */
+        String acoh1, acoh2, acoh3, acoh4, acoh5, acoh6;
+        SOAPFactory sf;
+        try {
+            sf = SOAPFactory.newInstance();
+        } catch (Exception e) {
+            e.printStackTrace();
+            fail(e.getMessage());
+            return;
+        }
+
+        Map<QName, List<String>> requestHeaders = new HashMap<QName, List<String>>();
+
+        // QName used here should match the key for the list set on the requestCtx
+        acoh1 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL1);
+
+        // QName used here should match the key for the list set on the requestCtx
+        acoh2 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH1_HEADER_QNAME, TestHeaders.CONTENT_SMALL2);
+
+        // QName used here should match the key for the list set on the requestCtx
+        acoh3 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL3);
+
+        // QName used here should match the key for the list set on the requestCtx
+        acoh4 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH2_HEADER_QNAME, TestHeaders.CONTENT_SMALL4);
+
+        // create additional header strings that will need to be checked:
+        acoh5 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH3_HEADER_QNAME, TestHeaders.CONTENT_LARGE);
+        acoh6 = TestHeaders.createHeaderXMLString(TestHeaders.ACOH4_HEADER_QNAME, TestHeaders.CONTENT_SMALL4);
+
+        List<String> list1 = new ArrayList<String>();
+        list1.add(acoh1);
+        list1.add(acoh2);
+
+        List<String> list2 = new ArrayList<String>();
+        list2.add(acoh3);
+        list2.add(acoh4);
+
+        requestHeaders.put(TestHeaders.ACOH1_HEADER_QNAME, list1);
+        requestHeaders.put(TestHeaders.ACOH2_HEADER_QNAME, list2);
+        requestCtx.put(Constants.JAXWS_OUTBOUND_SOAP_HEADERS, requestHeaders);
+
+        int intParam1 = 10;
+        int intParam2 = 33;
+            
+        try {
+            int total = proxy.headersHandler(intParam1, intParam2);
+        } catch (Exception e) {
+            /*
+             * I tried to give enough info below in the expected_calls list so you can tell what's
+             * being tested without having to look at handler code.  All header manipulation is
+             * done by SOAPHeadersAdapter.
+             * 
+             * TODO: I would very much like to have done some other means of
+             * header manipulation, but the Axis2 SAAJ module is lacking necessary implementation
+             * to do this with any reliability.
+             */
+            
+            
+            String log = readLogFile();
+            String expected_calls =
+                    // client outbound
+                      "HeadersClientLogicalHandler HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh1+"\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh2+"\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh3+"\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh4+"\n"
+                    + "HeadersClientLogicalHandler REMOVED_HEADER "+acoh1+"\n"
+                    + "HeadersClientLogicalHandler REMOVED_HEADER "+acoh3+"\n"
+                    + "HeadersClientLogicalHandler REMOVED_HEADER "+acoh4+"\n"   // message manipulated after this action
+                    + "HeadersClientProtocolHandler HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersClientProtocolHandler CHECKED_HEADER "+acoh2+"\n"                   
+                    + "HeadersClientProtocolHandler ADDED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler2 HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersClientProtocolHandler2 CHECKED_HEADER "+acoh2+"\n"
+                    + "HeadersClientProtocolHandler2 CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler GET_HEADERS\n"
+                    + "HeadersClientProtocolHandler2 GET_HEADERS\n"
+                    // server inbound
+                    + "HeadersServerProtocolHandler GET_HEADERS\n"
+                    + "HeadersServerProtocolHandler HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersServerProtocolHandler CHECKED_HEADER "+acoh2+"\n"
+                    + "HeadersServerProtocolHandler CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersServerProtocolHandler REMOVED_HEADER "+acoh2+"\n"
+                    + "HeadersServerProtocolHandler ADDED_HEADER "+acoh6+"\n"
+                    + "HeadersServerLogicalHandler HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersServerLogicalHandler CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersServerLogicalHandler CHECKED_HEADER "+acoh6+"\n"
+                    + "HeadersServerLogicalHandler REMOVED_HEADER "+acoh5+"\n"   // message manipulated after this action
+                    + "HeadersServerLogicalHandler REMOVED_HEADER "+acoh6+"\n"   // returns false
+                    // server outbound
+                    + "HeadersServerProtocolHandler HANDLE_MESSAGE_OUTBOUND\n"
+                    + "HeadersServerProtocolHandler ADDED_HEADER "+acoh1+"\n"
+                    + "HeadersServerProtocolHandler CHECKED_HEADER "+acoh1+"\n"
+                    + "HeadersServerProtocolHandler REMOVED_HEADER "+acoh1+"\n"
+                    + "HeadersServerProtocolHandler ADDED_HEADER "+acoh5+"\n"
+                    + "HeadersServerLogicalHandler CLOSE\n"
+                    + "HeadersServerProtocolHandler CLOSE\n"
+                    // client inbound
+                    + "HeadersClientProtocolHandler2 HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersClientProtocolHandler2 CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler2 ADDED_HEADER "+acoh3+"\n"
+                    + "HeadersClientProtocolHandler HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersClientProtocolHandler CHECKED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler CHECKED_HEADER "+acoh3+"\n"
+                    + "HeadersClientProtocolHandler REMOVED_HEADER "+acoh5+"\n"
+                    + "HeadersClientProtocolHandler ADDED_HEADER "+acoh4+"\n"
+                    + "HeadersClientLogicalHandler HANDLE_MESSAGE_INBOUND\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh3+"\n"
+                    + "HeadersClientLogicalHandler CHECKED_HEADER "+acoh4+"\n"
+                    + "HeadersClientLogicalHandler REMOVED_HEADER "+acoh3+"\n"
+                    + "HeadersClientLogicalHandler REMOVED_HEADER "+acoh4+"\n"
+                    + "HeadersClientProtocolHandler2 CLOSE\n"
+                    + "HeadersClientProtocolHandler CLOSE\n"
+                    + "HeadersClientLogicalHandler CLOSE\n";
+            
+            assertEquals("I don't like 33", e.getMessage());
+            assertEquals(expected_calls, log);
+            
+        }
+        TestLogger.logger.debug("----------------------------------");
+    }
+    
+    /*
+     * The intent of making the SOAPHeadersAdapter available to handlers is that they
+     * use it as an alternative to SAAJ.  We have protection built in to prevent handler
+     * implementations from doing both.  This method tests for that.
+     */
+    public void testHeadersHandlerTracker() {
+        TestLogger.logger.debug("----------------------------------");
+        TestLogger.logger.debug("test: " + getName());
+        try {
+
+            HeadersHandlerService service = new HeadersHandlerService();
+            HeadersHandlerPortType proxy = service.getHeadersHandlerPort();
+            BindingProvider p = (BindingProvider) proxy;
+            List<Handler> handlers = p.getBinding().getHandlerChain();
+            if (handlers == null)
+                handlers = new ArrayList<Handler>();
+            handlers.add(new HeadersClientTrackerHandler());
+            p.getBinding().setHandlerChain(handlers);
+            Map<String, Object> requestCtx = p.getRequestContext();
+
+            requestCtx.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, axisEndpoint);
+            
+            int total = proxy.headersHandler(1, 1);
+            fail("Should have received a WebServiceException, but did not.");
+
+        } catch (Exception e) {
+            assertTrue(e instanceof WebServiceException);
+        }
+        TestLogger.logger.debug("----------------------------------");
+    }
+    
+    
+    /*
+     * A callback implementation that can be used to collect the exceptions
+     */
+    class HeadersHandlerAsyncCallback implements AsyncHandler<HeadersHandlerResponse> {
+
+        private Exception exception;
+        private int retVal;
+
+        public void handleResponse(Response<HeadersHandlerResponse> response) {
+            try {
+                TestLogger.logger.debug("HeadersHandlerAsyncCallback.handleResponse() was called");
+                HeadersHandlerResponse r = response.get();
+                TestLogger.logger.debug("No exception was thrown from Response.get()");
+                retVal = r.getReturn();
+            } catch (Exception e) {
+                TestLogger.logger.debug("An exception was thrown: " + e.getClass());
+                exception = e;
+            }
+        }
+
+        public int getResponseValue() {
+            return retVal;
+        }
+
+        public Exception getException() {
+            return exception;
+        }
+    }
+    
+    
+    private String readLogFile() {
+        try {
+            FileReader fr = new FileReader(filelogname);
+            BufferedReader inputStream = new BufferedReader(fr);
+            String line = null;
+            String ret = null;
+            while ((line = inputStream.readLine()) != null) {
+                if (ret == null) {
+                    ret = "";
+                }
+                ret = ret.concat(line + "\n");
+            }
+            fr.close();
+            return ret;
+        } catch (FileNotFoundException fnfe) {
+            // it's possible the test does not actually call any handlers and therefore
+            // no file would have been written.  The test should account for this by
+            // assertNull on the return value from here
+        } catch (IOException ioe) {
+            ioe.printStackTrace();
+            fail(ioe.getMessage());
+        }
+        return null;
+    }
+
+}
Index: modules/jaxws-integration/test-resources/wsdl/HeadersHandler.wsdl
===================================================================
--- modules/jaxws-integration/test-resources/wsdl/HeadersHandler.wsdl	(revision 0)
+++ modules/jaxws-integration/test-resources/wsdl/HeadersHandler.wsdl	(revision 0)
@@ -0,0 +1,119 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one
+  ~ or more contributor license agreements. See the NOTICE file
+  ~ distributed with this work for additional information
+  ~ regarding copyright ownership. The ASF licenses this file
+  ~ to you under the Apache License, Version 2.0 (the
+  ~ "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing,
+  ~ software distributed under the License is distributed on an
+  ~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  ~ KIND, either express or implied. See the License for the
+  ~ specific language governing permissions and limitations
+  ~ under the License.
+  -->
+
+<definitions name="HeadersHandler" targetNamespace="http://org/test/headershandler"
+	xmlns:tns="http://org/test/headershandler" xmlns="http://schemas.xmlsoap.org/wsdl/"
+	xmlns:xsd="http://www.w3.org/2001/XMLSchema"
+	xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/">
+
+
+	<types>
+		<xsd:schema xmlns="http://www.w3.org/2001/XMLSchema"
+			elementFormDefault="qualified" targetNamespace="http://org/test/headershandler">
+			<element name="headersHandlerResponse">
+				<complexType>
+					<sequence>
+						<element name="return" type="xsd:int" />
+					</sequence>
+				</complexType>
+			</element>
+
+			<element name="headersHandler">
+				<complexType>
+					<sequence>
+						<element name="arg0" type="xsd:int" />
+						<element name="arg1" type="xsd:int" />
+					</sequence>
+				</complexType>
+			</element>
+
+			<element name="HeadersHandlerFault">
+				<complexType>
+					<sequence>
+						<element name="faultInfo" type="xsd:string" />
+						<element name="message" type="xsd:string" />
+					</sequence>
+				</complexType>
+			</element>
+
+			<element name="oneWayInt">
+				<complexType>
+					<sequence>
+						<element name="arg0" type="xsd:int" />
+					</sequence>
+				</complexType>
+			</element>
+
+		</xsd:schema>
+	</types>
+
+	<message name="headersHandler">
+		<part name="parameters" element="tns:headersHandler" />
+	</message>
+	<message name="headersHandlerResponse">
+		<part name="result" element="tns:headersHandlerResponse" />
+	</message>
+	<message name="headersHandlerFault">
+		<part name="HeadersHandlerFault" element="tns:HeadersHandlerFault" />
+	</message>
+	<message name="oneWayInt">
+		<part name="parameters" element="tns:oneWayInt" />
+	</message>
+
+	<portType name="HeadersHandlerPortType">
+		<operation name="headersHandler">
+			<input message="tns:headersHandler" name="add" />
+			<output message="tns:headersHandlerResponse" name="addResponse" />
+			<fault name="headersHandlerFault" message="tns:headersHandlerFault" />
+		</operation>
+		<operation name="oneWayInt">
+			<input message="tns:oneWayInt" />
+		</operation>
+	</portType>
+	<binding name="HeadersHandlerBinding" type="tns:HeadersHandlerPortType">
+		<soap:binding transport="http://schemas.xmlsoap.org/soap/http"
+			style="document" />
+		<operation name="headersHandler">
+			
+			<input>
+				<soap:body use="literal" />
+			</input>
+			<output>
+				<soap:body use="literal" />
+			</output>
+			<fault name="headersHandlerFault">
+				<soap:fault name="headersHandlerFault" use="literal" />
+			</fault>
+		</operation>
+		<operation name="oneWayInt">
+			
+			<input>
+				<soap:body use="literal" />
+			</input>
+		</operation>
+	</binding>
+	<service name="HeadersHandlerService">
+		<port name="HeadersHandlerPort" binding="tns:HeadersHandlerBinding">
+			<soap:address
+				location="http://localhost:9080/HeadersHandler/HeadersHandlerImplService" />
+		</port>
+	</service>
+</definitions>
Index: modules/jaxws-integration/pom.xml
===================================================================
--- modules/jaxws-integration/pom.xml	(revision 771051)
+++ modules/jaxws-integration/pom.xml	(working copy)
@@ -273,6 +273,12 @@
                                     <classpath location="${compiled.classes.dir}"/>
                                     <arg line="-d ${schema.generated.src.dir} -quiet -wsdl ${wsdl.source.dir}/AddNumbersHandler.wsdl"/>
                                 </java>
+                                <echo>Generating java from HeadersHandler.wsdl</echo>
+                                <java classname="com.sun.tools.xjc.Driver" fork="true">
+                                    <classpath refid="maven.runtime.classpath"/>
+                                    <classpath location="${compiled.classes.dir}"/>
+                                    <arg line="-d ${schema.generated.src.dir} -quiet -wsdl ${wsdl.source.dir}/HeadersHandler.wsdl"/>
+                                </java>
                                 <echo>Generating java from async_doclitwr.wsdl</echo>
                                 <java classname="com.sun.tools.xjc.Driver" fork="true">
                                     <classpath refid="maven.runtime.classpath"/>
@@ -387,12 +393,6 @@
                                     <classpath location="${compiled.classes.dir}"/>
                                     <arg line="-d ${schema.generated.src.dir} -quiet -wsdl ${wsdl.source.dir}/rpclitenum.wsdl"/>
                                 </java>
-                                <echo>Generating java from AddNumbersHandler.wsdl</echo>
-                                <java classname="com.sun.tools.xjc.Driver" fork="true">
-                                    <classpath refid="maven.runtime.classpath"/>
-                                    <classpath location="${compiled.classes.dir}"/>
-                                    <arg line="-d ${schema.generated.src.dir} -quiet -wsdl ${wsdl.source.dir}/AddNumbersHandler.wsdl"/>
-                                </java>
                                 <echo>Generating java from rpclitstringarray.wsdl</echo>
                                 <java classname="com.sun.tools.xjc.Driver" fork="true">
                                     <classpath refid="maven.runtime.classpath"/>
@@ -970,6 +970,21 @@
                                      basedir="${pom.basedir}/target/test-classes/servicejars/AddNumbersHandlerService"
                                         />
                                 <delete dir="target/test-classes/servicejars/AddNumbersHandlerService"/>
+                                <copy toDir="target/test-classes/servicejars/HeadersHandlerService/">
+                                    <fileset dir="target/test-classes">
+                                        <include name="org/apache/axis2/jaxws/sample/headershandler/**"/>
+                                        <exclude
+                                                name="org/apache/axis2/jaxws/sample/headershandler/META-INF/services.xml"/>
+                                    </fileset>
+                                    <fileset dir="test/org/apache/axis2/jaxws/sample/headershandler">
+                                        <include name="META-INF/**"/>
+                                        <exclude name="META-INF/services.xml"/>
+                                    </fileset>
+                                </copy>
+                                <zip destfile="target/test-classes/servicejars/HeadersHandlerService.jar"
+                                     basedir="${pom.basedir}/target/test-classes/servicejars/HeadersHandlerService"
+                                        />
+                                <delete dir="target/test-classes/servicejars/HeadersHandlerService"/>
                                 <copy toDir="target/test-classes/servicejars/GreeterService/">
                                     <fileset dir="target/test-classes">
                                         <include name="org/apache/axis2/jaxws/sample/dlwmin/**"/>
@@ -1364,6 +1379,7 @@
                         <include>**/JAXBProviderTests.java</include>
                         <include>**/BareTests.java</include>
                         <include>**/AddNumbersHandlerTests.java</include>
+                        <include>**/HeadersHandlerTests.java</include>
                         <include>**/AddNumbersTests.java</include>
                         <include>**/DLWMinTests.java</include>
                         <include>**/FaultsServiceTests.java</include>
Index: modules/jaxws/test/org/apache/axis2/jaxws/handler/soapheadersadapter/SOAPHeadersAdapterTests.java
===================================================================
--- modules/jaxws/test/org/apache/axis2/jaxws/handler/soapheadersadapter/SOAPHeadersAdapterTests.java	(revision 0)
+++ modules/jaxws/test/org/apache/axis2/jaxws/handler/soapheadersadapter/SOAPHeadersAdapterTests.java	(revision 0)
@@ -0,0 +1,982 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.handler.soapheadersadapter;
+
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+import javax.xml.soap.SOAPElement;
+import javax.xml.soap.SOAPEnvelope;
+import javax.xml.soap.SOAPFactory;
+import javax.xml.soap.SOAPHeader;
+import javax.xml.soap.SOAPHeaderElement;
+import javax.xml.soap.SOAPMessage;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.transform.Source;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.ws.WebServiceException;
+
+import junit.framework.TestCase;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.impl.llom.OMSourcedElementImpl;
+import org.apache.axiom.soap.impl.llom.soap11.SOAP11HeaderImpl;
+import org.apache.axis2.Constants;
+import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.handler.LogicalMessageImpl;
+import org.apache.axis2.jaxws.handler.SOAPHeadersAdapter;
+import org.apache.axis2.jaxws.message.Block;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.Protocol;
+import org.apache.axis2.jaxws.message.factory.MessageFactory;
+import org.apache.axis2.jaxws.message.factory.SourceBlockFactory;
+import org.apache.axis2.jaxws.message.factory.XMLStringBlockFactory;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
+
+public class SOAPHeadersAdapterTests extends TestCase {
+
+	private static final String sampleText = "<pre:a xmlns:pre=\"urn://sample\">"
+			+ "<b>Hello</b>" + "<c>World</c>" + "</pre:a>";
+	
+	private static String LARGE_STRING;
+	static {
+		// 100k string
+		for (int i = 0; i < 10000; i++) {
+			LARGE_STRING += "LongString";  // 10 chars * Integer.MAX_VALUE is pretty big.
+		}
+	}
+	
+	// header 1 (ACOH1)
+	private static final String identifierACOH1 = "acoh1";
+	private static final String identifierACOH1namespaceURI = "http://"+identifierACOH1+"ns";
+	private static final String identifierACOH1prefix = identifierACOH1+"pre";
+    public static final QName ACOH1_HEADER_QNAME = new QName(identifierACOH1namespaceURI, identifierACOH1, identifierACOH1prefix);
+    
+	// header 2 (ACOH2)
+	private static final String identifierACOH2 = "acoh2";
+	private static final String identifierACOH2namespaceURI = "http://"+identifierACOH2+"ns";
+	private static final String identifierACOH2prefix = identifierACOH2+"pre";
+    public static final QName ACOH2_HEADER_QNAME = new QName(identifierACOH2namespaceURI, identifierACOH2, identifierACOH2prefix);
+
+    public static final String CONTENT_STRING1 = "content string 1";
+    public static final String CONTENT_STRING2 = "content string 2";
+    
+    
+	public void testAddRemove() throws Exception {
+
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(CONTENT_STRING1);
+    	String acoh1 = e1.toString();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e2 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e2.addTextNode(CONTENT_STRING2);
+    	String acoh2 = e2.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        acoh1ContentList.add(acoh2);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        adapter.put(ACOH2_HEADER_QNAME, acoh1ContentList);
+        adapter.remove(ACOH1_HEADER_QNAME);
+        
+        assertTrue("Adapter should have one item, but has " + adapter.size(), adapter.size() == 1);
+
+	}
+	
+
+	public void testAddRemoveEmpty() throws Exception {
+
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(CONTENT_STRING1);
+    	String acoh1 = e1.toString();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e2 = sf.createElement(ACOH2_HEADER_QNAME);
+    	e2.addTextNode(CONTENT_STRING2);
+    	String acoh2 = e2.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        
+        List<String> acoh2ContentList = new ArrayList<String>();
+        acoh2ContentList.add(acoh2);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        adapter.put(ACOH2_HEADER_QNAME, acoh2ContentList);
+        adapter.remove(ACOH1_HEADER_QNAME);
+        adapter.remove(ACOH2_HEADER_QNAME);
+        
+        // testing isEmpty() method
+        assertTrue("Adapter should have no items, but has " + adapter.size(), adapter.isEmpty());
+        
+        // double-check
+        assertTrue("isEmpty() reported 'true' but we found an item", adapter.get(ACOH1_HEADER_QNAME) == null);
+        assertTrue("isEmpty() reported 'true' but we found an item", adapter.get(ACOH2_HEADER_QNAME) == null);
+
+	}
+	
+	public void testEmptyList() throws Exception {
+
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(CONTENT_STRING1);
+    	String acoh1 = e1.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        
+        // leaving this list empty
+        List<String> acoh2ContentList = new ArrayList<String>();
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        adapter.put(ACOH2_HEADER_QNAME, acoh2ContentList);
+        
+        // TODO is this reasonable for a map (the adapter) to ignore an empty list?  I think so.
+        assertTrue("Adapter should have one item, but has " + adapter.size(), adapter.size() == 1);
+        
+        // double-check
+        assertTrue(adapter.get(ACOH1_HEADER_QNAME).get(0).equals(acoh1));
+        // TODO is this reasonable for a map (the adapter) to ignore an empty list?  I think so.
+        assertTrue("We found an item where we shouldn't have.", adapter.get(ACOH2_HEADER_QNAME) == null);
+
+	}
+	
+	public void testKeyEquivalence() throws Exception {
+
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(CONTENT_STRING1);
+    	String acoh1 = e1.toString();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e2 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e2.addTextNode(CONTENT_STRING2);
+    	String acoh2 = e2.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        
+        // leaving this list empty
+        List<String> acoh2ContentList = new ArrayList<String>();
+        acoh2ContentList.add(acoh2);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        QName equivalentKey = new QName(ACOH1_HEADER_QNAME.getNamespaceURI(), ACOH1_HEADER_QNAME.getLocalPart(), ACOH1_HEADER_QNAME.getPrefix());
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        adapter.put(equivalentKey, acoh2ContentList);
+
+        // testing that two object keys that pass the QName.equals() will result
+        // in previously added headers being wiped
+        
+        assertTrue("Adapter should have one item, but has " + adapter.size(), adapter.size() == 1);
+        
+        // double-check
+        assertTrue(adapter.get(ACOH1_HEADER_QNAME).get(0).equals(acoh2));
+        assertTrue(((List<String>)(adapter.get(ACOH1_HEADER_QNAME))).size() == 1);
+
+	}
+	
+	public void testListItemRemoval() throws Exception {
+
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(CONTENT_STRING1);
+    	String acoh1 = e1.toString();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e2 = sf.createElement(ACOH2_HEADER_QNAME);
+    	e2.addTextNode(CONTENT_STRING2);
+    	String acoh2 = e2.toString();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e3 = sf.createElement(ACOH2_HEADER_QNAME);
+    	e3.addTextNode(LARGE_STRING);
+    	String acoh3 = e3.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        
+        // leaving this list empty
+        List<String> acoh2ContentList = new ArrayList<String>();
+        acoh2ContentList.add(acoh2);
+        acoh2ContentList.add(acoh3);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        adapter.put(ACOH2_HEADER_QNAME, acoh2ContentList);
+        
+        // remove everything, by different means
+        adapter.remove(ACOH1_HEADER_QNAME);
+        
+        // SOAPHeadersAdapter does NOT give back a live list, so these don't mean anything
+        adapter.get(ACOH2_HEADER_QNAME).remove(0);
+        adapter.get(ACOH2_HEADER_QNAME).remove(acoh3);
+
+        assertTrue("Adapter should have one item, but has " + adapter.size(), adapter.size() == 1);
+        
+        // double-check
+        assertTrue(adapter.get(ACOH2_HEADER_QNAME).get(0).equals(acoh2));
+        assertTrue(adapter.get(ACOH2_HEADER_QNAME).get(1).equals(acoh3));
+        assertTrue(((List<String>)(adapter.get(ACOH2_HEADER_QNAME))).size() == 2);
+
+	}
+	
+	// TODO review to verify validity of this test's expectations
+	public void testAddRemoveException() throws Exception {
+
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	// NOTE that for this test it intentionally does not match
+    	SOAPElement e1 = sf.createElement(ACOH2_HEADER_QNAME);
+    	e1.addTextNode(CONTENT_STRING1);
+    	String acoh1 = e1.toString();
+    	
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        
+        try {
+        	adapter.remove(ACOH1_HEADER_QNAME);
+        	fail("should have got an exception");
+        } catch (WebServiceException e) {
+        	// it's not ideal to compare exception output, but...
+        	assertTrue(e.getCause().getMessage().contains("Element name from data source is acoh2, not the expected acoh1"));
+        	return;
+        }
+        fail("Should have returned in the 'catch' block.");
+	}
+	
+	public void testBigContent() throws Exception {
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(LARGE_STRING);
+    	String acoh1 = e1.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        
+        assertTrue("Adapter should have one item, but has " + adapter.size(), adapter.size() == 1);
+	}
+	
+	public void testHeaderStringReuse() throws Exception {
+		MessageContext messageContext = getMessageContext();
+
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	// NOTE we are re-using this xml string in three adds, two of which have mismatched QNames
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(LARGE_STRING);
+    	String acoh1 = e1.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        // Mismatched QNames!
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        adapter.put(ACOH2_HEADER_QNAME, acoh1ContentList);
+        
+        assertTrue("Adapter should have two items, but has " + adapter.size(), adapter.size() == 2);
+	}
+	
+	public void testContainsKey() throws Exception {
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(LARGE_STRING);
+    	String acoh1 = e1.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        
+        assertTrue("Adapter should contain the key " + ACOH1_HEADER_QNAME, adapter.containsKey(ACOH1_HEADER_QNAME));
+	}
+	
+	public void testContainsValue() throws Exception {
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(LARGE_STRING);
+    	String acoh1 = e1.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        
+        assertTrue("Adapter should contain the value " + acoh1ContentList, adapter.containsValue(acoh1ContentList));
+	}
+	
+	public void testEmpty() throws Exception {
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(LARGE_STRING);
+    	String acoh1 = e1.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        adapter.remove(ACOH1_HEADER_QNAME);
+        
+        assertTrue("Adapter should be empty.", adapter.isEmpty());
+	}
+
+	
+	public void testValues() throws Exception {
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(CONTENT_STRING1);
+    	String acoh1 = e1.toString();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e2 = sf.createElement(ACOH2_HEADER_QNAME);
+    	e2.addTextNode(CONTENT_STRING2);
+    	String acoh2 = e2.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        
+        List<String> acoh2ContentList = new ArrayList<String>();
+        acoh2ContentList.add(acoh2);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        adapter.put(ACOH2_HEADER_QNAME, acoh2ContentList);
+
+        // testing "values()" method 
+        assertTrue(adapter.values().contains(acoh1ContentList));
+        assertTrue(adapter.values().contains(acoh2ContentList));
+
+        // re-check to make sure nothing got corrupted
+        assertTrue(adapter.get(ACOH1_HEADER_QNAME).get(0).equals(acoh1));
+        assertTrue(adapter.get(ACOH2_HEADER_QNAME).get(0).equals(acoh2));
+	}
+	
+
+	public void testKeySet() throws Exception {
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(CONTENT_STRING1);
+    	String acoh1 = e1.toString();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e2 = sf.createElement(ACOH2_HEADER_QNAME);
+    	e2.addTextNode(CONTENT_STRING2);
+    	String acoh2 = e2.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        
+        List<String> acoh2ContentList = new ArrayList<String>();
+        acoh2ContentList.add(acoh2);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        adapter.put(ACOH2_HEADER_QNAME, acoh2ContentList);
+        adapter.remove(ACOH1_HEADER_QNAME);
+        
+        // testing "keySet()" method 
+        Set<QName> keyset = adapter.keySet();
+        assertTrue(!keyset.contains(ACOH1_HEADER_QNAME));
+        assertTrue(keyset.contains(ACOH2_HEADER_QNAME));
+
+        // re-check to make sure nothing got corrupted
+        assertTrue(adapter.get(ACOH2_HEADER_QNAME).get(0).equals(acoh2));
+	}
+	
+	public void testEntrySet() throws Exception {
+	    MessageContext messageContext = getMessageContext();
+
+	    SOAPHeadersAdapter.install(messageContext);
+
+	    SOAPFactory sf = SOAPFactory.newInstance();
+
+	    // QName used here should match the key for the list set on the requestCtx
+	    SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+	    e1.addTextNode(CONTENT_STRING1);
+	    String acoh1 = e1.toString();
+
+	    // QName used here should match the key for the list set on the requestCtx
+	    SOAPElement e2 = sf.createElement(ACOH2_HEADER_QNAME);
+	    e2.addTextNode(CONTENT_STRING2);
+	    String acoh2 = e2.toString();
+
+	    List<String> acoh1ContentList = new ArrayList<String>();
+	    acoh1ContentList.add(acoh1);
+
+	    List<String> acoh2ContentList = new ArrayList<String>();
+	    acoh2ContentList.add(acoh2);
+
+	    SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+
+	    Map<QName, List<String>> hm1 = new HashMap<QName, List<String>>();
+        hm1.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        Map<QName, List<String>> hm2 = new HashMap<QName, List<String>>();
+        hm2.put(ACOH2_HEADER_QNAME, acoh2ContentList);
+	    
+	    adapter.putAll(hm1);
+	    adapter.putAll(hm2);
+
+	    // testing "entrySet()" method
+	    Set<Map.Entry<QName, List<String>>> entryset = adapter.entrySet();
+	    
+        int checkCounter = 0;
+	    for (Iterator it = entryset.iterator();it.hasNext();) {
+	        Map.Entry<QName, List<String>> entry = (Map.Entry<QName, List<String>>)it.next();
+	        // we cannot assume that the order the maps went into
+	        // the adapter will be the order they come out:
+	        if (entry.getKey().equals(ACOH1_HEADER_QNAME)) {
+	            assertTrue(entry.getKey().equals(ACOH1_HEADER_QNAME));
+	            assertTrue(entry.getValue().equals(acoh1ContentList));
+	            checkCounter++;
+	        } else if (entry.getKey().equals(ACOH2_HEADER_QNAME)) {
+	            assertTrue(entry.getKey().equals(ACOH2_HEADER_QNAME));
+	            assertTrue(entry.getValue().equals(acoh2ContentList));
+	            checkCounter += 2;
+	        }
+	    }
+        assertTrue("Expected entrySet was not returned from SOAPHeadersAdapter.entrySet().", checkCounter == 3);
+
+	    // re-check to make sure nothing got corrupted
+	    assertTrue(adapter.get(ACOH1_HEADER_QNAME).get(0).equals(acoh1));
+	    assertTrue(adapter.get(ACOH2_HEADER_QNAME).get(0).equals(acoh2));
+	}
+	
+	public void testPutAll() throws Exception {
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(CONTENT_STRING1);
+    	String acoh1 = e1.toString();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e2 = sf.createElement(ACOH2_HEADER_QNAME);
+    	e2.addTextNode(CONTENT_STRING2);
+    	String acoh2 = e2.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        
+        List<String> acoh2ContentList = new ArrayList<String>();
+        acoh2ContentList.add(acoh2);
+        
+        Map<QName, List<String>> requestHeaders = new HashMap<QName, List<String>>();
+        requestHeaders.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        requestHeaders.put(ACOH2_HEADER_QNAME, acoh2ContentList);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+
+        adapter.putAll(requestHeaders);
+        
+        // testing "keySet()" method 
+        Set<QName> keyset = adapter.keySet();
+        assertTrue(keyset.contains(ACOH1_HEADER_QNAME));
+        assertTrue(keyset.contains(ACOH2_HEADER_QNAME));
+
+        // check the data too
+        assertTrue(adapter.get(ACOH1_HEADER_QNAME).get(0).equals(acoh1));
+        assertTrue(adapter.get(ACOH2_HEADER_QNAME).get(0).equals(acoh2));
+	}
+
+	
+	// The next few tests exercise the underlying data structures that define a "Message" object
+
+	public void testAddRemoveAsSOAPMessage() throws Exception {
+
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(CONTENT_STRING1);
+    	String acoh1 = e1.toString();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e2 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e2.addTextNode(CONTENT_STRING2);
+    	String acoh2 = e2.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        acoh1ContentList.add(acoh2);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        
+        // get message object and convert to SOAPMessage
+        SOAPMessage soapMessage = messageContext.getMessage().getAsSOAPMessage();
+        
+        // confirm headers are there
+        SOAPHeader soapHeader = soapMessage.getSOAPHeader();
+        Iterator<SOAPHeaderElement> it = soapHeader.getChildElements();
+        // TODO: not sure if the order of the header additions is or should be preserved.
+        // in other words, this test may be a little too strict.
+        SOAPHeaderElement headerElem1 = it.next();
+        SOAPHeaderElement headerElem2 = it.next();
+        // should only be two header elements, so...
+        assertFalse(it.hasNext());
+        
+        assertTrue(headerElem1.toString().equals(acoh1));
+        assertTrue(headerElem2.toString().equals(acoh2));
+        
+        // now that we've done a toString() on the header elements, they've been parsed and
+        // processed by the underlying OM implementation...  let's remove one by way of SOAP
+        // API, then let's make sure we can still get and manipulate the headers via the
+        // SOAPHeadersAdapter
+        
+        // TODO:  removeChild gives an exception
+        //soapHeader.removeChild(headerElem1);
+        headerElem1.detachNode();
+        
+        // one is removed, make sure the SOAPHeadersAdapter reflects the change
+        
+        List<String> contentListAfterSOAPRemoval = adapter.get(ACOH1_HEADER_QNAME);
+        assertTrue(contentListAfterSOAPRemoval.size() == 1);
+        // remember we removed headerElem1, so we expect acoh2 to still exist
+        assertTrue(contentListAfterSOAPRemoval.get(0).equals(acoh2));
+        
+	}
+	
+	public void testAddRemoveAsSOAPEnvelope() throws Exception {
+
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(CONTENT_STRING1);
+    	String acoh1 = e1.toString();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e2 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e2.addTextNode(CONTENT_STRING2);
+    	String acoh2 = e2.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        acoh1ContentList.add(acoh2);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        
+        // get message object and convert to SOAPEnvelope
+        SOAPEnvelope soapEnvelope = messageContext.getMessage().getAsSOAPEnvelope();
+        
+        // confirm headers are there
+        SOAPHeader soapHeader = soapEnvelope.getHeader();
+        Iterator<SOAPHeaderElement> it = soapHeader.getChildElements();
+        // TODO: not sure if the order of the header additions is or should be preserved.
+        // in other words, this test may be a little too strict.
+        SOAPHeaderElement headerElem1 = it.next();
+        SOAPHeaderElement headerElem2 = it.next();
+        // should only be two header elements, so...
+        assertFalse(it.hasNext());
+        
+        assertTrue(headerElem1.toString().equals(acoh1));
+        assertTrue(headerElem2.toString().equals(acoh2));
+        
+        // now that we've done a toString() on the header elements, they've been parsed and
+        // processed by the underlying OM implementation...  let's remove one by way of SOAP
+        // API, then let's make sure we can still get and manipulate the headers via the
+        // SOAPHeadersAdapter
+        
+        // TODO:  removeChild gives an exception
+        //soapHeader.removeChild(headerElem1);
+        headerElem1.detachNode();
+        
+        // one is removed, make sure the SOAPHeadersAdapter reflects the change
+        
+        List<String> contentListAfterSOAPRemoval = adapter.get(ACOH1_HEADER_QNAME);
+        assertTrue(contentListAfterSOAPRemoval.size() == 1);
+        // remember we removed headerElem1, so we expect acoh2 to still exist
+        assertTrue(contentListAfterSOAPRemoval.get(0).equals(acoh2));
+        
+	}
+	
+	public void testAddRemoveAsOMElement() throws Exception {
+
+		MessageContext messageContext = getMessageContext();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(CONTENT_STRING1);
+    	String acoh1 = e1.toString();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e2 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e2.addTextNode(CONTENT_STRING2);
+    	String acoh2 = e2.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        acoh1ContentList.add(acoh2);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        
+        // get message object and convert to SOAPEnvelope
+        OMElement omEnvelope = messageContext.getMessage().getAsOMElement();
+        
+        // confirm headers are there.  I can cast here only because I know the implementation.  :)
+        SOAP11HeaderImpl omHeader = (SOAP11HeaderImpl)omEnvelope.getChildElements().next();
+
+        Iterator<OMSourcedElementImpl> it = omHeader.getChildElements();
+        // TODO: not sure if the order of the header additions is or should be preserved.
+        // in other words, this test may be a little too strict.
+        OMSourcedElementImpl headerElem1 = it.next();
+        OMSourcedElementImpl headerElem2 = it.next();
+        // should only be two header elements, so...
+        assertFalse(it.hasNext());
+        
+        assertTrue(headerElem1.toString().equals(acoh1));
+        assertTrue(headerElem2.toString().equals(acoh2));
+        
+        // now that we've done a toString() on the header elements, they've been parsed and
+        // processed by the underlying OM implementation...  let's remove one by way of SOAP
+        // API, then let's make sure we can still get and manipulate the headers via the
+        // SOAPHeadersAdapter
+        
+        // TODO:  removeChild gives an exception
+        //soapHeader.removeChild(headerElem1);
+        headerElem1.detach();
+        
+        // one is removed, make sure the SOAPHeadersAdapter reflects the change
+        
+        List<String> contentListAfterSOAPRemoval = adapter.get(ACOH1_HEADER_QNAME);
+        assertTrue(contentListAfterSOAPRemoval.size() == 1);
+        // remember we removed headerElem1, so we expect acoh2 to still exist
+        assertTrue(contentListAfterSOAPRemoval.get(0).equals(acoh2));
+
+	}
+	
+	public void testAddRemoveAsOMElementUsingSourceFactory() throws Exception {
+
+		MessageContext messageContext = getMessageContextUsingSourceFactory();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(CONTENT_STRING1);
+    	String acoh1 = e1.toString();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e2 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e2.addTextNode(CONTENT_STRING2);
+    	String acoh2 = e2.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        acoh1ContentList.add(acoh2);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        
+        // get message object and convert to SOAPEnvelope
+        OMElement omEnvelope = messageContext.getMessage().getAsOMElement();
+        
+        // confirm headers are there.  I can cast here only because I know the implementation.  :)
+        SOAP11HeaderImpl omHeader = (SOAP11HeaderImpl)omEnvelope.getChildElements().next();
+
+        Iterator<OMSourcedElementImpl> it = omHeader.getChildElements();
+        // TODO: not sure if the order of the header additions is or should be preserved.
+        // in other words, this test may be a little too strict.
+        OMSourcedElementImpl headerElem1 = it.next();
+        OMSourcedElementImpl headerElem2 = it.next();
+        // should only be two header elements, so...
+        assertFalse(it.hasNext());
+        
+        assertTrue(headerElem1.toString().equals(acoh1));
+        assertTrue(headerElem2.toString().equals(acoh2));
+        
+        // now that we've done a toString() on the header elements, they've been parsed and
+        // processed by the underlying OM implementation...  let's remove one by way of SOAP
+        // API, then let's make sure we can still get and manipulate the headers via the
+        // SOAPHeadersAdapter
+        
+        // TODO:  removeChild gives an exception
+        //soapHeader.removeChild(headerElem1);
+        headerElem1.detach();
+        
+        // one is removed, make sure the SOAPHeadersAdapter reflects the change
+        
+        List<String> contentListAfterSOAPRemoval = adapter.get(ACOH1_HEADER_QNAME);
+        assertTrue(contentListAfterSOAPRemoval.size() == 1);
+        // remember we removed headerElem1, so we expect acoh2 to still exist
+        assertTrue(contentListAfterSOAPRemoval.get(0).equals(acoh2));
+
+	}
+	
+	public void testAddRemoveAsOMElementUsingSourceFactoryLogicalMessageImpl() throws Exception {
+
+		MessageContext messageContext = getMessageContextUsingSourceFactory();
+		
+		SOAPHeadersAdapter.install(messageContext);
+		
+    	SOAPFactory sf = SOAPFactory.newInstance();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e1 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e1.addTextNode(CONTENT_STRING1);
+    	String acoh1 = e1.toString();
+    	
+    	// QName used here should match the key for the list set on the requestCtx
+    	SOAPElement e2 = sf.createElement(ACOH1_HEADER_QNAME);
+    	e2.addTextNode(CONTENT_STRING2);
+    	String acoh2 = e2.toString();
+
+        List<String> acoh1ContentList = new ArrayList<String>();
+        acoh1ContentList.add(acoh1);
+        acoh1ContentList.add(acoh2);
+        
+        SOAPHeadersAdapter adapter = (SOAPHeadersAdapter)messageContext.getProperty(Constants.JAXWS_OUTBOUND_SOAP_HEADERS);
+        
+        adapter.put(ACOH1_HEADER_QNAME, acoh1ContentList);
+        
+        List<String> headersList = adapter.get(ACOH1_HEADER_QNAME);
+        headersList.get(0).toString();  // trigger some underlying OM implementation parsing
+        
+        // use the LogicalMessageImpl to get the message payload
+        MyLogicalMessageImpl logicalMessageImpl = new MyLogicalMessageImpl(messageContext);
+        Source payload = logicalMessageImpl.getPayload();
+        payload.toString();
+        
+        // get message object and convert to SOAPEnvelope
+        OMElement omEnvelope = messageContext.getMessage().getAsOMElement();
+        
+        // confirm headers are there.  I can cast here only because I know the implementation.  :)
+        SOAP11HeaderImpl omHeader = (SOAP11HeaderImpl)omEnvelope.getChildElements().next();
+
+        Iterator<OMSourcedElementImpl> it = omHeader.getChildElements();
+        // TODO: not sure if the order of the header additions is or should be preserved.
+        // in other words, this test may be a little too strict.
+        OMSourcedElementImpl headerElem1 = it.next();
+        OMSourcedElementImpl headerElem2 = it.next();
+        // should only be two header elements, so...
+        assertFalse(it.hasNext());
+        
+        assertTrue(headerElem1.toString().equals(acoh1));
+        assertTrue(headerElem2.toString().equals(acoh2));
+        
+        // now that we've done a toString() on the header elements, they've been parsed and
+        // processed by the underlying OM implementation...  let's remove one by way of SOAP
+        // API, then let's make sure we can still get and manipulate the headers via the
+        // SOAPHeadersAdapter
+        
+        // TODO:  removeChild gives an exception
+        //soapHeader.removeChild(headerElem1);
+        headerElem1.detach();
+        
+        // one is removed, make sure the SOAPHeadersAdapter reflects the change
+        
+        List<String> contentListAfterSOAPRemoval = adapter.get(ACOH1_HEADER_QNAME);
+        assertTrue(contentListAfterSOAPRemoval.size() == 1);
+        // remember we removed headerElem1, so we expect acoh2 to still exist
+        assertTrue(contentListAfterSOAPRemoval.get(0).equals(acoh2));
+
+	}
+
+	
+	/*
+	 *  provide a MessageContext with a valid Message object
+	 */
+	private MessageContext getMessageContext() throws XMLStreamException {
+		// Create a SOAP 1.1 Message
+		MessageFactory mf = (MessageFactory) FactoryRegistry
+				.getFactory(MessageFactory.class);
+		Message m = mf.create(Protocol.soap11);
+
+		// Get the BlockFactory
+		XMLStringBlockFactory f = (XMLStringBlockFactory) FactoryRegistry
+				.getFactory(XMLStringBlockFactory.class);
+
+		Block block = f.createFrom(sampleText, null, null);
+		
+		// Add the block to the message as normal body content.
+		m.setBodyBlock(block);
+
+		MessageContext messageContext = new MessageContext();
+		messageContext.setMessage(m);
+		
+		return messageContext;
+	}
+	
+	/*
+	 * provide a MessageContext with a valid Message object
+	 */
+	private MessageContext getMessageContextUsingSourceFactory() throws XMLStreamException {
+		// Create a SOAP 1.1 Message
+		MessageFactory mf = (MessageFactory) FactoryRegistry
+				.getFactory(MessageFactory.class);
+		Message m = mf.create(Protocol.soap11);
+
+		// Get the BlockFactory
+		SourceBlockFactory f = (SourceBlockFactory) FactoryRegistry
+				.getFactory(SourceBlockFactory.class);
+
+		Block block = f.createFrom(new StreamSource(new StringReader(sampleText)), null, null);
+		
+		// Add the block to the message as normal body content.
+		m.setBodyBlock(block);
+
+		MessageContext messageContext = new MessageContext();
+		messageContext.setMessage(m);
+		
+		return messageContext;
+	}
+	
+	private class MyLogicalMessageImpl extends LogicalMessageImpl {
+		public MyLogicalMessageImpl(MessageContext mc) {
+			super(mc.getMEPContext());
+		}
+	}
+	
+}
Index: modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/XMLStringBlockImpl.java
===================================================================
--- modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/XMLStringBlockImpl.java	(revision 771051)
+++ modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/XMLStringBlockImpl.java	(working copy)
@@ -75,7 +75,12 @@
     protected Object _getBOFromReader(XMLStreamReader reader, Object busContext)
             throws XMLStreamException {
         // Create a Reader2Writer converter and get the output as a String
-        Reader2Writer r2w = new Reader2Writer(reader);
+        Reader2Writer r2w;
+        if ((busContext == null) && (omElement != null) && (omElement.isComplete())) {
+            r2w = new Reader2Writer(reader, false);
+        } else {
+            r2w = new Reader2Writer(reader);
+        }
         return r2w.getAsString();
     }
     
Index: modules/jaxws/src/org/apache/axis2/jaxws/message/util/Reader2Writer.java
===================================================================
--- modules/jaxws/src/org/apache/axis2/jaxws/message/util/Reader2Writer.java	(revision 771051)
+++ modules/jaxws/src/org/apache/axis2/jaxws/message/util/Reader2Writer.java	(working copy)
@@ -23,6 +23,9 @@
 import org.apache.axiom.om.OMNode;
 import org.apache.axiom.om.impl.builder.StAXOMBuilder;
 import org.apache.axiom.om.util.StAXUtils;
+import org.apache.axis2.jaxws.utility.JavaUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
@@ -37,6 +40,9 @@
 public class Reader2Writer {
 
     private XMLStreamReader reader;
+    private boolean closeReader = true;
+    
+    private static final Log log = LogFactory.getLog(Reader2Writer.class);
 
     /**
      * Construct from a Reader
@@ -48,6 +54,16 @@
     }
 
     /**
+     * Construct from a Reader
+     * @param reader -- the input to the converter
+     * @param closeReader -- close the reader upon completion
+     */
+    public Reader2Writer(XMLStreamReader reader, boolean closeReader) {
+        this(reader);
+        this.closeReader = closeReader;
+    }
+
+    /**
      * outputTo the writer.
      *
      * @param writer -- the output of the converter
@@ -66,8 +82,13 @@
             //omNode.serializeAndConsume(writer);
             omNode.serialize(writer);
         }
-        // Close the reader
-        reader.close();
+        // Close the reader if marked to do so
+        if (closeReader) {
+            if (log.isDebugEnabled()) {
+                log.debug("closing reader, builder: " + JavaUtils.stackToString());
+            }
+            reader.close();
+        }
     }
 
     /**
Index: modules/jaxws/src/org/apache/axis2/jaxws/handler/SOAPHeadersAdapter.java
===================================================================
--- modules/jaxws/src/org/apache/axis2/jaxws/handler/SOAPHeadersAdapter.java	(revision 771051)
+++ modules/jaxws/src/org/apache/axis2/jaxws/handler/SOAPHeadersAdapter.java	(working copy)
@@ -1,252 +1,353 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements. See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package org.apache.axis2.jaxws.handler;
-
-import org.apache.axis2.jaxws.Constants;
-import org.apache.axis2.jaxws.ExceptionFactory;
-import org.apache.axis2.jaxws.core.MessageContext;
-import org.apache.axis2.jaxws.message.Block;
-import org.apache.axis2.jaxws.message.Message;
-import org.apache.axis2.jaxws.message.factory.XMLStringBlockFactory;
-import org.apache.axis2.jaxws.registry.FactoryRegistry;
-import org.apache.axis2.jaxws.utility.JavaUtils;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-import javax.xml.namespace.QName;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * The JAX-WS exposes soap header properties whose value is Map<QName, List<String>>.  The
- * QName is the name of the header and List<String> are the xml values of the headers for qname.
- * 
- * The JAX-WS MessageContext stores soap headers in an Axiom tree object located on the JAX-WS 
- * Message.
- * 
- * This class, SOAPHeadersAdapter, is an adapter between the Map<QName, List<String>> interface needed
- * by the properties and the actual implementation.  All useful function is delegated through the MessageContext, so 
- * that we only have one copy of the soap header information.  
- * 
- * To use this class, invoke the install method.  This will create an SOAPHeaderAdapter (if necessary) and install it
- * on to provide the JAX-WS soap headers property.  (See BaseMessageContext.)
- */
-public class SOAPHeadersAdapter implements Map<QName, List<String>> {
-
-    private static final Log log = LogFactory.getLog(SOAPHeadersAdapter.class);
-    
-    private MessageContext mc;     // MessageContext which provides the backing implementation of Attachments
-    private boolean isOutbound;    // IsOutbound
-    private String property;
-    
-    /**
-     * Add the AttachmentAdapter as the property for the inbound and/or
-     * outbound attachment property
-     * @param mc MessageContext
-     */
-    public static void install(MessageContext mc) {
-        
-        Message m = mc.getMessage();
-        
-        if (m == null) {
-            // Probably a unit test, can't continue.
-            return;
-        }
-        
-        boolean isOutbound = mc.isOutbound();
-       
-        if (log.isTraceEnabled()) {
-            log.trace("Installing SOAPHeadersAdapter: " +
-                      JavaUtils.callStackToString());
-        }
-        
-        String property = (isOutbound) ? 
-                Constants.JAXWS_OUTBOUND_SOAP_HEADERS :
-                    Constants.JAXWS_INBOUND_SOAP_HEADERS;
-        
-        // See if there is an existing map
-        Object map = mc.getProperty(property);
-
-        // Reuse existing Adapter
-        if (map instanceof SOAPHeadersAdapter) {
-            if (log.isDebugEnabled()) {
-                log.debug("A SOAPHeadersAdapter is already installed.  Reusing the existing one.");
-            }
-            return;
-        } 
-      
-        // Create a new AttachmentsAdapter and set it on the property 
-        SOAPHeadersAdapter sha = 
-            new SOAPHeadersAdapter(mc, 
-                                   isOutbound);
-
-        if (map != null) {
-            // Copy the existing Map contents to this new adapter
-            sha.putAll((Map<QName, List<String>>) map);
-        }
-        mc.setProperty(property, sha);
-    }
-
-    /**
-     * The backing storage of the Attachments is the JAX-WS MessageContext.
-     * Intentionally private, use install(MessageContext)
-     */
-    private SOAPHeadersAdapter(MessageContext mc, 
-                               boolean isOutbound) {
-        this.mc = mc;
-        this.isOutbound = isOutbound;
-        this.property = (isOutbound) ? 
-                    Constants.JAXWS_OUTBOUND_SOAP_HEADERS :
-                    Constants.JAXWS_INBOUND_SOAP_HEADERS;
-        
-        if (log.isDebugEnabled()) {
-            log.debug("Init SOAPHeadersAdapter for " + property);
-        }
-    }
-    
-
-    public void clear() {
-        // Throw unsupported operation exception per Map javadoc
-        // for any method that is not supported.
-        throw new UnsupportedOperationException();
-    }
-    
-    public boolean containsKey(Object key) {
-        Set<QName> keys = this.keySet();
-        return keys.contains(key);
-    }
-    
-    public boolean containsValue(Object value) {
-        Set<QName> keys = this.keySet();
-        for(QName key: keys) {
-            List<String> tryValue = get(key);
-
-            if (tryValue == value ||
-                value.equals(tryValue)) {
-                return true;
-            }
-        }
-        return false;
-    }
-    
-    public Set<Entry<QName, List<String>>> entrySet() {
-        Map<QName, List<String>> tempMap = new HashMap<QName, List<String>>();
-        tempMap.putAll(this);
-        return tempMap.entrySet();
-    }
-    
-    public List<String> get(Object _key) {
-        try {
-            if (!(keySet().contains(_key))) {
-                return null;
-            }
-            QName key = (QName) _key;
-            Message m = mc.getMessage();
-            List<Block> blocks = m.getHeaderBlocks(key.getNamespaceURI(), 
-                                                   key.getLocalPart(),
-                                                   null,
-                                                   getXMLStringBlockFactory(),
-                                                   null);
-            if (blocks == null || blocks.size() == 0) {
-                return null;
-            }
-            
-            // Get the strings from the blocks
-            ArrayList<String> xmlStrings = new ArrayList<String>();
-            for (int i=0; i<blocks.size(); i++) {
-                Block block = blocks.get(i);
-                String value = (block == null) ? null : (String) block.getBusinessObject(false);
-                xmlStrings.add(value);
-            }
-            
-            return xmlStrings;
-        } catch (Throwable t) {
-            throw ExceptionFactory.makeWebServiceException(t);
-        }
-    }
-    
-    public boolean isEmpty() {
-        return this.keySet().isEmpty();
-    }
-    
-    public Set<QName> keySet() {
-        Message m = mc.getMessage();
-        return m.getHeaderQNames();
-    }
-    
-    public List<String> put(QName key, List<String> values) {
-        Message m = mc.getMessage();
-        if (log.isDebugEnabled()) {
-            log.debug("put(" + key + " , " + values + ")");
-        }
-        // Get the old value
-        List<String> old = get(key);
-        
-        if (values != null) {
-            if (old != null) {
-                // Replace the existing header blocks
-                m.removeHeaderBlock(key.getNamespaceURI(), key.getLocalPart());
-            }
-            for (int i=0; i < values.size(); i++) {
-                String value = values.get(i);
-                Block block = getXMLStringBlockFactory().createFrom(value, null, key);
-                m.appendHeaderBlock(key.getNamespaceURI(), key.getLocalPart(), block);
-            }
-        }
-        
-        return old;
-        
-    }
-    
-    public void putAll(Map<? extends QName, ? extends List<String>> t) {
-        for(Entry<? extends QName, ? extends List<String>> entry: t.entrySet()) {
-            QName key = entry.getKey();
-            List<String> value = entry.getValue();  
-            put(key, value);
-        }
-    }
-    
-    public List<String> remove(Object key) {
-        // Throw unsupported operation exception per Map javadoc
-        // for any method that is not supported.
-        throw new UnsupportedOperationException();
-    }
-    
-    public int size() {
-        return this.keySet().size();
-    }
-    
-    public Collection<List<String>> values() {
-        Map<QName, List<String>> tempMap = new HashMap<QName, List<String>>();
-        tempMap.putAll(this);
-        return tempMap.values();
-    }
-    
-    private XMLStringBlockFactory getXMLStringBlockFactory() {
-        return (XMLStringBlockFactory)
-            FactoryRegistry.getFactory(XMLStringBlockFactory.class);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.handler;
+
+import org.apache.axis2.jaxws.Constants;
+import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.message.Block;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.factory.XMLStringBlockFactory;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
+import org.apache.axis2.jaxws.utility.JavaUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import javax.xml.namespace.QName;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * The JAX-WS exposes soap header properties whose value is Map<QName, List<String>>.  The
+ * QName is the name of the header and List<String> are the xml values of the headers for qname.
+ * 
+ * The JAX-WS MessageContext stores soap headers in an Axiom tree object located on the JAX-WS 
+ * Message.
+ * 
+ * This class, SOAPHeadersAdapter, is an adapter between the Map<QName, List<String>> interface needed
+ * by the properties and the actual implementation.  All useful function is delegated through the MessageContext, so 
+ * that we only have one copy of the soap header information.  
+ * 
+ * To use this class, invoke the install method.  This will create an SOAPHeaderAdapter (if necessary) and install it
+ * on to provide the JAX-WS soap headers property.  (See BaseMessageContext.)
+ */
+public class SOAPHeadersAdapter implements Map<QName, List<String>> {
+
+    private static final Log log = LogFactory.getLog(SOAPHeadersAdapter.class);
+    
+    private MessageContext mc;     // MessageContext which provides the backing implementation of Attachments
+    private boolean isOutbound;    // IsOutbound
+    private String property;
+    
+    /**
+     * Add the AttachmentAdapter as the property for the inbound and/or
+     * outbound attachment property
+     * @param mc MessageContext
+     */
+    public static void install(MessageContext mc) {
+        
+        Message m = mc.getMessage();
+        
+        if (m == null) {
+            // Probably a unit test, can't continue.
+            return;
+        }
+        
+        boolean isOutbound = mc.isOutbound();
+       
+        if (log.isTraceEnabled()) {
+            log.trace("Installing SOAPHeadersAdapter: " +
+                      JavaUtils.callStackToString());
+        }
+        
+        String property = (isOutbound) ? 
+                Constants.JAXWS_OUTBOUND_SOAP_HEADERS :
+                    Constants.JAXWS_INBOUND_SOAP_HEADERS;
+        
+        // See if there is an existing map
+        Object map = mc.getProperty(property);
+
+        // Reuse existing Adapter
+        if (map instanceof SOAPHeadersAdapter) {
+            if (log.isDebugEnabled()) {
+                log.debug("A SOAPHeadersAdapter is already installed.  Reusing the existing one.");
+            }
+            return;
+        } 
+      
+        // Create a new AttachmentsAdapter and set it on the property 
+        SOAPHeadersAdapter sha = 
+            new SOAPHeadersAdapter(mc, 
+                                   isOutbound);
+
+        if (map != null) {
+            // Copy the existing Map contents to this new adapter
+            sha.putAll((Map<QName, List<String>>) map);
+        }
+        mc.setProperty(property, sha);
+    }
+
+    /**
+     * The backing storage of the Attachments is the JAX-WS MessageContext.
+     * Intentionally private, use install(MessageContext)
+     */
+    private SOAPHeadersAdapter(MessageContext mc, 
+                               boolean isOutbound) {
+        this.mc = mc;
+        this.isOutbound = isOutbound;
+        this.property = (isOutbound) ? 
+                    Constants.JAXWS_OUTBOUND_SOAP_HEADERS :
+                    Constants.JAXWS_INBOUND_SOAP_HEADERS;
+        
+        if (log.isDebugEnabled()) {
+            log.debug("Init SOAPHeadersAdapter for " + property);
+        }
+    }
+    
+    @Override
+    public void clear() {
+        // Throw unsupported operation exception per Map javadoc
+        // for any method that is not supported.
+    	
+    	// this should remain unsupported as handlers or client
+    	// apps would be able to easily wipe important soap headers
+    	
+        throw new UnsupportedOperationException();
+    }
+    
+    @Override
+    public boolean containsKey(Object key) {
+        Set<QName> keys = this.keySet();
+        return keys.contains(key);
+    }
+    
+    @Override
+    public boolean containsValue(Object value) {
+        Set<QName> keys = this.keySet();
+        for(QName key: keys) {
+            List<String> tryValue = get(key);
+
+            if (tryValue == value ||
+                value.equals(tryValue)) {
+                return true;
+            }
+        }
+        return false;
+    }
+    
+
+    @Override
+    public Set<Entry<QName, List<String>>> entrySet() {
+        // Previous implementation of this method called tempMap.putAll(this), which resulted
+        // in an infinite loop due to Map calling back into this entrySet() method.  So, don't do that!
+        Map<QName, List<String>> tempMap = new HashMap<QName, List<String>>();
+        Set<QName> keys = this.keySet();
+        QName key;
+        for (Iterator<QName> it = keys.iterator();it.hasNext();) {
+            key = (QName)it.next();
+            tempMap.put(key, this.get(key));
+        }
+        return tempMap.entrySet();
+    }
+    
+    
+    /**
+     * Returns a list of XML strings that have the same namespace as the QName key.  The
+     * returned list is not "live"; it manipulating the list will not result in changed
+     * headers on the message.
+     * @param _key Object -- QName key of header XML strings you intend to retrieve
+     */
+    @Override
+    public List<String> get(Object _key) {
+        // notify the HandlerChainProcessor that a transformation has occurred possibly due to a handler method call into here
+        HandlerChainProcessor.trackInternalCall(mc, HandlerChainProcessor.TRACKER.SOAP_HEADERS_ADAPTER_CALLED);
+        try {
+            if (!(keySet().contains(_key))) {
+                return null;
+            }
+            QName key = (QName) _key;
+            Message m = mc.getMessage();
+            List<Block> blocks = m.getHeaderBlocks(key.getNamespaceURI(), 
+                                                   key.getLocalPart(),
+                                                   null,
+                                                   getXMLStringBlockFactory(),
+                                                   null);
+            if (blocks == null || blocks.size() == 0) {
+                return null;
+            }
+            
+            // Get the strings from the blocks
+            ArrayList<String> xmlStrings = new ArrayList<String>();
+            for (int i=0; i<blocks.size(); i++) {
+                Block block = blocks.get(i);
+                String value = (block == null) ? null : (String) block.getBusinessObject(false);
+                xmlStrings.add(value);
+            }
+            
+            return xmlStrings;
+        } catch (Throwable t) {
+            throw ExceptionFactory.makeWebServiceException(t);
+        }
+    }
+    
+    @Override
+    public boolean isEmpty() {
+        return this.keySet().isEmpty();
+    }
+    
+    @Override
+    public Set<QName> keySet() {
+        // notify the HandlerChainProcessor that a transformation has occurred possibly due to a handler method call into here
+        HandlerChainProcessor.trackInternalCall(mc, HandlerChainProcessor.TRACKER.SOAP_HEADERS_ADAPTER_CALLED);
+        Message m = mc.getMessage();
+        return m.getHeaderQNames();
+    }
+    
+    /**
+     * put will inject the headers into the SOAP message immediately
+     * @param key Object -- QName key of header XML strings you wish to be put on the SOAP header
+     * @param values List<String> -- list of XML strings that have the same namespace as the QName key
+     */
+    @Override
+    public List<String> put(QName key, List<String> values) {
+        // notify the HandlerChainProcessor that a transformation has occurred possibly due to a handler method call into here
+        HandlerChainProcessor.trackInternalCall(mc, HandlerChainProcessor.TRACKER.SOAP_HEADERS_ADAPTER_CALLED);
+        
+        Message m = mc.getMessage();
+        if (log.isDebugEnabled()) {
+            log.debug("put(" + key + " , " + values + ")");
+        }
+        // Get the old value
+        List<String> old = get(key);
+        
+        if (values != null) {
+            if (old != null) {
+                // Replace the existing header blocks
+                m.removeHeaderBlock(key.getNamespaceURI(), key.getLocalPart());
+            }
+            for (int i=0; i < values.size(); i++) {
+                String value = values.get(i);
+                Block block = getXMLStringBlockFactory().createFrom(value, null, key);
+                m.appendHeaderBlock(key.getNamespaceURI(), key.getLocalPart(), block);
+            }
+        }
+        
+        return old;
+        
+    }
+    
+    /**
+     * putAll will inject the headers into the SOAP message immediately
+     */
+    @Override
+    public void putAll(Map<? extends QName, ? extends List<String>> t) {
+        for(Entry<? extends QName, ? extends List<String>> entry: t.entrySet()) {
+            QName key = entry.getKey();
+            List<String> value = entry.getValue();  
+            put(key, value);
+        }
+    }
+    
+    
+    /**
+     * remove will immediately remove the headers from the SOAP message that match the QName key
+     * @param key Object -- QName key of header XML strings you wish to remove from the SOAP header
+     */
+    @Override
+    public List<String> remove(Object _key) {
+        // notify the HandlerChainProcessor that a transformation has occurred possibly due to a handler method call into here
+        HandlerChainProcessor.trackInternalCall(mc, HandlerChainProcessor.TRACKER.SOAP_HEADERS_ADAPTER_CALLED);
+        try {
+            if (!(keySet().contains(_key))) {
+                return null;
+            }
+            if (!(_key instanceof QName)) {
+            	throw ExceptionFactory.makeWebServiceException("key must be of type " + QName.class.getName());
+            }
+            QName key = (QName) _key;
+
+            if (log.isDebugEnabled()) {
+                log.debug("remove(" + key + ")");
+            }
+            
+            // Get the old value
+            List<String> old = get(key);
+            
+            Message m = mc.getMessage();
+            List<Block> blocks = m.getHeaderBlocks(key.getNamespaceURI(), 
+                                                   key.getLocalPart(),
+                                                   null,
+                                                   getXMLStringBlockFactory(),
+                                                   null);
+            if (blocks == null || blocks.size() == 0) {
+                return null;
+            }
+            
+            // Get the strings from the blocks
+            ArrayList<String> xmlStrings = new ArrayList<String>();
+            for (int i=0; i<blocks.size(); i++) {
+                Block block = blocks.get(i);
+                String value = (block == null) ? null : (String) block.getBusinessObject(false);
+                xmlStrings.add(value);
+                m.removeHeaderBlock(key.getNamespaceURI(), key.getLocalPart());
+            }
+            
+            keySet().remove(key);
+            
+            return old;
+        } catch (Throwable t) {
+            throw ExceptionFactory.makeWebServiceException(t);
+        }
+    	
+    }
+    
+    @Override
+    public int size() {
+        return this.keySet().size();
+    }
+    
+    @Override
+    public Collection<List<String>> values() {
+    	/*
+    	 * Previous implementation of this method called tempMap.putAll(this), which resulted
+    	 * in an infinite loop due to Map calling back into this values() method.  So, don't do that!
+    	 */
+        Map<QName, List<String>> tempMap = new HashMap<QName, List<String>>();
+        Set<QName> keys = this.keySet();
+        QName key;
+        for (Iterator<QName> it = keys.iterator();it.hasNext();) {
+        	key = (QName)it.next();
+        	tempMap.put(key, this.get(key));
+        }
+        return tempMap.values();
+    }
+    
+    private XMLStringBlockFactory getXMLStringBlockFactory() {
+        return (XMLStringBlockFactory)
+            FactoryRegistry.getFactory(XMLStringBlockFactory.class);
+    }
+
+}
Index: modules/jaxws/src/org/apache/axis2/jaxws/handler/Constants.java
===================================================================
--- modules/jaxws/src/org/apache/axis2/jaxws/handler/Constants.java	(revision 0)
+++ modules/jaxws/src/org/apache/axis2/jaxws/handler/Constants.java	(revision 0)
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.handler;
+
+public class Constants {
+
+    /**
+     * This constant is used to decide if we should track a JAX-WS handler's usage
+     * of the SOAPHeadersAdapter along with SAAJ.  If this property is set to 'true',
+     * then the handler framework will track whether a handler has called any getters/setters/etc
+     * on the SOAPHeadersAdapter AND called any API under Message to get SAAJ objects.  Both
+     * of these cause transformations of data, and together would be more expensive than
+     * if they were separated.
+     */
+    public static final String JAXWS_HANDLER_TRACKER = "org.apache.axis2.jaxws.handler.tracker";
+    
+}
Index: modules/jaxws/src/org/apache/axis2/jaxws/handler/HandlerChainProcessor.java
===================================================================
--- modules/jaxws/src/org/apache/axis2/jaxws/handler/HandlerChainProcessor.java	(revision 771051)
+++ modules/jaxws/src/org/apache/axis2/jaxws/handler/HandlerChainProcessor.java	(working copy)
@@ -71,6 +71,10 @@
     private MEPContext mepCtx;
 
     private List<Handler> handlers = null;
+    
+    // for tracking purposes -- see trackInternalCall
+    private static Handler currentHandler = null;
+    private static String currentMethod = null;
 
     // track start/end of logical and protocol handlers in the list
     // The two scenarios are:  1) run logical handlers only, 2) run all handlers
@@ -88,6 +92,16 @@
     private RuntimeException savedException;
     private Protocol proto; // need to save it incase we have to make a fault message
 
+    // we track whether the SOAPHeadersAdapter and SAAJ are both used in a given handler
+    // method.  If the tracker property is set, and both are called in a handler method,
+    // we throw an exception.  This behavior can easily be turned off by a handler method
+    // by removing or setting to true the Constants.JAXWS_HANDLER_TRACKER property
+    public enum TRACKER {
+        SOAP_HEADERS_ADAPTER_CALLED, SAAJ_CALLED
+    };
+    private static boolean soap_headers_adapter_called = false;
+    private static boolean saaj_called = false;
+
     /*
       * HandlerChainProcess expects null, empty list, or an already-sorted
       * list.  If the chain passed into here came from our HandlerChainResolver,
@@ -236,10 +250,20 @@
         if (expectResponse) {
             if (result == FAILED) {
                 // we should only use callGenericHandlers_avoidRecursion in this case
+                // the message context is now an outbound message context,
+                // and should be marked as such so the SOAPHeadersAdapter will
+                // "install" with the correct property key.
+                mepCtx.getMessageContext().setOutbound(newDirection == Direction.OUT);
+                SOAPHeadersAdapter.install(mepCtx.getMessageContext());                
                 callGenericHandlers_avoidRecursion(newStart, newEnd, newDirection);
                 callCloseHandlers(newStart_inclusive, newEnd, newDirection);
             } else if (result == PROTOCOL_EXCEPTION) {
                 try {
+                    // the message context is now an outbound message context,
+                    // and should be marked as such so the SOAPHeadersAdapter will
+                    // "install" with the correct property key.
+                    mepCtx.getMessageContext().setOutbound(newDirection == Direction.OUT);
+                    SOAPHeadersAdapter.install(mepCtx.getMessageContext());
                     callGenericHandleFault(newStart, newEnd, newDirection);
                     callCloseHandlers(newStart_inclusive, newEnd, newDirection);
                 } catch (RuntimeException re) {
@@ -319,7 +343,7 @@
                 if (log.isDebugEnabled()) {
                     log.debug("Invoking handleMessage on: " + handler.getClass().getName());
                 }
-                handler.handleMessage(currentMC);
+                callHandleMessageWithTracker(handler);
             }
         } else { // IN case
             for (; i >= end; i--) {
@@ -329,7 +353,7 @@
                 if (log.isDebugEnabled()) {
                     log.debug("Invoking handleMessage on: " + handler.getClass().getName());
                 }
-                handler.handleMessage(currentMC);
+                callHandleMessageWithTracker(handler);
             }
         }
     }
@@ -353,7 +377,7 @@
             currentMC.put(Constants.MEP_CONTEXT, mepCtx);
 
             getPreInvoker().preInvoke(currentMC);
-            boolean success = handler.handleMessage(currentMC);
+            boolean success = callHandleMessageWithTracker(handler);
             getPostInvoker().postInvoke(currentMC);
             if (success) {
                 if (log.isDebugEnabled()) {
@@ -411,7 +435,7 @@
                     if (log.isDebugEnabled()) {
                         log.debug("Invoking close on: " + handler.getClass().getName());
                     }
-                    handler.close(currentMC);
+                    callCloseWithTracker(handler);
                     
                     // TODO when we close, are we done with the handler instance, and thus
                     // may call the PreDestroy annotated method?  I don't think so, especially
@@ -431,7 +455,7 @@
                     if (log.isDebugEnabled()) {
                         log.debug("Invoking close on: " + handler.getClass().getName());
                     }
-                    handler.close(currentMC);
+                    callCloseWithTracker(handler);
                     
                     // TODO when we close, are we done with the handler instance, and thus
                     // may call the PreDestroy annotated method?  I don't think so, especially
@@ -509,7 +533,7 @@
                 if (log.isDebugEnabled()) {
                     log.debug("Invoking handleFault on: " + handler.getClass().getName());
                 }
-                boolean success = handler.handleFault(currentMC);
+                boolean success = callHandleFaultWithTracker(handler);
 
                 if (!success)
                     break;
@@ -521,7 +545,7 @@
                 if (log.isDebugEnabled()) {
                     log.debug("Invoking handleFault on: " + handler.getClass().getName());
                 }
-                boolean success = handler.handleFault(currentMC);
+                boolean success = callHandleFaultWithTracker(handler);
 
                 if (!success)
                     break;
@@ -623,5 +647,96 @@
     	return handlerPostInvoker;
     }
     
+    public static void trackInternalCall(org.apache.axis2.jaxws.core.MessageContext mc, TRACKER tracker) {
+        switch (tracker) {
+        case SAAJ_CALLED:
+            saaj_called = true;
+            break;
+        case SOAP_HEADERS_ADAPTER_CALLED:
+            soap_headers_adapter_called = true;
+            break;
+        }
+        Object trackerProp = (mc == null ? null : mc.getProperty(org.apache.axis2.jaxws.handler.Constants.JAXWS_HANDLER_TRACKER));
+        if ((trackerProp != null) && ((Boolean)trackerProp).booleanValue()) {
+            if (saaj_called && soap_headers_adapter_called) {
+                // this means both the SAAJ model and SOAPHeadersAdapter code has been called in such a
+                // way as to cause data transformation.  We want customers to avoid doing this (calling both)
+                // in a given handler method, so we throw an exception:
+                if (log.isDebugEnabled()) {
+                    String logString = "JAX-WS Handler implementations should not use the " + org.apache.axis2.jaxws.handler.Constants.JAXWS_HANDLER_TRACKER 
+                    + " property to retrieve SOAP headers and manipulate the SOAP message using the SAAJ API in the same method "
+                    + "implementation.  The Handler implementation and method doing this is: "
+                    + currentHandler.getClass().getName() + currentMethod;
+                    log.debug(logString);
+                }
+            }
+        }
+    }
+    
+    private boolean callHandleMessageWithTracker(Handler handler) throws RuntimeException {
+        currentHandler = handler;
+        currentMethod = "handleMessage";
+        // turn on the tracker property
+        currentMC.put(org.apache.axis2.jaxws.handler.Constants.JAXWS_HANDLER_TRACKER, true);
+        boolean success = false;
+        RuntimeException savedEx = null;
+        try {
+            success = handler.handleMessage(currentMC);
+        } catch (RuntimeException t) {
+            savedEx = t;
+        }
+        // turn off the tracker property and reset the static tracker booleans
+        currentMC.put(org.apache.axis2.jaxws.handler.Constants.JAXWS_HANDLER_TRACKER, false);
+        saaj_called = false;
+        soap_headers_adapter_called = false;
+        
+        if (savedEx != null) {
+            throw savedEx;
+        }
+        return success;
+    }
+    
+    private boolean callHandleFaultWithTracker(Handler handler) {
+        currentHandler = handler;
+        currentMethod = "handleFault";
+        // turn on the tracker property
+        currentMC.put(org.apache.axis2.jaxws.handler.Constants.JAXWS_HANDLER_TRACKER, true);
+        boolean success = false;
+        RuntimeException savedEx = null;
+        try {
+            success = handler.handleFault(currentMC);
+        } catch (RuntimeException t) {
+            savedEx = t;
+        }
+        // turn off the tracker property and reset the static tracker booleans
+        currentMC.put(org.apache.axis2.jaxws.handler.Constants.JAXWS_HANDLER_TRACKER, false);
+        saaj_called = false;
+        soap_headers_adapter_called = false;
+        
+        if (savedEx != null) {
+            throw savedEx;
+        }
+        return success;
+    }
+    
+    private void callCloseWithTracker(Handler handler) {
+        currentHandler = handler;
+        currentMethod = "close";
+        // turn on the tracker property
+        currentMC.put(org.apache.axis2.jaxws.handler.Constants.JAXWS_HANDLER_TRACKER, true);
+        RuntimeException savedEx = null;
+        try {
+            handler.close(currentMC);
+        } catch (RuntimeException t) {
+            savedEx = t;
+        }
+        // turn off the tracker property and reset the static tracker booleans
+        currentMC.put(org.apache.axis2.jaxws.handler.Constants.JAXWS_HANDLER_TRACKER, false);
+        saaj_called = false;
+        soap_headers_adapter_called = false;
+        if (savedEx != null) {
+            throw savedEx;
+        }
+    }
 
 }
