Index: modules/corba/src/org/apache/axis2/corba/deployer/SchemaGenerator.java
===================================================================
--- modules/corba/src/org/apache/axis2/corba/deployer/SchemaGenerator.java	(revision 614165)
+++ modules/corba/src/org/apache/axis2/corba/deployer/SchemaGenerator.java	(working copy)
@@ -31,6 +31,7 @@
 
 import org.apache.axis2.corba.idl.types.*;
 import org.apache.axis2.corba.receivers.CorbaUtil;
+import org.apache.axis2.corba.exceptions.SchemaGeneratorException;
 
 public class SchemaGenerator implements CorbaConstants {
     private static int prefixCount = 1;
@@ -52,7 +53,7 @@
     private String targetNamespace = null;
     private ArrayList nonRpcMethods = new ArrayList();
 
-    public NamespaceGenerator getNsGen() throws Exception {
+    public NamespaceGenerator getNsGen() throws SchemaGeneratorException {
         if ( nsGen == null ) {
             nsGen = new DefaultNamespaceGenerator();
         }
@@ -117,10 +118,17 @@
      * parameter type and later refers to them.
      *
      * @return Returns XmlSchema.
-     * @throws Exception if failed
+     * @throws SchemaGeneratorException if failed
      */
-    public Collection generateSchema() throws Exception {
+    public Collection generateSchema() throws SchemaGeneratorException {
         Map interfaces = idl.getInterfaces();
+
+        if (interfaces==null)
+            throw new SchemaGeneratorException("No interfaces defined");
+
+        if (interfaceName==null)
+            throw new SchemaGeneratorException("Interface name required");
+
         Interface intf = (Interface) interfaces.get(interfaceName);
         /**
          * Schema genertaion done in two stage 1. Load all the methods and
@@ -146,7 +154,7 @@
             }
 
             if (uniqueMethods.get(operationName) != null) {
-                throw new Exception(
+                throw new SchemaGeneratorException(
                         " Sorry we don't support methods overloading !!!! ");
             }
 
@@ -260,10 +268,10 @@
      *
      * @param dataType object
      * @return Qname
-     * @throws Exception if fails
+     * @throws SchemaGeneratorException if fails
      */
     //private QName generateSchema(JClass dataType) throws Exception {
-    private QName generateSchema(CompositeDataType dataType) throws Exception {
+    private QName generateSchema(CompositeDataType dataType) throws SchemaGeneratorException {
         String name = CorbaUtil.getQualifiedName(dataType);
         QName schemaTypeName = typeTable.getComplexSchemaType(name);
         if (schemaTypeName == null) {
@@ -373,7 +381,7 @@
     // moved code common to Fields & properties out of above method
     private XmlSchemaElement generateSchemaforFieldsandProperties(XmlSchema xmlSchema,
                                                                   DataType type,
-                                                                  String name, boolean forceNotNillable) throws Exception {
+                                                                  String name, boolean forceNotNillable) throws SchemaGeneratorException {
         boolean isArryType = false;
         long maxOccurs = 0;
         long minOccurs = 0;
@@ -433,7 +441,7 @@
                                 typeTable.getComplexSchemaType(propertyTypeName).getNamespaceURI());
             }
         } else {
-            throw new Exception("Unsupported type:" + type);
+            throw new SchemaGeneratorException("Unsupported type:" + type);
         }
         return elt1;
     }
@@ -451,7 +459,7 @@
 
 
     private QName generateSchemaForType(XmlSchemaSequence sequence, DataType type, String partName)
-            throws Exception {
+            throws SchemaGeneratorException {
 
         boolean isArrayType = false;
         if(type!=null){
@@ -630,7 +638,7 @@
         this.extraClasses = extraClasses;
     }
 
-    private String resolveSchemaNamespace(String packageName) throws Exception {
+    private String resolveSchemaNamespace(String packageName) throws SchemaGeneratorException {
         if (useWSDLTypesNamespace) {
             return (String) pkg2nsmap.get("all");
         } else {
Index: modules/corba/src/org/apache/axis2/corba/deployer/CorbaDeployer.java
===================================================================
--- modules/corba/src/org/apache/axis2/corba/deployer/CorbaDeployer.java	(revision 614165)
+++ modules/corba/src/org/apache/axis2/corba/deployer/CorbaDeployer.java	(working copy)
@@ -56,6 +56,11 @@
     public void init(ConfigurationContext configCtx) {
         this.configCtx = configCtx;
         this.axisConfig = this.configCtx.getAxisConfiguration();
+        /*try {
+            System.in.read();
+        } catch (IOException e) {
+
+        }*/
     }
 
     public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {
Index: modules/corba/src/org/apache/axis2/corba/receivers/CorbaUtil.java
===================================================================
--- modules/corba/src/org/apache/axis2/corba/receivers/CorbaUtil.java	(revision 614165)
+++ modules/corba/src/org/apache/axis2/corba/receivers/CorbaUtil.java	(working copy)
@@ -33,6 +33,7 @@
 import org.apache.axis2.namespace.Constants;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.description.*;
+import org.apache.axis2.description.java2wsdl.TypeTable;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.omg.CORBA_2_3.ORB;
@@ -45,6 +46,7 @@
 import org.omg.CORBA.TCKind;
 import org.omg.CORBA.TypeCode;
 
+import javax.xml.namespace.QName;
 import java.util.*;
 import java.util.zip.ZipInputStream;
 import java.util.zip.ZipEntry;
@@ -319,7 +321,7 @@
         if (dataType!=null
                 && !getQualifiedName(dataType).equals(VOID)
                 && resObject!=null) {
-            processResponse(child, bodyContent, resObject, dataType, fac, ns, qualified);
+            processResponse(child, bodyContent, resObject, dataType, fac, ns, qualified, service);
         } else {
             child.addAttribute("nil", "true", fac.createOMNamespace(Constants.URI_2001_SCHEMA_XSI,
                     Constants.NS_PREFIX_SCHEMA_XSI));
@@ -338,7 +340,7 @@
                     child = fac.createOMElement(param.getName(), null);
                 }
                 bodyContent.addChild(child);
-                processResponse(child, bodyContent, paramsIter.next(), param.getDataType(), fac, ns, qualified);
+                processResponse(child, bodyContent, paramsIter.next(), param.getDataType(), fac, ns, qualified, service);
             }
         }
 
@@ -348,14 +350,15 @@
     }
 
     private static void processResponse(OMElement child, OMElement bodyContent, Object resObject, DataType dataType,
-                                        SOAPFactory fac, OMNamespace ns, boolean qualified) {
+                                        SOAPFactory fac, OMNamespace defaultNS, boolean qualified, AxisService service) {
         if (dataType instanceof PrimitiveDataType) {
             child.addChild(fac.createOMText(child, resObject.toString()));
         } else if (dataType instanceof Typedef) {
             Typedef typedef = (Typedef) dataType;
             AliasValue aliasValue = (AliasValue) resObject;
+            OMNamespace ns = getNameSpaceForType(fac, service, typedef);
             OMElement item = fac.createOMElement(ARRAY_ITEM, ns, child);
-            processResponse(item, child, aliasValue.getValue(), typedef.getDataType(), fac, ns, qualified);
+            processResponse(item, child, aliasValue.getValue(), typedef.getDataType(), fac, ns, qualified, service);
         } else if (dataType instanceof AbstractCollectionType) {
             AbstractCollectionType collectionType = (AbstractCollectionType) dataType;
             AbstractCollectionValue collectionValue = (AbstractCollectionValue) resObject;
@@ -366,16 +369,16 @@
                 if (collectionType.getDataType() instanceof AbstractCollectionType) {
                     outer = child;
                     if (qualified) {
-                        child = fac.createOMElement(ARRAY_ITEM, ns);
+                        child = fac.createOMElement(ARRAY_ITEM, defaultNS);
                     } else {
                         child = fac.createOMElement(ARRAY_ITEM, null);
                     }
                     outer.addChild(child);
                 }
-                processResponse(child, outer, values[i], collectionType.getDataType(), fac, ns, qualified);
+                processResponse(child, outer, values[i], collectionType.getDataType(), fac, defaultNS, qualified, service);
                 if (i < (length -1)) {
                     if (qualified) {
-                        child = fac.createOMElement(ARRAY_ITEM, ns);
+                        child = fac.createOMElement(ARRAY_ITEM, defaultNS);
                     } else {
                         child = fac.createOMElement(ARRAY_ITEM, null);
                     }
@@ -386,20 +389,22 @@
             AbstractValue resValue = (AbstractValue) resObject;
             Member[] members = resValue.getMembers();
             Object[] memberValues = resValue.getMemberValues();
+            OMNamespace ns = getNameSpaceForType(fac, service, (CompositeDataType) dataType);
             for (int i = 0; i < memberValues.length; i++) {
                 OMElement memberElement = fac.createOMElement(members[i].getName(), ns);
-                processResponse(memberElement, bodyContent, memberValues[i], members[i].getDataType(), fac, ns, qualified);
+                processResponse(memberElement, bodyContent, memberValues[i], members[i].getDataType(), fac, ns, qualified, service);
                 child.addChild(memberElement);
             }
         } else if (dataType instanceof UnionType) {
             UnionValue unionValue = (UnionValue) resObject;
             OMElement unMember;
-            if (qualified) {// ?
+            OMNamespace ns = getNameSpaceForType(fac, service, (CompositeDataType) dataType);
+            if (qualified) {
                 unMember = fac.createOMElement(unionValue.getMemberName(), ns);
             } else {
                 unMember = fac.createOMElement(unionValue.getMemberName(), null);
             }
-            processResponse(unMember, child, unionValue.getMemberValue(), unionValue.getMemberType(), fac, ns, qualified);
+            processResponse(unMember, child, unionValue.getMemberValue(), unionValue.getMemberType(), fac, ns, qualified, service);
             child.addChild(unMember);
         } else if (dataType instanceof EnumType) {
             EnumValue enumValue = (EnumValue) resObject;
@@ -407,6 +412,16 @@
         }
     }
 
+    private static OMNamespace getNameSpaceForType(SOAPFactory fac, AxisService service, CompositeDataType dataType) {
+        TypeTable typeTable = service.getTypeTable();
+        String fullname = (dataType.getModule()!=null) ? dataType.getModule() + dataType.getName() : dataType.getName();
+        fullname = fullname.replaceAll(CompositeDataType.MODULE_SEPERATOR, ".");
+        QName qname = typeTable.getQNamefortheType(fullname);
+        if (qname==null)
+            return null;
+        return fac.createOMNamespace(qname.getNamespaceURI(), qname.getPrefix());
+    }
+
     public static String getQualifiedName(DataType type){
         if (type instanceof CompositeDataType) {
             CompositeDataType compositeType = (CompositeDataType) type;
Index: modules/corba/src/org/apache/axis2/corba/idl/types/CompositeDataType.java
===================================================================
--- modules/corba/src/org/apache/axis2/corba/idl/types/CompositeDataType.java	(revision 614165)
+++ modules/corba/src/org/apache/axis2/corba/idl/types/CompositeDataType.java	(working copy)
@@ -24,7 +24,8 @@
 
 public abstract class CompositeDataType extends DataType {
     public static final String IDL_REPO_STRING = "IDL:";
-    public static final String IDL_VERSION = ":1.0";
+    public static final String IDL_VERSION = ":1.0";
+    public static final String MODULE_SEPERATOR = "::";
 
 	protected String id;
 	protected String name;
@@ -33,7 +34,7 @@
 
     public String getId() {
         if (id==null)
-            id = IDL_REPO_STRING + module.replaceAll("::", "/") + name + IDL_VERSION;
+            id = IDL_REPO_STRING + module.replaceAll(MODULE_SEPERATOR, "/") + name + IDL_VERSION;
         return id;
     }
 
Index: modules/corba/src/org/apache/axis2/corba/idl/parser/IDLVisitor.java
===================================================================
--- modules/corba/src/org/apache/axis2/corba/idl/parser/IDLVisitor.java	(revision 614165)
+++ modules/corba/src/org/apache/axis2/corba/idl/parser/IDLVisitor.java	(working copy)
@@ -18,6 +18,8 @@
     private static final Log log = LogFactory.getLog(IDLVisitor.class);
     private IDL idl = null;
     private String module = "";
+    private String moduleForInnerTypes = null;
+    private static final String INNERTYPE_SUFFIX = "Package";
 
     public IDL getIDL() {
         return idl;
@@ -68,7 +70,7 @@
                 }
 
                 case IDLTokenTypes.LITERAL_typedef: {
-                    visitAndAddTypedefs(node);
+                    visitAndAddTypedefs(node, module);
                     break;
                 }
 
@@ -168,16 +170,40 @@
         Interface intf = new Interface();
         intf.setModule(module);
         AST interfaceNode = node.getFirstChild();
-        intf.setName(interfaceNode.toString());
+        String interfaceName = interfaceNode.toString();
+        intf.setName(interfaceName);
+        moduleForInnerTypes = module + interfaceName + INNERTYPE_SUFFIX + CompositeDataType.MODULE_SEPERATOR;
         AST node2 = interfaceNode.getNextSibling();
         while (node2 != null) {
             switch (node2.getType()) {
             case IDLTokenTypes.LITERAL_struct:
+                Struct innerStruct = visitStruct(node2);
+                innerStruct.setModule(moduleForInnerTypes);
+                idl.addType(innerStruct);
+                break;
+            case IDLTokenTypes.LITERAL_valuetype:
+                log.error("Unsupported IDL token " + node2);
+                // CORBA 3.O spec does not support this
+                break;
             case IDLTokenTypes.LITERAL_exception:
-            case IDLTokenTypes.LITERAL_const:
+                Struct innerEx = visitException(node2);
+                innerEx.setModule(moduleForInnerTypes);
+                idl.addType(innerEx);
+                break;
             case IDLTokenTypes.LITERAL_enum:
+                EnumType innerEnum = visitEnum(node2);
+                innerEnum.setModule(moduleForInnerTypes);
+                idl.addType(innerEnum);
+                break;
             case IDLTokenTypes.LITERAL_union:
+                UnionType innerUnion = visitUnion(node2);
+                innerUnion.setModule(moduleForInnerTypes);
+                idl.addType(innerUnion);
+                break;
             case IDLTokenTypes.LITERAL_typedef:
+                visitAndAddTypedefs(node2, moduleForInnerTypes);
+                break;
+            case IDLTokenTypes.LITERAL_const:
                 log.error("Unsupported IDL token " + node2);
                 break;
             case IDLTokenTypes.LITERAL_attribute:
@@ -199,6 +225,7 @@
             }
             node2 = node2.getNextSibling();
         }
+        moduleForInnerTypes = null;
         return intf;
     }
 
@@ -289,6 +316,12 @@
                 }
             }
 
+            if (dataType==null && moduleForInnerTypes!=null) {
+                if (!typeName.startsWith(module)) {
+                    dataType = (DataType) idl.getCompositeDataTypes().get(moduleForInnerTypes + typeName);
+                }
+            }
+
             if (dataType==null)
                 dataType = (DataType) idl.getCompositeDataTypes().get(typeName);
         }
@@ -303,7 +336,7 @@
         String typeName = node.getText();
         AST memberTypeNodeChild = node.getFirstChild();
         while(memberTypeNodeChild!=null) {
-            typeName = typeName + "::" + memberTypeNodeChild.toString();
+            typeName = typeName + CompositeDataType.MODULE_SEPERATOR + memberTypeNodeChild.toString();
             memberTypeNodeChild = memberTypeNodeChild.getNextSibling();
         }
         return typeName;
@@ -312,8 +345,8 @@
     public void setModule(String module) {
         if (module==null || module.length()<1)
             module = "";
-        else if (!module.endsWith("::"))
-            module += "::";
+        else if (!module.endsWith(CompositeDataType.MODULE_SEPERATOR))
+            module += CompositeDataType.MODULE_SEPERATOR;
         this.module = module;
     }
 
@@ -364,7 +397,7 @@
         return unionType;
     }
 
-    private void visitAndAddTypedefs(AST node) {
+    private void visitAndAddTypedefs(AST node, String moduleName) {
         AST typedefNode = node.getFirstChild();
 
         DataType dataType;
@@ -388,7 +421,7 @@
                 int i = 1;
                 while(dimensionNode!=null) {
                     ArrayType temp = new ArrayType();
-                    temp.setElementModule(module);
+                    temp.setElementModule(moduleName);
                     temp.setElementName(typedefName);
                     temp.setDepth(i);
                     i++;
@@ -408,7 +441,7 @@
             }
             typedef = new Typedef();
             typedef.setDataType(dataType);
-            typedef.setModule(module);
+            typedef.setModule(moduleName);
             typedef.setName(typedefName);
             idl.addType(typedef);
             typedefNameNode = typedefNameNode.getNextSibling();
