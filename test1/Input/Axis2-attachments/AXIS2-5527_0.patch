Index: modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSListener.java
===================================================================
--- modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSListener.java	(revision 780227)
+++ modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSListener.java	(working copy)
@@ -17,6 +17,7 @@
 
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
+import org.apache.axis2.util.JavaUtils;
 import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.description.AxisService;
@@ -161,6 +162,12 @@
         
         ServiceTaskManager stm = JMSUtils.createTaskManagerForService(cf, service, workerPool);
         stm.setJmsMessageReceiver(new JMSMessageReceiver(this, cf, endpoint));
+        stm.setJmsConnectionFactory(cf);
+        // only set the transaction manager if it enabled the jta transaction
+        Parameter jtaTransaction = service.getParameter(BaseConstants.JTA_TRANSACTION);
+        if ((jtaTransaction != null) && (JavaUtils.isTrueExplicitly(jtaTransaction.getValue()))){
+            stm.setTransactionConfiguration(service.getAxisConfiguration().getTransactionConfiguration());
+        }
         stm.start();
         serviceNameToSTMMap.put(service.getName(), stm);
 
Index: modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSMessageSender.java
===================================================================
--- modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSMessageSender.java	(revision 780227)
+++ modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSMessageSender.java	(working copy)
@@ -108,6 +108,7 @@
 
         Boolean jtaCommit    = getBooleanProperty(msgCtx, BaseConstants.JTA_COMMIT_AFTER_SEND);
         Boolean rollbackOnly = getBooleanProperty(msgCtx, BaseConstants.SET_ROLLBACK_ONLY);
+        Boolean jtaTransaction = getBooleanProperty(msgCtx, BaseConstants.JTA_TRANSACTION);
         Boolean persistent   = getBooleanProperty(msgCtx, JMSConstants.JMS_DELIVERY_MODE);
         Integer priority     = getIntegerProperty(msgCtx, JMSConstants.JMS_PRIORITY);
         Integer timeToLive   = getIntegerProperty(msgCtx, JMSConstants.JMS_TIME_TO_LIVE);
@@ -202,7 +203,7 @@
                     }
                 }
 
-            } else {
+            } else if (!jtaTransaction) {
                 try {
                     if (session.getTransacted()) {
                         if (sendingSuccessful && (rollbackOnly == null || !rollbackOnly)) {
Index: modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSConnectionFactory.java
===================================================================
--- modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSConnectionFactory.java	(revision 780227)
+++ modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSConnectionFactory.java	(working copy)
@@ -49,24 +49,24 @@
     private static final Log log = LogFactory.getLog(JMSConnectionFactory.class);
 
     /** The name used for the connection factory definition within Axis2 */
-    private String name = null;
+    protected String name = null;
     /** The list of parameters from the axis2.xml definition */
-    private Hashtable<String, String> parameters = new Hashtable<String, String>();
+    protected Hashtable<String, String> parameters = new Hashtable<String, String>();
 
     /** The cached InitialContext reference */
-    private Context context = null;
+    protected Context context = null;
     /** The JMS ConnectionFactory this definition refers to */
-    private ConnectionFactory conFactory = null;
+    protected ConnectionFactory conFactory = null;
     /** The shared JMS Connection for this JMS connection factory */
-    private Connection sharedConnection = null;
+    protected Connection sharedConnection = null;
     /** The shared JMS Session for this JMS connection factory */
-    private Session sharedSession = null;
+    protected Session sharedSession = null;
     /** The shared JMS MessageProducer for this JMS connection factory */
-    private MessageProducer sharedProducer = null;
+    protected MessageProducer sharedProducer = null;
     /** The Shared Destination */
-    private Destination sharedDestination = null;
+    protected Destination sharedDestination = null;
     /** The shared JMS connection for this JMS connection factory */
-    private int cacheLevel = JMSConstants.CACHE_CONNECTION;
+    protected int cacheLevel = JMSConstants.CACHE_CONNECTION;
 
     /**
      * Digest a JMS CF definition from an axis2.xml 'Parameter' and construct
@@ -88,6 +88,17 @@
             parameters.put(p.getName(), (String) p.getValue());
         }
 
+        loadDetails();
+    }
+
+    public JMSConnectionFactory(Map<String,String> prop){
+        for (String key: prop.keySet()){
+            parameters.put(key,prop.get(key));
+        }
+        loadDetails();
+    }
+
+    protected void loadDetails() {
         digestCacheLevel();
         try {
             context = new InitialContext(parameters);
@@ -176,6 +187,14 @@
     public Destination getDestination(String name) {
         try {
             return JMSUtils.lookup(context, Destination.class, name);
+        } catch (NameNotFoundException e) {
+            try {
+                return JMSUtils.lookup(context, Destination.class,
+                        (JMSConstants.DESTINATION_TYPE_TOPIC.equals(parameters.get(JMSConstants.PARAM_DEST_TYPE)) ?
+                                "dynamicTopics/" : "dynamicQueues/") + name);
+            } catch (NamingException x) {
+                handleException("Cannot locate destination : " + name, e);
+            }
         } catch (NamingException e) {
             handleException("Unknown JMS Destination : " + name + " using : " + parameters, e);
         }
@@ -190,7 +209,7 @@
         return parameters.get(JMSConstants.PARAM_REPLY_DESTINATION);
     }
 
-    private void handleException(String msg, Exception e) {
+    protected void handleException(String msg, Exception e) {
         log.error(msg, e);
         throw new AxisJMSException(msg, e);
     }
@@ -239,7 +258,7 @@
      * Is a session transaction requested from users of this JMS CF?
      * @return session transaction required by the clients of this?
      */
-    private boolean isSessionTransacted() {
+    protected boolean isSessionTransacted() {
         return parameters.get(JMSConstants.PARAM_SESSION_TRANSACTED) == null ||
             Boolean.valueOf(parameters.get(JMSConstants.PARAM_SESSION_TRANSACTED));
     }
@@ -248,7 +267,7 @@
      * Create a new Connection
      * @return a new Connection
      */
-    private Connection createConnection() {
+    protected Connection createConnection() {
 
         Connection connection = null;
         try {
@@ -274,13 +293,13 @@
      * @param connection Connection to use
      * @return A new Session
      */
-    private Session createSession(Connection connection) {
+    protected Session createSession(Connection connection) {
         try {
             if (log.isDebugEnabled()) {
                 log.debug("Creating a new JMS Session from JMS CF : " + name);
             }
             return JMSUtils.createSession(
-                connection, isSessionTransacted(), Session.AUTO_ACKNOWLEDGE, isJmsSpec11(), isQueue());
+                connection, isSessionTransacted(), Session.SESSION_TRANSACTED, isJmsSpec11(), isQueue());
 
         } catch (JMSException e) {
             handleException("Error creating JMS session from JMS CF : " + name, e);
@@ -294,7 +313,7 @@
      * @param destination Destination to be used
      * @return a new MessageProducer
      */
-    private MessageProducer createProducer(Session session, Destination destination) {
+    protected MessageProducer createProducer(Session session, Destination destination) {
         try {
             if (log.isDebugEnabled()) {
                 log.debug("Creating a new JMS MessageProducer from JMS CF : " + name);
@@ -354,7 +373,7 @@
      * Get a new Connection or shared Connection from this JMS CF
      * @return new or shared Connection from this JMS CF
      */
-    private Connection getSharedConnection() {
+    protected Connection getSharedConnection() {
         if  (sharedConnection == null) {
             sharedConnection = createConnection();
             if (log.isDebugEnabled()) {
@@ -368,7 +387,7 @@
      * Get a shared Session from this JMS CF
      * @return shared Session from this JMS CF
      */
-    private Session getSharedSession() {
+    protected Session getSharedSession() {
         if (sharedSession == null) {
             sharedSession = createSession(getSharedConnection());
             if (log.isDebugEnabled()) {
@@ -382,7 +401,7 @@
      * Get a shared MessageProducer from this JMS CF
      * @return shared MessageProducer from this JMS CF
      */
-    private MessageProducer getSharedProducer() {
+    protected MessageProducer getSharedProducer() {
         if (sharedProducer == null) {
             sharedProducer = createProducer(getSharedSession(), sharedDestination);
             if (log.isDebugEnabled()) {
Index: modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSUtils.java
===================================================================
--- modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSUtils.java	(revision 780227)
+++ modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSUtils.java	(working copy)
@@ -584,6 +584,7 @@
     public static ServiceTaskManager createTaskManagerForService(JMSConnectionFactory jcf,
         AxisService service, WorkerPool workerPool) {
 
+        
         String name = service.getName();
         Map<String, String> svc = getServiceStringParameters(service.getParameters());
         Map<String, String> cf  = jcf.getParameters();
Index: modules/jms/src/main/java/org/apache/axis2/transport/jms/ServiceTaskManager.java
===================================================================
--- modules/jms/src/main/java/org/apache/axis2/transport/jms/ServiceTaskManager.java	(revision 780227)
+++ modules/jms/src/main/java/org/apache/axis2/transport/jms/ServiceTaskManager.java	(working copy)
@@ -21,6 +21,8 @@
 
 import org.apache.axis2.transport.base.BaseConstants;
 import org.apache.axis2.transport.base.threads.WorkerPool;
+import org.apache.axis2.transaction.TransactionConfiguration;
+import org.apache.axis2.AxisFault;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -29,9 +31,7 @@
 import javax.naming.InitialContext;
 import javax.naming.Context;
 import javax.naming.NamingException;
-import javax.transaction.UserTransaction;
-import javax.transaction.NotSupportedException;
-import javax.transaction.SystemException;
+import javax.transaction.*;
 import java.util.*;
 
 /**
@@ -138,6 +138,10 @@
     /** The JMS Connection shared between multiple polling tasks - when enabled (reccomended) */
     private Connection sharedConnection = null;
 
+    private JMSConnectionFactory jmsConnectionFactory = null;
+
+    private TransactionConfiguration transactionConfiguration;
+
     /**
      * Start or re-start the Task Manager by shutting down any existing worker tasks and
      * re-creating them. However, if this is STM is PAUSED, a start request is ignored.
@@ -386,17 +390,29 @@
                 while (isActive() &&
                     (getMaxMessagesPerTask() < 0 || messageCount < getMaxMessagesPerTask()) &&
                     (getConcurrentConsumers() == 1 || idleExecutionCount < getIdleTaskExecutionLimit())) {
-
                     UserTransaction ut = null;
-                    try {
-                        if (transactionality == BaseConstants.TRANSACTION_JTA) {
-                            ut = getUserTransaction();
+                    if (transactionConfiguration == null) {
+                        try {
+                            if (transactionality == BaseConstants.TRANSACTION_JTA) {
+                                ut = getUserTransaction();
+                                ut.begin();
+                            }
+                        } catch (NotSupportedException e) {
+                            handleException("Listener Task is already associated with a transaction", e);
+                        } catch (SystemException e) {
+                            handleException("Error starting a JTA transaction", e);
+                        }
+                    } else {
+                        try {
+                            ut = transactionConfiguration.getUserTransaction();
                             ut.begin();
+                        } catch (AxisFault axisFault) {
+                            log.error("Can not get the transaction manager");
+                        } catch (SystemException e) {
+                            log.error("Can not start the transaction");
+                        } catch (NotSupportedException e) {
+                            log.error("Can not start the transaction");
                         }
-                    } catch (NotSupportedException e) {
-                        handleException("Listener Task is already associated with a transaction", e);
-                    } catch (SystemException e) {
-                        handleException("Error starting a JTA transaction", e);
                     }
 
                     // Get a message by polling, or receive null
@@ -426,6 +442,15 @@
                     } else {
                         idle = true;
                         idleExecutionCount++;
+                        // if we don't have received any messages then we need to roll back the transaction.
+                        // a new transaction will be started when the thread calls for the next time.
+                        if (transactionConfiguration != null){
+                            try {
+                                ut.rollback();
+                            } catch (SystemException e) {
+                                handleException("Can not rollback the transaction which was started to receive messages", e);
+                            }
+                        }
                     }
                 }
 
@@ -467,8 +492,14 @@
             // get a new connection, session and consumer to prevent a conflict.
             // If idle, it means we can re-use what we already have 
             if (consumer == null) {
-                connection = getConnection();
-                session = getSession();
+                connection = jmsConnectionFactory.createConnection();
+                try {
+                    connection.setExceptionListener(this);
+                    connection.start();
+                } catch (JMSException e) {
+                    handleException("Can not start the connection ", e);                                                                
+                }
+                session = jmsConnectionFactory.createSession(connection);
                 consumer = getMessageConsumer();
                 if (log.isDebugEnabled()) {
                     log.debug("Preparing a Connection, Session and Consumer to read messages");
@@ -529,28 +560,28 @@
                 closeConsumer(false);
 
                 // if session was transacted, commit it or rollback
-                try {
-                    if (session.getTransacted()) {
-                        if (commitOrAck) {
-                            session.commit();
-                            if (log.isDebugEnabled()) {
-                                log.debug("Session for message : " + messageId + " committed");
+                if (ut == null) {
+                    try {
+                        if (session.getTransacted()) {
+                            if (commitOrAck) {
+                                session.commit();
+                                if (log.isDebugEnabled()) {
+                                    log.debug("Session for message : " + messageId + " committed");
+                                }
+                            } else {
+                                session.rollback();
+                                if (log.isDebugEnabled()) {
+                                    log.debug("Session for message : " + messageId + " rolled back");
+                                }
                             }
-                        } else {
-                            session.rollback();
-                            if (log.isDebugEnabled()) {
-                                log.debug("Session for message : " + messageId + " rolled back");
-                            }
                         }
+                    } catch (JMSException e) {
+                        logError("Error " + (commitOrAck ? "committing" : "rolling back") +
+                                " local session txn for message : " + messageId, e);
                     }
-                } catch (JMSException e) {
-                    logError("Error " + (commitOrAck ? "committing" : "rolling back") +
-                        " local session txn for message : " + messageId, e);
-                }
-
-                // if a JTA transaction was being used, commit it or rollback
-                try {
-                    if (ut != null) {
+                } else {
+                    // if a JTA transaction was being used, commit it or rollback
+                    try {
                         if (commitOrAck) {
                             ut.commit();
                             if (log.isDebugEnabled()) {
@@ -562,12 +593,12 @@
                                 log.debug("JTA txn for message : " + messageId + " rolled back");
                             }
                         }
+                    } catch (Exception e) {
+                        logError("Error " + (commitOrAck ? "committing" : "rolling back") +
+                                " JTA txn for message : " + messageId + " from the session", e);
                     }
-                } catch (Exception e) {
-                    logError("Error " + (commitOrAck ? "committing" : "rolling back") +
-                        " JTA txn for message : " + messageId + " from the session", e);
                 }
-
+                
                 closeSession(false);
                 closeConnection();
             }
@@ -1202,4 +1233,20 @@
     public void setServiceTaskManagerState(int serviceTaskManagerState) {
         this.serviceTaskManagerState = serviceTaskManagerState;
     }
+
+    public JMSConnectionFactory getJmsConnectionFactory() {
+        return jmsConnectionFactory;
+    }
+
+    public void setJmsConnectionFactory(JMSConnectionFactory jmsConnectionFactory) {
+        this.jmsConnectionFactory = jmsConnectionFactory;
+    }
+
+    public TransactionConfiguration getTransactionConfiguration() {
+        return transactionConfiguration;
+    }
+
+    public void setTransactionConfiguration(TransactionConfiguration transactionConfiguration) {
+        this.transactionConfiguration = transactionConfiguration;
+    }
 }
Index: modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSConstants.java
===================================================================
--- modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSConstants.java	(revision 780227)
+++ modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSConstants.java	(working copy)
@@ -270,4 +270,6 @@
     /** The JMSXGroupSeq property */
     public static final String JMSX_GROUP_SEQ = "JMSXGroupSeq";
 
+    public static final String JMS_CONNECTION_FACTORY_CLASS = "jmsConnectionFactoryClass";
+
 }
Index: modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSSender.java
===================================================================
--- modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSSender.java	(revision 780227)
+++ modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSSender.java	(working copy)
@@ -94,6 +94,7 @@
         JMSOutTransportInfo jmsOut = null;
         JMSMessageSender messageSender = null;
 
+
         if (targetAddress != null) {
 
             jmsOut = new JMSOutTransportInfo(targetAddress);
@@ -353,8 +354,8 @@
             }
 
             if (!useBytesMessage) {
-                TextMessage txtMsg = session.createTextMessage();
-                txtMsg.setText(sw.toString());
+                TextMessage txtMsg = session.createTextMessage(sw.toString());
+//                txtMsg.setText();
                 message = txtMsg;
             }
             
Index: modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSConnectionFactoryManager.java
===================================================================
--- modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSConnectionFactoryManager.java	(revision 780227)
+++ modules/jms/src/main/java/org/apache/axis2/transport/jms/JMSConnectionFactoryManager.java	(working copy)
@@ -19,6 +19,8 @@
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
 
 import javax.jms.JMSException;
 import javax.naming.Context;
@@ -44,6 +46,11 @@
         new HashMap<String,JMSConnectionFactory>();
 
     /**
+     * set the default value to JMSConnectionFactory
+     */
+    private String jmsConnectionFactoryClassName = JMSConnectionFactory.class.getName();
+
+    /**
      * Construct a Connection factory manager for the JMS transport sender or receiver
      * @param trpInDesc
      */
@@ -60,11 +67,15 @@
     private void loadConnectionFactoryDefinitions(ParameterInclude trpDesc) {
 
         for (Parameter p : trpDesc.getParameters()) {
-            try {
-                JMSConnectionFactory jmsConFactory = new JMSConnectionFactory(p);
-                connectionFactories.put(jmsConFactory.getName(), jmsConFactory);
-            } catch (AxisJMSException e) {
-                log.error("Error setting up connection factory : " + p.getName(), e);
+            if (p.getName().equals(JMSConstants.JMS_CONNECTION_FACTORY_CLASS)) {
+                jmsConnectionFactoryClassName = (String) p.getValue();
+            } else {
+                try {
+                    JMSConnectionFactory jmsConFactory = getJMSConnectionFactory(Parameter.class, p);
+                    connectionFactories.put(jmsConFactory.getName(), jmsConFactory);
+                } catch (AxisJMSException e) {
+                    log.error("Error setting up connection factory : " + p.getName(), e);
+                }
             }
         }
     }
@@ -110,9 +121,30 @@
                 return cf;
             }
         }
-        return null;
+        return getJMSConnectionFactory(Map.class,props);
+
     }
 
+    private JMSConnectionFactory getJMSConnectionFactory(Class type, Object param) {
+        try {
+            Class jmsConnectionFactoryClass = Class.forName(jmsConnectionFactoryClassName);
+            Constructor constructor = jmsConnectionFactoryClass.getConstructor(new Class[]{type});
+            return (JMSConnectionFactory) constructor.newInstance(new Object[]{param});
+        } catch (ClassNotFoundException e) {
+            throw new RuntimeException("Jms connection factory class " + jmsConnectionFactoryClassName
+                    + " can not found", e);
+        } catch (NoSuchMethodException e) {
+            throw new RuntimeException("A constructor which takes a Map as an argument can not found in "
+                    + jmsConnectionFactoryClassName, e);
+        } catch (InvocationTargetException e) {
+            throw new RuntimeException(jmsConnectionFactoryClassName + " can not be instantiated ", e);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException(jmsConnectionFactoryClassName + " can not be instantiated ", e);
+        } catch (InstantiationException e) {
+            throw new RuntimeException(jmsConnectionFactoryClassName + " can not be instantiated ", e);
+        }
+    }
+
     /**
      * Compare two values preventing NPEs
      */
Index: modules/base/src/main/java/org/apache/axis2/transport/base/BaseConstants.java
===================================================================
--- modules/base/src/main/java/org/apache/axis2/transport/base/BaseConstants.java	(revision 780227)
+++ modules/base/src/main/java/org/apache/axis2/transport/base/BaseConstants.java	(working copy)
@@ -131,5 +131,7 @@
     /** A message level property indicating a request to rollback the transaction associated with the message */
     public static final String SET_ROLLBACK_ONLY = "SET_ROLLBACK_ONLY";
     /** A message level property indicating a commit is required after the next immidiate send over a transport */
-    public static final String JTA_COMMIT_AFTER_SEND = "JTA_COMMIT_AFTER_SEND";    
+    public static final String JTA_COMMIT_AFTER_SEND = "JTA_COMMIT_AFTER_SEND";
+
+    public static final String JTA_TRANSACTION = "JTA_TRANSACTION";    
 }
