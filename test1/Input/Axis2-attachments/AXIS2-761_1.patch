Index: modules/integration/project.xml
===================================================================
--- modules/integration/project.xml	(revision 412455)
+++ modules/integration/project.xml	(working copy)
@@ -144,6 +144,14 @@
             </properties>
         </dependency>
         <dependency>
+            <groupId>jakarta-httpcore</groupId>
+            <artifactId>jakarta-httpcore</artifactId>
+            <version>${jakarta.httpcore.version}</version>
+            <properties>
+                <module>true</module>
+            </properties>
+        </dependency> 
+        <dependency>
             <groupId>${stax.impl.groupid}</groupId>
             <artifactId>${stax.impl.artifactid}</artifactId>
             <version>${stax.impl.version}</version>
Index: modules/core/conf/axis2.xml
===================================================================
--- modules/core/conf/axis2.xml	(revision 412455)
+++ modules/core/conf/axis2.xml	(working copy)
@@ -52,10 +52,29 @@
     <!-- ================================================= -->
     <transportReceiver name="http"
                        class="org.apache.axis2.transport.http.SimpleHTTPServer">
-        <parameter name="port" locked="false">6060</parameter>
-        <!--If you want to give your own host address for EPR generation-->
-        <!--uncommet following paramter , and set as you required.-->
-        <!--<parameter name="hostname" locked="false">http://myApp.com/ws</parameter>-->
+        <parameter name="port" locked="false">8080</parameter>
+    <!-- Here is the complete list of supported parameters (see example settings further below):
+        port: the port to listen on (default 8080)
+        hostname:  if non-null, url prefix used in reply-to endpoint references                                 (default null)
+        originServer:  value of http Server header in outgoing messages                                         (default "Simple-Server/1.1")
+        requestTimeout:  value in millis of time that requests can wait for data                                (default 20000)
+        requestTcpNoDelay:  true to maximize performance and minimize latency                                   (default true)
+                            false to minimize bandwidth consumption by combining segments  
+        requestCoreThreadPoolSize:  number of threads available for request processing (unless queue fills up)  (default 25)
+        requestMaxThreadPoolSize:  number of threads available for request processing if queue fills us         (default 150)
+                                   note that default queue never fills up:  see HttpFactory
+        threadKeepAliveTime:  time to keep threads in excess of core size alive while inactive                  (default 180)
+                              note that no such threads can exist with default unbounded request queue
+        threadKeepAliveTimeUnit:  TimeUnit of value in threadKeepAliveTime (default SECONDS)                    (default SECONDS)
+    -->
+        <!-- <parameter name="hostname"                  locked="false">http://www.myApp.com/ws</parameter> -->
+        <!-- <parameter name="originServer"              locked="false">My-Server/1.1</parameter>           -->
+        <!-- <parameter name="requestTimeout"            locked="false">10000</parameter>                   -->
+        <!-- <parameter name="requestTcpNoDelay"         locked="false">false</parameter>                   -->
+        <!-- <parameter name="requestCoreThreadPoolSize" locked="false">50</parameter>                      -->
+        <!-- <parameter name="RequestMaxThreadPoolSize"  locked="false">100</parameter>                     -->
+        <!-- <parameter name="threadKeepAliveTime"       locked="false">240000</parameter>                  -->
+        <!-- <parameter name="threadKeepAliveTimeUnit"   locked="false">MILLISECONDS</parameter>            -->
     </transportReceiver>
 
     <!--Uncomment if you want to have SMTP transport support-->
Index: modules/core/project.xml
===================================================================
--- modules/core/project.xml	(revision 412455)
+++ modules/core/project.xml	(working copy)
@@ -105,6 +105,14 @@
               <module>true</module>
           </properties>
        </dependency>      
+        <dependency>
+            <groupId>jakarta-httpcore</groupId>
+            <artifactId>jakarta-httpcore</artifactId>
+            <version>${jakarta.httpcore.version}</version>
+            <properties>
+                <module>true</module>
+            </properties>
+        </dependency> 
         <!--added this to support to keep WSDL information in AxisService-->
          <dependency>
             <groupId>org.apache.ws.commons</groupId>
Index: modules/core/src/org/apache/axis2/transport/http/HTTPWorkerFactory.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/HTTPWorkerFactory.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/HTTPWorkerFactory.java	(revision 0)
@@ -0,0 +1,52 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http;
+
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.transport.http.server.Worker;
+import org.apache.axis2.transport.http.server.WorkerFactory;
+
+public class HTTPWorkerFactory implements WorkerFactory {
+
+    final ConfigurationContext configurationContext;
+    
+    public HTTPWorkerFactory(final ConfigurationContext configurationContext) {
+        super();
+        if (configurationContext == null) {
+            throw new IllegalArgumentException("Configuration context may not be null");
+        }
+        this.configurationContext = configurationContext;
+    }
+    
+    public Worker newWorker() {
+        return new HTTPWorker(this.configurationContext);
+    }
+    
+}
Index: modules/core/src/org/apache/axis2/transport/http/AxisServlet.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/AxisServlet.java	(revision 412455)
+++ modules/core/src/org/apache/axis2/transport/http/AxisServlet.java	(working copy)
@@ -63,7 +63,7 @@
 
     private transient ListingAgent agent;
     public static String SERVICE_PATH;
-    private String conetxtPath;
+    private String contextPath;
 
 
     protected MessageContext createAndSetInitialParamsToMsgCtxt(MessageContext msgContext, HttpServletResponse httpServletResponse,
@@ -296,20 +296,20 @@
         if (port == null) {
             port = "8080";
         }
-        if (conetxtPath == null) {
+        if (contextPath == null) {
             // HACK ALERT!!! - Is there a better way to get the webapp name?
             try {
                 String[] array = servletConfig.getServletContext().getResource("/").toString().split("/");
-                conetxtPath = array[array.length - 1];
-                configContext.setContextPath(conetxtPath);
+                contextPath = array[array.length - 1];
+                configContext.setContextPath(contextPath);
             } catch (Exception e) {
             }
-            if (conetxtPath == null) {
-                conetxtPath = "axis2";
+            if (contextPath == null) {
+                contextPath = "axis2";
             }
         }
         return new EndpointReference("http://" + ip + ":" + port + '/' +
-                conetxtPath + "/" + SERVICE_PATH + "/" + serviceName);
+                contextPath + "/" + SERVICE_PATH + "/" + serviceName);
     }
 
     protected MessageContext createMessageContext(HttpServletRequest req,
Index: modules/core/src/org/apache/axis2/transport/http/HTTPWorker.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/HTTPWorker.java	(revision 412455)
+++ modules/core/src/org/apache/axis2/transport/http/HTTPWorker.java	(working copy)
@@ -14,44 +14,63 @@
 * limitations under the License.
 */
 
-
 package org.apache.axis2.transport.http;
 
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.SocketException;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Iterator;
+
+import javax.xml.namespace.QName;
+
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
-import org.apache.axis2.context.*;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.OperationContext;
+import org.apache.axis2.context.ServiceContext;
+import org.apache.axis2.context.ServiceGroupContext;
+import org.apache.axis2.context.SessionContext;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.Parameter;
+import org.apache.axis2.description.TransportInDescription;
 import org.apache.axis2.description.TransportOutDescription;
-import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.axis2.engine.AxisEngine;
 import org.apache.axis2.engine.DependencyManager;
 import org.apache.axis2.i18n.Messages;
-import org.apache.axis2.transport.http.server.HttpRequestHandler;
-import org.apache.axis2.transport.http.server.SimpleHttpServerConnection;
-import org.apache.axis2.transport.http.server.SimpleRequest;
-import org.apache.axis2.transport.http.server.SimpleResponse;
+import org.apache.axis2.transport.http.HTTPConstants;
+import org.apache.axis2.transport.http.HTTPTransportReceiver;
+import org.apache.axis2.transport.http.HTTPTransportUtils;
+import org.apache.axis2.transport.http.server.OutputBuffer;
+import org.apache.axis2.transport.http.server.HttpUtils;
+import org.apache.axis2.transport.http.server.Worker;
 import org.apache.axis2.util.UUIDGenerator;
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HttpVersion;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpEntityEnclosingRequest;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpVersion;
+import org.apache.http.MethodNotSupportedException;
+import org.apache.http.StatusLine;
+import org.apache.http.entity.ContentProducer;
+import org.apache.http.entity.EntityTemplate;
+import org.apache.http.entity.StringEntity;
 import org.apache.ws.commons.schema.XmlSchema;
 
-import javax.xml.namespace.QName;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.SocketException;
-import java.util.*;
-
-public class HTTPWorker implements HttpRequestHandler {
+public class HTTPWorker implements Worker {
 
     private static final Log log = LogFactory.getLog(HTTPWorker.class);
+    
     private ConfigurationContext configurationContext;
     // to store session object
-    private Hashtable sessionContextTable = new Hashtable();
+    private static Hashtable sessionContextTable = new Hashtable();
     private String contextPath = null;
     private String servicePath = null;
 
@@ -61,166 +80,147 @@
         servicePath = configurationContext.getServicePath();
     }
 
-    public boolean processRequest(final SimpleHttpServerConnection conn,
-                                  final SimpleRequest request)
-            throws IOException {
-        MessageContext msgContext = null;
-        SimpleResponse response = new SimpleResponse();
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-
+    public void service(final HttpRequest request, final HttpResponse response) 
+            throws HttpException, IOException {    
+        MessageContext msgContext = new MessageContext();
+        msgContext.setIncomingTransportName(Constants.TRANSPORT_HTTP);
         try {
             if (configurationContext == null) {
                 throw new AxisFault(Messages.getMessage("cannotBeNullConfigurationContext"));
             }
-            InputStream inStream = request.getBody();
-            TransportOutDescription transportOut =
-                    configurationContext.getAxisConfiguration().getTransportOut(
-                            new QName(Constants.TRANSPORT_HTTP));
-            String cookieID = request.getCookieID();
-
+            // Get relevant request parameters
+            HttpVersion ver = request.getRequestLine().getHttpVersion();
+            String uri = request.getRequestLine().getUri();
+            String method = request.getRequestLine().getMethod();
 
-            msgContext = new MessageContext();
-            msgContext.setIncomingTransportName(Constants.TRANSPORT_HTTP);
+            String soapAction = HttpUtils.getSoapAction(request);
+            String cookieID = HttpUtils.getCookieID(request);
+            
+            boolean chunked = false;
+
+            TransportOutDescription transportOut = configurationContext.getAxisConfiguration()
+                .getTransportOut(new QName(Constants.TRANSPORT_HTTP));
+            TransportInDescription transportIn = configurationContext.getAxisConfiguration()
+                .getTransportIn(new QName(Constants.TRANSPORT_HTTP));            
+        
+            // Configure message context
             msgContext.setConfigurationContext(configurationContext);
             if (configurationContext.getAxisConfiguration().isManageTransportSession()) {
                 SessionContext sessionContext = getSessionContext(cookieID);
                 msgContext.setSessionContext(sessionContext);
             }
-            msgContext.setTransportIn(configurationContext.getAxisConfiguration().getTransportIn(
-                    new QName(Constants.TRANSPORT_HTTP)));
+            msgContext.setTransportIn(transportIn);
             msgContext.setTransportOut(transportOut);
+            msgContext.setServiceGroupContextId(UUIDGenerator.getUUID());
             msgContext.setServerSide(true);
-
-            HttpVersion ver = request.getRequestLine().getHttpVersion();
-
-            if (ver == null) {
-                throw new AxisFault("HTTP version can not be Null");
-            }
-
-
-            if (HttpVersion.HTTP_1_0.equals(ver)) {
-//                httpVersion = HTTPConstants.HEADER_PROTOCOL_10;
-            } else if (HttpVersion.HTTP_1_1.equals(ver)) {
-//                httpVersion = HTTPConstants.HEADER_PROTOCOL_11;
-
-                /**
-                 * Transport Sender configuration via axis2.xml
-                 */
-                this.transportOutConfiguration(configurationContext, response);
-            } else {
-                throw new AxisFault("Unknown supported protocol version " + ver);
-            }
-
-            msgContext.setProperty(MessageContext.TRANSPORT_OUT, baos);
+            msgContext.setProperty(Constants.Configuration.TRANSPORT_IN_URL, uri);
 
             // set the transport Headers
-            msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, getHeaders(request));
-            msgContext.setServiceGroupContextId(UUIDGenerator.getUUID());
-
-            // This is way to provide access to the transport information to the transport Sender
-            msgContext.setProperty(Constants.OUT_TRANSPORT_INFO,
-                    new SimpleHTTPOutTransportInfo(response));
-            msgContext.setProperty(Constants.Configuration.TRANSPORT_IN_URL, request.getRequestLine().getUri());
-
-
-            String soapAction = null;
-
-            if (request.getFirstHeader(HTTPConstants.HEADER_SOAP_ACTION) != null) {
-                soapAction = request.getFirstHeader(HTTPConstants.HEADER_SOAP_ACTION).getValue();
+            HashMap headerMap = new HashMap();
+            Header[] headers = request.getAllHeaders();
+            for (int i = 0; i < headers.length; i++) {
+                headerMap.put(headers[i].getName(), headers[i].getValue());
+            }
+            msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, headerMap);
+
+            // Adjust version and content chunking based on the config
+            if (transportOut != null) {
+                Parameter p = transportOut.getParameter(HTTPConstants.PROTOCOL_VERSION);
+                if (p != null) {
+                    if (HTTPConstants.HEADER_PROTOCOL_10.equals(p.getValue())) {
+                        ver = HttpVersion.HTTP_1_0;
+                    }
+                }
+                if (ver.greaterEquals(HttpVersion.HTTP_1_1)) {
+                    p = transportOut.getParameter(HTTPConstants.HEADER_TRANSFER_ENCODING);
+                    if (p != null) {
+                        if (HTTPConstants.HEADER_TRANSFER_ENCODING_CHUNKED.equals(p.getValue())) {
+                            chunked = true;
+                        }
+                    }
+                }
             }
 
-            if (HTTPConstants.HEADER_GET.equals(request.getRequestLine().getMethod())) {
-                String uri = request.getRequestLine().getUri();
-                log.debug("HTTP GET:" + uri);
+            if (method.equals(HTTPConstants.HEADER_GET)) {
                 if (uri.equals("/favicon.ico")) {
-                    response.setStatusLine(request.getRequestLine().getHttpVersion(), 301, "Redirect");
+                    response.setStatusLine(new StatusLine(ver, 301, "Redirect"));
                     response.addHeader(new Header("Location", "http://ws.apache.org/favicon.ico"));
-                    conn.writeResponse(response);
-                    return true;
+                    return;
                 }
                 if (!uri.startsWith(contextPath)) {
-                    response.setStatusLine(request.getRequestLine().getHttpVersion(), 301, "Redirect");
+                    response.setStatusLine(new StatusLine(ver, 301, "Redirect"));
                     response.addHeader(new Header("Location", contextPath));
-                    conn.writeResponse(response);
-                    return true;
+                    return;
                 }
-
                 if (uri.indexOf("?") < 0) {
-                    if (!(uri.endsWith(contextPath))) {
-                        String serviceName = uri.replaceAll(contextPath, "");
+                    if (!(uri.endsWith(contextPath) || uri.endsWith(contextPath+"/"))) {
+                        String serviceName = uri.replaceAll(contextPath+"/", "");
                         if (serviceName.indexOf("/") < 0) {
-                            response.addHeader(new Header("Content-Type", "text/html"));
                             String res = HTTPTransportReceiver.printServiceHTML(serviceName, configurationContext);
-                            byte[] buf = res.getBytes();
-                            response.setBody(new ByteArrayInputStream(buf));
-                            conn.writeResponse(response);
-                            return true;
+                            StringEntity entity = new StringEntity(res);
+                            entity.setContentType("text/html");
+                            entity.setChunked(chunked);
+                            response.setEntity(entity);
+                            return;
                         }
                     }
                 }
                 if (uri.endsWith("?wsdl2")) {
                     String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.length() - 6);
                     HashMap services = configurationContext.getAxisConfiguration().getServices();
-                    AxisService service = (AxisService) services.get(serviceName);
+                    final AxisService service = (AxisService) services.get(serviceName);
                     if (service != null) {
-                        response.addHeader(new Header("Content-Type", "text/xml"));
-//                        String url = conn.getURL(uri.substring(1, uri.length() - 5));
-                        String url = conn.getURL("");
-                        int ipindex = url.indexOf("//");
-                        String ip = null;
-                        if (ipindex >= 0) {
-                            ip = url.substring(ipindex + 2, url.length());
-                            int seperatorIndex = ip.indexOf(":");
-                            if (seperatorIndex > 0) {
-                                ip = ip.substring(0, seperatorIndex);
+                        final String ip = HttpUtils.getIpAddress();
+                        EntityTemplate entity = new EntityTemplate(new ContentProducer() {
+
+                            public void writeTo(final OutputStream outstream) throws IOException {
+                                service.printWSDL2(outstream, ip, servicePath);
                             }
-                        }
-                        service.printWSDL2(baos, ip, servicePath);
-                        byte[] buf = baos.toByteArray();
-                        response.setBody(new ByteArrayInputStream(buf));
-                        conn.writeResponse(response);
-                        return true;
+                            
+                        });
+                        entity.setContentType("text/xml");
+                        entity.setChunked(chunked);
+                        response.setEntity(entity);
+                        return;
                     }
                 }
-
                 if (uri.endsWith("?wsdl")) {
                     String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.length() - 5);
                     HashMap services = configurationContext.getAxisConfiguration().getServices();
-                    AxisService service = (AxisService) services.get(serviceName);
+                    final AxisService service = (AxisService) services.get(serviceName);
                     if (service != null) {
-                        response.addHeader(new Header("Content-Type", "text/xml"));
-//                        String url = conn.getURL(uri.substring(1, uri.length() - 5));
-                        String url = conn.getURL("");
-                        int ipindex = url.indexOf("//");
-                        String ip = null;
-                        if (ipindex >= 0) {
-                            ip = url.substring(ipindex + 2, url.length());
-                            int seperatorIndex = ip.indexOf(":");
-                            if (seperatorIndex > 0) {
-                                ip = ip.substring(0, seperatorIndex);
+                        final String ip = HttpUtils.getIpAddress();
+                        EntityTemplate entity = new EntityTemplate(new ContentProducer() {
+
+                            public void writeTo(final OutputStream outstream) throws IOException {
+                                service.printWSDL(outstream, ip, servicePath);
                             }
-                        }
-                        service.printWSDL(baos, ip, servicePath);
-                        byte[] buf = baos.toByteArray();
-                        response.setBody(new ByteArrayInputStream(buf));
-                        conn.writeResponse(response);
-                        return true;
+                            
+                        });
+                        entity.setContentType("text/xml");
+                        entity.setChunked(chunked);
+                        response.setEntity(entity);
+                        return;
                     }
                 }
                 if (uri.endsWith("?xsd")) {
                     String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.length() - 4);
                     HashMap services = configurationContext.getAxisConfiguration().getServices();
-                    AxisService service = (AxisService) services.get(serviceName);
+                    final AxisService service = (AxisService) services.get(serviceName);
                     if (service != null) {
-                        response.addHeader(new Header("Content-Type", "text/xml"));
-                        service.printSchema(baos);
-                        byte[] buf = baos.toByteArray();
-                        response.setBody(new ByteArrayInputStream(buf));
-                        conn.writeResponse(response);
-                        return true;
+                        EntityTemplate entity = new EntityTemplate(new ContentProducer() {
+
+                            public void writeTo(final OutputStream outstream) throws IOException {
+                                service.printSchema(outstream);
+                            }
+                            
+                        });
+                        entity.setContentType("text/xml");
+                        entity.setChunked(chunked);
+                        response.setEntity(entity);
+                        return;
                     }
                 }
-
                 //cater for named xsds - check for the xsd name
                 if (uri.indexOf("?xsd=") > 0) {
                     String serviceName = uri.substring(uri.lastIndexOf("/") + 1, uri.lastIndexOf("?xsd="));
@@ -233,189 +233,124 @@
                         service.populateSchemaMappings();
                         //write out the correct schema
                         Hashtable schemaTable = service.getSchemaMappingTable();
-                        XmlSchema schema = (XmlSchema) schemaTable.get(schemaName);
+                        final XmlSchema schema = (XmlSchema)schemaTable.get(schemaName);
                         //schema found - write it to the stream
                         if (schema != null) {
-                            response.addHeader(new Header("Content-Type", "text/xml"));
-                            schema.write(baos);
-                            byte[] buf = baos.toByteArray();
-                            response.setBody(new ByteArrayInputStream(buf));
-                            conn.writeResponse(response);
+                            EntityTemplate entity = new EntityTemplate(new ContentProducer() {
 
+                                public void writeTo(final OutputStream outstream) throws IOException {
+                                    schema.write(outstream);
+                                }
+                                
+                            });
+                            entity.setContentType("text/xml");
+                            entity.setChunked(chunked);
+                            response.setEntity(entity);
+                            return;
                         } else {
                             // no schema available by that name  - send 404
-                            response.setStatusLine(
-                                    request.getRequestLine().getHttpVersion(),
-                                    404, "Schema Not Found!");
+                            response.setStatusLine(new StatusLine(ver, 404, "Schema Not Found!"));
+                            return;
                         }
-
-                        return true;
-
                     }
                 }
-                // It is GET handle the Get request
-                boolean processed = HTTPTransportUtils.processHTTPGetRequest(
-                        msgContext, baos,
-                        soapAction, request.getRequestLine().getUri(),
-                        configurationContext,
-                        HTTPTransportReceiver.getGetRequestParameters(
-                                request.getRequestLine().getUri()));
 
-                if (!processed) {
-                    response.setStatusLine(request.getRequestLine().getHttpVersion(), 200, "OK");
-                    response.addHeader(new Header("Content-Type", "text/html"));
-                    response.setBodyString(
-                            HTTPTransportReceiver.getServicesHTML(configurationContext));
-                    setResponseHeaders(conn, request, response, 0, msgContext);
-                    conn.writeResponse(response);
+                OutputBuffer outbuffer = new OutputBuffer(); 
+                msgContext.setProperty(MessageContext.TRANSPORT_OUT, outbuffer);
+                msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outbuffer);
 
-                    return true;
-                }
+                // deal with GET request
+                boolean processed = HTTPTransportUtils.processHTTPGetRequest(
+                        msgContext, 
+                        outbuffer.getOutputStream(), 
+                        soapAction, 
+                        uri,
+                        configurationContext,
+                        HTTPTransportReceiver.getGetRequestParameters(uri));
+                
+                if (processed) {
+                    outbuffer.setChunked(chunked);
+                    response.setEntity(outbuffer);
+                } else {
+                    response.setStatusLine(new StatusLine(ver, 200, "OK"));
+                    String s = HTTPTransportReceiver.getServicesHTML(configurationContext);
+                    StringEntity entity = new StringEntity(s);
+                    entity.setContentType("text/html");
+                    entity.setChunked(chunked);
+                    response.setEntity(entity);
+                }
+                
+            } else if (method.equals(HTTPConstants.HEADER_POST)) {
+                // deal with POST request
+
+                OutputBuffer outbuffer = new OutputBuffer(); 
+                msgContext.setProperty(MessageContext.TRANSPORT_OUT, outbuffer);
+                msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outbuffer);
+
+                HttpEntity inentity = ((HttpEntityEnclosingRequest) request).getEntity();
+                String contenttype = null;
+                if (inentity.getContentType() != null) {
+                    contenttype = inentity.getContentType().getValue();
+                }
+                HTTPTransportUtils.processHTTPPostRequest(
+                        msgContext, 
+                        inentity.getContent(), 
+                        outbuffer.getOutputStream(),
+                        contenttype, 
+                        soapAction, 
+                        uri);
+                
+                outbuffer.setChunked(chunked);
+                response.setEntity(outbuffer);
+                
             } else {
-                ByteArrayOutputStream baosIn = new ByteArrayOutputStream();
-                byte[]                bytes = new byte[8192];
-                int size;
-
-                while ((size = inStream.read(bytes)) > 0) {
-                    baosIn.write(bytes, 0, size);
-                }
-
-                inStream = new ByteArrayInputStream(baosIn.toByteArray());
-
-                // It is POST, handle it
-                HTTPTransportUtils.processHTTPPostRequest(msgContext, inStream, baos,
-                        request.getContentType(), soapAction, request.getRequestLine().getUri());
+                throw new MethodNotSupportedException(method + " method not supported");
             }
-
+            
+            // Finalize response
             OperationContext operationContext = msgContext.getOperationContext();
             Object contextWritten = null;
-
             if (operationContext != null) {
                 contextWritten = operationContext.getProperty(Constants.RESPONSE_WRITTEN);
             }
-
             if ((contextWritten != null) && Constants.VALUE_TRUE.equals(contextWritten)) {
-                response.setStatusLine(request.getRequestLine().getHttpVersion(), 200, "OK");
+                response.setStatusLine(new StatusLine(ver, 200, "OK"));
             } else {
-                response.setStatusLine(request.getRequestLine().getHttpVersion(), 202, "OK");
+                response.setStatusLine(new StatusLine(ver, 202, "OK"));
             }
-
-            byte[] buf = baos.toByteArray();
-            response.setBody(new ByteArrayInputStream(buf));
-            setResponseHeaders(conn, request, response, buf.length, msgContext);
-
-            conn.writeResponse(response);
+            setCookie(response, msgContext);
+            
+        } catch (SocketException ex) {
+            // Socket is unreliable. 
+            throw ex;
+        } catch (HttpException ex) {
+            // HTTP protocol violation. Transport is unrelaible
+            throw ex;
         } catch (Throwable e) {
-            if (!(e instanceof java.net.SocketException)) {
-                log.debug(e.getMessage(), e);
-            }
-
+            HttpVersion ver = request.getRequestLine().getHttpVersion();
             try {
                 AxisEngine engine = new AxisEngine(configurationContext);
-
-                if (msgContext != null) {
-                    msgContext.setProperty(MessageContext.TRANSPORT_OUT, baos);
-
-                    MessageContext faultContext = engine.createFaultMessageContext(msgContext, e);
-
-                    response.setStatusLine(request.getRequestLine().getHttpVersion(), 500,
-                            "Internal server error");
-                    engine.sendFault(faultContext);
-                    byte[] buf = baos.toByteArray();
-                    response.setBody(new ByteArrayInputStream(buf));
-                    setResponseHeaders(conn, request, response, buf.length, msgContext);
-                    conn.writeResponse(response);
-                }
-            } catch (SocketException e1) {
-                log.debug(e1.getMessage(), e1);
-            } catch (Exception e1) {
-                log.warn(e1.getMessage(), e1);
-            }
-        }
-
-        return true;
-    }
-
-    /**
-     * Simple Axis Transport Selection via deployment
-     *
-     * @param configContext
-     * @param response
-     */
-    private void transportOutConfiguration(ConfigurationContext configContext,
-                                           SimpleResponse response) {
-        AxisConfiguration axisConf = configContext.getAxisConfiguration();
-        HashMap transportOuts = axisConf.getTransportsOut();
-        Iterator values = transportOuts.values().iterator();
-
-        while (values.hasNext()) {
-            TransportOutDescription transportOut = (TransportOutDescription) values.next();
-
-            // reading axis2.xml for transport senders..
-            Parameter version = transportOut.getParameter(HTTPConstants.PROTOCOL_VERSION);
-
-            if (version != null) {
-                if (HTTPConstants.HEADER_PROTOCOL_11.equals(version.getValue())) {
-
-                    Parameter transferEncoding =
-                            transportOut.getParameter(HTTPConstants.HEADER_TRANSFER_ENCODING);
-
-                    if (transferEncoding != null) {
-                        if (HTTPConstants.HEADER_TRANSFER_ENCODING_CHUNKED.equals(
-                                transferEncoding.getValue())) {
-                            response.setHeader(
-                                    new Header(
-                                            HTTPConstants.HEADER_TRANSFER_ENCODING,
-                                            HTTPConstants.HEADER_TRANSFER_ENCODING_CHUNKED));
-                        }
-                    }
-                }
+                
+                OutputBuffer outbuffer = new OutputBuffer(); 
+                msgContext.setProperty(MessageContext.TRANSPORT_OUT, outbuffer.getOutputStream());
+                msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outbuffer);
+
+                MessageContext faultContext = engine.createFaultMessageContext(msgContext, e);
+
+                response.setStatusLine(new StatusLine(ver, 500, "Internal server error"));
+                engine.sendFault(faultContext);
+                response.setEntity(outbuffer);
+                setCookie(response, msgContext);
+            } catch (Exception ex) {
+                response.setStatusLine(new StatusLine(ver, 500, "Internal server error"));
+                StringEntity entity = new StringEntity(ex.getMessage());
+                entity.setContentType("text/plain");
+                response.setEntity(entity);
             }
         }
     }
 
-    private Map getHeaders(SimpleRequest request) {
-        HashMap headerMap = new HashMap();
-        Header[] headers = request.getHeaders();
-
-        for (int i = 0; i < headers.length; i++) {
-            headerMap.put(headers[i].getName(), headers[i].getValue());
-        }
-
-        return headerMap;
-    }
-
-    private void setResponseHeaders(final SimpleHttpServerConnection conn, SimpleRequest request,
-                                    SimpleResponse response, long contentLength, MessageContext msgContext) {
-        if (!response.containsHeader("Connection")) {
-
-            // See if the the client explicitly handles connection persistence
-            Header connheader = request.getFirstHeader("Connection");
-
-            if (connheader != null) {
-                if (connheader.getValue().equalsIgnoreCase("keep-alive")) {
-                    Header header = new Header("Connection", "keep-alive");
-
-                    response.addHeader(header);
-                    conn.setKeepAlive(true);
-                }
-
-                if (connheader.getValue().equalsIgnoreCase("close")) {
-                    Header header = new Header("Connection", "close");
-
-                    response.addHeader(header);
-                    conn.setKeepAlive(false);
-                }
-            } else {
-
-                // Use protocol default connection policy
-                if (response.getHttpVersion().greaterEquals(HttpVersion.HTTP_1_1)) {
-                    conn.setKeepAlive(true);
-                } else {
-                    conn.setKeepAlive(false);
-                }
-            }
-        }
+    private static void setCookie(final HttpResponse response, MessageContext msgContext) {
         //TODO : provide a way to enable and diable cookies
         //setting the coolie in the out path
         Object cookieString = msgContext.getProperty(Constants.COOKIE_STRING);
@@ -423,14 +358,6 @@
             response.addHeader(new Header(HTTPConstants.HEADER_SET_COOKIE, (String) cookieString));
             response.addHeader(new Header(HTTPConstants.HEADER_SET_COOKIE2, (String) cookieString));
         }
-
-        if (!response.containsHeader("Transfer-Encoding")) {
-            if (contentLength != 0) {
-                Header header = new Header("Content-Length", String.valueOf(contentLength));
-
-                response.addHeader(header);
-            }
-        }
     }
 
     /**
Index: modules/core/src/org/apache/axis2/transport/http/SimpleHTTPOutTransportInfo.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/SimpleHTTPOutTransportInfo.java	(revision 412455)
+++ modules/core/src/org/apache/axis2/transport/http/SimpleHTTPOutTransportInfo.java	(working copy)
@@ -1,43 +0,0 @@
-/*
-* Copyright 2004,2005 The Apache Software Foundation.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-
-package org.apache.axis2.transport.http;
-
-import org.apache.axis2.transport.OutTransportInfo;
-import org.apache.axis2.transport.http.server.SimpleResponse;
-import org.apache.commons.httpclient.Header;
-
-public class SimpleHTTPOutTransportInfo implements OutTransportInfo {
-    private String encoding;
-    private SimpleResponse outInfo;
-
-    public SimpleHTTPOutTransportInfo(SimpleResponse outInfo) {
-        this.outInfo = outInfo;
-    }
-
-    public void setCharacterEncoding(String encoding) {
-        this.encoding = encoding;
-    }
-
-    public void setContentType(String contentType) {
-        if (encoding != null) {
-            contentType = contentType + ";charset=" + encoding;
-        }
-
-        outInfo.setHeader(new Header(HTTPConstants.HEADER_CONTENT_TYPE, contentType));
-    }
-}
Index: modules/core/src/org/apache/axis2/transport/http/SimpleHTTPServer.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/SimpleHTTPServer.java	(revision 412455)
+++ modules/core/src/org/apache/axis2/transport/http/SimpleHTTPServer.java	(working copy)
@@ -26,8 +26,9 @@
 import org.apache.axis2.description.TransportInDescription;
 import org.apache.axis2.engine.ListenerManager;
 import org.apache.axis2.transport.TransportListener;
+import org.apache.axis2.transport.http.server.HttpFactory;
+import org.apache.axis2.transport.http.server.HttpUtils;
 import org.apache.axis2.transport.http.server.SimpleHttpServer;
-import org.apache.axis2.transport.http.server.SimpleHttpServerConnection;
 import org.apache.axis2.util.OptionsParser;
 import org.apache.axis2.util.threadpool.ThreadFactory;
 import org.apache.commons.logging.Log;
@@ -40,73 +41,45 @@
 
 /**
  * This is a simple implementation of an HTTP server for processing
- * SOAP requests via Apache's xml-axis2.  This is not intended for production
- * use.  Its intended uses are for demos, debugging, and performance
- * profiling.
- * Note this classes uses static objects to provide a thread pool, so you should
- * not use multiple instances of this class in the same JVM/classloader unless
- * you want bad things to happen at shutdown.
+ * SOAP requests via Apache's xml-axis2.
+ * It can be used with no configuration other than the port to listen on, or it can
+ * be configured in detail with an HttpFactory.
  */
 public class SimpleHTTPServer implements TransportListener {
 
-    /**
-     * Field log
-     */
     private static final Log log = LogFactory.getLog(SimpleHTTPServer.class);
 
     /**
-     * Embedded commons http client based server
+     * Embedded commons http core based server
      */
     SimpleHttpServer embedded = null;
     int port = -1;
-    private ThreadFactory threadPool = null;
 
     public static int DEFAULT_PORT = 8080;
+
     private String hostAddress = null;
-    private String conetxtPath;
+    private String contextPath;
 
-    /**
-     * Field systemContext
-     */
     protected ConfigurationContext configurationContext;
+    protected HttpFactory httpFactory;
 
     public SimpleHTTPServer() {
     }
 
-    public SimpleHTTPServer(ConfigurationContext systemContext, int port) throws AxisFault {
-        this(systemContext, port, null);
-    }
-
-    /**
-     * Constructor SimpleHTTPServer
-     *
-     * @param systemContext
-     * @param pool
-     */
-    public SimpleHTTPServer(ConfigurationContext systemContext, int port, ThreadFactory pool) throws AxisFault {
-        // If a threadPool is not passed-in the threadpool
-        // from the ConfigurationContext
-        // is used. This is a bit tricky, and might cause a
-        // thread lock. So use with
-        // caution
-        this.configurationContext = systemContext;
-        if (pool == null) {
-            pool = this.configurationContext.getThreadPool();
-        } else {
-            this.configurationContext.setThreadPool(pool);
-        }
-        this.port = port;
-        this.threadPool = pool;
-        ListenerManager listenerManager = configurationContext.getListenerManager();
-        TransportInDescription trsIn = new TransportInDescription(
-                new QName(Constants.TRANSPORT_HTTP));
-        trsIn.setReceiver(this);
-        if (listenerManager == null) {
-            listenerManager = new ListenerManager();
-            listenerManager.init(configurationContext);
-        }
-        listenerManager.addListener(trsIn, true);
-        conetxtPath = configurationContext.getContextPath();
+    /** Create a SimpleHTTPServer using default HttpFactory settings */
+    public SimpleHTTPServer(ConfigurationContext configurationContext, int port) throws AxisFault {
+        this(new HttpFactory(configurationContext, port));
+    }
+    
+    /** Create a configured SimpleHTTPServer */
+    public SimpleHTTPServer(HttpFactory httpFactory) throws AxisFault {
+        this.httpFactory = httpFactory;
+        this.configurationContext = httpFactory.getConfigurationContext();
+        this. port = httpFactory.getPort();
+        TransportInDescription httpDescription = new TransportInDescription(new QName(Constants.TRANSPORT_HTTP));
+        httpDescription.setReceiver(this);
+        httpFactory.getListenerManager().addListener(httpDescription, true);
+        contextPath = configurationContext.getContextPath();
     }
 
     /**
@@ -122,15 +95,19 @@
             this.configurationContext = axisConf;
 
             Parameter param = transprtIn.getParameter(PARAM_PORT);
-
-            if (param != null) {
+            if (param != null)
                 this.port = Integer.parseInt((String) param.getValue());
-            }
+            
+            if (httpFactory==null)
+                httpFactory = new HttpFactory(configurationContext, port);
+            
             param = transprtIn.getParameter(HOST_ADDRESS);
-            if (param != null) {
+            if (param != null)
                 hostAddress = ((String) param.getValue()).trim();
-            }
-            conetxtPath = configurationContext.getContextPath();
+            else
+                hostAddress = httpFactory.getHostAddress();
+
+            contextPath = configurationContext.getContextPath();
         } catch (Exception e1) {
             throw new AxisFault(e1);
         }
@@ -165,7 +142,7 @@
         try {
             SimpleHTTPServer receiver = new SimpleHTTPServer(
                     ConfigurationContextFactory.createConfigurationContextFromFileSystem(
-                            args[0], null), port, null);
+                            args[0], null), port);
             Runtime.getRuntime().addShutdownHook(new ShutdownThread(receiver));
             receiver.start();
             System.out.println("[SimpleHTTPServer] Started");
@@ -189,8 +166,9 @@
      */
     public void start() throws AxisFault {
         try {
-            embedded = new SimpleHttpServer(port, this.threadPool);
-            embedded.setRequestHandler(new HTTPWorker(configurationContext));
+            embedded = new SimpleHttpServer(httpFactory, port);
+            embedded.init();
+            embedded.start();
         } catch (IOException e) {
             log.error(e);
             throw new AxisFault(e);
@@ -205,9 +183,18 @@
     public void stop() {
         System.out.println("[SimpleHTTPServer] Stop called");
         if (embedded != null) {
-            embedded.destroy();
+            try {
+                embedded.destroy();
+            } catch (Exception e) {
+                log.error(e);
+            }
         }
     }
+    
+    /** Getter for httpFactory */
+    public HttpFactory getHttpFactory() {
+        return httpFactory;
+    }
 
     /**
      * Method getConfigurationContext
@@ -233,7 +220,7 @@
         //if host address is present
         if (hostAddress != null) {
             if (embedded != null) {
-                return new EndpointReference(hostAddress + conetxtPath + serviceName);
+                return new EndpointReference(hostAddress + contextPath + "/" + serviceName);
             } else {
                 throw new AxisFault("Unable to generate EPR for the transport : http");
             }
@@ -244,15 +231,15 @@
             localAddress = ip;
         } else {
             try {
-                localAddress = SimpleHttpServerConnection.getIpAddress();
+                localAddress = HttpUtils.getIpAddress();
             } catch (SocketException e) {
                 throw AxisFault.makeFault(e);
             }
         }
         if (embedded != null) {
             return new EndpointReference("http://" + localAddress + ":" +
-                    (embedded.getLocalPort())
-                    + conetxtPath + "/" + serviceName);
+                    (embedded.getPort())
+                    + contextPath + "/" + serviceName);
         } else {
             throw new AxisFault("Unable to generate EPR for the transport : http");
         }
Index: modules/core/src/org/apache/axis2/transport/http/server/WorkerFactory.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/WorkerFactory.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/WorkerFactory.java	(revision 0)
@@ -0,0 +1,34 @@
+/*
+* $HeadURL$
+* $Revision$
+* $Date$
+*
+* ====================================================================
+*
+*  Copyright 1999-2004 The Apache Software Foundation
+*
+*  Licensed under the Apache License, Version 2.0 (the "License");
+*  you may not use this file except in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing, software
+*  distributed under the License is distributed on an "AS IS" BASIS,
+*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+*  See the License for the specific language governing permissions and
+*  limitations under the License.
+* ====================================================================
+*
+* This software consists of voluntary contributions made by many
+* individuals on behalf of the Apache Software Foundation.  For more
+* information on the Apache Software Foundation, please see
+* <http://www.apache.org/>.
+*/
+package org.apache.axis2.transport.http.server;
+
+public interface WorkerFactory {
+
+    Worker newWorker();    
+    
+}
Index: modules/core/src/org/apache/axis2/transport/http/server/DefaultThreadFactory.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/DefaultThreadFactory.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/DefaultThreadFactory.java	(revision 0)
@@ -0,0 +1,58 @@
+/*
+* $HeadURL$
+* $Revision$
+* $Date$
+*
+* ====================================================================
+*
+*  Copyright 1999-2004 The Apache Software Foundation
+*
+*  Licensed under the Apache License, Version 2.0 (the "License");
+*  you may not use this file except in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing, software
+*  distributed under the License is distributed on an "AS IS" BASIS,
+*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+*  See the License for the specific language governing permissions and
+*  limitations under the License.
+* ====================================================================
+*
+* This software consists of voluntary contributions made by many
+* individuals on behalf of the Apache Software Foundation.  For more
+* information on the Apache Software Foundation, please see
+* <http://www.apache.org/>.
+*/
+
+package org.apache.axis2.transport.http.server;
+
+import edu.emory.mathcs.backport.java.util.concurrent.ThreadFactory;
+import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicInteger;
+
+public class DefaultThreadFactory implements ThreadFactory {
+
+    final ThreadGroup group;
+    final AtomicInteger count;
+    final String namePrefix;
+	
+    public DefaultThreadFactory(final ThreadGroup group, final String namePrefix) {
+        super();
+        this.count = new AtomicInteger(1);
+        this.group = group;
+        this.namePrefix = namePrefix;
+    }
+
+    public Thread newThread(final Runnable runnable) {
+    	StringBuffer buffer = new StringBuffer();
+    	buffer.append(this.namePrefix);
+    	buffer.append('-');
+    	buffer.append(this.count.getAndIncrement());
+        Thread t = new Thread(group, runnable, buffer.toString(), 0);
+        t.setDaemon(false);
+        t.setPriority(Thread.NORM_PRIORITY);
+        return t;
+    }
+        
+}
Index: modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpServiceProcessor.java	(revision 0)
@@ -0,0 +1,145 @@
+/*
+* $HeadURL$
+* $Revision$
+* $Date$
+*
+* ====================================================================
+*
+*  Copyright 1999-2004 The Apache Software Foundation
+*
+*  Licensed under the Apache License, Version 2.0 (the "License");
+*  you may not use this file except in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing, software
+*  distributed under the License is distributed on an "AS IS" BASIS,
+*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+*  See the License for the specific language governing permissions and
+*  limitations under the License.
+* ====================================================================
+*
+* This software consists of voluntary contributions made by many
+* individuals on behalf of the Apache Software Foundation.  For more
+* information on the Apache Software Foundation, please see
+* <http://www.apache.org/>.
+*/
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.Header;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpServerConnection;
+import org.apache.http.HttpVersion;
+import org.apache.http.RequestLine;
+import org.apache.http.UnsupportedHttpVersionException;
+import org.apache.http.protocol.HttpContext;
+import org.apache.http.protocol.HttpService;
+
+public class DefaultHttpServiceProcessor extends HttpServiceProcessor {
+
+    private static final Log LOG = LogFactory.getLog(DefaultHttpServiceProcessor.class);
+    private static final Log HEADERLOG = LogFactory.getLog("org.apache.axis2.transport.http.server.wire");
+    
+    private final Worker worker;
+    private final IOProcessorCallback callback;
+    
+    public DefaultHttpServiceProcessor(
+            final HttpServerConnection conn, 
+            final Worker worker,
+            final IOProcessorCallback callback) {
+        super(conn);
+        if (worker == null) {
+            throw new IllegalArgumentException("Worker may not be null");
+        }
+        this.worker = worker;
+        this.callback = callback;
+    }
+    
+    protected void postprocessResponse(final HttpResponse response, final HttpContext context) 
+            throws IOException, HttpException {
+        super.postprocessResponse(response, context);
+        if (HEADERLOG.isDebugEnabled()) {
+            HEADERLOG.debug("<< " + response.getStatusLine().toString());
+            Header[] headers = response.getAllHeaders();
+            for (int i = 0; i < headers.length; i++) {
+                HEADERLOG.debug("<< " + headers[i].toString());
+            }
+        }
+    }
+
+    protected void preprocessRequest(final HttpRequest request, final HttpContext context) 
+            throws IOException, HttpException {
+        super.preprocessRequest(request, context);
+        if (HEADERLOG.isDebugEnabled()) {
+            HEADERLOG.debug(">> " + request.getRequestLine().toString());
+            Header[] headers = request.getAllHeaders();
+            for (int i = 0; i < headers.length; i++) {
+                HEADERLOG.debug(">> " + headers[i].toString());
+            }
+        }
+    }
+
+    protected void doService(final HttpRequest request, final HttpResponse response) 
+            throws HttpException, IOException {
+        RequestLine reqline = request.getRequestLine();
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Request method: " + reqline.getMethod());
+            LOG.debug("Target URI: " + reqline.getUri());
+        }
+        
+        HttpVersion ver = reqline.getHttpVersion();
+        if (!ver.lessEquals(HttpVersion.HTTP_1_1)) {
+            throw new UnsupportedHttpVersionException("Unsupported HTTP version: " + ver); 
+        }
+        this.worker.service(request, response);
+    }
+    
+    protected void logIOException(final IOException ex) {
+        if (ex instanceof SocketTimeoutException) {
+            LOG.debug(ex.getMessage());
+        } else if (ex instanceof SocketException) {
+            LOG.debug(ex.getMessage());
+        }
+        else {
+            LOG.warn(ex.getMessage(), ex);
+        }
+    }
+
+    protected void logMessage(final String s) {
+        LOG.debug(s);
+    }
+
+    protected void logProtocolException(final HttpException ex) {
+        if (LOG.isWarnEnabled()) {
+            LOG.warn("HTTP protocol error: " + ex.getMessage());
+        }
+    }
+
+    public void close() throws IOException {
+        closeConnection();
+    }
+
+    public void run() {
+        LOG.debug("New connection thread");
+        try {
+            while (!Thread.interrupted() && !isDestroyed() && isActive()) {
+                handleRequest();
+            }
+        } finally {
+            destroy();
+            if (this.callback != null) {
+                this.callback.completed(this);
+            }
+        }
+    }
+                   
+}
Index: modules/core/src/org/apache/axis2/transport/http/server/Worker.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/Worker.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/Worker.java	(revision 0)
@@ -0,0 +1,41 @@
+/*
+* $HeadURL$
+* $Revision$
+* $Date$
+*
+* ====================================================================
+*
+*  Copyright 1999-2004 The Apache Software Foundation
+*
+*  Licensed under the Apache License, Version 2.0 (the "License");
+*  you may not use this file except in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing, software
+*  distributed under the License is distributed on an "AS IS" BASIS,
+*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+*  See the License for the specific language governing permissions and
+*  limitations under the License.
+* ====================================================================
+*
+* This software consists of voluntary contributions made by many
+* individuals on behalf of the Apache Software Foundation.  For more
+* information on the Apache Software Foundation, please see
+* <http://www.apache.org/>.
+*/
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+
+public interface Worker {
+
+    void service(HttpRequest request, HttpResponse response) 
+        throws HttpException, IOException;    
+    
+}
Index: modules/core/src/org/apache/axis2/transport/http/server/DefaultConnectionListener.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/DefaultConnectionListener.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/DefaultConnectionListener.java	(revision 0)
@@ -0,0 +1,125 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketException;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.HttpServerConnection;
+
+public class DefaultConnectionListener implements IOProcessor {
+
+    private static Log LOG = LogFactory.getLog(DefaultConnectionListener.class);
+	
+    private volatile boolean destroyed = false;
+    
+    private final HttpConnectionFactory connfactory;
+    private final HttpConnectionManager connmanager;
+    private final ServerSocket serversocket;
+        
+    public DefaultConnectionListener(
+    		int port,
+            final HttpConnectionFactory connfactory,
+            final HttpConnectionManager connmanager) throws IOException {
+    	super();
+        if (connfactory == null) {
+            throw new IllegalArgumentException("Connection factory may not be null");
+        }
+        if (connmanager == null) {
+            throw new IllegalArgumentException("Connection manager may not be null");
+        }
+        this.connmanager = connmanager;
+        this.connfactory = connfactory;
+        this.serversocket = new ServerSocket(port);
+    }
+
+    public void run() {
+    	if (LOG.isInfoEnabled()) {
+            LOG.info("Listening on port " + this.serversocket.getLocalPort());
+    	}
+        try {
+            while (!this.serversocket.isClosed() && !Thread.interrupted()) {
+                try {
+                    LOG.debug("Waiting for incoming HTTP connection");
+                    Socket socket = this.serversocket.accept();
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug("Incoming HTTP connection from " + 
+                        		socket.getRemoteSocketAddress());
+                    }
+                    HttpServerConnection conn = this.connfactory.newConnection(socket);
+                    this.connmanager.process(conn);
+                } catch (IOException ex) {
+                    if (ex instanceof SocketException) {
+                        if (LOG.isDebugEnabled() 
+                                && !this.destroyed && !Thread.interrupted()) {
+                            LOG.debug("Connection listener terminated due to an I/O error: " + 
+                                    ex.getMessage());
+                        }
+                    } else {
+                        if (LOG.isWarnEnabled()) {
+                            LOG.warn("Connection listener terminated due to an I/O error: " + 
+                                    ex.getMessage(), ex);
+                        }
+                    }
+                    break;
+                } catch (Throwable ex) {
+                    LOG.error("Connection listener terminated due to a runtime error", ex);
+                    break;
+                }
+            }
+        } finally {
+            destroy();
+        }
+    }
+    
+	public void close() throws IOException {
+        this.serversocket.close();
+	}
+    
+    public void destroy() {
+        this.destroyed = true;
+        try {
+            close();
+        } catch (IOException ex) {
+            if (LOG.isWarnEnabled()) {
+                LOG.warn("I/O error closing listener", ex);
+            }
+        }
+    }
+
+    public boolean isDestroyed() {
+        return this.destroyed;
+    }
+    
+}
Index: modules/core/src/org/apache/axis2/transport/http/server/IOProcessorCallback.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/IOProcessorCallback.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/IOProcessorCallback.java	(revision 0)
@@ -0,0 +1,36 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+public interface IOProcessorCallback {
+
+    void completed(IOProcessor processor);
+    
+}
Index: modules/core/src/org/apache/axis2/transport/http/server/HttpConnectionFactory.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/HttpConnectionFactory.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/HttpConnectionFactory.java	(revision 0)
@@ -0,0 +1,41 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+import java.net.Socket;
+
+import org.apache.http.HttpServerConnection;
+
+public interface HttpConnectionFactory {
+
+    HttpServerConnection newConnection(Socket socket) throws IOException;
+    
+}
Index: modules/core/src/org/apache/axis2/transport/http/server/HttpConnectionManager.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/HttpConnectionManager.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/HttpConnectionManager.java	(revision 0)
@@ -0,0 +1,40 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import org.apache.http.HttpServerConnection;
+
+public interface HttpConnectionManager {
+
+    void process(HttpServerConnection incoming);
+    
+    void shutdown();
+    
+}
Index: modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionFactory.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionFactory.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionFactory.java	(revision 0)
@@ -0,0 +1,58 @@
+/*
+ * $HeadURL:https://svn.apache.org/repos/asf/jakarta/httpcomponents/trunk/coyote-httpconnector/src/java/org/apache/http/tcconnector/impl/DefaultHttpConnectionFactory.java $
+ * $Revision:379772 $
+ * $Date:2006-02-22 14:52:29 +0100 (Wed, 22 Feb 2006) $
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+import java.net.Socket;
+
+import org.apache.http.HttpServerConnection;
+import org.apache.http.impl.DefaultHttpServerConnection;
+import org.apache.http.params.HttpParams;
+
+public class DefaultHttpConnectionFactory implements HttpConnectionFactory {
+
+	final HttpParams params;
+	
+    public DefaultHttpConnectionFactory(final HttpParams params) {
+        super();
+        if (params == null) {
+            throw new IllegalArgumentException("HTTP parameters may not be null");
+        }
+        this.params = params;
+    }
+    
+    public HttpServerConnection newConnection(final Socket socket)
+            throws IOException {
+        DefaultHttpServerConnection conn = new DefaultHttpServerConnection();
+        conn.bind(socket, this.params);
+        return conn;
+    }
+    
+}
Index: modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/DefaultHttpConnectionManager.java	(revision 0)
@@ -0,0 +1,149 @@
+/*
+ * $HeadURL:https://svn.apache.org/repos/asf/jakarta/httpcomponents/trunk/coyote-httpconnector/src/java/org/apache/http/tcconnector/impl/DefaultHttpConnectionManager.java $
+ * $Revision:379772 $
+ * $Date:2006-02-22 14:52:29 +0100 (Wed, 22 Feb 2006) $
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.HttpServerConnection;
+import org.apache.http.params.HttpParams;
+import org.apache.http.protocol.ResponseConnControl;
+import org.apache.http.protocol.ResponseContent;
+import org.apache.http.protocol.ResponseDate;
+import org.apache.http.protocol.ResponseServer;
+
+import edu.emory.mathcs.backport.java.util.concurrent.Executor;
+
+public class DefaultHttpConnectionManager implements HttpConnectionManager {
+
+    private static Log LOG = LogFactory.getLog(DefaultHttpConnectionManager.class);
+    
+    private final Executor executor;
+    private final WorkerFactory workerfactory;
+    private final HttpParams params;
+    private final List processors;
+    
+    private HttpFactory httpFactory = null;
+    
+    public DefaultHttpConnectionManager(
+    		final Executor executor,
+            final WorkerFactory workerfactory,
+    		final HttpParams params) {
+        super();
+        if (executor == null) {
+            throw new IllegalArgumentException("Executor may not be null");
+        }
+        if (workerfactory == null) {
+            throw new IllegalArgumentException("Worker factory may not be null");
+        }
+        if (params == null) {
+            throw new IllegalArgumentException("HTTP parameters may not be null");
+        }
+        this.executor = executor;
+        this.workerfactory = workerfactory;
+        this.params = params;
+        this.processors = new LinkedList();
+    }
+    
+    public DefaultHttpConnectionManager(final Executor executor, final WorkerFactory workerfactory, final HttpParams params, final HttpFactory httpFactory) {
+        this(executor, workerfactory, params);
+        this.httpFactory = httpFactory;
+    }
+
+
+    private synchronized void cleanup() {
+        for (Iterator i = this.processors.iterator(); i.hasNext(); ) {
+            IOProcessor processor = (IOProcessor) i.next();
+            if (processor.isDestroyed()) {
+                i.remove();
+            }
+        }
+    }
+    
+    private synchronized void addProcessor(final IOProcessor processor) {
+        if (processor == null) {
+            return;
+        }
+        this.processors.add(processor);
+    }
+    
+    private synchronized void removeProcessor(final IOProcessor processor) {
+        if (processor == null) {
+            return;
+        }
+        this.processors.remove(processor);
+    }
+    
+    public void process(final HttpServerConnection conn) {
+        if (conn == null) {
+            throw new IllegalArgumentException("HTTP connection may not be null");
+        }
+        // Evict destroyed processors
+        cleanup();
+        
+        IOProcessorCallback callback = new IOProcessorCallback() {
+          
+            public void completed(final IOProcessor processor) {
+                removeProcessor(processor);
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(processor + " terminated");
+                }
+            }
+            
+        };
+        HttpServiceProcessor processor;
+        if (httpFactory!=null)
+            processor = httpFactory.newRequestServiceProcessor(conn, workerfactory.newWorker(), callback);
+        else
+            processor = new DefaultHttpServiceProcessor(conn, workerfactory.newWorker(), callback);
+
+        processor.setParams(this.params);
+        // Add required protocol interceptors
+        processor.addInterceptor(new ResponseDate());
+        processor.addInterceptor(new ResponseServer());                    
+        processor.addInterceptor(new ResponseContent());
+        processor.addInterceptor(new ResponseConnControl());
+        
+        addProcessor(processor);
+        this.executor.execute(processor);
+    }
+    
+    public synchronized void shutdown() {
+        for (int i = 0; i < this.processors.size(); i++) {
+            IOProcessor processor = (IOProcessor) this.processors.get(i);
+            processor.destroy();
+        }
+        this.processors.clear();
+    }
+	
+}
Index: modules/core/src/org/apache/axis2/transport/http/server/HttpUtils.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/HttpUtils.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/HttpUtils.java	(revision 0)
@@ -0,0 +1,109 @@
+/*
+* $HeadURL$
+* $Revision$
+* $Date$
+*
+* ====================================================================
+*
+*  Copyright 1999-2004 The Apache Software Foundation
+*
+*  Licensed under the Apache License, Version 2.0 (the "License");
+*  you may not use this file except in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing, software
+*  distributed under the License is distributed on an "AS IS" BASIS,
+*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+*  See the License for the specific language governing permissions and
+*  limitations under the License.
+* ====================================================================
+*
+* This software consists of voluntary contributions made by many
+* individuals on behalf of the Apache Software Foundation.  For more
+* information on the Apache Software Foundation, please see
+* <http://www.apache.org/>.
+*/
+package org.apache.axis2.transport.http.server;
+
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.util.Enumeration;
+
+import org.apache.axis2.transport.http.HTTPConstants;
+import org.apache.http.Header;
+import org.apache.http.HttpRequest;
+
+public class HttpUtils {
+    
+    private HttpUtils() {
+    }
+
+    public static String getCookieID(final HttpRequest request) {
+        if (request == null) {
+            return null;
+        }
+        Header header = request.getFirstHeader(HTTPConstants.HEADER_COOKIE);
+        if (header == null) {
+            header = request.getFirstHeader(HTTPConstants.HEADER_COOKIE2);
+        }
+        if (header == null) {
+            return null;
+        } else {
+            return header.getValue();
+        }
+    }
+    
+    public static String getSoapAction(final HttpRequest request) {
+        if (request == null) {
+            return null;
+        }
+        Header header = request.getFirstHeader(HTTPConstants.HEADER_SOAP_ACTION);
+        if (header != null) {
+            return header.getValue();
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the ip address to be used for the replyto epr
+     * CAUTION:
+     * This will go through all the available network interfaces and will try to return an ip address.
+     * First this will try to get the first IP which is not loopback address (127.0.0.1). If none is found
+     * then this will return this will return 127.0.0.1.
+     * This will <b>not<b> consider IPv6 addresses.
+     * <p/>
+     * TODO:
+     * - Improve this logic to genaralize it a bit more
+     * - Obtain the ip to be used here from the Call API
+     *
+     * @return Returns String.
+     * @throws SocketException
+     */
+    public static String getIpAddress() throws SocketException {
+        Enumeration e = NetworkInterface.getNetworkInterfaces();
+        String address = "127.0.0.1";
+
+        while (e.hasMoreElements()) {
+            NetworkInterface netface = (NetworkInterface) e.nextElement();
+            Enumeration addresses = netface.getInetAddresses();
+
+            while (addresses.hasMoreElements()) {
+                InetAddress ip = (InetAddress) addresses.nextElement();
+                if (!ip.isLoopbackAddress() && isIP(ip.getHostAddress())) {
+                    return ip.getHostAddress();
+                }
+            }
+        }
+
+        return address;
+    }
+
+    private static boolean isIP(String hostAddress) {
+        return hostAddress.split("[.]").length == 4;
+    }
+    
+}
Index: modules/core/src/org/apache/axis2/transport/http/server/HttpServiceProcessor.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/HttpServiceProcessor.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/HttpServiceProcessor.java	(revision 0)
@@ -0,0 +1,49 @@
+/*
+ * HttpServiceProcessor.java
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2004 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ * Created on May 25, 2006, 4:09 PM
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import org.apache.http.HttpServerConnection;
+import org.apache.http.protocol.HttpService;
+
+/**
+ * Abstract base class to process requests and fill in respnses.
+ * @author Chuck Williams
+ */
+
+public abstract class HttpServiceProcessor extends HttpService implements IOProcessor {
+    
+    /** Create an HttpServiceProcessor
+     * @param conn the connection we are receiving the request on
+     */
+    public HttpServiceProcessor(HttpServerConnection conn) {
+        super(conn);
+    }
+
+}
Index: modules/core/src/org/apache/axis2/transport/http/server/HttpFactory.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/HttpFactory.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/HttpFactory.java	(revision 0)
@@ -0,0 +1,376 @@
+/*
+ * HttpFactory.java
+ *
+ * ====================================================================
+ *
+ *  Copyright 2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ * Created on May 25, 2006, 10:11 AM
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import edu.emory.mathcs.backport.java.util.concurrent.BlockingQueue;
+import edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingQueue;
+import edu.emory.mathcs.backport.java.util.concurrent.ExecutorService;
+import edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor;
+import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
+import java.io.IOException;
+import javax.xml.namespace.QName;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.description.TransportInDescription;
+import org.apache.axis2.engine.ListenerManager;
+import org.apache.axis2.transport.http.HTTPWorker;
+import org.apache.axis2.transport.http.HTTPWorkerFactory;
+import org.apache.http.HttpServerConnection;
+import org.apache.http.impl.DefaultHttpParams;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.params.HttpProtocolParams;
+
+/**
+ * Factory used to configure and create the various instances required in http transports.
+ * Either configure this class in axis2.xml, or in code via the setters, or subclass it and specialize some factory methods to gain more control.
+ *
+ * @author Chuck Williams
+ */
+public class HttpFactory {
+
+    /** Name of axis2.xml port parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_PORT = "port";
+    
+    /** Name of axis2.xml hostname parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_HOST_ADDRESS = "hostname";
+
+    /** Name of axis2.xml originServer parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_ORIGIN_SERVER = "originServer";
+
+    /** Name of axis2.xml requestTimeout parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_REQUEST_SOCKET_TIMEOUT = "requestTimeout";
+
+    /** Name of axis2.xml requestTcpNoDelay parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_REQUEST_TCP_NO_DELAY = "requestTcpNoDelay";
+
+    /** Name of axis2.xml requestCoreThreadPoolSize parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_REQUEST_CORE_THREAD_POOL_SIZE = "requestCoreThreadPoolSize";
+
+    /** Name of axis2.xml requestMaxThreadPoolSize parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_REQUEST_MAX_THREAD_POOL_SIZE = "requestMaxThreadPoolSize";
+
+    /** Name of axis2.xml threadKeepAliveTime parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_THREAD_KEEP_ALIVE_TIME = "threadKeepAliveTime";
+
+    /** Name of axis2.xml threadKeepAliveTimeUnit parameter for SimpleHTTPServer configuration */
+    public static final String PARAMETER_THREAD_KEEP_ALIVE_TIME_UNIT = "threadKeepAliveTimeUnit";
+    
+    private ConfigurationContext configurationContext;
+    private TransportInDescription httpConfiguration;
+    private int port;
+    private String hostAddress;
+    private String originServer;
+    private int requestSocketTimeout;
+    private boolean requestTcpNoDelay;
+    private int requestCoreThreadPoolSize;
+    private int requestMaxThreadPoolSize;
+    private long threadKeepAliveTime;
+    private TimeUnit threadKeepAliveTimeUnit;
+    
+    private WorkerFactory requestWorkerFactory = null;
+    
+    private static final QName HTTP_NAME = new QName(Constants.TRANSPORT_HTTP);
+    
+    /** Create and configure a new HttpFactory */
+    public HttpFactory(ConfigurationContext configurationContext) throws AxisFault {
+        this.configurationContext = configurationContext;
+        httpConfiguration = configurationContext.getAxisConfiguration().getTransportIn(HTTP_NAME);
+        port = getIntParam(PARAMETER_PORT, 8080);
+        hostAddress = getStringParam(PARAMETER_HOST_ADDRESS, null);
+        originServer = getStringParam(PARAMETER_ORIGIN_SERVER, "Simple-Server/1.1");
+        requestSocketTimeout = getIntParam(PARAMETER_REQUEST_SOCKET_TIMEOUT, 20000);
+        requestTcpNoDelay = getBooleanParam(PARAMETER_REQUEST_TCP_NO_DELAY, true);
+        requestCoreThreadPoolSize = getIntParam(PARAMETER_REQUEST_CORE_THREAD_POOL_SIZE, 25);
+        requestMaxThreadPoolSize = getIntParam(PARAMETER_REQUEST_MAX_THREAD_POOL_SIZE, 150);
+        threadKeepAliveTime = getLongParam(PARAMETER_THREAD_KEEP_ALIVE_TIME, 180L);
+        threadKeepAliveTimeUnit = getTimeUnitParam(PARAMETER_THREAD_KEEP_ALIVE_TIME_UNIT, TimeUnit.SECONDS);
+    }
+    
+    /** Create and configure a new HttpFactory */
+    public HttpFactory(ConfigurationContext configurationContext, int port) throws AxisFault {
+        this(configurationContext);
+        this.port = port;
+    }
+    
+    /** Create and configure a new HttpFactory */
+    public HttpFactory(ConfigurationContext configurationContext, int port, WorkerFactory requestWorkerFactory) throws AxisFault {
+        this(configurationContext, port);
+        this.requestWorkerFactory = requestWorkerFactory;
+    }
+
+    private int getIntParam(String name, int def) {
+        String config = getStringParam(name, null);
+        if (config!=null)
+            return Integer.parseInt(config);
+        else 
+            return def;
+    }
+    
+    private long getLongParam(String name, long def) {
+        String config = getStringParam(name, null);
+        if (config!=null)
+            return Long.parseLong(config);
+        else 
+            return def;
+    }
+    
+    private boolean getBooleanParam(String name, boolean def) throws AxisFault {
+        String config = getStringParam(name, null);
+        if (config!=null) {
+            if (config.equals("yes") || config.equals("true"))
+                return true;
+            else if (config.equals("no") || config.equals("false"))
+                return false;
+            else throw new AxisFault("Boolean value must be yes, true, no or false for parameter " + name + ":  " + config);
+        }
+        return def;
+    }
+    
+    private TimeUnit getTimeUnitParam(String name, TimeUnit def) throws AxisFault {
+        String config = getStringParam(name, null);
+        if (config!=null)
+            try {
+                return (TimeUnit) TimeUnit.class.getField(config).get(null);
+            } catch (Exception e) {
+                throw new AxisFault(e);
+            }
+        return def;
+    }
+        
+    private String getStringParam(String name, String def) {
+        Parameter param = httpConfiguration.getParameter(name);
+        if (param!=null) {
+            assert param.getParameterType() == Parameter.TEXT_PARAMETER;
+            String config = (String) param.getValue();
+            if (config!=null)
+                return config;
+        }
+        return def;
+    }
+    
+    /** Return the configured listener manager or create and configure one with configurationContext */
+    public ListenerManager getListenerManager() {
+        ListenerManager lm = configurationContext.getListenerManager();
+        if (lm==null) {
+            lm = new ListenerManager();
+            lm.init(configurationContext);
+        }
+        return lm;
+    }
+    
+    /** Create the executor used to launch the single requestConnectionListener */
+    public ExecutorService newListenerExecutor(int port) {
+        return new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,
+                new LinkedBlockingQueue(),
+                new DefaultThreadFactory(new ThreadGroup("Listener thread group"), "HttpListener-" + this.port));
+    }
+    
+    /** Create the listener for request connections */
+    public IOProcessor newRequestConnectionListener(HttpConnectionFactory factory, HttpConnectionManager manager, int port) throws IOException {
+        return new DefaultConnectionListener(port, factory, manager);
+    }
+    
+    /** Create a request connection */
+    public HttpConnectionFactory newRequestConnectionFactory(HttpParams params) {
+        return new DefaultHttpConnectionFactory(params);
+    }
+    
+    /** Create and set the parameters applied to incoming request connections */
+    public HttpParams newRequestConnectionParams() {
+        HttpParams params = new DefaultHttpParams(); 
+        params
+            .setIntParameter(HttpConnectionParams.SO_TIMEOUT, requestSocketTimeout)
+            .setBooleanParameter(HttpConnectionParams.TCP_NODELAY, requestTcpNoDelay) 
+            .setParameter(HttpProtocolParams.ORIGIN_SERVER, originServer);
+        return params;
+    }
+    
+    /** Create the connection manager used to launch request threads */
+    public HttpConnectionManager newRequestConnectionManager(ExecutorService requestExecutor, WorkerFactory workerFactory, HttpParams params) {
+        return new DefaultHttpConnectionManager(requestExecutor, workerFactory, params);
+    }
+    
+    /** Create the executor use the manage request processing threads */
+    public ExecutorService newRequestExecutor(int port) {
+        return new ThreadPoolExecutor(requestCoreThreadPoolSize, requestMaxThreadPoolSize, threadKeepAliveTime, threadKeepAliveTimeUnit,
+                                      newRequestBlockingQueue(),
+                                      new DefaultThreadFactory(new ThreadGroup("Connection thread group"), "HttpConnection-" + port));
+    }
+    
+    /** Create the queue used to hold incoming requests when requestCoreThreadPoolSize threads are busy.
+     * Default is an unbounded queue.
+     */
+    public BlockingQueue newRequestBlockingQueue() {
+        return new LinkedBlockingQueue();
+    }
+    
+    /** Create the factory for request workers */
+    public WorkerFactory newRequestWorkerFactory() {
+        if (requestWorkerFactory!=null)
+            return requestWorkerFactory;
+        else
+            return new HTTPWorkerFactory(configurationContext);
+    }
+
+    /** Create a request service processor to populate the response */
+    public HttpServiceProcessor newRequestServiceProcessor(HttpServerConnection connection, Worker worker, IOProcessorCallback callback) {
+        return new DefaultHttpServiceProcessor(connection, worker, callback);
+    }
+    
+    // *****
+    // Getters and Setters
+    // *****
+
+    /** Getter for configurationContext */
+    public ConfigurationContext getConfigurationContext() {
+        return configurationContext;
+    }
+
+    /** Getter for httpConfiguration */
+    public TransportInDescription getHttpConfiguration() {
+        return httpConfiguration;
+    }
+
+    /** Getter for port
+      * return the port on which to listen for http connections (default = 8080)
+     */
+    public int getPort() {
+        return port;
+    }
+
+    /** Setter for port */
+    public void setPort(int port) {
+        this.port = port;
+    }
+
+    /** Getter for hostAddress
+     * @return the host address (or name) to be use in reply-to endpoint references, or null if not specified (default = null)
+     */
+    public String getHostAddress() {
+        return hostAddress;
+    }
+
+    /** Setter for hostAddress */
+    public void setHostAddress(String hostAddress) {
+        this.hostAddress = hostAddress;
+    }
+
+    /** Getter for originServer
+     * @return the Server header string for outgoing messages (default "Simple-Server/1.1")
+     */
+    public String getOriginServer() {
+        return originServer;
+    }
+
+    /** Setter for originServer */
+    public void setOriginServer(String originServer) {
+        this.originServer = originServer;
+    }
+
+    /** Getter for requestSocketTimeout
+     * @return the maximum time in millis to wait for data on a request socket (default 20000)
+     */
+    public int getRequestSocketTimeout() {
+        return requestSocketTimeout;
+    }
+
+    /** Setter for requestSocketTimeout */
+    public void setRequestSocketTimeout(int requestSocketTimeout) {
+        this.requestSocketTimeout = requestSocketTimeout;
+    }
+
+    /** Getter for requestTcpNoDelay
+     * return false iff Nagle's algorithm should be used to conserve bandwidth by minimizing segments
+     *              at the cost of latency and performance (default true, i.e. maximize performance at
+     *              the cost of bandwidth)
+     */
+    public boolean getRequestTcpNoDelay() {
+        return requestTcpNoDelay;
+    }
+
+    /** Setter for requestTcpNoDelay */
+    public void setRequestTcpNoDelay(boolean requestTcpNoDelay) {
+        this.requestTcpNoDelay = requestTcpNoDelay;
+    }
+
+    /** Getter for RequestCoreThreadPoolSize
+     * @return the size of the thread pool use to process requests assuming there is adequate queue space (default 25)
+     */
+    public int getRequestCoreThreadPoolSize() {
+        return requestCoreThreadPoolSize;
+    }
+
+    /** Setter for RequestCoreThreadPoolSize */
+    public void setRequestCoreThreadPoolSize(int requestCoreThreadPoolSize) {
+        this.requestCoreThreadPoolSize = requestCoreThreadPoolSize;
+    }
+
+    /** Getter for requestMaxThreadPoolSize
+     * @return the maximum size of the thread pool used to process requests if the queue fills up (default 150).
+     *         Since the default queue is unbounded this parameter is meaningless unless you override newRequestBlockingQueue()
+     */
+    public int getRequestMaxThreadPoolSize() {
+        return requestMaxThreadPoolSize;
+    }
+
+    /** Setter for requestMaxThreadPoolSize */
+    public void setRequestMaxThreadPoolSize(int requestMaxThreadPoolSize) {
+        this.requestMaxThreadPoolSize = requestMaxThreadPoolSize;
+    }
+
+    /** Getter for threadKeepAliveTime
+     * @return how long a request processing thread in excess of the core pool size will be kept alive it if is inactive
+     *         (default with threadKeepAliveTimeUnit to 180 seconds)
+     */
+    public long getThreadKeepAliveTime() {
+        return threadKeepAliveTime;
+    }
+
+    /** Setter for threadKeepAliveTime */
+    public void setThreadKeepAliveTime(long threadKeepAliveTime) {
+        this.threadKeepAliveTime = threadKeepAliveTime;
+    }
+
+    /** Getter for threadKeepAliveTimeUnit
+     * return the time unit for threadKeepAliveTime (default SECONDS)
+     */
+    public TimeUnit getThreadKeepAliveTimeUnit() {
+        return threadKeepAliveTimeUnit;
+    }
+
+    /** Setter for threadKeepAliveTimeUnit */
+    public void setThreadKeepAliveTimeUnit(TimeUnit threadKeepAliveTimeUnit) {
+        this.threadKeepAliveTimeUnit = threadKeepAliveTimeUnit;
+    }
+
+}
Index: modules/core/src/org/apache/axis2/transport/http/server/IOProcessor.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/IOProcessor.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/IOProcessor.java	(revision 0)
@@ -0,0 +1,42 @@
+/*
+ * $HeadURL$
+ * $Revision$
+ * $Date$
+ *
+ * ====================================================================
+ *
+ *  Copyright 1999-2006 The Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.axis2.transport.http.server;
+
+import java.io.IOException;
+
+public interface IOProcessor extends Runnable {
+
+    void close() throws IOException;
+    
+    boolean isDestroyed();
+    
+    void destroy();
+    
+}
Index: modules/core/src/org/apache/axis2/transport/http/server/SimpleHttpServer.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/SimpleHttpServer.java	(revision 412455)
+++ modules/core/src/org/apache/axis2/transport/http/server/SimpleHttpServer.java	(working copy)
@@ -1,5 +1,5 @@
 /*
-* $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//httpclient/src/test/org/apache/commons/httpclient/server/SimpleHttpServer.java,v 1.15 2004/12/11 22:35:26 olegk Exp $
+* $HeadURL$
 * $Revision: 155418 $
 * $Date: 2005-02-26 08:01:52 -0500 (Sat, 26 Feb 2005) $
 *
@@ -30,232 +30,100 @@
 
 package org.apache.axis2.transport.http.server;
 
-import org.apache.axis2.util.threadpool.ThreadFactory;
-import org.apache.axis2.util.threadpool.ThreadPool;
+import java.io.IOException;
+import org.apache.axis2.context.ConfigurationContext;
+
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
+import org.apache.http.impl.DefaultHttpParams;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.params.HttpProtocolParams;
+
+import edu.emory.mathcs.backport.java.util.concurrent.ExecutorService;
+import edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingQueue;
+import edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor;
+import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
 
 /**
- * A simple, but extensible HTTP server, mostly for testing purposes.
+ * A simple, but configurable and extensible HTTP server.
  */
-public class SimpleHttpServer implements Runnable {
-	private static final Log log = LogFactory.getLog(SimpleHttpServer.class);
-    private String testname = "Simple test";
-    private ServerSocket listener = null;
-    private long count = 0;
-    private ThreadFactory threadPool = null;
-    private boolean stopped = false;
-    private HttpRequestHandler requestHandler = null;
-    private SimpleConnSet connectionsPool = new SimpleConnSet();
-    private Thread t;
-
-    /**
-     * Creates a new HTTP server instance, using an arbitrary free TCP port
-     *
-     * @throws IOException if anything goes wrong during initialization
-     */
-    public SimpleHttpServer() throws IOException {
-        this(null, 0, null);
-    }
-
-    /**
-     * Creates a new HTTP server instance, using the specified TCP port
-     *
-     * @param port Desired TCP port
-     * @throws IOException if anything goes wrong during initialization
-     */
-    public SimpleHttpServer(int port) throws IOException {
-        this(null, port, null);
-    }
-
-    /**
-     * Creates a new HTTP server instance, using the specified TCP port
-     *
-     * @param port       Desired TCP port
-     * @param threadPool ThreadPool to be used.
-     * @throws IOException if anything goes wrong during initialization
-     */
-    public SimpleHttpServer(int port, ThreadFactory threadPool) throws IOException {
-        this(null, port, threadPool);
-    }
-
-    /**
-     * Creates a new HTTP server instance, using the specified socket
-     * factory and the TCP port
-     *
-     * @param port Desired TCP port
-     * @throws IOException if anything goes wrong during initialization
-     */
-    public SimpleHttpServer(SimpleSocketFactory socketfactory, int port) throws IOException {
-        this(socketfactory, port, null);
-    }
-
-    /**
-     * Creates a new HTTP server instance, using the specified socket
-     * factory and the TCP port that uses the given ThreadPool. If a
-     * ThreadPool is not given then a new default axis2 ThreadPool will be
-     * used.
-     *
-     * @param port       Desired TCP port
-     * @param threadPool ThreadPool to be used inside the SimpleHttpServer. The
-     *                   threadPool object that is provided needs to implement
-     *                   tp.execute(Runnable r)
-     * @throws IOException if anything goes wrong during initialization
-     */
-    public SimpleHttpServer(SimpleSocketFactory socketfactory, int port, ThreadFactory threadPool)
-            throws IOException {
-        if (socketfactory == null) {
-            socketfactory = new SimplePlainSocketFactory();
-        }
-
-        if (threadPool == null) {
-            threadPool = new ThreadPool();
-        }
-
-        this.threadPool = threadPool;
-        listener = socketfactory.createServerSocket(port);
-
-        if (log.isDebugEnabled()) {
-            log.debug("Starting test HTTP server on port " + getLocalPort());
-        }
-
-        t = new Thread(this);
-        t.start();
-    }
-
-    /**
-     * Stops this HTTP server instance.
-     */
-    public synchronized void destroy() {
-        if (stopped) {
-            return;
-        }
-
-        this.stopped = true;
-
-        if (log.isDebugEnabled()) {
-            log.debug("Stopping test HTTP server on port " + getLocalPort());
-        }
-
-        t.interrupt();
-
-        if (listener != null) {
-            try {
-                listener.close();
-            } catch (IOException e) {
-            }
-        }
-
-        this.connectionsPool.shutdown();
-    }
-
-    public void run() {
-        try {
-            while (!this.stopped && !Thread.interrupted()) {
-                Socket socket = listener.accept();
-
-                try {
-                    if (this.requestHandler == null) {
-                        socket.close();
-
-                        break;
-                    }
-
-                    SimpleHttpServerConnection conn = new SimpleHttpServerConnection(socket);
-
-                    this.connectionsPool.addConnection(conn);
-                    this.threadPool.execute(new SimpleConnectionThread(this.testname + " thread "
-                            + this.count, conn, this.connectionsPool, this.requestHandler));
-                } catch (IOException e) {
-                    log.debug("I/O error: " + e.getMessage());
-                }
-
-                this.count++;
-                Thread.sleep(100);
-            }
-        } catch (InterruptedException accept) {
-        }
-        catch (IOException e) {
-            if (!stopped) {
-                log.debug("I/O error: " + e.getMessage());
-            }
-        } finally {
-            destroy();
-        }
-    }
-
-    /**
-     * Returns the IP address that this HTTP server instance is bound to.
-     *
-     * @return String representation of the IP address or <code>null</code> if not running
-     */
-    public String getLocalAddress() {
-        InetAddress address = listener.getInetAddress();
-
-        // Ugly work-around for older JDKs
-        byte[] octets = address.getAddress();
+public class SimpleHttpServer {
 
-        if ((octets[0] == 0) && (octets[1] == 0) && (octets[2] == 0) && (octets[3] == 0)) {
-            return "localhost";
-        } else {
-            return address.getHostAddress();
-        }
-    }
-
-    /**
-     * Returns the TCP port that this HTTP server instance is bound to.
-     *
-     * @return TCP port, or -1 if not running
-     */
-    public int getLocalPort() {
-        return listener.getLocalPort();
-    }
-
-    /**
-     * Returns the currently used HttpRequestHandler by this SimpleHttpServer
-     *
-     * @return The used HttpRequestHandler, or null.
-     */
-    public HttpRequestHandler getRequestHandler() {
-        return requestHandler;
-    }
-
-    public String getTestname() {
-        return this.testname;
+    private static Log LOG = LogFactory.getLog(SimpleHttpServer.class);
+    
+    private static final String ORIGIN_SERVER = "Simple-Server/1.1";
+    private static final int SHUTDOWN_GRACE_PERIOD = 3000; // ms
+    
+    private HttpFactory httpFactory;
+    private final int port;
+    private final HttpParams params;
+    private final WorkerFactory workerFactory;
+    
+    private IOProcessor listener = null;
+    private ExecutorService listenerExecutor = null;
+    private ThreadGroup listenertg = null;
+    private HttpConnectionManager connmanager = null;
+    private ExecutorService requestExecutor = null;
+    private ThreadGroup conntg = null;
+
+    public SimpleHttpServer(ConfigurationContext configurationContext, WorkerFactory workerFactory, int port) throws IOException {
+        this(new HttpFactory(configurationContext, port, workerFactory), port);
+    }
+    
+    public SimpleHttpServer(HttpFactory httpFactory, int port) throws IOException {
+        this.httpFactory = httpFactory;
+        this.port = port;
+        this.workerFactory = httpFactory.newRequestWorkerFactory();
+        this.params = httpFactory.newRequestConnectionParams();
+    }
+
+    public void init() throws IOException {
+        requestExecutor = httpFactory.newRequestExecutor(port);
+        connmanager = httpFactory.newRequestConnectionManager(requestExecutor, workerFactory, params);
+        listenerExecutor = httpFactory.newListenerExecutor(port);
+        listener = httpFactory.newRequestConnectionListener(httpFactory.newRequestConnectionFactory(params),
+                                                            httpFactory.newRequestConnectionManager(requestExecutor, workerFactory, params),
+                                                            port);
+    }
+    
+    public void destroy() throws IOException, InterruptedException {
+        // Attempt to terminate the listener nicely
+        LOG.info("Shut down connection listener");
+        this.listenerExecutor.shutdownNow();
+        this.listener.destroy();
+        this.listenerExecutor.awaitTermination(SHUTDOWN_GRACE_PERIOD, TimeUnit.MILLISECONDS);
+        if (!this.listenerExecutor.isTerminated()) {
+            // Terminate the listener forcibly
+            LOG.info("Force shut down connection listener");
+            this.listener.destroy();
+            // Leave it up to the garbage collector to clean up the mess
+            this.listener = null;
+        }
+        // Attempt to terminate the active processors nicely
+        LOG.info("Shut down HTTP processors");
+        this.requestExecutor.shutdownNow();
+        this.requestExecutor.awaitTermination(SHUTDOWN_GRACE_PERIOD, TimeUnit.MILLISECONDS);
+        if (!this.requestExecutor.isTerminated()) {
+            // Terminate the active processors forcibly
+            LOG.info("Force shut down HTTP processors");
+            this.connmanager.shutdown();
+            // Leave it up to the garbage collector to clean up the mess
+            this.connmanager = null;
+        }
+        LOG.info("HTTP protocol handler shut down");
+    }
+    
+    public void start() {
+        this.listenerExecutor.execute(this.listener);
     }
-
-    /**
-     * Checks if this HTTP server instance is running.
-     *
-     * @return true/false
-     */
+    
     public boolean isRunning() {
-        if (t == null) {
-            return false;
-        }
-
-        return t.isAlive();
-    }
-
-    public void setHttpService(HttpService service) {
-        setRequestHandler(new HttpServiceHandler(service));
-    }
-
-    /**
-     * Sets the HttpRequestHandler to be used for this SimpleHttpServer.
-     *
-     * @param rh Request handler to be used, or null to disable.
-     */
-    public void setRequestHandler(HttpRequestHandler rh) {
-        this.requestHandler = rh;
+        return this.listenerExecutor != null && !this.listenerExecutor.isShutdown();
     }
 
-    public void setTestname(final String testname) {
-        this.testname = testname;
+    public int getPort() {
+        return this.port;
     }
+    
 }
Index: modules/core/src/org/apache/axis2/transport/http/server/OutputBuffer.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/server/OutputBuffer.java	(revision 0)
+++ modules/core/src/org/apache/axis2/transport/http/server/OutputBuffer.java	(revision 0)
@@ -0,0 +1,151 @@
+/*
+* $HeadURL$
+* $Revision$
+* $Date$
+*
+* ====================================================================
+*
+*  Copyright 1999-2004 The Apache Software Foundation
+*
+*  Licensed under the Apache License, Version 2.0 (the "License");
+*  you may not use this file except in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing, software
+*  distributed under the License is distributed on an "AS IS" BASIS,
+*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+*  See the License for the specific language governing permissions and
+*  limitations under the License.
+* ====================================================================
+*
+* This software consists of voluntary contributions made by many
+* individuals on behalf of the Apache Software Foundation.  For more
+* information on the Apache Software Foundation, please see
+* <http://www.apache.org/>.
+*/
+package org.apache.axis2.transport.http.server;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import org.apache.axis2.transport.OutTransportInfo;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.io.ByteArrayBuffer;
+import org.apache.http.protocol.HTTP;
+
+public class OutputBuffer implements OutTransportInfo, HttpEntity {
+
+    private final ByteArrayBuffer buffer;
+    private String contentType;
+    private boolean chunked;
+    
+    public OutputBuffer(int initialCapacity) {
+        super();
+        this.buffer = new ByteArrayBuffer(initialCapacity);
+        this.contentType = "text/xml";
+    }
+    
+    public OutputBuffer() {
+        this(1024);
+    }
+
+    public OutputStream getOutputStream() {
+        return new BufferOutputStream(this.buffer);
+    }
+
+    public InputStream getContent() throws IOException, IllegalStateException {
+        return new ByteArrayInputStream(this.buffer.toByteArray());
+    }
+
+    public void setContentType(final String contentType) {
+        this.contentType = contentType;
+    }
+
+    public Header getContentType() {
+        return new Header(HTTP.CONTENT_TYPE, this.contentType);
+    }
+
+    public void consumeContent() throws IOException {
+    }
+
+    public Header getContentEncoding() {
+        return null;
+    }
+
+    public long getContentLength() {
+        return this.buffer.length();
+    }
+
+    public boolean isChunked() {
+        return this.chunked;
+    }
+
+    public void setChunked(boolean b) {
+        this.chunked = b;
+    }
+
+    public boolean isRepeatable() {
+        return true;
+    }
+
+    public boolean isStreaming() {
+        return false;
+    }
+
+    public void writeTo(final OutputStream outstream) throws IOException {
+        outstream.write(this.buffer.buffer(), 0, this.buffer.length());
+    }
+
+    public String toString() {
+        return new String(this.buffer.buffer(), 0, this.buffer.length());
+    }
+    
+    private static class BufferOutputStream extends OutputStream {
+
+        private final ByteArrayBuffer buffer;
+        private boolean closed = false;
+
+        public BufferOutputStream(final ByteArrayBuffer buffer) {
+            super();
+            this.buffer = buffer;
+        }
+        
+        public void close() throws IOException {
+            this.closed = true;
+        }
+
+        private void ensureNotClosed() {
+            if (this.closed) {
+                throw new IllegalStateException("Stream closed");
+            }
+        }
+        
+        public void write(byte[] b, int off, int len) throws IOException {
+            ensureNotClosed();
+            if (b == null) {
+                return;
+            }
+            this.buffer.append(b, off, len);
+        }
+
+        public void write(byte[] b) throws IOException {
+            ensureNotClosed();
+            if (b == null) {
+                return;
+            }
+            this.buffer.append(b, 0, b.length);
+        }
+
+        public void write(int b) throws IOException {
+            ensureNotClosed();
+            this.buffer.append(b);
+        }
+                
+    }
+    
+}
Index: modules/core/src/org/apache/axis2/transport/http/ListingAgent.java
===================================================================
--- modules/core/src/org/apache/axis2/transport/http/ListingAgent.java	(revision 412455)
+++ modules/core/src/org/apache/axis2/transport/http/ListingAgent.java	(working copy)
@@ -241,7 +241,7 @@
 
         private int port;
         private String schema;
-        private String conetxtPath;
+        private String contextPath;
 
         public HTTPSTListener(int port, String schema) {
             this.port = port;
@@ -250,7 +250,7 @@
 
         public void init(ConfigurationContext axisConf,
                          TransportInDescription transprtIn) throws AxisFault {
-            conetxtPath = axisConf.getContextPath();
+            contextPath = axisConf.getContextPath();
         }
 
         public void start() throws AxisFault {
@@ -260,7 +260,7 @@
         }
 
         public EndpointReference getEPRForService(String serviceName, String ip) throws AxisFault {
-            return new EndpointReference(schema + "://" + ip + ":" + port + conetxtPath + "/" + serviceName);
+            return new EndpointReference(schema + "://" + ip + ":" + port + contextPath + "/" + serviceName);
         }
     }
 
Index: modules/core/src/org/apache/axis2/engine/AxisEngine.java
===================================================================
--- modules/core/src/org/apache/axis2/engine/AxisEngine.java	(revision 412455)
+++ modules/core/src/org/apache/axis2/engine/AxisEngine.java	(working copy)
@@ -202,10 +202,11 @@
         }
 
         EndpointReference faultTo = processingContext.getFaultTo();
+        SOAPEnvelope env = processingContext.getEnvelope();
         if (faultTo != null && !doNotSendFaultUsingFaultTo) {
             faultContext.setTo(processingContext.getFaultTo());
-        } else if (!doNotSendFaultUsingFaultTo && processingContext.isHeaderPresent() && processingContext.getEnvelope().getHeader().getFirstChildWithName(new QName("FaultTo")) != null) {
-            OMElement faultToElement = processingContext.getEnvelope().getHeader().getFirstChildWithName(new QName("FaultTo"));
+        } else if (env != null && !doNotSendFaultUsingFaultTo && processingContext.isHeaderPresent() && env.getHeader().getFirstChildWithName(new QName("FaultTo")) != null) {
+            OMElement faultToElement = env.getHeader().getFirstChildWithName(new QName("FaultTo"));
             faultTo = new EndpointReference("");
             faultTo.fromOM(faultToElement);
             faultContext.setTo(faultTo);
@@ -339,7 +340,7 @@
         }
 
         // defaulting to fault code Sender, if no message is available
-        if (faultCode == null) {
+        if (faultCode == null && context.getEnvelope() != null) {
             soapFaultCode = ("".equals(soapFaultCode) || (soapFaultCode == null))
                     ? getSenderFaultCode(context.getEnvelope().getNamespace())
                     : soapFaultCode;
Index: modules/jibx/project.xml
===================================================================
--- modules/jibx/project.xml	(revision 412455)
+++ modules/jibx/project.xml	(working copy)
@@ -122,6 +122,14 @@
             </properties>
         </dependency>
         <dependency>
+            <groupId>jakarta-httpcore</groupId>
+            <artifactId>jakarta-httpcore</artifactId>
+            <version>${jakarta.httpcore.version}</version>
+            <properties>
+                <module>true</module>
+            </properties>
+        </dependency> 
+        <dependency>
             <groupId>backport-util-concurrent</groupId>
             <artifactId>backport-util-concurrent</artifactId>
             <version>${backport_util_concurrent.version}</version>
Index: modules/codegen/project.xml
===================================================================
--- modules/codegen/project.xml	(revision 412455)
+++ modules/codegen/project.xml	(working copy)
@@ -95,6 +95,14 @@
             </properties>
         </dependency>
         <dependency>
+            <groupId>jakarta-httpcore</groupId>
+            <artifactId>jakarta-httpcore</artifactId>
+            <version>${jakarta.httpcore.version}</version>
+            <properties>
+                <module>true</module>
+            </properties>
+        </dependency> 
+        <dependency>
             <groupId>${stax.impl.groupid}</groupId>
             <artifactId>${stax.impl.artifactid}</artifactId>
             <version>${stax.impl.version}</version>
Index: modules/saaj/project.xml
===================================================================
--- modules/saaj/project.xml	(revision 412455)
+++ modules/saaj/project.xml	(working copy)
@@ -83,7 +83,7 @@
     </build>
 
     <dependencies>
-               <dependency>
+        <dependency>
             <groupId>ws-commons</groupId>
             <artifactId>axiom-api</artifactId>
             <version>${axiom.version}</version>
@@ -133,6 +133,14 @@
             </properties>
         </dependency>
         <dependency>
+            <groupId>jakarta-httpcore</groupId>
+            <artifactId>jakarta-httpcore</artifactId>
+            <version>${jakarta.httpcore.version}</version>
+            <properties>
+                <module>true</module>
+            </properties>
+        </dependency> 
+        <dependency>
             <groupId>${stax.impl.groupid}</groupId>
             <artifactId>${stax.impl.artifactid}</artifactId>
             <version>${stax.impl.version}</version>
Index: etc/project.properties
===================================================================
--- etc/project.properties	(revision 412455)
+++ etc/project.properties	(working copy)
@@ -105,6 +105,7 @@
 geronimo.spec.javamail.version=1.3.1-rc5
 geronimo.spec.jms.version=1.1-rc4
 groovy.all.version=1.0-jsr-01
+jakarta.httpcore.version=4.0-20060602
 jaxbri.version=2.0EA3
 jaxen.version=1.1-beta-8
 jaxme.version=0.5.1
@@ -159,6 +160,7 @@
 maven.jar.geronimo-spec-javamail=${dependencies.dir}/geronimo-spec-javamail-${geronimo.spec.javamail.version}.jar
 maven.jar.geronimo-spec-jms=${dependencies.dir}/geronimo-spec-jms-${geronimo.spec.jms.version}.jar
 maven.jar.groovy-all=${dependencies.dir}/groovy-all-${groovy.all.version}.jar
+maven.jar.jakarta-httpcore=${dependencies.dir}/jakarta-httpcore-${jakarta.httpcore.version}.jar
 maven.jar.jaxen=${dependencies.dir}/jaxen-${jaxen.version}.jar
 maven.jar.jaxme2=${dependencies.dir}/jaxme2-${jaxme.version}.jar
 maven.jar.jaxmeapi=${dependencies.dir}/jaxmeapi-${jaxme.version}.jar
