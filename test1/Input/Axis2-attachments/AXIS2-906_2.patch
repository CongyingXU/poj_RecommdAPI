Index: modules/adb-codegen/src/org/apache/axis2/schema/BeanWriterMetaInfoHolder.java
===================================================================
--- modules/adb-codegen/src/org/apache/axis2/schema/BeanWriterMetaInfoHolder.java	(revision 425831)
+++ modules/adb-codegen/src/org/apache/axis2/schema/BeanWriterMetaInfoHolder.java	(working copy)
@@ -38,7 +38,9 @@
     protected boolean choice = false;
 
     protected boolean extension = false;
+    protected boolean restriction = false;
     private String extensionClassName = "";
+    private String restrictionClassName = "";
     protected Map elementToSchemaQNameMap = new LinkedHashMap();
     protected Map elementToJavaClassMap = new LinkedHashMap();
     protected Map specialTypeFlagMap = new LinkedHashMap();
@@ -147,7 +149,39 @@
         this.extension = extension;
     }
 
+    public String getRestrictionClassName() {
+        return restrictionClassName;
+    }
+    
     /**
+     * Sets the restriction base class name. Valid only when the isRestriction
+     * returns true.
+     *
+     * @param restrictionClassName
+     */
+    public void setRestrictionClassName(String restrictionClassName) {
+        this.restrictionClassName = restrictionClassName;
+    }
+    
+    /**
+     * Gets the restriction status.
+     *
+     * @return Returns boolean.
+     */
+    public boolean isRestriction() {
+        return restriction;
+    }
+    
+    /**
+     * Sets the restriction status.
+     *
+     * @param restriction
+     */
+    public void setRestriction(boolean restriction) {
+        this.restriction = restriction;
+    }
+    
+    /**
      * Gets the ordered status.
      *
      * @return Returns boolean.
Index: modules/adb-codegen/src/org/apache/axis2/schema/template/ADBBeanTemplate.xsl
===================================================================
--- modules/adb-codegen/src/org/apache/axis2/schema/template/ADBBeanTemplate.xsl	(revision 425831)
+++ modules/adb-codegen/src/org/apache/axis2/schema/template/ADBBeanTemplate.xsl	(working copy)
@@ -41,6 +41,7 @@
         <xsl:variable name="originalName" select="@originalName"/>
         <xsl:variable name="nsprefix" select="@nsprefix"/>
         <xsl:variable name="extension" select="@extension"/>
+        <xsl:variable name="restriction" select="@restriction"/>
         <xsl:variable name="mapperClass" select="@mapperClass"/>
     <!-- write the class header. this should be done only when unwrapped -->
 
@@ -57,7 +58,7 @@
             *  <xsl:value-of select="$name"/> bean class
             */
         </xsl:if>
-        public <xsl:if test="not(@unwrapped) or (@skip-write)">static</xsl:if> class <xsl:value-of select="$name"/> <xsl:if test="$extension"> extends <xsl:value-of select="$extension"/></xsl:if>
+        public <xsl:if test="not(@unwrapped) or (@skip-write)">static</xsl:if> class <xsl:value-of select="$name"/> <xsl:if test="$extension"> extends <xsl:value-of select="$extension"/></xsl:if> <xsl:if test="$restriction"> extends <xsl:value-of select="$restriction"/></xsl:if>
         implements org.apache.axis2.databinding.ADBBean{
         <xsl:choose>
             <xsl:when test="@type">/* This type was generated from the piece of schema that had
@@ -99,11 +100,101 @@
             <xsl:variable name="varName">local<xsl:value-of select="$javaName"/></xsl:variable>
             <xsl:variable name="settingTracker">local<xsl:value-of select="$javaName"/>Tracker</xsl:variable>
 
+			<xsl:choose>
+            <xsl:when test="(@restricted) and (@removed)">
+           
+           /**
+           * Auto generated getter method
+           * Overridden from <xsl:value-of select="$restriction"/>
+           *
+           * @throws RuntimeException
+           */
+           public  <xsl:value-of select="$propertyType"/><xsl:text> </xsl:text>get<xsl:value-of select="$javaName"/>(){
+               throw new java.lang.RuntimeException();
+           }
+           
+           /**
+           * Auto generated setter method
+           * Overridden from <xsl:value-of select="$restriction"/>
+           *
+           * @param param <xsl:value-of select="$javaName"/>
+           * @throws RuntimeException
+           */
+           public void set<xsl:value-of select="$javaName"/>(<xsl:value-of select="$propertyType"/> param){
+           	   throw new java.lang.RuntimeException();
+           }
+               
+           </xsl:when>
+           <xsl:otherwise>
+               <xsl:choose>
+               <xsl:when test="(@restricted) and (@occuranceChanged)">
+               		<xsl:variable name="basePropertyType"><xsl:value-of select="@arrayBaseType"/></xsl:variable>
 
+
+                   <!-- generate the validator Method, this is specifiacally for validating the arrays-->
+                  /**
+                   * Validate the array for <xsl:value-of select="$javaName"/>
+                   * Overridden from <xsl:value-of select="$restriction"/>
+                   */
+                  protected void validate<xsl:value-of select="$javaName"/>(<xsl:value-of select="$propertyType"/> param){
+                     <xsl:if test="not(@unbound)">
+                          if (param.length &gt; <xsl:value-of select="@maxOccurs"/>){
+                            throw new java.lang.RuntimeException();
+                          }
+                      </xsl:if>
+                      <xsl:if test="$min!=0">
+                          if (param.length &lt; <xsl:value-of select="$min"/>){
+                            throw new java.lang.RuntimeException();
+                          }
+                      </xsl:if>
+                  }
+
+
+                 /**
+                  * Auto generated setter method
+                  * Overridden from <xsl:value-of select="$restriction"/>
+                  *
+                  * @param param <xsl:value-of select="$javaName"/>
+                  */
+                  public void set<xsl:value-of select="$javaName"/>(<xsl:value-of select="$propertyType"/> param){
+                   <!-- call the validator-->
+                  		validate<xsl:value-of select="$javaName"/>(param);
+
+                   <xsl:if test="$choice">
+                        clearAllSettingTrackers();
+                   </xsl:if>
+                   <xsl:if test="$min=0 or $choice">
+                       <!-- the updating of setting tracker for null values should
+                            happen if the attribute is marked as nillable. Else
+                            the user can set a null value and it is never marked
+                            as set
+                       -->
+                       <xsl:choose>
+                          <xsl:when test="not(@nillable) and not(@primitive)">
+                              if (param !=null){
+                              //update the setting tracker
+                              <xsl:value-of select="$settingTracker"/> = true;
+                               }
+                           </xsl:when>
+                           <xsl:otherwise>
+                               //update the setting tracker
+                              <xsl:value-of select="$settingTracker"/> = true;
+                           </xsl:otherwise>
+                       </xsl:choose>
+                   </xsl:if>
+                  this.<xsl:value-of select="$varName"/>=param;
+                  }
+               </xsl:when>
+               <xsl:otherwise>
+               
             /**
             * field for <xsl:value-of select="$javaName"/>
             <xsl:if test="@attribute">* This was an Attribute!</xsl:if>
             <xsl:if test="@array">* This was an Array!</xsl:if>
+            <xsl:if test="(@restricted) and (@typeChanged)">
+            * Type of this field is a subtype of its original.</xsl:if>
+            <xsl:if test="(@rewrite) and (@occuranceChanged)">
+            * This field was an array in <xsl:value-of select="$restriction"/>.</xsl:if> 
             */
 
             protected <xsl:value-of select="$propertyType"/><xsl:text> </xsl:text><xsl:value-of select="$varName" /> ;
@@ -239,8 +330,13 @@
                    }
                 </xsl:otherwise>
             </xsl:choose>
+			
+			</xsl:otherwise>
+            </xsl:choose>
+            
+			</xsl:otherwise>
+            </xsl:choose>
 
-
              <!-- end of xsl:if for not(@inherited) -->
             </xsl:if>
 
Index: modules/adb-codegen/src/org/apache/axis2/schema/SchemaCompiler.java
===================================================================
--- modules/adb-codegen/src/org/apache/axis2/schema/SchemaCompiler.java	(revision 425831)
+++ modules/adb-codegen/src/org/apache/axis2/schema/SchemaCompiler.java	(working copy)
@@ -893,9 +893,48 @@
             //Note  - this is no array! so the array boolean is false
 
         }else if (content instanceof XmlSchemaComplexContentRestriction){
-            //todo handle complex restriction here
-            throw new SchemaCompilationException(
-                    SchemaCompilerMessages.getMessage("schema.unsupportedcontenterror","Complex Content"));
+        	// to handle extension we need to attach the extended items to the base type
+            // and create a new type
+            XmlSchemaComplexContentRestriction restriction = (XmlSchemaComplexContentRestriction)
+                    content;
+
+            //process the base type if it has not been processed yet
+            if (!isAlreadyProcessed(restriction.getBaseTypeName())){
+                //pick the relevant basetype from the schema and process it
+                XmlSchemaType type=  parentSchema.getTypeByName(restriction.getBaseTypeName());
+                if (type instanceof XmlSchemaComplexType) {
+                    XmlSchemaComplexType complexType = (XmlSchemaComplexType) type;
+                    if (complexType.getName() != null) {
+                        processNamedComplexSchemaType(complexType,parentSchema);
+                    } else {
+                        //this is not possible. The restriction should always
+                        //have a name
+                        throw new SchemaCompilationException("Unnamed complex type used in restriction");//Internationlize this
+                    }
+                } else if (type instanceof XmlSchemaSimpleType) {
+                    
+                	throw new SchemaCompilationException("Not a valid restriction, complex content restriction base type cannot be a simple type.");
+                }
+            }
+
+            // before actually processing this node, we need to recurse through the base types and add their
+            // children (sometimes even preserving the order) to the metainfo holder of this type
+            // the reason is that for restriction, the prefered way is to have the sequences of the base class
+            //* before * the sequence of the child element.
+            copyMetaInfoHierarchy(metaInfHolder,restriction.getBaseTypeName(),parentSchema);
+
+            //process the particle of this node
+            processParticle(restriction.getParticle(),metaInfHolder,parentSchema);
+
+            //the particle has been processed, However since this is an restriction we need to
+            //add the basetype as an extension to the complex type class.
+            // The basetype has been processed already
+            //metaInfHolder.setExtension(true);
+            //metaInfHolder.setExtensionClassName(findClassName(restriction.getBaseTypeName(),false));
+            
+            metaInfHolder.setRestriction(true);
+            metaInfHolder.setRestrictionClassName(findClassName(restriction.getBaseTypeName(),false));
+            //Note  - this is no array! so the array boolean is false
         }
     }
 
Index: modules/adb-codegen/src/org/apache/axis2/schema/writer/JavaBeanWriter.java
===================================================================
--- modules/adb-codegen/src/org/apache/axis2/schema/writer/JavaBeanWriter.java	(revision 425831)
+++ modules/adb-codegen/src/org/apache/axis2/schema/writer/JavaBeanWriter.java	(working copy)
@@ -469,6 +469,11 @@
                     .getExtensionClassName(), rootElt);
 
         }
+        if (metainf.isRestriction()) {
+            XSLTUtils.addAttribute(model, "restriction", metainf
+                    .getRestrictionClassName(), rootElt);
+
+        }
         //add the mapper class name
         XSLTUtils.addAttribute(model, "mapperClass", getFullyQualifiedMapperClassName(), rootElt);
 
@@ -525,18 +530,33 @@
                                     Document model, Element rootElt, ArrayList propertyNames,
                                     Map typeMap, boolean isInherited) throws SchemaCompilationException {
         // go in the loop and add the part elements
-        QName[] qNames;
+    	QName[] qName;
+    	String javaClassNameForElement;
+        ArrayList missingQNames = new ArrayList();
+        ArrayList qNames = new ArrayList();
+        
+        BeanWriterMetaInfoHolder parentMetaInf = metainf.getParent();
+        
         if (metainf.isOrdered()) {
-            qNames = metainf.getOrderedQNameArray();
+            qName = metainf.getOrderedQNameArray();
         } else {
-            qNames = metainf.getQNameArray();
+            qName= metainf.getQNameArray();
         }
+        
+        for (int i = 0; i < qName.length; i++) {
+        	qNames.add(qName[i]);
+        }
+        //adding missing QNames to the end, including elements & attributes.
+        if (metainf.isRestriction()) {
+        	addMissingQNames(metainf, qNames, missingQNames);
+        }
+        QName name;
 
-        QName name;
-        for (int i = 0; i < qNames.length; i++) {
+        for (int i = 0; i < qNames.size(); i++) {
+        	name = (QName) qNames.get(i);
             Element property = XSLTUtils.addChildElement(model, "property",
                     rootElt);
-            name = qNames[i];
+            name = (QName)qNames.get(i);
             String xmlName = name.getLocalPart();
             XSLTUtils.addAttribute(model, "name", xmlName, property);
             XSLTUtils.addAttribute(model, "nsuri", name.getNamespaceURI(),
@@ -544,13 +564,23 @@
             String javaName = makeUniqueJavaClassName(propertyNames, xmlName);
             XSLTUtils.addAttribute(model, "javaname", javaName, property);
 
-            String javaClassNameForElement = metainf.getClassNameForQName(name);
-
+            if (metainf.isRestriction() && missingQNames.contains(name)) {
+            	javaClassNameForElement = parentMetaInf.getClassNameForQName(name);
+            }
+            else {
+            	javaClassNameForElement = metainf.getClassNameForQName(name);
+            }
+            
             if (javaClassNameForElement == null) {
                 throw new SchemaCompilationException(SchemaCompilerMessages
                         .getMessage("schema.typeMissing"));
             }
-
+            
+            if (metainf.isRestriction() && typeChanged(name, missingQNames, metainf)) {
+            	XSLTUtils.addAttribute(model, "typeChanged", "yes", property);
+            	XSLTUtils.addAttribute(model, "restricted", "yes", property);
+            }
+            
             XSLTUtils.addAttribute(model, "type", javaClassNameForElement,
                     property);
 
@@ -590,6 +620,11 @@
             XSLTUtils.addAttribute(model, "shorttypename", shortTypeName,
                     property);
 
+            if (metainf.isRestriction() && missingQNames.contains(name)) {
+            	XSLTUtils.addAttribute(model, "restricted", "yes", property);
+            	XSLTUtils.addAttribute(model, "removed", "yes", property);
+            }
+            
             if (isInherited) {
                 XSLTUtils.addAttribute(model, "inherited", "yes", property);
             }
@@ -606,6 +641,18 @@
             long minOccurs = metainf.getMinOccurs(name);
             XSLTUtils
                     .addAttribute(model, "minOccurs", minOccurs + "", property);
+            
+            //in the case the original element is an array but the derived one is not.
+            if (metainf.isRestriction() && !missingQNames.contains(name) &&
+               (parentMetaInf.getArrayStatusForQName(name) && !metainf.getArrayStatusForQName(name))) {
+            	XSLTUtils.addAttribute(model, "rewrite", "yes", property);
+            	XSLTUtils.addAttribute(model, "occuranceChanged", "yes", property);
+            }
+            else if (metainf.isRestriction() && !missingQNames.contains(name) &&
+            		(minOccursChanged(name, missingQNames, metainf) || maxOccursChanged(name, missingQNames, metainf))) {
+            	XSLTUtils.addAttribute(model, "restricted", "yes", property);
+            	XSLTUtils.addAttribute(model, "occuranceChanged", "yes", property);
+            }
 
             if (metainf.getArrayStatusForQName(name)) {
 
@@ -627,6 +674,158 @@
         }
     }
 
+    private void addMissingQNames(BeanWriterMetaInfoHolder metainf, ArrayList qName, ArrayList missingQNames) {
+    	
+    	QName[] qNames;
+        QName[] pQNames;
+        //ArrayList missingQNames = new ArrayList();
+            		
+        BeanWriterMetaInfoHolder parentMetaInf = metainf.getParent();
+        
+        if (metainf.isOrdered()) {
+            qNames = metainf.getOrderedQNameArray();
+        } else {
+            qNames = metainf.getQNameArray();
+        }
+        
+        if (parentMetaInf.isOrdered()) {
+            pQNames = parentMetaInf.getOrderedQNameArray();
+        } else {
+            pQNames = parentMetaInf.getQNameArray();
+        }
+        
+        
+        for (int i=0; i < pQNames.length; i++) {
+       		if (qNameNotFound(pQNames[i], metainf)) {
+       			missingQNames.add(pQNames[i]);
+       		}
+       	}
+       	//adding missing QNames to the end of list.
+        if (!missingQNames.isEmpty()) {
+       		for (int i=0; i < missingQNames.size(); i++) {
+       			qName.add(missingQNames.get(i));
+       		}
+       	}
+        //return qName;
+    }
+    
+    private boolean qNameNotFound(QName qname, BeanWriterMetaInfoHolder metainf) {
+    	
+    	boolean found = false;
+    	QName[] qNames;
+    	
+    	if (metainf.isOrdered()) {
+        	qNames = metainf.getOrderedQNameArray();
+        } else {
+        	qNames = metainf.getQNameArray();
+        }
+        
+        for (int j = 0; j < qNames.length; j++) {
+        	if (qname.getLocalPart().equals(qNames[j].getLocalPart())) {
+        			found = true;
+        	}
+        }
+        return !found;
+    }
+    
+    private boolean typeChanged(QName qname, ArrayList missingQNames, BeanWriterMetaInfoHolder metainf) {
+    	
+    	boolean typeChanged = false;
+    	QName[] pQNames;
+    	
+    	BeanWriterMetaInfoHolder parentMetainf = metainf.getParent(); 
+        
+    	if (!missingQNames.contains(qname)) {
+    		
+    		if (parentMetainf.isOrdered()) {
+    			pQNames = parentMetainf.getOrderedQNameArray();
+    		} else {
+    			pQNames = parentMetainf.getQNameArray();
+    		}
+    		
+    		for (int j = 0; j < pQNames.length; j++) {
+    			if (qname.getLocalPart().equals(pQNames[j].getLocalPart())) {
+    				
+    				String javaClassForParentElement = parentMetainf.getClassNameForQName(pQNames[j]);
+    				String javaClassForElement = metainf.getClassNameForQName(qname);
+    				
+    				if (!javaClassForParentElement.equals(javaClassForElement)) {
+    					if ((javaClassForParentElement.substring(0,javaClassForParentElement.indexOf('['))).equals(javaClassForElement)) {
+    						continue;
+    					}
+    					else if ((javaClassForElement.substring(0,javaClassForElement.indexOf('['))).equals(javaClassForParentElement)) {
+    						continue;
+    					}
+    					else {
+    						typeChanged = true;
+    					}
+    				}
+    			}
+    		}
+    	}
+        return typeChanged;
+    }
+    
+    private boolean minOccursChanged(QName qname, ArrayList missingQNames, BeanWriterMetaInfoHolder metainf) throws SchemaCompilationException {
+    	
+    	boolean minChanged = false;
+    	QName[] pQNames;
+    	
+    	BeanWriterMetaInfoHolder parentMetainf = metainf.getParent(); 
+        	
+    	if (!missingQNames.contains(qname)) {
+    		
+    		if (parentMetainf.isOrdered()) {
+    			pQNames = parentMetainf.getOrderedQNameArray();
+    		} else {
+    			pQNames = parentMetainf.getQNameArray();
+    		}
+    		
+    		for (int j = 0; j < pQNames.length; j++) {
+    			if (qname.getLocalPart().equals(pQNames[j].getLocalPart())) {
+    				
+    				if (metainf.getMinOccurs(qname) > parentMetainf.getMinOccurs(pQNames[j])) {
+    					minChanged = true;
+    				}
+    				else if(metainf.getMinOccurs(qname) < parentMetainf.getMinOccurs(pQNames[j])) {
+    					throw new SchemaCompilationException(SchemaCompilerMessages.getMessage("minOccurs Wrong!")); 
+    				}
+    				
+    			}
+    		}
+    	}
+        return minChanged;
+    }
+    
+    private boolean maxOccursChanged(QName qname, ArrayList missingQNames, BeanWriterMetaInfoHolder metainf) throws SchemaCompilationException {
+    	
+    	boolean maxChanged = false;
+    	QName[] pQNames;
+    	
+    	BeanWriterMetaInfoHolder parentMetainf = metainf.getParent();
+    	
+    	if (!missingQNames.contains(qname)) {	
+    		if (parentMetainf.isOrdered()) {
+    			pQNames = parentMetainf.getOrderedQNameArray();
+    		} else {
+    			pQNames = parentMetainf.getQNameArray();
+    		}
+    		
+    		for (int j = 0; j < pQNames.length; j++) {
+    			if (qname.getLocalPart().equals(pQNames[j].getLocalPart())) {
+    				
+    				if (metainf.getMaxOccurs(qname) < parentMetainf.getMaxOccurs(pQNames[j])) {
+    					maxChanged = true;
+    				}
+    				else if(metainf.getMaxOccurs(qname) > parentMetainf.getMaxOccurs(pQNames[j])) {
+    					throw new SchemaCompilationException(SchemaCompilerMessages.getMessage("maxOccurs Wrong!")); 
+    				}
+    			}
+    		}
+    	}
+        return maxChanged;
+    }
+    
     /**
      * Test whether the given class name matches the default
      * 
