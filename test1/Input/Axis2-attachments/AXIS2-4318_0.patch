diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/kernel/pom.xml .\axis2-1.6.1-src\axis2-1.6.1/modules/kernel/pom.xml
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/kernel/pom.xml	2011-08-31 00:15:40.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/kernel/pom.xml	2011-09-21 10:21:50.718750000 +0100
@@ -53,10 +53,6 @@
             <artifactId>servlet-api</artifactId>
         </dependency>
         <dependency>
-            <groupId>commons-httpclient</groupId>
-            <artifactId>commons-httpclient</artifactId>
-        </dependency>
-        <dependency>
             <groupId>commons-fileupload</groupId>
             <artifactId>commons-fileupload</artifactId>
         </dependency>
@@ -96,6 +92,11 @@
             <artifactId>commons-io</artifactId>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.apache.httpcomponents</groupId>
+            <artifactId>httpmime</artifactId>
+            <version>4.1-beta1</version>
+        </dependency>
     </dependencies>
     <url>http://axis.apache.org/axis2/java/core/</url>
     <scm>
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/kernel/src/org/apache/axis2/client/Stub.java .\axis2-1.6.1-src\axis2-1.6.1/modules/kernel/src/org/apache/axis2/client/Stub.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/kernel/src/org/apache/axis2/client/Stub.java	2011-08-31 00:15:32.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/kernel/src/org/apache/axis2/client/Stub.java	2011-09-23 12:16:34.750000000 +0100
@@ -41,10 +41,10 @@
 import org.apache.axis2.description.RobustOutOnlyAxisOperation;
 import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.transport.http.HTTPConstants;
-import org.apache.commons.httpclient.Header;
 
 import java.util.ArrayList;
 import java.util.Iterator;
+import org.apache.axis2.context.NamedValue;
 
 /**
  * Base class for generated client stubs. This defines several client API
@@ -160,9 +160,7 @@
             headersObj = new java.util.ArrayList();
         }
         java.util.List headers = (java.util.List) headersObj;
-        Header header = new Header();
-        header.setName(name);
-        header.setValue(value);
+        NamedValue header = new NamedValue(name, value);
         headers.add(header);
         messageContext.setProperty(HTTPConstants.HTTP_HEADERS, headers);
     }
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/kernel/src/org/apache/axis2/context/NamedValue.java .\axis2-1.6.1-src\axis2-1.6.1/modules/kernel/src/org/apache/axis2/context/NamedValue.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/kernel/src/org/apache/axis2/context/NamedValue.java	1970-01-01 00:00:00.000000000 +0000
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/kernel/src/org/apache/axis2/context/NamedValue.java	2011-09-20 17:22:26.000000000 +0100
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2011 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.context;
+
+
+/**
+ * This is the top most level of the Context hierarchy and is a bag of properties.
+ */
+public class NamedValue {
+
+    private final String name;
+    private final String value;
+    
+    public NamedValue(final String name, final String value) {
+        super();
+        if (name == null) {
+            throw new IllegalArgumentException("Name may not be null");
+        }
+        this.name = name;
+        this.value = value;
+    }
+
+    public String getName() {
+       return name;
+    }
+
+    public String getValue() {
+        return value;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder buffer = new StringBuilder();
+        buffer.append(this.name);
+        buffer.append("=");
+        buffer.append(this.value);
+        return buffer.toString();
+    }    
+}
+
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/kernel/src/org/apache/axis2/java/security/SSLProtocolSocketFactory.java .\axis2-1.6.1-src\axis2-1.6.1/modules/kernel/src/org/apache/axis2/java/security/SSLProtocolSocketFactory.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/kernel/src/org/apache/axis2/java/security/SSLProtocolSocketFactory.java	2011-08-31 00:15:22.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/kernel/src/org/apache/axis2/java/security/SSLProtocolSocketFactory.java	2011-09-23 13:00:31.796875000 +0100
@@ -15,8 +15,8 @@
  */
 package org.apache.axis2.java.security;
 
-import org.apache.commons.httpclient.params.HttpConnectionParams;
-import org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;
+//import org.apache.commons.httpclient.params.HttpConnectionParams;
+//import org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;
 
 import javax.net.SocketFactory;
 import javax.net.ssl.SSLContext;
@@ -26,57 +26,59 @@
 import java.net.Socket;
 import java.net.SocketAddress;
 
+// TODO - putting this in will put a dependency back on org.apache.http.conn.ssl.SSLSocketFactory in the kernal package,
+// which I was trying to avoid.
 /**
  * @see TrustAllTrustManager
  */
-public class SSLProtocolSocketFactory implements SecureProtocolSocketFactory {
-    SSLContext ctx;
-
-    public SSLProtocolSocketFactory(SSLContext ctx) {
-        this.ctx = ctx;
-    }
-
-    public Socket createSocket(final String host, final int port, final InetAddress localAddress,
-                               final int localPort, final HttpConnectionParams params) throws
-                                                                                       IOException {
-        if (params == null) {
-            throw new IllegalArgumentException("Parameters may not be null");
-        }
-        int timeout = params.getConnectionTimeout();
-        SocketFactory socketfactory = ctx.getSocketFactory();
-        if (timeout == 0) {
-            return socketfactory.createSocket(host, port, localAddress, localPort);
-        } else {
-            Socket socket = socketfactory.createSocket();
-            SocketAddress localaddr = new InetSocketAddress(localAddress, localPort);
-            SocketAddress remoteaddr = new InetSocketAddress(host, port);
-            socket.bind(localaddr);
-            socket.connect(remoteaddr, timeout);
-            return socket;
-        }
-    }
-
-    /**
-     * @see SecureProtocolSocketFactory#createSocket(java.lang.String, int, java.net.InetAddress, int)
-     */
-    public Socket createSocket(String host, int port, InetAddress clientHost, int clientPort)
-            throws IOException {
-        return ctx.getSocketFactory().createSocket(host, port, clientHost, clientPort);
-    }
-
-    /**
-     * @see SecureProtocolSocketFactory#createSocket(java.lang.String, int)
-     */
-    public Socket createSocket(String host, int port) throws IOException {
-        return ctx.getSocketFactory().createSocket(host, port);
-    }
-
-    /**
-     * @see SecureProtocolSocketFactory#createSocket(java.net.Socket, java.lang.String, int, boolean)
-     */
-    public Socket createSocket(Socket socket, String host, int port, boolean autoClose)
-            throws IOException {
-        return ctx.getSocketFactory().createSocket(socket, host, port, autoClose);
-    }
+public class SSLProtocolSocketFactory /*implements SSLSocketFactory */{
+//    SSLContext ctx;
+//
+//    public SSLProtocolSocketFactory(SSLContext ctx) {
+//        this.ctx = ctx;
+//    }
+//
+//    public Socket createSocket(final String host, final int port, final InetAddress localAddress,
+//                               final int localPort, final HttpConnectionParams params) throws
+//                                                                                       IOException {
+//        if (params == null) {
+//            throw new IllegalArgumentException("Parameters may not be null");
+//        }
+//        int timeout = params.getConnectionTimeout();
+//        SocketFactory socketfactory = ctx.getSocketFactory();
+//        if (timeout == 0) {
+//            return socketfactory.createSocket(host, port, localAddress, localPort);
+//        } else {
+//            Socket socket = socketfactory.createSocket();
+//            SocketAddress localaddr = new InetSocketAddress(localAddress, localPort);
+//            SocketAddress remoteaddr = new InetSocketAddress(host, port);
+//            socket.bind(localaddr);
+//            socket.connect(remoteaddr, timeout);
+//            return socket;
+//        }
+//    }
+//
+//    /**
+//     * @see SecureProtocolSocketFactory#createSocket(java.lang.String, int, java.net.InetAddress, int)
+//     */
+//    public Socket createSocket(String host, int port, InetAddress clientHost, int clientPort)
+//            throws IOException {
+//        return ctx.getSocketFactory().createSocket(host, port, clientHost, clientPort);
+//    }
+//
+//    /**
+//     * @see SecureProtocolSocketFactory#createSocket(java.lang.String, int)
+//     */
+//    public Socket createSocket(String host, int port) throws IOException {
+//        return ctx.getSocketFactory().createSocket(host, port);
+//    }
+//
+//    /**
+//     * @see SecureProtocolSocketFactory#createSocket(java.net.Socket, java.lang.String, int, boolean)
+//     */
+//    public Socket createSocket(Socket socket, String host, int port, boolean autoClose)
+//            throws IOException {
+//        return ctx.getSocketFactory().createSocket(socket, host, port, autoClose);
+//    }
 
 }
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/kernel/src/org/apache/axis2/transport/http/MultipartFormDataFormatter.java .\axis2-1.6.1-src\axis2-1.6.1/modules/kernel/src/org/apache/axis2/transport/http/MultipartFormDataFormatter.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/kernel/src/org/apache/axis2/transport/http/MultipartFormDataFormatter.java	2011-08-31 00:15:28.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/kernel/src/org/apache/axis2/transport/http/MultipartFormDataFormatter.java	2011-09-23 12:24:13.437500000 +0100
@@ -19,6 +19,7 @@
 
 package org.apache.axis2.transport.http;
 
+import java.io.UnsupportedEncodingException;
 import org.apache.axiom.om.OMAbstractFactory;
 import org.apache.axiom.om.OMElement;
 import org.apache.axiom.om.OMFactory;
@@ -28,15 +29,16 @@
 import org.apache.axis2.transport.MessageFormatter;
 import org.apache.axis2.transport.http.util.ComplexPart;
 import org.apache.axis2.transport.http.util.URLTemplatingUtil;
-import org.apache.commons.httpclient.methods.multipart.Part;
-import org.apache.commons.httpclient.methods.multipart.StringPart;
+import org.apache.http.entity.mime.content.StringBody;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.net.URL;
-import java.util.ArrayList;
+import java.nio.charset.Charset;
 import java.util.Iterator;
+import org.apache.http.entity.mime.FormBodyPart;
+import org.apache.http.entity.mime.HttpMultipart;
 
 /**
  * Formates the request message as multipart/form-data. An example of this serialization is shown
@@ -86,21 +88,22 @@
      */
     public byte[] getBytes(MessageContext messageContext, OMOutputFormat format) throws AxisFault {
 
+        // Character set, is that right??
+        HttpMultipart httpMultipart = new HttpMultipart("multipart/form-data", Charset.forName(format.getCharSetEncoding()), format.getMimeBoundary());
         OMElement omElement = messageContext.getEnvelope().getBody().getFirstElement();
 
-        Part[] parts = createMultipatFormDataRequest(omElement);
-        if (parts.length > 0) {
-            ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-            try {
-
-                // This is accessing a class of Commons-FlieUpload
-                Part.sendParts(bytesOut, parts, format.getMimeBoundary().getBytes());
-            } catch (IOException e) {
-                throw AxisFault.makeFault(e);
+        try {
+            createMultipatFormDataRequest(omElement, httpMultipart);
+            if (!httpMultipart.getBodyParts().isEmpty()) {
+                ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
+
+                httpMultipart.writeTo(bytesOut);
+                return bytesOut.toByteArray();
             }
-            return bytesOut.toByteArray();
+        } catch (IOException e) {
+            throw AxisFault.makeFault(e);
         }
-
+     
         return new byte[0];  //To change body of implemented methods use File | Settings | File Templates.
     }
 
@@ -177,8 +180,7 @@
      * @param dataOut
      * @return
      */
-    private Part[] createMultipatFormDataRequest(OMElement dataOut) {
-        ArrayList parts = new ArrayList();
+    private void createMultipatFormDataRequest(OMElement dataOut, HttpMultipart httpMultipart) throws UnsupportedEncodingException {
         if (dataOut != null) {
             Iterator iter1 = dataOut.getChildElements();
             OMFactory omFactory = OMAbstractFactory.getOMFactory();
@@ -191,14 +193,16 @@
                             omFactory.createOMElement(ele.getQName().getLocalPart(), null);
                     omElement.addChild(
                             processComplexType(omElement, ele.getChildElements(), omFactory));
-                    parts.add(new ComplexPart(ele.getQName().getLocalPart(), omElement.toString()));
+                    FormBodyPart formBodyPart = new FormBodyPart(ele.getLocalName(), new ComplexPart(ele.getQName().getLocalPart(), omElement.toString()));
+                    httpMultipart.addBodyPart(formBodyPart);
                 } else {
-                    parts.add(new StringPart(ele.getQName().getLocalPart(), ele.getText()));
+                	// cannot put the name anymore
+                	// ele.getQName().getLocalPart()
+                    FormBodyPart formBodyPart = new FormBodyPart(ele.getLocalName(), new StringBody(ele.getText()));
+                    httpMultipart.addBodyPart(formBodyPart);                    
                 }
             }
         }
-        Part[] partsArray = new Part[parts.size()];
-        return (Part[]) parts.toArray(partsArray);
     }
 
     /**
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/kernel/src/org/apache/axis2/transport/http/util/ComplexPart.java .\axis2-1.6.1-src\axis2-1.6.1/modules/kernel/src/org/apache/axis2/transport/http/util/ComplexPart.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/kernel/src/org/apache/axis2/transport/http/util/ComplexPart.java	2011-08-31 00:15:28.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/kernel/src/org/apache/axis2/transport/http/util/ComplexPart.java	2011-09-23 12:21:53.921875000 +0100
@@ -19,14 +19,14 @@
 
 package org.apache.axis2.transport.http.util;
 
-import org.apache.commons.httpclient.methods.multipart.PartBase;
-import org.apache.commons.httpclient.util.EncodingUtil;
-
 import java.io.IOException;
 import java.io.OutputStream;
 
-public class ComplexPart extends PartBase {
+import org.apache.http.entity.mime.content.AbstractContentBody;
+import org.apache.http.util.EncodingUtils;
 
+ 
+public class ComplexPart extends AbstractContentBody {
     /**
      * Default content encoding of string parameters.
      */
@@ -52,6 +52,12 @@
      */
     private String value;
 
+    private String charset;
+
+    private String transferEncoding;
+
+    private String name;
+    
     /**
      * Constructor.
      *
@@ -62,12 +68,11 @@
      */
     public ComplexPart(String name, String value, String charset) {
 
-        super(
-                name,
-                DEFAULT_CONTENT_TYPE,
-                charset == null ? DEFAULT_CHARSET : charset,
-                DEFAULT_TRANSFER_ENCODING
-        );
+        super(DEFAULT_CONTENT_TYPE);
+        this.name = name;
+        this.charset = charset == null ? DEFAULT_CHARSET : charset; 
+        this.transferEncoding = DEFAULT_TRANSFER_ENCODING;   
+        
         if (value == null) {
             throw new IllegalArgumentException("Value may not be null");
         }
@@ -96,38 +101,38 @@
      */
     private byte[] getContent() {
         if (content == null) {
-            content = EncodingUtil.getBytes(value, getCharSet());
+            content = EncodingUtils.getBytes(value, getCharset());
         }
         return content;
     }
 
-    /**
-     * Writes the data to the given OutputStream.
-     *
-     * @param out the OutputStream to write to
-     * @throws IOException if there is a write error
+    /* (non-Javadoc)
+     * @see org.apache.commons.httpclient.methods.multipart.BasePart#setCharSet(java.lang.String)
      */
-    protected void sendData(OutputStream out) throws IOException {
-        out.write(getContent());
+    public void setCharset(String charSet) {
+        this.charset = charSet;
+        this.content = null;
     }
 
-    /**
-     * Return the length of the data.
-     *
-     * @return The length of the data.
-     * @throws IOException If an IO problem occurs
-     * @see org.apache.commons.httpclient.methods.multipart.Part#lengthOfData()
-     */
-    protected long lengthOfData() throws IOException {
-        return getContent().length;
+    public String getFilename() {
+            return name;
     }
 
-    /* (non-Javadoc)
-     * @see org.apache.commons.httpclient.methods.multipart.BasePart#setCharSet(java.lang.String)
-     */
-    public void setCharSet(String charSet) {
-        super.setCharSet(charSet);
-        this.content = null;
+    public String getCharset() {
+            return charset;
+    }
+
+    public long getContentLength() {
+            return getContent().length;
     }
 
+    public String getTransferEncoding() {
+            return transferEncoding;
+    }
+
+    public void writeTo(OutputStream out) throws IOException {
+                out.write(getContent());
+    }
+
+
 }
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/pom.xml .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/pom.xml
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/pom.xml	2011-08-31 00:17:02.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/pom.xml	2011-09-20 15:58:57.312500000 +0100
@@ -100,15 +100,27 @@
             <groupId>org.apache.axis2</groupId>
             <artifactId>axis2-kernel</artifactId>
             <version>${project.version}</version>
-        </dependency>
-        <dependency>
-            <groupId>org.apache.httpcomponents</groupId>
-            <artifactId>httpcore</artifactId>
+            <exclusions>
+                <exclusion>
+                    <artifactId>commons-httpclient</artifactId>
+                    <groupId>commons-httpclient</groupId>
+                </exclusion>
+            </exclusions>
         </dependency>
         <dependency>
             <groupId>jetty</groupId>
             <artifactId>jetty</artifactId>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.apache.httpcomponents</groupId>
+            <artifactId>httpclient</artifactId>
+            <version>4.1</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.httpcomponents</groupId>
+            <artifactId>httpcore</artifactId>
+            <version>4.1.1</version>
+        </dependency>
     </dependencies>
 </project>
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/AbstractHTTPSender.java .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/AbstractHTTPSender.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/AbstractHTTPSender.java	2011-08-31 00:17:02.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/AbstractHTTPSender.java	2011-09-23 12:16:34.781250000 +0100
@@ -34,26 +34,49 @@
 import org.apache.axis2.transport.http.util.HTTPProxyConfigurationUtil;
 import org.apache.axis2.util.JavaUtils;
 import org.apache.axis2.wsdl.WSDLConstants;
-import org.apache.commons.httpclient.Credentials;
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HeaderElement;
-import org.apache.commons.httpclient.HostConfiguration;
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.HttpConnectionManager;
-import org.apache.commons.httpclient.HttpMethod;
-import org.apache.commons.httpclient.HttpMethodBase;
-import org.apache.commons.httpclient.HttpState;
-import org.apache.commons.httpclient.HttpVersion;
-import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;
-import org.apache.commons.httpclient.NTCredentials;
-import org.apache.commons.httpclient.NameValuePair;
-import org.apache.commons.httpclient.UsernamePasswordCredentials;
-import org.apache.commons.httpclient.auth.AuthPolicy;
-import org.apache.commons.httpclient.auth.AuthScope;
-import org.apache.commons.httpclient.params.HttpMethodParams;
-import org.apache.commons.httpclient.params.HttpConnectionManagerParams;
-import org.apache.commons.httpclient.params.HttpClientParams;
-import org.apache.commons.httpclient.protocol.Protocol;
+//import org.apache.commons.httpclient.Credentials;
+//import org.apache.commons.httpclient.Header;
+//import org.apache.commons.httpclient.HeaderElement;
+//import org.apache.commons.httpclient.HostConfiguration;
+//import org.apache.commons.httpclient.HttpClient;
+//import org.apache.commons.httpclient.HttpConnectionManager;
+//import org.apache.commons.httpclient.HttpMethod;
+//import org.apache.commons.httpclient.HttpMethodBase;
+//import org.apache.commons.httpclient.HttpState;
+//import org.apache.commons.httpclient.HttpVersion;
+//import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;
+//import org.apache.commons.httpclient.NTCredentials;
+//import org.apache.commons.httpclient.NameValuePair;
+//import org.apache.commons.httpclient.UsernamePasswordCredentials;
+//import org.apache.commons.httpclient.auth.AuthPolicy;
+//import org.apache.commons.httpclient.auth.AuthScope;
+//import org.apache.commons.httpclient.params.HttpMethodParams;
+//import org.apache.commons.httpclient.params.HttpConnectionManagerParams;
+//import org.apache.commons.httpclient.params.HttpClientParams;
+//import org.apache.commons.httpclient.protocol.Protocol;
+import org.apache.http.Header;
+import org.apache.http.HeaderElement;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpVersion;
+import org.apache.http.NameValuePair;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.Credentials;
+import org.apache.http.auth.NTCredentials;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpRequestBase;
+import org.apache.http.client.params.AuthPolicy;
+import org.apache.http.client.params.ClientPNames;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.params.ConnManagerParams;
+import org.apache.http.entity.BufferedHttpEntity;
+import org.apache.http.impl.client.AbstractHttpClient;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.params.CoreProtocolPNames;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpProtocolParams;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.http.protocol.HTTP;
@@ -61,11 +84,17 @@
 import javax.xml.namespace.QName;
 import java.io.IOException;
 import java.io.InputStream;
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.net.URL;
 import java.util.*;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.zip.GZIPInputStream;
+import org.apache.axis2.context.NamedValue;
+import org.apache.axis2.transport.http.server.HttpConnectionManager;
+import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
+import org.apache.http.params.HttpParams;
 
 public abstract class AbstractHTTPSender {
     protected static final String ANONYMOUS = "anonymous";
@@ -117,125 +146,125 @@
      * @param msgContext the MessageContext in which to place the information... OR NOT!
      * @throws AxisFault if problems occur
      */
-    protected void obtainHTTPHeaderInformation(HttpMethodBase method,
-                                               MessageContext msgContext) throws AxisFault {
-        // Set RESPONSE properties onto the REQUEST message context.  They will need to be copied off the request context onto
-        // the response context elsewhere, for example in the OutInOperationClient.
-        Map transportHeaders = new CommonsTransportHeaders(method.getResponseHeaders());
-        msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, transportHeaders);
-        msgContext.setProperty(HTTPConstants.MC_HTTP_STATUS_CODE, new Integer(method.getStatusCode()));
-        Header header = method.getResponseHeader(HTTPConstants.HEADER_CONTENT_TYPE);
-
-        if (header != null) {
-            HeaderElement[] headers = header.getElements();
-            MessageContext inMessageContext = msgContext.getOperationContext().getMessageContext(
-                    WSDLConstants.MESSAGE_LABEL_IN_VALUE);
-
-            Object contentType = header.getValue();
-            Object charSetEnc = null;
-
-            for (int i = 0; i < headers.length; i++) {
-                NameValuePair charsetEnc = headers[i].getParameterByName(
-                        HTTPConstants.CHAR_SET_ENCODING);
-                if (charsetEnc != null) {
-                    charSetEnc = charsetEnc.getValue();
-                }
-            }
-
-            if (inMessageContext != null) {
-                inMessageContext
-                        .setProperty(Constants.Configuration.CONTENT_TYPE, contentType);
-                inMessageContext
-                        .setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEnc);
-            } else {
-
-                // Transport details will be stored in a HashMap so that anybody interested can
-                // retrieve them
-                HashMap transportInfoMap = new HashMap();
-                transportInfoMap.put(Constants.Configuration.CONTENT_TYPE, contentType);
-                transportInfoMap.put(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEnc);
-
-                //the HashMap is stored in the outgoing message.
-                msgContext.setProperty(Constants.Configuration.TRANSPORT_INFO_MAP,
-                                       transportInfoMap);
-            }
-        }
-
-        String sessionCookie = null;
-        // Process old style headers first
-        Header[] cookieHeaders = method.getResponseHeaders(HTTPConstants.HEADER_SET_COOKIE);
-        String customCoookiId = (String) msgContext.getProperty(Constants.CUSTOM_COOKIE_ID);
-        for (int i = 0; i < cookieHeaders.length; i++) {
-            HeaderElement[] elements = cookieHeaders[i].getElements();
-            for (int e = 0; e < elements.length; e++) {
-                HeaderElement element = elements[e];
-                if (Constants.SESSION_COOKIE.equalsIgnoreCase(element.getName()) ||
-                        Constants.SESSION_COOKIE_JSESSIONID.equalsIgnoreCase(element.getName())) {
-                    sessionCookie = processCookieHeader(element);
-                }
-                if (customCoookiId != null && customCoookiId.equalsIgnoreCase(element.getName())) {
-                    sessionCookie = processCookieHeader(element);
-                }
-            }
-        }
-        // Overwrite old style cookies with new style ones if present
-        cookieHeaders = method.getResponseHeaders(HTTPConstants.HEADER_SET_COOKIE2);
-        for (int i = 0; i < cookieHeaders.length; i++) {
-            HeaderElement[] elements = cookieHeaders[i].getElements();
-            for (int e = 0; e < elements.length; e++) {
-                HeaderElement element = elements[e];
-                if (Constants.SESSION_COOKIE.equalsIgnoreCase(element.getName()) ||
-                        Constants.SESSION_COOKIE_JSESSIONID.equalsIgnoreCase(element.getName())) {
-                    sessionCookie = processCookieHeader(element);
-                }
-                if(customCoookiId!=null&&customCoookiId.equalsIgnoreCase(element.getName())){
-                    sessionCookie = processCookieHeader(element);
-                }
-            }
-        }
-
-        if (sessionCookie != null) {
-            msgContext.getServiceContext().setProperty(HTTPConstants.COOKIE_STRING, sessionCookie);
-        }
-    }
-
-    private String processCookieHeader(HeaderElement element) {
-        String cookie = element.getName() + "=" + element.getValue();
-        NameValuePair[] parameters =  element.getParameters();
-        for (int j = 0; parameters != null && j < parameters.length; j++) {
-            NameValuePair parameter = parameters[j];
-            cookie = cookie + "; " + parameter.getName() + "=" + parameter.getValue();
-        }
-        return cookie;
-    }
-
-    protected void processResponse(HttpMethodBase httpMethod,
-                                   MessageContext msgContext)
-            throws IOException {
-        obtainHTTPHeaderInformation(httpMethod, msgContext);
-
-        InputStream in = httpMethod.getResponseBodyAsStream();
-        if (in == null) {
-            throw new AxisFault(Messages.getMessage("canNotBeNull", "InputStream"));
-        }
-        Header contentEncoding =
-                httpMethod.getResponseHeader(HTTPConstants.HEADER_CONTENT_ENCODING);
-        if (contentEncoding != null) {
-            if (contentEncoding.getValue().
-                    equalsIgnoreCase(HTTPConstants.COMPRESSION_GZIP)) {
-                in = new GZIPInputStream(in);
-                // If the content-encoding is identity we can basically ignore it.
-            } else if (!"identity".equalsIgnoreCase(contentEncoding.getValue())) {
-                throw new AxisFault("HTTP :" + "unsupported content-encoding of '"
-                        + contentEncoding.getValue() + "' found");
-            }
-        }
-
-        OperationContext opContext = msgContext.getOperationContext();
-        if (opContext != null) {
-            opContext.setProperty(MessageContext.TRANSPORT_IN, in);
-        }
-    }
+//    protected void obtainHTTPHeaderInformation(HttpMethodBase method,
+//                                               MessageContext msgContext) throws AxisFault {
+//        // Set RESPONSE properties onto the REQUEST message context.  They will need to be copied off the request context onto
+//        // the response context elsewhere, for example in the OutInOperationClient.
+//        Map transportHeaders = new CommonsTransportHeaders(method.getResponseHeaders());
+//        msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, transportHeaders);
+//        msgContext.setProperty(HTTPConstants.MC_HTTP_STATUS_CODE, new Integer(method.getStatusCode()));
+//        Header header = method.getResponseHeader(HTTPConstants.HEADER_CONTENT_TYPE);
+//
+//        if (header != null) {
+//            HeaderElement[] headers = header.getElements();
+//            MessageContext inMessageContext = msgContext.getOperationContext().getMessageContext(
+//                    WSDLConstants.MESSAGE_LABEL_IN_VALUE);
+//
+//            Object contentType = header.getValue();
+//            Object charSetEnc = null;
+//
+//            for (int i = 0; i < headers.length; i++) {
+//                NameValuePair charsetEnc = headers[i].getParameterByName(
+//                        HTTPConstants.CHAR_SET_ENCODING);
+//                if (charsetEnc != null) {
+//                    charSetEnc = charsetEnc.getValue();
+//                }
+//            }
+//
+//            if (inMessageContext != null) {
+//                inMessageContext
+//                        .setProperty(Constants.Configuration.CONTENT_TYPE, contentType);
+//                inMessageContext
+//                        .setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEnc);
+//            } else {
+//
+//                // Transport details will be stored in a HashMap so that anybody interested can
+//                // retrieve them
+//                HashMap transportInfoMap = new HashMap();
+//                transportInfoMap.put(Constants.Configuration.CONTENT_TYPE, contentType);
+//                transportInfoMap.put(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEnc);
+//
+//                //the HashMap is stored in the outgoing message.
+//                msgContext.setProperty(Constants.Configuration.TRANSPORT_INFO_MAP,
+//                                       transportInfoMap);
+//            }
+//        }
+//
+//        String sessionCookie = null;
+//        // Process old style headers first
+//        Header[] cookieHeaders = method.getResponseHeaders(HTTPConstants.HEADER_SET_COOKIE);
+//        String customCoookiId = (String) msgContext.getProperty(Constants.CUSTOM_COOKIE_ID);
+//        for (int i = 0; i < cookieHeaders.length; i++) {
+//            HeaderElement[] elements = cookieHeaders[i].getElements();
+//            for (int e = 0; e < elements.length; e++) {
+//                HeaderElement element = elements[e];
+//                if (Constants.SESSION_COOKIE.equalsIgnoreCase(element.getName()) ||
+//                        Constants.SESSION_COOKIE_JSESSIONID.equalsIgnoreCase(element.getName())) {
+//                    sessionCookie = processCookieHeader(element);
+//                }
+//                if (customCoookiId != null && customCoookiId.equalsIgnoreCase(element.getName())) {
+//                    sessionCookie = processCookieHeader(element);
+//                }
+//            }
+//        }
+//        // Overwrite old style cookies with new style ones if present
+//        cookieHeaders = method.getResponseHeaders(HTTPConstants.HEADER_SET_COOKIE2);
+//        for (int i = 0; i < cookieHeaders.length; i++) {
+//            HeaderElement[] elements = cookieHeaders[i].getElements();
+//            for (int e = 0; e < elements.length; e++) {
+//                HeaderElement element = elements[e];
+//                if (Constants.SESSION_COOKIE.equalsIgnoreCase(element.getName()) ||
+//                        Constants.SESSION_COOKIE_JSESSIONID.equalsIgnoreCase(element.getName())) {
+//                    sessionCookie = processCookieHeader(element);
+//                }
+//                if(customCoookiId!=null&&customCoookiId.equalsIgnoreCase(element.getName())){
+//                    sessionCookie = processCookieHeader(element);
+//                }
+//            }
+//        }
+//
+//        if (sessionCookie != null) {
+//            msgContext.getServiceContext().setProperty(HTTPConstants.COOKIE_STRING, sessionCookie);
+//        }
+//    }
+
+//    private String processCookieHeader(HeaderElement element) {
+//        String cookie = element.getName() + "=" + element.getValue();
+//        NameValuePair[] parameters =  element.getParameters();
+//        for (int j = 0; parameters != null && j < parameters.length; j++) {
+//            NameValuePair parameter = parameters[j];
+//            cookie = cookie + "; " + parameter.getName() + "=" + parameter.getValue();
+//        }
+//        return cookie;
+//    }
+
+//    protected void processResponse(HttpMethodBase httpMethod,
+//                                   MessageContext msgContext)
+//            throws IOException {
+//        obtainHTTPHeaderInformation(httpMethod, msgContext);
+//
+//        InputStream in = httpMethod.getResponseBodyAsStream();
+//        if (in == null) {
+//            throw new AxisFault(Messages.getMessage("canNotBeNull", "InputStream"));
+//        }
+//        Header contentEncoding =
+//                httpMethod.getResponseHeader(HTTPConstants.HEADER_CONTENT_ENCODING);
+//        if (contentEncoding != null) {
+//            if (contentEncoding.getValue().
+//                    equalsIgnoreCase(HTTPConstants.COMPRESSION_GZIP)) {
+//                in = new GZIPInputStream(in);
+//                // If the content-encoding is identity we can basically ignore it.
+//            } else if (!"identity".equalsIgnoreCase(contentEncoding.getValue())) {
+//                throw new AxisFault("HTTP :" + "unsupported content-encoding of '"
+//                        + contentEncoding.getValue() + "' found");
+//            }
+//        }
+//
+//        OperationContext opContext = msgContext.getOperationContext();
+//        if (opContext != null) {
+//            opContext.setProperty(MessageContext.TRANSPORT_IN, in);
+//        }
+//    }
 
     public abstract void send(MessageContext msgContext, URL url, String soapActionString)
             throws IOException;
@@ -249,53 +278,53 @@
      * @return a HostConfiguration set up with proxy information
      * @throws AxisFault if problems occur
      */
-    protected HostConfiguration getHostConfiguration(HttpClient client,
-                                                     MessageContext msgCtx,
-                                                     URL targetURL)throws AxisFault {
-
-        boolean isAuthenticationEnabled = isAuthenticationEnabled(msgCtx);
-        int port = targetURL.getPort();
-
-        String protocol = targetURL.getProtocol();
-        if (port == -1) {
-            if (PROTOCOL_HTTP.equals(protocol)) {
-                port = 80;
-            } else if (PROTOCOL_HTTPS.equals(protocol)) {
-                port = 443;
-            }
-
-        }
-
-        // to see the host is a proxy and in the proxy list - available in axis2.xml
-        HostConfiguration config = new HostConfiguration();
-
-        // one might need to set his own socket factory. Let's allow that case as well.
-        Protocol protocolHandler =
-                (Protocol)msgCtx.getOptions().getProperty(HTTPConstants.CUSTOM_PROTOCOL_HANDLER);
-
-        // setting the real host configuration
-        // I assume the 90% case, or even 99% case will be no protocol handler case.
-        if (protocolHandler == null) {
-            config.setHost(targetURL.getHost(), port, targetURL.getProtocol());
-        } else {
-            config.setHost(targetURL.getHost(), port, protocolHandler);
-        }
-
-        if (isAuthenticationEnabled) {
-            // Basic, Digest, NTLM and custom authentications.
-            this.setAuthenticationInfo(client, msgCtx, config);
-        }
-        // proxy configuration
-
-        if (HTTPProxyConfigurationUtil.isProxyEnabled(msgCtx, targetURL)) {
-            if(log.isDebugEnabled()){
-                log.debug("Configuring HTTP proxy.");
-            }
-            HTTPProxyConfigurationUtil.configure(msgCtx, client, config);
-        }
-
-        return config;
-    }
+//    protected HostConfiguration getHostConfiguration(HttpClient client,
+//                                                     MessageContext msgCtx,
+//                                                     URL targetURL)throws AxisFault {
+//
+//        boolean isAuthenticationEnabled = isAuthenticationEnabled(msgCtx);
+//        int port = targetURL.getPort();
+//
+//        String protocol = targetURL.getProtocol();
+//        if (port == -1) {
+//            if (PROTOCOL_HTTP.equals(protocol)) {
+//                port = 80;
+//            } else if (PROTOCOL_HTTPS.equals(protocol)) {
+//                port = 443;
+//            }
+//
+//        }
+//
+//        // to see the host is a proxy and in the proxy list - available in axis2.xml
+//        HostConfiguration config = new HostConfiguration();
+//
+//        // one might need to set his own socket factory. Let's allow that case as well.
+//        Protocol protocolHandler =
+//                (Protocol)msgCtx.getOptions().getProperty(HTTPConstants.CUSTOM_PROTOCOL_HANDLER);
+//
+//        // setting the real host configuration
+//        // I assume the 90% case, or even 99% case will be no protocol handler case.
+//        if (protocolHandler == null) {
+//            config.setHost(targetURL.getHost(), port, targetURL.getProtocol());
+//        } else {
+//            config.setHost(targetURL.getHost(), port, protocolHandler);
+//        }
+//
+//        if (isAuthenticationEnabled) {
+//            // Basic, Digest, NTLM and custom authentications.
+//            this.setAuthenticationInfo(client, msgCtx, config);
+//        }
+//        // proxy configuration
+//
+//        if (HTTPProxyConfigurationUtil.isProxyEnabled(msgCtx, targetURL)) {
+//            if(log.isDebugEnabled()){
+//                log.debug("Configuring HTTP proxy.");
+//            }
+//            HTTPProxyConfigurationUtil.configure(msgCtx, client, config);
+//        }
+//
+//        return config;
+//    }
 
     protected boolean isAuthenticationEnabled(MessageContext msgCtx) {
         return (msgCtx.getProperty(HTTPConstants.AUTHENTICATE) != null);
@@ -305,9 +334,8 @@
     This will handle server Authentication, It could be either NTLM, Digest or Basic Authentication.
     Apart from that user can change the priory or add a custom authentication scheme.
     */
-    protected void setAuthenticationInfo(HttpClient agent,
-                                         MessageContext msgCtx,
-                                         HostConfiguration config) throws AxisFault {
+    protected void setAuthenticationInfo(AbstractHttpClient agent,
+                                         MessageContext msgCtx) throws AxisFault {
         HttpTransportProperties.Authenticator authenticator;
         Object obj = msgCtx.getProperty(HTTPConstants.AUTHENTICATE);
         if (obj != null) {
@@ -325,61 +353,61 @@
                 /* If retrying is available set it first */
                 isAllowedRetry = authenticator.isAllowedRetry();
 
-                Credentials creds;
+                Credentials creds;             
 
-                HttpState tmpHttpState = null;
-                HttpState httpState = (HttpState)msgCtx.getProperty(HTTPConstants.CACHED_HTTP_STATE);
-                if (httpState != null) {
-                    tmpHttpState = httpState;
-                } else {
-                    tmpHttpState = agent.getState();
-                }
-                
-                agent.getParams()
-                        .setAuthenticationPreemptive(authenticator.getPreemptiveAuthentication());
+                // TODO port preemptive auth feature for httpclient 4.0           
+//                agent.getParams()
+//                        .setAuthenticationPreemptive(authenticator.getPreemptiveAuthentication());
 
                 if (host != null) {
                     if (domain != null) {
                         /*Credentials for NTLM Authentication*/
+                        agent.getAuthSchemes().register("ntlm", new org.apache.http.impl.auth.NTLMSchemeFactory());
                         creds = new NTCredentials(username, password, host, domain);
                     } else {
                         /*Credentials for Digest and Basic Authentication*/
                         creds = new UsernamePasswordCredentials(username, password);
                     }
-                    tmpHttpState.setCredentials(new AuthScope(host, port, realm), creds);
+                    agent.getCredentialsProvider().setCredentials(new AuthScope(host, port, realm), creds);
                 } else {
                     if (domain != null) {
                         /*Credentials for NTLM Authentication when host is ANY_HOST*/
+                        agent.getAuthSchemes().register("ntlm", new org.apache.http.impl.auth.NTLMSchemeFactory());
                         creds = new NTCredentials(username, password, AuthScope.ANY_HOST, domain);
-                        tmpHttpState.setCredentials(
+                        agent.getCredentialsProvider().setCredentials(
                                 new AuthScope(AuthScope.ANY_HOST, port, realm), creds);
                     } else {
                         /*Credentials only for Digest and Basic Authentication*/
                         creds = new UsernamePasswordCredentials(username, password);
-                        tmpHttpState.setCredentials(new AuthScope(AuthScope.ANY), creds);
+                        agent.getCredentialsProvider().setCredentials(new AuthScope(AuthScope.ANY), creds);
                     }
                 }
+//                authenticator.getAuthSchemes().add(obj);
                 /* Customizing the priority Order */
-                List schemes = authenticator.getAuthSchemes();
-                if (schemes != null && schemes.size() > 0) {
-                    List authPrefs = new ArrayList(3);
-                    for (int i = 0; i < schemes.size(); i++) {
-                        if (schemes.get(i) instanceof AuthPolicy) {
-                            authPrefs.add(schemes.get(i));
-                            continue;
-                        }
-                        String scheme = (String) schemes.get(i);
-                        if (HttpTransportProperties.Authenticator.BASIC.equals(scheme)) {
-                            authPrefs.add(AuthPolicy.BASIC);
-                        } else if (HttpTransportProperties.Authenticator.NTLM.equals(scheme)) {
-                            authPrefs.add(AuthPolicy.NTLM);
-                        } else if (HttpTransportProperties.Authenticator.DIGEST.equals(scheme)) {
-                            authPrefs.add(AuthPolicy.DIGEST);
-                        }
-                    }
-                    agent.getParams().setParameter(AuthPolicy.AUTH_SCHEME_PRIORITY,
-                            authPrefs);
-                }
+//                List schemes = agent.getAuthSchemes();
+//                schemes.add(AuthPolicy.NTLM);
+//                if (schemes != null && schemes.size() > 0) {
+//                    List authPrefs = new ArrayList(3);
+//                    for (int i = 0; i < schemes.size(); i++) {
+////                        if (schemes.get(i) instanceof AuthPolicy) {
+////                            authPrefs.add(schemes.get(i));
+////                            continue;
+////                        }
+//                        String scheme = (String) schemes.get(i);
+//                        if (HttpTransportProperties.Authenticator.BASIC.equals(scheme)) {
+//                            authPrefs.add(AuthPolicy.BASIC);
+//                        } else if (HttpTransportProperties.Authenticator.NTLM.equals(scheme)) {
+//                            authPrefs.add(AuthPolicy.NTLM);
+//                        } else if (HttpTransportProperties.Authenticator.DIGEST.equals(scheme)) {
+//                            authPrefs.add(AuthPolicy.DIGEST);
+//                        }
+//                    }
+//                    agent.getParams().setParameter(AuthPolicy.AUTH_SCHEME_PRIORITY,
+//                            authPrefs);
+//                    Axis2TargetAuthenticationHandler handler = new Axis2TargetAuthenticationHandler();
+//                    handler.setAuthPreferences(schemes);
+//                    agent.setTargetAuthenticationHandler(handler);                    
+//                }
 
             } else {
                 throw new AxisFault("HttpTransportProperties.Authenticator class cast exception");
@@ -400,29 +428,29 @@
      * @throws AxisFault - Thrown in case an exception occurs
      */
     protected MessageFormatter populateCommonProperties(MessageContext msgContext, URL url,
-                                                      HttpMethodBase httpMethod,
+                                                      HttpRequestBase httpRequest,
                                                       HttpClient httpClient,
                                                       String soapActionString)
             throws AxisFault {
 
-        if (isAuthenticationEnabled(msgContext)) {
-            httpMethod.setDoAuthentication(true);
-        }
+//        if (isAuthenticationEnabled(msgContext)) {
+//            httpRequest.getParams().setBooleanParameter(ClientPNames.HANDLE_AUTHENTICATION, false);
+//        }
 
         MessageFormatter messageFormatter = TransportUtils.getMessageFormatter(
                 msgContext);
 
         url = messageFormatter.getTargetAddress(msgContext, format, url);
 
-        httpMethod.setPath(url.getPath());
-
-        httpMethod.setQueryString(url.getQuery());
-
-        httpMethod.setRequestHeader(HTTPConstants.HEADER_CONTENT_TYPE,
-                                    messageFormatter.getContentType(msgContext, format,
-                                                                    soapActionString));
+        try {
+                httpRequest.setURI(new URI(url.toString()));
+        } catch (URISyntaxException e) {
+                throw new AxisFault("Failed to create URI: " + e.getMessage(), e);
+        }
+        
+        httpRequest.setHeader(HTTPConstants.HEADER_CONTENT_TYPE, messageFormatter.getContentType(msgContext, format, soapActionString));
 
-        httpMethod.setRequestHeader(HTTPConstants.HEADER_HOST, url.getHost());
+        httpRequest.setHeader(HTTPConstants.HEADER_HOST, url.getHost());
 
         if (msgContext.getOptions() != null && msgContext.getOptions().isManageSession()) {
             // setting the cookie in the out path
@@ -431,12 +459,12 @@
             if (cookieString != null) {
                 StringBuffer buffer = new StringBuffer();
                 buffer.append(cookieString);
-                httpMethod.setRequestHeader(HTTPConstants.HEADER_COOKIE, buffer.toString());
+                httpRequest.setHeader(HTTPConstants.HEADER_COOKIE, buffer.toString());
             }
         }
 
         if (httpVersion.equals(HTTPConstants.HEADER_PROTOCOL_10)) {
-            httpClient.getParams().setVersion(HttpVersion.HTTP_1_0);
+            HttpProtocolParams.setVersion(httpClient.getParams(), HttpVersion.HTTP_1_0);
         }
         return messageFormatter;
     }
@@ -462,24 +490,22 @@
         if (tempConnTimeoutProperty != null) {
             int connectionTimeout = tempConnTimeoutProperty.intValue();
             // timeout for initial connection
-            httpClient.getHttpConnectionManager().getParams().setConnectionTimeout(connectionTimeout);
+            HttpConnectionParams.setConnectionTimeout(httpClient.getParams(), connectionTimeout);
         } else {
             // set timeout in client
             if (timeout > 0) {
-                httpClient.getHttpConnectionManager().getParams().setConnectionTimeout((int) timeout);
+                HttpConnectionParams.setConnectionTimeout(httpClient.getParams(), (int)timeout);
             }
         }
 
         if (tempSoTimeoutProperty != null) {
             int soTimeout = tempSoTimeoutProperty.intValue();
             // SO_TIMEOUT -- timeout for blocking reads
-            httpClient.getHttpConnectionManager().getParams().setSoTimeout(soTimeout);
-            httpClient.getParams().setSoTimeout(soTimeout);
+            HttpConnectionParams.setSoTimeout(httpClient.getParams(), soTimeout);
         } else {
             // set timeout in client
             if (timeout > 0) {
-                httpClient.getHttpConnectionManager().getParams().setSoTimeout((int) timeout);
-                httpClient.getParams().setSoTimeout((int) timeout);
+                HttpConnectionParams.setSoTimeout(httpClient.getParams(), (int) timeout);
             }
         }
     }
@@ -492,7 +518,7 @@
      * @param msgContext the active MessageContext
      * @param httpMethod method
      */
-    protected void setTimeouts(MessageContext msgContext, HttpMethod httpMethod) {
+    protected void setTimeouts(MessageContext msgContext, AbstractHttpClient httpClient) {
         // If the SO_TIMEOUT of CONNECTION_TIMEOUT is set by dynamically the
         // override the static config
         Integer tempSoTimeoutProperty =
@@ -504,17 +530,17 @@
 
         if (tempConnTimeoutProperty != null) {
             // timeout for initial connection
-            httpMethod.getParams().setParameter("http.connection.timeout",
+            httpClient.getParams().setParameter("http.connection.timeout",
                     tempConnTimeoutProperty);
         }
 
         if (tempSoTimeoutProperty != null) {
             // SO_TIMEOUT -- timeout for blocking reads
-            httpMethod.getParams().setSoTimeout(tempSoTimeoutProperty);
+            HttpConnectionParams.setSoTimeout(httpClient.getParams(), tempSoTimeoutProperty);            
         } else {
             // set timeout in client
             if (timeout > 0) {
-                httpMethod.getParams().setSoTimeout((int) timeout);
+                HttpConnectionParams.setSoTimeout(httpClient.getParams(), (int) timeout);            
             }
         }
     }
@@ -523,14 +549,14 @@
         this.format = format;
     }
 
-    protected HttpClient getHttpClient(MessageContext msgContext) {
+    protected AbstractHttpClient getHttpClient(MessageContext msgContext) {
         ConfigurationContext configContext = msgContext.getConfigurationContext();
 
-        HttpClient httpClient = (HttpClient) msgContext.getProperty(
+        AbstractHttpClient httpClient = (AbstractHttpClient) msgContext.getProperty(
                 HTTPConstants.CACHED_HTTP_CLIENT);
 
         if (httpClient == null) {
-            httpClient = (HttpClient) configContext.getProperty(HTTPConstants.CACHED_HTTP_CLIENT);
+            httpClient = (AbstractHttpClient) configContext.getProperty(HTTPConstants.CACHED_HTTP_CLIENT);
         }
 
         if (httpClient != null) {
@@ -538,10 +564,10 @@
         }
 
         synchronized (this) {
-            httpClient = (HttpClient) msgContext.getProperty(HTTPConstants.CACHED_HTTP_CLIENT);
+            httpClient = (AbstractHttpClient) msgContext.getProperty(HTTPConstants.CACHED_HTTP_CLIENT);
 
             if (httpClient == null) {
-                httpClient = (HttpClient) configContext.getProperty(
+                httpClient = (AbstractHttpClient) configContext.getProperty(
                         HTTPConstants.CACHED_HTTP_CLIENT);
             }
 
@@ -549,22 +575,22 @@
                 return httpClient;
             }
 
-            HttpConnectionManager connManager =
-                    (HttpConnectionManager) msgContext.getProperty(
+            ClientConnectionManager connManager =
+                    (ClientConnectionManager) msgContext.getProperty(
                             HTTPConstants.MULTITHREAD_HTTP_CONNECTION_MANAGER);
             if (connManager == null) {
                 connManager =
-                        (HttpConnectionManager) msgContext.getProperty(
-                                HTTPConstants.MUTTITHREAD_HTTP_CONNECTION_MANAGER);
+                        (ClientConnectionManager) msgContext.getProperty(
+                                HTTPConstants.MULTITHREAD_HTTP_CONNECTION_MANAGER);
             }
             if (connManager == null) {
                 // reuse HttpConnectionManager
                 synchronized (configContext) {
-                    connManager = (HttpConnectionManager) configContext.getProperty(
+                    connManager = (ClientConnectionManager) configContext.getProperty(
                             HTTPConstants.MULTITHREAD_HTTP_CONNECTION_MANAGER);
                     if (connManager == null) {
                         log.trace("Making new ConnectionManager");
-                        connManager = new MultiThreadedHttpConnectionManager();
+                        connManager = new ThreadSafeClientConnManager();
                         configContext.setProperty(
                                 HTTPConstants.MULTITHREAD_HTTP_CONNECTION_MANAGER, connManager);
                     }
@@ -574,11 +600,12 @@
              * Create a new instance of HttpClient since the way
              * it is used here it's not fully thread-safe.
              */
-            httpClient = new HttpClient(connManager);
+            httpClient = new DefaultHttpClient(connManager);
 
             // Set the default timeout in case we have a connection pool starvation to 30sec
-            httpClient.getParams().setConnectionManagerTimeout(30000);
-
+            // TODO
+//             httpClient.getParams().setConnectionManagerTimeout(30000);
+           
             // Get the timeout values set in the runtime
             initializeTimeouts(msgContext, httpClient);
 
@@ -586,56 +613,56 @@
         }
     }
 
-    protected void executeMethod(HttpClient httpClient, MessageContext msgContext, URL url,
-                                 HttpMethod method) throws IOException {
-        HostConfiguration config = this.getHostConfiguration(httpClient, msgContext, url);
+    protected HttpResponse executeMethod(AbstractHttpClient httpClient, MessageContext msgContext, URL url,
+                                 HttpRequestBase request) throws IOException {
+        configureHttpClient(httpClient, msgContext, url);
 
         // set the custom headers, if available
-        addCustomHeaders(method, msgContext);
+        addCustomHeaders(request, msgContext);
 
         // add compression headers if needed
         if (msgContext.isPropertyTrue(HTTPConstants.MC_ACCEPT_GZIP)) {
-            method.addRequestHeader(HTTPConstants.HEADER_ACCEPT_ENCODING,
+            request.addHeader(HTTPConstants.HEADER_ACCEPT_ENCODING,
                     HTTPConstants.COMPRESSION_GZIP);
         }
 
         if (msgContext.isPropertyTrue(HTTPConstants.MC_GZIP_REQUEST)) {
-            method.addRequestHeader(HTTPConstants.HEADER_CONTENT_ENCODING,
+            request.addHeader(HTTPConstants.HEADER_CONTENT_ENCODING,
                     HTTPConstants.COMPRESSION_GZIP);
         }
         
         if (msgContext.getProperty(HTTPConstants.HTTP_METHOD_PARAMS) != null) {
-            HttpMethodParams params = (HttpMethodParams)msgContext
+            HttpParams params = (HttpParams)msgContext
                     .getProperty(HTTPConstants.HTTP_METHOD_PARAMS);
-            method.setParams(params);
+            request.setParams(params);
         }
 
-        String cookiePolicy = (String) msgContext.getProperty(HTTPConstants.COOKIE_POLICY);
+        String cookiePolicy = (String) msgContext.getProperty(ClientPNames.COOKIE_POLICY);
         if (cookiePolicy != null) {
-            method.getParams().setCookiePolicy(cookiePolicy);   
+            httpClient.getParams().setParameter(ClientPNames.COOKIE_POLICY, cookiePolicy); 
         }
-        HttpState httpState = (HttpState)msgContext.getProperty(HTTPConstants.CACHED_HTTP_STATE);
+//        HttpState httpState = (HttpState)msgContext.getProperty(HTTPConstants.CACHED_HTTP_STATE);
 
-        setTimeouts(msgContext, method);
+        setTimeouts(msgContext, httpClient);
 
-        httpClient.executeMethod(config, method, httpState);
+        return httpClient.execute(getTargetHost(url), request);
     }
 
-    public void addCustomHeaders(HttpMethod method, MessageContext msgContext) {
+    public void addCustomHeaders(HttpRequestBase request, MessageContext msgContext) {
 
         boolean isCustomUserAgentSet = false;
         // set the custom headers, if available
         Object httpHeadersObj = msgContext.getProperty(HTTPConstants.HTTP_HEADERS);
         if (httpHeadersObj != null) {
-            if (httpHeadersObj instanceof ArrayList) {
-                ArrayList httpHeaders = (ArrayList) httpHeadersObj;
-                Header header;
+            if (httpHeadersObj instanceof List) {
+                List httpHeaders = (List) httpHeadersObj;
+                NamedValue namedValue;
                 for (int i = 0; i < httpHeaders.size(); i++) {
-                    header = (Header) httpHeaders.get(i);
-                    if (HTTPConstants.HEADER_USER_AGENT.equals(header.getName())) {
+                    namedValue = (NamedValue) httpHeaders.get(i);
+                    if (HTTPConstants.HEADER_USER_AGENT.equals(namedValue.getName())) {
                         isCustomUserAgentSet = true;
                     }
-                    method.addRequestHeader(header);
+                    request.addHeader(namedValue.getName(), namedValue.getValue());
                 }
     
             }
@@ -648,7 +675,7 @@
                     if (HTTPConstants.HEADER_USER_AGENT.equals(key)) {
                         isCustomUserAgentSet = true;
                     }
-                    method.addRequestHeader(key, value);
+                    request.addHeader(key, value);
                 }
             }
         }
@@ -662,7 +689,7 @@
 
             for (Object headerEntry : headerEntries) {
                 if (headerEntry instanceof Map.Entry) {
-                    Header[] headers = method.getRequestHeaders();
+                    Header[] headers = request.getAllHeaders();
 
                     boolean headerAdded = false;
                     for (Header header : headers) {
@@ -674,7 +701,7 @@
                     }
 
                     if (!headerAdded) {
-                        method.addRequestHeader(((Map.Entry) headerEntry).getKey().toString(),
+                        request.addHeader(((Map.Entry) headerEntry).getKey().toString(),
                                 ((Map.Entry) headerEntry).getValue().toString());
                     }
                 }
@@ -683,7 +710,7 @@
 
         if (!isCustomUserAgentSet) {
             String userAgentString = getUserAgent(msgContext);
-            method.setRequestHeader(HTTPConstants.HEADER_USER_AGENT, userAgentString);
+            request.setHeader(HTTPConstants.HEADER_USER_AGENT, userAgentString);
         }
 
     }
@@ -740,4 +767,193 @@
         return userAgentString;
     }
     
-}
+    protected HttpHost getTargetHost(URL targetURL) {
+    	 int port = targetURL.getPort();
+
+         String protocol = targetURL.getProtocol();
+         if (port == -1) {
+             if (PROTOCOL_HTTP.equals(protocol)) {
+                 port = 80;
+             } else if (PROTOCOL_HTTPS.equals(protocol)) {
+                 port = 443;
+             }
+         }
+          HttpHost httpHost;
+ 
+         // one might need to set his own socket factory. Let's allow that case as well.
+         
+         // TODO port custom protocol handler feature to httpclient 4.0
+       /*  Protocol protocolHandler =
+                 (Protocol)msgCtx.getOptions().getProperty(HTTPConstants.CUSTOM_PROTOCOL_HANDLER);*/
+
+         // setting the real host configuration
+         // I assume the 90% case, or even 99% case will be no protocol handler case.
+      //   if (protocolHandler == null) {
+         	httpHost = new HttpHost(targetURL.getHost(), port, targetURL.getProtocol());
+       //  } else {
+       // 	httpHost = new HttpHost(targetURL.getHost(), port, protocolHandler);
+       //  }
+         return httpHost;
+     }    
+    
+	/**
+     * Collect the HTTP header information and set them in the message context
+     *
+     * @param method HttpResponse from which to get information
+     * @param msgContext the MessageContext in which to place the information... OR NOT!
+     * @throws AxisFault if problems occur
+     */
+    protected void obtainHTTPHeaderInformation(HttpResponse response,
+                                               MessageContext msgContext) throws AxisFault {
+        // Set RESPONSE properties onto the REQUEST message context.  They will need to be copied off the request context onto
+        // the response context elsewhere, for example in the OutInOperationClient.
+        Map transportHeaders = new CommonsTransportHeaders(response.getAllHeaders());
+        msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, transportHeaders);
+        msgContext.setProperty(HTTPConstants.MC_HTTP_STATUS_CODE, new Integer(response.getStatusLine().getStatusCode()));
+        Header header = response.getEntity().getContentType();
+
+        if (header != null) {
+            HeaderElement[] headers = header.getElements();
+            MessageContext inMessageContext = msgContext.getOperationContext().getMessageContext(
+                    WSDLConstants.MESSAGE_LABEL_IN_VALUE);
+
+            Object contentType = header.getValue();
+            Object charSetEnc = null;
+
+            for (int i = 0; i < headers.length; i++) {
+                NameValuePair charsetEnc = headers[i].getParameterByName(
+                        HTTPConstants.CHAR_SET_ENCODING);
+                if (charsetEnc != null) {
+                    charSetEnc = charsetEnc.getValue();
+                }
+            }
+
+            if (inMessageContext != null) {
+                inMessageContext
+                        .setProperty(Constants.Configuration.CONTENT_TYPE, contentType);
+                inMessageContext
+                        .setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEnc);
+            } else {
+
+                // Transport details will be stored in a HashMap so that anybody interested can
+                // retrieve them
+                Map transportInfoMap = new HashMap();
+                transportInfoMap.put(Constants.Configuration.CONTENT_TYPE, contentType);
+                transportInfoMap.put(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEnc);
+
+                //the HashMap is stored in the outgoing message.
+                msgContext.setProperty(Constants.Configuration.TRANSPORT_INFO_MAP,
+                                       transportInfoMap);
+            }
+        }
+
+        String sessionCookie = null;
+        // Process old style headers first
+        Header[] cookieHeaders = response.getHeaders(HTTPConstants.HEADER_SET_COOKIE);
+        String customCoookiId = (String) msgContext.getProperty(Constants.CUSTOM_COOKIE_ID);
+        for (int i = 0; i < cookieHeaders.length; i++) {
+            HeaderElement[] elements = cookieHeaders[i].getElements();
+            for (int e = 0; e < elements.length; e++) {
+                HeaderElement element = elements[e];
+                if (Constants.SESSION_COOKIE.equalsIgnoreCase(element.getName()) ||
+                        Constants.SESSION_COOKIE_JSESSIONID.equalsIgnoreCase(element.getName())) {
+                    sessionCookie = processCookieHeader(element);
+                }
+                if (customCoookiId != null && customCoookiId.equalsIgnoreCase(element.getName())) {
+                    sessionCookie = processCookieHeader(element);
+                }
+            }
+        }
+        // Overwrite old style cookies with new style ones if present
+        cookieHeaders = response.getHeaders(HTTPConstants.HEADER_SET_COOKIE2);
+        for (int i = 0; i < cookieHeaders.length; i++) {
+            HeaderElement[] elements = cookieHeaders[i].getElements();
+            for (int e = 0; e < elements.length; e++) {
+                HeaderElement element = elements[e];
+                if (Constants.SESSION_COOKIE.equalsIgnoreCase(element.getName()) ||
+                        Constants.SESSION_COOKIE_JSESSIONID.equalsIgnoreCase(element.getName())) {
+                    sessionCookie = processCookieHeader(element);
+                }
+                if(customCoookiId!=null&&customCoookiId.equalsIgnoreCase(element.getName())){
+                    sessionCookie = processCookieHeader(element);
+                }
+            }
+        }
+
+        if (sessionCookie != null) {
+            msgContext.getServiceContext().setProperty(HTTPConstants.COOKIE_STRING, sessionCookie);
+        }
+    }
+    
+    private String processCookieHeader(HeaderElement element) {
+        String cookie = element.getName() + "=" + element.getValue();
+        NameValuePair[] parameters =  element.getParameters();
+        for (int j = 0; parameters != null && j < parameters.length; j++) {
+            NameValuePair parameter = parameters[j];
+            cookie = cookie + "; " + parameter.getName() + "=" + parameter.getValue();
+        }
+        return cookie;
+    }
+
+    protected void processResponse(HttpResponse httpResponse,
+                                   MessageContext msgContext)
+            throws IOException {
+        obtainHTTPHeaderInformation(httpResponse, msgContext);
+ 
+        // ensure that http connection is released. A better option would have been
+        // to use a response callback handler, but time constraints dictates I use this
+        // quick patch. The main drawback to this approach is the full inputstream is loaded in memory
+        // instead of just streamed. Since we are using this patched axis2 version in a controlled
+        // environment it shouldnt be a problem.
+        // TODO use a responsehandler callback instead, see HttpClient javadoc for more info
+        HttpEntity bufferedHttpEntity = new BufferedHttpEntity(httpResponse.getEntity());
+        InputStream in = bufferedHttpEntity.getContent();
+        if (in == null) {
+            throw new AxisFault(Messages.getMessage("canNotBeNull", "InputStream"));
+        }
+        Header contentEncoding = bufferedHttpEntity.getContentEncoding();
+        if (contentEncoding != null) {
+            if (contentEncoding.getValue().
+                    equalsIgnoreCase(HTTPConstants.COMPRESSION_GZIP)) {
+                in = new GZIPInputStream(in);
+            } else {
+                throw new AxisFault("HTTP :" + "unsupported content-encoding of '"
+                        + contentEncoding.getValue() + "' found");
+            }
+        }
+
+        OperationContext opContext = msgContext.getOperationContext();
+        if (opContext != null) {
+            opContext.setProperty(MessageContext.TRANSPORT_IN, in);
+        }
+    }
+    
+    protected void configureHttpClient(AbstractHttpClient client,
+                                                      MessageContext msgCtx,
+                                                      URL targetURL)throws AxisFault {
+ 
+         boolean isAuthenticationEnabled = isAuthenticationEnabled(msgCtx);
+
+
+         if (isAuthenticationEnabled) {
+             // Basic, Digest, NTLM and custom authentications.
+
+            this.setAuthenticationInfo(client, msgCtx);
+         }
+
+        // need to set to false because POST SOAP requests are not getting
+        // accepted by IIS/Sharepoint web services otherwise.
+        client.getParams().setBooleanParameter(CoreProtocolPNames.USE_EXPECT_CONTINUE, false);
+        
+        // TODO - this needs testing/reviewing
+        if (HTTPProxyConfigurationUtil.isProxyEnabled(msgCtx, targetURL)) {
+            if(log.isDebugEnabled()){
+                log.debug("Configuring HTTP proxy.");
+            }
+            HTTPProxyConfigurationUtil.configure(msgCtx, client);
+        }
+
+     }
+     
+}    
+
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/AxisRequestEntity.java .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/AxisRequestEntity.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/AxisRequestEntity.java	2011-08-31 00:17:02.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/AxisRequestEntity.java	2011-09-21 12:52:30.359375000 +0100
@@ -19,23 +19,28 @@
 
 package org.apache.axis2.transport.http;
 
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
 import org.apache.axiom.om.OMOutputFormat;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.transport.MessageFormatter;
 import org.apache.axis2.util.JavaUtils;
-import org.apache.commons.httpclient.methods.RequestEntity;
+//import org.apache.commons.httpclient.methods.RequestEntity;
 
 import javax.xml.stream.FactoryConfigurationError;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.zip.GZIPOutputStream;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
 
 /**
  * This Request Entity is used by the HTTPCommonsTransportSender. This wraps the
  * Axis2 message formatter object.
  */
-public class AxisRequestEntity implements RequestEntity {
+public class AxisRequestEntity implements HttpEntity {
 
     private MessageFormatter messageFormatter;
 
@@ -74,31 +79,6 @@
         return true;
     }
 
-    public void writeRequest(OutputStream outStream) throws IOException {
-        Object gzip = messageContext.getOptions().getProperty(HTTPConstants.MC_GZIP_REQUEST);
-        if (gzip != null && JavaUtils.isTrueExplicitly(gzip) && chunked) {
-            outStream = new GZIPOutputStream(outStream);
-        }
-        try {
-            if (chunked) {
-                messageFormatter.writeTo(messageContext, format, outStream, isAllowedRetry);
-            } else {
-                if (bytes == null) {
-                    bytes = messageFormatter.getBytes(messageContext, format);
-                }
-                outStream.write(bytes);
-            }
-            if (outStream instanceof GZIPOutputStream) {
-                ((GZIPOutputStream) outStream).finish();
-            }
-            outStream.flush();
-        } catch (FactoryConfigurationError e) {
-            throw AxisFault.makeFault(e);
-        } catch (IOException e) {
-            throw AxisFault.makeFault(e);
-        }
-
-    }
 
     public long getContentLength() {
         if (chunked) {
@@ -114,7 +94,55 @@
         return bytes.length;
     }
 
-    public String getContentType() {
-        return messageFormatter.getContentType(messageContext, format, soapAction);
+    public boolean isChunked() {
+        return chunked;
+    }
+
+    public Header getContentType() {
+        return new BasicHeader(HTTPConstants.HEADER_CONTENT_TYPE, messageFormatter.getContentType(messageContext, format,
+				soapAction));
+    }
+
+    public Header getContentEncoding() {
+        return null;
+    }
+
+    public InputStream getContent() throws IOException, IllegalStateException {
+        return new ByteArrayInputStream(messageFormatter.getBytes(messageContext, format));
+    }
+
+    public void writeTo(OutputStream outstream) throws IOException {
+        Object gzip = messageContext.getOptions().getProperty(
+                        HTTPConstants.MC_GZIP_REQUEST);
+        if (gzip != null && JavaUtils.isTrueExplicitly(gzip) && chunked) {
+                outstream = new GZIPOutputStream(outstream);
+        }
+        try {
+                if (chunked) {
+                        messageFormatter.writeTo(messageContext, format, outstream,
+                                        isAllowedRetry);
+                } else {
+                        if (bytes == null) {
+                                bytes = messageFormatter.getBytes(messageContext, format);
+                        }
+                        outstream.write(bytes);
+                }
+                if (outstream instanceof GZIPOutputStream) {
+                        ((GZIPOutputStream) outstream).finish();
+                }
+                outstream.flush();
+        } catch (FactoryConfigurationError e) {
+                throw AxisFault.makeFault(e);
+        } catch (IOException e) {
+                throw AxisFault.makeFault(e);
+        }
+    }
+
+    public boolean isStreaming() {
+        return false;
+    }
+
+    public void consumeContent() throws IOException {
+        // TODO not sure what to do here.
     }
 }
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/AxisServlet.java .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/AxisServlet.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/AxisServlet.java	2011-08-31 00:17:02.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/AxisServlet.java	2011-09-21 15:59:09.734375000 +0100
@@ -51,7 +51,6 @@
 import org.apache.axis2.util.JavaUtils;
 import org.apache.axis2.util.MessageContextBuilder;
 import org.apache.axis2.util.OnDemandLogger;
-import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;
 
 import javax.servlet.ServletConfig;
 import javax.servlet.ServletContext;
@@ -70,6 +69,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.CountDownLatch;
+import org.apache.http.conn.ClientConnectionManager;
 
 /**
  * Servlet implementing the HTTP and HTTPS transport. Note that this class doesn't implement
@@ -518,10 +518,13 @@
     }
 
     /**
-     * distroy the ConfigurationContext
+     * destroy the ConfigurationContext
      */
     @Override
     public void destroy() {
+        ClientConnectionManager connManager = (ClientConnectionManager) configContext.getProperty(
+                            HTTPConstants.MULTITHREAD_HTTP_CONNECTION_MANAGER);
+        
         //stoping listner manager
         try {
             if (configContext != null) {
@@ -538,7 +541,9 @@
         // AXIS2-4898: MultiThreadedHttpConnectionManager starts a thread that is not stopped by the
         // shutdown of the connection manager. If we want to avoid a resource leak, we need to call
         // shutdownAll here.
-        MultiThreadedHttpConnectionManager.shutdownAll();
+        if (connManager != null) {
+            connManager.shutdown();
+        }
     }
 
     /**
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java	2011-08-31 00:17:02.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java	2011-09-23 12:29:11.859375000 +0100
@@ -34,9 +34,6 @@
 import org.apache.axis2.transport.TransportUtils;
 import org.apache.axis2.transport.http.server.AxisHttpResponseImpl;
 import org.apache.axis2.util.JavaUtils;
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HttpException;
-import org.apache.commons.httpclient.HttpMethod;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -50,6 +47,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.zip.GZIPOutputStream;
+//import org.apache.http.Header;
+import org.apache.axis2.context.NamedValue;
 
 public class CommonsHTTPTransportSender extends AbstractHandler implements
         TransportSender {
@@ -80,15 +79,23 @@
     private int connectionTimeout = HTTPConstants.DEFAULT_CONNECTION_TIMEOUT;
 
     public void cleanup(MessageContext msgContext) throws AxisFault {
-        HttpMethod httpMethod = (HttpMethod) msgContext.getProperty(HTTPConstants.HTTP_METHOD);
-
-        if (httpMethod != null) {
-            // TODO : Don't do this if we're not on the right thread! Can we confirm?
-            log.trace("cleanup() releasing connection for " + httpMethod);
-
-            httpMethod.releaseConnection();
-            msgContext.removeProperty(HTTPConstants.HTTP_METHOD); // guard against multiple calls
-        }
+//        HttpMethod httpMethod = (HttpMethod) msgContext.getProperty(HTTPConstants.HTTP_METHOD);
+//
+//        if (httpMethod != null) {
+//            // TODO : Don't do this if we're not on the right thread! Can we confirm?
+//            log.trace("cleanup() releasing connection for " + httpMethod);
+//
+//            httpMethod.releaseConnection();
+//            msgContext.removeProperty(HTTPConstants.HTTP_METHOD); // guard against multiple calls
+//        }
+    	/* No need to cleanup, the HttpConnectionManager is smart enough to 
+    	 * know what to do.
+    	 * 
+    	 * AbortableHttpRequest abortableRequest = (AbortableHttpRequest)msgContext.getProperty(HTTPConstants.HTTP_METHOD);
+ 
+        if (abortableRequest != null) {
+        	abortableRequest.abort();
+        }*/        
     }
 
     public void init(ConfigurationContext confContext,
@@ -292,7 +299,7 @@
                 if (customHeaders instanceof List) {
                     Iterator iter = ((List) customHeaders).iterator();
                     while (iter.hasNext()) {
-                        Header header = (Header) iter.next();
+                        NamedValue header = (NamedValue) iter.next();
                         if (header != null) {
                             servletBasedOutTransportInfo
                                     .addHeader(header.getName(), header.getValue());
@@ -315,7 +322,7 @@
                 if (customHeaders instanceof List) {
                     Iterator iter = ((List) customHeaders).iterator();
                     while (iter.hasNext()) {
-                        Header header = (Header) iter.next();
+                        NamedValue header = (NamedValue)iter.next();                        
                         if (header != null) {
                             ((AxisHttpResponseImpl) transportInfo)
                                     .addHeader(header.getName(), header.getValue());
@@ -405,9 +412,6 @@
         } catch (MalformedURLException e) {
             log.debug(e);
             throw AxisFault.makeFault(e);
-        } catch (HttpException e) {
-            log.debug(e);
-            throw AxisFault.makeFault(e);
         } catch (IOException e) {
             log.debug(e);
             throw AxisFault.makeFault(e);
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/CommonsTransportHeaders.java .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/CommonsTransportHeaders.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/CommonsTransportHeaders.java	2011-08-31 00:17:02.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/CommonsTransportHeaders.java	2011-09-20 17:22:28.015625000 +0100
@@ -19,7 +19,7 @@
 
 package org.apache.axis2.transport.http;
 
-import org.apache.commons.httpclient.Header;
+import org.apache.http.Header;
 
 import java.util.Collection;
 import java.util.HashMap;
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/HTTPSender.java .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/HTTPSender.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/HTTPSender.java	2011-08-31 00:17:02.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/HTTPSender.java	2011-09-21 15:59:09.281250000 +0100
@@ -27,20 +27,22 @@
 import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.transport.MessageFormatter;
 import org.apache.axis2.wsdl.WSDLConstants;
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.HttpMethod;
-import org.apache.commons.httpclient.HttpMethodBase;
-import org.apache.commons.httpclient.HttpStatus;
-import org.apache.commons.httpclient.methods.DeleteMethod;
-import org.apache.commons.httpclient.methods.GetMethod;
-import org.apache.commons.httpclient.methods.PostMethod;
-import org.apache.commons.httpclient.methods.PutMethod;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.methods.HttpDelete;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.client.methods.HttpPut;
+import org.apache.http.client.methods.HttpRequestBase;
+import org.apache.http.impl.client.AbstractHttpClient;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import java.io.IOException;
 import java.net.URL;
+import org.apache.http.util.EntityUtils;
 
 public class HTTPSender extends AbstractHTTPSender {
 
@@ -86,36 +88,29 @@
     private void sendViaGet(MessageContext msgContext, URL url, String soapActiionString)
             throws AxisFault {
 
-        GetMethod getMethod = new GetMethod();
-        HttpClient httpClient = getHttpClient(msgContext);
+        HttpGet getRequest = new HttpGet();
+        AbstractHttpClient httpClient = getHttpClient(msgContext);
         MessageFormatter messageFormatter =
-                populateCommonProperties(msgContext, url, getMethod, httpClient, soapActiionString);
+                populateCommonProperties(msgContext, url, getRequest, httpClient, soapActiionString);
 
         // Need to have this here because we can have soap action when using the soap response MEP
         String soapAction =
                 messageFormatter.formatSOAPAction(msgContext, format, soapActiionString);
 
         if (soapAction != null) {
-            getMethod.setRequestHeader(HTTPConstants.HEADER_SOAP_ACTION, soapAction);
-        }
-        try {
-            executeMethod(httpClient, msgContext, url, getMethod);
-            handleResponse(msgContext, getMethod);
-        } catch (IOException e) {
-            log.info("Unable to sendViaGet to url[" + url + "]", e);
-            throw AxisFault.makeFault(e);
-        } finally {
-            cleanup(msgContext, getMethod);
+            getRequest.setHeader(HTTPConstants.HEADER_SOAP_ACTION, soapAction);
         }
+        doSend(httpClient, msgContext, url, getRequest);
     }
-
+/* * TODO no need to auto release connection, httpclient 4.0 already does that
+	 * behavior. 
     private void cleanup(MessageContext msgContext, HttpMethod method) {
         if (msgContext.isPropertyTrue(HTTPConstants.AUTO_RELEASE_CONNECTION)) {
             log.trace("AutoReleasing " + method);
             method.releaseConnection();
         }
     }
-
+*/
     /**
      * Used to send a request via HTTP Delete Method
      *
@@ -127,19 +122,11 @@
     private void sendViaDelete(MessageContext msgContext, URL url, String soapActiionString)
             throws AxisFault {
 
-        DeleteMethod deleteMethod = new DeleteMethod();
-        HttpClient httpClient = getHttpClient(msgContext);
-        populateCommonProperties(msgContext, url, deleteMethod, httpClient, soapActiionString);
-
-        try {
-            executeMethod(httpClient, msgContext, url, deleteMethod);
-            handleResponse(msgContext, deleteMethod);
-        } catch (IOException e) {
-            log.info("Unable to sendViaDelete to url[" + url + "]", e);
-            throw AxisFault.makeFault(e);
-        } finally {
-            cleanup(msgContext, deleteMethod);
-        }
+        HttpDelete deleteRequest = new HttpDelete();
+        AbstractHttpClient httpClient = getHttpClient(msgContext);
+        populateCommonProperties(msgContext, url, deleteRequest, httpClient, soapActiionString);
+
+        doSend(httpClient, msgContext, url, deleteRequest);
     }
 
     /**
@@ -153,51 +140,29 @@
     private void sendViaPost(MessageContext msgContext, URL url,
                              String soapActionString) throws AxisFault {
 
-
-        HttpClient httpClient = getHttpClient(msgContext);
-
-/*  What's up with this, it never gets used anywhere?? --Glen
-        String charEncoding =
-                (String) msgContext.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
-
-        if (charEncoding == null) {
-            charEncoding = MessageContext.DEFAULT_CHAR_SET_ENCODING;
-        }
-*/
-
-        PostMethod postMethod = new PostMethod();
+        HttpPost postRequest = new HttpPost();
+        AbstractHttpClient httpClient = getHttpClient(msgContext);
         if (log.isTraceEnabled()) {
-            log.trace(Thread.currentThread() + " PostMethod " + postMethod + " / " + httpClient);
+            log.trace(Thread.currentThread() + " PostMethod " + postRequest + " / " + httpClient);
         }
         MessageFormatter messageFormatter =
-                populateCommonProperties(msgContext, url, postMethod, httpClient, soapActionString);
+                populateCommonProperties(msgContext, url, postRequest, httpClient, soapActionString);
 
-        postMethod.setRequestEntity(new AxisRequestEntity(messageFormatter,
+        postRequest.setEntity(new AxisRequestEntity(messageFormatter,
                                                           msgContext, format, soapActionString,
                                                           chunked, isAllowedRetry));
 
-        if (!httpVersion.equals(HTTPConstants.HEADER_PROTOCOL_10) && chunked) {
-            postMethod.setContentChunked(true);
-        }
-
         String soapAction = messageFormatter.formatSOAPAction(msgContext, format, soapActionString);
 
         if (soapAction != null) {
-            postMethod.setRequestHeader(HTTPConstants.HEADER_SOAP_ACTION, soapAction);
+            postRequest.setHeader(HTTPConstants.HEADER_SOAP_ACTION, soapAction);
         }
 
+
         /*
          *   main excecution takes place..
          */
-        try {
-            executeMethod(httpClient, msgContext, url, postMethod);
-            handleResponse(msgContext, postMethod);
-        } catch (IOException e) {
-            log.info("Unable to sendViaPost to url[" + url + "]", e);
-            throw AxisFault.makeFault(e);
-        } finally {
-            cleanup(msgContext, postMethod);
-        }
+        doSend(httpClient, msgContext, url, postRequest);
     }
 
     /**
@@ -212,48 +177,56 @@
                             String soapActionString) throws AxisFault {
 
 
-        HttpClient httpClient = getHttpClient(msgContext);
+        AbstractHttpClient httpClient = getHttpClient(msgContext);
 
-/*  Same deal - this value never gets used, why is it here? --Glen
-        String charEncoding =
-                (String) msgContext.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
-
-        if (charEncoding == null) {
-            charEncoding = MessageContext.DEFAULT_CHAR_SET_ENCODING;
-        }
-*/
-
-        PutMethod putMethod = new PutMethod();
+        HttpPut putRequest = new HttpPut();
         MessageFormatter messageFormatter =
-                populateCommonProperties(msgContext, url, putMethod, httpClient, soapActionString);
+                populateCommonProperties(msgContext, url, putRequest, httpClient, soapActionString);
 
-        putMethod.setRequestEntity(new AxisRequestEntity(messageFormatter,
+        putRequest.setEntity(new AxisRequestEntity(messageFormatter,
                                                          msgContext, format, soapActionString,
                                                          chunked, isAllowedRetry));
 
-        if (!httpVersion.equals(HTTPConstants.HEADER_PROTOCOL_10) && chunked) {
-            putMethod.setContentChunked(true);
-        }
-
         String soapAction = messageFormatter.formatSOAPAction(msgContext, format, soapActionString);
         if (soapAction != null) {
-            putMethod.setRequestHeader(HTTPConstants.HEADER_SOAP_ACTION, soapAction);
+            putRequest.setHeader(HTTPConstants.HEADER_SOAP_ACTION, soapAction);
         }
 
         /*
          *   main excecution takes place..
          */
-        try {
-            executeMethod(httpClient, msgContext, url, putMethod);
-            handleResponse(msgContext, putMethod);
-        } catch (IOException e) {
-            log.info("Unable to sendViaPut to url[" + url + "]", e);
-            throw AxisFault.makeFault(e);
-        } finally {
-            cleanup(msgContext, putMethod);
-        }
+        doSend(httpClient, msgContext, url, putRequest);
     }
 
+
+	private void doSend(AbstractHttpClient httpClient, MessageContext msgContext, URL url, HttpRequestBase httpRequest) throws AxisFault {
+		/*
+		 * main excecution takes place..
+		 */
+		HttpResponse response = null;
+		try {
+			response = executeMethod(httpClient, msgContext, url, httpRequest);
+			handleResponse(msgContext, response);
+		} catch (IOException e) {
+			log.info("Unable to doSend: " + httpRequest.getRequestLine().toString() + " to url[" + url + "]", e);
+			cleanup(response);
+			throw AxisFault.makeFault(e);
+		}
+	}
+	
+	private void cleanup(HttpResponse response) {
+		if(response != null) {
+			HttpEntity httpEntity = response.getEntity();
+			if(httpEntity != null) {
+				try {
+                                     EntityUtils.consume(httpEntity);
+				} catch (IOException e) {
+					log.warn("Failed to cleanup response:" + e.getMessage(), e);
+				}
+			}
+		}
+	}
+
     /**
      * Used to handle the HTTP Response
      *
@@ -262,26 +235,29 @@
      * @throws IOException - Thrown in case an exception occurs
      */
     private void handleResponse(MessageContext msgContext,
-                                HttpMethodBase method) throws IOException {
-        int statusCode = method.getStatusCode();
+                                HttpResponse response)
+			throws IOException {
+        int statusCode = response.getStatusLine().getStatusCode();
         log.trace("Handling response - " + statusCode);
+               
         if (statusCode == HttpStatus.SC_OK) {
             // Save the HttpMethod so that we can release the connection when cleaning up
-            msgContext.setProperty(HTTPConstants.HTTP_METHOD, method);
-            processResponse(method, msgContext);
+//            msgContext.setProperty(HTTPConstants.HTTP_METHOD, method);
+            processResponse(response, msgContext);
         } else if (statusCode == HttpStatus.SC_ACCEPTED) {
         	/* When an HTTP 202 Accepted code has been received, this will be the case of an execution 
         	 * of an in-only operation. In such a scenario, the HTTP response headers should be returned,
         	 * i.e. session cookies. */
-        	obtainHTTPHeaderInformation(method, msgContext);
+            
+        	obtainHTTPHeaderInformation(response, msgContext);
         	// Since we don't expect any content with a 202 response, we must release the connection
-        	method.releaseConnection();
+//        	method.releaseConnection();
         } else if (statusCode == HttpStatus.SC_INTERNAL_SERVER_ERROR ||
                 statusCode == HttpStatus.SC_BAD_REQUEST) {
             // Save the HttpMethod so that we can release the connection when cleaning up
-            msgContext.setProperty(HTTPConstants.HTTP_METHOD, method);
+//            msgContext.setProperty(HTTPConstants.HTTP_METHOD, method);
             Header contenttypeHeader =
-                    method.getResponseHeader(HTTPConstants.HEADER_CONTENT_TYPE);
+                    response.getEntity().getContentType();
             String value = null;
             if (contenttypeHeader != null) {
                 value = contenttypeHeader.getValue();
@@ -295,21 +271,19 @@
                 }
             }
             if (value != null) {
-
-                processResponse(method, msgContext);
+                processResponse(response, msgContext);
             }
             
             if (org.apache.axis2.util.Utils.isClientThreadNonBlockingPropertySet(msgContext)) {
             	 throw new AxisFault(Messages.getMessage("transportError",
                          String.valueOf(statusCode),
-                         method.getStatusText()));
+                         response.getStatusLine().toString()));
             }
         } else {
             // Since we don't process the response, we must release the connection immediately
-            method.releaseConnection();
             throw new AxisFault(Messages.getMessage("transportError",
                                                     String.valueOf(statusCode),
-                                                    method.getStatusText()));
+                                                    response.getStatusLine().toString()));
         }
     }
 }
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/HttpTransportProperties.java .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/HttpTransportProperties.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/HttpTransportProperties.java	2011-08-31 00:17:02.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/HttpTransportProperties.java	2011-09-23 12:31:48.218750000 +0100
@@ -19,9 +19,9 @@
 
 package org.apache.axis2.transport.http;
 
-import org.apache.commons.httpclient.HttpVersion;
-import org.apache.commons.httpclient.auth.AuthPolicy;
-import org.apache.commons.httpclient.auth.AuthScope;
+import org.apache.http.HttpVersion;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.client.params.AuthPolicy;
 
 import java.util.List;
 import java.util.Properties;
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/RESTRequestEntity.java .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/RESTRequestEntity.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/RESTRequestEntity.java	2011-08-31 00:17:02.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/RESTRequestEntity.java	2011-09-23 12:32:19.906250000 +0100
@@ -19,19 +19,23 @@
 
 package org.apache.axis2.transport.http;
 
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
 import org.apache.axiom.om.OMElement;
 import org.apache.axiom.om.OMOutputFormat;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.context.MessageContext;
-import org.apache.commons.httpclient.methods.RequestEntity;
 
 import javax.xml.stream.FactoryConfigurationError;
 import javax.xml.stream.XMLStreamException;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
 
-public class RESTRequestEntity implements RequestEntity {
+public class RESTRequestEntity implements HttpEntity {
     private byte[] bytes;
     private String charSetEnc;
     private boolean chunked;
@@ -80,26 +84,6 @@
         }
     }
 
-    public void writeRequest(OutputStream out) throws IOException {
-        try {
-            if (chunked) {
-                this.handleOMOutput(out, format.isDoingSWA());
-            } else {
-                if (bytes == null) {
-                    bytes = writeBytes();
-                }
-                out.write(bytes);
-            }
-            out.flush();
-        } catch (XMLStreamException e) {
-            throw AxisFault.makeFault(e);
-        } catch (FactoryConfigurationError e) {
-            throw AxisFault.makeFault(e);
-        } catch (IOException e) {
-            throw AxisFault.makeFault(e);
-        }
-    }
-
     public long getContentLength() {
         try {
             if (chunked) {
@@ -115,7 +99,15 @@
         }
     }
 
-    public String getContentType() {
+    public boolean isRepeatable() {
+        return true;
+    }
+
+    public boolean isChunked() {
+        return chunked;
+    }
+
+    public Header getContentType() {
         String encoding = format.getCharSetEncoding();
         String contentType = format.getContentType();
         if (encoding != null) {
@@ -127,10 +119,42 @@
                 && !"".equals(soapActionString.trim()) && !"\"\"".equals(soapActionString.trim())) {
             contentType = contentType + ";action=\"" + soapActionString + "\";";
         }
-        return contentType;
+        return new BasicHeader(HTTPConstants.HEADER_CONTENT_TYPE, contentType);
     }
 
-    public boolean isRepeatable() {
-        return true;
+    public Header getContentEncoding() {
+        return null;
+    }
+
+    public InputStream getContent() throws IOException, IllegalStateException {
+        return new ByteArrayInputStream(writeBytes());
+    }
+
+    public void writeTo(OutputStream outstream) throws IOException {
+        try {
+            if (chunked) {
+                this.handleOMOutput(outstream, format.isDoingSWA());
+            } else {
+                if (bytes == null) {
+                    bytes = writeBytes();
+                }
+                outstream.write(bytes);
+            }
+            outstream.flush();
+        } catch (XMLStreamException e) {
+            throw AxisFault.makeFault(e);
+        } catch (FactoryConfigurationError e) {
+            throw AxisFault.makeFault(e);
+        } catch (IOException e) {
+            throw AxisFault.makeFault(e);
+        }
+    }
+
+    public boolean isStreaming() {
+        return false;
+    }
+
+    public void consumeContent() throws IOException {
+        // TODO not sure what to do here.
     }
 }
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/RESTRequestEntity2.java .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/RESTRequestEntity2.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/RESTRequestEntity2.java	2011-08-31 00:17:02.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/RESTRequestEntity2.java	2011-09-23 12:32:44.859375000 +0100
@@ -19,12 +19,15 @@
 
 package org.apache.axis2.transport.http;
 
-import org.apache.commons.httpclient.methods.RequestEntity;
-
+import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.OutputStream;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
 
-public class RESTRequestEntity2 implements RequestEntity {
+public class RESTRequestEntity2 implements HttpEntity {
     private String contentType;
     private String postRequestBody;
 
@@ -33,19 +36,39 @@
         this.contentType = contentType;
     }
 
-    public void writeRequest(OutputStream output) throws IOException {
-        output.write(postRequestBody.getBytes());
-    }
-
     public long getContentLength() {
         return this.postRequestBody.getBytes().length;
     }
 
-    public String getContentType() {
-        return this.contentType;
-    }
-
     public boolean isRepeatable() {
         return true;
     }
+
+    public boolean isChunked() {
+        return false;
+    }
+
+    public Header getContentType() {
+        return new BasicHeader(HTTPConstants.HEADER_CONTENT_TYPE, this.contentType);
+    }
+
+    public Header getContentEncoding() {
+        return null;
+    }
+
+    public InputStream getContent() throws IOException, IllegalStateException {
+        return new ByteArrayInputStream(this.postRequestBody.getBytes());
+    }
+
+    public void writeTo(OutputStream outstream) throws IOException {
+        outstream.write(postRequestBody.getBytes());
+    }
+
+    public boolean isStreaming() {
+        return false;
+    }
+
+    public void consumeContent() throws IOException {
+        // TODO not sure what to do here
+    }
 }
diff -ruN -X exclude.txt .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/util/HTTPProxyConfigurationUtil.java .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/util/HTTPProxyConfigurationUtil.java
--- .\axis2-1.6.1-src-orig\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/util/HTTPProxyConfigurationUtil.java	2011-08-31 00:17:02.000000000 +0100
+++ .\axis2-1.6.1-src\axis2-1.6.1/modules/transport/http/src/org/apache/axis2/transport/http/util/HTTPProxyConfigurationUtil.java	2011-09-23 12:29:12.046875000 +0100
@@ -25,14 +25,19 @@
 import org.apache.axis2.description.Parameter;
 import org.apache.axis2.transport.http.HTTPConstants;
 import org.apache.axis2.transport.http.HttpTransportProperties;
-import org.apache.commons.httpclient.*;
-import org.apache.commons.httpclient.auth.AuthScope;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import javax.xml.namespace.QName;
 import java.net.URL;
 import java.util.StringTokenizer;
+import org.apache.http.HttpHost;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.Credentials;
+import org.apache.http.auth.NTCredentials;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.HttpClient;
+import org.apache.http.conn.params.ConnRoutePNames;
 
 /**
  * Contains utility functions used when configuring HTTP Proxy for HTTP Sender.
@@ -82,8 +87,7 @@
      * @throws AxisFault if Proxy settings are invalid
      */
     public static void configure(MessageContext messageContext,
-                                 HttpClient httpClient,
-                                 HostConfiguration config) throws AxisFault {
+                                 HttpClient httpClient) throws AxisFault {
 
         Credentials proxyCredentials = null;
         String proxyHost = null;
@@ -154,15 +158,17 @@
             proxyPort = Integer.parseInt(port);
         }
 
-        if(proxyCredentials != null) {
-            httpClient.getParams().setAuthenticationPreemptive(true);
-            HttpState cachedHttpState = (HttpState)messageContext.getProperty(HTTPConstants.CACHED_HTTP_STATE);
-            if(cachedHttpState != null){
-                httpClient.setState(cachedHttpState);
-            }
-            httpClient.getState().setProxyCredentials(AuthScope.ANY, proxyCredentials);
-        }
-        config.setProxy(proxyHost, proxyPort);
+        // TODO
+//        if(proxyCredentials != null) {
+//            httpClient.getParams().setAuthenticationPreemptive(true);
+//            HttpState cachedHttpState = (HttpState)messageContext.getProperty(HTTPConstants.CACHED_HTTP_STATE);
+//            if(cachedHttpState != null){
+//                httpClient.setState(cachedHttpState);
+//            }
+//            httpClient.getState().setProxyCredentials(AuthScope.ANY, proxyCredentials);
+//        }
+        HttpHost proxy = new HttpHost(proxyHost, proxyPort);
+        httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
     }
 
     private static OMElement getProxyConfigurationElement(Parameter proxySettingsFromAxisConfig) throws AxisFault {
