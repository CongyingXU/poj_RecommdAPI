Index: modules/kernel/src/org/apache/axis2/context/NamedValue.java
===================================================================
--- modules/kernel/src/org/apache/axis2/context/NamedValue.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/context/NamedValue.java	(revision 0)
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package org.apache.axis2.context;
+
+/**
+ * This is the top most level of the Context hierarchy and is a bag of properties.
+ */
+public class NamedValue {
+
+    private final String name;
+    private final String value;
+    
+    public NamedValue(final String name, final String value) {
+        super();
+        if (name == null) {
+            throw new IllegalArgumentException("Name may not be null");
+        }
+        this.name = name;
+        this.value = value;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public String getValue() {
+        return value;
+    }
+
+    public String toString() {
+        StringBuilder buffer = new StringBuilder();
+        buffer.append(this.name);
+        buffer.append("=");
+        buffer.append(this.value);
+        return buffer.toString();
+    }    
+}
\ No newline at end of file
Index: modules/kernel/src/org/apache/axis2/transport/http/AbstractHTTPSender.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/AbstractHTTPSender.java	(revision 765719)
+++ modules/kernel/src/org/apache/axis2/transport/http/AbstractHTTPSender.java	(working copy)
@@ -19,49 +19,61 @@
 
 package org.apache.axis2.transport.http;
 
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.zip.GZIPInputStream;
+
+import javax.xml.namespace.QName;
+
 import org.apache.axiom.om.OMAttribute;
 import org.apache.axiom.om.OMElement;
 import org.apache.axiom.om.OMOutputFormat;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.NamedValue;
 import org.apache.axis2.context.OperationContext;
 import org.apache.axis2.description.TransportOutDescription;
 import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.transport.MessageFormatter;
 import org.apache.axis2.transport.TransportUtils;
+import org.apache.axis2.transport.http.auth.NTLMSchemeFactory;
 import org.apache.axis2.util.JavaUtils;
 import org.apache.axis2.wsdl.WSDLConstants;
-import org.apache.commons.httpclient.Credentials;
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HeaderElement;
-import org.apache.commons.httpclient.HostConfiguration;
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.HttpConnectionManager;
-import org.apache.commons.httpclient.HttpMethod;
-import org.apache.commons.httpclient.HttpMethodBase;
-import org.apache.commons.httpclient.HttpVersion;
-import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;
-import org.apache.commons.httpclient.NTCredentials;
-import org.apache.commons.httpclient.NameValuePair;
-import org.apache.commons.httpclient.UsernamePasswordCredentials;
-import org.apache.commons.httpclient.auth.AuthPolicy;
-import org.apache.commons.httpclient.auth.AuthScope;
-import org.apache.commons.httpclient.protocol.Protocol;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.http.Header;
+import org.apache.http.HeaderElement;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpVersion;
+import org.apache.http.NameValuePair;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.Credentials;
+import org.apache.http.auth.NTCredentials;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpRequestBase;
+import org.apache.http.client.params.AuthPolicy;
+import org.apache.http.client.params.ClientPNames;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.params.ConnManagerParams;
+import org.apache.http.entity.BufferedHttpEntity;
+import org.apache.http.impl.client.AbstractHttpClient;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.params.CoreProtocolPNames;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpProtocolParams;
 
-import javax.xml.namespace.QName;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.zip.GZIPInputStream;
-
 public abstract class AbstractHTTPSender {
     protected static final String ANONYMOUS = "anonymous";
     protected static final String PROXY_HOST_NAME = "proxy_host";
@@ -103,191 +115,69 @@
                                 + " Can have values only HTTP/1.0 or HTTP/1.1");
             }
         }
-    }
+    }    
 
-    /**
-     * Collect the HTTP header information and set them in the message context
-     *
-     * @param method HttpMethodBase from which to get information
-     * @param msgContext the MessageContext in which to place the information... OR NOT!
-     * @throws AxisFault if problems occur
-     */
-    protected void obtainHTTPHeaderInformation(HttpMethodBase method,
-                                               MessageContext msgContext) throws AxisFault {
-        // Set RESPONSE properties onto the REQUEST message context.  They will need to be copied off the request context onto
-        // the response context elsewhere, for example in the OutInOperationClient.
-        Map transportHeaders = new CommonsTransportHeaders(method.getResponseHeaders());
-        msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, transportHeaders);
-        msgContext.setProperty(HTTPConstants.MC_HTTP_STATUS_CODE, new Integer(method.getStatusCode()));
-        Header header = method.getResponseHeader(HTTPConstants.HEADER_CONTENT_TYPE);
+    public abstract void send(MessageContext msgContext, URL url, String soapActionString)
+            throws IOException;
 
-        if (header != null) {
-            HeaderElement[] headers = header.getElements();
-            MessageContext inMessageContext = msgContext.getOperationContext().getMessageContext(
-                    WSDLConstants.MESSAGE_LABEL_IN_VALUE);
+    
+    protected HttpHost getTargetHost(URL targetURL) {
+    	 int port = targetURL.getPort();
 
-            Object contentType = header.getValue();
-            Object charSetEnc = null;
+         String protocol = targetURL.getProtocol();
+         if (port == -1) {
+             if (PROTOCOL_HTTP.equals(protocol)) {
+                 port = 80;
+             } else if (PROTOCOL_HTTPS.equals(protocol)) {
+                 port = 443;
+             }
 
-            for (int i = 0; i < headers.length; i++) {
-                NameValuePair charsetEnc = headers[i].getParameterByName(
-                        HTTPConstants.CHAR_SET_ENCODING);
-                if (charsetEnc != null) {
-                    charSetEnc = charsetEnc.getValue();
-                }
-            }
+         }
 
-            if (inMessageContext != null) {
-                inMessageContext
-                        .setProperty(Constants.Configuration.CONTENT_TYPE, contentType);
-                inMessageContext
-                        .setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEnc);
-            } else {
+         HttpHost httpHost;
 
-                // Transport details will be stored in a HashMap so that anybody interested can
-                // retrieve them
-                HashMap transportInfoMap = new HashMap();
-                transportInfoMap.put(Constants.Configuration.CONTENT_TYPE, contentType);
-                transportInfoMap.put(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEnc);
+         // one might need to set his own socket factory. Let's allow that case as well.
+         
+         // TODO port custom protocol handler feature to httpclient 4.0
+       /*  Protocol protocolHandler =
+                 (Protocol)msgCtx.getOptions().getProperty(HTTPConstants.CUSTOM_PROTOCOL_HANDLER);*/
 
-                //the HashMap is stored in the outgoing message.
-                msgContext.setProperty(Constants.Configuration.TRANSPORT_INFO_MAP,
-                                       transportInfoMap);
-            }
-        }
-
-        String sessionCookie = null;
-        // Process old style headers first
-        Header[] cookieHeaders = method.getResponseHeaders(HTTPConstants.HEADER_SET_COOKIE);
-        String customCoookiId = (String) msgContext.getProperty(Constants.CUSTOM_COOKIE_ID);
-        for (int i = 0; i < cookieHeaders.length; i++) {
-            HeaderElement[] elements = cookieHeaders[i].getElements();
-            for (int e = 0; e < elements.length; e++) {
-                HeaderElement element = elements[e];
-                if (Constants.SESSION_COOKIE.equalsIgnoreCase(element.getName()) ||
-                        Constants.SESSION_COOKIE_JSESSIONID.equalsIgnoreCase(element.getName())) {
-                    sessionCookie = processCookieHeader(element);
-                }
-                if (customCoookiId != null && customCoookiId.equalsIgnoreCase(element.getName())) {
-                    sessionCookie = processCookieHeader(element);
-                }
-            }
-        }
-        // Overwrite old style cookies with new style ones if present
-        cookieHeaders = method.getResponseHeaders(HTTPConstants.HEADER_SET_COOKIE2);
-        for (int i = 0; i < cookieHeaders.length; i++) {
-            HeaderElement[] elements = cookieHeaders[i].getElements();
-            for (int e = 0; e < elements.length; e++) {
-                HeaderElement element = elements[e];
-                if (Constants.SESSION_COOKIE.equalsIgnoreCase(element.getName()) ||
-                        Constants.SESSION_COOKIE_JSESSIONID.equalsIgnoreCase(element.getName())) {
-                    sessionCookie = processCookieHeader(element);
-                }
-                if(customCoookiId!=null&&customCoookiId.equalsIgnoreCase(element.getName())){
-                    sessionCookie = processCookieHeader(element);
-                }
-            }
-        }
-
-        if (sessionCookie != null) {
-            msgContext.getServiceContext().setProperty(HTTPConstants.COOKIE_STRING, sessionCookie);
-        }
+         // setting the real host configuration
+         // I assume the 90% case, or even 99% case will be no protocol handler case.
+      //   if (protocolHandler == null) {
+         	httpHost = new HttpHost(targetURL.getHost(), port, targetURL.getProtocol());
+       //  } else {
+       // 	httpHost = new HttpHost(targetURL.getHost(), port, protocolHandler);
+       //  }
+         return httpHost;
     }
-
-    private String processCookieHeader(HeaderElement element) {
-        String cookie = element.getName() + "=" + element.getValue();
-        NameValuePair[] parameters =  element.getParameters();
-        for (int j = 0; parameters != null && j < parameters.length; j++) {
-            NameValuePair parameter = parameters[j];
-            cookie = cookie + "; " + parameter.getName() + "=" + parameter.getValue();
-        }
-        return cookie;
-    }
-
-    protected void processResponse(HttpMethodBase httpMethod,
-                                   MessageContext msgContext)
-            throws IOException {
-        obtainHTTPHeaderInformation(httpMethod, msgContext);
-
-        InputStream in = httpMethod.getResponseBodyAsStream();
-        if (in == null) {
-            throw new AxisFault(Messages.getMessage("canNotBeNull", "InputStream"));
-        }
-        Header contentEncoding =
-                httpMethod.getResponseHeader(HTTPConstants.HEADER_CONTENT_ENCODING);
-        if (contentEncoding != null) {
-            if (contentEncoding.getValue().
-                    equalsIgnoreCase(HTTPConstants.COMPRESSION_GZIP)) {
-                in = new GZIPInputStream(in);
-            } else {
-                throw new AxisFault("HTTP :" + "unsupported content-encoding of '"
-                        + contentEncoding.getValue() + "' found");
-            }
-        }
-
-        OperationContext opContext = msgContext.getOperationContext();
-        if (opContext != null) {
-            opContext.setProperty(MessageContext.TRANSPORT_IN, in);
-        }
-    }
-
-    public abstract void send(MessageContext msgContext, URL url, String soapActionString)
-            throws IOException;
-
     /**
-     * getting host configuration to support standard http/s, proxy and NTLM support
+     * configureHttpClient to support standard http/s, proxy and NTLM support
      *
-     * @param client active HttpClient
+     * @param client active AbstractHttpClient
      * @param msgCtx active MessageContext
      * @param targetURL the target URL
-     * @return a HostConfiguration set up with proxy information
      * @throws AxisFault if problems occur
      */
-    protected HostConfiguration getHostConfiguration(HttpClient client,
+    protected void configureHttpClient(AbstractHttpClient client,
                                                      MessageContext msgCtx,
                                                      URL targetURL)throws AxisFault {
 
         boolean isAuthenticationEnabled = isAuthenticationEnabled(msgCtx);
-        int port = targetURL.getPort();
 
-        String protocol = targetURL.getProtocol();
-        if (port == -1) {
-            if (PROTOCOL_HTTP.equals(protocol)) {
-                port = 80;
-            } else if (PROTOCOL_HTTPS.equals(protocol)) {
-                port = 443;
-            }
-
-        }
-
-        // to see the host is a proxy and in the proxy list - available in axis2.xml
-        HostConfiguration config = new HostConfiguration();
-
-        // one might need to set his own socket factory. Let's allow that case as well.
-        Protocol protocolHandler =
-                (Protocol)msgCtx.getOptions().getProperty(HTTPConstants.CUSTOM_PROTOCOL_HANDLER);
-
-        // setting the real host configuration
-        // I assume the 90% case, or even 99% case will be no protocol handler case.
-        if (protocolHandler == null) {
-            config.setHost(targetURL.getHost(), port, targetURL.getProtocol());
-        } else {
-            config.setHost(targetURL.getHost(), port, protocolHandler);
-        }
-
         if (isAuthenticationEnabled) {
             // Basic, Digest, NTLM and custom authentications.
-            this.setAuthenticationInfo(client, msgCtx, config);
+            this.setAuthenticationInfo(client, msgCtx);
         }
-        // proxy configuration
-
+        // need to set to false because POST SOAP requests are not getting
+        // accepted by IIS/Sharepoint web services otherwise.
+        client.getParams().setBooleanParameter(CoreProtocolPNames.USE_EXPECT_CONTINUE, false);
+        
         if (ProxyConfiguration.isProxyEnabled(msgCtx,targetURL)) {
             log.debug("ProxyConfiguration");
             ProxyConfiguration proxyConfiguration = new ProxyConfiguration();
-            proxyConfiguration.configure(msgCtx,client,config);
+            proxyConfiguration.configure(msgCtx, client);
         }
-
-        return config;
     }
 
     protected boolean isAuthenticationEnabled(MessageContext msgCtx) {
@@ -298,9 +188,8 @@
     This will handle server Authentication, It could be either NTLM, Digest or Basic Authentication.
     Apart from that user can change the priory or add a custom authentication scheme.
     */
-    protected void setAuthenticationInfo(HttpClient agent,
-                                         MessageContext msgCtx,
-                                         HostConfiguration config) throws AxisFault {
+    protected void setAuthenticationInfo(AbstractHttpClient agent,
+                                         MessageContext msgCtx) throws AxisFault {
         HttpTransportProperties.Authenticator authenticator;
         Object obj = msgCtx.getProperty(HTTPConstants.AUTHENTICATE);
         if (obj != null) {
@@ -319,10 +208,11 @@
                 isAllowedRetry = authenticator.isAllowedRetry();
 
                 Credentials creds;
+ 	
+                // TODO port preemptive auth feature for httpclient 4.0
+               // agent.getParams()
+               //       .setAuthenticationPreemptive(authenticator.getPreemptiveAuthentication());
 
-                agent.getParams()
-                        .setAuthenticationPreemptive(authenticator.getPreemptiveAuthentication());
-
                 if (host != null) {
                     if (domain != null) {
                         /*Credentials for NTLM Authentication*/
@@ -331,28 +221,28 @@
                         /*Credentials for Digest and Basic Authentication*/
                         creds = new UsernamePasswordCredentials(username, password);
                     }
-                    agent.getState().setCredentials(new AuthScope(host, port, realm), creds);
+                    agent.getCredentialsProvider().setCredentials(new AuthScope(host, port, realm), creds);
                 } else {
                     if (domain != null) {
                         /*Credentials for NTLM Authentication when host is ANY_HOST*/
                         creds = new NTCredentials(username, password, AuthScope.ANY_HOST, domain);
-                        agent.getState().setCredentials(
+                        agent.getCredentialsProvider().setCredentials(
                                 new AuthScope(AuthScope.ANY_HOST, port, realm), creds);
                     } else {
                         /*Credentials only for Digest and Basic Authentication*/
                         creds = new UsernamePasswordCredentials(username, password);
-                        agent.getState().setCredentials(new AuthScope(AuthScope.ANY), creds);
+                        agent.getCredentialsProvider().setCredentials(new AuthScope(AuthScope.ANY), creds);
                     }
                 }
+                
+                if(host != null) {
+                	agent.getAuthSchemes().register("ntlm", new NTLMSchemeFactory());
+                }
                 /* Customizing the priority Order */
-                List schemes = authenticator.getAuthSchemes();
+               List schemes = authenticator.getAuthSchemes();
                 if (schemes != null && schemes.size() > 0) {
                     List authPrefs = new ArrayList(3);
                     for (int i = 0; i < schemes.size(); i++) {
-                        if (schemes.get(i) instanceof AuthPolicy) {
-                            authPrefs.add(schemes.get(i));
-                            continue;
-                        }
                         String scheme = (String) schemes.get(i);
                         if (HttpTransportProperties.Authenticator.BASIC.equals(scheme)) {
                             authPrefs.add(AuthPolicy.BASIC);
@@ -362,8 +252,9 @@
                             authPrefs.add(AuthPolicy.DIGEST);
                         }
                     }
-                    agent.getParams().setParameter(AuthPolicy.AUTH_SCHEME_PRIORITY,
-                            authPrefs);
+                    Axis2TargetAuthenticationHandler handler = new Axis2TargetAuthenticationHandler();
+                    handler.setAuthPreferences(schemes);
+                    agent.setTargetAuthenticationHandler(handler);
                 }
 
             } else {
@@ -378,20 +269,20 @@
      *
      * @param msgContext       - The messageContext of the request message
      * @param url              - The target URL
-     * @param httpMethod       - The http method used to send the request
+     * @param httpRequest       - The http method used to send the request
      * @param httpClient       - The httpclient used to send the request
      * @param soapActionString - The soap action atring of the request message
      * @return MessageFormatter - The messageFormatter for the relavent request message
      * @throws AxisFault - Thrown in case an exception occurs
      */
     protected MessageFormatter populateCommonProperties(MessageContext msgContext, URL url,
-                                                      HttpMethodBase httpMethod,
+                                                      HttpRequestBase httpRequest,
                                                       HttpClient httpClient,
                                                       String soapActionString)
             throws AxisFault {
-
-        if (isAuthenticationEnabled(msgContext)) {
-            httpMethod.setDoAuthentication(true);
+   
+        if (!isAuthenticationEnabled(msgContext)) {
+        	httpRequest.getParams().setBooleanParameter(ClientPNames.HANDLE_AUTHENTICATION, false);
         }
 
         MessageFormatter messageFormatter = TransportUtils.getMessageFormatter(
@@ -399,16 +290,17 @@
 
         url = messageFormatter.getTargetAddress(msgContext, format, url);
 
-        httpMethod.setPath(url.getPath());
+        try {
+			httpRequest.setURI(new URI(url.toString()));
+		} catch (URISyntaxException e) {
+			throw new AxisFault("Failed to create URI: " + e.getMessage(), e);
+		}
+        
+        httpRequest.setHeader(HTTPConstants.HEADER_CONTENT_TYPE, messageFormatter.getContentType(msgContext, format,
+                soapActionString));
 
-        httpMethod.setQueryString(url.getQuery());
+        httpRequest.setHeader(HTTPConstants.HEADER_HOST, url.getHost());
 
-        httpMethod.setRequestHeader(HTTPConstants.HEADER_CONTENT_TYPE,
-                                    messageFormatter.getContentType(msgContext, format,
-                                                                    soapActionString));
-
-        httpMethod.setRequestHeader(HTTPConstants.HEADER_HOST, url.getHost());
-
         if (msgContext.getOptions() != null && msgContext.getOptions().isManageSession()) {
             // setting the cookie in the out path
             Object cookieString = msgContext.getProperty(HTTPConstants.COOKIE_STRING);
@@ -416,12 +308,12 @@
             if (cookieString != null) {
                 StringBuffer buffer = new StringBuffer();
                 buffer.append(cookieString);
-                httpMethod.setRequestHeader(HTTPConstants.HEADER_COOKIE, buffer.toString());
+                httpRequest.setHeader(HTTPConstants.HEADER_COOKIE, buffer.toString());
             }
         }
 
         if (httpVersion.equals(HTTPConstants.HEADER_PROTOCOL_10)) {
-            httpClient.getParams().setVersion(HttpVersion.HTTP_1_0);
+        	HttpProtocolParams.setVersion(httpClient.getParams(), HttpVersion.HTTP_1_0);
         }
         return messageFormatter;
     }
@@ -447,24 +339,22 @@
         if (tempConnTimeoutProperty != null) {
             int connectionTimeout = tempConnTimeoutProperty.intValue();
             // timeout for initial connection
-            httpClient.getHttpConnectionManager().getParams().setConnectionTimeout(connectionTimeout);
+            ConnManagerParams.setTimeout(httpClient.getParams(), connectionTimeout);
         } else {
             // set timeout in client
             if (timeout > 0) {
-                httpClient.getHttpConnectionManager().getParams().setConnectionTimeout((int) timeout);
+            	ConnManagerParams.setTimeout(httpClient.getParams(), timeout);
             }
         }
 
         if (tempSoTimeoutProperty != null) {
             int soTimeout = tempSoTimeoutProperty.intValue();
             // SO_TIMEOUT -- timeout for blocking reads
-            httpClient.getHttpConnectionManager().getParams().setSoTimeout(soTimeout);
-            httpClient.getParams().setSoTimeout(soTimeout);
+            HttpConnectionParams.setSoTimeout(httpClient.getParams(), soTimeout);
         } else {
             // set timeout in client
             if (timeout > 0) {
-                httpClient.getHttpConnectionManager().getParams().setSoTimeout((int) timeout);
-                httpClient.getParams().setSoTimeout((int) timeout);
+            	HttpConnectionParams.setSoTimeout(httpClient.getParams(), (int) timeout);
             }
         }
     }
@@ -473,40 +363,38 @@
         this.format = format;
     }
 
-    protected HttpClient getHttpClient(MessageContext msgContext) {
-        HttpClient httpClient;
+    protected AbstractHttpClient getHttpClient(MessageContext msgContext) {
+    	AbstractHttpClient httpClient;
         Object reuse = msgContext.getOptions().getProperty(HTTPConstants.REUSE_HTTP_CLIENT);
         if (reuse == null) {
             reuse = msgContext.getConfigurationContext().getProperty(HTTPConstants.REUSE_HTTP_CLIENT);
         }
         if (reuse != null && JavaUtils.isTrueExplicitly(reuse)) {
-            httpClient = (HttpClient) msgContext.getOptions().getProperty(HTTPConstants.CACHED_HTTP_CLIENT);
+            httpClient = (AbstractHttpClient) msgContext.getOptions().getProperty(HTTPConstants.CACHED_HTTP_CLIENT);
             if (httpClient == null) {
-                httpClient = (HttpClient) msgContext.getConfigurationContext()
+                httpClient = (AbstractHttpClient) msgContext.getConfigurationContext()
                         .getProperty(HTTPConstants.CACHED_HTTP_CLIENT);
             }
             if (httpClient != null)
                 return httpClient;
-            MultiThreadedHttpConnectionManager connectionManager =
-                new MultiThreadedHttpConnectionManager();
-            httpClient = new HttpClient(connectionManager);
+  
+            httpClient = new MultiThreadedHttpClient();
             msgContext.getConfigurationContext()
                 .setProperty(HTTPConstants.CACHED_HTTP_CLIENT, httpClient);
         } else {
-            HttpConnectionManager connManager =
-                    (HttpConnectionManager) msgContext.getProperty(
+        	ClientConnectionManager connManager =
+                    (ClientConnectionManager) msgContext.getProperty(
                             HTTPConstants.MULTITHREAD_HTTP_CONNECTION_MANAGER);
             if (connManager == null) {
                 connManager =
-                        (HttpConnectionManager) msgContext.getProperty(
+                        (ClientConnectionManager) msgContext.getProperty(
                                 HTTPConstants.MUTTITHREAD_HTTP_CONNECTION_MANAGER);
             }
             if(connManager != null){
-                httpClient = new HttpClient(connManager);
+                httpClient = new DefaultHttpClient(connManager, null);
             } else {
                 //Multi threaded http connection manager has set as the default 
-                connManager = new MultiThreadedHttpConnectionManager();
-                httpClient = new HttpClient(connManager);
+                httpClient = new MultiThreadedHttpClient();
             }
         }
 
@@ -515,68 +403,69 @@
         return httpClient;
     }
 
-    protected void executeMethod(HttpClient httpClient, MessageContext msgContext, URL url,
-                                 HttpMethod method) throws IOException {
-        HostConfiguration config = this.getHostConfiguration(httpClient, msgContext, url);
+    protected HttpResponse executeMethod(AbstractHttpClient httpClient, MessageContext msgContext, URL url,
+                                 HttpRequestBase request) throws IOException {
+        configureHttpClient(httpClient, msgContext, url);
 
-        msgContext.setProperty(HTTPConstants.HTTP_METHOD, method);
+        msgContext.setProperty(HTTPConstants.HTTP_METHOD, request);
 
         // set the custom headers, if available
-        addCustomHeaders(method, msgContext);
+        addCustomHeaders(request, msgContext);
 
         // add compression headers if needed
         if (msgContext.isPropertyTrue(HTTPConstants.MC_ACCEPT_GZIP)) {
-            method.addRequestHeader(HTTPConstants.HEADER_ACCEPT_ENCODING,
+        	request.addHeader(HTTPConstants.HEADER_ACCEPT_ENCODING,
                     HTTPConstants.COMPRESSION_GZIP);
         }
 
         if (msgContext.isPropertyTrue(HTTPConstants.MC_GZIP_REQUEST)) {
-            method.addRequestHeader(HTTPConstants.HEADER_CONTENT_ENCODING,
+        	request.addHeader(HTTPConstants.HEADER_CONTENT_ENCODING,
                     HTTPConstants.COMPRESSION_GZIP);
         }
 
-        String cookiePolicy = (String) msgContext.getProperty(HTTPConstants.COOKIE_POLICY);
+        String cookiePolicy = (String) msgContext.getProperty(ClientPNames.COOKIE_POLICY);
         if (cookiePolicy != null) {
-            method.getParams().setCookiePolicy(cookiePolicy);   
+        	httpClient.getParams().setParameter(ClientPNames.COOKIE_POLICY, cookiePolicy);   
         }
-        httpClient.executeMethod(config, method);
+
+        return httpClient.execute(getTargetHost(url), request);
     }
 
-    public void addCustomHeaders(HttpMethod method, MessageContext msgContext) {
+    public void addCustomHeaders(HttpRequestBase request, MessageContext msgContext) {
 
         boolean isCustomUserAgentSet = false;
         // set the custom headers, if available
         Object httpHeadersObj = msgContext.getProperty(HTTPConstants.HTTP_HEADERS);
         if (httpHeadersObj != null) {
             if (httpHeadersObj instanceof ArrayList) {
-                ArrayList httpHeaders = (ArrayList) httpHeadersObj;
-                Header header;
+                List httpHeaders = (List)httpHeadersObj;
+                NamedValue namedValue;
                 for (int i = 0; i < httpHeaders.size(); i++) {
-                    header = (Header) httpHeaders.get(i);
-                    if (HTTPConstants.HEADER_USER_AGENT.equals(header.getName())) {
+                	namedValue = (NamedValue) httpHeaders.get(i);
+                    if (HTTPConstants.HEADER_USER_AGENT.equals(namedValue.getName())) {
                         isCustomUserAgentSet = true;
                     }
-                    method.addRequestHeader(header);
+                    request.addHeader(namedValue.getName(), namedValue.getValue());
                 }
     
             }
             if (httpHeadersObj instanceof Map) {
-                Map httpHeaders = (Map) httpHeadersObj;
+                Map httpHeaders = (Map)httpHeadersObj;
                 for (Iterator iterator = httpHeaders.entrySet().iterator(); iterator.hasNext();) {
-                    Map.Entry entry  = (Map.Entry) iterator.next();
-                    String key = (String) entry.getKey();
-                    String value = (String) entry.getValue();
+                    Map.Entry entry  = (Map.Entry)iterator.next();
+                    String key = (String)entry.getKey();
+                    String value = (String)entry.getValue();
                     if (HTTPConstants.HEADER_USER_AGENT.equals(key)) {
                         isCustomUserAgentSet = true;
                     }
-                    method.addRequestHeader(key, value);
+                    request.addHeader(key, value);
                 }
             }
         }
 
         if (!isCustomUserAgentSet) {
             String userAgentString = getUserAgent(msgContext);
-            method.setRequestHeader(HTTPConstants.HEADER_USER_AGENT, userAgentString);
+            request.setHeader(HTTPConstants.HEADER_USER_AGENT, userAgentString);
         }
 
     }
@@ -604,4 +493,136 @@
 
         return userAgentString;
     }
+
+	/**
+     * Collect the HTTP header information and set them in the message context
+     *
+     * @param method HttpResponse from which to get information
+     * @param msgContext the MessageContext in which to place the information... OR NOT!
+     * @throws AxisFault if problems occur
+     */
+    protected void obtainHTTPHeaderInformation(HttpResponse response,
+                                               MessageContext msgContext) throws AxisFault {
+        // Set RESPONSE properties onto the REQUEST message context.  They will need to be copied off the request context onto
+        // the response context elsewhere, for example in the OutInOperationClient.
+        Map transportHeaders = new CommonsTransportHeaders(response.getAllHeaders());
+        msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, transportHeaders);
+        msgContext.setProperty(HTTPConstants.MC_HTTP_STATUS_CODE, new Integer(response.getStatusLine().getStatusCode()));
+        Header header = response.getEntity().getContentType();
+
+        if (header != null) {
+            HeaderElement[] headers = header.getElements();
+            MessageContext inMessageContext = msgContext.getOperationContext().getMessageContext(
+                    WSDLConstants.MESSAGE_LABEL_IN_VALUE);
+
+            Object contentType = header.getValue();
+            Object charSetEnc = null;
+
+            for (int i = 0; i < headers.length; i++) {
+                NameValuePair charsetEnc = headers[i].getParameterByName(
+                        HTTPConstants.CHAR_SET_ENCODING);
+                if (charsetEnc != null) {
+                    charSetEnc = charsetEnc.getValue();
+                }
+            }
+
+            if (inMessageContext != null) {
+                inMessageContext
+                        .setProperty(Constants.Configuration.CONTENT_TYPE, contentType);
+                inMessageContext
+                        .setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEnc);
+            } else {
+
+                // Transport details will be stored in a HashMap so that anybody interested can
+                // retrieve them
+                Map transportInfoMap = new HashMap();
+                transportInfoMap.put(Constants.Configuration.CONTENT_TYPE, contentType);
+                transportInfoMap.put(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEnc);
+
+                //the HashMap is stored in the outgoing message.
+                msgContext.setProperty(Constants.Configuration.TRANSPORT_INFO_MAP,
+                                       transportInfoMap);
+            }
+        }
+
+        String sessionCookie = null;
+        // Process old style headers first
+        Header[] cookieHeaders = response.getHeaders(HTTPConstants.HEADER_SET_COOKIE);
+        String customCoookiId = (String) msgContext.getProperty(Constants.CUSTOM_COOKIE_ID);
+        for (int i = 0; i < cookieHeaders.length; i++) {
+            HeaderElement[] elements = cookieHeaders[i].getElements();
+            for (int e = 0; e < elements.length; e++) {
+                HeaderElement element = elements[e];
+                if (Constants.SESSION_COOKIE.equalsIgnoreCase(element.getName()) ||
+                        Constants.SESSION_COOKIE_JSESSIONID.equalsIgnoreCase(element.getName())) {
+                    sessionCookie = processCookieHeader(element);
+                }
+                if (customCoookiId != null && customCoookiId.equalsIgnoreCase(element.getName())) {
+                    sessionCookie = processCookieHeader(element);
+                }
+            }
+        }
+        // Overwrite old style cookies with new style ones if present
+        cookieHeaders = response.getHeaders(HTTPConstants.HEADER_SET_COOKIE2);
+        for (int i = 0; i < cookieHeaders.length; i++) {
+            HeaderElement[] elements = cookieHeaders[i].getElements();
+            for (int e = 0; e < elements.length; e++) {
+                HeaderElement element = elements[e];
+                if (Constants.SESSION_COOKIE.equalsIgnoreCase(element.getName()) ||
+                        Constants.SESSION_COOKIE_JSESSIONID.equalsIgnoreCase(element.getName())) {
+                    sessionCookie = processCookieHeader(element);
+                }
+                if(customCoookiId!=null&&customCoookiId.equalsIgnoreCase(element.getName())){
+                    sessionCookie = processCookieHeader(element);
+                }
+            }
+        }
+
+        if (sessionCookie != null) {
+            msgContext.getServiceContext().setProperty(HTTPConstants.COOKIE_STRING, sessionCookie);
+        }
+    }
+    
+    private String processCookieHeader(HeaderElement element) {
+        String cookie = element.getName() + "=" + element.getValue();
+        NameValuePair[] parameters =  element.getParameters();
+        for (int j = 0; parameters != null && j < parameters.length; j++) {
+            NameValuePair parameter = parameters[j];
+            cookie = cookie + "; " + parameter.getName() + "=" + parameter.getValue();
+        }
+        return cookie;
+    }
+
+    protected void processResponse(HttpResponse httpResponse,
+                                   MessageContext msgContext)
+            throws IOException {
+        obtainHTTPHeaderInformation(httpResponse, msgContext);
+ 
+        // ensure that http connection is released. A better option would have been
+        // to use a response callback handler, but time constraints dictates I use this
+        // quick patch. The main drawback to this approach is the full inputstream is loaded in memory
+        // instead of just streamed. Since we are using this patched axis2 version in a controlled
+        // environment it shouldnt be a problem.
+        // TODO use a responsehandler callback instead, see HttpClient javadoc for more info
+        HttpEntity bufferedHttpEntity = new BufferedHttpEntity(httpResponse.getEntity());
+        InputStream in = bufferedHttpEntity.getContent();
+        if (in == null) {
+            throw new AxisFault(Messages.getMessage("canNotBeNull", "InputStream"));
+        }
+        Header contentEncoding = bufferedHttpEntity.getContentEncoding();
+        if (contentEncoding != null) {
+            if (contentEncoding.getValue().
+                    equalsIgnoreCase(HTTPConstants.COMPRESSION_GZIP)) {
+                in = new GZIPInputStream(in);
+            } else {
+                throw new AxisFault("HTTP :" + "unsupported content-encoding of '"
+                        + contentEncoding.getValue() + "' found");
+            }
+        }
+
+        OperationContext opContext = msgContext.getOperationContext();
+        if (opContext != null) {
+            opContext.setProperty(MessageContext.TRANSPORT_IN, in);
+        }
+    }
 }
Index: modules/kernel/src/org/apache/axis2/transport/http/RESTRequestEntity2.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/RESTRequestEntity2.java	(revision 765719)
+++ modules/kernel/src/org/apache/axis2/transport/http/RESTRequestEntity2.java	(working copy)
@@ -19,12 +19,16 @@
 
 package org.apache.axis2.transport.http;
 
-import org.apache.commons.httpclient.methods.RequestEntity;
-
+import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.OutputStream;
 
-public class RESTRequestEntity2 implements RequestEntity {
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
+
+public class RESTRequestEntity2 implements HttpEntity {
     private String contentType;
     private String postRequestBody;
 
@@ -33,19 +37,40 @@
         this.contentType = contentType;
     }
 
-    public void writeRequest(OutputStream output) throws IOException {
-        output.write(postRequestBody.getBytes());
-    }
-
     public long getContentLength() {
         return this.postRequestBody.getBytes().length;
     }
 
-    public String getContentType() {
-        return this.contentType;
+    public Header getContentType() {
+        return new BasicHeader(HTTPConstants.HEADER_CONTENT_TYPE, this.contentType);
     }
 
     public boolean isRepeatable() {
         return true;
     }
+
+	public void consumeContent() throws IOException {
+		// TODO not sure what to do here
+		
+	}
+
+	public InputStream getContent() throws IOException, IllegalStateException {
+		return new ByteArrayInputStream(this.postRequestBody.getBytes());
+	}
+
+	public Header getContentEncoding() {
+		return null;
+	}
+
+	public boolean isChunked() {
+		return false;
+	}
+
+	public boolean isStreaming() {
+		return false;
+	}
+
+	public void writeTo(OutputStream outstream) throws IOException {
+		outstream.write(postRequestBody.getBytes());
+	}
 }
Index: modules/kernel/src/org/apache/axis2/transport/http/ProxyConfiguration.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/ProxyConfiguration.java	(revision 765719)
+++ modules/kernel/src/org/apache/axis2/transport/http/ProxyConfiguration.java	(working copy)
@@ -19,22 +19,24 @@
 
 package org.apache.axis2.transport.http;
 
+import java.net.URL;
+import java.util.StringTokenizer;
+
+import javax.xml.namespace.QName;
+
 import org.apache.axiom.om.OMElement;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.description.Parameter;
-import org.apache.commons.httpclient.Credentials;
-import org.apache.commons.httpclient.HostConfiguration;
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.NTCredentials;
-import org.apache.commons.httpclient.UsernamePasswordCredentials;
-import org.apache.commons.httpclient.auth.AuthScope;
+import org.apache.http.HttpHost;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.Credentials;
+import org.apache.http.auth.NTCredentials;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.conn.params.ConnRoutePNames;
+import org.apache.http.impl.client.AbstractHttpClient;
 
-import javax.xml.namespace.QName;
-import java.net.URL;
-import java.util.StringTokenizer;
 
-
 /**
  * The purpose of this class is to configure the proxy auth regardles of the protocol.
  * Proxy will be set only for HTTP connection
@@ -59,8 +61,7 @@
     protected static final String PROXY_PASSWORD_ELEMENT = "ProxyPassword";
 
     public void configure(MessageContext messageContext,
-                          HttpClient httpClient,
-                          HostConfiguration config) throws AxisFault {
+                          AbstractHttpClient httpClient) throws AxisFault {
 
         //        <parameter name="Proxy">
         //              <Configuration>
@@ -195,8 +196,10 @@
             throw new AxisFault(ProxyConfiguration.class.getName() +
                                     " Minimum proxy credentials are not set");
         }
-        httpClient.getState().setProxyCredentials(AuthScope.ANY, proxyCred);
-        config.setProxy(this.getProxyHost(), this.getProxyPort());
+        HttpHost proxyHost = new HttpHost(this.getProxyHost(), this.getProxyPort());
+        
+        httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxyHost);
+        httpClient.getCredentialsProvider().setCredentials(AuthScope.ANY, proxyCred);
     }
 
     /**
Index: modules/kernel/src/org/apache/axis2/transport/http/HttpTransportProperties.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/HttpTransportProperties.java	(revision 765719)
+++ modules/kernel/src/org/apache/axis2/transport/http/HttpTransportProperties.java	(working copy)
@@ -19,13 +19,13 @@
 
 package org.apache.axis2.transport.http;
 
-import org.apache.commons.httpclient.HttpVersion;
-import org.apache.commons.httpclient.auth.AuthPolicy;
-import org.apache.commons.httpclient.auth.AuthScope;
-
 import java.util.List;
 import java.util.Properties;
 
+import org.apache.http.HttpVersion;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.client.params.AuthPolicy;
+
 /**
  * Utility bean for setting transport properties in runtime.
  */
Index: modules/kernel/src/org/apache/axis2/transport/http/AxisRequestEntity.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/AxisRequestEntity.java	(revision 765719)
+++ modules/kernel/src/org/apache/axis2/transport/http/AxisRequestEntity.java	(working copy)
@@ -19,102 +19,130 @@
 
 package org.apache.axis2.transport.http;
 
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.zip.GZIPOutputStream;
+
+import javax.xml.stream.FactoryConfigurationError;
+
 import org.apache.axiom.om.OMOutputFormat;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.transport.MessageFormatter;
 import org.apache.axis2.util.JavaUtils;
-import org.apache.commons.httpclient.methods.RequestEntity;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
 
-import javax.xml.stream.FactoryConfigurationError;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.zip.GZIPOutputStream;
-
 /**
  * This Request Entity is used by the HTTPCommonsTransportSender. This wraps the
  * Axis2 message formatter object.
  */
-public class AxisRequestEntity implements RequestEntity {
+public class AxisRequestEntity implements HttpEntity {
 
-    private MessageFormatter messageFormatter;
+	private MessageFormatter messageFormatter;
 
-    private boolean chunked = false;
+	private boolean chunked = false;
 
-    private MessageContext messageContext;
+	private MessageContext messageContext;
 
-    private byte[] bytes;
+	private byte[] bytes;
 
-    private boolean isAllowedRetry;
+	private boolean isAllowedRetry;
 
-    private OMOutputFormat format;
+	private OMOutputFormat format;
 
-    private String soapAction;
+	private String soapAction;
 
-    /**
-     * Method calls to this request entity are delegated to the following Axis2
-     * message formatter object.
-     *
-     * @param messageFormatter
-     */
-    public AxisRequestEntity(MessageFormatter messageFormatter,
-                             MessageContext msgContext, OMOutputFormat format, String soapAction,
-                             boolean chunked, boolean isAllowedRetry) {
-        this.messageFormatter = messageFormatter;
-        this.messageContext = msgContext;
-        this.chunked = chunked;
-        this.isAllowedRetry = isAllowedRetry;
-        this.format = format;
-        this.soapAction = soapAction;
-    }
+	/**
+	 * Method calls to this request entity are delegated to the following Axis2
+	 * message formatter object.
+	 * 
+	 * @param messageFormatter
+	 */
+	public AxisRequestEntity(MessageFormatter messageFormatter,
+			MessageContext msgContext, OMOutputFormat format,
+			String soapAction, boolean chunked, boolean isAllowedRetry) {
+		this.messageFormatter = messageFormatter;
+		this.messageContext = msgContext;
+		this.chunked = chunked;
+		this.isAllowedRetry = isAllowedRetry;
+		this.format = format;
+		this.soapAction = soapAction;
+	}
 
-    public boolean isRepeatable() {
-        // All Axis2 request entity implementations were returning this true
-        // So we return true as defualt
-        return true;
-    }
+	public boolean isRepeatable() {
+		// All Axis2 request entity implementations were returning this true
+		// So we return true as defualt
+		return true;
+	}
 
-    public void writeRequest(OutputStream outStream) throws IOException {
-        Object gzip = messageContext.getOptions().getProperty(HTTPConstants.MC_GZIP_REQUEST);
-        if (gzip != null && JavaUtils.isTrueExplicitly(gzip) && chunked) {
-            outStream = new GZIPOutputStream(outStream);
-        }
-        try {
-            if (chunked) {
-                messageFormatter.writeTo(messageContext, format, outStream, isAllowedRetry);
-            } else {
-                if (bytes == null) {
-                    bytes = messageFormatter.getBytes(messageContext, format);
-                }
-                outStream.write(bytes);
-            }
-            if (outStream instanceof GZIPOutputStream) {
-                ((GZIPOutputStream) outStream).finish();
-            }
-            outStream.flush();
-        } catch (FactoryConfigurationError e) {
-            throw AxisFault.makeFault(e);
-        } catch (IOException e) {
-            throw AxisFault.makeFault(e);
-        }
+	public long getContentLength() {
+		if (chunked) {
+			return -1;
+		}
+		if (bytes == null) {
+			try {
+				bytes = messageFormatter.getBytes(messageContext, format);
+			} catch (AxisFault e) {
+				return -1;
+			}
+		}
+		return bytes.length;
+	}
 
-    }
+	public Header getContentType() {
+		return new BasicHeader(HTTPConstants.HEADER_CONTENT_TYPE, messageFormatter.getContentType(messageContext, format,
+				soapAction));
+	}
 
-    public long getContentLength() {
-        if (chunked) {
-            return -1;
-        }
-        if (bytes == null) {
-            try {
-                bytes = messageFormatter.getBytes(messageContext, format);
-            } catch (AxisFault e) {
-                return -1;
-            }
-        }
-        return bytes.length;
-    }
+	public void consumeContent() throws IOException {
+		// TODO not sure what to do here.
 
-    public String getContentType() {
-        return messageFormatter.getContentType(messageContext, format, soapAction);
-    }
+	}
+
+	public InputStream getContent() throws IOException, IllegalStateException {
+		return new ByteArrayInputStream(messageFormatter.getBytes(messageContext, format));
+	}
+
+	public Header getContentEncoding() {
+		return null;
+	}
+
+	public boolean isChunked() {
+		return chunked;
+	}
+
+	public boolean isStreaming() {
+		return false;
+	}
+
+	public void writeTo(OutputStream outstream) throws IOException {
+		Object gzip = messageContext.getOptions().getProperty(
+				HTTPConstants.MC_GZIP_REQUEST);
+		if (gzip != null && JavaUtils.isTrueExplicitly(gzip) && chunked) {
+			outstream = new GZIPOutputStream(outstream);
+		}
+		try {
+			if (chunked) {
+				messageFormatter.writeTo(messageContext, format, outstream,
+						isAllowedRetry);
+			} else {
+				if (bytes == null) {
+					bytes = messageFormatter.getBytes(messageContext, format);
+				}
+				outstream.write(bytes);
+			}
+			if (outstream instanceof GZIPOutputStream) {
+				((GZIPOutputStream) outstream).finish();
+			}
+			outstream.flush();
+		} catch (FactoryConfigurationError e) {
+			throw AxisFault.makeFault(e);
+		} catch (IOException e) {
+			throw AxisFault.makeFault(e);
+		}
+	}
 }
Index: modules/kernel/src/org/apache/axis2/transport/http/HTTPSender.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/HTTPSender.java	(revision 765719)
+++ modules/kernel/src/org/apache/axis2/transport/http/HTTPSender.java	(working copy)
@@ -19,6 +19,8 @@
 
 package org.apache.axis2.transport.http;
 
+import java.io.IOException;
+import java.net.URL;
 
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
@@ -27,275 +29,274 @@
 import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.transport.MessageFormatter;
 import org.apache.axis2.wsdl.WSDLConstants;
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.HttpMethod;
-import org.apache.commons.httpclient.HttpMethodBase;
-import org.apache.commons.httpclient.HttpStatus;
-import org.apache.commons.httpclient.methods.DeleteMethod;
-import org.apache.commons.httpclient.methods.GetMethod;
-import org.apache.commons.httpclient.methods.PostMethod;
-import org.apache.commons.httpclient.methods.PutMethod;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.methods.HttpDelete;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.client.methods.HttpPut;
+import org.apache.http.client.methods.HttpRequestBase;
+import org.apache.http.impl.client.AbstractHttpClient;
 
-import java.io.IOException;
-import java.net.URL;
-
 public class HTTPSender extends AbstractHTTPSender {
 
-    private static final Log log = LogFactory.getLog(HTTPSender.class);
+	private static final Log log = LogFactory.getLog(HTTPSender.class);
 
-    public void send(MessageContext msgContext, URL url, String soapActionString)
-            throws IOException {
+	public void send(MessageContext msgContext, URL url, String soapActionString)
+			throws IOException {
 
-        // execute the HtttpMethodBase - a connection manager can be given for
-        // handle multiple
+		// execute the HtttpMethodBase - a connection manager can be given for
+		// handle multiple
 
-        String httpMethod =
-                (String) msgContext.getProperty(Constants.Configuration.HTTP_METHOD);
+		String httpMethod = (String) msgContext
+				.getProperty(Constants.Configuration.HTTP_METHOD);
 
-        if ((httpMethod != null)) {
+		if ((httpMethod != null)) {
 
-            if (Constants.Configuration.HTTP_METHOD_GET.equalsIgnoreCase(httpMethod)) {
-                this.sendViaGet(msgContext, url, soapActionString);
+			if (Constants.Configuration.HTTP_METHOD_GET
+					.equalsIgnoreCase(httpMethod)) {
+				this.sendViaGet(msgContext, url, soapActionString);
 
-                return;
-            } else if (Constants.Configuration.HTTP_METHOD_DELETE.equalsIgnoreCase(httpMethod)) {
-                this.sendViaDelete(msgContext, url, soapActionString);
+				return;
+			} else if (Constants.Configuration.HTTP_METHOD_DELETE
+					.equalsIgnoreCase(httpMethod)) {
+				this.sendViaDelete(msgContext, url, soapActionString);
 
-                return;
-            } else if (Constants.Configuration.HTTP_METHOD_PUT.equalsIgnoreCase(httpMethod)) {
-                this.sendViaPut(msgContext, url, soapActionString);
+				return;
+			} else if (Constants.Configuration.HTTP_METHOD_PUT
+					.equalsIgnoreCase(httpMethod)) {
+				this.sendViaPut(msgContext, url, soapActionString);
 
-                return;
-            }
-        }
+				return;
+			}
+		}
 
-        this.sendViaPost(msgContext, url, soapActionString);
-    }
+		this.sendViaPost(msgContext, url, soapActionString);
+	}
 
-    /**
-     * Used to send a request via HTTP Get method
-     *
-     * @param msgContext        - The MessageContext of the message
-     * @param url               - The target URL
-     * @param soapActiionString - The soapAction string of the request
-     * @throws AxisFault - Thrown in case an exception occurs
-     */
-    private void sendViaGet(MessageContext msgContext, URL url, String soapActiionString)
-            throws AxisFault {
+	/**
+	 * Used to send a request via HTTP Get method
+	 * 
+	 * @param msgContext -
+	 *            The MessageContext of the message
+	 * @param url -
+	 *            The target URL
+	 * @param soapActiionString -
+	 *            The soapAction string of the request
+	 * @throws AxisFault -
+	 *             Thrown in case an exception occurs
+	 */
+	private void sendViaGet(MessageContext msgContext, URL url,
+			String soapActionString) throws AxisFault {
 
-        GetMethod getMethod = new GetMethod();
-        HttpClient httpClient = getHttpClient(msgContext);
-        MessageFormatter messageFormatter =
-                populateCommonProperties(msgContext, url, getMethod, httpClient, soapActiionString);
+		HttpGet getRequest = new HttpGet();
+		AbstractHttpClient httpClient = getHttpClient(msgContext);
+		MessageFormatter messageFormatter = populateCommonProperties(
+				msgContext, url, getRequest, httpClient, soapActionString);
 
-        // Need to have this here because we can have soap action when using the soap response MEP
-        String soapAction =
-                messageFormatter.formatSOAPAction(msgContext, format, soapActiionString);
+		// Need to have this here because we can have soap action when using the
+		// soap response MEP
+		String soapAction = messageFormatter.formatSOAPAction(msgContext,
+				format, soapActionString);
 
-        if (soapAction != null) {
-            getMethod.setRequestHeader(HTTPConstants.HEADER_SOAP_ACTION, soapAction);
-        }
-        try {
-            executeMethod(httpClient, msgContext, url, getMethod);
-            handleResponse(msgContext, getMethod);
-        } catch (IOException e) {
-            log.info("Unable to sendViaGet to url[" + url + "]", e);
-            throw AxisFault.makeFault(e);
-        } finally {
-            cleanup(msgContext, getMethod);
-        }
-    }
+		if (soapAction != null) {
+			getRequest.setHeader(HTTPConstants.HEADER_SOAP_ACTION, soapAction);
+		}
+		doSend(httpClient, msgContext, url, getRequest);
+	}
 
-    private void cleanup(MessageContext msgContext, HttpMethod method) {
-        if (msgContext.isPropertyTrue(HTTPConstants.AUTO_RELEASE_CONNECTION)) {
-            method.releaseConnection();
-        }
-    }
+	/*
+	 * TODO no need to auto release connection, httpclient 4.0 already does that
+	 * behavior. private void cleanup(MessageContext msgContext, HttpMethod
+	 * method) { if
+	 * (msgContext.isPropertyTrue(HTTPConstants.AUTO_RELEASE_CONNECTION)) {
+	 * method.releaseConnection(); } }
+	 */
 
-    /**
-     * Used to send a request via HTTP Delete Method
-     *
-     * @param msgContext        - The MessageContext of the message
-     * @param url               - The target URL
-     * @param soapActiionString - The soapAction string of the request
-     * @throws AxisFault - Thrown in case an exception occurs
-     */
-    private void sendViaDelete(MessageContext msgContext, URL url, String soapActiionString)
-            throws AxisFault {
+	/**
+	 * Used to send a request via HTTP Delete Method
+	 * 
+	 * @param msgContext -
+	 *            The MessageContext of the message
+	 * @param url -
+	 *            The target URL
+	 * @param soapActiionString -
+	 *            The soapAction string of the request
+	 * @throws AxisFault -
+	 *             Thrown in case an exception occurs
+	 */
+	private void sendViaDelete(MessageContext msgContext, URL url,
+			String soapActiionString) throws AxisFault {
 
-        DeleteMethod deleteMethod = new DeleteMethod();
-        HttpClient httpClient = getHttpClient(msgContext);
-        populateCommonProperties(msgContext, url, deleteMethod, httpClient, soapActiionString);
+		HttpDelete deleteRequest = new HttpDelete();
+		AbstractHttpClient httpClient = getHttpClient(msgContext);
+		populateCommonProperties(msgContext, url, deleteRequest, httpClient,
+				soapActiionString);
 
-        try {
-            executeMethod(httpClient, msgContext, url, deleteMethod);
-            handleResponse(msgContext, deleteMethod);
-        } catch (IOException e) {
-            log.info("Unable to sendViaDelete to url[" + url + "]", e);
-            throw AxisFault.makeFault(e);
-        } finally {
-            cleanup(msgContext, deleteMethod);
-        }
-    }
+		doSend(httpClient, msgContext, url, deleteRequest);
+	}
 
-    /**
-     * Used to send a request via HTTP Post Method
-     *
-     * @param msgContext       - The MessageContext of the message
-     * @param url              - The target URL
-     * @param soapActionString - The soapAction string of the request
-     * @throws AxisFault - Thrown in case an exception occurs
-     */
-    private void sendViaPost(MessageContext msgContext, URL url,
-                             String soapActionString) throws AxisFault {
+	/**
+	 * Used to send a request via HTTP Post Method
+	 * 
+	 * @param msgContext -
+	 *            The MessageContext of the message
+	 * @param url -
+	 *            The target URL
+	 * @param soapActionString -
+	 *            The soapAction string of the request
+	 * @throws AxisFault -
+	 *             Thrown in case an exception occurs
+	 */
+	private void sendViaPost(MessageContext msgContext, URL url,
+			String soapActionString) throws AxisFault {
 
+		AbstractHttpClient httpClient = getHttpClient(msgContext);
 
-        HttpClient httpClient = getHttpClient(msgContext);
+		/*
+		 * What's up with this, it never gets used anywhere?? --Glen String
+		 * charEncoding = (String)
+		 * msgContext.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
+		 * 
+		 * if (charEncoding == null) { charEncoding =
+		 * MessageContext.DEFAULT_CHAR_SET_ENCODING; }
+		 */
 
-/*  What's up with this, it never gets used anywhere?? --Glen
-        String charEncoding =
-                (String) msgContext.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
+		HttpPost postRequest = new HttpPost();
+		MessageFormatter messageFormatter = populateCommonProperties(
+				msgContext, url, postRequest, httpClient, soapActionString);
 
-        if (charEncoding == null) {
-            charEncoding = MessageContext.DEFAULT_CHAR_SET_ENCODING;
-        }
-*/
+		postRequest.setEntity(new AxisRequestEntity(messageFormatter,
+				msgContext, format, soapActionString, chunked, isAllowedRetry));
 
-        PostMethod postMethod = new PostMethod();
-        MessageFormatter messageFormatter =
-                populateCommonProperties(msgContext, url, postMethod, httpClient, soapActionString);
+		String soapAction = messageFormatter.formatSOAPAction(msgContext,
+				format, soapActionString);
 
-        postMethod.setRequestEntity(new AxisRequestEntity(messageFormatter,
-                                                          msgContext, format, soapActionString,
-                                                          chunked, isAllowedRetry));
+		if (soapAction != null) {
+			postRequest.setHeader(HTTPConstants.HEADER_SOAP_ACTION, soapAction);
+		}
 
-        if (!httpVersion.equals(HTTPConstants.HEADER_PROTOCOL_10) && chunked) {
-            postMethod.setContentChunked(true);
-        }
+		doSend(httpClient, msgContext, url, postRequest);
+	}
 
-        String soapAction = messageFormatter.formatSOAPAction(msgContext, format, soapActionString);
+	/**
+	 * Used to send a request via HTTP Put Method
+	 * 
+	 * @param msgContext -
+	 *            The MessageContext of the message
+	 * @param url -
+	 *            The target URL
+	 * @param soapActionString -
+	 *            The soapAction string of the request
+	 * @throws AxisFault -
+	 *             Thrown in case an exception occurs
+	 */
+	private void sendViaPut(MessageContext msgContext, URL url,
+			String soapActionString) throws AxisFault {
 
-        if (soapAction != null) {
-            postMethod.setRequestHeader(HTTPConstants.HEADER_SOAP_ACTION, soapAction);
-        }
+		AbstractHttpClient httpClient = getHttpClient(msgContext);
 
-        /*
-         *   main excecution takes place..
-         */
-        try {
-            executeMethod(httpClient, msgContext, url, postMethod);
-            handleResponse(msgContext, postMethod);
-        } catch (IOException e) {
-            log.info("Unable to sendViaPost to url[" + url + "]", e);
-            throw AxisFault.makeFault(e);
-        } finally {
-            cleanup(msgContext, postMethod);
-        }
-    }
+		/*
+		 * Same deal - this value never gets used, why is it here? --Glen String
+		 * charEncoding = (String)
+		 * msgContext.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
+		 * 
+		 * if (charEncoding == null) { charEncoding =
+		 * MessageContext.DEFAULT_CHAR_SET_ENCODING; }
+		 */
 
-    /**
-     * Used to send a request via HTTP Put Method
-     *
-     * @param msgContext       - The MessageContext of the message
-     * @param url              - The target URL
-     * @param soapActionString - The soapAction string of the request
-     * @throws AxisFault - Thrown in case an exception occurs
-     */
-    private void sendViaPut(MessageContext msgContext, URL url,
-                            String soapActionString) throws AxisFault {
+		HttpPut putRequest = new HttpPut();
+		MessageFormatter messageFormatter = populateCommonProperties(
+				msgContext, url, putRequest, httpClient, soapActionString);
 
+		putRequest.setEntity(new AxisRequestEntity(messageFormatter, msgContext,
+				format, soapActionString, chunked, isAllowedRetry));
 
-        HttpClient httpClient = getHttpClient(msgContext);
+		String soapAction = messageFormatter.formatSOAPAction(msgContext,
+				format, soapActionString);
+		if (soapAction != null) {
+			putRequest.setHeader(HTTPConstants.HEADER_SOAP_ACTION, soapAction);
+		}
 
-/*  Same deal - this value never gets used, why is it here? --Glen
-        String charEncoding =
-                (String) msgContext.getProperty(Constants.Configuration.CHARACTER_SET_ENCODING);
+		doSend(httpClient, msgContext, url, putRequest);
+	}
+	
+	private void doSend(AbstractHttpClient httpClient, MessageContext msgContext, URL url, HttpRequestBase httpRequest) throws AxisFault {
+		/*
+		 * main excecution takes place..
+		 */
+		HttpResponse response = null;
+		try {
+			response = executeMethod(httpClient, msgContext, url, httpRequest);
+			handleResponse(msgContext, response);
+		} catch (IOException e) {
+			log.info("Unable to doSend: " + httpRequest.getRequestLine().toString() + " to url[" + url + "]", e);
+			cleanup(response);
+			throw AxisFault.makeFault(e);
+		}
+	}
+	
+	private void cleanup(HttpResponse response) {
+		if(response != null) {
+			HttpEntity httpEntity = response.getEntity();
+			if(httpEntity != null) {
+				try {
+					httpEntity.consumeContent();
+				} catch (IOException e) {
+					log.warn("Failed to cleanup response:" + e.getMessage(), e);
+				}
+			}
+		}
+	}
 
-        if (charEncoding == null) {
-            charEncoding = MessageContext.DEFAULT_CHAR_SET_ENCODING;
-        }
-*/
+	/**
+	 * Used to handle the HTTP Response
+	 * 
+	 * @param msgContext - The MessageContext of the message
+	 * @param response - The HTTP response to handle
+	 * @throws IOException - Thrown in case an exception occurs
+	 */
+	private void handleResponse(MessageContext msgContext, HttpResponse response)
+			throws IOException {
 
-        PutMethod putMethod = new PutMethod();
-        MessageFormatter messageFormatter =
-                populateCommonProperties(msgContext, url, putMethod, httpClient, soapActionString);
+		int statusCode = response.getStatusLine().getStatusCode();
+		if (statusCode == HttpStatus.SC_OK) {
+			processResponse(response, msgContext);
+		} else if (statusCode == HttpStatus.SC_ACCEPTED) {
 
-        putMethod.setRequestEntity(new AxisRequestEntity(messageFormatter,
-                                                         msgContext, format, soapActionString,
-                                                         chunked, isAllowedRetry));
-
-        if (!httpVersion.equals(HTTPConstants.HEADER_PROTOCOL_10) && chunked) {
-            putMethod.setContentChunked(true);
-        }
-
-        String soapAction = messageFormatter.formatSOAPAction(msgContext, format, soapActionString);
-        if (soapAction != null) {
-            putMethod.setRequestHeader(HTTPConstants.HEADER_SOAP_ACTION, soapAction);
-        }
-
-        /*
-         *   main excecution takes place..
-         */
-        try {
-            executeMethod(httpClient, msgContext, url, putMethod);
-            handleResponse(msgContext, putMethod);
-        } catch (IOException e) {
-            log.info("Unable to sendViaPut to url[" + url + "]", e);
-            throw AxisFault.makeFault(e);
-        } finally {
-            cleanup(msgContext, putMethod);
-        }
-    }
-
-    /**
-     * Used to handle the HTTP Response
-     *
-     * @param msgContext - The MessageContext of the message
-     * @param method     - The HTTP method used
-     * @throws IOException - Thrown in case an exception occurs
-     */
-    private void handleResponse(MessageContext msgContext,
-                                HttpMethodBase method) throws IOException {
-
-        int statusCode = method.getStatusCode();
-        if (statusCode == HttpStatus.SC_OK) {
-            processResponse(method, msgContext);
-        } else if (statusCode == HttpStatus.SC_ACCEPTED) {
-        } else if (statusCode == HttpStatus.SC_INTERNAL_SERVER_ERROR ||
-                statusCode == HttpStatus.SC_BAD_REQUEST) {
-            Header contenttypeHeader =
-                    method.getResponseHeader(HTTPConstants.HEADER_CONTENT_TYPE);
-            String value = null;
-            if (contenttypeHeader != null) {
-                value = contenttypeHeader.getValue();
-            }
-             OperationContext opContext = msgContext.getOperationContext();
-            if(opContext!=null){
-                MessageContext inMessageContext =
-                        opContext.getMessageContext(WSDLConstants.MESSAGE_LABEL_IN_VALUE);
-                if(inMessageContext!=null){
-                    inMessageContext.setProcessingFault(true);
-                }
-            }
-            if (value != null) {
-
-                processResponse(method, msgContext);
-            }
-            Object isTransportNonBlocking = msgContext.getProperty(
-                    MessageContext.TRANSPORT_NON_BLOCKING);
-            if (isTransportNonBlocking != null &&
-                    ((Boolean) isTransportNonBlocking).booleanValue()) {
-                throw new AxisFault(Messages.getMessage("transportError",
-                        String.valueOf(statusCode),
-                        method.getStatusText()));
-            }
-        } else {
-            throw new AxisFault(Messages.getMessage("transportError",
-                                                    String.valueOf(statusCode),
-                                                    method.getStatusText()));
-        }
-    }
+		} else if (statusCode == HttpStatus.SC_INTERNAL_SERVER_ERROR
+				|| statusCode == HttpStatus.SC_BAD_REQUEST) {
+			Header contenttypeHeader = response.getEntity().getContentType();
+			String value = null;
+			if (contenttypeHeader != null) {
+				value = contenttypeHeader.getValue();
+			}
+			OperationContext opContext = msgContext.getOperationContext();
+			if (opContext != null) {
+				MessageContext inMessageContext = opContext
+						.getMessageContext(WSDLConstants.MESSAGE_LABEL_IN_VALUE);
+				if (inMessageContext != null) {
+					inMessageContext.setProcessingFault(true);
+				}
+			}
+			if (value != null) {
+				processResponse(response, msgContext);
+			}
+			Object isTransportNonBlocking = msgContext
+					.getProperty(MessageContext.TRANSPORT_NON_BLOCKING);
+			if (isTransportNonBlocking != null
+					&& ((Boolean) isTransportNonBlocking).booleanValue()) {
+				throw new AxisFault(Messages.getMessage("transportError",
+						String.valueOf(statusCode), response.getStatusLine()
+								.toString()));
+			}
+		} else {
+			throw new AxisFault(Messages.getMessage("transportError", String
+					.valueOf(statusCode), response.getStatusLine().toString()));
+		}
+	}
 }
Index: modules/kernel/src/org/apache/axis2/transport/http/MultipartFormDataFormatter.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/MultipartFormDataFormatter.java	(revision 765719)
+++ modules/kernel/src/org/apache/axis2/transport/http/MultipartFormDataFormatter.java	(working copy)
@@ -19,6 +19,15 @@
 
 package org.apache.axis2.transport.http;
 
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
 import org.apache.axiom.om.OMAbstractFactory;
 import org.apache.axiom.om.OMElement;
 import org.apache.axiom.om.OMFactory;
@@ -28,16 +37,10 @@
 import org.apache.axis2.transport.MessageFormatter;
 import org.apache.axis2.transport.http.util.ComplexPart;
 import org.apache.axis2.transport.http.util.URLTemplatingUtil;
-import org.apache.commons.httpclient.methods.multipart.Part;
-import org.apache.commons.httpclient.methods.multipart.StringPart;
+import org.apache.http.entity.mime.content.StringBody;
+import org.apache.james.mime4j.message.Body;
+import org.apache.james.mime4j.util.MessageUtils;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.Iterator;
-
 /**
  * Formates the request message as multipart/form-data. An example of this serialization is shown
  * below which was extracted from the Web Services Description Language (WSDL) Version 2.0 Part 2: Adjuncts
@@ -88,17 +91,20 @@
 
         OMElement omElement = messageContext.getEnvelope().getBody().getFirstElement();
 
-        Part[] parts = createMultipatFormDataRequest(omElement);
-        if (parts.length > 0) {
-            ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-            try {
-
-                // This is accessing a class of Commons-FlieUpload
-                Part.sendParts(bytesOut, parts, format.getMimeBoundary().getBytes());
-            } catch (IOException e) {
-                throw AxisFault.makeFault(e);
+        try {
+        	Body[] parts = createMultipatFormDataRequest(omElement);
+            if (parts.length > 0) {
+            	ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
+            	// TODO verify we are using the API properly.
+            	for (int i = 0; i < parts.length; i++) {
+            		parts[i].writeTo(bytesOut, MessageUtils.LENIENT);
+				}
+            	return bytesOut.toByteArray();
             }
-            return bytesOut.toByteArray();
+        	// This is accessing a class of Commons-FlieUpload
+        	//Part.sendParts(bytesOut, parts, format.getMimeBoundary().getBytes());
+        } catch (IOException e) {
+            throw AxisFault.makeFault(e);
         }
 
         return new byte[0];  //To change body of implemented methods use File | Settings | File Templates.
@@ -176,9 +182,10 @@
     /**
      * @param dataOut
      * @return
+     * @throws UnsupportedEncodingException 
      */
-    private Part[] createMultipatFormDataRequest(OMElement dataOut) {
-        ArrayList parts = new ArrayList();
+    private Body[] createMultipatFormDataRequest(OMElement dataOut) throws UnsupportedEncodingException {
+        List parts = new ArrayList();
         if (dataOut != null) {
             Iterator iter1 = dataOut.getChildElements();
             OMFactory omFactory = OMAbstractFactory.getOMFactory();
@@ -193,12 +200,14 @@
                             processComplexType(omElement, ele.getChildElements(), omFactory));
                     parts.add(new ComplexPart(ele.getQName().getLocalPart(), omElement.toString()));
                 } else {
-                    parts.add(new StringPart(ele.getQName().getLocalPart(), ele.getText()));
+                	// cannot put the name anymore
+                	// ele.getQName().getLocalPart()
+                    parts.add(new StringBody(ele.getText()));
                 }
             }
         }
-        Part[] partsArray = new Part[parts.size()];
-        return (Part[]) parts.toArray(partsArray);
+        Body[] partsArray = new Body[parts.size()];
+        return (Body[]) parts.toArray(partsArray);
     }
 
     /**
Index: modules/kernel/src/org/apache/axis2/transport/http/RESTRequestEntity.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/RESTRequestEntity.java	(revision 765719)
+++ modules/kernel/src/org/apache/axis2/transport/http/RESTRequestEntity.java	(working copy)
@@ -19,118 +19,144 @@
 
 package org.apache.axis2.transport.http;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import javax.xml.stream.FactoryConfigurationError;
+import javax.xml.stream.XMLStreamException;
+
 import org.apache.axiom.om.OMElement;
 import org.apache.axiom.om.OMOutputFormat;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.context.MessageContext;
-import org.apache.commons.httpclient.methods.RequestEntity;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.message.BasicHeader;
 
-import javax.xml.stream.FactoryConfigurationError;
-import javax.xml.stream.XMLStreamException;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
+public class RESTRequestEntity implements HttpEntity {
+	private byte[] bytes;
+	private String charSetEnc;
+	private boolean chunked;
+	private OMElement element;
+	private MessageContext msgCtxt;
+	private String soapActionString;
+	private OMOutputFormat format;
 
-public class RESTRequestEntity implements RequestEntity {
-    private byte[] bytes;
-    private String charSetEnc;
-    private boolean chunked;
-    private OMElement element;
-    private MessageContext msgCtxt;
-    private String soapActionString;
-    private OMOutputFormat format;
+	public RESTRequestEntity(OMElement element, boolean chunked,
+			MessageContext msgCtxt, String charSetEncoding,
+			String soapActionString, OMOutputFormat format) {
+		this.element = element;
+		this.chunked = chunked;
+		this.msgCtxt = msgCtxt;
+		this.charSetEnc = charSetEncoding;
+		this.soapActionString = soapActionString;
+		this.format = format;
+	}
 
-    public RESTRequestEntity(OMElement element, boolean chunked,
-                             MessageContext msgCtxt,
-                             String charSetEncoding,
-                             String soapActionString,
-                             OMOutputFormat format) {
-        this.element = element;
-        this.chunked = chunked;
-        this.msgCtxt = msgCtxt;
-        this.charSetEnc = charSetEncoding;
-        this.soapActionString = soapActionString;
-        this.format = format;
-    }
+	private void handleOMOutput(OutputStream out, boolean doingMTOM)
+			throws XMLStreamException {
+		format.setDoOptimize(doingMTOM);
+		element.serializeAndConsume(out, format);
+	}
 
-    private void handleOMOutput(OutputStream out, boolean doingMTOM)
-            throws XMLStreamException {
-        format.setDoOptimize(doingMTOM);
-        element.serializeAndConsume(out, format);
-    }
+	public byte[] writeBytes() throws AxisFault {
+		try {
+			ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
+			if (!format.isOptimized()) {
+				OMOutputFormat format2 = new OMOutputFormat();
+				format2.setCharSetEncoding(charSetEnc);
+				element.serializeAndConsume(bytesOut, format2);
+				return bytesOut.toByteArray();
+			} else {
+				format.setCharSetEncoding(charSetEnc);
+				format.setDoOptimize(true);
+				element.serializeAndConsume(bytesOut, format);
+				return bytesOut.toByteArray();
+			}
+		} catch (XMLStreamException e) {
+			throw AxisFault.makeFault(e);
+		} catch (FactoryConfigurationError e) {
+			throw AxisFault.makeFault(e);
+		}
+	}
 
-    public byte[] writeBytes() throws AxisFault {
-        try {
-            ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-            if (!format.isOptimized()) {
-                OMOutputFormat format2 = new OMOutputFormat();
-                format2.setCharSetEncoding(charSetEnc);
-                element.serializeAndConsume(bytesOut, format2);
-                return bytesOut.toByteArray();
-            } else {
-                format.setCharSetEncoding(charSetEnc);
-                format.setDoOptimize(true);
-                element.serializeAndConsume(bytesOut, format);
-                return bytesOut.toByteArray();
-            }
-        } catch (XMLStreamException e) {
-            throw AxisFault.makeFault(e);
-        } catch (FactoryConfigurationError e) {
-            throw AxisFault.makeFault(e);
-        }
-    }
+	public long getContentLength() {
+		try {
+			if (chunked) {
+				return -1;
+			} else {
+				if (bytes == null) {
+					bytes = writeBytes();
+				}
+				return bytes.length;
+			}
+		} catch (AxisFault e) {
+			return -1;
+		}
+	}
 
-    public void writeRequest(OutputStream out) throws IOException {
-        try {
-            if (chunked) {
-                this.handleOMOutput(out, format.isDoingSWA());
-            } else {
-                if (bytes == null) {
-                    bytes = writeBytes();
-                }
-                out.write(bytes);
-            }
-            out.flush();
-        } catch (XMLStreamException e) {
-            throw AxisFault.makeFault(e);
-        } catch (FactoryConfigurationError e) {
-            throw AxisFault.makeFault(e);
-        } catch (IOException e) {
-            throw AxisFault.makeFault(e);
-        }
-    }
+	public Header getContentType() {
+		String encoding = format.getCharSetEncoding();
+		String contentType = format.getContentType();
+		if (encoding != null) {
+			contentType += "; charset=" + encoding;
+		}
 
-    public long getContentLength() {
-        try {
-            if (chunked) {
-                return -1;
-            } else {
-                if (bytes == null) {
-                    bytes = writeBytes();
-                }
-                return bytes.length;
-            }
-        } catch (AxisFault e) {
-            return -1;
-        }
-    }
+		// action header is not mandated in SOAP 1.2. So putting it, if
+		// available
+		if (!msgCtxt.isSOAP11() && (soapActionString != null)
+				&& !"".equals(soapActionString.trim())
+				&& !"\"\"".equals(soapActionString.trim())) {
+			contentType = contentType + ";action=\"" + soapActionString + "\";";
+		}
+		return new BasicHeader(HTTPConstants.HEADER_CONTENT_TYPE, contentType);
+	}
 
-    public String getContentType() {
-        String encoding = format.getCharSetEncoding();
-        String contentType = format.getContentType();
-        if (encoding != null) {
-            contentType += "; charset=" + encoding;
-        }
+	public boolean isRepeatable() {
+		return true;
+	}
 
-        // action header is not mandated in SOAP 1.2. So putting it, if available
-        if (!msgCtxt.isSOAP11() && (soapActionString != null)
-                && !"".equals(soapActionString.trim()) && !"\"\"".equals(soapActionString.trim())) {
-            contentType = contentType + ";action=\"" + soapActionString + "\";";
-        }
-        return contentType;
-    }
+	public void consumeContent() throws IOException {
+		// TODO not sure what to do here.
+	}
 
-    public boolean isRepeatable() {
-        return true;
-    }
+	public InputStream getContent() throws IOException, IllegalStateException {
+		return new ByteArrayInputStream(writeBytes());
+	}
+
+	public Header getContentEncoding() {
+		return null;
+	}
+
+	public boolean isChunked() {
+		return chunked;
+	}
+
+	public boolean isStreaming() {
+		return false;
+	}
+
+	public void writeTo(OutputStream outstream) throws IOException {
+		try {
+			if (chunked) {
+				this.handleOMOutput(outstream, format.isDoingSWA());
+			} else {
+				if (bytes == null) {
+					bytes = writeBytes();
+				}
+				outstream.write(bytes);
+			}
+			outstream.flush();
+		} catch (XMLStreamException e) {
+			throw AxisFault.makeFault(e);
+		} catch (FactoryConfigurationError e) {
+			throw AxisFault.makeFault(e);
+		} catch (IOException e) {
+			throw AxisFault.makeFault(e);
+		}
+
+	}
 }
Index: modules/kernel/src/org/apache/axis2/transport/http/CommonsTransportHeaders.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/CommonsTransportHeaders.java	(revision 765719)
+++ modules/kernel/src/org/apache/axis2/transport/http/CommonsTransportHeaders.java	(working copy)
@@ -19,13 +19,13 @@
 
 package org.apache.axis2.transport.http;
 
-import org.apache.commons.httpclient.Header;
-
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 
+import org.apache.http.Header;
+
 public class CommonsTransportHeaders implements Map {
     private Header[] headers;
 
Index: modules/kernel/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java	(revision 765719)
+++ modules/kernel/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java	(working copy)
@@ -19,12 +19,24 @@
 
 package org.apache.axis2.transport.http;
 
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.zip.GZIPOutputStream;
+
+import javax.xml.stream.FactoryConfigurationError;
+
 import org.apache.axiom.om.OMOutputFormat;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.NamedValue;
 import org.apache.axis2.description.Parameter;
 import org.apache.axis2.description.TransportOutDescription;
 import org.apache.axis2.handlers.AbstractHandler;
@@ -34,21 +46,9 @@
 import org.apache.axis2.transport.TransportUtils;
 import org.apache.axis2.transport.http.server.AxisHttpResponseImpl;
 import org.apache.axis2.util.JavaUtils;
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HttpException;
-import org.apache.commons.httpclient.HttpMethod;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
-import javax.xml.stream.FactoryConfigurationError;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.zip.GZIPOutputStream;
 
 public class CommonsHTTPTransportSender extends AbstractHandler implements
         TransportSender {
@@ -74,12 +74,15 @@
     int connectionTimeout = HTTPConstants.DEFAULT_CONNECTION_TIMEOUT;
 
     public void cleanup(MessageContext msgContext) throws AxisFault {
-        HttpMethod httpMethod = (HttpMethod) msgContext
-                .getProperty(HTTPConstants.HTTP_METHOD);
+       
+    	/* No need to cleanup, the HttpConnectionManager is smart enough to 
+    	 * know what to do.
+    	 * 
+    	 * AbortableHttpRequest abortableRequest = (AbortableHttpRequest)msgContext.getProperty(HTTPConstants.HTTP_METHOD);
 
-        if (httpMethod != null) {
-            httpMethod.releaseConnection();
-        }
+        if (abortableRequest != null) {
+        	abortableRequest.abort();
+        }*/
     }
 
     public void init(ConfigurationContext confContext,
@@ -258,7 +261,7 @@
                 if (customHeaders instanceof List) {
                     Iterator iter = ((List) customHeaders).iterator();
                     while (iter.hasNext()) {
-                        Header header = (Header) iter.next();
+                    	NamedValue header = (NamedValue)iter.next();
                         if (header != null) {
                             servletBasedOutTransportInfo
                                     .addHeader(header.getName(), header.getValue());
@@ -281,7 +284,7 @@
                 if (customHeaders instanceof List) {
                     Iterator iter = ((List) customHeaders).iterator();
                     while (iter.hasNext()) {
-                        Header header = (Header) iter.next();
+                        NamedValue header = (NamedValue)iter.next();
                         if (header != null) {
                             ((AxisHttpResponseImpl) transportInfo)
                                     .addHeader(header.getName(), header.getValue());
@@ -365,9 +368,6 @@
         } catch (MalformedURLException e) {
             log.debug(e);
             throw AxisFault.makeFault(e);
-        } catch (HttpException e) {
-            log.debug(e);
-            throw AxisFault.makeFault(e);
         } catch (IOException e) {
             log.debug(e);
             throw AxisFault.makeFault(e);
Index: modules/kernel/src/org/apache/axis2/transport/http/util/ComplexPart.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/util/ComplexPart.java	(revision 765719)
+++ modules/kernel/src/org/apache/axis2/transport/http/util/ComplexPart.java	(working copy)
@@ -19,14 +19,15 @@
 
 package org.apache.axis2.transport.http.util;
 
-import org.apache.commons.httpclient.methods.multipart.PartBase;
-import org.apache.commons.httpclient.util.EncodingUtil;
-
 import java.io.IOException;
 import java.io.OutputStream;
 
-public class ComplexPart extends PartBase {
+import org.apache.http.entity.mime.content.AbstractContentBody;
+import org.apache.http.util.EncodingUtils;
+import org.apache.james.mime4j.MimeException;
 
+public class ComplexPart extends AbstractContentBody {
+
     /**
      * Default content encoding of string parameters.
      */
@@ -52,6 +53,12 @@
      */
     private String value;
 
+	private String charSet;
+
+	private String transferEncoding;
+
+	private String name;
+
     /**
      * Constructor.
      *
@@ -62,12 +69,10 @@
      */
     public ComplexPart(String name, String value, String charset) {
 
-        super(
-                name,
-                DEFAULT_CONTENT_TYPE,
-                charset == null ? DEFAULT_CHARSET : charset,
-                DEFAULT_TRANSFER_ENCODING
-        );
+        super(DEFAULT_CONTENT_TYPE);
+        this.name = name;
+        this.charSet = charset == null ? DEFAULT_CHARSET : charset; 
+        this.transferEncoding = DEFAULT_TRANSFER_ENCODING;
         if (value == null) {
             throw new IllegalArgumentException("Value may not be null");
         }
@@ -96,38 +101,38 @@
      */
     private byte[] getContent() {
         if (content == null) {
-            content = EncodingUtil.getBytes(value, getCharSet());
+            content = EncodingUtils.getBytes(value, getCharset());
         }
         return content;
     }
 
-    /**
-     * Writes the data to the given OutputStream.
-     *
-     * @param out the OutputStream to write to
-     * @throws IOException if there is a write error
-     */
-    protected void sendData(OutputStream out) throws IOException {
-        out.write(getContent());
-    }
-
-    /**
-     * Return the length of the data.
-     *
-     * @return The length of the data.
-     * @throws IOException If an IO problem occurs
-     * @see org.apache.commons.httpclient.methods.multipart.Part#lengthOfData()
-     */
-    protected long lengthOfData() throws IOException {
-        return getContent().length;
-    }
-
     /* (non-Javadoc)
      * @see org.apache.commons.httpclient.methods.multipart.BasePart#setCharSet(java.lang.String)
      */
     public void setCharSet(String charSet) {
-        super.setCharSet(charSet);
+        this.charSet = charSet;
         this.content = null;
     }
 
+	public String getFilename() {
+		return name;
+	}
+
+	public void writeTo(OutputStream out, int mode) throws IOException,
+			MimeException {
+		out.write(getContent());
+	}
+
+	public String getCharset() {
+		return charSet;
+	}
+
+	public long getContentLength() {
+		return getContent().length;
+	}
+
+	public String getTransferEncoding() {
+		return transferEncoding;
+	}
+
 }
Index: modules/kernel/src/org/apache/axis2/client/Stub.java
===================================================================
--- modules/kernel/src/org/apache/axis2/client/Stub.java	(revision 765719)
+++ modules/kernel/src/org/apache/axis2/client/Stub.java	(working copy)
@@ -20,6 +20,9 @@
 
 package org.apache.axis2.client;
 
+import java.util.ArrayList;
+import java.util.Iterator;
+
 import org.apache.axiom.om.OMAbstractFactory;
 import org.apache.axiom.om.OMAttribute;
 import org.apache.axiom.om.OMElement;
@@ -35,17 +38,14 @@
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.NamedValue;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.OutInAxisOperation;
 import org.apache.axis2.description.OutOnlyAxisOperation;
 import org.apache.axis2.description.RobustOutOnlyAxisOperation;
 import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.transport.http.HTTPConstants;
-import org.apache.commons.httpclient.Header;
 
-import java.util.ArrayList;
-import java.util.Iterator;
-
 /**
  * Base class for generated client stubs. This defines several client API
  * (<code>public</code>) methods shared between all types of stubs, along with
@@ -159,9 +159,7 @@
             headersObj = new java.util.ArrayList();
         }
         java.util.List headers = (java.util.List) headersObj;
-        Header header = new Header();
-        header.setName(name);
-        header.setValue(value);
+        NamedValue header = new NamedValue(name, value);
         headers.add(header);
         messageContext.setProperty(HTTPConstants.HTTP_HEADERS, headers);
     }
Index: modules/kernel/pom.xml
===================================================================
--- modules/kernel/pom.xml	(revision 765719)
+++ modules/kernel/pom.xml	(working copy)
@@ -37,11 +37,26 @@
             <groupId>javax.servlet</groupId>
             <artifactId>servlet-api</artifactId>
         </dependency>
-        <dependency>
+       <!-- <dependency>
             <groupId>commons-httpclient</groupId>
             <artifactId>commons-httpclient</artifactId>
-        </dependency>
+        </dependency>  --> 
         <dependency>
+	    	<groupId>org.apache.httpcomponents</groupId>
+	    	<artifactId>httpclient</artifactId>
+	    	<version>4.0-beta2</version>
+    	</dependency>
+    	<dependency>
+	      <groupId>org.apache.httpcomponents</groupId>
+	      <artifactId>httpmime</artifactId>
+	      <version>4.0-beta2</version>
+	    </dependency>  
+	    <dependency>
+	    	<groupId>jcifs</groupId>
+	    	<artifactId>jcifs</artifactId>
+	    	<version>1.3.8</version>
+	    </dependency>
+        <dependency>
             <groupId>commons-fileupload</groupId>
             <artifactId>commons-fileupload</artifactId>
         </dependency>
Index: modules/fastinfoset/test/org/apache/axis2/fastinfoset/SimpleAddServiceClient.java
===================================================================
--- modules/fastinfoset/test/org/apache/axis2/fastinfoset/SimpleAddServiceClient.java	(revision 765719)
+++ modules/fastinfoset/test/org/apache/axis2/fastinfoset/SimpleAddServiceClient.java	(working copy)
@@ -19,6 +19,8 @@
 
 package org.apache.axis2.fastinfoset;
 
+import java.rmi.RemoteException;
+
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.addressing.EndpointReference;
@@ -26,15 +28,8 @@
 import org.apache.axis2.client.ServiceClient;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.ConfigurationContextFactory;
-import org.apache.axis2.fastinfoset.SimpleAddServiceStub;
-import org.apache.axis2.fastinfoset.SimpleAddServiceStub.AddFloats;
-import org.apache.axis2.fastinfoset.SimpleAddServiceStub.AddFloatsResponse;
-import org.apache.axis2.fastinfoset.SimpleAddServiceStub.AddInts;
-import org.apache.axis2.fastinfoset.SimpleAddServiceStub.AddIntsResponse;
-import org.apache.axis2.fastinfoset.SimpleAddServiceStub.AddStrings;
-import org.apache.axis2.fastinfoset.SimpleAddServiceStub.AddStringsResponse;
 
-import java.rmi.RemoteException;
+import org.apache.axis2.fastinfoset.SimpleAddServiceStub.*;
 
 public class SimpleAddServiceClient {
 	
Index: modules/parent/pom.xml
===================================================================
--- modules/parent/pom.xml	(revision 765719)
+++ modules/parent/pom.xml	(working copy)
@@ -90,7 +90,7 @@
         <scripting.mar.version>1.4</scripting.mar.version>
 
         <!-- Version #'s of all our dependencies -->
-        <activemq.version>5.0.0</activemq.version>
+        <activemq.version>5.1.0</activemq.version>
         <activemq.version-jdk14>4.1.1</activemq.version-jdk14>
         <annogen.version>0.1.0</annogen.version>
         <ant.version>1.7.0</ant.version>
@@ -112,7 +112,7 @@
         <geronimo.spec.javamail.version>1.2</geronimo.spec.javamail.version>
         <geronimo.spec.stax.version>1.0.1</geronimo.spec.stax.version>
         <geronimo.spec.jms.version>1.1</geronimo.spec.jms.version>
-        <httpcore.version>4.0-beta1</httpcore.version>
+        <httpcore.version>4.0</httpcore.version>
         <intellij.version>5.0</intellij.version>
         <jalopy.version>1.5rc3</jalopy.version>
         <jaxb.api.version>2.1</jaxb.api.version>
@@ -955,6 +955,12 @@
             </dependency>
             <dependency>
                 <groupId>org.apache.activemq</groupId>
+                <artifactId>activemq-core</artifactId>
+                <version>${activemq.version}</version> 
+            </dependency>
+            <!-- 
+            <dependency>
+                <groupId>org.apache.activemq</groupId>
                 <artifactId>apache-activemq</artifactId>
                 <version>${activemq.version}</version>
                 <exclusions>
@@ -979,7 +985,7 @@
                         <artifactId>axis</artifactId>
                     </exclusion>
                 </exclusions>
-            </dependency>
+            </dependency> -->
             <dependency>
                 <groupId>jalopy</groupId>
                 <artifactId>jalopy</artifactId>
Index: modules/saaj/pom.xml
===================================================================
--- modules/saaj/pom.xml	(revision 765719)
+++ modules/saaj/pom.xml	(working copy)
@@ -69,6 +69,11 @@
             </exclusions>
         </dependency>
         <dependency>
+        	<groupId>commons-httpclient</groupId>
+        	<artifactId>commons-httpclient</artifactId>
+        	<scope>test</scope>
+        </dependency>
+        <dependency>
             <groupId>log4j</groupId>
             <artifactId>log4j</artifactId>
         </dependency>
@@ -158,4 +163,17 @@
             </plugin>
         </plugins>
     </build>
+    <repositories>
+	    <repository>
+	     <id>Apache snapshots repository</id>
+	     <name>Apache snapshots repository</name>
+	     <url>http://people.apache.org/repo/m2-snapshot-repository</url>
+	     <releases>
+			<enabled>false</enabled>
+	     </releases>
+	     <snapshots>
+			<enabled>true</enabled>
+	     </snapshots>
+	   </repository>
+    </repositories>
 </project>
Index: modules/integration/pom.xml
===================================================================
--- modules/integration/pom.xml	(revision 765719)
+++ modules/integration/pom.xml	(working copy)
@@ -258,6 +258,11 @@
             </exclusions>
         </dependency>
         <dependency>
+        	<groupId>commons-httpclient</groupId>
+        	<artifactId>commons-httpclient</artifactId>
+        	<scope>test</scope>
+        </dependency>
+        <dependency>
             <groupId>org.apache.ws.commons.schema</groupId>
             <artifactId>XmlSchema</artifactId>
         </dependency>
@@ -296,9 +301,9 @@
             <artifactId>xmlbeans</artifactId>
         </dependency>
         <dependency>
-            <groupId>org.apache.activemq</groupId>
-            <artifactId>apache-activemq</artifactId>
-        </dependency>
+             <groupId>org.apache.activemq</groupId>
+             <artifactId>activemq-core</artifactId>
+         </dependency>
         <dependency>
             <groupId>wsdl4j</groupId>
             <artifactId>wsdl4j</artifactId>
