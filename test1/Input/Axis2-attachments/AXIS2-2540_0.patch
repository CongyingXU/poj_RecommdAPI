
Property changes on: C:\eclipse\workspace_axis2\GM_apache_latest
___________________________________________________________________
Name: svn:ignore
   - *.ipr
*.iml
*.iws
target

   + *.ipr
*.iml
*.iws
target
.classpath
.project



Property changes on: C:\eclipse\workspace_axis2\GM_apache_latest\modules\fastinfoset
___________________________________________________________________
Name: svn:ignore
   + target


Index: C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/sample/addnumbershandler/AddNumbersLogicalHandler2.java
===================================================================
--- C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/sample/addnumbershandler/AddNumbersLogicalHandler2.java	(revision 528437)
+++ C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/sample/addnumbershandler/AddNumbersLogicalHandler2.java	(working copy)
@@ -1,54 +1,57 @@
 package org.apache.axis2.jaxws.sample.addnumbershandler;
 
-import javax.xml.soap.SOAPMessage;
-import javax.xml.soap.SOAPPart;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+
+import javax.xml.transform.OutputKeys;
+import javax.xml.transform.Source;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.stream.StreamResult;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.ws.LogicalMessage;
 import javax.xml.ws.handler.MessageContext;
 
-import org.apache.axis2.jaxws.handler.SoapMessageContext;
-import org.w3c.dom.Node;
+import org.apache.axis2.jaxws.handler.LogicalMessageContext;
 
-public class AddNumbersLogicalHandler2 implements javax.xml.ws.handler.LogicalHandler {
+public class AddNumbersLogicalHandler2 implements javax.xml.ws.handler.LogicalHandler<LogicalMessageContext> {
 
     public void close(MessageContext messagecontext) {
-        // TODO Auto-generated method stub
         
     }
 
-    public boolean handleFault(MessageContext messagecontext) {
+    public boolean handleFault(LogicalMessageContext messagecontext) {
         Boolean outbound = (Boolean)messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
         if (outbound) {  // outbound response if we're on the server
-            SOAPMessage msg = ((SoapMessageContext)messagecontext).getMessage();
-            SOAPPart part = msg.getSOAPPart();
-            Node node1 = part.getFirstChild();
-            if (node1 != null) {
-                Node node2 = node1.getFirstChild();
-                if (node2 != null) {
-                    Node node3 = node2.getFirstChild();
-                    if (node3 != null) {
-                        Node node4 = node3.getFirstChild();
-                        if (node4 != null) {
-                            Node node5 = node4.getNextSibling();
-                            if (node5 != null)
-                                node5.setTextContent("AddNumbersLogicalHandler2 was here");
-                        }
-                    }
-                }
-            }
-            //part.getFirstChild().getFirstChild().getFirstChild().getFirstChild().getNextSibling().setTextContent("AddNumbersLogicalHandler2 was here");
+            LogicalMessage msg = messagecontext.getMessage();
+            String st = getStringFromSourcePayload(msg.getPayload());
+            st = st.replaceFirst("blarg", "AddNumbersLogicalHandler2 was here");
+            st = st.replaceFirst("I don't like the value 99", "AddNumbersLogicalHandler2 was here");
+            msg.setPayload(new StreamSource(new ByteArrayInputStream(st.getBytes())));
         }
         return true;
     }
 
-    /*
-     * this test handleMessage method is obviously not what a customer might write, but it does
-     * the trick for kicking the tires in the handler framework.  The AddNumbers service takes two
-     * ints as incoming params, adds them, and returns the sum.  This method subtracts 1 from the 
-     * first int on the inbound request, and subtracts 1 from the int on the outbound response.
-     * So the client app should expect a sum 2 less than a sum without this handler manipulating
-     * the SOAP message.
-     */
-    public boolean handleMessage(MessageContext messagecontext) {
+    public boolean handleMessage(LogicalMessageContext messagecontext) {
     	return true;
     }
+    
+    private static String getStringFromSourcePayload(Source payload) {
+        try {
 
+            TransformerFactory factory = TransformerFactory.newInstance();
+            Transformer trans = factory.newTransformer();
+
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            StreamResult result = new StreamResult(baos);
+
+            trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
+            trans.transform(payload, result);
+
+            return new String(baos.toByteArray());
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
 }
Index: C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/sample/addnumbershandler/AddNumbersClientLogicalHandler.java
===================================================================
--- C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/sample/addnumbershandler/AddNumbersClientLogicalHandler.java	(revision 528437)
+++ C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/sample/addnumbershandler/AddNumbersClientLogicalHandler.java	(working copy)
@@ -1,11 +1,20 @@
 package org.apache.axis2.jaxws.sample.addnumbershandler;
 
-import javax.xml.soap.SOAPMessage;
-import javax.xml.soap.SOAPPart;
+import java.io.ByteArrayOutputStream;
+import java.io.StringBufferInputStream;
+import java.util.StringTokenizer;
+
+import javax.xml.transform.OutputKeys;
+import javax.xml.transform.Source;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.stream.StreamResult;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.ws.LogicalMessage;
 import javax.xml.ws.ProtocolException;
 import javax.xml.ws.handler.MessageContext;
 
-import org.apache.axis2.jaxws.handler.SoapMessageContext;
+import org.apache.axis2.jaxws.handler.LogicalMessageContext;
 
 /*
  * You can't actually specify whether a handler is for client or server,
@@ -13,37 +22,69 @@
  * sure what direction we're going.
  */
 
-public class AddNumbersClientLogicalHandler implements javax.xml.ws.handler.LogicalHandler {
+public class AddNumbersClientLogicalHandler implements javax.xml.ws.handler.LogicalHandler<LogicalMessageContext> {
 
     public void close(MessageContext messagecontext) {
-        // TODO Auto-generated method stub
-        
     }
 
-    public boolean handleFault(MessageContext messagecontext) {
+    public boolean handleFault(LogicalMessageContext messagecontext) {
         return true;
     }
 
-    public boolean handleMessage(MessageContext messagecontext) {
+    public boolean handleMessage(LogicalMessageContext messagecontext) {
         Boolean outbound = (Boolean)messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
         if (!outbound) {  // inbound response on the client
-            SOAPMessage msg = ((SoapMessageContext)messagecontext).getMessage();
-            SOAPPart part = msg.getSOAPPart();
-            // hack-ish change, but it's for testing, so who cares.
-            String txt = part.getFirstChild().getFirstChild().getFirstChild().getFirstChild().getTextContent();
-            txt = String.valueOf(Integer.valueOf(txt) - 1);
-            part.getFirstChild().getFirstChild().getFirstChild().getFirstChild().setTextContent(txt);
+            LogicalMessage msg = messagecontext.getMessage();
+            String st = getStringFromSourcePayload(msg.getPayload());
+            String txt = String.valueOf(Integer.valueOf(getFirstArg(st)) - 1);
+            st = replaceFirstArg(st, txt);
+            msg.setPayload(new StreamSource(new StringBufferInputStream(st)));
         }
         else {
-            SOAPMessage msg = ((SoapMessageContext)messagecontext).getMessage();
-            SOAPPart part = msg.getSOAPPart();
-            // hack-ish change, but it's for testing, so who cares.
-            String txt = part.getFirstChild().getFirstChild().getFirstChild().getFirstChild().getTextContent();
-            if (txt.equals("99")) {
+            LogicalMessage msg = messagecontext.getMessage();
+            
+            Source s = msg.getPayload();
+            s = msg.getPayload();
+            
+            String st = getStringFromSourcePayload(msg.getPayload());
+            if (st.contains("<arg0>99</arg0>"))
                 throw new ProtocolException("I don't like the value 99");
-            }
         }
         return true;
     }
+    
+    private static String getFirstArg(String payloadString) {
+        StringTokenizer st = new StringTokenizer(payloadString, ">");
+        st.nextToken();  // skip first token.
+        st.nextToken();  // skip second
+        String tempString = st.nextToken();
+        String returnString = new StringTokenizer(tempString, "<").nextToken();
+        return returnString;
+    }
+    
+    private static String replaceFirstArg(String payloadString, String newArg) {
+        String firstArg = getFirstArg(payloadString);
+        payloadString = payloadString.replaceFirst(firstArg, newArg);
+        return payloadString;
+    }
+    
+    private static String getStringFromSourcePayload(Source payload) {
+        try {
 
+            TransformerFactory factory = TransformerFactory.newInstance();
+            Transformer trans = factory.newTransformer();
+
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            StreamResult result = new StreamResult(baos);
+
+            trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
+            trans.transform(payload, result);
+
+            return new String(baos.toByteArray());
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+
+    }
+
 }
Index: C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/sample/addnumbershandler/AddNumbersLogicalHandler.java
===================================================================
--- C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/sample/addnumbershandler/AddNumbersLogicalHandler.java	(revision 528437)
+++ C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/sample/addnumbershandler/AddNumbersLogicalHandler.java	(working copy)
@@ -1,19 +1,28 @@
 package org.apache.axis2.jaxws.sample.addnumbershandler;
 
+import java.io.ByteArrayOutputStream;
+import java.io.StringBufferInputStream;
+import java.util.StringTokenizer;
+import java.util.regex.Pattern;
+
 import javax.annotation.PostConstruct;
-import javax.xml.soap.SOAPMessage;
-import javax.xml.soap.SOAPPart;
+import javax.xml.transform.OutputKeys;
+import javax.xml.transform.Source;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.stream.StreamResult;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.ws.LogicalMessage;
 import javax.xml.ws.ProtocolException;
 import javax.xml.ws.handler.MessageContext;
 
-import org.apache.axis2.jaxws.handler.SoapMessageContext;
+import org.apache.axis2.jaxws.handler.LogicalMessageContext;
 
-public class AddNumbersLogicalHandler implements javax.xml.ws.handler.LogicalHandler {
+public class AddNumbersLogicalHandler implements javax.xml.ws.handler.LogicalHandler<LogicalMessageContext> {
 
     private int deduction = 1;
     
     public void close(MessageContext messagecontext) {
-        // TODO Auto-generated method stub
         
     }
     
@@ -22,15 +31,7 @@
         deduction = 2;
     }
 
-    public boolean handleFault(MessageContext messagecontext) {
-        /*
-        Boolean outbound = (Boolean)messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
-        if (outbound) {  // outbound response if we're on the server
-            SOAPMessage msg = ((SoapMessageContext)messagecontext).getMessage();
-            SOAPPart part = msg.getSOAPPart();
-            part.getFirstChild().getFirstChild().getFirstChild().setTextContent("a handler was here");
-        }
-        */
+    public boolean handleFault(LogicalMessageContext messagecontext) {
         return true;
     }
 
@@ -42,28 +43,57 @@
      * So the client app should expect a sum 2 less than a sum without this handler manipulating
      * the SOAP message.
      */
-    public boolean handleMessage(MessageContext messagecontext) {
+    public boolean handleMessage(LogicalMessageContext messagecontext) {
         Boolean outbound = (Boolean)messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
         if (!outbound) {  // inbound request if we're on the server
-            SOAPMessage msg = ((SoapMessageContext)messagecontext).getMessage();
-            SOAPPart part = msg.getSOAPPart();
-            // hack-ish change, but it's for testing, so who cares.
-            String txt = part.getFirstChild().getFirstChild().getFirstChild().getFirstChild().getTextContent();
-            if (txt.equals("99")) {
+            LogicalMessage msg = messagecontext.getMessage();
+            String st = getStringFromSourcePayload(msg.getPayload());
+            if (st.contains("<arg0>99</arg0>"))
                 throw new ProtocolException("I don't like the value 99");
-            }
-            txt = String.valueOf(Integer.valueOf(txt) - 1);
-            part.getFirstChild().getFirstChild().getFirstChild().getFirstChild().setTextContent(txt);
-            return true;
+            String txt = String.valueOf(Integer.valueOf(getFirstArg(st)) - 1);
+            st = replaceFirstArg(st, txt);
+            msg.setPayload(new StreamSource(new StringBufferInputStream(st)));
+            
         } else { // outbound response if we're on the server
-            SOAPMessage msg = ((SoapMessageContext)messagecontext).getMessage();
-            SOAPPart part = msg.getSOAPPart();
-            // hack-ish change, but it's for testing, so who cares.
-            String txt = part.getFirstChild().getFirstChild().getFirstChild().getTextContent();
-            txt = String.valueOf(Integer.valueOf(txt) - deduction);
-            part.getFirstChild().getFirstChild().getFirstChild().getFirstChild().setTextContent(txt);
-            return true;
+            LogicalMessage msg = messagecontext.getMessage();
+            String st = getStringFromSourcePayload(msg.getPayload());
+            String txt = String.valueOf(Integer.valueOf(getFirstArg(st)) - deduction);
+            st = replaceFirstArg(st, txt);
+            msg.setPayload(new StreamSource(new StringBufferInputStream(st)));
         }
+        return true;
     }
+    
+    private static String getFirstArg(String payloadString) {
+        StringTokenizer st = new StringTokenizer(payloadString, ">");
+        st.nextToken();  // skip first token.
+        st.nextToken();  // skip second
+        String tempString = st.nextToken();
+        String returnString = new StringTokenizer(tempString, "<").nextToken();
+        return returnString;
+    }
+    
+    private static String replaceFirstArg(String payloadString, String newArg) {
+        String firstArg = getFirstArg(payloadString);
+        payloadString = payloadString.replaceFirst(firstArg, newArg);
+        return payloadString;
+    }
+    
+    private static String getStringFromSourcePayload(Source payload) {
+        try {
 
+            TransformerFactory factory = TransformerFactory.newInstance();
+            Transformer trans = factory.newTransformer();
+
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            StreamResult result = new StreamResult(baos);
+
+            trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
+            trans.transform(payload, result);
+
+            return new String(baos.toByteArray());
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
 }
Index: C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/sample/addnumbershandler/AddNumbersClientLogicalHandler2.java
===================================================================
--- C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/sample/addnumbershandler/AddNumbersClientLogicalHandler2.java	(revision 528437)
+++ C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/sample/addnumbershandler/AddNumbersClientLogicalHandler2.java	(working copy)
@@ -1,10 +1,19 @@
 package org.apache.axis2.jaxws.sample.addnumbershandler;
 
-import javax.xml.soap.SOAPMessage;
-import javax.xml.soap.SOAPPart;
+import java.io.ByteArrayOutputStream;
+import java.io.StringBufferInputStream;
+import java.util.StringTokenizer;
+
+import javax.xml.transform.OutputKeys;
+import javax.xml.transform.Source;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.stream.StreamResult;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.ws.LogicalMessage;
 import javax.xml.ws.handler.MessageContext;
 
-import org.apache.axis2.jaxws.handler.SoapMessageContext;
+import org.apache.axis2.jaxws.handler.LogicalMessageContext;
 
 /*
  * You can't actually specify whether a handler is for client or server,
@@ -12,27 +21,58 @@
  * sure what direction we're going.
  */
 
-public class AddNumbersClientLogicalHandler2 implements javax.xml.ws.handler.LogicalHandler {
-    
+public class AddNumbersClientLogicalHandler2 implements javax.xml.ws.handler.LogicalHandler<LogicalMessageContext> {
+
     public void close(MessageContext messagecontext) {
-        // TODO Auto-generated method stub
     }
 
-    public boolean handleFault(MessageContext messagecontext) {
+    public boolean handleFault(LogicalMessageContext messagecontext) {
         return true;
     }
 
-    public boolean handleMessage(MessageContext messagecontext) {
+    public boolean handleMessage(LogicalMessageContext messagecontext) {
         Boolean outbound = (Boolean)messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
         if (outbound) {  // outbound request on the client
-            SOAPMessage msg = ((SoapMessageContext)messagecontext).getMessage();
-            SOAPPart part = msg.getSOAPPart();
-            // hack-ish change, but it's for testing, so who cares.
-            String txt = part.getFirstChild().getFirstChild().getFirstChild().getFirstChild().getTextContent();
-            txt = String.valueOf(Integer.valueOf(txt) * 2);
-            part.getFirstChild().getFirstChild().getFirstChild().getFirstChild().setTextContent(txt);
+            LogicalMessage msg = messagecontext.getMessage();
+            Source payload = msg.getPayload();
+            String st = getStringFromSourcePayload(payload);
+            String txt = String.valueOf(Integer.valueOf(getFirstArg(st)) * 2);
+            st = replaceFirstArg(st, txt);
+            msg.setPayload(new StreamSource(new StringBufferInputStream(st)));
         }
         return true;
     }
+    
+    private static String getFirstArg(String payloadString) {
+        StringTokenizer st = new StringTokenizer(payloadString, ">");
+        st.nextToken();  // skip first token.
+        st.nextToken();  // skip second
+        String tempString = st.nextToken();
+        String returnString = new StringTokenizer(tempString, "<").nextToken();
+        return returnString;
+    }
+    
+    private static String replaceFirstArg(String payloadString, String newArg) {
+        String firstArg = getFirstArg(payloadString);
+        payloadString = payloadString.replaceFirst(firstArg, newArg);
+        return payloadString;
+    }
+    
+    private static String getStringFromSourcePayload(Source payload) {
+        try {
 
+            TransformerFactory factory = TransformerFactory.newInstance();
+            Transformer trans = factory.newTransformer();
+
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            StreamResult result = new StreamResult(baos);
+
+            trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
+            trans.transform(payload, result);
+
+            return new String(baos.toByteArray());
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
 }
Index: C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/handler/HandlerChainProcessorTests.java
===================================================================
--- C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/handler/HandlerChainProcessorTests.java	(revision 528437)
+++ C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/test/org/apache/axis2/jaxws/handler/HandlerChainProcessorTests.java	(working copy)
@@ -23,6 +23,7 @@
 import javax.xml.ws.handler.Handler;
 import javax.xml.ws.handler.LogicalHandler;
 import javax.xml.ws.handler.soap.SOAPHandler;
+import javax.xml.ws.handler.soap.SOAPMessageContext;
 
 import junit.framework.TestCase;
 
@@ -84,8 +85,8 @@
 		HandlerChainProcessor processor1 = new HandlerChainProcessor(null, Protocol.soap11);
 		HandlerChainProcessor processor2 = new HandlerChainProcessor(new ArrayList<Handler>(), Protocol.soap11);
 		try {
-			processor1.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
-			processor2.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+			processor1.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+			processor2.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
 		} catch (Exception e) {
 			local_exception = e;
 		}
@@ -113,7 +114,7 @@
 	
 		HandlerChainProcessor processor = new HandlerChainProcessor(local_list, Protocol.soap11);
 		
-		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
 
 		assertEquals("S1m:S1c:", result);
 		
@@ -138,7 +139,7 @@
 	
 		HandlerChainProcessor processor = new HandlerChainProcessor(local_list, Protocol.soap11);
 		
-		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
 
 		assertEquals("S1m:S1c:", result);
 	}
@@ -162,7 +163,7 @@
 	
 		HandlerChainProcessor processor = new HandlerChainProcessor(local_list, Protocol.soap11);
 		
-		processor.processChain(new LogicalMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
 
 		assertEquals("L1m:L1c:", result);
 	}
@@ -188,7 +189,7 @@
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
 		
-		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
 
 		assertEquals("S2m:S1m:L1m:L2m:", result);
 		
@@ -215,7 +216,7 @@
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
 		
-		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
 
 		assertEquals("S2m:S1m:L1m:L2m:L2c:L1c:S1c:S2c:", result);
 		
@@ -242,7 +243,7 @@
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
 		
-		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.RESPONSE, true);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.RESPONSE, true);
 
 		assertEquals("S2m:S1m:L1m:L2m:L2c:L1c:S1c:S2c:", result);
 
@@ -269,7 +270,7 @@
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
 		
-		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.REQUEST, true);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.REQUEST, true);
 
 		assertEquals("L2m:L1m:S1m:S2m:", result);
 	}
@@ -295,7 +296,7 @@
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
 		
-		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.REQUEST, false);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.REQUEST, false);
 
 		assertEquals("L2m:L1m:S1m:S2m:S2c:S1c:L1c:L2c:", result);
 	}
@@ -321,7 +322,7 @@
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
 		
-		processor.processChain(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.RESPONSE, true);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.RESPONSE, true);
 
 		assertEquals("L2m:L1m:S1m:S2m:S2c:S1c:L1c:L2c:", result);
 	}
@@ -334,8 +335,7 @@
 	 * outgoing response (we must be on the server), response expected (ignored)
 	 * processing expected:  Logical only, normal order, close
 	 */
-    // TODO re-enable when handlers are fixed
-	public void _testHandleMessage_true7() {
+	public void testHandleMessage_true7() {
 		
 		// reset result
 		result = "";
@@ -352,8 +352,8 @@
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
 		
-		processor.processChain(new LogicalMessageContext(new MessageContext()), HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.RESPONSE, true);
-		assertEquals("L2m:L1m:L1c:L2c:", result);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.RESPONSE, true);
+		assertEquals("L2m:L1m:S1m:S2m:S2c:S1c:L1c:L2c:", result);
 	}
 	
 	/*
@@ -361,7 +361,7 @@
 	 * a middle Handler.handleMessage returns false
 	 * processing expected:  Logical and SOAP, reverse order, message reversed, close
 	 */
-	public void _testHandleMessage_false1() {
+	public void testHandleMessage_false1() {
 		
 		// reset result
 		result = "";
@@ -377,11 +377,9 @@
 		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
-		SoapMessageContext context = new SoapMessageContext(new MessageContext());
-		processor.processChain(context, HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
 
 		assertEquals("S2m:S1m:L1m:S1m:S2m:L1c:S1c:S2c:", result);
-		assertTrue((Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
 	}
 	
 	/*
@@ -389,7 +387,7 @@
 	 * a middle Handler.handleMessage returns false
 	 * processing expected:  Logical and SOAP, normal order, message reversed, close
 	 */
-	public void _testHandleMessage_false2() {
+	public void testHandleMessage_false2() {
 		
 		// reset result
 		result = "";
@@ -405,11 +403,9 @@
 		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
-		SoapMessageContext context = new SoapMessageContext(new MessageContext());
-		processor.processChain(context, HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.REQUEST, true);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.REQUEST, true);
 
 		assertEquals("L2m:L1m:L2m:L1c:L2c:", result);
-		assertTrue(!(Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
 	}
 	
 	/*
@@ -417,7 +413,7 @@
 	 * a middle Handler.handleMessage returns false
 	 * processing expected:  Logical and SOAP, normal order, message NOT reversed, close
 	 */
-	public void _testHandleMessage_false3() {
+	public void testHandleMessage_false3() {
 		
 		// reset result
 		result = "";
@@ -433,11 +429,9 @@
 		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
-		SoapMessageContext context = new SoapMessageContext(new MessageContext());
-		processor.processChain(context, HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.REQUEST, false);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.OUT, HandlerChainProcessor.MEP.REQUEST, false);
 
 		assertEquals("L2m:L1m:L1c:L2c:", result);
-		assertTrue((Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
 	}
 	
 	/*
@@ -445,7 +439,7 @@
 	 * a middle Handler.handleMessage throws ProtocolException
 	 * processing expected:  Logical and SOAP, reverse order, message reversed, handleFault, close
 	 */
-	public void _testHandleMessage_protocolex_true1() {
+	public void testHandleMessage_protocolex_true1() {
 		
 		// reset result
 		result = "";
@@ -461,12 +455,10 @@
 		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
-		SoapMessageContext context = new SoapMessageContext(new MessageContext());
-		processor.processChain(context, HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
 
 		// handleFault processing
 		assertEquals("S2m:S1m:L1m:S1f:S2f:L1c:S1c:S2c:", result);
-		assertTrue((Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
 	}
 	
 	/*
@@ -474,7 +466,7 @@
 	 * a middle Handler.handleMessage throws ProtocolException
 	 * processing expected:  Logical and SOAP, reverse order, message NOT reversed, close
 	 */
-	public void _testHandleMessage_protocolex_true2() {
+	public void testHandleMessage_protocolex_true2() {
 		
 		// reset result
 		result = "";
@@ -490,12 +482,10 @@
 		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
-		SoapMessageContext context = new SoapMessageContext(new MessageContext());
-		processor.processChain(context, HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, false);
 
 		// no handleFault calls
 		assertEquals("S2m:S1m:L1m:L1c:S1c:S2c:", result);
-		assertTrue(!(Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
 	}
 	
 	/*
@@ -503,7 +493,7 @@
 	 * a middle Handler.handleMessage throws RuntimeException
 	 * processing expected:  Logical and SOAP, reverse order, message reversed, (no handleFault), close
 	 */
-	public void _testHandleMessage_runtimeex_true() {
+	public void testHandleMessage_runtimeex_true() {
 		
 		// reset result
 		result = "";
@@ -519,10 +509,9 @@
 		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
-		SoapMessageContext context = new SoapMessageContext(new MessageContext());
 		Exception e = null;
 		try {
-			processor.processChain(context, HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+			processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
 		} catch (RuntimeException re) {
 			e = re;
 		}
@@ -530,7 +519,6 @@
 		assertNotNull(e);
 		// no handleFault calls
 		assertEquals("S2m:S1m:L1m:L1c:S1c:S2c:", result);
-		assertTrue((Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
 	}
 	
 	/*
@@ -538,7 +526,7 @@
 	 * a middle Handler.handleMessage throws ProtocolException, later a Handler.handleFault returns false
 	 * processing expected:  Logical and SOAP, reverse order, message reversed, handleFault, close
 	 */
-	public void _testHandleMessage_protocolex_false() {
+	public void testHandleMessage_protocolex_false() {
 		
 		// reset result
 		result = "";
@@ -554,12 +542,10 @@
 		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
-		SoapMessageContext context = new SoapMessageContext(new MessageContext());
-		processor.processChain(context, HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+		processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
 
 		// handleFault processing, but notice S2f does not get called
 		assertEquals("S2m:S1m:L1m:S1f:L1c:S1c:S2c:", result);
-		assertTrue((Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
 	}
 	
 	/*
@@ -567,7 +553,7 @@
 	 * a middle Handler.handleMessage throws ProtocolException, later a Handler.handleFault throws ProtocolException
 	 * processing expected:  Logical and SOAP, reverse order, message reversed, handleFault, close
 	 */
-	public void _testHandleMessage_protocolex_protocolex() {
+	public void testHandleMessage_protocolex_protocolex() {
 		
 		// reset result
 		result = "";
@@ -583,18 +569,16 @@
 		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
-		SoapMessageContext context = new SoapMessageContext(new MessageContext());
 		Exception e = null;
 		try {
 			// handleFault processing, but notice S2f does not get called, and we get an exception
-			processor.processChain(context, HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+			processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
 		} catch (ProtocolException pe) {
 			e = pe;
 		}
 
 		assertNotNull(e);
 		assertEquals("S2m:S1m:L1m:S1f:L1c:S1c:S2c:", result);
-		assertTrue((Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
 	}
 	
 	/*
@@ -602,7 +586,7 @@
 	 * a middle Handler.handleMessage throws ProtocolException, later a Handler.handleFault throws ProtocolException
 	 * processing expected:  Logical and SOAP, reverse order, handleFault, close
 	 */
-	public void _testHandleMessage_protocolex_runtimeex() {
+	public void testHandleMessage_protocolex_runtimeex() {
 		
 		// reset result
 		result = "";
@@ -618,18 +602,16 @@
 		logicalhandler2_FaultResultDesired = ResultDesired.TRUE;
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
-		SoapMessageContext context = new SoapMessageContext(new MessageContext());
 		Exception e = null;
 		try {
 			// same results as testHandlers_protocolex_protocolex
-			processor.processChain(context, HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
+			processor.processChain(new MessageContext(), HandlerChainProcessor.Direction.IN, HandlerChainProcessor.MEP.REQUEST, true);
 		} catch (RuntimeException pe) {
 			e = pe;
 		}
 
 		assertNotNull(e);
 		assertEquals("S2m:S1m:L1m:S1f:L1c:S1c:S2c:", result);
-		assertTrue((Boolean)(context.get(SoapMessageContext.MESSAGE_OUTBOUND_PROPERTY)));
 	}
 
 	
@@ -643,8 +625,8 @@
 		HandlerChainProcessor processor1 = new HandlerChainProcessor(null, Protocol.soap11);
 		HandlerChainProcessor processor2 = new HandlerChainProcessor(new ArrayList<Handler>(), Protocol.soap11);
 		try {
-			processor1.processFault(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN);
-			processor2.processFault(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN);
+			processor1.processFault(new MessageContext(), HandlerChainProcessor.Direction.IN);
+			processor2.processFault(new MessageContext(), HandlerChainProcessor.Direction.IN);
 		} catch (Exception e) {
 			local_exception = e;
 		}
@@ -658,7 +640,7 @@
 	 * outgoing response (we must be on the server), response expected (ignored)
 	 * processing expected:  Logical and SOAP, normal order, handleFault, close
 	 */
-	public void _testHandleFault_true1() {
+	public void testHandleFault_true1() {
 		
 		// reset result
 		result = "";
@@ -675,7 +657,7 @@
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
 		
-		processor.processFault(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.OUT);
+		processor.processFault(new MessageContext(), HandlerChainProcessor.Direction.OUT);
 
 		assertEquals("L2f:L1f:S1f:S2f:S2c:S1c:L1c:L2c:", result);
 	}
@@ -685,7 +667,7 @@
 	 * a middle Handler.handleFault returns false
 	 * processing expected:  Logical and SOAP, normal order, handleFault, close (all)
 	 */
-	public void _testHandleFault_false1() {
+	public void testHandleFault_false1() {
 		
 		// reset result
 		result = "";
@@ -702,7 +684,7 @@
 		
 		HandlerChainProcessor processor = new HandlerChainProcessor(handlers, Protocol.soap11);
 		
-		processor.processFault(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.OUT);
+		processor.processFault(new MessageContext(), HandlerChainProcessor.Direction.OUT);
 
 		// notice all handlers are closed in this scenario
 		assertEquals("L2f:L1f:S2c:S1c:L1c:L2c:", result);
@@ -713,7 +695,7 @@
 	 * a middle Handler.handleFault throws ProtocolException
 	 * processing expected:  Logical and SOAP, reverse order, handleFault, close (all)
 	 */
-	public void _testHandleFault_protocolex() {
+	public void testHandleFault_protocolex() {
 		
 		// reset result
 		result = "";
@@ -733,7 +715,7 @@
 		Exception e = null;
 		try {
 			// notice all handlers are closed in this scenario, and we get an exception
-			processor.processFault(new SoapMessageContext(new MessageContext()), HandlerChainProcessor.Direction.IN);
+			processor.processFault(new MessageContext(), HandlerChainProcessor.Direction.IN);
 		} catch (ProtocolException pe) {
 			e = pe;
 		}
@@ -744,7 +726,7 @@
 	
 	
 	
-	private class SOAPHandler1 implements SOAPHandler {
+	private class SOAPHandler1 implements SOAPHandler<SOAPMessageContext> {
 		
 		public Set getHeaders() {
 			return null;
@@ -754,7 +736,7 @@
 			result = result.concat("S1c:");
 		}
 
-		public boolean handleFault(javax.xml.ws.handler.MessageContext messagecontext) {
+		public boolean handleFault(SOAPMessageContext messagecontext) {
 			result = result.concat("S1f:");
 			if (soaphandler1_FaultResultDesired == ResultDesired.TRUE)
 				return true;
@@ -769,7 +751,7 @@
 			return true;
 		}
 
-		public boolean handleMessage(javax.xml.ws.handler.MessageContext messagecontext) {
+		public boolean handleMessage(SOAPMessageContext messagecontext) {
 			result = result.concat("S1m:");
 			if (soaphandler1_MessageResultDesired == ResultDesired.TRUE)
 				return true;
@@ -787,7 +769,7 @@
 	}
 	
 
-	private class SOAPHandler2 implements SOAPHandler {
+	private class SOAPHandler2 implements SOAPHandler<SOAPMessageContext> {
 
 		public Set getHeaders() {
 			return null;
@@ -797,7 +779,7 @@
 			result = result.concat("S2c:");
 		}
 
-		public boolean handleFault(javax.xml.ws.handler.MessageContext messagecontext) {
+		public boolean handleFault(SOAPMessageContext messagecontext) {
 			result = result.concat("S2f:");
 			if (soaphandler2_FaultResultDesired == ResultDesired.TRUE)
 				return true;
@@ -812,7 +794,7 @@
 			return true;
 		}
 
-		public boolean handleMessage(javax.xml.ws.handler.MessageContext messagecontext) {
+		public boolean handleMessage(SOAPMessageContext messagecontext) {
 			result = result.concat("S2m:");
 			if (soaphandler2_MessageResultDesired == ResultDesired.TRUE)
 				return true;
@@ -830,13 +812,13 @@
 	}
 	
 
-	private class LogicalHandler1 implements LogicalHandler {
+	private class LogicalHandler1 implements LogicalHandler<LogicalMessageContext> {
 
 		public void close(javax.xml.ws.handler.MessageContext messagecontext) {
 			result = result.concat("L1c:");
 		}
 
-		public boolean handleFault(javax.xml.ws.handler.MessageContext messagecontext) {
+		public boolean handleFault(LogicalMessageContext messagecontext) {
 			result = result.concat("L1f:");
 			if (logicalhandler1_FaultResultDesired == ResultDesired.TRUE)
 				return true;
@@ -851,7 +833,7 @@
 			return true;
 		}
 
-		public boolean handleMessage(javax.xml.ws.handler.MessageContext messagecontext) {
+		public boolean handleMessage(LogicalMessageContext messagecontext) {
 			result = result.concat("L1m:");
 			if (logicalhandler1_MessageResultDesired == ResultDesired.TRUE)
 				return true;
@@ -869,13 +851,13 @@
 	}
 	
 
-	private class LogicalHandler2 implements LogicalHandler {
+	private class LogicalHandler2 implements LogicalHandler<LogicalMessageContext> {
 
 		public void close(javax.xml.ws.handler.MessageContext messagecontext) {
 			result = result.concat("L2c:");
 		}
 
-		public boolean handleFault(javax.xml.ws.handler.MessageContext messagecontext) {
+		public boolean handleFault(LogicalMessageContext messagecontext) {
 			result = result.concat("L2f:");
 			if (logicalhandler2_FaultResultDesired == ResultDesired.TRUE)
 				return true;
@@ -890,7 +872,7 @@
 			return true;
 		}
 
-		public boolean handleMessage(javax.xml.ws.handler.MessageContext messagecontext) {
+		public boolean handleMessage(LogicalMessageContext messagecontext) {
 			result = result.concat("L2m:");
 			if (logicalhandler2_MessageResultDesired == ResultDesired.TRUE)
 				return true;
Index: C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/server/EndpointController.java
===================================================================
--- C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/server/EndpointController.java	(revision 528437)
+++ C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/server/EndpointController.java	(working copy)
@@ -177,11 +177,15 @@
 
                 // Invoke outbound application handlers.  It's safe to use the first object on the iterator because there is
                 // always exactly one EndpointDescription on a server invoke
+                // Also, if the message is oneWay, don't bother with response handlers.  The responseMsgContext is probably NULL
+                // anyway, and would cause an NPE.
+                if (!isOneWay(requestMsgCtx.getAxisMessageContext())) {
                 HandlerInvokerUtils.invokeOutboundHandlers(responseMsgContext,
                         ic.getHandlers(),
                                                            requestMsgCtx.getEndpointDescription(),
                                                            HandlerChainProcessor.MEP.RESPONSE,
                                                            false);
+                }
             } else
             { // the inbound handler chain must have had a problem, and we've reversed directions
                 responseMsgContext =
Index: C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/handler/HandlerChainProcessor.java
===================================================================
--- C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/handler/HandlerChainProcessor.java	(revision 528437)
+++ C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/handler/HandlerChainProcessor.java	(working copy)
@@ -18,33 +18,31 @@
  */
 package org.apache.axis2.jaxws.handler;
 
-import org.apache.axis2.jaxws.ExceptionFactory;
-import org.apache.axis2.jaxws.i18n.Messages;
-import org.apache.axis2.jaxws.marshaller.impl.alt.MethodMarshallerUtils;
-import org.apache.axis2.jaxws.message.Protocol;
-import org.apache.axis2.jaxws.message.XMLFault;
-import org.apache.axis2.jaxws.message.util.XMLFaultUtils;
-import org.apache.axis2.jaxws.utility.SAAJFactory;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
 import javax.xml.soap.SOAPBody;
 import javax.xml.soap.SOAPConstants;
-import javax.xml.soap.SOAPException;
 import javax.xml.soap.SOAPFault;
 import javax.xml.soap.SOAPMessage;
 import javax.xml.ws.ProtocolException;
 import javax.xml.ws.WebServiceException;
 import javax.xml.ws.handler.Handler;
 import javax.xml.ws.handler.LogicalHandler;
-import javax.xml.ws.handler.MessageContext;
 import javax.xml.ws.handler.soap.SOAPHandler;
-import javax.xml.ws.handler.soap.SOAPMessageContext;
 
-import org.apache.axis2.jaxws.message.util.MessageUtils;
-import org.apache.axis2.jaxws.util.SoapUtils;
-import org.apache.axis2.saaj.SOAPFactoryImpl;
+import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.context.factory.MessageContextFactory;
+import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.i18n.Messages;
+import org.apache.axis2.jaxws.marshaller.impl.alt.MethodMarshallerUtils;
+import org.apache.axis2.jaxws.message.Protocol;
+import org.apache.axis2.jaxws.message.XMLFault;
+import org.apache.axis2.jaxws.message.factory.MessageFactory;
+import org.apache.axis2.jaxws.message.util.XMLFaultUtils;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
+import org.apache.axis2.jaxws.utility.SAAJFactory;
 
 public class HandlerChainProcessor {
 
@@ -57,6 +55,7 @@
         REQUEST, RESPONSE
     };
 
+	private javax.xml.ws.handler.MessageContext currentMC;
     private MessageContext mc;
 	private List<Handler> handlers = null;
 
@@ -92,7 +91,7 @@
     }
 
     /*
-      * verifyChain will check that the chain is properly sorted, since it may be
+      * sortChain will properly sort the chain, logical then protocol, since it may be
       * a chain built or modified by a client application.  Also keep track of
       * start/end for each type of handler.
       */
@@ -135,36 +134,42 @@
 	}
 	
 
-    /**
-     * @param mc By the time processChain method is called, we already have the sorted chain, and now
-     *           we have the direction, MEP, MessageContext, and if a response is expected.  We should
-     *           be able to handle everything from here, no pun intended.
-     *           <p/>
-     *           Two things a user of processChain should check when the method completes: 1.  Has the
-     *           MessageContext.MESSAGE_OUTBOUND_PROPERTY changed, indicating reversal of message
-     *           direction 2.  Has the message been converted to a fault message? (indicated by a flag
-     *           in the message)
-     */
-	public void processChain(MessageContext mc, Direction direction, MEP mep, boolean expectResponse) {
-        // make sure it's set:
-        mc.put(MessageContext.MESSAGE_OUTBOUND_PROPERTY, (direction == Direction.OUT));
+	
+	/**
+	 * @param mc
+	 * By the time processChain method is called, we already have the sorted chain,
+	 * and now we have the direction, MEP, MessageContext, and if a response is expected.  We should
+	 * be able to handle everything from here, no pun intended.
+	 * 
+	 * Two things a user of processChain should check when the method completes:
+	 * 1.  Has the MessageContext.MESSAGE_OUTBOUND_PROPERTY changed, indicating reversal of message direction
+	 * 2.  Has the message been converted to a fault message? (indicated by a flag in the message)
+	 */
+	public boolean processChain(MessageContext mc, Direction direction, MEP mep, boolean expectResponse) {
 
+        if (handlers.size() == 0)
+            return true;
+        
         this.mc = mc;
 		sortChain();
-
+        initContext(direction);
+		
 		if (direction == Direction.OUT) {  // 9.3.2 outbound
-            // logical context, then SOAP
+            currentMC.put(javax.xml.ws.handler.MessageContext.MESSAGE_OUTBOUND_PROPERTY, (direction == Direction.OUT));
 		    callGenericHandlers(mep, expectResponse, 0, handlers.size()-1, direction);
 		}
 		else { // IN case - 9.3.2 inbound
-            // soap context, then logical
+            currentMC.put(javax.xml.ws.handler.MessageContext.MESSAGE_OUTBOUND_PROPERTY, (direction == Direction.OUT));
 			callGenericHandlers(mep, expectResponse, handlers.size()-1, 0, direction);
 		}
 
 		// message context may have been changed to be response, and message converted
-		// according to the JAXWS spec 9.3.2.1 footnote 2
+		// according to the JAXWS spec 9.3.2.1 footnote 2        
+        if ((Boolean)(currentMC.get(javax.xml.ws.handler.MessageContext.MESSAGE_OUTBOUND_PROPERTY)) != (direction == Direction.OUT))
+            return false;
+        return true;
 
-    }
+	}
 
 
     /*
@@ -193,6 +198,8 @@
                 newEnd = 0;
                 newDirection = Direction.IN;
                 i++;
+                if (result == SUCCESSFUL)  // don't switch if failed, since we'll be reversing directions
+                    switchContext(direction, i);
             }
         } else { // IN case
             while ((i >= end) && (result == SUCCESSFUL)) {
@@ -202,11 +209,12 @@
                 newEnd = handlers.size() - 1;
                 newDirection = Direction.OUT;
                 i--;
+                if (result == SUCCESSFUL)  // don't switch if failed, since we'll be reversing directions
+                    switchContext(direction, i);
             }
         }
 
-        if (newDirection ==
-                direction) // we didn't actually process anything, probably due to empty list
+        if (newDirection == direction) // we didn't actually process anything, probably due to empty list
             return;  // no need to continue
 
         // 9.3.2.3 in all situations, we want to close as many handlers as
@@ -250,11 +258,13 @@
 
         if (direction == Direction.OUT) {
             for (; i <= end; i++) {
-                ((Handler)handlers.get(i)).handleMessage(mc);
+                switchContext(direction, i);
+				((Handler) handlers.get(i)).handleMessage(currentMC);
             }
         } else { // IN case
             for (; i >= end; i--) {
-                ((Handler)handlers.get(i)).handleMessage(mc);
+                switchContext(direction, i);
+				((Handler) handlers.get(i)).handleMessage(currentMC);
             }
         }
     }
@@ -269,19 +279,19 @@
     private int handleMessage(Handler handler, Direction direction,
                               boolean expectResponse) throws RuntimeException {
         try {
-            boolean success = handler.handleMessage(mc);
+			boolean success = handler.handleMessage(currentMC);
             if (success)
                 return SUCCESSFUL;
             else {
                 if (expectResponse)
-                    mc.put(MessageContext.MESSAGE_OUTBOUND_PROPERTY, (direction != Direction.OUT));
+					currentMC.put(javax.xml.ws.handler.MessageContext.MESSAGE_OUTBOUND_PROPERTY, (direction != Direction.OUT));
                 return FAILED;
             }
         } catch (RuntimeException re) {  // RuntimeException and ProtocolException
             savedException = re;
             if (expectResponse)
                 // mark it as reverse direction
-                mc.put(MessageContext.MESSAGE_OUTBOUND_PROPERTY, (direction != Direction.OUT));
+				currentMC.put(javax.xml.ws.handler.MessageContext.MESSAGE_OUTBOUND_PROPERTY, (direction != Direction.OUT));
             if (ProtocolException.class.isAssignableFrom(re.getClass())) {
 				convertToFaultMessage(mc, re, proto);
                 return PROTOCOL_EXCEPTION;
@@ -302,7 +312,8 @@
         if (direction == Direction.OUT) {
             for (int i = start; i <= end; i++) {
                 try {
-                    ((Handler)handlers.get(i)).close(mc);
+                    switchContext(direction, i);
+					((Handler) handlers.get(i)).close(currentMC);
                     // TODO when we close, are we done with the handler instance, and thus
                     // may call the PreDestroy annotated method?  I don't think so, especially
                     // if we've cached the handler list somewhere.
@@ -313,7 +324,8 @@
         } else { // IN case
             for (int i = start; i >= end; i--) {
                 try {
-                    ((Handler)handlers.get(i)).close(mc);
+                    switchContext(direction, i);
+					((Handler) handlers.get(i)).close(currentMC);
 					// TODO when we close, are we done with the handler instance, and thus
                     // may call the PreDestroy annotated method?  I don't think so, especially
                     // if we've cached the handler list somewhere.
@@ -322,6 +334,9 @@
                 }
             }
         }
+	}
+    public void callHandlerCloseMethods(Direction direction) {
+        callCloseHandlers(0, handlers.size() - 1, direction);
     }
 
     /*
@@ -336,12 +351,12 @@
 
         // direction.IN = client
         // direction.OUT = server
+        if (handlers.size() == 0)
+            return;
         this.mc = mc;
-
-        // make sure it's right:
-        mc.put(MessageContext.MESSAGE_OUTBOUND_PROPERTY, (direction == Direction.OUT));
-
 		sortChain();
+        initContext(direction);
+		currentMC.put(javax.xml.ws.handler.MessageContext.MESSAGE_OUTBOUND_PROPERTY, (direction == Direction.OUT));
 
         try {
             if (direction == Direction.OUT) {
@@ -355,8 +370,10 @@
         } finally {
             // we can close all the Handlers in reverse order
             if (direction == Direction.OUT) {
+                initContext(Direction.IN);
                 callCloseHandlers(handlers.size() - 1, 0, Direction.IN);
             } else { // IN case
+                initContext(Direction.IN);
                 callCloseHandlers(0, handlers.size() - 1, Direction.OUT);
             }
         }
@@ -374,18 +391,23 @@
                                         Direction direction) throws RuntimeException {
 
         int i = start;
+        
+        // we may be starting in the middle of the list, and therefore may need to switch contexts
+        switchContext(direction, i);
 
         if (direction == Direction.OUT) {
             for (; i <= end; i++) {
-                if (((Handler)handlers.get(i)).handleFault(mc) == false) {
+				if (((Handler) handlers.get(i)).handleFault(currentMC) == false) {
                     break;
                 }
+                switchContext(direction, i+1);
             }
         } else { // IN case
             for (; i >= end; i--) {
-                if (((Handler)handlers.get(i)).handleFault(mc) == false) {
+				if (((Handler) handlers.get(i)).handleFault(currentMC) == false) {
                     break;
                 }
+                switchContext(direction, i-1);
             }
         }
     }
@@ -417,17 +439,47 @@
                 // TODO something is wrong here.  The message should be a response message, not
                 // a request message.  I don't see how to change that.  (see the debugger...)
                 // TODO probably also need to turn on message.WRITE_XML_DECLARATION
-                ((SoapMessageContext)mc).setMessage(message);
+                mc.setMessage(((MessageFactory)(FactoryRegistry.getFactory(MessageFactory.class))).createFrom(message));
 
             } else {
                 throw ExceptionFactory.makeWebServiceException("We only support SOAP11 and SOAP12 for JAXWS handlers");
             }
 
-        } catch (SOAPException soapex) {
-            throw ExceptionFactory.makeWebServiceException(soapex);
+        } catch (Exception ex) {
+            throw ExceptionFactory.makeWebServiceException(ex);
         }
 
+	}
+    
+    private void initContext(Direction direction) {
+        if (direction == Direction.OUT) {
+            // logical context, then SOAP
+            if ((logicalLength == 0) && (handlers.size() > 0))  // we only have soap handlers
+                currentMC = MessageContextFactory.createSoapMessageContext(mc);
+            else
+                currentMC = MessageContextFactory.createLogicalMessageContext(mc);
+        }
+        else {
+            // SOAP context, then logical
+            if ((logicalLength == handlers.size()) && (handlers.size() > 0))  // we only have logical handlers
+                currentMC = MessageContextFactory.createLogicalMessageContext(mc);
+            else
+                currentMC = MessageContextFactory.createSoapMessageContext(mc);
+        }
     }
+    
+    private void switchContext(Direction direction, int index) {
 
+        if ((logicalLength == handlers.size()) || (logicalLength == 0))
+            return;  // all handlers must be the same type, so no context switch
+        
+        if (((direction == Direction.OUT) && (index == logicalLength))
+                || ((direction == Direction.IN) && (index == (logicalLength - 1)))) {
+            if (currentMC.getClass().isAssignableFrom(LogicalMessageContext.class))
+                currentMC = MessageContextFactory.createSoapMessageContext(mc);
+            else
+                currentMC = MessageContextFactory.createLogicalMessageContext(mc);
+        }
+    }
 
 }
Index: C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/handler/HandlerResolverImpl.java
===================================================================
--- C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/handler/HandlerResolverImpl.java	(revision 528437)
+++ C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/handler/HandlerResolverImpl.java	(working copy)
@@ -20,6 +20,8 @@
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.Map;
 import org.apache.axis2.java.security.AccessController;
 import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.description.EndpointDescription;
@@ -58,6 +60,15 @@
 
 public class HandlerResolverImpl implements HandlerResolver {
 
+    // TODO should probably use constants defined elsewhere
+    static final Map<String, String> protocolBindingsMap = new HashMap<String, String>(5);
+    static {
+        protocolBindingsMap.put("##SOAP11_HTTP",        "http://schemas.xmlsoap.org/wsdl/soap/http");
+        protocolBindingsMap.put("##SOAP11_HTTP_MTOM",   "http://schemas.xmlsoap.org/wsdl/soap/http?mtom=true");
+        protocolBindingsMap.put("##SOAP12_HTTP",        "http://www.w3.org/2003/05/soap/bindings/HTTP/");
+        protocolBindingsMap.put("##SOAP12_HTTP_MTOM",   "http://www.w3.org/2003/05/soap/bindings/HTTP/?mtom=true");
+        protocolBindingsMap.put("##XML_HTTP",           "http://www.w3.org/2004/08/wsdl/http");
+    }
     private static Log log = LogFactory.getLog(HandlerResolverImpl.class);
     /*
       * TODO:  is there any value/reason in caching the list we collect from the
@@ -88,7 +99,43 @@
 	 * and returning it.  We do not sort here.
       */
     private ArrayList<Handler> resolveHandlers(PortInfo portinfo) throws WebServiceException {
+        /*
 
+            A sample XML file for the handler-chains:
+            
+            <jws:handler-chains xmlns:jws="http://java.sun.com/xml/ns/javaee">
+                <jws:handler-chain>
+                    <jws:protocol-bindings>##XML_HTTP</jws:protocol-bindings>
+                    <jws:handler>
+                        <jws:handler-name>MyHandler</jws:handler-name>
+                        <jws:handler-class>org.apache.axis2.jaxws.MyHandler</jws:handler-class>
+                    </jws:handler>
+                </jws:handler-chain>
+                <jws:handler-chain>
+                    <jws:port-name-pattern>jws:Foo*</jws:port-name-pattern>
+                    <jws:handler>
+                        <jws:handler-name>MyHandler</jws:handler-name>
+                        <jws:handler-class>org.apache.axis2.jaxws.MyHandler</jws:handler-class>
+                    </jws:handler>
+                </jws:handler-chain>
+                <jws:handler-chain>
+                    <jws:service-name-pattern>jws:Bar</jws:service-name-pattern>
+                    <jws:handler>
+                        <jws:handler-name>MyHandler</jws:handler-name>
+                        <jws:handler-class>org.apache.axis2.jaxws.MyHandler</jws:handler-class>
+                    </jws:handler>
+                </jws:handler-chain>
+            </jws:handler-chains>
+            
+            Couple of things I'm not sure about...
+            1)  if the protocol-binding, port-name-pattern, and service-name-pattern all
+                match the PortInfo object, does MyHandler get added three times?  Probably would get added 3 times.
+            2)  I assume the asterisk "*" is a wildcard.  Can the asterisk only occur on the local part of the qname?
+            3)  Can there be more than one service-name-pattern or port-name-pattern, just like for protocol-bindings?
+            4)  How many protocol-bindings are there?  ##XML_HTTP ##SOAP11_HTTP ##SOAP12_HTTP ##SOAP11_HTTP_MTOM ##SOAP12_HTTP_MTOM
+                They are separated by spaces
+         */
+
         // our implementation already has a reference to the EndpointDescription,
         // which is where one might get the portinfo object.  We still have the 
         // passed-in variable, however, due to the spec
@@ -105,7 +152,13 @@
         Iterator it = handlerCT == null ? null : handlerCT.getHandlerChain().iterator();
 
         while ((it != null) && (it.hasNext())) {
-            List<HandlerType> handlerTypeList = ((HandlerChainType)it.next()).getHandler();
+            HandlerChainType handlerChainType = ((HandlerChainType)it.next());
+            
+            // if !match, continue (to next chain)
+            if (!(chainResolvesToPort(handlerChainType, portinfo)))
+                continue;
+            
+            List<HandlerType> handlerTypeList = handlerChainType.getHandler();
             Iterator ht = handlerTypeList.iterator();
             while (ht.hasNext()) {
                 
@@ -270,4 +323,31 @@
         }
     }
     
+    private static boolean chainResolvesToPort(HandlerChainType handlerChainType, PortInfo portinfo) {
+        
+        boolean match = true;
+        
+        List<String> protocolBindings = handlerChainType.getProtocolBindings();
+        if (protocolBindings != null) {
+            for (Iterator<String> it = protocolBindings.iterator() ; it.hasNext();) {
+                match = false;  // default to false in the protocol bindings until we find a match
+                String protocolBinding = it.next();
+                protocolBinding = protocolBinding.startsWith("##") ? protocolBindingsMap.get(protocolBinding) : protocolBinding;
+                if ((protocolBinding != null) && (protocolBinding.equals(portinfo.getBindingID()))) {
+                    match = true;
+                    break;
+                }
+            }
+            if (match == false) {
+                // we've checked all the protocolBindings, but didn't find a match, no need to continue
+                return match;
+            }
+        }
+        
+        // TODO should continue on and check portnamepattern and servicenamepattern
+        String portNamePattern = handlerChainType.getPortNamePattern();
+        
+        return match;
+    }
+    
 }
Index: C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/handler/HandlerInvokerUtils.java
===================================================================
--- C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/handler/HandlerInvokerUtils.java	(revision 528437)
+++ C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/handler/HandlerInvokerUtils.java	(working copy)
@@ -45,19 +45,7 @@
      */
     public static boolean invokeInboundHandlers(MessageContext msgCtx,
             List<Handler> handlers, EndpointDescription endpointDesc, HandlerChainProcessor.MEP mep, boolean isOneWay) {
-        
-        if (handlers == null)
-            return true;
-        
-        int numHandlers = handlers.size();
 
-        javax.xml.ws.handler.MessageContext handlerMessageContext = null;
-        if (numHandlers > 0) {
-            handlerMessageContext = findOrCreateMessageContext(msgCtx);
-        } else {
-            return true;
-        }
-
         String bindingProto = null;
         if (mep.equals(HandlerChainProcessor.MEP.REQUEST))  // inbound request; must be on the server
             bindingProto = endpointDesc.getBindingType();
@@ -67,12 +55,13 @@
         
         HandlerChainProcessor processor = new HandlerChainProcessor(handlers, proto);
         // if not one-way, expect a response
+        boolean success = true;
         try {
             if (msgCtx.getMessage().isFault()) {
-                processor.processFault(handlerMessageContext,
+        		processor.processFault(msgCtx,
                                        HandlerChainProcessor.Direction.IN);
             } else {
-        		processor.processChain(handlerMessageContext,
+        		success = processor.processChain(msgCtx,
                                                                HandlerChainProcessor.Direction.IN,
                                                                mep,
                                                                !isOneWay);
@@ -83,18 +72,19 @@
                 * we are in the client inbound case.  Make sure the message
                 * context and message are transformed.
                 */
-        	HandlerChainProcessor.convertToFaultMessage(handlerMessageContext, re, proto);
-            addConvertedFaultMsgToCtx(msgCtx, handlerMessageContext);
+        	HandlerChainProcessor.convertToFaultMessage(msgCtx, re, proto);
             return false;
         }
 
-        if (handlerMessageContext.get(javax.xml.ws.handler.MessageContext.MESSAGE_OUTBOUND_PROPERTY)
-                .equals(true)
-                && mep.equals(HandlerChainProcessor.MEP.REQUEST)) {
+        if (success && mep.equals(HandlerChainProcessor.MEP.RESPONSE)) {
+            // inbound response must be client, and we were successful, so close handlers
+            processor.callHandlerCloseMethods(HandlerChainProcessor.Direction.IN);
+        }
+        
+        if (!success && mep.equals(HandlerChainProcessor.MEP.REQUEST)) {
             // uh-oh.  We've changed directions on the server inbound handler processing,
             // This means we're now on an outbound flow, and the endpoint will not
             // be called.  Be sure to mark the context and message as such.
-            addConvertedFaultMsgToCtx(msgCtx, handlerMessageContext);
             return false;
         }
         return true;
@@ -111,16 +101,7 @@
         
         if (handlers == null)
             return true;
-        
-        int numHandlers = handlers.size();
 
-        javax.xml.ws.handler.MessageContext handlerMessageContext = null;
-        if (numHandlers > 0) {
-            handlerMessageContext = findOrCreateMessageContext(msgCtx);
-        } else {
-            return true;
-        }
-        
         String bindingProto = null;
         if (mep.equals(HandlerChainProcessor.MEP.REQUEST))  // outbound request; must be on the client
             bindingProto = endpointDesc.getClientBindingID();
@@ -130,12 +111,13 @@
         
         HandlerChainProcessor processor = new HandlerChainProcessor(handlers, proto);
         // if not one-way, expect a response
+        boolean success = true;
         try {
             if (msgCtx.getMessage().isFault()) {
-                processor.processFault(handlerMessageContext,
+        		processor.processFault(msgCtx,
                                        HandlerChainProcessor.Direction.OUT);
             } else {
-        		processor.processChain(handlerMessageContext,
+        		success = processor.processChain(msgCtx,
                                                                HandlerChainProcessor.Direction.OUT,
                                                                mep, !isOneWay);
             }
@@ -145,70 +127,23 @@
                 * we are in the server outbound case.  Make sure the message
                 * context and message are transformed.
                 */
-        	HandlerChainProcessor.convertToFaultMessage(handlerMessageContext, re, proto);
-            addConvertedFaultMsgToCtx(msgCtx, handlerMessageContext);
+        	HandlerChainProcessor.convertToFaultMessage(msgCtx, re, proto);
             return false;
         }
 
-        if (handlerMessageContext.get(javax.xml.ws.handler.MessageContext.MESSAGE_OUTBOUND_PROPERTY)
-                .equals(false)
-                && mep.equals(HandlerChainProcessor.MEP.REQUEST)) {
+        if (success && mep.equals(HandlerChainProcessor.MEP.RESPONSE)) {
+            // outbound response must be server, and we were successful, so close handlers
+            processor.callHandlerCloseMethods(HandlerChainProcessor.Direction.OUT);
+        }
+
+        if (!success && mep.equals(HandlerChainProcessor.MEP.REQUEST)) {
             // uh-oh.  We've changed directions on the client outbound handler processing,
             // This means we're now on an inbound flow, and the service will not
             // be called.  Be sure to mark the context and message as such.
-            addConvertedFaultMsgToCtx(msgCtx, handlerMessageContext);
             return false;
         }
         return true;
 
     }
-
-    /**
-     * Find or Create Handler Message Context
-     *
-     * @param mc
-     * @return javax.xml.ws.handler.MessageContext
-     */
-    private static javax.xml.ws.handler.MessageContext findOrCreateMessageContext(
-            MessageContext mc) {
-        // See if a soap message context is already present on the WebServiceContext
-        javax.xml.ws.handler.MessageContext handlerMessageContext = null;
-        ServiceContext serviceContext = mc.getAxisMessageContext().getServiceContext();
-        // there's no such thing as a serviceContext on the client? -- that was my experience, anyway
-        if (serviceContext != null) {
-            WebServiceContext ws = (WebServiceContext)serviceContext.getProperty(EndpointLifecycleManagerImpl.WEBSERVICE_MESSAGE_CONTEXT);
-            if (ws != null) {
-                handlerMessageContext = ws.getMessageContext();
-            }
-        }
-        if (handlerMessageContext == null) {
-            handlerMessageContext = createSOAPMessageContext(mc);
-        }
-        return handlerMessageContext;
-    }
-
-    /**
-     * @param mc
-     * @return new SOAPMessageContext
-     */
-    private static javax.xml.ws.handler.MessageContext createSOAPMessageContext(MessageContext mc) {
-        SoapMessageContext soapMessageContext =
-                (SoapMessageContext)MessageContextFactory.createSoapMessageContext(mc);
-        ContextUtils.addProperties(soapMessageContext, mc);
-        return soapMessageContext;
-    }
-
-
-    private static void addConvertedFaultMsgToCtx(MessageContext msgCtx,
-                                                  javax.xml.ws.handler.MessageContext handlerMsgCtx) {
-        try {
-            Message msg = ((MessageFactory)FactoryRegistry.getFactory(MessageFactory.class))
-                    .createFrom(((SOAPMessageContext)handlerMsgCtx).getMessage());
-            msgCtx.setMessage(msg);
-        } catch (XMLStreamException e) {
-            // TODO log it
-            throw ExceptionFactory.makeWebServiceException(e);
-        }
-    }
     
 }
Index: C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/handler/SoapMessageContext.java
===================================================================
--- C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/handler/SoapMessageContext.java	(revision 528437)
+++ C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/handler/SoapMessageContext.java	(working copy)
@@ -56,7 +56,7 @@
         return msg.getAsSOAPMessage();
     }
 
-    public Set<URI> getRoles() {
+    public Set<String> getRoles() {
         return null;
     }
 
Index: C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/client/async/AsyncResponse.java
===================================================================
--- C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/client/async/AsyncResponse.java	(revision 528437)
+++ C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws/src/org/apache/axis2/jaxws/client/async/AsyncResponse.java	(working copy)
@@ -245,8 +245,10 @@
         // A faultMessageContext means that there could possibly be a SOAPFault
         // on the MessageContext that we need to unmarshall.
         if (faultMessageContext != null) {
+            // it is possible the message could be null.  For example, if we gave the proxy a bad endpoint address.
+            // If it is the case that the message is null, there's no sense running through the handlers.
+            if (faultMessageContext.getMessage() != null)
             // Invoke inbound handlers.
-            // TODO: integrate -- uncomment line
             HandlerInvokerUtils.invokeInboundHandlers(faultMessageContext, faultMessageContext.getInvocationContext().getHandlers(), faultMessageContext.getEndpointDescription(), HandlerChainProcessor.MEP.RESPONSE, false);
             Throwable t = getFaultResponse(faultMessageContext);
             if (t != null) {

Property changes on: C:\eclipse\workspace_axis2\GM_apache_latest\modules\scripting
___________________________________________________________________
Name: svn:ignore
   + target


Index: C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws-api/src/javax/xml/ws/handler/soap/SOAPMessageContext.java
===================================================================
--- C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws-api/src/javax/xml/ws/handler/soap/SOAPMessageContext.java	(revision 528437)
+++ C:/eclipse/workspace_axis2/GM_apache_latest/modules/jaxws-api/src/javax/xml/ws/handler/soap/SOAPMessageContext.java	(working copy)
@@ -30,5 +30,5 @@
 
     public abstract Object[] getHeaders(QName qname, JAXBContext jaxbcontext, boolean flag);
 
-    public abstract Set<java.net.URI> getRoles();
+    public abstract Set<String> getRoles();
 }
