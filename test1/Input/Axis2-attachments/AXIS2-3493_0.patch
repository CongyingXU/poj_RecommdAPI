Index: modules/kernel/src/org/apache/axis2/description/AxisService.java
===================================================================
--- modules/kernel/src/org/apache/axis2/description/AxisService.java	(revision 618720)
+++ modules/kernel/src/org/apache/axis2/description/AxisService.java	(working copy)
@@ -25,6 +25,7 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.PrintWriter;
+import java.io.OutputStreamWriter;
 import java.net.SocketException;
 import java.net.URL;
 import java.security.PrivilegedAction;
@@ -58,6 +59,7 @@
 import javax.xml.parsers.ParserConfigurationException;
 
 import org.apache.axiom.om.OMElement;
+import org.apache.axiom.attachments.utils.IOUtils;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.addressing.AddressingHelper;
@@ -73,6 +75,7 @@
 import org.apache.axis2.dataretrieval.LocatorType;
 import org.apache.axis2.dataretrieval.OutputForm;
 import org.apache.axis2.dataretrieval.WSDLSupplier;
+import org.apache.axis2.dataretrieval.SchemaSupplier;
 import org.apache.axis2.deployment.DeploymentConstants;
 import org.apache.axis2.deployment.util.ExcludeInfo;
 import org.apache.axis2.deployment.util.PhasesInfo;
@@ -952,10 +955,10 @@
         return eprs;
     }
 
-    private void printDefinitionObject(Definition definition, OutputStream out)
+    private void printDefinitionObject(Definition definition, OutputStream out, String requestIP)
             throws AxisFault, WSDLException {
         if (isModifyUserWSDLPortAddress()) {
-            setPortAddress(definition);
+            setPortAddress(definition, requestIP);
         }
         if (!wsdlImportLocationAdjusted){
            changeImportAndIncludeLocations(definition);
@@ -976,7 +979,7 @@
 
         if (definition != null) {
             try {
-                printDefinitionObject(getWSDLDefinition(definition, wsdlName), out);
+                printDefinitionObject(getWSDLDefinition(definition, wsdlName), out, null);
             } catch (WSDLException e) {
                 throw AxisFault.makeFault(e);
             }
@@ -1090,6 +1093,90 @@
     }
 
     /**
+     * Produces a XSD for this AxisService and prints it to the specified OutputStream.
+     * 
+     * @param out destination stream.
+     * @param xsd schema name
+     * @return -1 implies not found, 0 implies redirect to root, 1 implies found/printed a schema
+     * @throws IOException
+     */
+    public int printXSD(OutputStream out, String xsd) throws IOException {
+
+        // If we find a SchemaSupplier, use that
+        SchemaSupplier supplier = (SchemaSupplier)getParameterValue("SchemaSupplier");
+        if (supplier != null) {
+                XmlSchema schema = supplier.getSchema(this, xsd);
+                if (schema != null) {
+                    schema.write(new OutputStreamWriter(out, "UTF8"));
+                    out.flush();
+                    out.close();
+                    return 1;
+                }
+        }
+
+        //call the populator
+        populateSchemaMappings();
+        Map schemaMappingtable =
+                getSchemaMappingTable();
+        ArrayList schemas = getSchema();
+
+        //a name is present - try to pump the requested schema
+        if (!"".equals(xsd)) {
+            XmlSchema schema =
+                    (XmlSchema) schemaMappingtable.get(xsd);
+            if (schema == null) {
+                int dotIndex = xsd.indexOf('.');
+                if (dotIndex > 0) {
+                    String schemaKey = xsd.substring(0,dotIndex);
+                    schema = (XmlSchema) schemaMappingtable.get(schemaKey);
+                }
+            }
+            if (schema != null) {
+                //schema is there - pump it outs
+                schema.write(new OutputStreamWriter(out, "UTF8"));
+                out.flush();
+                out.close();
+            } else {
+                InputStream in = getClassLoader()
+                        .getResourceAsStream(DeploymentConstants.META_INF + "/" + xsd);
+                if (in != null) {
+                    out.write(IOUtils.getStreamAsByteArray(in));
+                    out.flush();
+                    out.close();
+                } else {
+                    // Can't find the schema
+                    return -1;
+                }
+            }
+        } else if (schemas.size() > 1) {
+            //multiple schemas are present and the user specified
+            //no name - in this case we cannot possibly pump a schema
+            //so redirect to the service root
+            return 0;
+        } else {
+            //user specified no name and there is only one schema
+            //so pump that out
+            ArrayList list = getSchema();
+            if (list.size() > 0) {
+                XmlSchema schema = getSchema(0);
+                if (schema != null) {
+                    schema.write(new OutputStreamWriter(out, "UTF8"));
+                    out.flush();
+                    out.close();
+                }
+            } else {
+                String xsdNotFound = "<error>" +
+                        "<description>Unable to access schema for this service</description>" +
+                        "</error>";
+                out.write(xsdNotFound.getBytes());
+                out.flush();
+                out.close();
+            }
+        }
+        return 1;
+    }
+
+    /**
      * Produces a WSDL for this AxisService and prints it to the specified OutputStream.
      *
      * @param out destination stream.  The WSDL will be sent here.
@@ -1110,7 +1197,7 @@
             try {
                 Definition definition = supplier.getWSDL(this);
                 if (definition != null) {
-                    printDefinitionObject(getWSDLDefinition(definition, null), out);
+                    printDefinitionObject(getWSDLDefinition(definition, null), out, requestIP);
                 }
             } catch (Exception e) {
                 printWSDLError(out, e);
@@ -1150,13 +1237,18 @@
                     Object extensibilityEle = list.get(i);
                     if (extensibilityEle instanceof SOAPAddress) {
                         SOAPAddress soapAddress = (SOAPAddress) extensibilityEle;
-                        String exsistingAddress = soapAddress.getLocationURI();
-                        if (requestIP == null) {
+                        String existingAddress = soapAddress.getLocationURI();
+                        if (existingAddress == null || existingAddress.equals("REPLACE_WITH_ACTUAL_URL")) {
                             ((SOAPAddress) extensibilityEle).setLocationURI(
-                                    getLocationURI(getEPRs(), exsistingAddress));
+                                    getEPRs()[0]);
                         } else {
-                            ((SOAPAddress) extensibilityEle).setLocationURI(
-                                    getLocationURI(calculateEPRs(requestIP), exsistingAddress));
+                            if (requestIP == null) {
+                                ((SOAPAddress) extensibilityEle).setLocationURI(
+                                        getLocationURI(getEPRs(), existingAddress));
+                            } else {
+                                ((SOAPAddress) extensibilityEle).setLocationURI(
+                                        getLocationURI(calculateEPRs(requestIP), existingAddress));
+                            }
                         }
                     } else if (extensibilityEle instanceof SOAP12Address){
                         SOAP12Address soapAddress = (SOAP12Address) extensibilityEle;
Index: modules/kernel/src/org/apache/axis2/dataretrieval/SchemaSupplier.java
===================================================================
--- modules/kernel/src/org/apache/axis2/dataretrieval/SchemaSupplier.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/dataretrieval/SchemaSupplier.java	(revision 0)
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.dataretrieval;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.description.AxisService;
+import org.apache.ws.commons.schema.XmlSchema;
+
+/**
+ * Return a XMLSchema as an OMElement.  This is used by any AxisService that wishes
+ * to override the standard AxisService2WSDL (see the org.apache.axis2.description
+ * package) method of getting XSD.  If one of these is present in the AxisService
+ * Parameters under the name "SchemaSupplier", it will be queried.
+ */
+public interface SchemaSupplier {
+    XmlSchema getSchema(AxisService service, String xsd) throws AxisFault;
+}
Index: modules/kernel/src/org/apache/axis2/dataretrieval/WSDLSupplier.java
===================================================================
--- modules/kernel/src/org/apache/axis2/dataretrieval/WSDLSupplier.java	(revision 618720)
+++ modules/kernel/src/org/apache/axis2/dataretrieval/WSDLSupplier.java	(working copy)
@@ -1,9 +1,7 @@
 package org.apache.axis2.dataretrieval;
 
-import org.apache.axiom.om.OMElement;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.description.AxisService;
-import org.apache.axis2.context.MessageContext;
 
 import javax.wsdl.Definition;
 /*
Index: modules/kernel/src/org/apache/axis2/transport/http/ListingAgent.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/ListingAgent.java	(revision 618720)
+++ modules/kernel/src/org/apache/axis2/transport/http/ListingAgent.java	(working copy)
@@ -284,71 +284,14 @@
                     return;
                 } else if (xsd >= 0) {
                     res.setContentType("text/xml");
-                    AxisService axisService = (AxisService) serviceObj;
-                    //call the populator
-                    axisService.populateSchemaMappings();
-                    Map schemaMappingtable =
-                            axisService.getSchemaMappingTable();
-                    ArrayList schemas = axisService.getSchema();
-
-                    //a name is present - try to pump the requested schema
-                    String xsds = req.getParameter("xsd");
-                    if (!"".equals(xsds)) {
-                        XmlSchema schema =
-                                (XmlSchema) schemaMappingtable.get(xsds);
-                        if (schema == null) {
-                            int dotIndex = xsds.indexOf('.');
-                            if (dotIndex > 0) {
-                                String schemaKey = xsds.substring(0,dotIndex);
-                                schema = (XmlSchema) schemaMappingtable.get(schemaKey);
-                            }
-                        }
-                        if (schema != null) {
-                            //schema is there - pump it outs
-                            OutputStream out = res.getOutputStream();
-                            schema.write(new OutputStreamWriter(out, "UTF8"));
-                            out.flush();
-                            out.close();
-                        } else {
-                            InputStream in = axisService.getClassLoader()
-                                    .getResourceAsStream(DeploymentConstants.META_INF + "/" + xsds);
-                            if (in != null) {
-                                OutputStream out = res.getOutputStream();
-                                out.write(IOUtils.getStreamAsByteArray(in));
-                                out.flush();
-                                out.close();
-                            } else {
-                                res.sendError(HttpServletResponse.SC_NOT_FOUND);
-                            }
-                        }
-
+                    int ret = ((AxisService) serviceObj).printXSD(res.getOutputStream(), req.getParameter("xsd"));
+                    if (ret == 0) {
                         //multiple schemas are present and the user specified
                         //no name - in this case we cannot possibly pump a schema
                         //so redirect to the service root
-                    } else if (schemas.size() > 1) {
                         res.sendRedirect("");
-                        //user specified no name and there is only one schema
-                        //so pump that out
-                    } else {
-                        ArrayList list = axisService.getSchema();
-                        if (list.size() > 0) {
-                            XmlSchema schema = axisService.getSchema(0);
-                            if (schema != null) {
-                                OutputStream out = res.getOutputStream();
-                                schema.write(new OutputStreamWriter(out, "UTF8"));
-                                out.flush();
-                                out.close();
-                            }
-                        } else {
-                            res.setContentType("text/xml");
-                            String xsdNotFound = "<error>" +
-                                    "<description>Unable to access schema for this service</description>" +
-                                    "</error>";
-                            OutputStream out = res.getOutputStream();
-                            out.write(xsdNotFound.getBytes());
-                            out.flush();
-                            out.close();
-                        }
+                    } else if (ret == -1) {
+                        res.sendError(HttpServletResponse.SC_NOT_FOUND);
                     }
                     return;
                 } else if (policy >= 0) {
Index: modules/parent/pom.xml
===================================================================
--- modules/parent/pom.xml	(revision 618720)
+++ modules/parent/pom.xml	(working copy)
@@ -115,9 +115,10 @@
         <intellij.version>5.0</intellij.version>
         <jalopy.version>1.5rc3</jalopy.version>
         <jaxb.api.version>2.1</jaxb.api.version>
-        <jaxbri.version>2.1</jaxbri.version>
+        <jaxbri.version>2.1.6</jaxbri.version>
         <jaxen.version>1.1.1</jaxen.version>
         <jaxme2.version>0.5.2</jaxme2.version>
+        <jaxws.ri.version>2.1.3</jaxws.ri.version>
         <jettison.version>1.0-RC2</jettison.version>
         <jibx.version>1.1.5</jibx.version>
         <junit.version-jdk1.4>3.8.2</junit.version-jdk1.4>
@@ -504,7 +505,7 @@
         </repository>
         <repository>
             <id>java.net</id>
-            <url>http://download.java.net/maven/1/</url>
+            <url>https://maven-repository.dev.java.net/nonav/repository/</url>
             <layout>legacy</layout>
             <snapshots>
                 <enabled>false</enabled>
@@ -932,6 +933,61 @@
                 <artifactId>xercesImpl</artifactId>
                 <version>${xerces.version}</version>
            </dependency>
+            <dependency>
+                <groupId>com.sun.xml.ws</groupId>
+                <artifactId>jaxws-rt</artifactId>
+                <version>${jaxws.ri.version}</version>
+                <exclusions>
+                    <exclusion>
+                        <groupId>javax.xml.ws</groupId>
+                        <artifactId>jaxws-api</artifactId>
+                    </exclusion>
+                    <exclusion>
+                        <groupId>com.sun.xml.bind</groupId>
+                        <artifactId>jaxb-impl</artifactId>
+                    </exclusion>
+                    <exclusion>
+                        <groupId>com.sun.xml.messaging.saaj</groupId>
+                        <artifactId>saaj-impl</artifactId>
+                    </exclusion>
+                    <exclusion>
+                        <groupId>com.sun.xml.stream.buffer</groupId>
+                        <artifactId>streambuffer</artifactId>
+                    </exclusion>
+                    <exclusion>
+                        <groupId>com.sun.xml.stream</groupId>
+                        <artifactId>sjsxp</artifactId>
+                    </exclusion>
+                    <exclusion>
+                        <groupId>org.jvnet.staxex</groupId>
+                        <artifactId>stax-ex</artifactId>
+                    </exclusion>
+                    <exclusion>
+                        <groupId>com.sun.org.apache.xml.internal</groupId>
+                        <artifactId>resolver</artifactId>
+                    </exclusion>
+                    <exclusion>
+                        <groupId>org.jvnet</groupId>
+                        <artifactId>mimepull</artifactId>
+                    </exclusion>
+                </exclusions>
+            </dependency>
+            <dependency>
+                <groupId>com.sun.xml.ws</groupId>
+                <artifactId>jaxws-tools</artifactId>
+                <version>${jaxws.ri.version}</version>
+                <scope>provided</scope>
+                <exclusions>
+                    <exclusion>
+                        <groupId>com.sun.xml.ws</groupId>
+                        <artifactId>jaxws-rt</artifactId>
+                    </exclusion>
+                    <exclusion>
+                        <groupId>com.sun.xml.bind</groupId>
+                        <artifactId>jaxb-xjc</artifactId>
+                    </exclusion>
+                </exclusions>
+            </dependency>
         </dependencies>
     </dependencyManagement>
     <!-- Top level dependencies that will be needed in all sub mvn modules -->
Index: modules/metadata/src/org/apache/axis2/jaxws/description/builder/JAXWSRIWSDLGenerator.java
===================================================================
--- modules/metadata/src/org/apache/axis2/jaxws/description/builder/JAXWSRIWSDLGenerator.java	(revision 0)
+++ modules/metadata/src/org/apache/axis2/jaxws/description/builder/JAXWSRIWSDLGenerator.java	(revision 0)
@@ -0,0 +1,316 @@
+package org.apache.axis2.jaxws.description.builder;
+
+import com.sun.tools.ws.spi.WSToolsObjectFactory;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.dataretrieval.SchemaSupplier;
+import org.apache.axis2.dataretrieval.WSDLSupplier;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.axis2.jaxws.util.ClassLoaderUtils;
+import org.apache.axis2.transport.http.HTTPConstants;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.xml.sax.InputSource;
+
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletContext;
+import javax.wsdl.Definition;
+import javax.wsdl.WSDLException;
+import javax.wsdl.factory.WSDLFactory;
+import javax.wsdl.xml.WSDLReader;
+import javax.xml.ws.WebServiceException;
+import javax.xml.ws.soap.SOAPBinding;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * This class will implement an interface that is defined by the
+ * MDQ code. It will be registered within the MDQ framework, and the
+ * MDQ code will call this when it finds an application that was
+ * deployed without WSDL. This class will use the WsGen tool to
+ * generate a WSDL Definition based on the Java source for the application.
+ */
+public class JAXWSRIWSDLGenerator implements SchemaSupplier, WSDLSupplier {
+
+    private static final Log log = LogFactory.getLog(JAXWSRIWSDLGenerator.class);
+
+    private String classPath;
+
+    private AxisService axisService;
+    private boolean init = false;
+    private HashMap<String, XmlSchema> docMap;
+    private HashMap<String, Definition> wsdlDefMap;
+
+    public JAXWSRIWSDLGenerator(AxisService axisService) {
+        this.axisService = axisService;
+    }
+
+    /**
+     * This method will drive the call to WsGen to generate a WSDL file for
+     * applications deployed without WSDL. We will then read this file in from
+     * disk and create a Definition. After we are done with the file we will
+     * remove it from disk.
+     */
+    public void generateWsdl(String className, String bindingType) throws
+            WebServiceException {
+
+        AxisConfiguration axisConfiguration = axisService.getAxisConfiguration();
+        File tempFile = (File) axisConfiguration.getParameterValue(
+                Constants.Configuration.ARTIFACTS_TEMP_DIR);
+        if (tempFile == null) {
+            tempFile = new File(System.getProperty("java.io.tmpdir"), "_axis2");
+        }
+
+        Parameter servletConfigParam = axisConfiguration
+                .getParameter(HTTPConstants.HTTP_SERVLETCONFIG);
+
+        if (servletConfigParam == null) {
+            throw new WebServiceException("Axis2 Can't find ServletConfigParameter");
+        }
+        Object obj = servletConfigParam.getValue();
+        ServletContext servletContext;
+        String webBase = null;
+
+        if (obj instanceof ServletConfig) {
+            ServletConfig servletConfig = (ServletConfig) obj;
+            servletContext = servletConfig.getServletContext();
+            webBase = servletContext.getRealPath("/WEB-INF");
+        } else {
+            throw new WebServiceException("Axis2 Can't find ServletConfig");
+        }
+
+        this.classPath = ClassLoaderUtils.getDefaultClasspath(webBase);
+        if (log.isDebugEnabled()) {
+            log.debug("For implementation class " + className +
+                    " WsGen classpath: " +
+                    classPath);
+        }
+        String localOutputDirectory = tempFile.getAbsolutePath() + className;
+        if (log.isDebugEnabled()) {
+            log.debug("Output directory for generated WSDL file: " + localOutputDirectory);
+        }
+        boolean errorOnRead = false;
+        try {
+
+            if (log.isDebugEnabled()) {
+                log.debug("Generating new WSDL Definition");
+            }
+
+            createOutputDirectory(localOutputDirectory);
+            WSToolsObjectFactory factory = WSToolsObjectFactory.newInstance();
+            String[] arguments = getWsGenArguments(className, bindingType, localOutputDirectory);
+            OutputStream os = new ByteArrayOutputStream();
+            factory.wsgen(os, arguments);
+            os.close();
+            wsdlDefMap = readInWSDL(localOutputDirectory);
+            if (wsdlDefMap.isEmpty()) {
+                throw new Exception("A WSDL Definition could not be generated for " +
+                        "the implementation class: " + className);
+            }
+            docMap = readInSchema(localOutputDirectory);
+        }
+        catch (Throwable t) {
+            String msg =
+                    "Error occurred generating WSDL file for Web service implementation class " +
+                            "{" + className + "}: {" + t + "}";
+            log.error(msg);
+            throw new WebServiceException(msg, t);
+        }
+    }
+
+    /**
+     * This will set up the arguments that will be used by the WsGen tool.
+     */
+    private String[] getWsGenArguments(String className, String bindingType, String localOutputDirectory) throws
+            WebServiceException {
+        String[] arguments = null;
+        if (bindingType == null || bindingType.equals("") || bindingType.equals(
+                SOAPBinding.SOAP11HTTP_BINDING) || bindingType.equals(
+                SOAPBinding.SOAP11HTTP_MTOM_BINDING)) {
+            if (log.isDebugEnabled()) {
+                log.debug("Generating WSDL with SOAP 1.1 binding type");
+            }
+            arguments = new String[]{"-cp", classPath, className, "-keep", "-wsdl:soap1.1", "-d",
+                    localOutputDirectory};
+        } else if (bindingType.equals(SOAPBinding.SOAP12HTTP_BINDING) || bindingType.equals(
+                SOAPBinding.SOAP12HTTP_MTOM_BINDING)) {
+            if (log.isDebugEnabled()) {
+                log.debug("Generating WSDL with SOAP 1.2 binding type");
+            }
+            arguments = new String[]{"-cp", classPath, className, "-keep", "-extension",
+                    "-wsdl:Xsoap1.2", "-d", localOutputDirectory};
+        } else {
+            throw new WebServiceException("The binding " + bindingType + " specified by the " +
+                    "class " + className + " cannot be used to generate a WSDL. Please choose " +
+                    "a supported binding type.");
+        }
+        return arguments;
+    }
+
+    /**
+     * This method will be used to create a Definition based on the
+     * WSDL file generated by WsGen.
+     */
+    private HashMap<String, Definition> readInWSDL(String localOutputDirectory) throws Exception {
+        List<File> wsdlFiles = getWSDLFiles(localOutputDirectory);
+        HashMap<String, Definition> wsdlDefMap = new HashMap<String, Definition>();
+        for (File wsdlFile : wsdlFiles) {
+            if (wsdlFile != null) {
+                try {
+                    WSDLFactory wsdlFactory = WSDLFactory.newInstance();
+                    WSDLReader wsdlReader = wsdlFactory.newWSDLReader();
+                    // prevent system out from occurring
+                    wsdlReader.setFeature(com.ibm.wsdl.Constants.FEATURE_VERBOSE, false);
+                    InputStream is = wsdlFile.toURL().openStream();
+                    Definition definition = wsdlReader.readWSDL(localOutputDirectory,
+                            new InputSource(is));
+                    try {
+                        definition.setDocumentBaseURI(wsdlFile.toURI().toString());
+                        if (log.isDebugEnabled()) {
+                            log.debug("Set base document URI for generated WSDL: " +
+                                    wsdlFile.toURI().toString());
+                        }
+                    }
+                    catch (Throwable t) {
+                        if (log.isDebugEnabled()) {
+                            log.debug("Could not set base document URI for generated " +
+                                    "WSDL: " + wsdlFile.getAbsolutePath() + " : " +
+                                    t.toString());
+                        }
+                    }
+                    wsdlDefMap.put(wsdlFile.getName().toLowerCase(), definition);
+                }
+                catch (WSDLException e) {
+                    String msg = "Error occurred while attempting to create Definition from " +
+                            "generated WSDL file {" + wsdlFile.getName() + "}: {" + e + "}";
+                    log.error(msg);
+                    throw new Exception(msg);
+                }
+                catch (IOException e) {
+                    String msg = "Error occurred while attempting to create Definition from " +
+                            "generated WSDL file  {" + wsdlFile.getName() + "}: {" + e + "}";
+                    log.error(msg);
+                    throw new Exception(msg);
+                }
+            }
+        }
+        return wsdlDefMap;
+    }
+
+    /**
+     * This method will be used to locate the WSDL file that was
+     * generated by WsGen. There should be only one file with the
+     * ".wsdl" extension in this directory.
+     */
+    private List<File> getWSDLFiles(String localOutputDirectory) {
+        File classDirectory = new File(localOutputDirectory);
+        ArrayList<File> wsdlFiles = new ArrayList<File>();
+        if (classDirectory.isDirectory()) {
+            File[] files = classDirectory.listFiles();
+            for (File file : files) {
+                String fileName = file.getName();
+                if (fileName.endsWith(".wsdl")) {
+                    if (log.isDebugEnabled()) {
+                        log.debug("Located generated WSDL file: " + fileName);
+                    }
+                    wsdlFiles.add(file);
+                }
+            }
+        }
+        return wsdlFiles;
+    }
+
+    /**
+     * This file will create the directory we will use as the output
+     * directory argument in our call to WsGen.
+     */
+    private void createOutputDirectory(String localOutputDirectory) {
+        File directory = new File(localOutputDirectory);
+        if (!directory.isDirectory()) {
+            directory.mkdirs();
+        }
+    }
+
+    /**
+     * This method will read in all of the schema files that were generated
+     * for a given application.
+     */
+    private HashMap<String, XmlSchema> readInSchema(String localOutputDirectory) throws Exception {
+        try {
+
+            XmlSchemaCollection schemaCollection = new XmlSchemaCollection();
+            schemaCollection.setBaseUri(new File(localOutputDirectory).getAbsolutePath());
+
+
+            HashMap<String, XmlSchema> docMap = new HashMap<String, XmlSchema>();
+            List<File> schemaFiles = getSchemaFiles(localOutputDirectory);
+            for (File schemaFile : schemaFiles) {
+                XmlSchema doc = schemaCollection.read(new InputSource(schemaFile.toURL().toString()), null);
+                if (log.isDebugEnabled()) {
+                    log.debug("Read in schema file: " + schemaFile.getName());
+                }
+                docMap.put(schemaFile.getName(), doc);
+            }
+            return docMap;
+        }
+        catch (Exception e) {
+            String msg =
+                    "Error occurred while attempting to read generated schema file {" + e + "}";
+            log.error(msg);
+            throw new Exception(msg);
+        }
+    }
+
+    /**
+     * This method will return a list of file objects that represent all the
+     * schema files in the current directory.
+     */
+    private List<File> getSchemaFiles(String localOutputDirectory) {
+        ArrayList<File> schemaFiles = new ArrayList<File>();
+        File classDirectory = new File(localOutputDirectory);
+        if (classDirectory.isDirectory()) {
+            File[] files = classDirectory.listFiles();
+            for (File file : files) {
+                String fileName = file.getName();
+                if (fileName.endsWith(".xsd")) {
+                    if (log.isDebugEnabled()) {
+                        log.debug("Located generated schema file: " + fileName);
+                    }
+                    schemaFiles.add(file);
+                }
+            }
+        }
+        return schemaFiles;
+    }
+
+    public Definition getWSDL(AxisService service) throws AxisFault {
+        initialize();
+        return wsdlDefMap.values().iterator().next();
+    }
+
+    private synchronized void initialize() {
+        String className = (String) axisService.getParameter(Constants.SERVICE_CLASS).getValue();
+        if (!init) {
+            generateWsdl(className, SOAPBinding.SOAP11HTTP_BINDING);
+            init = true;
+        }
+    }
+
+    public XmlSchema getSchema(AxisService service, String xsd) throws AxisFault {
+        XmlSchema schema = docMap.get(xsd);
+        if (schema == null) {
+            docMap.values().iterator().next();
+        }
+        return schema;
+    }
+}
\ No newline at end of file
Index: modules/metadata/src/org/apache/axis2/jaxws/description/DescriptionFactory.java
===================================================================
--- modules/metadata/src/org/apache/axis2/jaxws/description/DescriptionFactory.java	(revision 618720)
+++ modules/metadata/src/org/apache/axis2/jaxws/description/DescriptionFactory.java	(working copy)
@@ -22,7 +22,11 @@
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.jaxws.ClientConfigurationFactory;
 import org.apache.axis2.jaxws.description.builder.DescriptionBuilderComposite;
+import org.apache.axis2.jaxws.description.builder.JAXWSRIWSDLGenerator;
 import org.apache.axis2.jaxws.description.impl.DescriptionFactoryImpl;
+import org.apache.axis2.AxisFault;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 
 import javax.xml.namespace.QName;
 
@@ -35,6 +39,8 @@
  * information including annotations, and (in the future) deployment descriptors.
  */
 public class DescriptionFactory {
+    private static final Log log = LogFactory.getLog(DescriptionFactory.class);
+
     /**
      * The type of update being done for a particular Port.  This is used by the JAX-WS service
      * delegate on the CLIENT side. This is used as a parameter to the updateEndpoint factory
@@ -311,6 +317,13 @@
         ServiceDescription serviceDescription = createServiceDescription(serviceImplClass);
         EndpointDescription[] edArray = serviceDescription.getEndpointDescriptions();
         AxisService axisService = edArray[0].getAxisService();
+        try {
+            JAXWSRIWSDLGenerator value = new JAXWSRIWSDLGenerator(axisService);
+            axisService.addParameter("WSDLSupplier", value);
+            axisService.addParameter("SchemaSupplier", value);
+        } catch (Exception ex) {
+            log.info("Unable to set the WSDLSupplier", ex);
+        }
         return axisService;
     }
 
Index: modules/metadata/src/org/apache/axis2/jaxws/util/ClassLoaderUtils.java
===================================================================
--- modules/metadata/src/org/apache/axis2/jaxws/util/ClassLoaderUtils.java	(revision 618720)
+++ modules/metadata/src/org/apache/axis2/jaxws/util/ClassLoaderUtils.java	(working copy)
@@ -19,26 +19,40 @@
 
 package org.apache.axis2.jaxws.util;
 
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
-
 import org.apache.axis2.java.security.AccessController;
 import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
+import java.io.File;
+import java.io.FileFilter;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.net.URLDecoder;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
+import java.util.HashSet;
+import java.util.StringTokenizer;
+import java.util.Iterator;
+import java.util.jar.Attributes;
+import java.util.jar.JarFile;
+import java.util.jar.JarInputStream;
+import java.util.jar.Manifest;
+
 public class ClassLoaderUtils {
 
     private static final Log log = LogFactory.getLog(ClassLoaderUtils.class);
-    
-    private ClassLoaderUtils() {        
-    }
-    
-    /** @return ClassLoader */
+
+    /**
+     * @return ClassLoader
+     */
     public static ClassLoader getClassLoader(final Class cls) {
         ClassLoader cl = null;
         try {
-            cl = (ClassLoader)AccessController.doPrivileged(
+            cl = (ClassLoader) AccessController.doPrivileged(
                     new PrivilegedExceptionAction() {
                         public Object run() throws ClassNotFoundException {
                             return cls.getClassLoader();
@@ -54,12 +68,14 @@
 
         return cl;
     }
-    
-    /** @return ClassLoader */
+
+    /**
+     * @return ClassLoader
+     */
     public static ClassLoader getContextClassLoader(final ClassLoader classLoader) {
         ClassLoader cl;
         try {
-            cl = (ClassLoader)AccessController.doPrivileged(
+            cl = (ClassLoader) AccessController.doPrivileged(
                     new PrivilegedExceptionAction() {
                         public Object run() throws ClassNotFoundException {
                             return classLoader != null ? classLoader : Thread.currentThread().getContextClassLoader();
@@ -85,7 +101,7 @@
                                 final ClassLoader classloader) throws ClassNotFoundException {
         Class cl = null;
         try {
-            cl = (Class)AccessController.doPrivileged(
+            cl = (Class) AccessController.doPrivileged(
                     new PrivilegedExceptionAction() {
                         public Object run() throws ClassNotFoundException {
                             return Class.forName(className, initialize, classloader);
@@ -96,7 +112,7 @@
             if (log.isDebugEnabled()) {
                 log.debug("Exception thrown from AccessController: " + e.getMessage(), e);
             }
-            throw (ClassNotFoundException)e.getException();
+            throw (ClassNotFoundException) e.getException();
         }
 
         return cl;
@@ -110,7 +126,7 @@
     public static Class forName(final String className) throws ClassNotFoundException {
         Class cl = null;
         try {
-            cl = (Class)AccessController.doPrivileged(
+            cl = (Class) AccessController.doPrivileged(
                     new PrivilegedExceptionAction() {
                         public Object run() throws ClassNotFoundException {
                             return Class.forName(className);
@@ -121,10 +137,222 @@
             if (log.isDebugEnabled()) {
                 log.debug("Exception thrown from AccessController: " + e.getMessage(), e);
             }
-            throw (ClassNotFoundException)e.getException();
+            throw (ClassNotFoundException) e.getException();
         }
 
         return cl;
     }
 
+    /**
+     * Expand a directory path or list of directory paths (File.pathSeparator
+     * delimited) into a list of file paths of all the jar files in those
+     * directories.
+     *
+     * @param dirPaths The string containing the directory path or list of
+     *                 directory paths.
+     * @return The file paths of the jar files in the directories. This is an
+     *         empty string if no files were found, and is terminated by an
+     *         additional pathSeparator in all other cases.
+     */
+    public static String expandDirs(String dirPaths) {
+        StringTokenizer st = new StringTokenizer(dirPaths, File.pathSeparator);
+        StringBuffer buffer = new StringBuffer();
+        while (st.hasMoreTokens()) {
+            String d = st.nextToken();
+            File dir = new File(d);
+            if (dir.isDirectory()) {
+                File[] files = dir.listFiles(new JavaArchiveFilter());
+                for (int i = 0; i < files.length; i++) {
+                    buffer.append(files[i]).append(File.pathSeparator);
+                }
+            }
+        }
+        return buffer.toString();
+    }
+
+    /**
+     * Check if this inputstream is a jar/zip
+     *
+     * @param is
+     * @return true if inputstream is a jar
+     */
+    public static boolean isJar(InputStream is) {
+        try {
+            JarInputStream jis = new JarInputStream(is);
+            if (jis.getNextEntry() != null) {
+                return true;
+            }
+        } catch (IOException ioe) {
+        }
+        return false;
+    }
+
+    /**
+     * Get the default classpath from various thingies in the message context
+     *
+     * @param msgContext
+     * @return default classpath
+     */
+    public static String getDefaultClasspath(String webBase) {
+        HashSet classpath = new HashSet();
+        ClassLoader cl = Thread.currentThread().getContextClassLoader();
+        fillClassPath(cl, classpath);
+
+        // Just to be safe (the above doesn't seem to return the webapp
+        // classpath in all cases), manually do this:
+        if (webBase != null) {
+            addPath(classpath, webBase + File.separatorChar + "classes");
+            try {
+                String libBase = webBase + File.separatorChar + "lib";
+                File libDir = new File(libBase);
+                String[] jarFiles = libDir.list();
+                for (int i = 0; i < jarFiles.length; i++) {
+                    String jarFile = jarFiles[i];
+                    if (jarFile.endsWith(".jar")) {
+                        addPath(classpath, libBase +
+                                File.separatorChar +
+                                jarFile);
+                    }
+                }
+            } catch (Exception e) {
+                // Oh well.  No big deal.
+            }
+        }
+
+        // axis.ext.dirs can be used in any appserver
+        getClassPathFromDirectoryProperty(classpath, "axis.ext.dirs");
+
+        // classpath used by Jasper 
+        getClassPathFromProperty(classpath, "org.apache.catalina.jsp_classpath");
+
+        // websphere stuff.
+        getClassPathFromProperty(classpath, "ws.ext.dirs");
+        getClassPathFromProperty(classpath, "com.ibm.websphere.servlet.application.classpath");
+
+        // java class path
+        getClassPathFromProperty(classpath, "java.class.path");
+
+        // Load jars from java external directory
+        getClassPathFromDirectoryProperty(classpath, "java.ext.dirs");
+
+        // boot classpath isn't found in above search
+        getClassPathFromProperty(classpath, "sun.boot.class.path");
+        
+        StringBuffer path = new StringBuffer();
+        for (Iterator iterator = classpath.iterator(); iterator.hasNext();) {
+            String s = (String) iterator.next();
+            path.append(s);
+            path.append(File.pathSeparatorChar);
+        }
+        log.info(path);
+        return path.toString();
+    }
+
+    private static void addPath(HashSet classpath, String s) {
+        String path = s.replace(((File.separatorChar == '/') ? '\\' : '/'), File.separatorChar).trim();
+        File file = new File(path);
+        if (file.exists()) {
+            path = file.getAbsolutePath();
+            classpath.add(path);
+        }
+    }
+
+    /**
+     * Add all files in the specified directory to the classpath
+     *
+     * @param classpath
+     * @param property
+     */
+    private static void getClassPathFromDirectoryProperty(HashSet classpath, String property) {
+        String dirs = System.getProperty(property);
+        String path = null;
+        try {
+            path = expandDirs(dirs);
+        } catch (Exception e) {
+            // Oh well.  No big deal.
+        }
+        if (path != null) {
+            addPath(classpath, path);
+        }
+    }
+
+    /**
+     * Add a classpath stored in a property.
+     *
+     * @param classpath
+     * @param property
+     */
+    private static void getClassPathFromProperty(HashSet classpath, String property) {
+        String path = System.getProperty(property);
+        if (path != null) {
+            addPath(classpath, path);
+        }
+    }
+
+    /**
+     * Walk the classloader hierarchy and add to the classpath
+     *
+     * @param cl
+     * @param classpath
+     */
+    private static void fillClassPath(ClassLoader cl, HashSet classpath) {
+        while (cl != null) {
+            if (cl instanceof URLClassLoader) {
+                URL[] urls = ((URLClassLoader) cl).getURLs();
+                for (int i = 0; (urls != null) && i < urls.length; i++) {
+                    String path = urls[i].getPath();
+                    //If it is a drive letter, adjust accordingly.
+                    if (path.length() >= 3 && path.charAt(0) == '/' && path.charAt(2) == ':')
+                        path = path.substring(1);
+                    addPath(classpath, URLDecoder.decode(path));
+
+                    // if its a jar extract Class-Path entries from manifest
+                    File file = new File(urls[i].getFile());
+                    if (file.isFile()) {
+                        FileInputStream fis = null;
+                        try {
+                            fis = new FileInputStream(file);
+                            if (isJar(fis)) {
+                                JarFile jar = new JarFile(file);
+                                Manifest manifest = jar.getManifest();
+                                if (manifest != null) {
+                                    Attributes attributes = manifest.getMainAttributes();
+                                    if (attributes != null) {
+                                        String s = attributes.getValue(Attributes.Name.CLASS_PATH);
+                                        String base = file.getParent();
+                                        if (s != null) {
+                                            StringTokenizer st = new StringTokenizer(s, " ");
+                                            while (st.hasMoreTokens()) {
+                                                String t = st.nextToken();
+                                                addPath(classpath, base + File.separatorChar + t);
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        } catch (IOException ioe) {
+                        } finally {
+                            if (fis != null) {
+                                try {
+                                    fis.close();
+                                } catch (IOException ioe2) {
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            cl = cl.getParent();
+        }
+    }
+
+    /**
+     * Filter for zip/jar
+     */
+    private static class JavaArchiveFilter implements FileFilter {
+        public boolean accept(File file) {
+            String name = file.getName().toLowerCase();
+            return (name.endsWith(".jar") || name.endsWith(".zip"));
+        }
+    }
 }
Index: modules/metadata/pom.xml
===================================================================
--- modules/metadata/pom.xml	(revision 618720)
+++ modules/metadata/pom.xml	(working copy)
@@ -77,6 +77,16 @@
 				</exclusion>
 			</exclusions>
 		</dependency>
+		<dependency>
+			<groupId>com.sun.xml.ws</groupId> 
+			<artifactId>jaxws-rt</artifactId>
+            <scope>provided</scope>
+		</dependency>
+		<dependency>
+			<groupId>com.sun.xml.ws</groupId> 
+			<artifactId>jaxws-tools</artifactId>
+            <scope>provided</scope>
+		</dependency>
 	</dependencies>
 	<build>
 		<sourceDirectory>src</sourceDirectory>
@@ -154,16 +164,6 @@
 					</execution>
 					
 				</executions>
-				<dependencies>
-					<!--<dependency>
-						<groupId>org.apache.ant</groupId>
-						<artifactId>ant-antlr</artifactId>
-					</dependency>
-					<dependency>
-						<groupId>antlr</groupId>
-						<artifactId>antlrall</artifactId>
-					</dependency>-->
-				</dependencies>
 			</plugin>
 			<plugin>
 				<groupId>org.codehaus.mojo</groupId>
