Index: modules/kernel/src/org/apache/axis2/java/security/SSLProtocolSocketFactory.java
===================================================================
--- modules/kernel/src/org/apache/axis2/java/security/SSLProtocolSocketFactory.java	(revision 1179619)
+++ modules/kernel/src/org/apache/axis2/java/security/SSLProtocolSocketFactory.java	(working copy)
@@ -15,8 +15,6 @@
  */
 package org.apache.axis2.java.security;
 
-import org.apache.commons.httpclient.params.HttpConnectionParams;
-import org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;
 
 import javax.net.SocketFactory;
 import javax.net.ssl.SSLContext;
@@ -29,20 +27,34 @@
 /**
  * @see TrustAllTrustManager
  */
-public class SSLProtocolSocketFactory implements SecureProtocolSocketFactory {
+public class SSLProtocolSocketFactory{
     SSLContext ctx;
 
     public SSLProtocolSocketFactory(SSLContext ctx) {
         this.ctx = ctx;
     }
 
-    public Socket createSocket(final String host, final int port, final InetAddress localAddress,
-                               final int localPort, final HttpConnectionParams params) throws
-                                                                                       IOException {
-        if (params == null) {
-            throw new IllegalArgumentException("Parameters may not be null");
-        }
-        int timeout = params.getConnectionTimeout();
+
+    /**
+     * Gets a new socket connection to the given host.
+     *
+     * @param host the host name/IP
+     * @param port the port on the host
+     * @param localAddress the local host name/IP to bind the socket to
+     * @param localPort the port on the local machine
+     *
+     * @return Socket a new socket
+     *
+     * @throws IOException if an I/O error occurs while creating the socket
+     *
+     * @since 3.0
+     */
+     public Socket createSocket
+                (final String host, final int port, final InetAddress localAddress,
+                final int localPort, final int connectionTimeOut) throws
+                    IOException {
+
+        int timeout = connectionTimeOut;
         SocketFactory socketfactory = ctx.getSocketFactory();
         if (timeout == 0) {
             return socketfactory.createSocket(host, port, localAddress, localPort);
@@ -57,7 +69,18 @@
     }
 
     /**
-     * @see SecureProtocolSocketFactory#createSocket(java.lang.String, int, java.net.InetAddress, int)
+     * Gets a new socket connection to the given host.
+     *
+     * @param host the host name/IP
+     * @param port the port on the host
+     * @param clientHost the local host name/IP to bind the socket to
+     * @param clientPort the port on the local machine
+     *
+     * @return Socket a new socket
+     *
+     * @throws IOException if an I/O error occurs while creating the socket
+     * @throws java.net.UnknownHostException if the IP address of the host cannot be
+     * determined
      */
     public Socket createSocket(String host, int port, InetAddress clientHost, int clientPort)
             throws IOException {
@@ -65,14 +88,37 @@
     }
 
     /**
-     * @see SecureProtocolSocketFactory#createSocket(java.lang.String, int)
+     * Gets a new socket connection to the given host.
+     *
+     * @param host the host name/IP
+     * @param port the port on the host
+     *
+     * @return Socket a new socket
+     *
+     * @throws IOException if an I/O error occurs while creating the socket
+     * @throws java.net.UnknownHostException if the IP address of the host cannot be
+     * determined
      */
     public Socket createSocket(String host, int port) throws IOException {
         return ctx.getSocketFactory().createSocket(host, port);
     }
 
     /**
-     * @see SecureProtocolSocketFactory#createSocket(java.net.Socket, java.lang.String, int, boolean)
+     * Returns a socket connected to the given host that is layered over an
+     * existing socket.  Used primarily for creating secure sockets through
+     * proxies.
+     *
+     * @param socket the existing socket
+     * @param host the host name/IP
+     * @param port the port on the host
+     * @param autoClose a flag for closing the underling socket when the created
+     * socket is closed
+     *
+     * @return Socket a new socket
+     *
+     * @throws IOException if an I/O error occurs while creating the socket
+     * @throws java.net.UnknownHostException if the IP address of the host cannot be
+     * determined
      */
     public Socket createSocket(Socket socket, String host, int port, boolean autoClose)
             throws IOException {
Index: modules/kernel/src/org/apache/axis2/context/NamedValue.java
===================================================================
--- modules/kernel/src/org/apache/axis2/context/NamedValue.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/context/NamedValue.java	(revision 0)
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package org.apache.axis2.context;
+
+public class NamedValue {
+    private final String name;
+    private final String value;
+
+    public NamedValue(final String name ,final String value){
+        if(name==null){
+            throw new IllegalArgumentException("Name must not be null");
+        }else if(name.equals("")) {
+            throw new IllegalArgumentException("Name must not be empty");
+        }
+        this.name = name;
+        this.value = value;
+    }
+
+       /* get the name*/
+    public String getName() {
+        return name;
+    }
+
+    public String getValue() {
+        return value;
+    }
+
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append("Name =");
+        sb.append(this.name);
+        sb.append("      Value =");
+        sb.append(this.value);
+        return sb.toString();
+    }
+}
Index: modules/kernel/src/org/apache/axis2/transport/http/MultipartFormDataFormatter.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/MultipartFormDataFormatter.java	(revision 1179619)
+++ modules/kernel/src/org/apache/axis2/transport/http/MultipartFormDataFormatter.java	(working copy)
@@ -26,10 +26,10 @@
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.transport.MessageFormatter;
+import org.apache.axis2.transport.http.util.AbstractContent;
 import org.apache.axis2.transport.http.util.ComplexPart;
+import org.apache.axis2.transport.http.util.SimplePart;
 import org.apache.axis2.transport.http.util.URLTemplatingUtil;
-import org.apache.commons.httpclient.methods.multipart.Part;
-import org.apache.commons.httpclient.methods.multipart.StringPart;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -88,13 +88,13 @@
 
         OMElement omElement = messageContext.getEnvelope().getBody().getFirstElement();
 
-        Part[] parts = createMultipatFormDataRequest(omElement);
-        if (parts.length > 0) {
+        AbstractContent[] abstractContents = createMultipatFormDataRequest(omElement);
+        if (abstractContents.length > 0) {
             ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
             try {
 
                 // This is accessing a class of Commons-FlieUpload
-                Part.sendParts(bytesOut, parts, format.getMimeBoundary().getBytes());
+                AbstractContent.sendAbstractContents(bytesOut, abstractContents, format.getMimeBoundary().getBytes());
             } catch (IOException e) {
                 throw AxisFault.makeFault(e);
             }
@@ -177,7 +177,7 @@
      * @param dataOut
      * @return
      */
-    private Part[] createMultipatFormDataRequest(OMElement dataOut) {
+    private AbstractContent[] createMultipatFormDataRequest(OMElement dataOut) {
         ArrayList parts = new ArrayList();
         if (dataOut != null) {
             Iterator iter1 = dataOut.getChildElements();
@@ -193,12 +193,12 @@
                             processComplexType(omElement, ele.getChildElements(), omFactory));
                     parts.add(new ComplexPart(ele.getQName().getLocalPart(), omElement.toString()));
                 } else {
-                    parts.add(new StringPart(ele.getQName().getLocalPart(), ele.getText()));
+                    parts.add(new SimplePart(ele.getQName().getLocalPart(), ele.getText()));
                 }
             }
         }
-        Part[] partsArray = new Part[parts.size()];
-        return (Part[]) parts.toArray(partsArray);
+        AbstractContent[] partsArray = new AbstractContent[parts.size()];
+        return (AbstractContent[]) parts.toArray(partsArray);
     }
 
     /**
Index: modules/kernel/src/org/apache/axis2/transport/http/util/SimplePart.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/util/SimplePart.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/transport/http/util/SimplePart.java	(revision 0)
@@ -0,0 +1,122 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package org.apache.axis2.transport.http.util;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+public class SimplePart extends AbstractContentBase {
+
+    /**
+     * Log object for this class.
+     */
+    private static final Log LOG = LogFactory.getLog(SimplePart.class);
+
+    /** Default content encoding of string parameters. */
+    public static final String DEFAULT_CONTENT_TYPE = "text/plain";
+
+    /** Default charset of string parameters*/
+    public static final String DEFAULT_CHARSET = "US-ASCII";
+
+    /** Default transfer encoding of string parameters*/
+    public static final String DEFAULT_TRANSFER_ENCODING = "8bit";
+
+    /** Contents of this StringPart. */
+    private byte[] content;
+
+    /** The String value of this part. */
+    private String value;
+
+    /**
+     * Constructor.
+     *
+     * @param name             The name of the part
+     * @param value          The character encoding, or <code>null</code>
+     * @param charSet          The character encoding, or <code>null</code>
+     */
+    public SimplePart(String name, String value, String charSet) {
+        super(
+                name,
+                DEFAULT_CONTENT_TYPE,
+                charSet == null ? DEFAULT_CHARSET : charSet,
+                DEFAULT_TRANSFER_ENCODING
+        );
+
+        if (value == null) {
+            throw new IllegalArgumentException("Value may not be null");
+        }
+        if (value.indexOf(0) != -1) {
+            // See RFC 2048, 2.8. "8bit Data"
+            throw new IllegalArgumentException("NULs may not be present in string parts");
+        }
+        this.value = name;
+    }
+
+    public SimplePart(String name, String value) {
+        this(name, value, null);
+    }
+
+
+    /**
+     * Gets the content in bytes.  Bytes are lazily created to allow the charset to be changed
+     * after the part is created.
+     *
+     * @return the content in bytes
+     */
+    private byte[] getContent() {
+        if (content == null) {
+            content = EncodingUtils.getBytes(value, getCharSet());
+        }
+        return content;
+    }
+
+    /**
+     * Writes the data to the given OutputStream.
+     * @param out the OutputStream to write to
+     * @throws java.io.IOException if there is a write error
+     */
+    protected void sendData(OutputStream out) throws IOException {
+        LOG.trace("enter sendData(OutputStream)");
+        out.write(getContent());
+    }
+
+    /**
+     * Return the length of the data.
+     * @return The length of the data.
+     * @throws IOException If an IO problem occurs
+     * @see package org.apache.axis2.transport.http.util.Part#lengthOfData()
+     */
+    protected long lengthOfData() throws IOException {
+        LOG.trace("enter lengthOfData()");
+        return getContent().length;
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.commons.httpclient.methods.multipart.BasePart#setCharSet(java.lang.String)
+     */
+    public void setCharSet(String charSet) {
+        super.setCharSet(charSet);
+        this.content = null;
+    }
+}
Index: modules/kernel/src/org/apache/axis2/transport/http/util/EncodingUtils.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/util/EncodingUtils.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/transport/http/util/EncodingUtils.java	(revision 0)
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.transport.http.util;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.UnsupportedEncodingException;
+
+public class EncodingUtils {
+    public static final String charSetName = "US-ASCII";
+    // this should not be initialized
+    private EncodingUtils() {
+    }
+
+    /**
+     * Converts the specified string to byte array of ASCII characters.
+     *
+     * @param data the string to be encoded
+     * @return The string as a byte array.
+     *
+     * @since 3.0
+     */
+    public static byte[] getAsciiBytes(final String data) {
+
+        if (data == null) {
+            throw new IllegalArgumentException("Parameter may not be null");
+        }
+
+        try {
+            return data.getBytes(charSetName);
+        } catch (UnsupportedEncodingException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Converts the specified string to a byte array.  If the charset is not supported the
+     * default system charset is used.
+     *
+     * @param data the string to be encoded
+     * @param charset the desired character encoding
+     * @return The resulting byte array.
+     *
+     * @since 3.0
+     */
+        /**
+     * Log object for this class.
+     */
+    private static final Log LOG = LogFactory.getLog(EncodingUtils.class);
+
+    public static byte[] getBytes(final String data, String charset) {
+
+        if (data == null) {
+            throw new IllegalArgumentException("data may not be null");
+        }
+
+        if (charset == null || charset.length() == 0) {
+            throw new IllegalArgumentException("charset may not be null or empty");
+        }
+
+        try {
+            return data.getBytes(charset);
+        } catch (UnsupportedEncodingException e) {
+
+            if (LOG.isWarnEnabled()) {
+                LOG.warn("Unsupported encoding: " + charset + ". System encoding used.");
+            }
+
+            return data.getBytes();
+        }
+    }
+}
Index: modules/kernel/src/org/apache/axis2/transport/http/util/AbstractContentBase.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/util/AbstractContentBase.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/transport/http/util/AbstractContentBase.java	(revision 0)
@@ -0,0 +1,88 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.transport.http.util;
+
+public abstract class AbstractContentBase extends AbstractContent {
+
+    /** Name of the file part. */
+    private String name;
+
+    /** Content type of the file part. */
+    private String contentType;
+
+    /** Content encoding of the file part. */
+    private String charSet;
+
+    /** The transfer encoding. */
+    private String transferEncoding;
+    /**
+     * Constructor.
+     *
+     * @param name The name of the part
+     * @param contentType The content type, or <code>null</code>
+     * @param charSet The character encoding, or <code>null</code>
+     * @param transferEncoding The transfer encoding, or <code>null</code>
+     */
+    public AbstractContentBase(String name, String contentType, String charSet, String transferEncoding) {
+
+        if (name == null) {
+            throw new IllegalArgumentException("Name must not be null");
+        }
+        this.name = name;
+        this.contentType = contentType;
+        this.charSet = charSet;
+        this.transferEncoding = transferEncoding;
+    }
+
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public String getContentType() {
+        return contentType;
+    }
+
+    public void setContentType(String contentType) {
+        this.contentType = contentType;
+    }
+
+    public String getCharSet() {
+        return charSet;
+    }
+
+    public void setCharSet(String charSet) {
+        this.charSet = charSet;
+    }
+
+    public String getTransferEncoding() {
+        return transferEncoding;
+    }
+
+    public void setTransferEncoding(String transferEncoding) {
+        this.transferEncoding = transferEncoding;
+    }
+}
+
+
+
Index: modules/kernel/src/org/apache/axis2/transport/http/util/AbstractContent.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/util/AbstractContent.java	(revision 0)
+++ modules/kernel/src/org/apache/axis2/transport/http/util/AbstractContent.java	(revision 0)
@@ -0,0 +1,372 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package org.apache.axis2.transport.http.util;
+
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+public abstract class AbstractContent {
+
+    /**
+     * Log object for this class.
+     */
+    private static final Log LOG = LogFactory.getLog(AbstractContent.class);
+    /**
+     * The boundary
+     * @deprecated use {@link org.apache.commons.httpclient.params.HttpMethodParams#MULTIPART_BOUNDARY}
+     */
+    protected static final String BOUNDARY = "----------------314159265358979323846";
+
+    /**
+     * The boundary as a byte array.
+     * @deprecated
+     */
+    protected static final byte[] BOUNDARY_BYTES = EncodingUtils.getAsciiBytes(BOUNDARY);
+
+    /**
+     * The default boundary to be used if {@link #setBoundaryBytes(byte[])) has not
+     * been called.
+     */
+    private static final byte[] DEFAULT_BOUNDARY_BYTES = BOUNDARY_BYTES;
+
+    /**
+     * The ASCII bytes to use as the multipart boundary.
+     */
+    private byte[] boundaryBytes;
+
+    /** Extra characters */
+    protected static final String EXTRA = "--";
+
+    /** Extra characters as a byte array */
+    protected static final byte[] EXTRA_BYTES =
+            EncodingUtils.getAsciiBytes(EXTRA);
+
+    /** Carriage return/linefeed */
+    protected static final String CRLF = "\r\n";
+
+    /** Carriage return/linefeed as a byte array */
+    protected static final byte[] CRLF_BYTES = EncodingUtils.getAsciiBytes(CRLF);
+
+
+    /** Content dispostion characters */
+    protected static final String QUOTE = "\"";
+
+    /** Content dispostion as a byte array */
+    protected static final byte[] QUOTE_BYTES =
+            EncodingUtils.getAsciiBytes(QUOTE);
+
+    /** Content dispostion characters */
+    protected static final String CONTENT_DISPOSITION = "Content-Disposition: form-data; name=";
+
+    /** Content dispostion as a byte array */
+    protected static final byte[] CONTENT_DISPOSITION_BYTES =
+            EncodingUtils.getAsciiBytes(CONTENT_DISPOSITION);
+
+    /** Content type header */
+    protected static final String CONTENT_TRANSFER_ENCODING = "Content-Transfer-Encoding: ";
+
+    /** Content type header as a byte array */
+    protected static final byte[] CONTENT_TRANSFER_ENCODING_BYTES =
+            EncodingUtils.getAsciiBytes(CONTENT_TRANSFER_ENCODING);
+
+    /** Content type header */
+    protected static final String CONTENT_TYPE = "Content-Type: ";
+
+    /** Content type header as a byte array */
+    protected static final byte[] CONTENT_TYPE_BYTES =
+            EncodingUtils.getAsciiBytes(CONTENT_TYPE);
+
+    /** Content charset */
+    protected static final String CHARSET = "; charset=";
+
+    /** Content charset as a byte array */
+    protected static final byte[] CHARSET_BYTES =
+            EncodingUtils.getAsciiBytes(CHARSET);
+
+
+
+    public static void sendAbstractContents(OutputStream out, AbstractContent[] abstractContents, byte[] partBoundary)
+            throws IOException {
+
+        if (abstractContents == null) {
+            throw new IllegalArgumentException("Parts may not be null");
+        }
+        if (partBoundary == null || partBoundary.length == 0) {
+            throw new IllegalArgumentException("partBoundary may not be empty");
+        }
+        for (int i = 0; i < abstractContents.length; i++) {
+            // set the part boundary before the part is sent
+            abstractContents[i].setPartBoundary(partBoundary);
+            abstractContents[i].send(out);
+        }
+        out.write(EXTRA_BYTES);
+        out.write(partBoundary);
+        out.write(EXTRA_BYTES);
+        out.write(CRLF_BYTES);
+    }
+
+    /**
+     * Sets the part boundary.  Only meant to be used by
+     * {@link AbstractContent#sendAbstractContents(OutputStream, AbstractContent[], byte[])}
+     * and {@link AbstractContent#getLengthOfParts(AbstractContent[], byte[])}
+     * @param boundaryBytes An array of ASCII bytes.
+     * @since 3.0
+     */
+    void setPartBoundary(byte[] boundaryBytes) {
+        this.boundaryBytes = boundaryBytes;
+    }
+
+    /**
+     * Write all the data to the output stream.
+     * If you override this method make sure to override
+     * #length() as well
+     *
+     * @param out The output stream
+     * @throws IOException If an IO problem occurs.
+     */
+    public void send(OutputStream out) throws IOException {
+        LOG.trace("enter send(OutputStream out)");
+        sendStart(out);
+        sendDispositionHeader(out);
+        sendContentTypeHeader(out);
+        sendTransferEncodingHeader(out);
+        sendEndOfHeader(out);
+        sendData(out);
+        sendEnd(out);
+    }
+
+    /**
+     * Write the start to the specified output stream
+     * @param out The output stream
+     * @throws IOException If an IO problem occurs.
+     */
+    protected void sendStart(OutputStream out) throws IOException {
+        LOG.trace("enter sendStart(OutputStream out)");
+        out.write(EXTRA_BYTES);
+        out.write(getPartBoundary());
+        out.write(CRLF_BYTES);
+    }
+
+    /**
+     * Write the content disposition header to the specified output stream
+     *
+     * @param out The output stream
+     * @throws IOException If an IO problem occurs.
+     */
+    protected void sendDispositionHeader(OutputStream out) throws IOException {
+        LOG.trace("enter sendDispositionHeader(OutputStream out)");
+        out.write(CONTENT_DISPOSITION_BYTES);
+        out.write(QUOTE_BYTES);
+        out.write(EncodingUtils.getAsciiBytes(getName()));
+        out.write(QUOTE_BYTES);
+    }
+
+    /**
+     * Write the content type header to the specified output stream
+     * @param out The output stream
+     * @throws IOException If an IO problem occurs.
+     */
+    protected void sendContentTypeHeader(OutputStream out) throws IOException {
+        LOG.trace("enter sendContentTypeHeader(OutputStream out)");
+        String contentType = getContentType();
+        if (contentType != null) {
+            out.write(CRLF_BYTES);
+            out.write(CONTENT_TYPE_BYTES);
+            out.write(EncodingUtils.getAsciiBytes(contentType));
+            String charSet = getCharSet();
+            if (charSet != null) {
+                out.write(CHARSET_BYTES);
+                out.write(EncodingUtils.getAsciiBytes(charSet));
+            }
+        }
+    }
+
+    /**
+     * Write the content transfer encoding header to the specified
+     * output stream
+     *
+     * @param out The output stream
+     * @throws IOException If an IO problem occurs.
+     */
+    protected void sendTransferEncodingHeader(OutputStream out) throws IOException {
+        LOG.trace("enter sendTransferEncodingHeader(OutputStream out)");
+        String transferEncoding = getTransferEncoding();
+        if (transferEncoding != null) {
+            out.write(CRLF_BYTES);
+            out.write(CONTENT_TRANSFER_ENCODING_BYTES);
+            out.write(EncodingUtils.getAsciiBytes(transferEncoding));
+        }
+    }
+
+    /**
+     * Write the end of the header to the output stream
+     * @param out The output stream
+     * @throws IOException If an IO problem occurs.
+     */
+    protected void sendEndOfHeader(OutputStream out) throws IOException {
+        LOG.trace("enter sendEndOfHeader(OutputStream out)");
+        out.write(CRLF_BYTES);
+        out.write(CRLF_BYTES);
+    }
+
+
+
+    /**
+     * Write the end data to the output stream.
+     * @param out The output stream
+     * @throws IOException If an IO problem occurs.
+     */
+    protected void sendEnd(OutputStream out) throws IOException {
+        LOG.trace("enter sendEnd(OutputStream out)");
+        out.write(CRLF_BYTES);
+    }
+
+    /**
+     * Gets the part boundary to be used.
+     * @return the part boundary as an array of bytes.
+     *
+     * @since 3.0
+     */
+    protected byte[] getPartBoundary() {
+        if (boundaryBytes == null) {
+            // custom boundary bytes have not been set, use the default.
+            return DEFAULT_BOUNDARY_BYTES;
+        } else {
+            return boundaryBytes;
+        }
+    }
+
+    /**
+     * Return the name of this part.
+     * @return The name.
+     */
+    public abstract String getName();
+
+    /**
+     * Returns the content type of this part.
+     * @return the content type, or <code>null</code> to exclude the content type header
+     */
+    public abstract String getContentType();
+
+    /**
+     * Return the character encoding of this part.
+     * @return the character encoding, or <code>null</code> to exclude the character
+     * encoding header
+     */
+    public abstract String getCharSet();
+
+    /**
+     * Return the transfer encoding of this part.
+     * @return the transfer encoding, or <code>null</code> to exclude the transfer encoding header
+     */
+    public abstract String getTransferEncoding();
+
+    /**
+     * Write the data to the specified output stream
+     * @param out The output stream
+     * @throws IOException If an IO problem occurs.
+     */
+    protected abstract void sendData(OutputStream out) throws IOException;
+
+    /**
+     * Return the length of the main content
+     *
+     * @return long The length.
+     * @throws IOException If an IO problem occurs
+     */
+    protected abstract long lengthOfData() throws IOException;
+
+
+    /**
+     * Return the total sum of all parts and that of the last boundary
+     *
+     * @param abstractContents The parts.
+     * @return The total length
+     *
+     * @throws IOException If an I/O error occurs while writing the parts.
+     */
+    public static long getLengthOfParts(AbstractContent[] abstractContents)
+            throws IOException {
+        return getLengthOfParts(abstractContents, DEFAULT_BOUNDARY_BYTES);
+    }
+
+    /**
+     * Gets the length of the multipart message including the given parts.
+     *
+     * @param abstractContents The parts.
+     * @param partBoundary The ASCII bytes to use as the part boundary.
+     * @return The total length
+     *
+     * @throws IOException If an I/O error occurs while writing the parts.
+     *
+     * @since 3.0
+     */
+    public static long getLengthOfParts(AbstractContent[] abstractContents, byte[] partBoundary) throws IOException {
+        LOG.trace("getLengthOfParts(Parts[])");
+        if (abstractContents == null) {
+            throw new IllegalArgumentException("Parts may not be null");
+        }
+        long total = 0;
+        for (int i = 0; i < abstractContents.length; i++) {
+            // set the part boundary before we calculate the part's length
+            abstractContents[i].setPartBoundary(partBoundary);
+            long l = abstractContents[i].length();
+            if (l < 0) {
+                return -1;
+            }
+            total += l;
+        }
+        total += EXTRA_BYTES.length;
+        total += partBoundary.length;
+        total += EXTRA_BYTES.length;
+        total += CRLF_BYTES.length;
+        return total;
+    }
+
+    /**
+     * Return the full length of all the data.
+     * If you override this method make sure to override
+     * #send(OutputStream) as well
+     *
+     * @return long The length.
+     * @throws IOException If an IO problem occurs
+     */
+    public long length() throws IOException {
+        LOG.trace("enter length()");
+        if (lengthOfData() < 0) {
+            return -1;
+        }
+        ByteArrayOutputStream overhead = new ByteArrayOutputStream();
+        sendStart(overhead);
+        sendDispositionHeader(overhead);
+        sendContentTypeHeader(overhead);
+        sendTransferEncodingHeader(overhead);
+        sendEndOfHeader(overhead);
+        sendEnd(overhead);
+        return overhead.size() + lengthOfData();
+    }
+
+}
Index: modules/kernel/src/org/apache/axis2/transport/http/util/ComplexPart.java
===================================================================
--- modules/kernel/src/org/apache/axis2/transport/http/util/ComplexPart.java	(revision 1179619)
+++ modules/kernel/src/org/apache/axis2/transport/http/util/ComplexPart.java	(working copy)
@@ -19,13 +19,11 @@
 
 package org.apache.axis2.transport.http.util;
 
-import org.apache.commons.httpclient.methods.multipart.PartBase;
-import org.apache.commons.httpclient.util.EncodingUtil;
 
 import java.io.IOException;
 import java.io.OutputStream;
 
-public class ComplexPart extends PartBase {
+public class ComplexPart extends AbstractContentBase {
 
     /**
      * Default content encoding of string parameters.
@@ -96,7 +94,7 @@
      */
     private byte[] getContent() {
         if (content == null) {
-            content = EncodingUtil.getBytes(value, getCharSet());
+            content = EncodingUtils.getBytes(value, getCharSet());
         }
         return content;
     }
@@ -116,7 +114,6 @@
      *
      * @return The length of the data.
      * @throws IOException If an IO problem occurs
-     * @see org.apache.commons.httpclient.methods.multipart.Part#lengthOfData()
      */
     protected long lengthOfData() throws IOException {
         return getContent().length;
Index: modules/kernel/src/org/apache/axis2/client/Stub.java
===================================================================
--- modules/kernel/src/org/apache/axis2/client/Stub.java	(revision 1179619)
+++ modules/kernel/src/org/apache/axis2/client/Stub.java	(working copy)
@@ -20,28 +20,18 @@
 
 package org.apache.axis2.client;
 
-import org.apache.axiom.om.OMAbstractFactory;
-import org.apache.axiom.om.OMAttribute;
-import org.apache.axiom.om.OMElement;
-import org.apache.axiom.om.OMFactory;
-import org.apache.axiom.om.OMNamespace;
-import org.apache.axiom.om.OMNode;
-import org.apache.axiom.soap.SOAP11Constants;
-import org.apache.axiom.soap.SOAP12Constants;
-import org.apache.axiom.soap.SOAPEnvelope;
-import org.apache.axiom.soap.SOAPFactory;
-import org.apache.axiom.soap.SOAPHeaderBlock;
-import org.apache.axiom.soap.SOAPProcessingException;
+import org.apache.axiom.om.*;
+import org.apache.axiom.soap.*;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.NamedValue;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.OutInAxisOperation;
 import org.apache.axis2.description.OutOnlyAxisOperation;
 import org.apache.axis2.description.RobustOutOnlyAxisOperation;
 import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.transport.http.HTTPConstants;
-import org.apache.commons.httpclient.Header;
 
 import java.util.ArrayList;
 import java.util.Iterator;
@@ -160,10 +150,8 @@
             headersObj = new java.util.ArrayList();
         }
         java.util.List headers = (java.util.List) headersObj;
-        Header header = new Header();
-        header.setName(name);
-        header.setValue(value);
-        headers.add(header);
+        NamedValue nameValue = new NamedValue(name , value);
+        headers.add(nameValue);
         messageContext.setProperty(HTTPConstants.HTTP_HEADERS, headers);
     }
 
Index: modules/kernel/pom.xml
===================================================================
--- modules/kernel/pom.xml	(revision 1179619)
+++ modules/kernel/pom.xml	(working copy)
@@ -53,10 +53,6 @@
             <artifactId>servlet-api</artifactId>
         </dependency>
         <dependency>
-            <groupId>commons-httpclient</groupId>
-            <artifactId>commons-httpclient</artifactId>
-        </dependency>
-        <dependency>
             <groupId>commons-fileupload</groupId>
             <artifactId>commons-fileupload</artifactId>
         </dependency>
Index: modules/transport/http/src/org/apache/axis2/transport/http/AbstractHTTPSender.java
===================================================================
--- modules/transport/http/src/org/apache/axis2/transport/http/AbstractHTTPSender.java	(revision 1179619)
+++ modules/transport/http/src/org/apache/axis2/transport/http/AbstractHTTPSender.java	(working copy)
@@ -24,35 +24,20 @@
 import org.apache.axiom.om.OMOutputFormat;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
+import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.NamedValue;
 import org.apache.axis2.context.OperationContext;
-import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.description.TransportOutDescription;
 import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.transport.MessageFormatter;
 import org.apache.axis2.transport.TransportUtils;
 import org.apache.axis2.transport.http.util.HTTPProxyConfigurationUtil;
-import org.apache.axis2.util.JavaUtils;
 import org.apache.axis2.wsdl.WSDLConstants;
-import org.apache.commons.httpclient.Credentials;
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HeaderElement;
-import org.apache.commons.httpclient.HostConfiguration;
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.HttpConnectionManager;
-import org.apache.commons.httpclient.HttpMethod;
-import org.apache.commons.httpclient.HttpMethodBase;
-import org.apache.commons.httpclient.HttpState;
-import org.apache.commons.httpclient.HttpVersion;
-import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;
-import org.apache.commons.httpclient.NTCredentials;
-import org.apache.commons.httpclient.NameValuePair;
-import org.apache.commons.httpclient.UsernamePasswordCredentials;
+import org.apache.commons.httpclient.*;
 import org.apache.commons.httpclient.auth.AuthPolicy;
 import org.apache.commons.httpclient.auth.AuthScope;
 import org.apache.commons.httpclient.params.HttpMethodParams;
-import org.apache.commons.httpclient.params.HttpConnectionManagerParams;
-import org.apache.commons.httpclient.params.HttpClientParams;
 import org.apache.commons.httpclient.protocol.Protocol;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -63,8 +48,6 @@
 import java.io.InputStream;
 import java.net.URL;
 import java.util.*;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
 import java.util.zip.GZIPInputStream;
 
 public abstract class AbstractHTTPSender {
@@ -627,15 +610,17 @@
         // set the custom headers, if available
         Object httpHeadersObj = msgContext.getProperty(HTTPConstants.HTTP_HEADERS);
         if (httpHeadersObj != null) {
-            if (httpHeadersObj instanceof ArrayList) {
-                ArrayList httpHeaders = (ArrayList) httpHeadersObj;
-                Header header;
+            if (httpHeadersObj instanceof List) {
+                List httpHeaders = (List) httpHeadersObj;
                 for (int i = 0; i < httpHeaders.size(); i++) {
-                    header = (Header) httpHeaders.get(i);
-                    if (HTTPConstants.HEADER_USER_AGENT.equals(header.getName())) {
-                        isCustomUserAgentSet = true;
+                    NamedValue nv = (NamedValue) httpHeaders.get(i);
+                    if (nv != null) {
+                        Header header = new Header(nv.getName(), nv.getValue());
+                        if (HTTPConstants.HEADER_USER_AGENT.equals(header.getName())) {
+                            isCustomUserAgentSet = true;
+                        }
+                        method.addRequestHeader(header);
                     }
-                    method.addRequestHeader(header);
                 }
     
             }
Index: modules/transport/http/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java
===================================================================
--- modules/transport/http/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java	(revision 1179619)
+++ modules/transport/http/src/org/apache/axis2/transport/http/CommonsHTTPTransportSender.java	(working copy)
@@ -25,6 +25,7 @@
 import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.NamedValue;
 import org.apache.axis2.description.Parameter;
 import org.apache.axis2.description.TransportOutDescription;
 import org.apache.axis2.handlers.AbstractHandler;
@@ -34,14 +35,13 @@
 import org.apache.axis2.transport.TransportUtils;
 import org.apache.axis2.transport.http.server.AxisHttpResponseImpl;
 import org.apache.axis2.util.JavaUtils;
-import org.apache.commons.httpclient.Header;
 import org.apache.commons.httpclient.HttpException;
 import org.apache.commons.httpclient.HttpMethod;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
+import javax.servlet.http.HttpServletResponse;
 import javax.xml.stream.FactoryConfigurationError;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.net.MalformedURLException;
@@ -292,10 +292,10 @@
                 if (customHeaders instanceof List) {
                     Iterator iter = ((List) customHeaders).iterator();
                     while (iter.hasNext()) {
-                        Header header = (Header) iter.next();
-                        if (header != null) {
+                        NamedValue nv = (NamedValue) iter.next();
+                        if (nv != null) {
                             servletBasedOutTransportInfo
-                                    .addHeader(header.getName(), header.getValue());
+                                    .addHeader(nv.getName(), nv.getValue());
                         }
                     }
                 } else if (customHeaders instanceof Map) {
@@ -315,19 +315,19 @@
                 if (customHeaders instanceof List) {
                     Iterator iter = ((List) customHeaders).iterator();
                     while (iter.hasNext()) {
-                        Header header = (Header) iter.next();
-                        if (header != null) {
+                        NamedValue nv = (NamedValue) iter.next();
+                        if (nv != null) {
                             ((AxisHttpResponseImpl) transportInfo)
-                                    .addHeader(header.getName(), header.getValue());
+                                    .addHeader(nv.getName(), nv.getValue());
                         }
                     }
                 } else if (customHeaders instanceof Map) {
                     Iterator iter = ((Map) customHeaders).entrySet().iterator();
                     while (iter.hasNext()) {
-                        Map.Entry header = (Map.Entry) iter.next();
-                        if (header != null) {
+                        Map.Entry nameValue = (Map.Entry) iter.next();
+                        if (nameValue != null) {
                             ((AxisHttpResponseImpl) transportInfo)
-                                    .addHeader((String) header.getKey(), (String) header.getValue());
+                                    .addHeader((String) nameValue.getKey(), (String) nameValue.getValue());
                         }
                     }
                 }
Index: modules/transport/http/pom.xml
===================================================================
--- modules/transport/http/pom.xml	(revision 1179619)
+++ modules/transport/http/pom.xml	(working copy)
@@ -110,5 +110,9 @@
             <artifactId>jetty</artifactId>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>commons-httpclient</groupId>
+            <artifactId>commons-httpclient</artifactId>
+        </dependency>
     </dependencies>
 </project>
