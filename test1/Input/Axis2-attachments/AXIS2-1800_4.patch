Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/AnnotationBuilder.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/AnnotationBuilder.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/AnnotationBuilder.java	(revision 0)
@@ -0,0 +1,315 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.runtime.description.marshal.impl;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Method;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+
+import javax.wsdl.Definition;
+import javax.wsdl.WSDLException;
+import javax.xml.bind.JAXBElement;
+
+import org.apache.axis2.java.security.AccessController;
+import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.description.EndpointDescription;
+import org.apache.axis2.jaxws.description.EndpointDescriptionJava;
+import org.apache.axis2.jaxws.description.EndpointInterfaceDescription;
+import org.apache.axis2.jaxws.description.FaultDescription;
+import org.apache.axis2.jaxws.description.OperationDescription;
+import org.apache.axis2.jaxws.description.ParameterDescription;
+import org.apache.axis2.jaxws.description.ServiceDescription;
+import org.apache.axis2.jaxws.description.ServiceDescriptionWSDL;
+import org.apache.axis2.jaxws.runtime.description.marshal.AnnotationDesc;
+import org.apache.axis2.jaxws.util.WSDL4JWrapper;
+import org.apache.axis2.jaxws.util.WSDLWrapper;
+import org.apache.axis2.jaxws.utility.ClassUtils;
+import org.apache.axis2.jaxws.utility.JavaUtils;
+import org.apache.axis2.jaxws.utility.XMLRootElementUtil;
+import org.apache.axis2.jaxws.wsdl.SchemaReader;
+import org.apache.axis2.jaxws.wsdl.SchemaReaderException;
+import org.apache.axis2.jaxws.wsdl.impl.SchemaReaderImpl;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * Walks the ServiceDescription and its child *Description classes
+ * to find all of the types.  An AnnotationDesc is built for each of the types
+ */
+/**
+ * @author scheu
+ *
+ */
+public class AnnotationBuilder {
+    
+    private static Log log = LogFactory.getLog(AnnotationBuilder.class);
+    
+
+    /**
+     * This is a static utility class.  The constructor is intentionally private
+     */
+    private AnnotationBuilder() {
+    }
+    
+   
+    
+    /**
+     * @param serviceDescription ServiceDescription
+     * @return AnnotationDesc Map
+     */
+    public static Map<String, AnnotationDesc> getAnnotationDescs(ServiceDescription serviceDesc) {
+        Map<String, AnnotationDesc> map = new HashMap<String, AnnotationDesc>();
+        EndpointDescription[] endpointDescs = serviceDesc.getEndpointDescriptions();
+        
+        // Build a set of packages from all of the endpoints
+        if (endpointDescs != null) {
+            for (int i=0; i< endpointDescs.length; i++) {
+                getAnnotationDescs(endpointDescs[i], map);
+            }
+        }
+        return map;
+    }
+    
+    
+    /**
+     * @param endpointDesc
+     * @param map
+     */
+    private static void getAnnotationDescs(EndpointDescription endpointDesc, Map<String, AnnotationDesc> map) {
+        EndpointInterfaceDescription endpointInterfaceDesc = 
+            endpointDesc.getEndpointInterfaceDescription();
+        if (endpointInterfaceDesc != null) {
+            getAnnotationDescs(endpointInterfaceDesc, map);
+        }
+    }
+    
+   
+    /**
+     * @param endpointInterfaceDesc
+     * @param map
+     */
+    private static void getAnnotationDescs(EndpointInterfaceDescription endpointInterfaceDesc, Map<String, AnnotationDesc> map) {
+        OperationDescription[] opDescs = endpointInterfaceDesc.getOperations();
+        
+        // Build a set of packages from all of the opertions
+        if (opDescs != null) {
+            for (int i=0; i< opDescs.length; i++) {
+                getAnnotationDescs(opDescs[i], map);
+            }
+        }
+    }
+    
+    
+    
+    /**
+     * Get annotations for this operation
+     * @param opDesc
+     * @param map
+     */
+    private static void getAnnotationDescs(OperationDescription opDesc, Map<String, AnnotationDesc> map) {
+       
+       // Walk the parameter information
+       ParameterDescription[] parameterDescs = opDesc.getParameterDescriptions();
+       if (parameterDescs != null) {
+           for (int i=0; i <parameterDescs.length; i++) {
+               getAnnotationDescs(parameterDescs[i], map);
+           }
+       }
+       
+       // Walk the fault information
+       FaultDescription[] faultDescs = opDesc.getFaultDescriptions();
+       if (faultDescs != null) {
+           for (int i=0; i <faultDescs.length; i++) {
+               getAnnotationDescs(faultDescs[i], map);
+           }
+       }
+       
+       // Also consider the request and response wrappers
+       addAnnotation(opDesc.getRequestWrapperClassName(), map);
+       addAnnotation(opDesc.getResponseWrapperClassName(), map);
+       
+       
+       // Finally consider the result type
+       Class cls = opDesc.getResultActualType();
+       if (cls != null && cls != void.class && cls != Void.class) {
+           addAnnotation(cls, map);
+       }
+    }
+    
+    
+    private static void getAnnotationDescs(ParameterDescription paramDesc, Map<String, AnnotationDesc> map) {
+       
+       // Get the type that defines the actual data.  (this is never a holder )
+       Class paramClass = paramDesc.getParameterActualType();
+       
+       if (paramClass != null) {
+           getTypeAnnotationDescs(paramClass, map);
+       }
+       
+    }
+    
+    /**
+     * Update the package set with the packages referenced by this FaultDescription
+     * @param faultDesc FaultDescription
+     * @param set Set<Package> that is updated
+     */
+    private static void getAnnotationDescs(FaultDescription faultDesc, Map<String, AnnotationDesc> map) {
+      
+      Class faultBean = loadClass(faultDesc.getFaultBean());  
+      if (faultBean != null) {
+          getTypeAnnotationDescs(faultBean, map);
+      }
+    }
+    
+    private final static Class[] noClass = new Class[] {};
+    
+    /**
+     * Get the annotations for this type
+     * @param cls
+     */
+    private static void getTypeAnnotationDescs(Class cls, Map<String, AnnotationDesc> map) {
+        
+        if (JAXBElement.class.isAssignableFrom(cls)) {
+            try {
+                Method m = cls.getMethod("getValue", noClass);
+                Class cls2 = m.getReturnType();
+                addAnnotation(cls2, map);
+                
+            } catch (Exception e) {
+                // We should never get here
+                if (log.isDebugEnabled()) {
+                    log.debug("Cannot find JAXBElement.getValue method.");
+                }
+            }
+        } else {
+            addAnnotation(cls, map);
+        }
+    }
+    
+    private static void addAnnotation(String className, Map<String, AnnotationDesc> map) {
+        
+        if (map.get(className) == null) {
+            Class clz = loadClass(className);
+            if (clz != null) {
+                addAnnotation(clz, map);
+            }
+        }
+    }
+    
+    private static void addAnnotation(Class cls, Map<String, AnnotationDesc> map) {
+        
+        String className = cls.getCanonicalName();
+        if (map.get(className) == null) {
+            AnnotationDesc desc = AnnotationDescImpl.create(cls);
+            map.put(className, desc);
+            if (cls.isPrimitive()) {
+                Class class2 = ClassUtils.getWrapperClass(cls);
+                AnnotationDesc desc2 = AnnotationDescImpl.create(class2);
+                map.put(class2.getCanonicalName(), desc2);
+            } else {
+                Class class2 = ClassUtils.getPrimitiveClass(cls);
+                if (class2 != null) {
+                    AnnotationDesc desc2 = AnnotationDescImpl.create(class2);
+                    map.put(class2.getCanonicalName(), desc2);
+                }
+            }
+        }
+    }
+    
+    /**
+     * Loads the class 
+     * @param className
+     * @return Class (or null if the class cannot be loaded)
+     */
+    private static Class loadClass(String className) {
+        // Don't make this public, its a security exposure
+        if (className == null || className.length() == 0) {
+            return null;
+        }
+        try {
+            
+            return forName(className, true, 
+                   getContextClassLoader());
+	        //Catch Throwable as ClassLoader can throw an NoClassDefFoundError that
+	        //does not extend Exception, so lets catch everything that extends Throwable
+            //rather than just Exception.
+        } catch (Throwable e) {
+            // TODO Should the exception be swallowed ?
+            if (log.isDebugEnabled()) {
+                log.debug("PackageSetBuilder cannot load the following class:" + className);
+            }
+        }
+        return null;
+    }
+   
+   /**
+    * Return the class for this name
+    * @return Class
+    */
+   static Class forName(final String className, final boolean initialize, final ClassLoader classloader) throws ClassNotFoundException {
+       // NOTE: This method must remain protected because it uses AccessController
+       Class cl = null;
+       try {
+           cl = (Class) AccessController.doPrivileged(
+                   new PrivilegedExceptionAction() {
+                       public Object run() throws ClassNotFoundException {
+                           return Class.forName(className, initialize, classloader);    
+                       }
+                   }
+                 );  
+       } catch (PrivilegedActionException e) {
+           if (log.isDebugEnabled()) {
+               log.debug("Exception thrown from AccessController: " + e);
+           }
+           throw (ClassNotFoundException) e.getException();
+       } 
+       
+       return cl;
+   }
+   
+   /**
+    * @return ClassLoader
+    */
+   static ClassLoader getContextClassLoader() {
+       // NOTE: This method must remain private because it uses AccessController
+       ClassLoader cl = null;
+       try {
+           cl = (ClassLoader) AccessController.doPrivileged(
+                   new PrivilegedExceptionAction() {
+                       public Object run() throws ClassNotFoundException {
+                           return Thread.currentThread().getContextClassLoader();      
+                       }
+                   }
+                 );  
+       } catch (PrivilegedActionException e) {
+           if (log.isDebugEnabled()) {
+               log.debug("Exception thrown from AccessController: " + e);
+           }
+           throw (RuntimeException) e.getException();
+       }
+       
+       return cl;
+   }
+}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/MarshalServiceRuntimeDescriptionImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/MarshalServiceRuntimeDescriptionImpl.java	(revision 505734)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/MarshalServiceRuntimeDescriptionImpl.java	(working copy)
@@ -1,6 +1,7 @@
 package org.apache.axis2.jaxws.runtime.description.marshal.impl;
 
 import java.util.HashMap;
+import java.util.Map;
 import java.util.TreeSet;
 
 import org.apache.axis2.jaxws.description.ServiceDescription;
@@ -14,7 +15,7 @@
     private ServiceDescription serviceDesc;
     private String key; 
     private TreeSet<String> packages;
-    private HashMap<String, AnnotationDesc> annotationMap = new HashMap<String, AnnotationDesc>();
+    private Map<String, AnnotationDesc> annotationMap = null;
     
     protected MarshalServiceRuntimeDescriptionImpl(String key,
                 ServiceDescription serviceDesc) {
@@ -53,4 +54,8 @@
     }
     
     
+    void setAnnotationMap(Map<String, AnnotationDesc> map) {
+        this.annotationMap = map;
+    }
+    
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/MarshalServiceRuntimeDescriptionBuilder.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/MarshalServiceRuntimeDescriptionBuilder.java	(revision 505734)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/MarshalServiceRuntimeDescriptionBuilder.java	(working copy)
@@ -20,17 +20,23 @@
 import java.lang.reflect.Method;
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.TreeSet;
 
 import javax.annotation.Resource;
 
 import org.apache.axis2.java.security.AccessController;
 import org.apache.axis2.jaxws.description.ServiceDescription;
+import org.apache.axis2.jaxws.runtime.description.marshal.AnnotationDesc;
 import org.apache.axis2.jaxws.runtime.description.marshal.MarshalServiceRuntimeDescription;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 
 public class MarshalServiceRuntimeDescriptionBuilder {
 
+    private static Log log = LogFactory.getLog(MarshalServiceRuntimeDescriptionBuilder.class);
     /**
      * Intentionally Private
      */
@@ -59,8 +65,20 @@
      */
     static private void init(MarshalServiceRuntimeDescriptionImpl marshalDesc, 
             ServiceDescription serviceDesc) {
-        TreeSet<String> packages = new TreeSet<String>();
         
+        // Build the annotation map first
+        Map<String, AnnotationDesc> map;
+        try {
+           map = AnnotationBuilder.getAnnotationDescs(serviceDesc);
+        } catch(Throwable t) {
+            // Since we are caching, proceed without exception
+            if (log.isDebugEnabled()) {
+                log.debug("Swallowing Exception:" + t);
+            }
+            map = new HashMap<String, AnnotationDesc>();
+        }
+        marshalDesc.setAnnotationMap(map);
+            
         // @TODO There are two ways to get the packages.
         // Schema Walk (prefered) and Annotation Walk.
         // The Schema walk requires an existing or generated schema.
@@ -68,6 +86,7 @@
         // There are some limitations in the current schema walk
         // And there are problems in the annotation walk.
         // So for now we will do both.
+        TreeSet<String> packages = new TreeSet<String>();
         boolean doSchemaWalk = true;
         boolean doAnnotationWalk = true;
         packages = new TreeSet<String>();
@@ -75,7 +94,8 @@
             packages.addAll(PackageSetBuilder.getPackagesFromSchema(serviceDesc));
         }
         if (doAnnotationWalk) {
-            packages.addAll(PackageSetBuilder.getPackagesFromAnnotations(serviceDesc));
+            // Get the package names from the annotations.  Use the annotation map to reduce Annotation introspection
+            packages.addAll(PackageSetBuilder.getPackagesFromAnnotations(serviceDesc, map));
         }
         marshalDesc.setPackages(packages);
     }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/PackageSetBuilder.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/PackageSetBuilder.java	(revision 505734)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/PackageSetBuilder.java	(working copy)
@@ -23,6 +23,7 @@
 import java.net.URL;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
+import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
 
@@ -40,6 +41,7 @@
 import org.apache.axis2.jaxws.description.ParameterDescription;
 import org.apache.axis2.jaxws.description.ServiceDescription;
 import org.apache.axis2.jaxws.description.ServiceDescriptionWSDL;
+import org.apache.axis2.jaxws.runtime.description.marshal.AnnotationDesc;
 import org.apache.axis2.jaxws.util.WSDL4JWrapper;
 import org.apache.axis2.jaxws.util.WSDLWrapper;
 import org.apache.axis2.jaxws.utility.JavaUtils;
@@ -91,7 +93,7 @@
      * @return Set of Packages
      */
     public static TreeSet<String> getPackagesFromSchema(ServiceDescription serviceDesc) {
-    	boolean annotationWalking = true;
+
     	TreeSet<String> set = new TreeSet<String>();
     	//If we are on client side we will get wsdl definition from ServiceDescription. If we are on server side we will have to 
     	//read wsdlLocation from @WebService Annotation.
@@ -102,6 +104,8 @@
             for (int i=0; i< endpointDescs.length; i++) {
             	EndpointDescription ed = (EndpointDescription)endpointDescs[i];
             	if(wsdlDefinition == null){
+                    // TODO I don't think we should be trying to load the wsdlDefinition here.
+                    
             		//Let see if we can get wsdl definition from endpoint @WebService annotation.
                     if (ed instanceof EndpointDescriptionJava) {
                         String wsdlLocation = ((EndpointDescriptionJava) ed).getAnnoWebServiceWSDLLocation();
@@ -118,18 +122,7 @@
            			}catch(SchemaReaderException e){
            				ExceptionFactory.makeWebServiceException(e);
            			}
-           			//FIXME: For now lets read packages from Annotation too. We will remove this once we are confident that 
-           			//Schema Walk thru works.
-           			if(annotationWalking){
-           				set.addAll(getPackagesFromAnnotations(serviceDesc));
-           			}
-           		}
-           		//if on client side, there is no wsdl provided by client application. if on server side there is no WSDLLocation on @WebService. 
-           		//let read all the required package from SEI Annotation.
-           		else{
-           			set.addAll(getPackagesFromAnnotations(serviceDesc));
-           		}    
-              
+           		}  
             }
     	}
     	return set;
@@ -139,14 +132,14 @@
      * @param serviceDescription ServiceDescription
      * @return Set of Packages
      */
-    public static TreeSet<String> getPackagesFromAnnotations(ServiceDescription serviceDesc) {
+    public static TreeSet<String> getPackagesFromAnnotations(ServiceDescription serviceDesc, Map<String, AnnotationDesc> annotationMap) {
         TreeSet<String> set = new TreeSet<String>();
         EndpointDescription[] endpointDescs = serviceDesc.getEndpointDescriptions();
         
         // Build a set of packages from all of the endpoints
         if (endpointDescs != null) {
             for (int i=0; i< endpointDescs.length; i++) {
-                set.addAll(getPackagesFromAnnotations(endpointDescs[i]));
+                set.addAll(getPackagesFromAnnotations(endpointDescs[i], annotationMap));
             }
         }
         return set;
@@ -156,13 +149,14 @@
      * @param endpointDesc EndpointDescription
      * @return Set of Packages
      */
-    public static TreeSet<String> getPackagesFromAnnotations(EndpointDescription endpointDesc) {
+    private static TreeSet<String> getPackagesFromAnnotations(EndpointDescription endpointDesc, 
+            Map<String, AnnotationDesc> annotationMap) {
         EndpointInterfaceDescription endpointInterfaceDesc = 
             endpointDesc.getEndpointInterfaceDescription();
         if (endpointInterfaceDesc == null) {
             return new TreeSet<String>(); 
         } else {
-            return getPackagesFromAnnotations(endpointInterfaceDesc);
+            return getPackagesFromAnnotations(endpointInterfaceDesc, annotationMap);
         }
     }
     
@@ -170,14 +164,15 @@
      * @param endpointInterfaceDescription EndpointInterfaceDescription
      * @return Set of Packages
      */
-    public static TreeSet<String> getPackagesFromAnnotations(EndpointInterfaceDescription endpointInterfaceDesc) {
+    private static TreeSet<String> getPackagesFromAnnotations(EndpointInterfaceDescription endpointInterfaceDesc, 
+            Map<String, AnnotationDesc> annotationMap) {
         TreeSet<String> set = new TreeSet<String>();
         OperationDescription[] opDescs = endpointInterfaceDesc.getOperations();
         
         // Build a set of packages from all of the opertions
         if (opDescs != null) {
             for (int i=0; i< opDescs.length; i++) {
-                getPackagesFromAnnotations(opDescs[i], set);
+                getPackagesFromAnnotations(opDescs[i], set, annotationMap);
             }
         }
         return set;
@@ -188,13 +183,14 @@
      * @param opDesc OperationDescription
      * @param set Set<Package> that is updated
      */
-    private static void getPackagesFromAnnotations(OperationDescription opDesc, TreeSet<String> set) {
+    private static void getPackagesFromAnnotations(OperationDescription opDesc, TreeSet<String> set, 
+            Map<String, AnnotationDesc> annotationMap) {
        
        // Walk the parameter information
        ParameterDescription[] parameterDescs = opDesc.getParameterDescriptions();
        if (parameterDescs != null) {
            for (int i=0; i <parameterDescs.length; i++) {
-               getPackagesFromAnnotations(parameterDescs[i], set);
+               getPackagesFromAnnotations(parameterDescs[i], set, annotationMap);
            }
        }
        
@@ -202,7 +198,7 @@
        FaultDescription[] faultDescs = opDesc.getFaultDescriptions();
        if (faultDescs != null) {
            for (int i=0; i <faultDescs.length; i++) {
-               getPackagesFromAnnotations(faultDescs[i], set);
+               getPackagesFromAnnotations(faultDescs[i], set, annotationMap);
            }
        }
        
@@ -241,13 +237,14 @@
      * @param paramDesc ParameterDesc
      * @param set Set<Package> that is updated
      */
-    private static void getPackagesFromAnnotations(ParameterDescription paramDesc, TreeSet<String> set) {
+    private static void getPackagesFromAnnotations(ParameterDescription paramDesc, TreeSet<String> set, 
+            Map<String, AnnotationDesc> annotationMap) {
        
        // Get the type that defines the actual data.  (this is never a holder )
        Class paramClass = paramDesc.getParameterActualType();
        
        if (paramClass != null) {
-           setTypeAndElementPackages(paramClass, paramDesc.getTargetNamespace(), paramDesc.getPartName(), set);
+           setTypeAndElementPackages(paramClass, paramDesc.getTargetNamespace(), paramDesc.getPartName(), set, annotationMap);
        }
        
     }
@@ -257,11 +254,12 @@
      * @param faultDesc FaultDescription
      * @param set Set<Package> that is updated
      */
-    private static void getPackagesFromAnnotations(FaultDescription faultDesc, TreeSet<String> set) {
+    private static void getPackagesFromAnnotations(FaultDescription faultDesc, TreeSet<String> set, 
+            Map<String, AnnotationDesc> annotationMap) {
       
       Class faultBean = loadClass(faultDesc.getFaultBean());  
       if (faultBean != null) {
-          setTypeAndElementPackages(faultBean, faultDesc.getTargetNamespace(), faultDesc.getName(), set);
+          setTypeAndElementPackages(faultBean, faultDesc.getTargetNamespace(), faultDesc.getName(), set, annotationMap);
       }
     }
     
@@ -272,10 +270,11 @@
      * @param localPart of the element
      * @param set with both type and element packages set
      */
-    private static void setTypeAndElementPackages(Class cls, String namespace, String localPart, TreeSet<String> set) {
+    private static void setTypeAndElementPackages(Class cls, String namespace, String localPart, TreeSet<String> set, 
+            Map<String, AnnotationDesc> annotationMap) {
         
         // Get the element and type classes
-        Class eClass = getElement(cls);
+        Class eClass = getElement(cls, annotationMap);
         Class tClass = getType(cls);
         
         // Set the package for the type
@@ -318,11 +317,16 @@
      * @param cls Class
      * @return Class or null
      */
-    private static Class getElement(Class cls) {
-        if (XMLRootElementUtil.getXmlRootElementQName(cls) == null) {
-            return null;
+    private static Class getElement(Class cls, Map<String, AnnotationDesc> annotationMap) {
+        AnnotationDesc annotationDesc = annotationMap.get(cls.getCanonicalName());
+        if (annotationDesc == null) {
+            // This shouldn't happen
+            annotationDesc = AnnotationDescImpl.create(cls);
+        }
+        if (annotationDesc.hasXmlRootElement()) {
+            return cls;
         } 
-        return cls;
+        return null;
     }
     
     private final static Class[] noClass = new Class[] {};
