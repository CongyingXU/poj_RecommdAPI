Index: C:/workspace/live/axis2/modules/metadata/src/org/apache/axis2/jaxws/description/impl/OperationDescriptionImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/metadata/src/org/apache/axis2/jaxws/description/impl/OperationDescriptionImpl.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/metadata/src/org/apache/axis2/jaxws/description/impl/OperationDescriptionImpl.java	(working copy)
@@ -31,8 +31,8 @@
 
 import javax.jws.Oneway;
 import javax.jws.WebMethod;
+import javax.jws.WebResult;
 import javax.jws.WebParam.Mode;
-import javax.jws.WebResult;
 import javax.jws.soap.SOAPBinding;
 import javax.xml.namespace.QName;
 import javax.xml.ws.AsyncHandler;
@@ -44,7 +44,6 @@
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisOperationFactory;
-import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.description.EndpointDescriptionJava;
 import org.apache.axis2.jaxws.description.EndpointInterfaceDescription;
 import org.apache.axis2.jaxws.description.FaultDescription;
@@ -1480,6 +1479,12 @@
             string.append("No Fault Descriptions");
         }
 
+        string.append("RuntimeDescriptions:" +this.runtimeDescMap.size());
+        string.append(newline);
+        for (OperationRuntimeDescription runtimeDesc:runtimeDescMap.values()) {
+            string.append(runtimeDesc.toString());
+            string.append(newline);
+        }
         return string.toString();
     }
 }
Index: C:/workspace/live/axis2/modules/metadata/src/org/apache/axis2/jaxws/description/impl/ServiceDescriptionImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/metadata/src/org/apache/axis2/jaxws/description/impl/ServiceDescriptionImpl.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/metadata/src/org/apache/axis2/jaxws/description/impl/ServiceDescriptionImpl.java	(working copy)
@@ -1224,7 +1224,12 @@
                 string.append(newline);
             }
         }
-
+        string.append("RuntimeDescriptions:" +this.runtimeDescMap.size());
+        string.append(newline);
+        for (ServiceRuntimeDescription runtimeDesc:runtimeDescMap.values()) {
+            string.append(runtimeDesc.toString());
+            string.append(newline);
+        }
         return string.toString();
         
     }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/PropertyInfo.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/PropertyInfo.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/PropertyInfo.java	(working copy)
@@ -1,229 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.axis2.jaxws.wrapper;
-
-import java.beans.IndexedPropertyDescriptor;
-import java.beans.PropertyDescriptor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.Collection;
-
-import org.apache.axis2.jaxws.ExceptionFactory;
-import org.apache.axis2.jaxws.i18n.Messages;
-import org.apache.axis2.jaxws.utility.ConvertUtils;
-import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-/**
- * A PropertyInfo is constructed with a PropertyDescriptor and
- * exposes get/set methods to access the object on a bean that matches the PropertyDescriptor
- *
- */
-public class PropertyInfo {
-	PropertyDescriptor descriptor;
-    Class propertyType = null;
-    String propertyName = null;
-	private static Log log = LogFactory.getLog(PropertyInfo.class);
-	/**
-	 * @param propertyName
-	 * @param descriptor
-	 */
-	public PropertyInfo(PropertyDescriptor descriptor) {
-		super();
-		this.descriptor = descriptor;
-	}
-	
-    /**
-     * @return property type
-     */
-    public Class getPropertyType() {
-        // Get once and remember so that we can avoid syncronization penalties
-        if (propertyType == null) {
-            propertyType = descriptor.getPropertyType();
-        }
-        return propertyType;
-    }
-    
-    /**
-     * @return property name
-     */
-    public String getPropertyName() {
-        // Get once and remember so that we can avoid syncronization penalties
-        if (propertyName == null) {
-            propertyName = descriptor.getName();
-        }
-        return propertyName;
-    }
-	
-	/**
-     * Get the object 
-	 * @param targetBean
-	 * @return Object for this property or null
-	 * @throws InvocationTargetException
-	 * @throws IllegalAccessException
-	 */
-	public Object get(Object targetBean)throws InvocationTargetException, IllegalAccessException{
-		Method method = descriptor.getReadMethod();
-		return method.invoke(targetBean, null);
-	}
-	
-	/** 
-     * Set the object
-	 * @param targetBean
-	 * @param propValue
-	 * @throws InvocationTargetException
-	 * @throws IllegalAccessException
-	 * @throws JAXBWrapperException
-	 */
-	public void set(Object targetBean, Object propValue) throws InvocationTargetException, IllegalAccessException, JAXBWrapperException{
-        
-        // No set occurs if the value is null
-        if (propValue == null) {
-            return;
-        }
-            
-        // There are 3 different types of setters that can occur.
-        // 1) Normal Attomic Setter : setFoo(type)
-        // 2) Indexed Array Setter : setFoo(type[])
-        // 3) No Setter case if the property is a List<T>.
-        
-        Method writeMethod = descriptor.getWriteMethod();
-        if (descriptor instanceof IndexedPropertyDescriptor) {
-            // Set for indexed  T[]
-            setIndexedArray(targetBean, propValue, writeMethod);
-        } else if (writeMethod == null) {
-            // Set for List<T>
-            setList(targetBean, propValue);
-        } else {
-            // Normal case
-            setAtomic(targetBean, propValue, writeMethod);
-        }
-    }
-    
-    /**
-     * Set the property value onto targetBean using the writeMethod
-     * @param targetBean
-     * @param propValue
-     * @param writeMethod (set(T))
-     * @throws InvocationTargetException
-     * @throws IllegalAccessException
-     * @throws JAXBWrapperException
-     */
-    private void setAtomic(Object targetBean, Object propValue, Method writeMethod) 
-        throws InvocationTargetException, IllegalAccessException, JAXBWrapperException {
-        // JAXB provides setters for atomic value.
-        Object[] object = new Object[]{propValue};
-        Class[] paramTypes = writeMethod.getParameterTypes();
-        if(paramTypes !=null && paramTypes.length ==1){
-            Class paramType = paramTypes[0];
-            if(paramType.isPrimitive() && propValue == null){
-                //Ignoring null value for primitive type, this could potentially be the way of a customer indicating to set
-                //default values defined in JAXBObject/xmlSchema.
-                if(log.isDebugEnabled()){
-                    log.debug("Ignoring null value for primitive type, this is the way to set default values defined in JAXBObject/xmlSchema. for primitive types");
-                }
-                return;
-            }
-        }
-        writeMethod.invoke(targetBean, object);
-    }
-    
-    /**
-     * Set the property value using the indexed array setter
-     * @param targetBean
-     * @param propValue
-     * @param writeMethod set(T[])
-     * @throws InvocationTargetException
-     * @throws IllegalAccessException
-     * @throws JAXBWrapperException
-     */
-    private void setIndexedArray(Object targetBean, Object propValue, Method writeMethod) 
-        throws InvocationTargetException, IllegalAccessException, JAXBWrapperException {
-        
-        Class paramType = writeMethod.getParameterTypes()[0];
-        Object value = asArray(propValue, paramType);
-        // JAXB provides setters for atomic value.
-        Object[] object = new Object[]{value};
-        
-        writeMethod.invoke(targetBean, value);
-    }
-    /**
-     * Set the property value for the collection case.
-     * @param targetBean
-     * @param propValue
-     * @throws InvocationTargetException
-     * @throws IllegalAccessException
-     * @throws JAXBWrapperException
-     */
-    private void setList(Object targetBean, Object propValue) throws InvocationTargetException, IllegalAccessException, JAXBWrapperException {
-        // For the List<T> case, there is no setter. 
-        // You are supposed to use the getter to obtain access to the collection and then add the collection
-        
-        Collection value = asCollection(propValue, descriptor.getPropertyType());
-        Collection collection = (Collection) get(targetBean);
-        
-        // Now add our our object to the collection
-        collection.clear();
-        if (propValue != null) {
-            collection.addAll(value);
-        }
-    }
-            
-    /**
-     * @param propValue
-     * @param destType
-     * @return propValue as a Collection
-     */
-    private static Collection asCollection(Object propValue, Class destType) {
-        // TODO Missing function
-        // Convert the object into an equivalent object that is a collection
-        if (ConvertUtils.isConvertable(propValue, destType)) {
-            return (Collection) ConvertUtils.convert(propValue, destType);
-        } else {
-            String objectClass = (propValue == null) ? "null" : propValue.getClass().getName();
-            throw ExceptionFactory.makeWebServiceException(
-                    Messages.getMessage("convertProblem", objectClass, destType.getName()));
-            
-        }
-    }
-    
-    /**
-     * @param propValue
-     * @param destType T[]
-     * @return array of component type
-     */
-    private static Object asArray(Object propValue, Class destType) {
-        if (ConvertUtils.isConvertable(propValue, destType)) {
-            return ConvertUtils.convert(propValue, destType);
-        } else {
-            String objectClass = (propValue == null) ? "null" : propValue.getClass().getName();
-            throw ExceptionFactory.makeWebServiceException(
-                    Messages.getMessage("convertProblem", objectClass, destType.getName()));
-
-        }
-    }
-    
-    public String toString() {
-        String value = "PropertyInfo[";
-        value += " name="+ this.getPropertyName();
-        value += " type=" + this.getPropertyType().getName();
-        value += " propertyDecriptor=" + this.descriptor;
-        return value +"]";
-    }
-}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperToolImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperToolImpl.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperToolImpl.java	(working copy)
@@ -18,22 +18,16 @@
 package org.apache.axis2.jaxws.wrapper.impl;
 
 import java.beans.IntrospectionException;
-import java.beans.PropertyDescriptor;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.WeakHashMap;
 
-import javax.xml.bind.JAXBElement;
-
 import org.apache.axis2.jaxws.i18n.Messages;
-import org.apache.axis2.jaxws.message.databinding.JAXBUtils;
+import org.apache.axis2.jaxws.utility.PropertyDescriptorPlus;
 import org.apache.axis2.jaxws.utility.XMLRootElementUtil;
 import org.apache.axis2.jaxws.wrapper.JAXBWrapperTool;
-import org.apache.axis2.jaxws.wrapper.PropertyInfo;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -50,10 +44,12 @@
      * Returns the list of child objects of the jaxb object
      * @param jaxbObject that represents the type
      * @param childNames list of xml child names as String
+     * @param pdMap PropertyDescriptor map for this jaxbObject
      * @return list of Objects in the same order as the element names.  
      */
     public Object[] unWrap(Object jaxbObject, 
-            List<String> childNames) throws JAXBWrapperException{
+            List<String> childNames, 
+            Map<String, PropertyDescriptorPlus> pdMap) throws JAXBWrapperException{
         
         
         if(jaxbObject == null){
@@ -70,14 +66,14 @@
             log.debug("Invoking unWrap() method with jaxb object:" + jaxbComplexTypeObj.getClass().getName());
             log.debug("The input child xmlnames are: " + toString(childNames));
         }
-        // Get the PropertyInfo map.
+        // Get the PropertyDescriptorPlus map.
         // The method makes sure that each child name has a matching jaxb property
-        Map<String , PropertyInfo> piMap = createPropertyInfoMap(jaxbComplexTypeObj.getClass(), childNames);
+        checkPropertyDescriptorMap(jaxbComplexTypeObj.getClass(), childNames, pdMap);
                 
         // Get the corresponsing objects from the jaxb bean
         ArrayList<Object> objList = new ArrayList<Object>();
         for(String childName:childNames){
-            PropertyInfo propInfo = piMap.get(childName);
+            PropertyDescriptorPlus propInfo = pdMap.get(childName);
             Object object = null;
             try {
                 object = propInfo.get(jaxbComplexTypeObj);
@@ -105,10 +101,12 @@
      * @param jaxbClass 
      * @param childNames list of xml child names as String
      * @param childObjects, component type objects
+     * @param pdMap PropertyDescriptor map for this jaxbObject
      */ 
     public Object wrap(Class jaxbClass, 
-            List<String> childNames, Map<String, Object> childObjects)
-    throws JAXBWrapperException {
+            List<String> childNames, 
+            Map<String, Object> childObjects,
+            Map<String, PropertyDescriptorPlus> pdMap) throws JAXBWrapperException {
         
         
         if(childNames == null|| childObjects == null){
@@ -124,7 +122,7 @@
         }
         
         // Just like unWrap, get the property info map
-        Map<String, PropertyInfo> pdTable = createPropertyInfoMap(jaxbClass, childNames);
+        checkPropertyDescriptorMap(jaxbClass, childNames, pdMap);
         
         // The jaxb object always has a default constructor.  Create the object
         Object jaxbObject = null;
@@ -139,7 +137,7 @@
         
         // Now set each object onto the jaxb object
         for(String childName:childNames){
-            PropertyInfo propInfo = pdTable.get(childName);
+            PropertyDescriptorPlus propInfo = pdMap.get(childName);
             Object value = childObjects.get(childName);
             try {
                 propInfo.set(jaxbObject, value);
@@ -160,39 +158,16 @@
 	}
 	
 	/**
-     * Creates a PropertyInfo map.
-     * The key to the map is the xml string.
-     * The value is a PropertyInfo object...which is used to set and get bean properties 
-     * creates propertyDescriptor for the childNames using the jaxbClass.  
-	 * use Introspector.getBeanInfo().getPropertyDescriptors() to get all the property descriptors. Assert if # of childNames and propertyDescriptor array
-	 * length do not match. if they match then get the xmlElement name from jaxbClass using propertyDescriptor's display name. See if the xmlElementName matches the 
-	 * childName if not use xmlElement annotation name and create PropertyInfo add childName or xmlElement name there, set propertyDescriptor 
-	 * and return Map<ChileName, PropertyInfo>.
-	 * @param jaxbClass - Class jaxbClass name
-	 * @param childNames - ArrayList<String> of xml childNames 
-	 * @return Map<String, PropertyInfo> - map of ChildNames that map to PropertyInfo that hold the propertyName and PropertyDescriptor.
-	 * @throws IntrospectionException, NoSuchFieldException
+     * Makes sure that each xmlChildName is present in the odMap
 	 */
-	private Map<String, PropertyInfo> createPropertyInfoMap(Class jaxbClass, 
-            List<String> xmlChildNames) throws JAXBWrapperException{
-		Map<String, PropertyInfo> map = new WeakHashMap<String, PropertyInfo>();
-		
-		// Get the property descriptor map for this JAXBClass
-        Map<String, PropertyDescriptor>  pdMap = null;
-        try {
-            pdMap = XMLRootElementUtil.createPropertyDescriptorMap(jaxbClass);
-        } catch (Throwable t) {
-            log.debug("Error occurred to build the PropertyDescriptor map");
-            log.debug("  The JAXBClass is:" + jaxbClass.getName());
-            throw new JAXBWrapperException(t);
-        }
-       
-		
-        // Now create the property info map
+	private void checkPropertyDescriptorMap(Class jaxbClass, 
+            List<String> xmlChildNames, Map<String, PropertyDescriptorPlus> pdMap) throws JAXBWrapperException{
+		Map<String, PropertyDescriptorPlus> map = new HashMap<String, PropertyDescriptorPlus>();
+		       
+        // Now check the property info map
         for (int i=0; i<xmlChildNames.size(); i++) {
-            PropertyInfo propInfo= null;
             String xmlChildName = xmlChildNames.get(i);
-            PropertyDescriptor pd = pdMap.get(xmlChildName);
+            PropertyDescriptorPlus pd = pdMap.get(xmlChildName);
             if(pd == null){
                 // Each xml child name must have a matching property.  
                 if (log.isDebugEnabled()) {
@@ -204,12 +179,7 @@
                 }
                 throw new JAXBWrapperException(Messages.getMessage("JAXBWrapperErr6", jaxbClass.getName(), xmlChildName));
             }
-            propInfo = new PropertyInfo(pd);
-            map.put(xmlChildName, propInfo);
         }
-        
-		
-		return map;
 	}
 	
     
@@ -233,6 +203,37 @@
         }
         return text + "]";
     }
+
+    public Object[] unWrap(Object jaxbObject, List<String> childNames) throws JAXBWrapperException {
+        // Get the property descriptor map for this JAXBClass
+        Class jaxbClass = jaxbObject.getClass();
+        Map<String, PropertyDescriptorPlus>  pdMap = null;
+        try {
+            pdMap = XMLRootElementUtil.createPropertyDescriptorMap(jaxbClass);
+        } catch (Throwable t) {
+            log.debug("Error occurred to build the PropertyDescriptor map");
+            log.debug("  The JAXBClass is:" + jaxbClass.getName());
+            throw new JAXBWrapperException(t);
+        }
+        
+        // Delegate
+        return unWrap(jaxbObject, childNames, pdMap);
+    }
+
+    public Object wrap(Class jaxbClass, List<String> childNames, Map<String, Object> childObjects) throws JAXBWrapperException {
+        // Get the property descriptor map
+        Map<String, PropertyDescriptorPlus>  pdMap = null;
+        try {
+            pdMap = XMLRootElementUtil.createPropertyDescriptorMap(jaxbClass);
+        } catch (Throwable t) {
+            log.debug("Error occurred to build the PropertyDescriptor map");
+            log.debug("  The JAXBClass is:" + jaxbClass.getName());
+            throw new JAXBWrapperException(t);
+        }
+        
+        // Delegate
+        return wrap(jaxbClass, childNames, childObjects, pdMap);
+    }
 	
 	
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/JAXBWrapperTool.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/JAXBWrapperTool.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/JAXBWrapperTool.java	(working copy)
@@ -20,6 +20,7 @@
 import java.util.List;
 import java.util.Map;
 
+import org.apache.axis2.jaxws.utility.PropertyDescriptorPlus;
 import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
 
 /**
@@ -32,9 +33,24 @@
      * Returns the list of child objects of the jaxb object
      * @param jaxbObject that represents the type
      * @param childNames list of xml child names as String
+     * @param pdMap PropertyDescriptorMap describing the jaxbObject
      * @return list of Objects in the same order as the element names.  
      */
-   public Object[] unWrap(Object jaxbObject, List<String> childNames) throws JAXBWrapperException;
+   public Object[] unWrap(Object jaxbObject, 
+           List<String> childNames, 
+           Map<String, PropertyDescriptorPlus> pdMap) throws JAXBWrapperException;
+   
+   /**
+    * unwrap 
+    * Returns the list of child objects of the jaxb object
+    * @param jaxbObject that represents the type
+    * @param childNames list of xml child names as String
+    * @return list of Objects in the same order as the element names.  
+    * Note: This method creates a PropertyDescriptor map; thus it is less
+    * performant than the other unWrap method
+    */
+  public Object[] unWrap(Object jaxbObject, 
+          List<String> childNames) throws JAXBWrapperException;
 
 
     /**
@@ -46,9 +62,30 @@
      * @param jaxbClass 
      * @param childNames list of xml child names as String
      * @param childObjects, component type objects
+     * @param pdMap PropertyDescriptorMap describing the jaxbObject
      */ 
-    public Object wrap(Class jaxbClass, List<String> childNames, Map<String, Object> childObjects) throws JAXBWrapperException;
+    public Object wrap(Class jaxbClass, 
+            List<String> childNames, 
+            Map<String, Object> childObjects,
+            Map<String, PropertyDescriptorPlus> pdMap) throws JAXBWrapperException;
     
+    /**
+     * wrap
+     * Creates a jaxb object that is initialized with the child objects.
+     * 
+     * Note that the jaxbClass must be the class the represents the complexType. (It should never be JAXBElement)
+     * 
+     * @param jaxbClass 
+     * @param childNames list of xml child names as String
+     * @param childObjects, component type objects
+     * @param pdMap PropertyDescriptorMap describing the jaxbObject
+     * Note: This method creates a PropertyDescriptor map; thus it is less
+     * performant than the other unWrap method
+     */ 
+    public Object wrap(Class jaxbClass, 
+            List<String> childNames, 
+            Map<String, Object> childObjects) throws JAXBWrapperException;
     
+    
 }
 
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/OperationRuntimeDescriptionFactory.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/OperationRuntimeDescriptionFactory.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/OperationRuntimeDescriptionFactory.java	(working copy)
@@ -1,42 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws.runtime.description;
-
-import org.apache.axis2.jaxws.description.OperationDescription;
-import org.apache.axis2.jaxws.runtime.description.impl.OperationRuntimeDescriptionBuilder;
-
-public class OperationRuntimeDescriptionFactory {
-
-    /**
-     * intentionally private
-     */
-    private OperationRuntimeDescriptionFactory() {}
-
-    /**
-     * Get or create OperationRuntimeDescription
-     * @param opDesc
-     * @return OperationRuntimeDescription
-     */
-    public static OperationRuntimeDescription get(OperationDescription opDesc) {
-        OperationRuntimeDescription opRTDesc = (OperationRuntimeDescription) opDesc.getOperationRuntimeDesc("JAXWS");
-        if (opRTDesc == null) {
-            opRTDesc = OperationRuntimeDescriptionBuilder.create(opDesc);
-            opDesc.setOperationRuntimeDesc(opRTDesc);
-        }
-        return opRTDesc;
-    }
-}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/impl/OperationRuntimeDescriptionBuilder.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/impl/OperationRuntimeDescriptionBuilder.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/impl/OperationRuntimeDescriptionBuilder.java	(working copy)
@@ -1,38 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws.runtime.description.impl;
-
-import org.apache.axis2.jaxws.description.OperationDescription;
-import org.apache.axis2.jaxws.runtime.description.OperationRuntimeDescription;
-
-public class OperationRuntimeDescriptionBuilder {
-
-    /**
-     * Intentionally Private
-     */
-    private OperationRuntimeDescriptionBuilder() { }
-
-    /**
-     * create
-     * @param opDesc
-     * @return
-     */
-    static public OperationRuntimeDescription create(OperationDescription opDesc) {
-        OperationRuntimeDescriptionImpl ordi = new OperationRuntimeDescriptionImpl("JAXWS", opDesc);
-        return ordi;
-    }
-}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/impl/OperationRuntimeDescriptionImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/impl/OperationRuntimeDescriptionImpl.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/impl/OperationRuntimeDescriptionImpl.java	(working copy)
@@ -1,46 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws.runtime.description.impl;
-
-import org.apache.axis2.jaxws.description.OperationDescription;
-import org.apache.axis2.jaxws.runtime.description.OperationRuntimeDescription;
-
-/**
- *
- *
- */
-public class OperationRuntimeDescriptionImpl implements OperationRuntimeDescription {
-
-    OperationDescription opDesc;
-    String name;
-    
-    /**
-     * @param name
-     * @param opDesc
-     */
-    OperationRuntimeDescriptionImpl(String name, OperationDescription opDesc) {
-       this.opDesc = opDesc;
-       this.name =name;
-    }
-    public OperationDescription getOperationDescription() {
-       return opDesc;
-    }
-    public String getKey() {
-        return name;
-    }
-
-}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/injection/impl/ResourceInjectionServiceRuntimeDescriptionImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/injection/impl/ResourceInjectionServiceRuntimeDescriptionImpl.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/injection/impl/ResourceInjectionServiceRuntimeDescriptionImpl.java	(working copy)
@@ -50,4 +50,16 @@
     void setResourceAnnotation(boolean value) {
         _hasResourceAnnotation = value;
     }
+    
+    public String toString() {
+        final String newline = "\n";
+        StringBuffer string = new StringBuffer();
+        
+        string.append(newline);
+        string.append("  ResourceInjectionServiceRuntime:" + getKey());
+        string.append(newline);
+        string.append("    @Resource Annotation = " + hasResourceAnnotation());
+        
+        return string.toString();
+    }
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/injection/ResourceInjectionServiceRuntimeDescriptionFactory.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/injection/ResourceInjectionServiceRuntimeDescriptionFactory.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/injection/ResourceInjectionServiceRuntimeDescriptionFactory.java	(working copy)
@@ -18,7 +18,6 @@
 
 import org.apache.axis2.jaxws.description.OperationDescription;
 import org.apache.axis2.jaxws.description.ServiceDescription;
-import org.apache.axis2.jaxws.runtime.description.impl.OperationRuntimeDescriptionBuilder;
 import org.apache.axis2.jaxws.runtime.description.injection.impl.ResourceInjectionServiceRuntimeDescriptionBuilder;
 
 public class ResourceInjectionServiceRuntimeDescriptionFactory {
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/MarshalServiceRuntimeDescription.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/MarshalServiceRuntimeDescription.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/MarshalServiceRuntimeDescription.java	(working copy)
@@ -16,9 +16,11 @@
  */
 package org.apache.axis2.jaxws.runtime.description.marshal;
 
+import java.util.Map;
 import java.util.TreeSet;
 
 import org.apache.axis2.jaxws.description.ServiceRuntimeDescription;
+import org.apache.axis2.jaxws.utility.PropertyDescriptorPlus;
 
 
 /**
@@ -32,9 +34,21 @@
     public TreeSet<String> getPackages();
     
     /**
-     * Return AnnotationDesc for this class
+     * Get the AnnotationDesc for this class.
+     * If one is not cached, a new one is creatd
      * @param cls
-     * @return
+     * @return AnnotationDesc
      */
     public AnnotationDesc getAnnotationDesc(Class cls);
+    
+    
+    /**
+     * Get the PropertyDescriptor map for the class.
+     * The key of the map is a child xml local name.
+     * The value is a PropertyDescriptor, that will be used to 
+     * set/get values from a bean of the indicated class
+     * @param cls
+     * @return get the cached copy or create a new one
+     */
+    public Map<String, PropertyDescriptorPlus> getPropertyDescriptorMap(Class cls);
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/AnnotationBuilder.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/AnnotationBuilder.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/AnnotationBuilder.java	(working copy)
@@ -58,10 +58,6 @@
  * Walks the ServiceDescription and its child *Description classes
  * to find all of the types.  An AnnotationDesc is built for each of the types
  */
-/**
- * @author scheu
- *
- */
 public class AnnotationBuilder {
     
     private static Log log = LogFactory.getLog(AnnotationBuilder.class);
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/MarshalServiceRuntimeDescriptionImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/MarshalServiceRuntimeDescriptionImpl.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/MarshalServiceRuntimeDescriptionImpl.java	(working copy)
@@ -1,12 +1,17 @@
 package org.apache.axis2.jaxws.runtime.description.marshal.impl;
 
+import java.beans.PropertyDescriptor;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.TreeSet;
+import java.util.Map.Entry;
 
+import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.description.ServiceDescription;
 import org.apache.axis2.jaxws.runtime.description.marshal.AnnotationDesc;
 import org.apache.axis2.jaxws.runtime.description.marshal.MarshalServiceRuntimeDescription;
+import org.apache.axis2.jaxws.utility.PropertyDescriptorPlus;
+import org.apache.axis2.jaxws.utility.XMLRootElementUtil;
 
 
 public class MarshalServiceRuntimeDescriptionImpl implements
@@ -16,6 +21,7 @@
     private String key; 
     private TreeSet<String> packages;
     private Map<String, AnnotationDesc> annotationMap = null;
+    private Map<Class, Map<String, PropertyDescriptorPlus>> pdMapCache = null;
     
     protected MarshalServiceRuntimeDescriptionImpl(String key,
                 ServiceDescription serviceDesc) {
@@ -57,5 +63,58 @@
     void setAnnotationMap(Map<String, AnnotationDesc> map) {
         this.annotationMap = map;
     }
+
+
+    public Map<String, PropertyDescriptorPlus> getPropertyDescriptorMap(Class cls) {
+        // We are caching by class.  
+        Map<String, PropertyDescriptorPlus> pdMap = pdMapCache.get(cls);
+        if (pdMap != null) {
+            // Cache hit
+            return pdMap;
+        }
+        
+        // Cache miss...this can occur if the classloader changed.
+        // We cannot add this new pdMap at this point due to sync issues.
+        try {
+            pdMap = XMLRootElementUtil.createPropertyDescriptorMap(cls);
+        } catch (Throwable t) {
+            ExceptionFactory.makeWebServiceException(t);
+        }
+        return pdMap;
+    }
     
+    void setPropertyDescriptorMapCache(Map<Class, Map<String, PropertyDescriptorPlus>> cache) {
+        this.pdMapCache = cache;
+    }
+    
+    public String toString() {
+        final String newline = "\n";
+        StringBuffer string = new StringBuffer();
+        
+        string.append(newline);
+        string.append("  MarshalServiceRuntime:" + getKey());
+        string.append(newline);
+        string.append("    Packages = " + getPackages().toString());
+        for(Entry<String, AnnotationDesc> entry: this.annotationMap.entrySet()) {
+            string.append(newline);
+            string.append("    AnnotationDesc cached for:" + entry.getKey());
+            string.append(entry.getValue().toString());
+        }
+        
+        for(Entry<Class, Map<String, PropertyDescriptorPlus>> entry: this.pdMapCache.entrySet()) {
+            string.append(newline);
+            string.append("    PropertyDescriptorPlus Map cached for:" + entry.getKey().getCanonicalName());
+            for (PropertyDescriptorPlus pdp:entry.getValue().values()) {
+                string.append(newline);
+                string.append("      propertyName   =" + pdp.getPropertyName());
+                string.append(newline);
+                string.append("        xmlName      =" + pdp.getXmlName());
+                string.append(newline);
+                string.append("        propertyType =" + pdp.getPropertyType().getCanonicalName());
+                string.append(newline);
+            }
+        }
+        
+        return string.toString();
+    }
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/MarshalServiceRuntimeDescriptionBuilder.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/MarshalServiceRuntimeDescriptionBuilder.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/MarshalServiceRuntimeDescriptionBuilder.java	(working copy)
@@ -16,6 +16,7 @@
  */
 package org.apache.axis2.jaxws.runtime.description.marshal.impl;
 
+import java.beans.PropertyDescriptor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.security.PrivilegedAction;
@@ -31,6 +32,8 @@
 import org.apache.axis2.jaxws.description.ServiceDescription;
 import org.apache.axis2.jaxws.runtime.description.marshal.AnnotationDesc;
 import org.apache.axis2.jaxws.runtime.description.marshal.MarshalServiceRuntimeDescription;
+import org.apache.axis2.jaxws.utility.PropertyDescriptorPlus;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -71,13 +74,27 @@
         try {
            map = AnnotationBuilder.getAnnotationDescs(serviceDesc);
         } catch(Throwable t) {
-            // Since we are caching, proceed without exception
+            // Since we are building a cache, proceed without exception
             if (log.isDebugEnabled()) {
-                log.debug("Swallowing Exception:" + t);
+                log.debug("Exception occurred during cache processing.  This will impact performance:" + t);
             }
             map = new HashMap<String, AnnotationDesc>();
         }
         marshalDesc.setAnnotationMap(map);
+        
+        // Build the property descriptor map
+        // TODO nothing is cached right now
+        Map<Class, Map<String, PropertyDescriptorPlus>> cache;
+        try {
+            cache = PropertyDescriptorMapBuilder.getPropertyDescMaps(serviceDesc);
+        } catch (Throwable t) {
+            // Since we are building a cache, proceed without exception
+            if (log.isDebugEnabled()) {
+                log.debug("Exception occurred during cache processing.  This will impact performance:" + t);
+            }
+            cache = new HashMap<Class, Map<String, PropertyDescriptorPlus>> ();
+        }
+        marshalDesc.setPropertyDescriptorMapCache(cache);
             
         // @TODO There are two ways to get the packages.
         // Schema Walk (prefered) and Annotation Walk.
@@ -99,5 +116,4 @@
         }
         marshalDesc.setPackages(packages);
     }
-       
 }
\ No newline at end of file
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/PropertyDescriptorMapBuilder.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/PropertyDescriptorMapBuilder.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/PropertyDescriptorMapBuilder.java	(revision 0)
@@ -0,0 +1,294 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.runtime.description.marshal.impl;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Method;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+
+import javax.wsdl.Definition;
+import javax.wsdl.WSDLException;
+import javax.xml.bind.JAXBElement;
+
+import org.apache.axis2.java.security.AccessController;
+import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.description.EndpointDescription;
+import org.apache.axis2.jaxws.description.EndpointDescriptionJava;
+import org.apache.axis2.jaxws.description.EndpointInterfaceDescription;
+import org.apache.axis2.jaxws.description.FaultDescription;
+import org.apache.axis2.jaxws.description.OperationDescription;
+import org.apache.axis2.jaxws.description.ParameterDescription;
+import org.apache.axis2.jaxws.description.ServiceDescription;
+import org.apache.axis2.jaxws.description.ServiceDescriptionWSDL;
+import org.apache.axis2.jaxws.runtime.description.marshal.AnnotationDesc;
+import org.apache.axis2.jaxws.util.WSDL4JWrapper;
+import org.apache.axis2.jaxws.util.WSDLWrapper;
+import org.apache.axis2.jaxws.utility.ClassUtils;
+import org.apache.axis2.jaxws.utility.JavaUtils;
+import org.apache.axis2.jaxws.utility.PropertyDescriptorPlus;
+import org.apache.axis2.jaxws.utility.XMLRootElementUtil;
+import org.apache.axis2.jaxws.wsdl.SchemaReader;
+import org.apache.axis2.jaxws.wsdl.SchemaReaderException;
+import org.apache.axis2.jaxws.wsdl.impl.SchemaReaderImpl;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * Walks the ServiceDescription and its child *Description classes
+ * to find all of the types.  An AnnotationDesc is built for each of the types
+ */
+public class PropertyDescriptorMapBuilder {
+    
+    private static Log log = LogFactory.getLog(PropertyDescriptorMapBuilder.class);
+    
+
+    /**
+     * This is a static utility class.  The constructor is intentionally private
+     */
+    private PropertyDescriptorMapBuilder() {
+    }
+    
+   
+    
+    /**
+     * @param serviceDescription ServiceDescription
+     * @return PropertyDescriptor Map
+     */
+    public static Map<Class,Map<String, PropertyDescriptorPlus>> getPropertyDescMaps(ServiceDescription serviceDesc) {
+        Map<Class,Map<String, PropertyDescriptorPlus>> map = new HashMap<Class,Map<String, PropertyDescriptorPlus>>();
+        EndpointDescription[] endpointDescs = serviceDesc.getEndpointDescriptions();
+        
+        // Build a set of packages from all of the endpoints
+        if (endpointDescs != null) {
+            for (int i=0; i< endpointDescs.length; i++) {
+                getPropertyDescMaps(endpointDescs[i], map);
+            }
+        }
+        return map;
+    }
+    
+    
+    /**
+     * @param endpointDesc
+     * @param map
+     */
+    private static void getPropertyDescMaps(EndpointDescription endpointDesc, Map<Class,Map<String, PropertyDescriptorPlus>> map) {
+        EndpointInterfaceDescription endpointInterfaceDesc = 
+            endpointDesc.getEndpointInterfaceDescription();
+        if (endpointInterfaceDesc != null) {
+            getPropertyDescMaps(endpointInterfaceDesc, map);
+        }
+    }
+    
+   
+    /**
+     * @param endpointInterfaceDesc
+     * @param map
+     */
+    private static void getPropertyDescMaps(EndpointInterfaceDescription endpointInterfaceDesc, Map<Class,Map<String, PropertyDescriptorPlus>> map) {
+        OperationDescription[] opDescs = endpointInterfaceDesc.getOperations();
+        
+        // Build a set of packages from all of the opertions
+        if (opDescs != null) {
+            for (int i=0; i< opDescs.length; i++) {
+                getPropertyDescMaps(opDescs[i], map);
+            }
+        }
+    }
+    
+    
+    
+    /**
+     * @param opDesc
+     * @param map
+     */
+    private static void getPropertyDescMaps(OperationDescription opDesc, Map<Class,Map<String, PropertyDescriptorPlus>> map) {
+       
+       
+       // Walk the fault information
+       FaultDescription[] faultDescs = opDesc.getFaultDescriptions();
+       if (faultDescs != null) {
+           for (int i=0; i <faultDescs.length; i++) {
+               getPropertyDescMaps(faultDescs[i], map);
+           }
+       }
+       
+       // Also consider the request and response wrappers
+       addPropertyDesc(opDesc.getRequestWrapperClassName(), map);
+       addPropertyDesc(opDesc.getResponseWrapperClassName(), map);
+       
+      
+    }
+    
+    /**
+     * @param opDesc
+     * @param map
+     */
+    private static void getPropertyDescMaps(FaultDescription faultDesc, Map<Class,Map<String, PropertyDescriptorPlus>> map) {
+        // TODO The property descriptors for legacy exceptions and the corresponding fault beans could be cached at this point.
+        String faultDescExceptionName = faultDesc.getExceptionClassName();
+        Class faultDescException = loadClass(faultDescExceptionName);
+        if (faultDescException != null && isLegacyException(faultDescException)) {
+            
+            // For legacy exceptions, the fault bean is a "wrapper class" that has the same properties
+            // as the exception.  To marshal an exception:
+            //    1) the values are obtained from the legacy exception (using the exception's property desc map)
+            //    2) the values are placed on the fault bean (using the bean's property desc map)
+            //    3) the bean is marshalled.
+            // 
+            // Unmarshalling is outside the spec, but we do provide proprietary support.
+            // The algorithm is basically
+            //    1) unmarshall into the fault bean
+            //    2) the values on the fault bean are obtained (using the bean's property desc map)
+            //    3) use heuristics to find a matching constructor on the exception class.  If found it is instantiated.
+            
+            // To accomplish the above marshalling and unmarshalling we need the property descriptor maps
+            // for the exception and the bean.
+            String faultDescBeanName = faultDesc.getFaultBean();
+            Class faultDescBean = loadClass(faultDescBeanName);
+            if (faultDescBean != null) {
+                addPropertyDesc(faultDescBeanName, map);
+                addPropertyDesc(faultDescExceptionName, map);
+            }
+            
+        }
+    }
+    
+    private static void addPropertyDesc(String clsName, Map<Class,Map<String, PropertyDescriptorPlus>> map) {
+        
+        Class cls = loadClass(clsName);
+        if (cls == null) {
+            return;
+        }
+        
+        if (map.get(cls) == null) {
+            try {
+                Map<String, PropertyDescriptorPlus> pdMap = XMLRootElementUtil.createPropertyDescriptorMap(cls);
+                map.put(cls, pdMap);
+            } catch (Throwable t) {
+                ExceptionFactory.makeWebServiceException(t);
+            }
+        }
+    }
+    
+    /**
+     * Loads the class 
+     * @param className
+     * @return Class (or null if the class cannot be loaded)
+     */
+    private static Class loadClass(String className) {
+        // Don't make this public, its a security exposure
+        if (className == null || className.length() == 0) {
+            return null;
+        }
+        try {
+            
+            return forName(className, true, 
+                   getContextClassLoader());
+	        //Catch Throwable as ClassLoader can throw an NoClassDefFoundError that
+	        //does not extend Exception, so lets catch everything that extends Throwable
+            //rather than just Exception.
+        } catch (Throwable e) {
+            // TODO Should the exception be swallowed ?
+            if (log.isDebugEnabled()) {
+                log.debug("PackageSetBuilder cannot load the following class:" + className);
+            }
+        }
+        return null;
+    }
+   
+   /**
+    * Return the class for this name
+    * @return Class
+    */
+   static Class forName(final String className, final boolean initialize, final ClassLoader classloader) throws ClassNotFoundException {
+       // NOTE: This method must remain protected because it uses AccessController
+       Class cl = null;
+       try {
+           cl = (Class) AccessController.doPrivileged(
+                   new PrivilegedExceptionAction() {
+                       public Object run() throws ClassNotFoundException {
+                           return Class.forName(className, initialize, classloader);    
+                       }
+                   }
+                 );  
+       } catch (PrivilegedActionException e) {
+           if (log.isDebugEnabled()) {
+               log.debug("Exception thrown from AccessController: " + e);
+           }
+           throw (ClassNotFoundException) e.getException();
+       } 
+       
+       return cl;
+   }
+   
+   /**
+    * @return ClassLoader
+    */
+   static ClassLoader getContextClassLoader() {
+       // NOTE: This method must remain private because it uses AccessController
+       ClassLoader cl = null;
+       try {
+           cl = (ClassLoader) AccessController.doPrivileged(
+                   new PrivilegedExceptionAction() {
+                       public Object run() throws ClassNotFoundException {
+                           return Thread.currentThread().getContextClassLoader();      
+                       }
+                   }
+                 );  
+       } catch (PrivilegedActionException e) {
+           if (log.isDebugEnabled()) {
+               log.debug("Exception thrown from AccessController: " + e);
+           }
+           throw (RuntimeException) e.getException();
+       }
+       
+       return cl;
+   }
+   
+   /**
+    * A compliant exception has a @WebFault annotation and a getFaultInfo method.
+    * Legacy exceptions do not.
+    * @param cls
+    * @return true if legacy exception
+    * REVIEW perhaps this detection should be in FaultDescription
+    */
+   static boolean isLegacyException(Class cls) {
+       boolean legacyException = false;
+       
+       try {
+           Method getFaultInfo = cls.getMethod("getFaultInfo", null);
+       } catch (Exception e) {
+           // Failure indicates that this is not a legacy exception
+           legacyException = true;
+       }
+       if (legacyException) {
+           if (log.isDebugEnabled()) {
+               log.debug("Detected Legacy Exception = " + cls);
+           }
+       }
+       return legacyException;
+   }
+}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/AnnotationDescImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/AnnotationDescImpl.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/AnnotationDescImpl.java	(working copy)
@@ -58,11 +58,27 @@
             return aDesc;
         }
         aDesc._hasXmlRootElement = true;
-        String name = qName.getLocalPart();
-        String namespace = qName.getNamespaceURI();
+        aDesc._XmlRootElementName = qName.getLocalPart();
+        aDesc._XmlRootElementNamespace = qName.getNamespaceURI();
           
         return aDesc;
     }
     
-    
+    public String toString() {
+        final String newline = "\n";
+        StringBuffer string = new StringBuffer();
+        
+        string.append(newline);
+        string.append("      @XMLRootElement exists = " + this.hasXmlRootElement());
+        
+        if (this.hasXmlRootElement()) {
+            string.append(newline);
+            string.append("      @XMLRootElement namespace = " + this.getXmlRootElementNamespace());
+            string.append(newline);
+            string.append("      @XMLRootElement name      = " + this.getXmlRootElementName());
+        }
+        
+        
+        return string.toString();
+    }
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/OperationRuntimeDescription.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/OperationRuntimeDescription.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/OperationRuntimeDescription.java	(working copy)
@@ -1,23 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws.runtime.description;
-import javax.xml.bind.annotation.XmlRootElement;
-
-
-public interface OperationRuntimeDescription extends org.apache.axis2.jaxws.description.OperationRuntimeDescription {
-   
-}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/LegacyExceptionUtil.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/LegacyExceptionUtil.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/LegacyExceptionUtil.java	(working copy)
@@ -36,9 +36,11 @@
 
 import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.description.FaultDescription;
+import org.apache.axis2.jaxws.runtime.description.marshal.MarshalServiceRuntimeDescription;
 import org.apache.axis2.jaxws.utility.ClassUtils;
+import org.apache.axis2.jaxws.utility.PropertyDescriptorPlus;
+import org.apache.axis2.jaxws.utility.XMLRootElementUtil;
 import org.apache.axis2.jaxws.wrapper.JAXBWrapperTool;
-import org.apache.axis2.jaxws.wrapper.PropertyInfo;
 import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperToolImpl;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -114,9 +116,10 @@
      * JAX-WS 3.7
      * @param t
      * @param fd
+     * @param marshalDesc
      * @return faultBean
      */
-    static Object createFaultBean(Throwable t, FaultDescription fd) throws WebServiceException {
+    static Object createFaultBean(Throwable t, FaultDescription fd, MarshalServiceRuntimeDescription marshalDesc) throws WebServiceException {
         
         Object faultBean = null;
         try {
@@ -134,11 +137,14 @@
             // Load the FaultBean Class
             Class faultBeanClass = MethodMarshallerUtils.loadClass(faultBeanName);
             
+            // Get the properties names from the exception class
+            Map<String, PropertyDescriptorPlus> pdMap = marshalDesc.getPropertyDescriptorMap(t.getClass());
+            
             // We need to assign the legacy exception data to the java bean class.
             // We will use the JAXBWrapperTool.wrap utility to do this.
             
             // Get the map of child objects
-            Map<String, Object> childObjects = getChildObjectsMap(t);
+            Map<String, Object> childObjects = getChildObjectsMap(t, pdMap);
             
             List<String> childNames = new ArrayList<String>(childObjects.keySet());
             
@@ -147,7 +153,8 @@
             }
             // Use the wrapper tool to get the child objects.
             JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
-            faultBean = wrapperTool.wrap(faultBeanClass, childNames, childObjects);
+            Map<String, PropertyDescriptorPlus> pdMapForBean = marshalDesc.getPropertyDescriptorMap(faultBeanClass);
+            faultBean = wrapperTool.wrap(faultBeanClass, childNames, childObjects, pdMapForBean);
             if (log.isErrorEnabled()) {
                 log.debug("Completed creation of the fault bean.");
             }
@@ -163,23 +170,26 @@
      * The specification is silent on this issue.
      * @param exceptionClass
      * @param jaxb
+     * @param marshalDesc
      * @return
      */
-    static Exception createFaultException(Class exceptionClass, Object jaxb) {
+    static Exception createFaultException(Class exceptionClass, 
+            Object jaxb,
+            MarshalServiceRuntimeDescription marshalDesc) {
         Exception e = null;
         try {
             if (log.isErrorEnabled()) {
                 log.debug("Create Legacy Exception for " + exceptionClass.getName());
             }
             // Get the properties names from the exception class
-            Map<String, PropertyInfo> piMap = getPropertyInfoMap(exceptionClass);
+            Map<String, PropertyDescriptorPlus> pdMap = marshalDesc.getPropertyDescriptorMap(exceptionClass);
             
-            // Now get a list of PropertyInfo objects that map to the jaxb bean properties
-            Iterator<Entry<String, PropertyInfo>> it = piMap.entrySet().iterator();
-            List<PropertyInfo> piList= new ArrayList<PropertyInfo>();
+            // Now get a list of PropertyDescriptorPlus objects that map to the jaxb bean properties
+            Iterator<Entry<String, PropertyDescriptorPlus>> it = pdMap.entrySet().iterator();
+            List<PropertyDescriptorPlus> piList= new ArrayList<PropertyDescriptorPlus>();
             while (it.hasNext()) {
-                Entry<String, PropertyInfo> entry = it.next();
-                String propertyName = entry.getKey();
+                Entry<String, PropertyDescriptorPlus> entry = it.next();
+                String propertyName = entry.getValue().getPropertyName();
                 // Some propertyNames should be ignored.
                 if (!ignore.contains(propertyName)) {
                     piList.add(entry.getValue());
@@ -198,7 +208,8 @@
             }
             // Use the wrapper tool to unwrap the jaxb object
             JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
-            Object[] childObjects = wrapperTool.unWrap(jaxb, childNames);
+            Map<String, PropertyDescriptorPlus> pdMapForBean = marshalDesc.getPropertyDescriptorMap(jaxb.getClass());
+            Object[] childObjects = wrapperTool.unWrap(jaxb, childNames, pdMapForBean);
             
             if (log.isErrorEnabled()) {
                 log.debug("Calling newInstance on the constructor " + constructor);
@@ -213,20 +224,20 @@
     /**
      * Find a construcor that matches this set of properties
      * @param cls
-     * @param piList
+     * @param pdList
      * @param childNames returned in the order that they occur in the constructor
      * @return Constructor or null
      */
-    private static Constructor findConstructor(Class cls, List<PropertyInfo> piList, List<String> childNames) {
+    private static Constructor findConstructor(Class cls, List<PropertyDescriptorPlus> pdList, List<String> childNames) {
         Constructor[] constructors = cls.getConstructors();
         Constructor constructor = null;
         if (constructors != null) {
             for (int i=0; i<constructors.length && constructor == null; i++) {
                 Constructor tryConstructor = constructors[i];
-                if (tryConstructor.getParameterTypes().length  == piList.size()) {
+                if (tryConstructor.getParameterTypes().length  == pdList.size()) {
                     // Try and find the best match using the property types
-                    List<PropertyInfo> list = new ArrayList<PropertyInfo>(piList);
-                    List<PropertyInfo> args = new ArrayList<PropertyInfo>();
+                    List<PropertyDescriptorPlus> list = new ArrayList<PropertyDescriptorPlus>(pdList);
+                    List<PropertyDescriptorPlus> args = new ArrayList<PropertyDescriptorPlus>();
                     
                     Class[] parms = tryConstructor.getParameterTypes();
                     boolean valid= true;
@@ -277,48 +288,28 @@
     /**
      * Get the child objects map that is required by the wrapper tool.
      * @param t Exception
+     * @param ParameterDescriptorPlus map for Throwable t
      * @return Map with key is bean property names and values are objects from the Exception
      * @throws IntrospectionException
      */
-    private static Map<String, Object> getChildObjectsMap(Throwable t) 
+    private static Map<String, Object> getChildObjectsMap(Throwable t, Map<String, PropertyDescriptorPlus> pdMap) 
         throws IntrospectionException, InvocationTargetException, IllegalAccessException {
         
-        Map<String, PropertyInfo> piMap = getPropertyInfoMap(t.getClass());
         
         Map<String, Object> coMap = new HashMap<String, Object>();
         
-        Iterator<Entry<String, PropertyInfo>> it = piMap.entrySet().iterator();
+        Iterator<Entry<String, PropertyDescriptorPlus>> it = pdMap.entrySet().iterator();
         while (it.hasNext()) {
-            Entry<String, PropertyInfo> entry = it.next();
-            String propertyName = entry.getKey();
+            Entry<String, PropertyDescriptorPlus> entry = it.next();
+            String propertyName = entry.getValue().getPropertyName();
+            String xmlName = entry.getKey();
             // Some propertyNames should be ignored.
             if (!ignore.contains(propertyName)) {
                 Object value = entry.getValue().get(t);
-                coMap.put(propertyName, value);
+                coMap.put(xmlName, value);
             }
         }
         return coMap;
     }
     
-    /**
-     * Get a Map<String, PropertyInfo> for the specified exception
-     * @param t
-     * @return Map<String, PropertyInfo>
-     */
-    private static Map<String, PropertyInfo> getPropertyInfoMap(Class cls) throws IntrospectionException {
-        // TODO Performance Alert
-        // Get a PropertyInfo Map.  Perhaps this should be cached on the FaultDesc for performance
-        PropertyDescriptor[] pds = Introspector.getBeanInfo(cls).getPropertyDescriptors();
-        
-        Map<String, PropertyInfo> piMap = new HashMap<String, PropertyInfo>();
-        if (pds != null) {
-            for (int i=0; i< pds.length; i++) {
-                PropertyInfo pi = new PropertyInfo(pds[i]);
-                piMap.put(pds[i].getName(), pi);
-            }
-        }
-        return piMap;
-    }
-    
-    
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitWrappedPlusMethodMarshaller.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitWrappedPlusMethodMarshaller.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitWrappedPlusMethodMarshaller.java	(working copy)
@@ -184,7 +184,8 @@
             }
             
             // Get the child objects
-            Object[] objects = wrapperTool.unWrap(wrapperObject, names);
+            Object[] objects = wrapperTool.unWrap(wrapperObject, names, 
+                    marshalDesc.getPropertyDescriptorMap(wrapperObject.getClass()));
             
             // Now create a list of paramValues so that we can populate the signature
             List<PDElement> pvList = new ArrayList<PDElement>();
@@ -312,7 +313,8 @@
             }
             
             // Get the child objects
-            Object[] objects = wrapperTool.unWrap(wrapperObject, xmlNames);
+            Object[] objects = wrapperTool.unWrap(wrapperObject, xmlNames,
+                    marshalDesc.getPropertyDescriptorMap(wrapperObject.getClass()));
             
             // Now create a list of paramValues 
             List<PDElement> pvList = new ArrayList<PDElement>();
@@ -464,7 +466,8 @@
             // Now create the single JAXB element
             Class cls = MethodMarshallerUtils.loadClass(operationDesc.getResponseWrapperClassName());
             JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
-            Object object  = wrapperTool.wrap(cls, nameList, objectList);
+            Object object  = wrapperTool.wrap(cls, nameList, objectList,
+                    marshalDesc.getPropertyDescriptorMap(cls));
             
             QName wrapperQName = new QName(operationDesc.getResponseWrapperTargetNamespace(),
                                            operationDesc.getResponseWrapperLocalName());
@@ -568,7 +571,8 @@
             // Now create the single JAXB element 
             Class cls = MethodMarshallerUtils.loadClass(operationDesc.getRequestWrapperClassName());
             JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
-            Object object  = wrapperTool.wrap(cls, nameList, objectList);
+            Object object  = wrapperTool.wrap(cls, nameList, objectList,
+                    marshalDesc.getPropertyDescriptorMap(cls));
             
             QName wrapperQName = new QName(operationDesc.getRequestWrapperTargetNamespace(),
                                            operationDesc.getRequestWrapperLocalName());
@@ -638,12 +642,11 @@
         EndpointInterfaceDescription ed = operationDesc.getEndpointInterfaceDescription();
         EndpointDescription endpointDesc = ed.getEndpointDescription();
         MarshalServiceRuntimeDescription marshalDesc = MethodMarshallerUtils.getMarshalDesc(endpointDesc);
-        TreeSet<String> packages = marshalDesc.getPackages();
         
         // Note all exceptions are caught and rethrown with a WebServiceException
         try {
             Throwable t = MethodMarshallerUtils.demarshalFaultResponse(operationDesc, 
-                    packages, 
+                    marshalDesc, 
                     message, 
                     false);
             return t;
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitBareMethodMarshaller.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitBareMethodMarshaller.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitBareMethodMarshaller.java	(working copy)
@@ -314,7 +314,6 @@
         EndpointInterfaceDescription ed = operationDesc.getEndpointInterfaceDescription();
         EndpointDescription endpointDesc = ed.getEndpointDescription();
         MarshalServiceRuntimeDescription marshalDesc = MethodMarshallerUtils.getMarshalDesc(endpointDesc);
-        TreeSet<String> packages = marshalDesc.getPackages();
         
         // We want to respond with the same protocol as the request,
         // It the protocol is null, then use the Protocol defined by the binding
@@ -345,11 +344,10 @@
         EndpointInterfaceDescription ed = operationDesc.getEndpointInterfaceDescription();
         EndpointDescription endpointDesc = ed.getEndpointDescription();
         MarshalServiceRuntimeDescription marshalDesc = MethodMarshallerUtils.getMarshalDesc(endpointDesc);
-        TreeSet<String> packages = marshalDesc.getPackages();
         
         // Note all exceptions are caught and rethrown with a WebServiceException
         try {
-            Throwable t = MethodMarshallerUtils.demarshalFaultResponse(operationDesc, packages, message, false);
+            Throwable t = MethodMarshallerUtils.demarshalFaultResponse(operationDesc, marshalDesc, message, false);
             return t;
         } catch(Exception e) {
             throw ExceptionFactory.makeWebServiceException(e);
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/RPCLitMethodMarshaller.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/RPCLitMethodMarshaller.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/RPCLitMethodMarshaller.java	(working copy)
@@ -427,11 +427,10 @@
         EndpointInterfaceDescription ed = operationDesc.getEndpointInterfaceDescription();
         EndpointDescription endpointDesc = ed.getEndpointDescription();
         MarshalServiceRuntimeDescription marshalDesc = MethodMarshallerUtils.getMarshalDesc(endpointDesc);
-        TreeSet<String> packages = marshalDesc.getPackages();
         
         // Note all exceptions are caught and rethrown with a WebServiceException
         try {
-            Throwable t = MethodMarshallerUtils.demarshalFaultResponse(operationDesc, packages, message,  true); 
+            Throwable t = MethodMarshallerUtils.demarshalFaultResponse(operationDesc, marshalDesc, message,  true); 
             return t;
         } catch(Exception e) {
             throw ExceptionFactory.makeWebServiceException(e);
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/MethodMarshallerUtils.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/MethodMarshallerUtils.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/MethodMarshallerUtils.java	(working copy)
@@ -528,7 +528,7 @@
                 
                 if (LegacyExceptionUtil.isLegacyException(t.getClass())) {
                     // Legacy Exception case
-                    faultBeanObject = LegacyExceptionUtil.createFaultBean(t, fd);
+                    faultBeanObject = LegacyExceptionUtil.createFaultBean(t, fd, marshalDesc);
                 } else {
                     // Normal case
                     // Get the fault bean object.  
@@ -670,7 +670,7 @@
      * Unmarshal the service/system exception from a Message.
      * This is used by all of the marshallers
      * @param operationDesc
-     * @param packages
+     * @param marshalDesc
      * @param message
      * @param isRPC
      * @return Throwable
@@ -682,7 +682,10 @@
      * @throws InvocationTargetException
      * @throws NoSuchMethodException
      */
-    static Throwable demarshalFaultResponse(OperationDescription operationDesc, TreeSet<String> packages,Message message, boolean isRPC) 
+    static Throwable demarshalFaultResponse(OperationDescription operationDesc, 
+            MarshalServiceRuntimeDescription marshalDesc,
+            Message message, 
+            boolean isRPC) 
         throws WebServiceException, ClassNotFoundException, IllegalAccessException,
                InstantiationException, XMLStreamException, InvocationTargetException, NoSuchMethodException {
         
@@ -733,7 +736,7 @@
                 log.debug("Ready to demarshal service exception.  The detail entry name is " + elementQName);
             }
             // Get the JAXB object from the block
-            JAXBBlockContext blockContext = new JAXBBlockContext(packages);        
+            JAXBBlockContext blockContext = new JAXBBlockContext(marshalDesc.getPackages());        
             
             if (isRPC) {
                 // RPC is problem ! 
@@ -764,7 +767,11 @@
                 log.debug("Found FaultDescription.  The exception name is " + exceptionClass.getName());
             }
             Class faultBeanFormalClass = loadClass(faultDesc.getFaultBean());  // Note that faultBean may not be a bean, it could be a primitive     
-            exception =createServiceException(xmlfault.getReason().getText(), exceptionClass, faultBeanObject, faultBeanFormalClass);
+            exception =createServiceException(xmlfault.getReason().getText(), 
+                    exceptionClass, 
+                    faultBeanObject, 
+                    faultBeanFormalClass, 
+                    marshalDesc);
         }
         return exception;
     }
@@ -877,13 +884,18 @@
      * @param exceptionclass
      * @param bean
      * @param beanFormalType
+     * @parma marshalDesc is used to get cached information about the exception class and bean
      * @return
      * @throws InvocationTargetException
      * @throws IllegalAccessException
      * @throws InstantiationException
      * @throws NoSuchMethodException
      */
-    private static Exception createServiceException(String message, Class exceptionclass, Object bean, Class beanFormalType) throws InvocationTargetException, IllegalAccessException, InstantiationException, NoSuchMethodException {
+    private static Exception createServiceException(String message, 
+            Class exceptionclass, 
+            Object bean, 
+            Class beanFormalType, 
+            MarshalServiceRuntimeDescription marshalDesc) throws InvocationTargetException, IllegalAccessException, InstantiationException, NoSuchMethodException {
         
         if (log.isDebugEnabled()) {
             log.debug("Constructing JAX-WS Exception:" + exceptionclass);
@@ -891,7 +903,7 @@
         Exception exception = null;
         if (LegacyExceptionUtil.isLegacyException(exceptionclass)) {
             // Legacy Exception
-            exception = LegacyExceptionUtil.createFaultException(exceptionclass, bean);
+            exception = LegacyExceptionUtil.createFaultException(exceptionclass, bean, marshalDesc);
         } else {
             // Normal case, use the contstructor to create the exception
             Constructor constructor = exceptionclass.getConstructor(new Class[] { String.class, beanFormalType });
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitWrappedMethodMarshaller.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitWrappedMethodMarshaller.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitWrappedMethodMarshaller.java	(working copy)
@@ -130,7 +130,8 @@
             }
             
             // Get the child objects
-            Object[] objects = wrapperTool.unWrap(wrapperObject, names);
+            Object[] objects = wrapperTool.unWrap(wrapperObject, names, 
+                    marshalDesc.getPropertyDescriptorMap(wrapperObject.getClass()));
             
             // Now create a list of paramValues so that we can populate the signature
             List<PDElement> pvList = new ArrayList<PDElement>();
@@ -230,7 +231,8 @@
             }
             
             // Get the child objects
-            Object[] objects = wrapperTool.unWrap(wrapperObject, names);
+            Object[] objects = wrapperTool.unWrap(wrapperObject, names,
+                    marshalDesc.getPropertyDescriptorMap(wrapperObject.getClass()));
             
             // Now create a list of paramValues 
             List<PDElement> pvList = new ArrayList<PDElement>();
@@ -335,7 +337,8 @@
             // Now create the single JAXB element
             Class cls = MethodMarshallerUtils.loadClass(operationDesc.getResponseWrapperClassName());
             JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
-            Object object  = wrapperTool.wrap(cls, nameList, objectList);
+            Object object  = wrapperTool.wrap(cls, nameList, objectList,
+                    marshalDesc.getPropertyDescriptorMap(cls));
             
             QName wrapperQName = new QName(operationDesc.getResponseWrapperTargetNamespace(),
                                            operationDesc.getResponseWrapperLocalName());
@@ -421,7 +424,8 @@
             // Now create the single JAXB element 
             Class cls = MethodMarshallerUtils.loadClass(operationDesc.getRequestWrapperClassName());
             JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
-            Object object  = wrapperTool.wrap(cls, nameList, objectList);
+            Object object  = wrapperTool.wrap(cls, nameList, objectList,
+                    marshalDesc.getPropertyDescriptorMap(cls));
             
             QName wrapperQName = new QName(operationDesc.getRequestWrapperTargetNamespace(),
                     operationDesc.getRequestWrapperLocalName());
@@ -482,12 +486,11 @@
         EndpointInterfaceDescription ed = operationDesc.getEndpointInterfaceDescription();
         EndpointDescription endpointDesc = ed.getEndpointDescription();
         MarshalServiceRuntimeDescription marshalDesc = MethodMarshallerUtils.getMarshalDesc(endpointDesc);
-        TreeSet<String> packages = marshalDesc.getPackages();
         
         // Note all exceptions are caught and rethrown with a WebServiceException
         try {
             Throwable t = MethodMarshallerUtils.demarshalFaultResponse(operationDesc, 
-                    packages, 
+                    marshalDesc, 
                     message, 
                     false);
             return t;
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/utility/PropertyDescriptorPlus.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/utility/PropertyDescriptorPlus.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/utility/PropertyDescriptorPlus.java	(revision 0)
@@ -0,0 +1,240 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.jaxws.utility;
+
+import java.beans.IndexedPropertyDescriptor;
+import java.beans.PropertyDescriptor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Collection;
+
+import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.i18n.Messages;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * A PropertyDescriptor provides acesss to a bean property.  Values can
+ * be queried/changed using the read and writer methods of the PropertyDescriptor.
+ * 
+ * A PropertyDescriptorPlus object wraps a PropertyDescriptor and supplies
+ * enhanced set/get methods that match JAXB semantis.
+ * 
+ * For example, the set(..) method is smart enough to add lists, arrays and
+ * atomic values on JAXB beans.
+ * 
+ * The PropertyDescriptorPlus object also stores the xmlName of the property.
+ * 
+ * @See XMLRootElementUtil.createPropertyDescriptorMap , which creates the PropertyDescriptorPlus objects
+ *
+ */
+public class PropertyDescriptorPlus {
+	PropertyDescriptor descriptor;
+    String xmlName = null;
+    
+	private static Log log = LogFactory.getLog(PropertyDescriptorPlus.class);
+	/**
+     * Package protected constructor.  Only created by XMLRootElementUtil.createPropertyDescriptorMap
+	 * @param propertyName
+	 * @param descriptor
+     * @see XMLRootElementUtil.createPropertyDescriptorMap
+	 */
+	PropertyDescriptorPlus(PropertyDescriptor descriptor, String xmlName) {
+		super();
+		this.descriptor = descriptor;
+        this.xmlName = xmlName;
+	}
+	
+    /**
+     * @return xmlname
+     */
+    public String getXmlName() {
+        return xmlName;
+    }
+    
+    /**
+     * @return property type
+     */
+    public Class getPropertyType() {
+        return descriptor.getPropertyType();
+    }
+    
+    /**
+     * @return property name
+     */
+    public String getPropertyName() {
+        return descriptor.getName();
+    }
+	
+	/**
+     * Get the object 
+	 * @param targetBean
+	 * @return Object for this property or null
+	 * @throws InvocationTargetException
+	 * @throws IllegalAccessException
+	 */
+	public Object get(Object targetBean)throws InvocationTargetException, IllegalAccessException{
+		Method method = descriptor.getReadMethod();
+		return method.invoke(targetBean, null);
+	}
+	
+	/** 
+     * Set the object
+	 * @param targetBean
+	 * @param propValue
+	 * @throws InvocationTargetException
+	 * @throws IllegalAccessException
+	 * @throws JAXBWrapperException
+	 */
+	public void set(Object targetBean, Object propValue) throws InvocationTargetException, IllegalAccessException, JAXBWrapperException{
+        
+        // No set occurs if the value is null
+        if (propValue == null) {
+            return;
+        }
+            
+        // There are 3 different types of setters that can occur.
+        // 1) Normal Attomic Setter : setFoo(type)
+        // 2) Indexed Array Setter : setFoo(type[])
+        // 3) No Setter case if the property is a List<T>.
+        
+        Method writeMethod = descriptor.getWriteMethod();
+        if (descriptor instanceof IndexedPropertyDescriptor) {
+            // Set for indexed  T[]
+            setIndexedArray(targetBean, propValue, writeMethod);
+        } else if (writeMethod == null) {
+            // Set for List<T>
+            setList(targetBean, propValue);
+        } else {
+            // Normal case
+            setAtomic(targetBean, propValue, writeMethod);
+        }
+    }
+    
+    /**
+     * Set the property value onto targetBean using the writeMethod
+     * @param targetBean
+     * @param propValue
+     * @param writeMethod (set(T))
+     * @throws InvocationTargetException
+     * @throws IllegalAccessException
+     * @throws JAXBWrapperException
+     */
+    private void setAtomic(Object targetBean, Object propValue, Method writeMethod) 
+        throws InvocationTargetException, IllegalAccessException, JAXBWrapperException {
+        // JAXB provides setters for atomic value.
+        Object[] object = new Object[]{propValue};
+        Class[] paramTypes = writeMethod.getParameterTypes();
+        if(paramTypes !=null && paramTypes.length ==1){
+            Class paramType = paramTypes[0];
+            if(paramType.isPrimitive() && propValue == null){
+                //Ignoring null value for primitive type, this could potentially be the way of a customer indicating to set
+                //default values defined in JAXBObject/xmlSchema.
+                if(log.isDebugEnabled()){
+                    log.debug("Ignoring null value for primitive type, this is the way to set default values defined in JAXBObject/xmlSchema. for primitive types");
+                }
+                return;
+            }
+        }
+        writeMethod.invoke(targetBean, object);
+    }
+    
+    /**
+     * Set the property value using the indexed array setter
+     * @param targetBean
+     * @param propValue
+     * @param writeMethod set(T[])
+     * @throws InvocationTargetException
+     * @throws IllegalAccessException
+     * @throws JAXBWrapperException
+     */
+    private void setIndexedArray(Object targetBean, Object propValue, Method writeMethod) 
+        throws InvocationTargetException, IllegalAccessException, JAXBWrapperException {
+        
+        Class paramType = writeMethod.getParameterTypes()[0];
+        Object value = asArray(propValue, paramType);
+        // JAXB provides setters for atomic value.
+        Object[] object = new Object[]{value};
+        
+        writeMethod.invoke(targetBean, value);
+    }
+    /**
+     * Set the property value for the collection case.
+     * @param targetBean
+     * @param propValue
+     * @throws InvocationTargetException
+     * @throws IllegalAccessException
+     * @throws JAXBWrapperException
+     */
+    private void setList(Object targetBean, Object propValue) throws InvocationTargetException, IllegalAccessException, JAXBWrapperException {
+        // For the List<T> case, there is no setter. 
+        // You are supposed to use the getter to obtain access to the collection and then add the collection
+        
+        Collection value = asCollection(propValue, descriptor.getPropertyType());
+        Collection collection = (Collection) get(targetBean);
+        
+        // Now add our our object to the collection
+        collection.clear();
+        if (propValue != null) {
+            collection.addAll(value);
+        }
+    }
+            
+    /**
+     * @param propValue
+     * @param destType
+     * @return propValue as a Collection
+     */
+    private static Collection asCollection(Object propValue, Class destType) {
+        // TODO Missing function
+        // Convert the object into an equivalent object that is a collection
+        if (ConvertUtils.isConvertable(propValue, destType)) {
+            return (Collection) ConvertUtils.convert(propValue, destType);
+        } else {
+            String objectClass = (propValue == null) ? "null" : propValue.getClass().getName();
+            throw ExceptionFactory.makeWebServiceException(
+                    Messages.getMessage("convertProblem", objectClass, destType.getName()));
+            
+        }
+    }
+    
+    /**
+     * @param propValue
+     * @param destType T[]
+     * @return array of component type
+     */
+    private static Object asArray(Object propValue, Class destType) {
+        if (ConvertUtils.isConvertable(propValue, destType)) {
+            return ConvertUtils.convert(propValue, destType);
+        } else {
+            String objectClass = (propValue == null) ? "null" : propValue.getClass().getName();
+            throw ExceptionFactory.makeWebServiceException(
+                    Messages.getMessage("convertProblem", objectClass, destType.getName()));
+
+        }
+    }
+    
+    public String toString() {
+        String value = "PropertyDescriptorPlus[";
+        value += " name="+ this.getPropertyName();
+        value += " type=" + this.getPropertyType().getName();
+        value += " propertyDecriptor=" + this.descriptor;
+        return value +"]";
+    }
+}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/utility/XMLRootElementUtil.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/utility/XMLRootElementUtil.java	(revision 506071)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/utility/XMLRootElementUtil.java	(working copy)
@@ -21,12 +21,10 @@
 import java.beans.PropertyDescriptor;
 import java.lang.reflect.Field;
 import java.security.PrivilegedAction;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.HashMap;
 import java.util.StringTokenizer;
 
 import javax.xml.bind.JAXBElement;
@@ -129,16 +127,14 @@
      * @param jaxbClass
      * @return map
      */
-    public static Map<String, PropertyDescriptor> createPropertyDescriptorMap(Class jaxbClass) throws NoSuchFieldException, IntrospectionException {
+    public static Map<String, PropertyDescriptorPlus> createPropertyDescriptorMap(Class jaxbClass) throws NoSuchFieldException, IntrospectionException {
         
         if (log.isDebugEnabled()) {
             log.debug("Get the PropertyDescriptor[] for " + jaxbClass);
         }
         
-        // TODO This is a very performance intensive search we should cache the calculated map keyed by the jaxbClass
         PropertyDescriptor[] pds = Introspector.getBeanInfo(jaxbClass).getPropertyDescriptors();
-        // Make this a weak map in case we want to cache the results
-        Map<String, PropertyDescriptor> map = new HashMap<String, PropertyDescriptor>();
+        Map<String, PropertyDescriptorPlus> map = new HashMap<String, PropertyDescriptorPlus>();
         
         // Unfortunately the element names are stored on the fields.
         // Get all of the fields in the class and super classes
@@ -173,10 +169,10 @@
                     }
                     if (map.get(xmlName) != null) {
                         if (log.isDebugEnabled()) {
-                            log.debug("    ALERT: property " + map.get(xmlName).getName() + " already has this same xmlName..this may cause problems.");
+                            log.debug("    ALERT: property " + map.get(xmlName).getPropertyName() + " already has this same xmlName..this may cause problems.");
                         }
                     }
-                    map.put(xmlName, pd);
+                    map.put(xmlName, new PropertyDescriptorPlus(pd, xmlName));
                     break;
                 }
                 
@@ -193,10 +189,10 @@
                         }
                         if (map.get(xmlName) != null) {
                             if (log.isDebugEnabled()) {
-                                log.debug("    ALERT: property " + map.get(xmlName).getName() + " already has this same xmlName..this may cause problems.");
+                                log.debug("    ALERT: property " + map.get(xmlName).getPropertyName() + " already has this same xmlName..this may cause problems.");
                             }
                         }
-                        map.put(xmlName, pd);
+                        map.put(xmlName, new PropertyDescriptorPlus(pd, xmlName));
                         break;
                     }
                 }
@@ -210,10 +206,10 @@
                 }
                 if (map.get(xmlName) != null) {
                     if (log.isDebugEnabled()) {
-                        log.debug("    ALERT: property " + map.get(xmlName).getName() + " already has this same xmlName..this may cause problems.");
+                        log.debug("    ALERT: property " + map.get(xmlName).getPropertyName() + " already has this same xmlName..this may cause problems.");
                     }
                 }
-                map.put(xmlName, pd);
+                map.put(xmlName, new PropertyDescriptorPlus(pd, xmlName));
             }
             if (log.isDebugEnabled()) {
                 log.debug("  End: Find xmlname for property:" + pd.getName());
