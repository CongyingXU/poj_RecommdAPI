Index: C:/workspace/live/axis2/modules/metadata/src/org/apache/axis2/jaxws/i18n/resource.properties
===================================================================
--- C:/workspace/live/axis2/modules/metadata/src/org/apache/axis2/jaxws/i18n/resource.properties	(revision 505591)
+++ C:/workspace/live/axis2/modules/metadata/src/org/apache/axis2/jaxws/i18n/resource.properties	(working copy)
@@ -120,8 +120,9 @@
 checkUsernameAndPassword=Error: The javax.xml.ws.security.auth.username user name and the javax.xml.ws.security.auth.password password must be specified.
 NoMaintainSessionProperty=Error: Maintain Session is enabled but none of the session properties (Cookies, Over-written URL) are returned.
 NullValueForMaintainSessionProperty=Error: The value of the {0} Session property is NULL.
-JAXBBlockFactoryErr1=An internal assertion error occurred. The context parameter of the JAXBBlockFactory object should be a JAXBBlockContext object, but a {0} object was found.
-JAXBBlockFactoryErr2=An internal assertion error occurred. The business object parameter of JAXBBlockFactory object should be a JAXBElement object or an object with an @XmlRootElement annotation, but a {0} object was found.
+JAXBBlockFactoryErr1=An internal assertion error occurred. The context parameter of the JAXBBlockFactory.createFrom method should be a JAXBBlockContext object, but a {0} object was found.
+JAXBBlockFactoryErr2=An internal assertion error occurred. The business object parameter of JAXBBlockFactory.createFrom method should be a JAXBElement object or an object with an @XmlRootElement annotation, but a {0} object was found.
+JAXBBlockFactoryErr3=An internal assertion error occurred. The qName parameter of JAXBBlockFactory.createFrom method should not be null.
 WebServiceContextInjectionImplErr1=A null service instance cannot be injected into the resource.
 WebServiceContextInjectionImplErr2=The injection of private and protected set methods are not supported.
 WebServiceContextInjectionImplErr3=A null service instance cannot be injected into the webservices context.
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperToolImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperToolImpl.java	(revision 505614)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperToolImpl.java	(working copy)
@@ -48,7 +48,7 @@
 	/**
      * unwrap
      * Returns the list of child objects of the jaxb object
-     * @param jaxbObject that is the wrapper element (JAXBElement or object with @XMLRootElement)
+     * @param jaxbObject that represents the type
      * @param childNames list of xml child names as String
      * @return list of Objects in the same order as the element names.  
      */
@@ -64,9 +64,7 @@
         }
         
         // Get the object that will have the property descriptors (i.e. the object representing the complexType)
-        Object jaxbComplexTypeObj = (jaxbObject instanceof JAXBElement) ?
-                ((JAXBElement)jaxbObject).getValue() : // Type object is the value of the JAXBElement
-                    jaxbObject;                        // Or JAXBObject represents both the element and anon complexType
+        Object jaxbComplexTypeObj = jaxbObject;
                 
         if (log.isDebugEnabled()) {
             log.debug("Invoking unWrap() method with jaxb object:" + jaxbComplexTypeObj.getClass().getName());
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/JAXBWrapperTool.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/JAXBWrapperTool.java	(revision 505591)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/JAXBWrapperTool.java	(working copy)
@@ -30,7 +30,7 @@
 	/**
      * unwrap
      * Returns the list of child objects of the jaxb object
-     * @param jaxbObject that is the wrapper element (JAXBElement or object with @XMLRootElement)
+     * @param jaxbObject that represents the type
      * @param childNames list of xml child names as String
      * @return list of Objects in the same order as the element names.  
      */
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/AnnotationDescImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/AnnotationDescImpl.java	(revision 505614)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/impl/AnnotationDescImpl.java	(working copy)
@@ -16,6 +16,11 @@
  */
 package org.apache.axis2.jaxws.runtime.description.marshal.impl;
 
+import java.util.StringTokenizer;
+
+import javax.xml.bind.annotation.XmlRootElement;
+import javax.xml.bind.annotation.XmlSchema;
+
 import org.apache.axis2.jaxws.runtime.description.marshal.AnnotationDesc;
 
 /**
@@ -23,14 +28,76 @@
  */
 class AnnotationDescImpl implements AnnotationDesc {
 
+    private boolean _hasXmlRootElement = false;
+    private String _XmlRootElementName = null;
+    private String _XmlRootElementNamespace = null;
+    
     private AnnotationDescImpl() {
         super();
     }
-    
+
+    public boolean hasXmlRootElement() {
+        return _hasXmlRootElement;
+    }
+
+    public String getXmlRootElementName() {
+       return _XmlRootElementName;
+    }
+
+    public String getXmlRootElementNamespace() {
+        return _XmlRootElementNamespace;
+    }
+
     static AnnotationDesc create(Class cls) {
         AnnotationDescImpl aDesc = new AnnotationDescImpl();
         
+        XmlRootElement root = (XmlRootElement) cls.getAnnotation(XmlRootElement.class);
+        if (root == null) {
+            return aDesc;
+        }
+        aDesc._hasXmlRootElement = true;
+        String name = root.name();
+        String namespace = root.namespace();
+        
+        // The name may need to be defaulted
+        if (name == null || name.length() == 0 || namespace.equals("##default")) {
+            name = getSimpleName(cls.getCanonicalName());
+        }
+        
+        // The namespace may need to be defaulted
+        if (namespace == null || namespace.length() == 0 || namespace.equals("##default")) {
+            Package pkg = cls.getPackage();
+            XmlSchema schema = (XmlSchema) pkg.getAnnotation(XmlSchema.class);
+            if (schema != null) {
+                namespace = schema.namespace();
+            } else {
+                namespace = "";
+            }
+        }
+        
+        aDesc._XmlRootElementName = name;
+        aDesc._XmlRootElementNamespace = namespace;
+          
         return aDesc;
     }
-
+    
+    /**
+     * utility method to get the last token in a "."-delimited package+classname string
+     * @return
+     */
+    private static String getSimpleName(String in) {
+        if (in == null || in.length() == 0) {
+            return in;
+        }
+        String out = null;
+        StringTokenizer tokenizer = new StringTokenizer(in, ".");
+        if (tokenizer.countTokens() == 0)
+            out = in;
+        else {
+            while (tokenizer.hasMoreTokens()) {
+                out = tokenizer.nextToken();
+            }
+        }
+        return out;
+    }
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/AnnotationDesc.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/AnnotationDesc.java	(revision 505614)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/runtime/description/marshal/AnnotationDesc.java	(working copy)
@@ -20,5 +20,20 @@
  * Annotation information cached for a particular class
  */
 public interface AnnotationDesc {
+    
+    /**
+     * @return true if class has @XmlRootElement
+     */
+    public boolean hasXmlRootElement();
+    
+    /**
+     * @return @XmlRootElement name or defaulted name (null if !hasXmlRootElement)
+     */
+    public String getXmlRootElementName();
+    
+    /**
+     * @return @XmlRootElement namespace or default namespace (null if !hasXmlRootElement)
+     */
+    public String getXmlRootElementNamespace();
 
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/JAXBBlockImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/JAXBBlockImpl.java	(revision 505614)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/JAXBBlockImpl.java	(working copy)
@@ -20,6 +20,7 @@
 import java.io.StringWriter;
 import java.util.List;
 
+import javax.xml.bind.JAXBElement;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.JAXBIntrospector;
 import javax.xml.bind.Marshaller;
@@ -62,13 +63,13 @@
 	 * @param busObject..The business object must be a JAXBElement or an object
      * with an @XMLRootElement.  This is assertion is validated in the JAXBFactory.
 	 * @param busContext
-	 * @param qName
+	 * @param qName QName must be non-null
 	 * @param factory
 	 */
 	JAXBBlockImpl(Object busObject, JAXBBlockContext busContext, QName qName, BlockFactory factory) throws JAXBException {
 		super(busObject, 
 				busContext, 
-				(qName==null) ? getQName(busObject, busContext): qName , 
+				qName , 
 				factory);
 	}
 
@@ -76,7 +77,7 @@
 	 * Called by JAXBBlockFactory
 	 * @param omelement
 	 * @param busContext
-	 * @param qName
+	 * @param qName must be non-null
 	 * @param factory
 	 */
 	JAXBBlockImpl(OMElement omElement, JAXBBlockContext busContext, QName qName, BlockFactory factory) {
@@ -112,11 +113,14 @@
                 jaxb = unmarshalByType(u, reader, ctx.getRPCType());
             }
             
-            // Set the qname 
+            
+            
+            /* QNAME should already be known at this point
             QName qName = XMLRootElementUtil.getXmlRootElementQName(jaxb);
             if (qName != null) {  // qname should always be non-null
                 setQName(qName); 
             }
+            */
             
             // Successfully unmarshalled the object
             // TODO remove attachment unmarshaller ?
@@ -310,7 +314,7 @@
             // <foo>1 2 3</foo>
             if (isXSDList(type)) {
                 QName qName = XMLRootElementUtil.getXmlRootElementQName(b);
-                String text = XSDListUtils.toXSDListString(XMLRootElementUtil.getTypeEnabledObject(b));
+                String text = XSDListUtils.toXSDListString(getTypeEnabledObject(b));
                 b = XMLRootElementUtil.getElementEnabledObject(qName.getNamespaceURI(), qName.getLocalPart(), String.class, text);
             }
             m.marshal(b, writer);
@@ -335,10 +339,7 @@
             // Unfortunately RPC is type based.  Thus a
             // declared type must be used to unmarshal the xml.
             Object jaxb;
-            
-            
-            
-            
+ 
             if (!isXSDList(type) ) {
                 // Normal case: We are not unmarshalling an xsd:list
                 jaxb = u.unmarshal(reader, type);
@@ -348,9 +349,9 @@
                 jaxb = u.unmarshal(reader, String.class);
                 
                 // Second convert the String into a list or array
-                if (XMLRootElementUtil.getTypeEnabledObject(jaxb) instanceof String) {
+                if (getTypeEnabledObject(jaxb) instanceof String) {
                     QName qName = XMLRootElementUtil.getXmlRootElementQName(jaxb);
-                    Object obj = XSDListUtils.fromXSDListString((String) XMLRootElementUtil.getTypeEnabledObject(jaxb), type);
+                    Object obj = XSDListUtils.fromXSDListString((String) getTypeEnabledObject(jaxb), type);
                     jaxb = XMLRootElementUtil.getElementEnabledObject(qName.getNamespaceURI(), qName.getLocalPart(), type, obj);
                 }
             } 
@@ -387,4 +388,19 @@
     public boolean isElementData() {
         return true;
     }
+    
+    /**
+     * Return type enabled object
+     * @param obj type or element enabled object
+     * @return type enabled object
+     */
+    static Object getTypeEnabledObject(Object obj) {
+        if (obj == null) {
+            return null;
+        }
+        if (obj instanceof JAXBElement) {
+            return ((JAXBElement) obj).getValue();
+        }
+        return obj;
+    }
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/JAXBBlockFactoryImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/JAXBBlockFactoryImpl.java	(revision 505614)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/JAXBBlockFactoryImpl.java	(working copy)
@@ -58,6 +58,9 @@
 		    // JAXWS spec 4.3.4 conformance requires a WebServiceException whose cause is JAXBException
 			throw ExceptionFactory.makeWebServiceException(new JAXBException(Messages.getMessage("JAXBBlockFactoryErr1", context.getClass().getName())));
 		}
+        if (qName == null) {
+            qName = omElement.getQName();
+        }
 		return new JAXBBlockImpl(omElement, (JAXBBlockContext) context, qName, this);
 	}
 
@@ -78,18 +81,13 @@
 			throw ExceptionFactory.makeWebServiceException(new JAXBException(Messages.getMessage("JAXBBlockFactoryErr1", context.getClass().getName())));
 		}
         
-        // The business object must be either a JAXBElement or a block with an @XmlRootElement qname.  The best way
-        // to verify this is to get the QName from the business object.
-        QName bQName = XMLRootElementUtil.getXmlRootElementQName(businessObject);
-        if (bQName == null) {
-            // JAXWS spec 4.3.4 conformance requires a WebServiceException whose cause is JAXBException
-            throw ExceptionFactory.makeWebServiceException(new JAXBException(Messages.getMessage("JAXBBlockFactoryErr2", businessObject.getClass().getName())));
+        // The business object must be either a JAXBElement or a block with an @XmlRootElement qname.  
+        // (Checking this is expensive, so it is assumed)
+        // The input QName must be set otherwise we have to look it up, which kills performance.
+        if (qName == null) {
+            qName = XMLRootElementUtil.getXmlRootElementQName(businessObject);
         }
         
-        // If the business obect qname does not match the parameter, use the business object qname
-        if (!bQName.equals(qName)) {
-            qName = bQName;
-        }
 		try {
 			return new JAXBBlockImpl(businessObject, (JAXBBlockContext) context, qName, this);
 		} catch (JAXBException e) {
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/factory/BlockFactory.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/factory/BlockFactory.java	(revision 505591)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/factory/BlockFactory.java	(working copy)
@@ -44,7 +44,7 @@
 	 * createBlock from XMLStreamReader
 	 * @param reader XMLStreamReader
 	 * @param context Associated Context or null
-	 * @param QName if known...if null the Block will determine the QName
+	 * @param QName must be supplied if known
 	 * @throws XMLStreamException
 	 * @throws WebServiceException
 	 */
@@ -54,7 +54,7 @@
 	 * createBlock from XMLStreamReader
 	 * @param omElement OMElement
 	 * @param context Associated Context or null
-	 * @param QName if known...if null the Block will determine the QName
+	 * @param QName must be supplied if known
 	 * @throws XMLStreamException
 	 * @throws WebServiceException
 	 */
@@ -77,7 +77,7 @@
 	 * Create from business object
 	 * @param businessObject
 	 * @param context Associated Context or null
-	 * @param QName if known...if null the Block will determine the QName
+	 * @param QName must be supplied if known
 	 * @throws XMLStreamException
 	 * @throws WebServiceException
 	 */
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitWrappedPlusMethodMarshaller.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitWrappedPlusMethodMarshaller.java	(revision 505614)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitWrappedPlusMethodMarshaller.java	(working copy)
@@ -30,6 +30,7 @@
 import javax.jws.WebResult;
 import javax.jws.WebParam.Mode;
 import javax.xml.bind.JAXBElement;
+import javax.xml.namespace.QName;
 import javax.xml.ws.RequestWrapper;
 import javax.xml.ws.ResponseWrapper;
 import javax.xml.ws.WebServiceException;
@@ -194,14 +195,15 @@
                     // Body elements are obtained from the unwrapped array of objects
                     Object value = objects[bodyIndex];
                     // The object in the PDElement must be an element
-                    if (!XMLRootElementUtil.isElementEnabled(pd.getParameterActualType())) {
-                        value = XMLRootElementUtil.getElementEnabledObject(pd.getTargetNamespace(),
-                                pd.getPartName(), 
-                                pd.getParameterActualType(), 
-                                value); 
-     
+                    QName qName = new QName(pd.getTargetNamespace(),
+                            pd.getPartName());
+                    Element element = null;
+                    if (!marshalDesc.getAnnotationDesc(pd.getParameterActualType()).hasXmlRootElement()) {
+                        element = new Element(value, qName, pd.getParameterActualType());
+                    } else {
+                        element = new Element(value, qName);
                     }
-                    pvList.add(new PDElement(pd, value));
+                    pvList.add(new PDElement(pd,element));
                     bodyIndex++;
                 } else {
                     // Header
@@ -209,7 +211,8 @@
                     String localName = pd.getParameterName();
                     block = message.getHeaderBlock(pd.getTargetNamespace(), localName, blockContext, factory);
                     Object value = block.getBusinessObject(true);
-                    pvList.add(new PDElement(pd, value));
+                    Element element = new Element(value, new QName(pd.getTargetNamespace(), localName));
+                    pvList.add(new PDElement(pd, element));
                 }
             }
             
@@ -226,8 +229,9 @@
                     returnValue = objects[objects.length-1];
                 } else {
                     // Header result: Get the value from the headers
-                    returnValue = MethodMarshallerUtils.getReturnValue(packages, message, null, true,
+                    Element returnElement = MethodMarshallerUtils.getReturnElement(packages, message, null, true,
                             operationDesc.getResultTargetNamespace(), operationDesc.getResultPartName());
+                    returnValue = returnElement.getTypeValue();
                 }
                 // returnValue may be incompatible with JAX-WS signature
                 if (ConvertUtils.isConvertable(returnValue, returnType)) {
@@ -319,15 +323,15 @@
                     // Normal case: Get the parameter value from the list of objects
                     Object value = objects[bodyIndex];
                     
-                    // The object in the PDElement must be an element
-                    if (!XMLRootElementUtil.isElementEnabled(pd.getParameterActualType())) {
-                        value = XMLRootElementUtil.getElementEnabledObject(pd.getTargetNamespace(),
-                                pd.getPartName(), 
-                                pd.getParameterActualType(), 
-                                value);
-     
+                    //  The object in the PDElement must be an element
+                    QName qName = new QName(pd.getTargetNamespace(), pd.getPartName());
+                    Element element = null;
+                    if (!marshalDesc.getAnnotationDesc(pd.getParameterActualType()).hasXmlRootElement()) {
+                        element = new Element(value, qName, pd.getParameterActualType());
+                    } else {
+                        element = new Element(value, qName);
                     }
-                    pvList.add(new PDElement(pd, value));
+                    pvList.add(new PDElement(pd,element));
                     bodyIndex++;
                 } else {
                     // Header
@@ -335,7 +339,8 @@
                     String localName = pd.getParameterName();
                     block = message.getHeaderBlock(pd.getTargetNamespace(), localName, blockContext, factory);
                     Object value = block.getBusinessObject(true);
-                    pvList.add(new PDElement(pd, value));
+                    Element element = new Element(value, new QName(pd.getTargetNamespace(), localName));
+                    pvList.add(new PDElement(pd, element));
                 }
                 
             }
@@ -396,7 +401,8 @@
             // The first step is to convert the signature arguments into a list
             // of parameter values
             List<PDElement> pdeList = 
-                MethodMarshallerUtils.getPDElements(pds,
+                MethodMarshallerUtils.getPDElements(marshalDesc,
+                        pds,
                         signatureArgs, 
                         false,  // output
                         true, false);   
@@ -415,10 +421,7 @@
                 if (!pde.getParam().isHeader()) {
                     // Normal case
                     // The object list contains type rendered objects
-                    Object value = pde.getElementValue();
-                    if (value instanceof JAXBElement) {
-                        value = ((JAXBElement) value).getValue();
-                    }  
+                    Object value = pde.getElement().getTypeValue();
                     nameList.add(name);
                     objectList.put(name, value);
                 } else {
@@ -443,9 +446,16 @@
                 // Header Result:
                 // Put the return object onto the message
                 if (returnType != void.class) {
-                    MethodMarshallerUtils.toMessage(returnObject, returnType,
-                            operationDesc.getResultTargetNamespace(),
-                            operationDesc.getResultName(), packages, m, 
+                    Element returnElement = null;
+                    QName returnQName = new QName(operationDesc.getResultTargetNamespace(),
+                            operationDesc.getResultName());
+                    if (marshalDesc.getAnnotationDesc(returnType).hasXmlRootElement()) {
+                        returnElement = new Element(returnObject, returnQName);
+                    } else {
+                        returnElement = new Element(returnObject, returnQName, returnType);
+                    }
+                    MethodMarshallerUtils.toMessage(returnElement, returnType,
+                            marshalDesc, m, 
                             false, // don't force xsi:type for doc/lit
                             true); 
                 }
@@ -456,11 +466,14 @@
             JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
             Object object  = wrapperTool.wrap(cls, nameList, objectList);
             
+            QName wrapperQName = new QName(operationDesc.getResponseWrapperTargetNamespace(),
+                                           operationDesc.getResponseWrapperLocalName());
+
             // Make sure object can be rendered as an element
-            if (!XMLRootElementUtil.isElementEnabled(cls)) {
+            if (!marshalDesc.getAnnotationDesc(cls).hasXmlRootElement()) {
                 object = XMLRootElementUtil.getElementEnabledObject(
-                        operationDesc.getResponseWrapperTargetNamespace(), 
-                        operationDesc.getResponseWrapperLocalName(), 
+                        wrapperQName.getNamespaceURI(),
+                        wrapperQName.getLocalPart(),
                         cls, 
                         object);
             }
@@ -472,7 +485,7 @@
             
             Block block = factory.createFrom(object, 
                     new JAXBBlockContext(packages), 
-                    null);  // The factory will get the qname from the value
+                    wrapperQName);  // The factory will get the qname from the value
             m.setBodyBlock(block);
             
             //  Now place the headers in the message
@@ -524,7 +537,8 @@
             // The signatureArguments represent the child elements of that block
             // The first step is to convert the signature arguments into list
             // of parameter values
-            List<PDElement> pdeList = MethodMarshallerUtils.getPDElements(pds, 
+            List<PDElement> pdeList = MethodMarshallerUtils.getPDElements(marshalDesc,
+                    pds, 
                     signatureArguments, 
                     true,   // input
                     true, false); 
@@ -543,10 +557,7 @@
                 if (!pde.getParam().isHeader()) {
                     // Normal case:
                     // The object list contains type rendered objects
-                    Object value = pde.getElementValue();
-                    if (value instanceof JAXBElement) {
-                        value = ((JAXBElement) value).getValue();
-                    }
+                    Object value = pde.getElement().getTypeValue();
                     nameList.add(name);
                     objectList.put(name, value);
                 } else {
@@ -563,11 +574,14 @@
             JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
             Object object  = wrapperTool.wrap(cls, nameList, objectList);
             
+            QName wrapperQName = new QName(operationDesc.getRequestWrapperTargetNamespace(),
+                                           operationDesc.getRequestWrapperLocalName());
+
             // Make sure object can be rendered as an element
-            if (!XMLRootElementUtil.isElementEnabled(cls)) {
+            if (!marshalDesc.getAnnotationDesc(cls).hasXmlRootElement()) {
                 object = XMLRootElementUtil.getElementEnabledObject(
-                        operationDesc.getRequestWrapperTargetNamespace(), 
-                        operationDesc.getRequestWrapperLocalName(), 
+                        wrapperQName.getNamespaceURI(),
+                        wrapperQName.getLocalPart(),
                         cls, 
                         object);
             }
@@ -577,7 +591,7 @@
                 (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
             Block block = factory.createFrom(object, 
                     new JAXBBlockContext(packages), 
-                    null);  // The factory will get the qname from the value
+                    wrapperQName);  // The factory will get the qname from the value
             m.setBodyBlock(block);
             
             // Now place the headers in the message
@@ -614,8 +628,8 @@
             
             // Put the fault onto the message
             MethodMarshallerUtils.marshalFaultResponse(throwable, 
+                    marshalDesc,
                     operationDesc, 
-                    packages, 
                     m, 
                     false); // don't force xsi:type for doc/lit
             return m;
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitBareMethodMarshaller.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitBareMethodMarshaller.java	(revision 505591)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitBareMethodMarshaller.java	(working copy)
@@ -21,6 +21,7 @@
 import java.util.List;
 import java.util.TreeSet;
 
+import javax.xml.namespace.QName;
 import javax.xml.ws.WebServiceException;
 
 import org.apache.axis2.jaxws.ExceptionFactory;
@@ -79,16 +80,18 @@
             Object returnValue = null;
             if (returnType != void.class) {
                 // If the webresult is in the header, we need the name of the header so that we can find it.
+                Element returnElement = null;
                 if (operationDesc.isResultHeader()) {
-                    returnValue = MethodMarshallerUtils.getReturnValue(packages, message, null, true,
+                    returnElement = MethodMarshallerUtils.getReturnElement(packages, message, null, true,
                             operationDesc.getResultTargetNamespace(), operationDesc.getResultName());
                 } else {
-                    returnValue = MethodMarshallerUtils.getReturnValue(packages, message, null, false, null, null);
+                    returnElement = MethodMarshallerUtils.getReturnElement(packages, message, null, false, null, null);
                 }
                 //TODO should we allow null if the return is a header?
                 //Validate input parameters for operation and make sure no input parameters are null.
                 //As per JAXWS Specification section 3.6.2.3 if a null value is passes as an argument 
                 //to a method then an implementation MUST throw WebServiceException.
+                returnValue = returnElement.getTypeValue();
                 if (returnValue == null){
                     throw ExceptionFactory.makeWebServiceException(Messages.getMessage("NullParamErr1", "Return", operationDesc.getJavaMethodName(), "doc/lit"));
                 }
@@ -208,15 +211,23 @@
                     throw ExceptionFactory.makeWebServiceException(Messages.getMessage("NullParamErr1", "Return", operationDesc.getJavaMethodName(), "doc/lit"));
 
                 }
-                MethodMarshallerUtils.toMessage(returnObject, returnType,
-                        operationDesc.getResultTargetNamespace(),
-                        operationDesc.getResultName(), packages, m, 
+                Element returnElement = null;
+                QName returnQName = new QName(operationDesc.getResultTargetNamespace(),
+                        operationDesc.getResultName());
+                if (marshalDesc.getAnnotationDesc(returnType).hasXmlRootElement()) {
+                    returnElement = new Element(returnObject, returnQName);
+                } else {
+                    returnElement = new Element(returnObject, returnQName, returnType);
+                }
+                MethodMarshallerUtils.toMessage(returnElement, returnType,
+                        marshalDesc, m, 
                         false, // don't force xsi:type for doc/lit
                         operationDesc.isResultHeader()); 
             }
             
             // Convert the holder objects into a list of JAXB objects for marshalling
-            List<PDElement> pvList = MethodMarshallerUtils.getPDElements(pds, 
+            List<PDElement> pvList = MethodMarshallerUtils.getPDElements(marshalDesc,
+                    pds, 
                     signatureArgs, 
                     false, // output
                     false, false);
@@ -282,7 +293,8 @@
             // The input object represent the signature arguments.
             // Signature arguments are both holders and non-holders
             // Convert the signature into a list of JAXB objects for marshalling
-            List<PDElement> pvList = MethodMarshallerUtils.getPDElements(pds, 
+            List<PDElement> pvList = MethodMarshallerUtils.getPDElements(marshalDesc,
+                    pds, 
                     signatureArguments, 
                     true,  // input
                     false, false);
@@ -318,8 +330,8 @@
             
             // Put the fault onto the message
             MethodMarshallerUtils.marshalFaultResponse(throwable, 
-                    operationDesc, 
-                    packages, 
+                    marshalDesc,
+                    operationDesc,  
                     m, 
                     false); // don't force xsi:type for doc/lit
             return m;
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/RPCLitMethodMarshaller.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/RPCLitMethodMarshaller.java	(revision 505591)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/RPCLitMethodMarshaller.java	(working copy)
@@ -119,15 +119,16 @@
             // The input object represent the signature arguments.
             // Signature arguments are both holders and non-holders
             // Convert the signature into a list of JAXB objects for marshalling
-            List<PDElement> pvList = 
-                MethodMarshallerUtils.getPDElements(pds, 
+            List<PDElement> pdeList = 
+                MethodMarshallerUtils.getPDElements(marshalDesc,
+                        pds,
                         signatureArguments,
                         true,  // input
                         false, true); // use partName since this is rpc/lit
                         
             
             // Put values onto the message
-            MethodMarshallerUtils.toMessage(pvList, m, packages, true);
+            MethodMarshallerUtils.toMessage(pdeList, m, packages, true);
             
             return m;
         } catch(Exception e) {
@@ -279,12 +280,16 @@
                     throw ExceptionFactory.makeWebServiceException(Messages.getMessage("NullParamErr1", "Return", operationDesc.getJavaMethodName(), "rpc/lit"));
 
                 }
-                
-                MethodMarshallerUtils.toMessage(returnObject, 
+                Element returnElement = null;
+                QName returnQName = new QName(returnNS, returnLocalPart);
+                if (marshalDesc.getAnnotationDesc(returnType).hasXmlRootElement()) {
+                    returnElement = new Element(returnObject, returnQName);
+                } else {
+                    returnElement = new Element(returnObject, returnQName, returnType);
+                }
+                MethodMarshallerUtils.toMessage(returnElement, 
                         returnType, 
-                        returnNS,
-                        returnLocalPart, 
-                        packages, 
+                        marshalDesc, 
                         m,
                         true, // forceXSI since this is rpc/lit
                         operationDesc.isResultHeader()); 
@@ -292,7 +297,8 @@
             
             // Convert the holder objects into a list of JAXB objects for marshalling
             List<PDElement> pvList = 
-                MethodMarshallerUtils.getPDElements(pds, 
+                MethodMarshallerUtils.getPDElements(marshalDesc,
+                        pds, 
                         signatureArgs, 
                         false,  // output
                         false, true);   // use partName since this is rpc/lit
@@ -348,12 +354,14 @@
             Object returnValue = null;
             if (returnType != void.class) {
                 // If the webresult is in the header, we need the name of the header so that we can find it.
+                Element returnElement = null;
                 if (operationDesc.isResultHeader()) {
-                    returnValue = MethodMarshallerUtils.getReturnValue(packages, message, returnType, true,
+                    returnElement = MethodMarshallerUtils.getReturnElement(packages, message, returnType, true,
                             operationDesc.getResultTargetNamespace(), operationDesc.getResultPartName());
                 } else {
-                    returnValue = MethodMarshallerUtils.getReturnValue(packages, message, returnType, false, null, null);
+                    returnElement = MethodMarshallerUtils.getReturnElement(packages, message, returnType, false, null, null);
                 }
+                returnValue = returnElement.getTypeValue();
                 // TODO should we allow null if the return is a header?
                 //Validate input parameters for operation and make sure no input parameters are null.
                 //As per JAXWS Specification section 3.6.2.3 if a null value is passes as an argument 
@@ -404,8 +412,8 @@
             
             // Put the fault onto the message
             MethodMarshallerUtils.marshalFaultResponse(throwable, 
+                    marshalDesc,
                     operationDesc, 
-                    packages, 
                     m, 
                     true);  // isRPC=true
             return m;
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/Element.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/Element.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/Element.java	(revision 0)
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.jaxws.marshaller.impl.alt;
+
+import javax.xml.bind.JAXBElement;
+import javax.xml.namespace.QName;
+
+/**
+ * Characteristics of the "Element" value.
+ *    * The Element value is ready for marshalling or is the result of unmarshalling.
+ *    * The Element value represents the element rendering.  Thus it is either
+ *      a JAXBElement or has the @XmlRootElement annotation.  (i.e. it is never a 
+ *      java.lang.String)
+ *    * The Element value is not a JAX-WS object. (i.e. it is not a holder or exception)
+ * Characteristis of the "Type" value
+ *    * It is the type value associated with the element value.  (Thus it is either
+ *      the element value or it is value of the JAXBElement
+ *    * The type value is usually the object needed for the method signature (i.e. String)
+ */
+public class Element {
+
+    private QName qName;
+    private Object elementValue;
+    private Object typeValue;
+    private Class typeClass;
+    
+    /**
+     * Create Element from an
+     * @param elementValue must be JAXBElement or @XmlRootElement rendered
+     * @param qName associated QName
+     */
+    public Element(Object elementValue, QName qName) {
+        if (elementValue != null) {
+            this.qName = qName;
+            this.elementValue = elementValue;
+        } else {
+            this.qName = qName;
+            this.typeValue = null;
+            this.typeClass = Object.class;
+        }
+    }
+    
+    /**
+     * @param typeValue must not be a JAXBElement.  Must not have @XmlRootElement rendering.
+     *        typeValue must not be a Holder or other JAXWS api value.
+     * @param qName associated QName
+     * @param cls
+     */
+    public Element(Object typeValue, QName qName, Class cls) {
+        this.qName = qName;
+        this.typeValue = typeValue;
+        this.typeClass = cls;
+        
+    }
+    
+    public Object getElementValue() {
+        if (elementValue == null) {
+            // Create ElementValue from type information
+            elementValue= new JAXBElement(qName, typeClass, typeValue);
+        }
+        return elementValue;
+    }
+    
+    public Object getTypeValue() {
+        if (elementValue != null) {
+            if (elementValue.getClass() == JAXBElement.class) {
+                return ((JAXBElement) elementValue).getValue();
+            } else {
+                return elementValue;
+            }
+        } else {
+            return typeValue;
+        }
+    }
+
+    public QName getQName() {
+        return qName;
+    }
+}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/MethodMarshallerUtils.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/MethodMarshallerUtils.java	(revision 505614)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/MethodMarshallerUtils.java	(working copy)
@@ -87,6 +87,7 @@
     /**
      * Returns the list of PDElements that need to be marshalled onto the wire
      * 
+     * @param marshalDesc
      * @param params ParameterDescription for this operation
      * @param sigArguments arguments 
      * @param isInput indicates if input or output  params(input args on client, output args on server)
@@ -94,8 +95,9 @@
      * @param isRPC
      * @return PDElements
      */
-    static List<PDElement> getPDElements(ParameterDescription[] params, Object[] sigArguments, boolean isInput, boolean isDocLitWrapped, boolean isRPC) {
-        List<PDElement> pvList = new ArrayList<PDElement>();
+    static List<PDElement> getPDElements(MarshalServiceRuntimeDescription marshalDesc,
+            ParameterDescription[] params, Object[] sigArguments, boolean isInput, boolean isDocLitWrapped, boolean isRPC) {
+        List<PDElement> pdeList = new ArrayList<PDElement>();
         
         int index = 0;
         for (int i=0; i<params.length; i++) {
@@ -122,39 +124,36 @@
                 // Get the formal type representing the value
                 Class formalType = pd.getParameterActualType();
                 
-                // If this value is element enabled, then we are okay
-                // Otherwise make an element enabled value
-                if (!XMLRootElementUtil.isElementEnabled(formalType)) {
-                    
-                    // The namespace and local name are obtained differently depending on the style/use and header
-                    String localName = "";
-                    String uri = "";
-                    if (pd.isHeader()) {
-                        // Headers (even rpc) are marshalled with the name defined by the element= attribute on the wsd:part
-                        localName = pd.getParameterName();
-                        uri = pd.getTargetNamespace();
-                        
-                    } else if (isDocLitWrapped) {
-                        // For doc/lit wrapped, the localName comes from the PartName
-                        localName = pd.getPartName();
-                        uri = pd.getTargetNamespace();
-                    } else if (isRPC) {
-                        localName = pd.getPartName();
-                        uri = "";  // Per WSI-BP, the namespace uri is unqualified
-                    } else {
-                        localName = pd.getParameterName();
-                        uri = pd.getTargetNamespace();
-                    }
-                    value = XMLRootElementUtil.getElementEnabledObject(uri, localName, formalType, value);
+                // The namespace and local name are obtained differently depending on the style/use and header
+                QName qName = null;
+                if (pd.isHeader()) {
+                    // Headers (even rpc) are marshalled with the name defined by the element= attribute on the wsd:part
+                    qName = new QName(pd.getTargetNamespace(), pd.getParameterName());                    
+                } else if (isDocLitWrapped) {
+                    // For doc/lit wrapped, the localName comes from the PartName
+                    qName = new QName(pd.getTargetNamespace(), pd.getPartName());    
+                } else if (isRPC) {
+                    // Per WSI-BP, the namespace uri is unqualified
+                    qName = new QName(pd.getPartName());    
+                } else {
+                    qName = new QName(pd.getTargetNamespace(), pd.getParameterName());  
                 }
                 
+                // Create an Element rendering
+                Element element = null;
+                if (!marshalDesc.getAnnotationDesc(formalType).hasXmlRootElement()) {
+                    element = new Element(value, qName, formalType);
+                } else {
+                    element = new Element(value, qName);
+                }
+                
                 // The object is now ready for marshalling
-                PDElement pv = new PDElement(pd, value);
-                pvList.add(pv);
+                PDElement pde = new PDElement(pd, element);
+                pdeList.add(pde);
             }
         }
         
-        return pvList;
+        return pdeList;
     }
     
     /**
@@ -231,9 +230,9 @@
                     index++;
                 }
                 
-                // The object is now ready for marshalling
-                PDElement pv = new PDElement(pd, block.getBusinessObject(true));
-                pdeList.add(pv);
+                Element element = new Element(block.getBusinessObject(true), block.getQName());
+                PDElement pde = new PDElement(pd, element);
+                pdeList.add(pde);
             }
         }
         
@@ -250,16 +249,16 @@
      * @throws IllegalAccessException
      * @throws ClassNotFoundException
      */
-    static Object[] createRequestSignatureArgs(ParameterDescription[] pds, List<PDElement> pvList) 
+    static Object[] createRequestSignatureArgs(ParameterDescription[] pds, List<PDElement> pdeList) 
         throws InstantiationException, IllegalAccessException, ClassNotFoundException {
         Object[] args = new Object[pds.length];
-        int pvIndex = 0;
+        int pdeIndex = 0;
         for (int i=0; i< args.length; i++) {
             // Get the paramValue
-            PDElement pv = (pvIndex < pvList.size()) ? pvList.get(pvIndex) : null;
+            PDElement pde = (pdeIndex < pdeList.size()) ? pdeList.get(pdeIndex) : null;
             ParameterDescription pd = pds[i];
-            if (pv == null ||
-                pv.getParam() != pd) {
+            if (pde == null ||
+                pde.getParam() != pd) {
                 // We have a ParameterDesc but there is not an equivalent PDElement. 
                 // Provide the default
                 if (pd.isHolderType()) {
@@ -269,13 +268,10 @@
                 }
             } else {
           
-                // We have a matching paramValue
-                Object value = pv.getElementValue();
-                pvIndex++;
+                // We have a matching paramValue.  Get the type object that represents the type
+                Object value = pde.getElement().getTypeValue();
+                pdeIndex++;
                 
-                // The signature wants the object that is rendered as the type
-                value = XMLRootElementUtil.getTypeEnabledObject(value);
-                
                 // Now that we have the type, there may be a mismatch
                 // between the type (as defined by JAXB) and the formal
                 // parameter (as defined by JAXWS).  Frequently this occurs
@@ -304,32 +300,29 @@
     /**
      * Update the signature arguments on the client with the unmarshalled element enabled objects (pvList)
      * @param pds ParameterDescriptions
-     * @param pvList Element Enabled objects
+     * @param pdeList Element Enabled objects
      * @param signatureArgs Signature Arguments (the out/inout holders are updated)
      * @throws InstantiationException
      * @throws IllegalAccessException
      * @throws ClassNotFoundException
      */
-    static void updateResponseSignatureArgs(ParameterDescription[] pds, List<PDElement> pvList, Object[] signatureArgs) 
+    static void updateResponseSignatureArgs(ParameterDescription[] pds, List<PDElement> pdeList, Object[] signatureArgs) 
             throws InstantiationException, IllegalAccessException, ClassNotFoundException {
-        int pvIndex = 0;
+        int pdeIndex = 0;
         
         // Each ParameterDescriptor has a correspondinging signatureArg from the 
         // the initial client call.  The pvList contains the response values from the message.
         // Walk the ParameterDescriptor/SignatureArg list and populate the holders with 
         // the match PDElement
         for (int i=0; i< pds.length; i++) {
-            // Get the paramValue
-            PDElement pv = (pvIndex < pvList.size()) ? pvList.get(pvIndex) : null;
+            // Get the param value
+            PDElement pde = (pdeIndex < pdeList.size()) ? pdeList.get(pdeIndex) : null;
             ParameterDescription pd = pds[i];
-            if (pv != null && pv.getParam() == pd) {   
-                // We have a matching paramValue
-                Object value = pv.getElementValue();
-                pvIndex++;
+            if (pde != null && pde.getParam() == pd) {   
+                // We have a matching paramValue.  Get the value that represents the type
+                Object value = pde.getElement().getTypeValue();
+                pdeIndex++;
                 
-                // The signature wants the object that is rendered as the type
-                value = XMLRootElementUtil.getTypeEnabledObject(value);
-                
                 // Now that we have the type, there may be a mismatch
                 // between the type (as defined by JAXB) and the formal
                 // parameter (as defined by JAXWS).  Frequently this occurs
@@ -386,9 +379,9 @@
             // (Note that the PDElement.getValue always returns an object
             // that has an element rendering...ie. it is either a JAXBElement o
             // has @XmlRootElement defined
-            Block block = factory.createFrom(pde.getElementValue(), 
+            Block block = factory.createFrom(pde.getElement().getElementValue(),
                     context, 
-                    null);  // The factory will get the qname from the value
+                    pde.getElement().getQName());  
             
             if (pde.getParam().isHeader()) {
                 // Header block
@@ -411,21 +404,17 @@
     
     /**
      * Marshals the return object to the message (used on server to marshal return object)
-     * @param returnValue
+     * @param returnElement element
      * @param returnType
-     * @param returnNS
-     * @param returnLocalPart
-     * @param packages
+     * @param marshalDesc
      * @param message
      * @param isRPC
      * @param isHeader
      * @throws MessageException
      */
-    static void toMessage(Object returnValue, 
+    static void toMessage(Element returnElement, 
             Class returnType, 
-            String returnNS, 
-            String returnLocalPart, 
-            TreeSet<String> packages, 
+            MarshalServiceRuntimeDescription marshalDesc,
             Message message, 
             boolean isRPC,
             boolean isHeader)
@@ -433,24 +422,18 @@
         
         // Create the JAXBBlockContext
         // RPC uses type marshalling, so recored the rpcType
-        JAXBBlockContext context = new JAXBBlockContext(packages);
+        JAXBBlockContext context = new JAXBBlockContext(marshalDesc.getPackages());
         if (isRPC) {
             context.setRPCType(returnType);
         }
         
-        // If this type is an element rendering, then we are okay
-        // If it is a type rendering then make a JAXBElement 
-        if (!XMLRootElementUtil.isElementEnabled(returnType)) {
-            returnValue = XMLRootElementUtil.getElementEnabledObject(returnNS, returnLocalPart,returnType, returnValue);
-        }
-        
         //  Create a JAXBBlock out of the value.
-        Block block = factory.createFrom(returnValue, 
+        Block block = factory.createFrom(returnElement.getElementValue(), 
                 context, 
-                null);  // The factory will get the qname from the value
+                returnElement.getQName());  
         
         if (isHeader) {
-            message.setHeaderBlock(returnNS, returnLocalPart, block);
+            message.setHeaderBlock(returnElement.getQName().getNamespaceURI(), returnElement.getQName().getLocalPart(), block);
         } else {
             message.setBodyBlock(block);
         }
@@ -464,11 +447,11 @@
      * @param isHeader
      * @param headerNS (only needed if isHeader)
      * @param headerLocalPart (only needed if isHeader)
-     * @return type enabled object
+     * @return Element
      * @throws WebService
      * @throws XMLStreamException
      */
-    static Object getReturnValue(TreeSet<String> packages, 
+    static Element getReturnElement(TreeSet<String> packages, 
             Message message, 
             Class rpcType,
             boolean isHeader,
@@ -490,10 +473,8 @@
         }
         
         // Get the business object.  We want to return the object that represents the type.
-        Object returnValue = block.getBusinessObject(true);
-        //  The signature wants the object that is rendered as the type
-        returnValue = XMLRootElementUtil.getTypeEnabledObject(returnValue);
-        return returnValue;
+        Element returnElement = new Element(block.getBusinessObject(true), block.getQName());
+        return returnElement;
     }
     
     /**
@@ -506,8 +487,8 @@
      * @param isRPC
      */
     static void marshalFaultResponse(Throwable throwable, 
+            MarshalServiceRuntimeDescription marshalDesc,
             OperationDescription operationDesc,  
-            TreeSet<String> packages, 
             Message message, 
             boolean isRPC) {
         // Get the root cause of the throwable object
@@ -559,7 +540,7 @@
                     log.debug("The faultBean type is" + faultBeanObject.getClass().getName());
                 }
                 // Make sure the faultBeanObject can be marshalled as an element
-                if (!XMLRootElementUtil.isElementEnabled(faultBeanObject.getClass())) {
+                if (!marshalDesc.getAnnotationDesc(faultBeanObject.getClass()).hasXmlRootElement()) {
                     faultBeanObject = XMLRootElementUtil.getElementEnabledObject(fd.getTargetNamespace(), fd.getName(), 
                             faultBeanObject.getClass(), faultBeanObject);
                 }
@@ -567,14 +548,15 @@
                 
                 // Create the JAXBBlockContext
                 // RPC uses type marshalling, so recored the rpcType
-                JAXBBlockContext context = new JAXBBlockContext(packages);
+                JAXBBlockContext context = new JAXBBlockContext(marshalDesc.getPackages());
                 if (isRPC) {
                     context.setRPCType(faultBeanObject.getClass());
                 }
                 
+                QName faultBeanQName = new QName(fd.getTargetNamespace(), fd.getName());
                 // Create a detailblock representing the faultBeanObject
                 Block[] detailBlocks = new Block[1];
-                detailBlocks[0] = factory.createFrom(faultBeanObject,context,null);
+                detailBlocks[0] = factory.createFrom(faultBeanObject,context,faultBeanQName);
                 
                 if (log.isErrorEnabled()) {
                     log.debug("Create the xmlFault for the Service Exception");
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitWrappedMethodMarshaller.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitWrappedMethodMarshaller.java	(revision 505614)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/DocLitWrappedMethodMarshaller.java	(working copy)
@@ -26,6 +26,7 @@
 
 import javax.jws.WebParam.Mode;
 import javax.xml.bind.JAXBElement;
+import javax.xml.namespace.QName;
 import javax.xml.ws.WebServiceException;
 
 import org.apache.axis2.jaxws.ExceptionFactory;
@@ -137,14 +138,16 @@
                 ParameterDescription pd = pdList.get(i);
                 Object value = objects[i];
                 // The object in the PDElement must be an element
-                if (!XMLRootElementUtil.isElementEnabled(pd.getParameterActualType())) {
-                    value = XMLRootElementUtil.getElementEnabledObject(pd.getTargetNamespace(),
-                            pd.getPartName(), 
-                            pd.getParameterActualType(), 
-                            value); 
+                Element element = null;
+                QName qName = new QName(pd.getTargetNamespace(), pd.getPartName());
+                if (!marshalDesc.getAnnotationDesc(pd.getParameterActualType()).hasXmlRootElement()) {
+                    element = new Element(value, qName, 
+                            pd.getParameterActualType());
      
+                } else {
+                    element = new Element(value, qName);
                 }
-                pvList.add(new PDElement(pd, value));
+                pvList.add(new PDElement(pd, element));
             }
             
             // Populate the response Holders in the signature
@@ -235,14 +238,15 @@
                 ParameterDescription pd = pdList.get(i);
                 Object value = objects[i];
                 // The object in the PDElement must be an element
-                if (!XMLRootElementUtil.isElementEnabled(pd.getParameterActualType())) {
-                    value = XMLRootElementUtil.getElementEnabledObject(pd.getTargetNamespace(),
-                            pd.getPartName(), 
-                            pd.getParameterActualType(), 
-                            value);
-     
+                Element element = null;
+                QName qName = new QName(pd.getTargetNamespace(),
+                        pd.getPartName());
+                if (!marshalDesc.getAnnotationDesc(pd.getParameterActualType()).hasXmlRootElement()) {
+                    element = new Element(value, qName,  pd.getParameterActualType());
+                } else {
+                    element = new Element(value, qName);
                 }
-                pvList.add(new PDElement(pd, value));
+                pvList.add(new PDElement(pd, element));
             }
              
             // Build the signature arguments
@@ -298,8 +302,9 @@
             // The signatureArguments represent the child elements of that block
             // The first step is to convert the signature arguments into a list
             // of parameter values
-            List<PDElement> pvList = 
-                MethodMarshallerUtils.getPDElements(pds,
+            List<PDElement> pdeList = 
+                MethodMarshallerUtils.getPDElements(marshalDesc,
+                        pds,
                         signatureArgs, 
                         false,  // output
                         true, false); 
@@ -310,14 +315,11 @@
             ArrayList<String> nameList = new ArrayList<String>();
             Map<String, Object> objectList = new HashMap<String, Object>();
             
-            for(PDElement pv:pvList) {
-                String name = pv.getParam().getParameterName();
+            for(PDElement pde:pdeList) {
+                String name = pde.getParam().getParameterName();
             
                 // The object list contains type rendered objects
-                Object value = pv.getElementValue();
-                if (value instanceof JAXBElement) {
-                    value = ((JAXBElement) value).getValue();
-                }
+                Object value = pde.getElement().getTypeValue();
                 nameList.add(name);
                 objectList.put(name, value);
             }
@@ -335,11 +337,14 @@
             JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
             Object object  = wrapperTool.wrap(cls, nameList, objectList);
             
+            QName wrapperQName = new QName(operationDesc.getResponseWrapperTargetNamespace(),
+                                           operationDesc.getResponseWrapperLocalName());
+
             // Make sure object can be rendered as an element
-            if (!XMLRootElementUtil.isElementEnabled(cls)) {
+            if (!marshalDesc.getAnnotationDesc(cls).hasXmlRootElement()) {
                 object = XMLRootElementUtil.getElementEnabledObject(
-                        operationDesc.getResponseWrapperTargetNamespace(), 
-                        operationDesc.getResponseWrapperLocalName(), 
+                        wrapperQName.getNamespaceURI(),
+                        wrapperQName.getLocalPart(),
                         cls, 
                         object);
             }
@@ -351,7 +356,7 @@
             
             Block block = factory.createFrom(object, 
                     new JAXBBlockContext(packages), 
-                    null);  // The factory will get the qname from the value
+                    wrapperQName);  
             m.setBodyBlock(block);
             
             return m;
@@ -396,7 +401,8 @@
             // The signatureArguments represent the child elements of that block
             // The first step is to convert the signature arguments into list
             // of parameter values
-            List<PDElement> pvList = MethodMarshallerUtils.getPDElements(pds, 
+            List<PDElement> pvList = MethodMarshallerUtils.getPDElements(marshalDesc,
+                    pds, 
                     signatureArguments, 
                     true,   // input
                     true, false);  
@@ -411,10 +417,7 @@
                 String name = pv.getParam().getParameterName();
             
                 // The object list contains type rendered objects
-                Object value = pv.getElementValue();
-                if (value instanceof JAXBElement) {
-                    value = ((JAXBElement) value).getValue();
-                }
+                Object value = pv.getElement().getTypeValue();
                 nameList.add(name);
                 objectList.put(name, value);
             }
@@ -424,11 +427,14 @@
             JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
             Object object  = wrapperTool.wrap(cls, nameList, objectList);
             
+            QName wrapperQName = new QName(operationDesc.getRequestWrapperTargetNamespace(),
+                    operationDesc.getRequestWrapperLocalName());
+                    
             // Make sure object can be rendered as an element
-            if (!XMLRootElementUtil.isElementEnabled(cls)) {
+            if (!marshalDesc.getAnnotationDesc(cls).hasXmlRootElement()) {
                 object = XMLRootElementUtil.getElementEnabledObject(
-                        operationDesc.getRequestWrapperTargetNamespace(), 
-                        operationDesc.getRequestWrapperLocalName(), 
+                        wrapperQName.getNamespaceURI(), 
+                        wrapperQName.getLocalPart(), 
                         cls, 
                         object);
             }
@@ -439,7 +445,7 @@
             
             Block block = factory.createFrom(object, 
                     new JAXBBlockContext(packages), 
-                    null);  // The factory will get the qname from the value
+                    wrapperQName);  
             m.setBodyBlock(block);
             
             return m;
@@ -469,8 +475,8 @@
             
             // Put the fault onto the message
             MethodMarshallerUtils.marshalFaultResponse(throwable, 
+                    marshalDesc,
                     operationDesc, 
-                    packages, 
                     m, 
                     false); // don't force xsi:type for doc/lit
             return m;
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/PDElement.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/PDElement.java	(revision 505591)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/alt/PDElement.java	(working copy)
@@ -22,32 +22,26 @@
 
 
 /**
- * A PDElement object holds a ParameterDescription (Param) and 
- * the "Element" value.
- * Characteristics of the "Element" value.
- *    * The Element value is ready for marshalling or is the result of unmarshalling.
- *    * The Element value represents the element rendering.  Thus it is either
- *      a JAXBElement or has the @XmlRootElement annotation.  (i.e. it is never a 
- *      java.lang.String)
- *    * The Element value is not a JAX-WS object. (i.e. it is not a holder or exception)
+ * A PDElement object holds a ParameterDescription and the matching 
+ * Element object
  */
 public class PDElement {
     private ParameterDescription param;
-    private Object elementValue;
+    private Element element;
     
-    public PDElement(ParameterDescription param, Object elementValue) {
+    public PDElement(ParameterDescription param, Element element) {
         super();
         this.param = param;
-        this.elementValue = elementValue;
+        this.element = element;
     }
 
     public ParameterDescription getParam() {
         return param;
     }
 
-    public Object getElementValue() {
+    public Element getElement() {
        
-        return elementValue;
+        return element;
     }
     
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/utility/XMLRootElementUtil.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/utility/XMLRootElementUtil.java	(revision 505614)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/utility/XMLRootElementUtil.java	(working copy)
@@ -26,7 +26,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
-import java.util.WeakHashMap;
+import java.util.HashMap;
 
 import javax.xml.bind.JAXBElement;
 import javax.xml.bind.annotation.XmlElement;
@@ -101,7 +101,6 @@
         if (clazz.equals(JAXBElement.class)) {
             return true;
         }
-        
         // If the clazz is a primitive, then it does not have a corresponding root element.
         if (clazz.isPrimitive() || ClassUtils.getWrapperClass(clazz) != null) {
             return false;
@@ -112,34 +111,8 @@
         return root !=null;
     }
     
-    /**
-     * Returns ture if this class is type enabled
-     * @param clazz
-     * @return
-     */
-    public static boolean isTypeEnabled(Class clazz) {
-        // Primitives, Primitive wrappers, BigDecimal, etc. are all type enabled
-        // So are all classes with @XmlRootElement or @XmlType.
-        // For now I am only going to assume that the class is type enabled unless it is JAXBElement
-        return (!clazz.equals(JAXBElement.class));
-    }
     
     /**
-     * Return type enabled object
-     * @param obj type or element enabled object
-     * @return type enabled object
-     */
-    public static Object getTypeEnabledObject(Object obj) {
-        if (obj == null) {
-            return null;
-        }
-        if (obj instanceof JAXBElement) {
-            return ((JAXBElement) obj).getValue();
-        }
-        return obj;
-    }
-    
-    /**
      * Return an object that can be marshalled/unmarshalled as an element
      * If the specified object is already element enabled, it is returned.
      * @param namespace
@@ -172,8 +145,7 @@
         }
         
         Class clazz = (obj instanceof java.lang.Class) ? (Class) obj : obj.getClass();
-        
-        // If the clazz is a primitive, then it does not have a corresponding root element.
+                // If the clazz is a primitive, then it does not have a corresponding root element.
         if (clazz.isPrimitive() ||
                 ClassUtils.getWrapperClass(clazz) != null) {
             return null;
@@ -218,7 +190,7 @@
         // TODO This is a very performance intensive search we should cache the calculated map keyed by the jaxbClass
         PropertyDescriptor[] pds = Introspector.getBeanInfo(jaxbClass).getPropertyDescriptors();
         // Make this a weak map in case we want to cache the results
-        Map<String, PropertyDescriptor> map = new WeakHashMap<String, PropertyDescriptor>();
+        Map<String, PropertyDescriptor> map = new HashMap<String, PropertyDescriptor>();
         
         // Unfortunately the element names are stored on the fields.
         // Get all of the fields in the class and super classes
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatch.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatch.java	(revision 505591)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatch.java	(working copy)
@@ -34,6 +34,7 @@
 import org.apache.axis2.jaxws.message.factory.XMLStringBlockFactory;
 import org.apache.axis2.jaxws.registry.FactoryRegistry;
 import org.apache.axis2.jaxws.spi.ServiceDelegate;
+import org.apache.axis2.jaxws.utility.XMLRootElementUtil;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -73,7 +74,8 @@
                 context = new JAXBBlockContext(clazz.getPackage().getName());
             }
             // Create a block from the value
-            Block block = factory.createFrom(value, context, null);
+            QName qName = XMLRootElementUtil.getXmlRootElementQName(value);
+            Block block = factory.createFrom(value, context, qName);
             MessageFactory mf = (MessageFactory) FactoryRegistry.getFactory(MessageFactory.class);
             
             if (mode.equals(Mode.PAYLOAD)) {
