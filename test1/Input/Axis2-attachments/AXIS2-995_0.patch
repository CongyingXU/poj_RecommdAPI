Index: modules/adb-codegen/src/org/apache/axis2/schema/BeanWriterMetaInfoHolder.java
===================================================================
--- modules/adb-codegen/src/org/apache/axis2/schema/BeanWriterMetaInfoHolder.java	(revision 430113)
+++ modules/adb-codegen/src/org/apache/axis2/schema/BeanWriterMetaInfoHolder.java	(working copy)
@@ -41,6 +41,8 @@
     protected boolean restriction = false;
     private String extensionClassName = "";
     private String restrictionClassName = "";
+    private QName extensionBaseType = null; 
+    private QName restrictionBaseType = null; 
     protected Map elementToSchemaQNameMap = new LinkedHashMap();
     protected Map elementToJavaClassMap = new LinkedHashMap();
     protected Map specialTypeFlagMap = new LinkedHashMap();
@@ -49,12 +51,19 @@
     protected Map qNameOrderMap = new LinkedHashMap();
     protected QName ownQname = null;
     protected String ownClassName = null;
+    
+    protected long lengthFacet = -1;
+    protected long maxExclusiveFacet = -1;
+    protected long minExclusiveFacet = -1;
+    protected long maxInclusiveFacet = -1;
+    protected long minInclusiveFacet = -1;
+    protected long maxLengthFacet = -1;
+    protected long minLengthFacet = -1;
+    protected String enumFacet = null;
+    protected String patternFacet = null;
 
     protected List nillableQNameList  = new ArrayList();
 
-
-
-
     //the parent metainfo holder, useful in handling extensions and
     //restrictions
     protected BeanWriterMetaInfoHolder parent = null;
@@ -182,6 +191,42 @@
     }
     
     /**
+     * Sets the extension basetype.
+     *
+     * @param extensionBaseType
+     */
+    public void setExtensionBaseType(QName extensionBaseType) {
+        this.extensionBaseType = extensionBaseType;
+    }
+    
+    /**
+     * Checks if it is a extension base type.
+     *
+     * @param extensionBaseType
+     */
+    public boolean isExtensionBaseType(QName extensionBaseType) {
+        return (this.extensionBaseType == extensionBaseType);
+    }
+    
+    /**
+     * Sets the restriction basetype.
+     *
+     * @param restrictionBaseType
+     */
+    public void setRestrictionBaseType(QName restrictionBaseType) {
+        this.restrictionBaseType = restrictionBaseType;
+    }
+    
+    /**
+     * Checks if it is a restriction base type.
+     *
+     * @param restrictionBaseType
+     */
+    public boolean isRestrictionBaseType(QName restrictionBaseType) {
+        return (this.restrictionBaseType == restrictionBaseType);
+    }
+    
+    /**
      * Gets the ordered status.
      *
      * @return Returns boolean.
@@ -480,4 +525,175 @@
         //the mask it self!
         return (mask==(mask & storedStatus));
     }
+    
+    /**
+     * Sets the length facet.
+     *
+     * @param lengthFacet
+     */
+    public void setLengthFacet(long lengthFacet) {
+    	this.lengthFacet = lengthFacet;
+    }
+    
+    /**
+     * Gets the length facet.
+     *
+     * @return Returns length facet.
+     */
+    public long getLengthFacet() {
+    	return this.lengthFacet;
+    }
+    
+    /**
+     * Sets the maxExclusive.
+     *
+     * @param maxExclusiveFacet
+     */
+    public void setMaxExclusiveFacet(long maxExclusiveFacet) {
+    	this.maxExclusiveFacet = maxExclusiveFacet;
+    }
+    
+    /**
+     * Gets the maxExclusive.
+     *
+     * @return Returns the maxExclusive.
+     */
+    public long getMaxExclusiveFacet() {
+    	return this.maxExclusiveFacet;
+    }
+    
+    /**
+     * Sets the minExclusive.
+     *
+     * @param minExclusiveFacet
+     */
+    public void setMinExclusiveFacet(long minExclusiveFacet) {
+    	this.minExclusiveFacet = minExclusiveFacet;
+    }
+    
+    /**
+     * Gets the minExclusive.
+     *
+     * @return Returns the minExclusive.
+     */
+    public long getMinExclusiveFacet() {
+    	return this.minExclusiveFacet;
+    }
+    
+    /**
+     * Sets the maxInclusive.
+     *
+     * @param maxInclusiveFacet
+     */
+    public void setMaxInclusiveFacet(long maxInclusiveFacet) {
+    	this.maxInclusiveFacet = maxInclusiveFacet;
+    }
+    
+    /**
+     * Gets the maxInclusive.
+     *
+     * @return Returns the maxInclusive.
+     */
+    public long getMaxInclusiveFacet() {
+    	return this.maxInclusiveFacet;
+    }
+    
+    /**
+     * Sets the minInclusive.
+     *
+     * @param minInclusiveFacet
+     */
+    public void setMinInclusiveFacet(long minInclusiveFacet) {
+    	this.minInclusiveFacet = minInclusiveFacet;
+    }
+    
+    /**
+     * Gets the minInclusive.
+     *
+     * @return Returns the minInclusive.
+     */
+    public long getMinInclusiveFacet() {
+    	return this.minInclusiveFacet;
+    }
+    
+    /**
+     * Sets the maxLength.
+     *
+     * @param maxLengthFacet
+     */
+    public void setMaxLengthFacet(long maxLengthFacet) {
+    	this.maxLengthFacet = maxLengthFacet;
+    }
+    
+    /**
+     * Gets the maxLength.
+     *
+     * @return Returns maxLength.
+     */
+    public long getMaxLengthFacet() {
+    	return this.maxLengthFacet;
+    }
+    
+    /**
+     * Sets the minLength.
+     *
+     * @param minLengthFacet
+     */
+    public void setMinLengthFacet(long minLengthFacet) {
+    	this.minLengthFacet = minLengthFacet;
+    }
+    
+    /**
+     * Gets the minLength.
+     *
+     * @return Returns minLength.
+     */
+    public long getMinLengthFacet() {
+    	return this.minLengthFacet;
+    }
+    
+    /**
+     * Sets the enumeration.
+     *
+     * @param enumFacet
+     */
+    public void setEnumFacet(String enumFacet) {
+    	this.enumFacet = enumFacet;
+    }
+    
+    /**
+     * Adds the enumeration.
+     *
+     * @param enumFacet
+     */
+    public void addEnumFacet(String enumFacet) {
+    	this.enumFacet += "|" + enumFacet;
+    }
+    
+    /**
+     * Gets the enumeration.
+     *
+     * @return Returns enumeration.
+     */
+    public String getEnumFacet() {
+    	return this.enumFacet;
+    }
+    
+    /**
+     * Sets the pattern.
+     *
+     * @param patternFacet
+     */
+    public void setPatternFacet(String patternFacet) {
+    	this.patternFacet = patternFacet;
+    }
+    
+    /**
+     * Gets the pattern.
+     *
+     * @return Returns pattern.
+     */
+    public String getPatternFacet() {
+    	return this.patternFacet;
+    }
 }
Index: modules/adb-codegen/src/org/apache/axis2/schema/template/ADBBeanTemplate.xsl
===================================================================
--- modules/adb-codegen/src/org/apache/axis2/schema/template/ADBBeanTemplate.xsl	(revision 430113)
+++ modules/adb-codegen/src/org/apache/axis2/schema/template/ADBBeanTemplate.xsl	(working copy)
@@ -100,6 +100,18 @@
             <xsl:variable name="varName">local<xsl:value-of select="$javaName"/></xsl:variable>
             <xsl:variable name="settingTracker">local<xsl:value-of select="$javaName"/>Tracker</xsl:variable>
 
+			
+            <xsl:variable name="lenFacet"><xsl:value-of select="@lenFacet"/></xsl:variable>
+           	<xsl:variable name="maxLenFacet"><xsl:value-of select="@maxLenFacet"/></xsl:variable>
+           	<xsl:variable name="minLenFacet"><xsl:value-of select="@minLenFacet"/></xsl:variable>
+           	<xsl:variable name="maxExFacet"><xsl:value-of select="@maxExFacet"/></xsl:variable>
+           	<xsl:variable name="minExFacet"><xsl:value-of select="@minExFacet"/></xsl:variable>
+           	<xsl:variable name="maxInFacet"><xsl:value-of select="@maxInFacet"/></xsl:variable>
+           	<xsl:variable name="minInFacet"><xsl:value-of select="@minInFacet"/></xsl:variable>
+           	<xsl:variable name="enumFacet"><xsl:value-of select="@enumFacet"/></xsl:variable>
+           	<xsl:variable name="patternFacet"><xsl:value-of select="@patternFacet"/></xsl:variable>
+            
+			
 			<xsl:choose>
             <xsl:when test="@removed">
            
@@ -328,7 +340,62 @@
                     		//update the setting tracker
                     	<xsl:value-of select="$settingTracker"/> = true;
                     	</xsl:if>
-                   			this.<xsl:value-of select="$varName"/>=param;
+                   		
+                   		<xsl:choose>
+                        <xsl:when test="(@restrictionBaseType)">
+                   		
+                   		<xsl:if test="(@patternFacet)">
+                    		if ( param.matches( <xsl:value-of select="$patternFacet"/> ) {  
+                   				this.<xsl:value-of select="$varName"/>=param;
+                   			}
+                   			else {
+                   				throw new java.lang.RuntimeException();
+                   			}
+                   		</xsl:if>
+						
+						<xsl:if test="(@enumFacet)">
+                    		if ( param.matches( <xsl:value-of select="$enumFacet"/> ) {  
+                   				this.<xsl:value-of select="$varName"/>=param;
+                   			}
+                   			else {
+                   				throw new java.lang.RuntimeException();
+                   			}
+                   		</xsl:if>
+						
+						<xsl:if test="(@lenFacet)">
+                    		if ( param.length() == <xsl:value-of select="@lenFacet"/> ) {  
+                   				this.<xsl:value-of select="$varName"/>=param;
+                   			}
+                   			else {
+                   				throw new java.lang.RuntimeException();
+                   			}
+                   		</xsl:if>
+                   		
+                   		<xsl:if test="(@maxLenFacet) or (@minLenFacet)">
+                    		if ( <xsl:if test="(@minLenFacet)"> <xsl:value-of select="$minLenFacet"/> &lt; </xsl:if> param.length() <xsl:if test="(@maxLenFacet)"> &gt; <xsl:value-of select="$maxLenFacet"/> = </xsl:if> ) {  
+                   				this.<xsl:value-of select="$varName"/>=param;
+                   			}
+                   			else {
+                   				throw new java.lang.RuntimeException();
+                   			}
+                   		</xsl:if>
+                   		
+                   		<xsl:if test="(@maxExFacet) or (@minExFacet) or (@maxInFacet) or (@minInFacet)">
+                    		if ( <xsl:if test="(@minExFacet)"> <xsl:value-of select="$minExFacet"/> &lt; </xsl:if> <xsl:if test="(@minInFacet)"> <xsl:value-of select="$minInFacet"/> &lt;= </xsl:if> param <xsl:if test="(@maxExFacet)"> &gt; <xsl:value-of select="$maxExFacet"/> </xsl:if> <xsl:if test="(@maxInFacet)"> &gt;= <xsl:value-of select="$maxInFacet"/> </xsl:if> ) {
+                    	 
+                   				this.<xsl:value-of select="$varName"/>=param;
+                   			}
+                   			else {
+                   				throw new java.lang.RuntimeException();
+                   			}
+                   		</xsl:if>
+						</xsl:when>
+						
+						<xsl:otherwise>
+								this.<xsl:value-of select="$varName"/>=param;
+						</xsl:otherwise>
+						</xsl:choose>
+
                    		}
                 		</xsl:otherwise>
             		</xsl:choose>
Index: modules/adb-codegen/src/org/apache/axis2/schema/SchemaCompiler.java
===================================================================
--- modules/adb-codegen/src/org/apache/axis2/schema/SchemaCompiler.java	(revision 430113)
+++ modules/adb-codegen/src/org/apache/axis2/schema/SchemaCompiler.java	(working copy)
@@ -36,6 +36,15 @@
 import org.apache.ws.commons.schema.XmlSchemaSimpleTypeRestriction;
 import org.apache.ws.commons.schema.XmlSchemaSimpleTypeUnion;
 import org.apache.ws.commons.schema.XmlSchemaType;
+import org.apache.ws.commons.schema.XmlSchemaPatternFacet;
+import org.apache.ws.commons.schema.XmlSchemaEnumerationFacet;
+import org.apache.ws.commons.schema.XmlSchemaLengthFacet;
+import org.apache.ws.commons.schema.XmlSchemaMaxExclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaMaxInclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaMaxLengthFacet;
+import org.apache.ws.commons.schema.XmlSchemaMinExclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaMinInclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaMinLengthFacet;
 
 import javax.xml.namespace.QName;
 import java.util.ArrayList;
@@ -209,26 +218,6 @@
                 );
             }
 
-            // Fix up the imported schemas when all the schemas are
-            // defined in the same file and import each other.
-            for (int i = 0; i < schemalist.size(); i++) {
-                schema = (XmlSchema) schemalist.get(i);
-                XmlSchemaObjectCollection includes = schema.getIncludes();
-                if (includes != null) {
-                    Iterator tempIterator = includes.getIterator();
-                    while (tempIterator.hasNext()) {
-                        Object o = tempIterator.next();
-                        if (o instanceof XmlSchemaImport) {
-                            XmlSchema schema1 = ((XmlSchemaImport) o).getSchema();
-                            if (schema1 == null) {
-                                ((XmlSchemaImport) o).setSchema(
-                                        (XmlSchema) availableSchemaMap.get(((XmlSchemaImport) o).getNamespace()));
-                            }
-                        }
-                    }
-                }
-            }
-
             //set a mapper package if not avaialable
             if (writer.getExtensionMapperPackageName()==null){
                 //get the first schema from the list and take that namespace as the
@@ -287,10 +276,9 @@
         //Note that these are processed recursively!
 
         //add the schema to the loaded schema list
-        if (loadedSchemaMap.containsKey(schema.getTargetNamespace())) {
-            return;
+        if (!loadedSchemaMap.containsKey(schema.getTargetNamespace())) {
+            loadedSchemaMap.put(schema.getTargetNamespace(), schema);
         }
-        loadedSchemaMap.put(schema.getTargetNamespace(), schema);
 
         XmlSchemaObjectCollection includes = schema.getIncludes();
         if (includes != null) {
@@ -914,10 +902,7 @@
             //Note  - this is no array! so the array boolean is false
 
         }else if (content instanceof XmlSchemaComplexContentRestriction){
-        	// to handle extension we need to attach the extended items to the base type
-            // and create a new type
-            XmlSchemaComplexContentRestriction restriction = (XmlSchemaComplexContentRestriction)
-                    content;
+        	XmlSchemaComplexContentRestriction restriction = (XmlSchemaComplexContentRestriction) content;
 
             //process the base type if it has not been processed yet
             if (!isAlreadyProcessed(restriction.getBaseTypeName())){
@@ -1047,7 +1032,7 @@
         	}
         	
         	//process extension base type
-        	ProcessSimpleExtensionbaseType(extension.getBaseTypeName(),metaInfHolder);
+        	processSimpleExtensionBaseType(extension.getBaseTypeName(),metaInfHolder);
         	
         	//process attributes 
             XmlSchemaObjectCollection attribs = extension.getAttributes();
@@ -1066,17 +1051,43 @@
                 processAnyAttribute(metaInfHolder,anyAtt);
             }
             
-            
+        }else if (content instanceof XmlSchemaSimpleContentRestriction){
+        	XmlSchemaSimpleContentRestriction restriction = (XmlSchemaSimpleContentRestriction) content; 
+			
+        	//process the base type if it has not been processed yet
+        	if (!isAlreadyProcessed(restriction.getBaseTypeName())){
+        		//pick the relevant basetype from the schema and process it
+        		XmlSchemaType type=  parentSchema.getTypeByName(restriction.getBaseTypeName());
+        		if (type instanceof XmlSchemaComplexType) {
+        			XmlSchemaComplexType complexType = (XmlSchemaComplexType) type;
+        			if (complexType.getName() != null) {
+        				processNamedComplexSchemaType(complexType,parentSchema);
+        			} else {
+        				//this is not possible. The extension should always
+        				//have a name
+        				throw new SchemaCompilationException("Unnamed complex type used in restriction");//Internationlize this
+        			}
+        		} else if (type instanceof XmlSchemaSimpleType) {
+        			//process simple type
+        			processSimpleSchemaType((XmlSchemaSimpleType)type,null);
+        		}
+        	}
+        	//process restriction base type
+        	processSimpleRestrictionBaseType(restriction.getBaseTypeName(),metaInfHolder);
         	
-        }else if (content instanceof XmlSchemaSimpleContentRestriction){
-            //todo - Handle simple type restriction here
-            throw new SchemaCompilationException(
-                    SchemaCompilerMessages.getMessage("schema.unsupportedcontenterror","Simple Content Restriction"));
-
+			//process facets
+        	XmlSchemaObjectCollection facets = restriction.getFacets();
+        	processFacets(facets,metaInfHolder);
         }
     }
 
-    public void ProcessSimpleExtensionbaseType(QName extBaseType,BeanWriterMetaInfoHolder metaInfHolder) {
+    /**
+    * Process Simple Extension Base Type.
+    *
+    * @param extBaseType
+    * @param metaInfHolder
+    */
+    public void processSimpleExtensionBaseType(QName extBaseType,BeanWriterMetaInfoHolder metaInfHolder) {
     	
         //find the class name
         String className = findClassName(extBaseType, false);
@@ -1094,6 +1105,98 @@
     }
     
     /**
+     * Process Simple Restriction Base Type.
+     *
+     * @param resBaseType
+     * @param metaInfHolder
+     */
+    public void processSimpleRestrictionBaseType(QName resBaseType,BeanWriterMetaInfoHolder metaInfHolder) {
+    	
+        //find the class name
+        String className = findClassName(resBaseType, false);
+
+        //this means the schema type actually returns a different QName
+        if (changedTypeMap.containsKey(resBaseType)) {
+        	metaInfHolder.registerMapping(resBaseType,
+                    (QName) changedTypeMap.get(resBaseType),
+                    className,SchemaConstants.ELEMENT_TYPE);
+        } else {
+        	metaInfHolder.registerMapping(resBaseType,
+        			resBaseType,
+                    className,SchemaConstants.ELEMENT_TYPE);
+        }
+        
+        metaInfHolder.setRestrictionBaseType(resBaseType);
+    }
+    
+    /**
+     * Process Facets.
+     *
+     * @param facets
+     * @param metaInfHolder
+     */
+    private void processFacets(XmlSchemaObjectCollection facets,BeanWriterMetaInfoHolder metaInfHolder) {
+    	
+    	Iterator facetIterator = facets.getIterator();
+		
+        boolean enumStart = true;
+		while (facetIterator.hasNext()) {
+            Object obj = facetIterator.next();
+            
+            if ( obj instanceof XmlSchemaPatternFacet ) {
+				XmlSchemaPatternFacet pattern = (XmlSchemaPatternFacet) obj;
+				metaInfHolder.setPatternFacet(pattern.getValue().toString());
+			}
+            
+			else if ( obj instanceof XmlSchemaEnumerationFacet ) {
+				XmlSchemaEnumerationFacet enum = (XmlSchemaEnumerationFacet) obj;
+				
+				if ( enumStart ) {
+					metaInfHolder.setEnumFacet(enum.getValue().toString());
+					enumStart = false;
+				}
+				else {
+					metaInfHolder.addEnumFacet(enum.getValue().toString());
+				}
+			}
+			
+			else if ( obj instanceof XmlSchemaLengthFacet ) {
+				XmlSchemaLengthFacet length = (XmlSchemaLengthFacet) obj;
+				metaInfHolder.setLengthFacet(Integer.parseInt(length.toString()));
+			}
+			
+			else if ( obj instanceof XmlSchemaMaxExclusiveFacet ) {
+				XmlSchemaMaxExclusiveFacet maxEx = (XmlSchemaMaxExclusiveFacet) obj;
+				metaInfHolder.setMaxExclusiveFacet(Integer.parseInt(maxEx.toString()));
+			}
+			
+			else if ( obj instanceof XmlSchemaMinExclusiveFacet ) {
+				XmlSchemaMinExclusiveFacet minEx = (XmlSchemaMinExclusiveFacet) obj;
+				metaInfHolder.setMinExclusiveFacet(Integer.parseInt(minEx.toString()));
+			}
+			
+			else if ( obj instanceof XmlSchemaMaxInclusiveFacet ) {
+				XmlSchemaMaxInclusiveFacet maxIn = (XmlSchemaMaxInclusiveFacet) obj;
+				metaInfHolder.setMaxInclusiveFacet(Integer.parseInt(maxIn.toString()));
+			}
+			
+			else if ( obj instanceof XmlSchemaMinInclusiveFacet ) {
+				XmlSchemaMinInclusiveFacet minIn = (XmlSchemaMinInclusiveFacet) obj;
+				metaInfHolder.setMinInclusiveFacet(Integer.parseInt(minIn.toString()));
+			}
+			
+			else if ( obj instanceof XmlSchemaMaxLengthFacet ) {
+				XmlSchemaMaxLengthFacet maxLen = (XmlSchemaMaxLengthFacet) obj;
+				metaInfHolder.setMaxLengthFacet(Integer.parseInt(maxLen.toString()));
+			}
+			
+			else if ( obj instanceof XmlSchemaMinLengthFacet ) {
+				XmlSchemaMinLengthFacet minLen = (XmlSchemaMinLengthFacet) obj;
+				metaInfHolder.setMinLengthFacet(Integer.parseInt(minLen.toString()));
+			}
+        }
+    }
+    /**
      * Handle any attribute
      * @param metainf
      */
@@ -1235,19 +1338,8 @@
                     referencedQName = elt.getRefName();
                     boolean arrayStatus = ((Boolean) processedElementArrayStatusMap.get(elt)).booleanValue();
                     clazzName = findRefClassName(referencedQName,arrayStatus);
-                    XmlSchemaElement refElement = parentSchema.getElementByName(referencedQName);
-                    
-                    if (refElement == null) {
-                        refElement = lookupImportedSchema(parentSchema, referencedQName);
-                    }
-                    
-                    // register the mapping if we found the referenced element
-                    // else throw an exception
-                    if (refElement == null) {
-                        throw new SchemaCompilationException("Referenced element " + referencedQName  + " not found!");
-                    }
                     metainfHolder.registerMapping(referencedQName,
-                            refElement.getSchemaTypeName()
+                            parentSchema.getElementByName(referencedQName).getSchemaTypeName()
                             , clazzName,
                             arrayStatus ?
                                     SchemaConstants.ARRAY_TYPE :
@@ -1312,34 +1404,7 @@
         //set the ordered flag in the metainf holder
         metainfHolder.setOrdered(order);
     }
-    private XmlSchemaElement lookupImportedSchema(XmlSchema parentSchema, QName referencedQName) {
-        XmlSchemaElement refElement = null;
-        // The referenced element seems to come from an imported
-        // schema.
-        XmlSchemaObjectCollection includes = parentSchema.getIncludes();
-        if (includes != null) {
-            Iterator tempIterator = includes.getIterator();
-            while (tempIterator.hasNext()) {
-                Object o = tempIterator.next();
-                XmlSchema inclSchema = null;
-                if (o instanceof XmlSchemaImport) {
-                    inclSchema = ((XmlSchemaImport) o).getSchema();
-                }
-                if (o instanceof XmlSchemaInclude) {
-                    inclSchema = ((XmlSchemaInclude) o).getSchema();
-                }
-                // get the element from the included schema
-                if (inclSchema != null) {
-                    refElement = inclSchema.getElementByName(referencedQName);
-                }
-                if (refElement != null) {
-                    // we found the referenced element an can break the loop
-                    break;
-                }
-            }
-        }
-        return refElement;
-    }
+
     /**
      * Checks whether a given element is a binary element
      * @param elt
Index: modules/adb-codegen/src/org/apache/axis2/schema/writer/JavaBeanWriter.java
===================================================================
--- modules/adb-codegen/src/org/apache/axis2/schema/writer/JavaBeanWriter.java	(revision 430113)
+++ modules/adb-codegen/src/org/apache/axis2/schema/writer/JavaBeanWriter.java	(working copy)
@@ -554,13 +554,11 @@
 
         for (int i = 0; i < qNames.size(); i++) {
         	name = (QName) qNames.get(i);
-            Element property = XSLTUtils.addChildElement(model, "property",
-                    rootElt);
-            name = (QName)qNames.get(i);
+            Element property = XSLTUtils.addChildElement(model, "property",rootElt);
+            
             String xmlName = name.getLocalPart();
             XSLTUtils.addAttribute(model, "name", xmlName, property);
-            XSLTUtils.addAttribute(model, "nsuri", name.getNamespaceURI(),
-                    property);
+            XSLTUtils.addAttribute(model, "nsuri", name.getNamespaceURI(),property);
             String javaName = makeUniqueJavaClassName(propertyNames, xmlName);
             XSLTUtils.addAttribute(model, "javaname", javaName, property);
 
@@ -581,8 +579,7 @@
             	//XSLTUtils.addAttribute(model, "restricted", "yes", property);
             }
             
-            XSLTUtils.addAttribute(model, "type", javaClassNameForElement,
-                    property);
+            XSLTUtils.addAttribute(model, "type", javaClassNameForElement,property);
 
             if (PrimitiveTypeFinder.isPrimitive(javaClassNameForElement)) {
                 XSLTUtils.addAttribute(model, "primitive", "yes", property);
@@ -607,18 +604,15 @@
             String shortTypeName;
             if (metainf.getSchemaQNameForQName(name) != null) {
                 // see whether the QName is a basetype
-                if (baseTypeMap.containsKey(metainf
-                        .getSchemaQNameForQName(name))) {
-                    shortTypeName = metainf.getSchemaQNameForQName(name)
-                            .getLocalPart();
+                if (baseTypeMap.containsKey(metainf.getSchemaQNameForQName(name))) {
+                    shortTypeName = metainf.getSchemaQNameForQName(name).getLocalPart();
                 } else {
                     shortTypeName = getShortTypeName(javaClassNameForElement);
                 }
             } else {
                 shortTypeName = getShortTypeName(javaClassNameForElement);
             }
-            XSLTUtils.addAttribute(model, "shorttypename", shortTypeName,
-                    property);
+            XSLTUtils.addAttribute(model, "shorttypename", shortTypeName,property);
 
             if (metainf.isRestriction() && missingQNames.contains(name)) {
             	//XSLTUtils.addAttribute(model, "restricted", "yes", property);
@@ -639,17 +633,18 @@
             // put the min occurs count irrespective of whether it's an array or
             // not
             long minOccurs = metainf.getMinOccurs(name);
-            XSLTUtils
-                    .addAttribute(model, "minOccurs", minOccurs + "", property);
+            XSLTUtils.addAttribute(model, "minOccurs", minOccurs + "", property);
             
             //in the case the original element is an array but the derived one is not.
             if (metainf.isRestriction() && !missingQNames.contains(name) &&
                (parentMetaInf.getArrayStatusForQName(name) && !metainf.getArrayStatusForQName(name))) {
+            	
             	XSLTUtils.addAttribute(model, "rewrite", "yes", property);
             	XSLTUtils.addAttribute(model, "occuranceChanged", "yes", property);
             }
             else if (metainf.isRestriction() && !missingQNames.contains(name) &&
             		(minOccursChanged(name, missingQNames, metainf) || maxOccursChanged(name, missingQNames, metainf))) {
+            	
             	XSLTUtils.addAttribute(model, "restricted", "yes", property);
             	XSLTUtils.addAttribute(model, "occuranceChanged", "yes", property);
             }
@@ -657,20 +652,58 @@
             if (metainf.getArrayStatusForQName(name)) {
 
                 XSLTUtils.addAttribute(model, "array", "yes", property);
-                XSLTUtils
-                        .addAttribute(model, "arrayBaseType",
-                                javaClassNameForElement.substring(0,
-                                        javaClassNameForElement.indexOf("[")),
-                                property);
+                XSLTUtils.addAttribute(model, "arrayBaseType",javaClassNameForElement.substring(0,javaClassNameForElement.indexOf("[")),property);
 
                 long maxOccurs = metainf.getMaxOccurs(name);
                 if (maxOccurs == Long.MAX_VALUE) {
                     XSLTUtils.addAttribute(model, "unbound", "yes", property);
                 } else {
-                    XSLTUtils.addAttribute(model, "maxOccurs", maxOccurs + "",
-                            property);
+                    XSLTUtils.addAttribute(model, "maxOccurs", maxOccurs + "",property);
                 }
             }
+            if (metainf.isRestrictionBaseType(name)) {
+            	XSLTUtils.addAttribute(model, "restrictionBaseType", "yes", property);
+            }
+            
+            if (metainf.isExtensionBaseType(name)) {
+            	XSLTUtils.addAttribute(model, "extensionBaseType", "yes", property);
+            }
+            
+            if (metainf.isRestrictionBaseType(name) && metainf.getLengthFacet() != -1) {
+            	XSLTUtils.addAttribute(model, "lenFacet", metainf.getLengthFacet() + "", property);
+            }
+            
+            if (metainf.isRestrictionBaseType(name) && metainf.getMaxLengthFacet() != -1) {
+            	XSLTUtils.addAttribute(model, "maxLenFacet", metainf.getMaxLengthFacet() + "", property);
+            }
+            
+            if (metainf.isRestrictionBaseType(name) && metainf.getMinLengthFacet() != -1) {
+            	XSLTUtils.addAttribute(model, "minLenFacet", metainf.getMinLengthFacet() + "", property);
+            }
+            
+            if (metainf.isRestrictionBaseType(name) && metainf.getMaxExclusiveFacet() != -1) {
+            	XSLTUtils.addAttribute(model, "maxExFacet", metainf.getMaxExclusiveFacet() + "", property);
+            }
+            
+            if (metainf.isRestrictionBaseType(name) && metainf.getMinExclusiveFacet() != -1) {
+            	XSLTUtils.addAttribute(model, "minExFacet", metainf.getMinExclusiveFacet() + "", property);
+            }
+            
+            if (metainf.isRestrictionBaseType(name) && metainf.getMaxInclusiveFacet() != -1) {
+            	XSLTUtils.addAttribute(model, "maxInFacet", metainf.getMaxInclusiveFacet() + "", property);
+            }
+            
+            if (metainf.isRestrictionBaseType(name) && metainf.getMinInclusiveFacet() != -1) {
+            	XSLTUtils.addAttribute(model, "minInFacet", metainf.getMinInclusiveFacet() + "", property);
+            }
+            
+            if (metainf.isRestrictionBaseType(name) && metainf.getEnumFacet() != null) {
+            	XSLTUtils.addAttribute(model, "enumFacet", metainf.getEnumFacet(), property);
+            }
+            
+            if (metainf.isRestrictionBaseType(name) && metainf.getPatternFacet() != null) {
+            	XSLTUtils.addAttribute(model, "patternFacet", metainf.getPatternFacet(), property);
+            }
         }
     }
 
@@ -678,8 +711,7 @@
     	
     	QName[] qNames;
         QName[] pQNames;
-        //ArrayList missingQNames = new ArrayList();
-            		
+        
         BeanWriterMetaInfoHolder parentMetaInf = metainf.getParent();
         
         if (metainf.isOrdered()) {
@@ -706,7 +738,7 @@
        			qName.add(missingQNames.get(i));
        		}
        	}
-        //return qName;
+        
     }
     
     private boolean qNameNotFound(QName qname, BeanWriterMetaInfoHolder metainf) {
