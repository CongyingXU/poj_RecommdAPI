/*
 * Copyright 2004,2005 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.axis2.transport.njms;

import java.io.InputStream;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.ejb.EJBException;
import javax.ejb.MessageDrivenBean;
import javax.ejb.MessageDrivenContext;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.Queue;
import javax.jms.Topic;
import javax.xml.stream.XMLStreamException;

import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.ConfigurationContextFactory;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.description.AxisService;
import org.apache.axis2.description.TransportInDescription;
import org.apache.axis2.engine.AxisEngine;
import org.apache.axis2.transport.TransportListener;
import org.apache.axis2.util.UUIDGenerator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/*
 * Requires geronimo-spec-ejb-2.1-rc4.jar for compiling.
 * 
 * http://www.ibiblio.org/pub/packages/maven2/geronimo-spec/geronimo-spec-ejb/2.1-rc4/
 */
// TODO Do we need to implement TransportListener although we never use its
// methods?
public class AxisMdb implements MessageDrivenBean, MessageListener,
		TransportListener {

	private static final Log log = LogFactory.getLog(AxisMdb.class);

	private static final String SERVER_REPO = "server_repo";

	/** A map of destinations to service names they belong to */
	private static Map destinations = new HashMap();

	/** The Axis configuration context */
	private static ConfigurationContext configContext = null;

	private static boolean initialized = false;

	/**
	 * Add a listen destination on this connection factory on behalf of the
	 * given service
	 * 
	 * @param destinationJndi
	 *            destination JNDI name
	 * @param serviceName
	 *            the service to which it belongs
	 */
	private void addDestination(String destinationJndi, String serviceName) {
		destinations.put(destinationJndi, serviceName);
	}

	/**
	 * Return the service name using this destination
	 * 
	 * @param destination
	 *            the destination name
	 * @return the service which uses the given destination, or null
	 */
	public String getServiceNameForDestination(String destination) {
		return (String) destinations.get(destination);
	}

	private synchronized void initialize() {
		if (initialized)
			return;
		try {
			// System.out.println("Path: " + new File ().getPath());
			// create configuration context
			configContext = ConfigurationContextFactory
					.createConfigurationContextFromFileSystem(SERVER_REPO,
							SERVER_REPO + "/conf/axis2.xml");

			// iterate through deployed services and validate connection factory
			// names, and mark services as faulty where appropriate.
			Iterator services = configContext.getAxisConfiguration()
					.getServices().values().iterator();

			while (services.hasNext()) {
				AxisService service = (AxisService) services.next();
				log.info("[" + service.getName() + "] is a JMS service: "
						+ JMSUtils.isJMSService(service));
				if (JMSUtils.isJMSService(service)) {
					String destination = JMSUtils.getDestination(service);
					log.info("Destination for [" + service.getName() + "]: "
							+ destination);

					// TODO: Should I use the following?
					// compute service EPR and keep for later use
					// serviceNameToEprMap.put(service.getName(), getEPR(cf,
					// destination));

					// add the specified or implicit destination of this service
					// to its connection factory
					addDestination(destination, service.getName());
				}
			}
		} catch (Exception e) {
			handleException("Initialization error occured.", e);
		}
		initialized = true;
		log.info("Axis2 message driven bean has been initialized.");
	}

	/**
	 * Creates an Axis MessageContext for the received JMS message and sets up
	 * the transports and various properties
	 * 
	 * @param message
	 *            the JMS message
	 * @return the Axis MessageContext
	 */
	private MessageContext createMessageContext(Message message) {

		InputStream in = JMSUtils.getInputStream(message);

		try {
			MessageContext msgContext = new MessageContext();

			// get destination and create correct EPR
			Destination dest = message.getJMSDestination();
			String destinationName = null;
			if (dest instanceof Queue) {
				destinationName = ((Queue) dest).getQueueName();
			} else if (dest instanceof Topic) {
				destinationName = ((Topic) dest).getTopicName();
			}

			log.info("Destination whose service will be looked up: "
					+ destinationName);
			String serviceName = getServiceNameForDestination(destinationName);
			log.info("Service to be invoked: " + serviceName);

			// TODO Do we need following commented block?
			// // hack to get around the crazy Active MQ dynamic queue and topic
			// issues
			// if (serviceName == null) {
			// String provider = (String) jmsConFac.getProperties().get(
			// Context.INITIAL_CONTEXT_FACTORY);
			// if (provider.indexOf("activemq") != -1) {
			// serviceName = jmsConFac.getServiceNameForDestination(
			// ((dest instanceof Queue ?
			// JMSConstants.ACTIVEMQ_DYNAMIC_QUEUE :
			// JMSConstants.ACTIVEMQ_DYNAMIC_TOPIC) + destinationName));
			// }
			// }

			if (serviceName != null) {
				// set to bypass dispatching and handover directly to this
				// service
				msgContext.setAxisService(configContext.getAxisConfiguration()
						.getService(serviceName));
			}

			msgContext.setConfigurationContext(configContext);
			msgContext.setIncomingTransportName(Constants.TRANSPORT_JMS);
			msgContext.setTransportIn(configContext.getAxisConfiguration()
					.getTransportIn(JMSConstants.JMS_QNAME));

			// TODO Do we need following commented block?
			// msgContext.setTransportOut(
			// configContext.getAxisConfiguration().getTransportOut(JMSConstants.JMS_QNAME));
			//
			// // the reply is assumed to be on the JMSReplyTo destination,
			// using
			// // the same incoming connection factory
			//
			// msgContext.setProperty(Constants.OUT_TRANSPORT_INFO,
			// new JMSOutTransportInfo(jmsConFac.getConFactory(),
			// message.getJMSReplyTo()));

			msgContext.setServerSide(true);
			msgContext.setServiceGroupContextId(UUIDGenerator.getUUID());

			String soapAction = JMSUtils.getProperty(message,
					JMSConstants.SOAPACTION);
			if (soapAction != null) {
				msgContext.setSoapAction(soapAction);
			}

			msgContext.setEnvelope(JMSUtils.getSOAPEnvelope(message,
					msgContext, in));

			return msgContext;

		} catch (JMSException e) {
			handleException("JMS Exception reading the destination name", e);
		} catch (AxisFault e) {
			handleException("Axis fault creating the MessageContext", e);
		} catch (XMLStreamException e) {
			handleException("Error reading the SOAP envelope", e);
		}
		return null;
	}

	private static void handleException(String msg, Exception e) {
		log.error(msg, e);
		throw new AxisJMSException(msg, e);
	}

	/**
	 * Returns the EPR for the given service and IP. (Picks up precomputed EPR)
	 * 
	 * @param serviceName
	 *            service name
	 * @param ip
	 *            ignored
	 * @return the EPR for the service
	 * @throws AxisFault
	 *             not used
	 */
	// public EndpointReference getEPRForService(String serviceName, String ip)
	// throws AxisFault {
	// return new EndpointReference((String)
	// serviceNameToEprMap.get(serviceName));
	// }
	public void ejbCreate() {
		initialize();
		try {
			// TODO Should I add this instance to listener manager? If yes, what
			// about ejb pool? Each time an ejb is created, its instance
			// is added as TransportInDescription by overriding previous
			// setting. Therefore, only the last ejb instance will be
			// associated with the listener manager.
			/*
			 * ListenerManager listenerManager = new ListenerManager();
			 * listenerManager.init(configContext); TransportInDescription
			 * transportInDescription = new TransportInDescription( new
			 * QName(Constants.TRANSPORT_JMS));
			 * transportInDescription.setReceiver(this);
			 * listenerManager.addListener(transportInDescription, true);
			 * ListenerManager.defaultConfigurationContext = configContext;
			 */
			log.info("Ejb [" + getClass().getName() + "] has been created.");
		} catch (Exception e) {
			log.error("Ejb could not be created", e);
		}

	}

	public void ejbActivate() {
	}

	public void ejbPassivate() {
	}

	public void ejbRemove() throws EJBException {
		// TODO If I add this instance to listener manager, then I have to
		// remove it while removing the ejb.
		// stoping listener manager
		// try {
		// configContext.getListenerManager().stop();
		// } catch (AxisFault axisFault) {
		// log.error(axisFault.getMessage(), axisFault);
		// }
		log.info("Ejb [" + getClass().getName() + "] has been removed.");
	}

	public void setMessageDrivenContext(MessageDrivenContext arg0)
			throws EJBException {
		// TODO Auto-generated method stub

	}

	public void onMessage(Message message) {
		MessageContext msgCtx = createMessageContext(message);

		AxisEngine engine = new AxisEngine(msgCtx.getConfigurationContext());
		try {
			log
					.debug("Delegating JMS message for processing to the Axis engine");
			if (msgCtx.getEnvelope().getBody().hasFault()) {
				engine.receiveFault(msgCtx);
			} else {
				engine.receive(msgCtx);
			}
		} catch (AxisFault af) {
			log.error("JMS Worker [" + Thread.currentThread().getName()
					+ "] Encountered an Axis Fault : " + af.getMessage(), af);
		}
	}

	/**
	 * To initilze as TransportListener, not as Message Driven Bean
	 * 
	 * @param axisConf
	 * @param transprtIn
	 * @throws AxisFault
	 */
	public void init(ConfigurationContext axisConf,
			TransportInDescription transprtIn) throws AxisFault {
		// no need to do anything :)
	}

	public void start() throws AxisFault {
		// no need to do anything :)
	}

	public void stop() throws AxisFault {
		// no need to do anything :)
	}

	public EndpointReference getEPRForService(String serviceName, String ip)
			throws AxisFault {
		// no need to do anything :)
		return null;
	}
}
