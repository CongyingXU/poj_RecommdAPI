Index: C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/spi/ServiceDelegate.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/spi/ServiceDelegate.java	(revision 426662)
+++ C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/spi/ServiceDelegate.java	(working copy)
@@ -234,7 +234,6 @@
     	
     	Class[] seiClazz = new Class[]{sei, BindingProvider.class};
     	Object proxyClass = Proxy.newProxyInstance(sei.getClassLoader(), seiClazz, proxyHandler);
-    	
     	return sei.cast(proxyClass);
     }
     
Index: C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyDescriptor.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyDescriptor.java	(revision 426662)
+++ C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyDescriptor.java	(working copy)
@@ -20,6 +20,7 @@
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 
+import javax.jws.Oneway;
 import javax.jws.SOAPBinding;
 import javax.jws.WebParam;
 import javax.jws.WebResult;
@@ -55,6 +56,7 @@
 	//TODO replace annotation work once endpointDescription is ready
 	private EndpointDescription endpointDescription = null;
 
+	//TODO Need to put validation to check if seiMethod is null;
 	public ProxyDescriptor(Class seiClazz){
 		this.seiClazz = seiClazz;
 	}
@@ -103,38 +105,54 @@
 	}
 	
 	//TODO: refactor this once PropertyDescriptor is implemented.
-	public Class getRequestWrapperClass() throws ClassNotFoundException{
-		if(getRequestWrapper() == null){
-			return null;
+	public Class getRequestWrapperClass(boolean isAsync) throws ClassNotFoundException{
+		RequestWrapper requestWrapper = getRequestWrapper();
+		String className = null;
+		if(requestWrapper == null){
+			Class clazz = seiMethod.getDeclaringClass();
+			String packageName =clazz.getPackage().getName();
+			String capitalized = toClass(seiMethod.getName());
+			className = packageName+"."+capitalized;
 		}
-		return Class.forName(getRequestWrapper().className(), true, ClassLoader.getSystemClassLoader());
+		if(requestWrapper!=null){
+			className = requestWrapper.className();
+		}
+		return Class.forName(className, true, ClassLoader.getSystemClassLoader());
 	}
 	
 	public String getRequestWrapperClassName(){
 		if(getRequestWrapper()== null){
-			return null;
+			Class clazz = seiMethod.getDeclaringClass();
+			String packageName =clazz.getPackage().getName();
+			String className = toClass(seiMethod.getName());
+			return packageName+"."+className;
 		}
 		return getRequestWrapper().className();
 	}
+	
 	public String getRequestWrapperLocalName(){
 		if(getRequestWrapper() == null){
-			return null;
+			return seiMethod.getName();
 		}
 		return getRequestWrapper().localName();
 	}
 	//TODO remove this once OperationDescription is implemented
-	public Class getResponseWrapperClass() throws ClassNotFoundException{
-		if(getResponseWrapper() == null){
-			return null;
+	public Class getResponseWrapperClass(boolean isAsync) throws ClassNotFoundException{
+		ResponseWrapper responseWrapper = getResponseWrapper();
+		String className = null;
+		if( responseWrapper==null && isAsync){
+			//As per jaxws spec section 2.3.4.4
+			className = toClass(seiMethod.getName()) + "Response";
 		}
-		return Class.forName(getResponseWrapper().className(), true, ClassLoader.getSystemClassLoader());
-	}
-	public String getResponseWrapperClassName(){
-		if(getResponseWrapper()==null){
-			return null;
+		if(responseWrapper == null){
+			return seiMethod.getReturnType();
 		}
-		return getResponseWrapper().className();
+		if(responseWrapper !=null){
+			className = responseWrapper.className();
+		}
+		return Class.forName(className, true, ClassLoader.getSystemClassLoader());
 	}
+
 	public String getResponseWrapperLocalName(){
 		if(getResponseWrapper()==null){
 			return null;
@@ -142,8 +160,15 @@
 		return getResponseWrapper().localName();
 	}
 	//TODO remove this once OperationDescription is implemented
-	public String getWebResultName(){
-		if(getWebResult()==null){
+	public String getWebResultName(boolean isAsync){
+		WebResult webResult = getWebResult();
+		if(webResult == null &&!isAsync){
+			if(!isOneWay() && !seiMethod.getReturnType().getName().equals("void")){
+				return "return";
+			}
+		}
+		if(webResult == null){
+			//I will return null here and when creating result in ProxyHandler I will check for null and return the wrapperObject if no webResultName found.
 			return null;
 		}
 		return getWebResult().name();
@@ -154,6 +179,10 @@
 		WebParam[] params = getWebParam();
 		ArrayList<String> names = new ArrayList<String>();
 		for(WebParam webParam:params){
+			//skip asyncHandler, method param name will be asyncHandler as per jaxws specification.
+			if(webParam.name().equals("asyncHandler")){
+				continue;
+			}
 			names.add(webParam.name());
 		}
 		return names;
@@ -170,17 +199,22 @@
 	public void setSeiMethod(Method seiMethod) {
 		this.seiMethod = seiMethod;
 	}
-	public SOAPBinding getSoapBinding(){
+	public SOAPBinding getSoapBindingOnClazz(){
 		if(soapBinding == null){
 			soapBinding = (SOAPBinding)seiClazz.getAnnotation(SOAPBinding.class);
 		}
 		return soapBinding;
 	}
+	public SOAPBinding getSoapBindingOnMethod(){
+		//TODO who has presendence if there is SOAPBinding on Class and method.
+		return null;
+	}
+	//TODO read soap binding on method too, make sure if Binding style is different from binding style in Clazz throw Exception.
 	public Style getBindingStyle(){
-		if(getSoapBinding()== null){
+		if(getSoapBindingOnClazz()== null){
 			return SOAPBinding.Style.DOCUMENT;
 		}
-		return getSoapBinding().style(); 
+		return getSoapBindingOnClazz().style(); 
 	}
 
 	public Class getSeiClazz() {
@@ -190,4 +224,28 @@
 	public void setSeiClazz(Class seiClazz) {
 		this.seiClazz = seiClazz;
 	}
+	/*
+	 * Convert getString to GetString. Converts method to clazz;
+	 */
+	private String toClass(String method){
+		if(method == null){
+			//Throw exception but I should have check this even before this method is Invoked.
+		}
+		StringBuffer methodName = new StringBuffer(method);
+		return methodName.replace(0,1, methodName.substring(0,1).toUpperCase()).toString();
+	}
+	
+	public String filterAsync(String method){
+		if(method.endsWith("Async")){
+			int index =method.lastIndexOf("Async");
+			return method.substring(0,index);
+		}
+		else{
+			return method;
+		}
+	}
+	
+	public boolean isOneWay(){
+		return seiMethod.isAnnotationPresent(Oneway.class);
+	}
 }
Index: C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyAsyncListener.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyAsyncListener.java	(revision 0)
+++ C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyAsyncListener.java	(revision 0)
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2006 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.client.proxy;
+
+import java.util.concurrent.ExecutionException;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.soap.SOAPBody;
+import javax.xml.ws.WebServiceException;
+
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axis2.jaxws.AxisCallback;
+import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.impl.AsyncListener;
+
+
+/**
+ * ProxyAsyncListener will be used to create response object when client does
+ * response.get();
+ * The Class will return the data type associated with Response<T> Generic Class.
+ * Example Response<Float> will return a Float object to client on Response.get() call.
+ */
+public class ProxyAsyncListener extends AsyncListener {
+
+	BaseProxyHandler handler = null;
+	public ProxyAsyncListener() {
+		super();
+	}
+
+	public BaseProxyHandler getHandler() {
+		return handler;
+	}
+
+	public void setHandler(BaseProxyHandler handler) {
+		this.handler = handler;
+	}
+
+	/**
+	 * @param cb
+	 */
+	public ProxyAsyncListener(AxisCallback cb) {
+		super(cb);
+		
+	}
+	
+	 public Object getResponseValueObject(MessageContext mc){
+		 
+		 try{
+			 //I will delegate the request to create respose to proxyHandler since it has all the logic written to create response for Sync and oneWay.
+			  return handler.createResponse(null, mc);
+		 }catch(Exception e){
+			throw ExceptionFactory.makeWebServiceException(e);
+		 }
+	 }
+
+	 
+}
Index: C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/BaseProxyHandler.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/BaseProxyHandler.java	(revision 426662)
+++ C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/BaseProxyHandler.java	(working copy)
@@ -20,20 +20,25 @@
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.util.concurrent.Future;
 
 import javax.xml.bind.JAXBException;
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLStreamException;
+import javax.xml.ws.AsyncHandler;
+import javax.xml.ws.Response;
 import javax.xml.ws.WebServiceException;
 
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.jaxws.AxisController;
 import org.apache.axis2.jaxws.BindingProvider;
+import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.core.InvocationContext;
 import org.apache.axis2.jaxws.core.InvocationContextFactory;
 import org.apache.axis2.jaxws.core.MessageContext;
 import org.apache.axis2.jaxws.core.controller.AxisInvocationController;
 import org.apache.axis2.jaxws.core.controller.InvocationController;
+import org.apache.axis2.jaxws.impl.AsyncListener;
 import org.apache.axis2.jaxws.message.MessageException;
 import org.apache.axis2.jaxws.spi.ServiceDelegate;
 import org.apache.axis2.jaxws.util.WSDLWrapper;
@@ -41,6 +46,8 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
+import com.sun.xml.bind.v2.runtime.reflect.Lister;
+
 /**
  * ProxyHandler is the java.lang.reflect.InvocationHandler implementation.
  * When jaxws client calls the method on proxy object that it gets using the getPort
@@ -123,6 +130,9 @@
 		if (log.isDebugEnabled()) {
             log.debug("Attempting to Invoke SEI Method "+ method.getName());
         }
+		
+		//TODO make sure the method is a public method and it is declared in SEI.
+		
 		InvocationContext requestIC = InvocationContextFactory.createInvocationContext(null);
 		MessageContext requestContext = createRequest(method, args);
 		requestIC.setRequestMessageContext(requestContext);
@@ -131,16 +141,68 @@
 		try{
 			requestIC.setServiceClient(delegate.getServiceClient());
 		}catch(AxisFault e){
-			throw new WebServiceException(e);
+			throw ExceptionFactory.makeWebServiceException(e);
 		}
-		//TODO: check if the call is OneWay, Async or Sync
-		InvocationContext responseIC = controller.invoke(requestIC);
-		MessageContext responseContext = responseIC.getResponseMessageContext();
-		Object responseObj = createResponse(method, responseContext);
+		//check if the call is OneWay, Async or Sync
+		if(proxyDescriptor.isOneWay() || method.getReturnType().getName().equals("void")){
+			if(log.isDebugEnabled()){
+				log.debug("OneWay Call");
+			}
+			controller.invokeOneWay(requestIC);
+		}
 		
-		return responseObj;
+		if(method.getReturnType().isAssignableFrom(Future.class)){
+			if(log.isDebugEnabled()){
+				log.debug("Async Callback");
+			}
+			//Get AsyncHandler from Objects and sent that to InvokeAsync
+			AsyncHandler asyncHandler = null;
+			for(Object obj:args){
+				if(obj !=null && AsyncHandler.class.isAssignableFrom(obj.getClass())){
+					asyncHandler = (AsyncHandler)obj;
+					break;
+				}
+			}
+			if(asyncHandler == null){
+				throw ExceptionFactory.makeWebServiceException("AynchHandler null for Async callback, Invalid AsyncHandler callback Object");
+			}
+			AsyncListener listener = createProxyListener();
+			requestIC.setAsyncListener(listener);
+			requestIC.setExecutor(delegate.getExecutor());
+			return controller.invokeAsync(requestIC, asyncHandler);
+		}
+		
+		if(method.getReturnType().isAssignableFrom(Response.class)){
+			if(log.isDebugEnabled()){
+				log.debug("Async Polling");
+			}
+			AsyncListener listener = createProxyListener();
+			requestIC.setAsyncListener(listener);
+			requestIC.setExecutor(delegate.getExecutor());
+			return controller.invokeAsync(requestIC);
+		}
+		
+		if(!proxyDescriptor.isOneWay()){
+			InvocationContext responseIC = controller.invoke(requestIC);
+		
+			MessageContext responseContext = responseIC.getResponseMessageContext();
+			Object responseObj = createResponse(method, responseContext);
+			return responseObj;
+		}
+		return null;
 	}
 	
+	private AsyncListener createProxyListener(){
+		ProxyAsyncListener listener = new ProxyAsyncListener();
+		listener.setHandler(this);
+		return listener;
+	}
+	
+	protected boolean isAsync(){
+		String methodName = proxyDescriptor.getSeiMethod().getName();
+		Class returnType = proxyDescriptor.getSeiMethod().getReturnType();
+		return methodName.endsWith("Async") && (returnType.isAssignableFrom(Response.class) || returnType.isAssignableFrom(Future.class));
+	}
 	/**
 	 * Create request context for the method call. This request context will be used by InvocationController to route the method call to axis engine.
 	 * @param method
@@ -194,4 +256,8 @@
 		super.initRequestContext(endPointAddress, soapAddress, soapAction);
 	}
 
+	protected ServiceDelegate getDelegate() {
+		return delegate;
+	}
+
 }
Index: C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/DocLitProxyHandler.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/DocLitProxyHandler.java	(revision 426662)
+++ C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/DocLitProxyHandler.java	(working copy)
@@ -1,249 +1,296 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws.client.proxy;
-
-import java.beans.IntrospectionException;
-import java.beans.Introspector;
-import java.beans.PropertyDescriptor;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Hashtable;
-import java.util.Map;
-
-import javax.xml.bind.JAXBContext;
-import javax.xml.bind.JAXBException;
-import javax.xml.bind.annotation.XmlElement;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.axiom.om.OMElement;
-import org.apache.axis2.jaxws.core.MessageContext;
-import org.apache.axis2.jaxws.core.controller.AxisInvocationController;
-import org.apache.axis2.jaxws.message.Block;
-import org.apache.axis2.jaxws.message.Message;
-import org.apache.axis2.jaxws.message.MessageException;
-import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
-import org.apache.axis2.jaxws.registry.FactoryRegistry;
-import org.apache.axis2.jaxws.spi.ServiceDelegate;
-import org.apache.axis2.jaxws.wrapper.JAXBWrapperTool;
-import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
-import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperToolImpl;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-
-public class DocLitProxyHandler extends BaseProxyHandler {
-	private static Log log = LogFactory.getLog(DocLitProxyHandler.class);
-	/**
-	 * @param pd
-	 * @param delegate
-	 */
-	public DocLitProxyHandler(ProxyDescriptor pd, ServiceDelegate delegate) {
-		super(pd, delegate);
-	}
-
-	@Override
-	protected MessageContext createRequest(Method method, Object[] args) throws ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, javax.xml.stream.XMLStreamException {
-		MessageContext requestCtx = null;
-		if(isDocLitWrapped()){
-			requestCtx = createDocLitWrappedRequest(method, args);
-		}
-		return requestCtx;
-	}
-
-	@Override
-	protected Object createResponse(Method method, MessageContext responseContext) throws IllegalAccessException, ClassNotFoundException, JAXBWrapperException, JAXBException, javax.xml.stream.XMLStreamException, MessageException, IntrospectionException, NoSuchFieldException, InvocationTargetException{
-		Object result = null;
-		if(isDocLitWrapped()){
-			 result = createDocLitWrappedResponse(method, responseContext);
-		}
-		return result;
-	}
-
-	/**
-	 * createDocLitWrappedRequest create request message context. It reads RequestWrapper annotation from OperationDescription and reads the calss name, then reads
-	 * all the webParam annotation on the method and uses JAXBWrapTool to wrap the request as jaxbObject. Create JAXBblock from the jaxbObject and sets OMElement on 
-	 * Request MessageContext, reads Biniding provider properties and set them on request message context and return request message context.
-	 * @param method
-	 * @param objects
-	 * @return
-	 * @throws ClassNotFoundException
-	 * @throws JAXBWrapperException
-	 * @throws JAXBException
-	 * @throws MessageException
-	 * @throws javax.xml.stream.XMLStreamException
-	 */
-	//TODO Refactor this once OperationDescription is implemented.
-	private MessageContext createDocLitWrappedRequest(Method method, Object[] objects)throws ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, javax.xml.stream.XMLStreamException{
-		/*TODO : getOperationDesc from method name
-		 * and call 
-		 * createDocLitWrapperRequest(od, values);
-		 */
-		Class wrapperClazz = proxyDescriptor.getRequestWrapperClass();
-		ArrayList<String> names = proxyDescriptor.getParamNames();
-		String localName = proxyDescriptor.getResponseWrapperLocalName();
-		Map<String, Object> values = getParamValues(names, objects);
-		JAXBWrapperTool wrapTool = new JAXBWrapperToolImpl();
-		
-		//TODO:if(@XmlRootElement) annotation found or defined
-		Object jaxbObject = wrapTool.wrap(wrapperClazz, localName,names, values);
-		//TODO: if (!@XmlRootElement) annotation not found or not defined then can I use JAXBElement?
-		//JAXBElement jaxbObject = wrapTool.wrapAsJAXBElement(wrapperClazz, requestWrapper.localName(),names, values);
-		JAXBContext ctx = JAXBContext.newInstance(new Class[]{wrapperClazz});
-		Block reqBlock = createJAXBBlock(jaxbObject, ctx);
-		MessageContext requestCtx = initializeRequest(reqBlock);
-		return requestCtx;
-		
-	}
-	/**
-	 * CreateDocLitWrappedResponse creates return result that client expects from the method call. It reads response wrapper annotation then reads OM from the
-	 * response message context and creates JAXBBlock from the OMElement on messageContext. It then reads the webresult annotation to gather the return parameter
-	 * name and creates the result object for it by reading the property object from JAXBBlock's business object using PropertyDescriptor. 
-	 * @param method
-	 * @param response
-	 * @return
-	 * @throws IllegalAccessException
-	 * @throws ClassNotFoundException
-	 * @throws JAXBWrapperException
-	 * @throws JAXBException
-	 * @throws javax.xml.stream.XMLStreamException
-	 * @throws MessageException
-	 * @throws IntrospectionException
-	 * @throws NoSuchFieldException
-	 * @throws InvocationTargetException
-	 */
-//	TODO Refactor this once OperationDescription is implemented.
-	private Object createDocLitWrappedResponse(Method method, MessageContext response)throws IllegalAccessException, ClassNotFoundException, JAXBWrapperException, JAXBException, javax.xml.stream.XMLStreamException, MessageException, IntrospectionException, NoSuchFieldException, InvocationTargetException{
-		Class wrapperClazz = proxyDescriptor.getResponseWrapperClass();
-		String resultName = proxyDescriptor.getWebResultName();
-		JAXBContext ctx = JAXBContext.newInstance(new Class[]{wrapperClazz});
-		//TODO: I should go away from using messageAsOM and see if I can fetch Block from messageContext!!
-		
-        // Get a JAXBBlockFactory instance.  We'll need this to get the JAXBBlock
-        // out of the Message
-        JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
-        
-        Message responseMsg = response.getMessage();
-        Block resBlock = responseMsg.getBodyBlock(0, ctx, factory);
-		Object bo = resBlock.getBusinessObject(true);
-		
-        return getWebResultObject(wrapperClazz, bo, resultName);
-	}
-	
-	private Block createJAXBBlock(Object jaxbObject, JAXBContext context) throws MessageException{
-		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
-		return factory.createFrom(jaxbObject,context,null);
-		
-	}
-	
-	private Block createJAXBBlock(OMElement om, JAXBContext context)throws javax.xml.stream.XMLStreamException{
-		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
-		return factory.createFrom(om,context,null);
-		
-	}
-
-	//TODO: should I unwrap the bo or use property descriptor?
-	private PropertyDescriptor gerPropertyDescriptor(Class returnClazz, String propertyName)throws IntrospectionException, NoSuchFieldException{
-		PropertyDescriptor[] allPds = Introspector.getBeanInfo(returnClazz).getPropertyDescriptors();
-		Field[] fields = returnClazz.getDeclaredFields();
-		for(PropertyDescriptor pd:allPds){
-			for(Field field:fields){
-				String javaFieldName = field.getName();
-				String pdName = pd.getDisplayName();
-				if(javaFieldName.equals(pdName)){
-					if(javaFieldName.equals(propertyName)){
-						return pd;
-						
-					}else{
-						XmlElement xmlElement =field.getAnnotation(XmlElement.class);
-						if(xmlElement == null){
-							//TODO:What happens if xmlElement not defined.
-							
-						}
-						String xmlName =xmlElement.name();
-						if(xmlName.equals(propertyName)){
-							return pd;
-						}
-						if(xmlName.toLowerCase().equals(propertyName.toLowerCase())){
-							return pd;
-						}
-					}
-				}
-			}
-		}
-		return null;
-	}
-	//TODO: refactor this once PropertyDescriptor is implemented.
-	private Map<String, Object> getParamValues(ArrayList<String> names, Object[] objects){
-		Map<String, Object> values = new Hashtable<String, Object>();
-		int i=0;
-		for(Object obj:objects){
-			values.put(names.get(i++), obj);
-		}
-		return values;
-	}
-	//TODO remove this once OperationDescription is implemented
-	
-	/** 
-	 * reads PropertyDescritpr and invokes  get method on result property and returns the object.
-	 * @param wrapperClazz
-	 * @param businessObject
-	 * @param propertyName
-	 * @return
-	 * @throws NoSuchFieldException
-	 * @throws IntrospectionException
-	 * @throws InvocationTargetException
-	 * @throws IllegalAccessException
-	 */
-	private Object getWebResultObject(Class wrapperClazz, Object businessObject, String propertyName) throws NoSuchFieldException, IntrospectionException,InvocationTargetException, IllegalAccessException{
-		PropertyDescriptor pd = gerPropertyDescriptor(wrapperClazz, propertyName);
-		if(pd == null){
-			//TODO: what happens if pd not found.
-		}
-		Method readMethod = pd.getReadMethod();
-		Object webResult = readMethod.invoke(wrapperClazz.cast(businessObject), null);
-		return webResult;
-	}
-	
-	private MessageContext initializeRequest(Block messageBlock) throws XMLStreamException, MessageException{
-		MessageContext request = new MessageContext();
-		//request.setMessageAsOM(messageBlock.getOMElement());
-		request.getProperties().putAll(getRequestContext());
-	
-		return request;
-		
-	}
-	
-	private boolean isDocLitRaw(){
-		/* TODO: if(EndPoinInterfaceDescriptor.clientCall == Doc/literal) && OperationDescriptor.isWrapped() == false){ 
-		 * return true; 
-		 * else
-		 * return false;
-		 */
-		return false;
-	}
-	
-	private boolean isDocLitWrapped(){
-		/* TODO: if(EndPoinInterfaceDescriptor.clientCall == Doc/literal) && OperationDescriptor.isWrapped() == true){ 
-		 * return true; 
-		 * else
-		 * return false;
-		 */
-		return true;
-	}
-}
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.client.proxy;
+
+import java.beans.IntrospectionException;
+import java.beans.Introspector;
+import java.beans.PropertyDescriptor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Hashtable;
+import java.util.Map;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.ws.AsyncHandler;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.soap.SOAPBody;
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.message.Block;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.MessageException;
+import org.apache.axis2.jaxws.message.Protocol;
+import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
+import org.apache.axis2.jaxws.message.factory.MessageFactory;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
+import org.apache.axis2.jaxws.spi.ServiceDelegate;
+import org.apache.axis2.jaxws.util.WSDLWrapper;
+import org.apache.axis2.jaxws.wrapper.JAXBWrapperTool;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperToolImpl;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+
+
+public class DocLitProxyHandler extends BaseProxyHandler {
+	private static Log log = LogFactory.getLog(DocLitProxyHandler.class);
+	/**
+	 * @param pd
+	 * @param delegate
+	 */
+	public DocLitProxyHandler(ProxyDescriptor pd, ServiceDelegate delegate) {
+		super(pd, delegate);
+	}
+
+	@Override
+	protected MessageContext createRequest(Method method, Object[] args) throws ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, javax.xml.stream.XMLStreamException {
+		MessageContext requestCtx = null;
+		if(isDocLitWrapped()){
+			requestCtx = createDocLitWrappedRequest(method, args);
+		}
+		return requestCtx;
+	}
+
+	@Override
+	protected Object createResponse(Method method, MessageContext responseContext) throws IllegalAccessException, ClassNotFoundException, JAXBWrapperException, JAXBException, javax.xml.stream.XMLStreamException, MessageException, IntrospectionException, NoSuchFieldException, InvocationTargetException{
+		Object result = null;
+		if(isDocLitWrapped()){
+			 result = createDocLitWrappedResponse(method, responseContext);
+		}
+		return result;
+	}
+
+	/**
+	 * createDocLitWrappedRequest create request message context. It reads RequestWrapper annotation from OperationDescription and reads the calss name, then reads
+	 * all the webParam annotation on the method and uses JAXBWrapTool to wrap the request as jaxbObject. Create JAXBblock from the jaxbObject and sets OMElement on 
+	 * Request MessageContext, reads Biniding provider properties and set them on request message context and return request message context.
+	 * @param method
+	 * @param objects
+	 * @return
+	 * @throws ClassNotFoundException
+	 * @throws JAXBWrapperException
+	 * @throws JAXBException
+	 * @throws MessageException
+	 * @throws javax.xml.stream.XMLStreamException
+	 */
+	//TODO Refactor this once OperationDescription is implemented.
+	private MessageContext createDocLitWrappedRequest(Method method, Object[] objects)throws ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, javax.xml.stream.XMLStreamException{
+		/*TODO : getOperationDesc from method name
+		 * and call 
+		 * createDocLitWrapperRequest(od, values);
+		 */
+		Class wrapperClazz = proxyDescriptor.getRequestWrapperClass(isAsync());
+		ArrayList<String> names = proxyDescriptor.getParamNames();
+		String localName = proxyDescriptor.getResponseWrapperLocalName();
+		Map<String, Object> values = getParamValues(names, objects);
+		JAXBWrapperTool wrapTool = new JAXBWrapperToolImpl();
+		
+		//TODO:if(@XmlRootElement) annotation found or defined
+		Object jaxbObject = wrapTool.wrap(wrapperClazz, localName,names, values);
+		//TODO: if (!@XmlRootElement) annotation not found or not defined then can I use JAXBElement?
+		//JAXBElement jaxbObject = wrapTool.wrapAsJAXBElement(wrapperClazz, requestWrapper.localName(),names, values);
+		JAXBContext ctx = JAXBContext.newInstance(new Class[]{wrapperClazz});
+		Block reqBlock = createJAXBBlock(jaxbObject, ctx);
+		MessageContext requestCtx = initializeRequest(reqBlock);
+		return requestCtx;
+		
+	}
+	/**
+	 * CreateDocLitWrappedResponse creates return result that client expects from the method call. It reads response wrapper annotation then reads OM from the
+	 * response message context and creates JAXBBlock from the OMElement on messageContext. It then reads the webresult annotation to gather the return parameter
+	 * name and creates the result object for it by reading the property object from JAXBBlock's business object using PropertyDescriptor. 
+	 * @param method
+	 * @param response
+	 * @return
+	 * @throws IllegalAccessException
+	 * @throws ClassNotFoundException
+	 * @throws JAXBWrapperException
+	 * @throws JAXBException
+	 * @throws javax.xml.stream.XMLStreamException
+	 * @throws MessageException
+	 * @throws IntrospectionException
+	 * @throws NoSuchFieldException
+	 * @throws InvocationTargetException
+	 */
+//	TODO Refactor this once OperationDescription is implemented.
+	private Object createDocLitWrappedResponse(Method method, MessageContext response)throws IllegalAccessException, ClassNotFoundException, JAXBWrapperException, JAXBException, javax.xml.stream.XMLStreamException, MessageException, IntrospectionException, NoSuchFieldException, InvocationTargetException{
+		Class wrapperClazz = proxyDescriptor.getResponseWrapperClass(isAsync());
+		String resultName = proxyDescriptor.getWebResultName(isAsync());
+		JAXBContext ctx = JAXBContext.newInstance(new Class[]{wrapperClazz});
+		//FIXME: I should go away from using messageAsOM when MessageContext start to return jaxbBlock!!
+		/*
+		OMElement om = response.getMessageAsOM();
+		if(om instanceof SOAPEnvelope){
+			SOAPEnvelope env =(SOAPEnvelope) om;
+			SOAPBody body = env.getBody();
+			om = body.getFirstElement();
+		}
+		
+		Block resBlock = createJAXBBlock(om, ctx);
+		*/
+		
+		// Get a JAXBBlockFactory instance.  We'll need this to get the JAXBBlock
+        // out of the Message
+        JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
+        
+        Message responseMsg = response.getMessage();
+        Block resBlock = responseMsg.getBodyBlock(0, ctx, factory);
+		Object bo = resBlock.getBusinessObject(true);
+		
+		//if wrapperClazz is assignable from bo then return bo;
+		if(resultName==null && wrapperClazz.isAssignableFrom(bo.getClass())){
+			return bo;
+		}
+	
+		return getWebResultObject(wrapperClazz, bo, resultName);
+		
+		
+	}
+	
+	private Block createJAXBBlock(Object jaxbObject, JAXBContext context) throws MessageException{
+		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
+		return factory.createFrom(jaxbObject,context,null);
+		
+	}
+	
+	private Block createJAXBBlock(OMElement om, JAXBContext context)throws javax.xml.stream.XMLStreamException{
+		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
+		return factory.createFrom(om,context,null);
+		
+	}
+
+	/*
+	 * this method return property descriptor to read or write the property value.
+	 * It reads all the property descriptor on the java bean. Then determins if java field name is the the actual property who's pd has been requested.
+	 * if true it returns pd.
+	 * Also the propertyName supplied is compared with java field name and if they dont match than xmlElement annotation on JAXB Object is lookedup. if they
+	 * dont match then xmlElement is compared with java field name using lowercases and finally return the pd.
+	 * if property descriptor not found for a perticular property just return null.
+	 */
+	private PropertyDescriptor getPropertyDescriptor(Class returnClazz, String propertyName)throws IntrospectionException, NoSuchFieldException{
+		PropertyDescriptor[] allPds = Introspector.getBeanInfo(returnClazz).getPropertyDescriptors();
+		Field[] fields = returnClazz.getDeclaredFields();
+		for(PropertyDescriptor pd:allPds){
+			for(Field field:fields){
+				if(propertyName == null){
+					//if this happens I will get the first property that has datatype same as return clazz and return its descriptor.
+					if(field.getType() == returnClazz){
+						return pd;
+					}
+				}
+				String javaFieldName = field.getName();
+				String pdName = pd.getDisplayName();
+				if(javaFieldName.equals(pdName)){
+					if(javaFieldName.equals(propertyName)){
+						return pd;
+						
+					}else{
+						XmlElement xmlElement =field.getAnnotation(XmlElement.class);
+						if(xmlElement == null){
+							//TODO:What happens if xmlElement not defined.
+							
+						}
+						String xmlName =xmlElement.name();
+						if(xmlName.equals(propertyName)){
+							return pd;
+						}
+						if(xmlName.toLowerCase().equals(propertyName.toLowerCase())){
+							return pd;
+						}
+					}
+				}
+			}
+		}
+		throw new NoSuchFieldException("Could not create WebResult Object for property :"+propertyName+ " on java bean:"+returnClazz);
+	}
+	//TODO: refactor this once PropertyDescriptor is implemented.
+	private Map<String, Object> getParamValues(ArrayList<String> names, Object[] objects){
+		Map<String, Object> values = new Hashtable<String, Object>();
+		int i=0;
+		for(Object obj:objects){
+			//skip AsycHandler Object
+			if(obj instanceof AsyncHandler){
+				i++;
+				continue;
+			}
+			
+			values.put(names.get(i++), obj);
+		}
+		return values;
+	}
+	//TODO remove this once OperationDescription is implemented
+	
+	/** 
+	 * reads PropertyDescritpr and invokes  get method on result property and returns the object.
+	 * @param wrapperClazz
+	 * @param businessObject
+	 * @param propertyName
+	 * @return
+	 * @throws NoSuchFieldException
+	 * @throws IntrospectionException
+	 * @throws InvocationTargetException
+	 * @throws IllegalAccessException
+	 */
+	private Object getWebResultObject(Class wrapperClazz, Object businessObject, String propertyName) throws NoSuchFieldException, IntrospectionException,InvocationTargetException, IllegalAccessException{
+		PropertyDescriptor pd = getPropertyDescriptor(wrapperClazz, propertyName);
+		if(pd == null){
+			//TODO: what happens if pd not found.
+		}
+		Method readMethod = pd.getReadMethod();
+		Object webResult = readMethod.invoke(wrapperClazz.cast(businessObject), null);
+		return webResult;
+	}
+	
+	private MessageContext initializeRequest(Block messageBlock) throws XMLStreamException, MessageException{
+		MessageContext request = new MessageContext();
+		MessageFactory mf = (MessageFactory)FactoryRegistry.getFactory(MessageFactory.class);
+		//FIXME: The protocol should actually come from the binding information included in
+        // either the WSDL or an annotation.
+		Message m = mf.create(Protocol.soap11);
+		m.setBodyBlock(0,messageBlock);
+		request.setMessage(m);
+		request.getProperties().putAll(getRequestContext());
+	
+		return request;
+		
+	}
+	
+	private boolean isDocLitRaw(){
+		/* TODO: if(EndPoinInterfaceDescriptor.clientCall == Doc/literal) && OperationDescriptor.isWrapped() == false){ 
+		 * return true; 
+		 * else
+		 * return false;
+		 */
+		return false;
+	}
+	
+	private boolean isDocLitWrapped(){
+		/* TODO: if(EndPoinInterfaceDescriptor.clientCall == Doc/literal) && OperationDescriptor.isWrapped() == true){ 
+		 * return true; 
+		 * else
+		 * return false;
+		 */
+		return true;
+	}
+}
Index: C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/javax/jws/WebMethod.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/javax/jws/WebMethod.java	(revision 426662)
+++ C:/WebServices/Eclipse/workspace/axis2_live/modules/jaxws/src/javax/jws/WebMethod.java	(working copy)
@@ -11,7 +11,7 @@
 @Target (ElementType.METHOD)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface WebMethod {
-	String OperationName() default "";
+	String operationName() default "";
 	String action() default "";
 	String exclude() default "";
 }
