Index: test/org/apache/axis2/transport/tcp/TCPEchoRawXMLTest.java
===================================================================
--- test/org/apache/axis2/transport/tcp/TCPEchoRawXMLTest.java	(revision 948315)
+++ test/org/apache/axis2/transport/tcp/TCPEchoRawXMLTest.java	(working copy)
@@ -42,6 +42,7 @@
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.OutInAxisOperation;
+import org.apache.axis2.description.Parameter;
 import org.apache.axis2.util.Utils;
 import org.apache.axis2.wsdl.WSDLConstants;
 import org.apache.commons.logging.Log;
@@ -90,6 +91,7 @@
 
     protected void tearDown() throws Exception {
         UtilsTCPServer.stop();
+        configContext.getListenerManager().destroy();
     }
 
     private OMElement createPayload() {
@@ -188,10 +190,7 @@
 
     }
 
-    public void testEchoXMLSyncMC() throws Exception {
-        ConfigurationContext configContext =
-                ConfigurationContextFactory.createConfigurationContextFromFileSystem(Constants.TESTING_REPOSITORY, Constants.TESTING_REPOSITORY + "/conf/axis2.xml");
-
+    public void testEchoXMLSyncMC() throws Exception {        
         AxisOperation opdesc = new OutInAxisOperation(new QName("echoOMElement"));
         Options options = new Options();
         options.setTo(targetEPR);
Index: test/org/apache/axis2/transport/tcp/TCPTwoChannelEchoRawXMLTest.java
===================================================================
--- test/org/apache/axis2/transport/tcp/TCPTwoChannelEchoRawXMLTest.java	(revision 948315)
+++ test/org/apache/axis2/transport/tcp/TCPTwoChannelEchoRawXMLTest.java	(working copy)
@@ -79,6 +79,7 @@
 
     protected void tearDown() throws Exception {
         UtilsTCPServer.stop();
+        configContext.getListenerManager().destroy();
     }
 
     public void testEchoXMLCompleteASync() throws Exception {
Index: test/org/apache/axis2/transport/tcp/UtilsTCPServer.java
===================================================================
--- test/org/apache/axis2/transport/tcp/UtilsTCPServer.java	(revision 948315)
+++ test/org/apache/axis2/transport/tcp/UtilsTCPServer.java	(working copy)
@@ -24,7 +24,6 @@
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.ConfigurationContextFactory;
 import org.apache.axis2.description.AxisService;
-import org.apache.axis2.transport.tcp.TCPServer;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -35,7 +34,7 @@
 public class UtilsTCPServer {
     private static int count = 0;
 
-    private static TCPServer receiver;
+    private static TCPTransportListener receiver;
 
     public static final int TESTING_PORT = 5555;
 
@@ -66,16 +65,16 @@
                 throw new Exception("Repository directory does not exist");
             }
             ConfigurationContext er =
-                ConfigurationContextFactory.createConfigurationContextFromFileSystem(file.getAbsolutePath(), 
-                                                                                     file.getAbsolutePath() + "/conf/axis2.xml");
+                ConfigurationContextFactory.createConfigurationContextFromFileSystem(
+                        file.getAbsolutePath(), file.getAbsolutePath() + "/conf/axis2.xml");
             try {
                 Thread.sleep(1000);
             } catch (InterruptedException e1) {
                 throw new AxisFault("Thread interuptted", e1);
             }
-            receiver = new TCPServer(TESTING_PORT, er);
+            receiver = new TCPTransportListener();
+            receiver.init(er, er.getAxisConfiguration().getTransportIn(Constants.TRANSPORT_TCP));
             receiver.start();
-
         }
         count++;
     }
@@ -84,6 +83,7 @@
         try {
             if (count == 1) {
                 receiver.stop();
+                receiver.destroy();
                 count = 0;
                 System.out.print("Server stopped .....");
             } else {
@@ -98,8 +98,8 @@
     public static ConfigurationContext createClientConfigurationContext() throws Exception {
         File file = new File(prefixBaseDirectory(Constants.TESTING_REPOSITORY));
         ConfigurationContext configContext = 
-            ConfigurationContextFactory.createConfigurationContextFromFileSystem(file.getAbsolutePath(), 
-                                                                                 file.getAbsolutePath() + "/conf/axis2.xml");
+            ConfigurationContextFactory.createConfigurationContextFromFileSystem(
+                    file.getAbsolutePath(), file.getAbsolutePath() + "/conf/client_axis2.xml");
         return configContext;
     }
 
Index: conf/client_axis2.xml
===================================================================
--- conf/client_axis2.xml	(revision 0)
+++ conf/client_axis2.xml	(revision 0)
@@ -0,0 +1,246 @@
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one
+  ~ or more contributor license agreements. See the NOTICE file
+  ~ distributed with this work for additional information
+  ~ regarding copyright ownership. The ASF licenses this file
+  ~ to you under the Apache License, Version 2.0 (the
+  ~ "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing,
+  ~ software distributed under the License is distributed on an
+  ~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  ~ KIND, either express or implied. See the License for the
+  ~ specific language governing permissions and limitations
+  ~ under the License.
+  -->
+
+<axisconfig name="AxisJava2.0">
+    <!-- ================================================= -->
+    <!-- Parameters -->
+    <!-- ================================================= -->
+    <parameter name="hotdeployment">true</parameter>
+    <parameter name="hotupdate">false</parameter>
+    <parameter name="enableMTOM">false</parameter>
+
+    <!--If turned on with use the Accept header of the request to determine the contentType of the
+    response-->
+    <parameter name="httpContentNegotiation">false</parameter>
+
+    <!--During a fault, stacktrace can be sent with the fault message. The following flag will control -->
+    <!--that behaviour.-->
+    <parameter name="sendStacktraceDetailsWithFaults">true</parameter>
+
+    <!--If there aren't any information available to find out the fault reason, we set the message of the exception-->
+    <!--as the faultreason/Reason. But when a fault is thrown from a service or some where, it will be -->
+    <!--wrapped by different levels. Due to this the initial exception message can be lost. If this flag-->
+    <!--is set then, Axis2 tries to get the first exception and set its message as the faultreason/Reason.-->
+    <parameter name="DrillDownToRootCauseForFaultReason">false</parameter>
+
+    <!--This is the user name and password of admin console-->
+    <parameter name="userName">admin</parameter>
+    <parameter name="password">axis2</parameter>
+
+    <!--To override repository/services you need to uncomment following parameter and value SHOULD be absolute file path.-->
+    <!--ServicesDirectory only works on the following cases-->
+    <!---File based configurator and in that case the value should be a file URL (http:// not allowed)-->
+    <!---When creating URL Based configurator with URL “file://”  -->
+    <!--- War based configurator with expanded case , -->
+
+    <!--All the other scenarios it will be ignored.-->
+    <!--<parameter name="ServicesDirectory">service</parameter>-->
+    <!--To override repository/modules you need to uncomment following parameter and value SHOULD be absolute file path-->
+    <!--<parameter name="ModulesDirectory">modules</parameter>-->
+
+    <!--Following params will set the proper context paths for invocations. All the endpoints will have a commons context-->
+    <!--root which can configured using the following contextRoot parameter-->
+    <!--<parameter name="contextRoot">axis2</parameter>-->
+
+    <!--Our HTTP endpoints can handle both REST and SOAP. Following parameters can be used to distinguish those endpoints-->
+    <!--<parameter name="servicePath">services</parameter>-->
+    <!--<parameter name="restPath">rest</parameter>-->
+
+    <!-- Following parameter will completely disable REST handling in Axis2-->
+    <parameter name="disableREST" locked="false">false</parameter>
+
+    <!--POJO deployer , this will alow users to drop .class file and make that into a service-->
+    <deployer extension=".class" directory="pojo" class="org.apache.axis2.deployment.POJODeployer"/>
+    <deployer extension=".jar" directory="transports" class="org.apache.axis2.deployment.TransportDeployer"/>
+
+    <!-- Following parameter will set the host name for the epr-->
+    <!--<parameter name="hostname" locked="true">myhost.com</parameter>-->
+
+    <!-- ================================================= -->
+    <!-- Message Receivers -->
+    <!-- ================================================= -->
+    <!--This is the Default Message Receiver for the system , if you want to have MessageReceivers for -->
+    <!--all the other MEP implement it and add the correct entry to here , so that you can refer from-->
+    <!--any operation -->
+    <!--Note : You can override this for particular service by adding the same element with your requirement-->
+    <messageReceivers>
+        <messageReceiver mep="http://www.w3.org/2004/08/wsdl/in-only"
+                         class="org.apache.axis2.receivers.RawXMLINOnlyMessageReceiver"/>
+        <messageReceiver mep="http://www.w3.org/2004/08/wsdl/in-out"
+                         class="org.apache.axis2.receivers.RawXMLINOutMessageReceiver"/>
+        <messageReceiver mep="http://www.w3.org/2006/01/wsdl/in-only"
+                         class="org.apache.axis2.receivers.RawXMLINOnlyMessageReceiver"/>
+        <messageReceiver mep="http://www.w3.org/2006/01/wsdl/in-out"
+                         class="org.apache.axis2.receivers.RawXMLINOutMessageReceiver"/>
+    </messageReceivers>
+
+    <!-- ================================================= -->
+    <!-- Message Formatter -->
+    <!-- ================================================= -->
+    <!--Following content type to message formatter mapping can be used to implement support for different message -->
+    <!--format  serialization in Axis2. These message formats are expected to be resolved based on the content type. -->
+    <messageFormatters>
+        <messageFormatter contentType="application/x-www-form-urlencoded"
+                         class="org.apache.axis2.transport.http.XFormURLEncodedFormatter"/>
+        <messageFormatter contentType="multipart/form-data"
+                         class="org.apache.axis2.transport.http.MultipartFormDataFormatter"/>
+        <messageFormatter contentType="application/xml"
+                         class="org.apache.axis2.transport.http.ApplicationXMLFormatter"/>
+        <messageFormatter contentType="text/xml"
+                         class="org.apache.axis2.transport.http.SOAPMessageFormatter"/>
+        <messageFormatter contentType="application/soap+xml"
+                         class="org.apache.axis2.transport.http.SOAPMessageFormatter"/>
+    </messageFormatters>
+
+    <!-- ================================================= -->
+    <!-- Message Builders -->
+    <!-- ================================================= -->
+    <!--Following content type to builder mapping can be used to implement support for different message -->
+    <!--formats in Axis2. These message formats are expected to be resolved based on the content type. -->
+    <messageBuilders>
+        <messageBuilder contentType="application/xml"
+                         class="org.apache.axis2.builder.ApplicationXMLBuilder"/>
+        <messageBuilder contentType="application/x-www-form-urlencoded"
+                         class="org.apache.axis2.builder.XFormURLEncodedBuilder"/>
+        <!--Left commented because it adds the depandancy of servlet-api to other modules.
+        Please uncomment to Receive messages in multipart/form-data format-->
+        <!--<messageBuilder contentType="multipart/form-data"-->
+                         <!--class="org.apache.axis2.builder.MultipartFormDataBuilder"/>-->
+    </messageBuilders>
+
+    <module ref="addressing"/>
+
+    <!-- ================================================= -->
+    <!-- Target Resolvers -->
+    <!-- ================================================= -->
+    <!-- Uncomment the following and specify the class name for your TargetResolver to add -->
+    <!-- a TargetResolver. TargetResolvers are used to process the To EPR for example to -->
+    <!-- choose a server in a cluster -->
+    <!--<targetResolvers>-->
+    <!--<targetResolver class="" />-->
+    <!--</targetResolvers>-->
+
+    <transportReceiver name="tcp"
+                       class="org.apache.axis2.transport.tcp.TCPTransportListener">
+        <parameter name="transport.tcp.port">5556</parameter>
+    </transportReceiver>
+
+    <transportSender name="tcp"
+                     class="org.apache.axis2.transport.tcp.TCPTransportSender"/>
+
+
+    <!-- ================================================= -->
+    <!--  SOAP Role Configuration                          -->
+    <!-- ================================================= -->
+    <!-- Use the following pattern to configure this axis2
+         instance to act in particular roles. Note that in
+         the absence of any configuration, Axis2 will act
+         only in the ultimate receiver role -->
+    <!--
+    <SOAPRoleConfiguration isUltimateReceiver="true">
+    	<role>http://my/custom/role</role>
+    </SOAPRoleConfiguration>
+	-->
+
+    <!-- ================================================= -->
+    <!-- Phases  -->
+    <!-- ================================================= -->
+    <phaseOrder type="InFlow">
+        <!--  System pre-defined phases       -->
+         <phase name="Transport">
+            <handler name="RequestURIBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.RequestURIBasedDispatcher">
+                <order phase="Transport"/>
+            </handler>
+            <handler name="SOAPActionBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher">
+                <order phase="Transport"/>
+            </handler>
+         </phase>
+        <phase name="Addressing">
+            <handler name="AddressingBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.AddressingBasedDispatcher">
+                <order phase="Addressing"/>
+            </handler>
+        </phase>
+        <phase name="Security"/>
+        <phase name="PreDispatch"/>
+        <phase name="Dispatch" class="org.apache.axis2.engine.DispatchPhase">
+            <handler name="RequestURIBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.RequestURIBasedDispatcher"/>
+            <handler name="SOAPActionBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher"/>
+            <handler name="RequestURIOperationDispatcher"
+                     class="org.apache.axis2.dispatchers.RequestURIOperationDispatcher"/>
+            <handler name="SOAPMessageBodyBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.SOAPMessageBodyBasedDispatcher"/>
+
+            <handler name="HTTPLocationBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.HTTPLocationBasedDispatcher"/>
+        </phase>
+        <phase name="RMPhase"/>
+        <!--  System pre defined phases       -->
+        <!--   After Postdispatch phase module author or or service author can add any phase he want      -->
+        <phase name="OperationInPhase"/>
+    </phaseOrder>
+    <phaseOrder type="OutFlow">
+        <!--      user can add his own phases to this area  -->
+        <phase name="OperationOutPhase"/>
+        <!--system predefined phase-->
+        <!--these phase will run irrespective of the service-->
+        <phase name="RMPhase"/>
+        <phase name="PolicyDetermination"/>
+        <phase name="MessageOut"/>
+        <phase name="Security"/>
+    </phaseOrder>
+    <phaseOrder type="InFaultFlow">
+        <phase name="Addressing">
+             <handler name="AddressingBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.AddressingBasedDispatcher">
+                 <order phase="Addressing"/>
+            </handler>
+        </phase>
+        <phase name="Security"/>
+        <phase name="PreDispatch"/>
+        <phase name="Dispatch" class="org.apache.axis2.engine.DispatchPhase">
+            <handler name="RequestURIBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.RequestURIBasedDispatcher"/>
+            <handler name="SOAPActionBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher"/>
+            <handler name="RequestURIOperationDispatcher"
+                     class="org.apache.axis2.dispatchers.RequestURIOperationDispatcher"/>
+            <handler name="SOAPMessageBodyBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.SOAPMessageBodyBasedDispatcher"/>
+
+            <handler name="HTTPLocationBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.HTTPLocationBasedDispatcher"/>
+        </phase>
+        <phase name="RMPhase"/>
+        <!--      user can add his own phases to this area  -->
+        <phase name="OperationInFaultPhase"/>
+    </phaseOrder>
+    <phaseOrder type="OutFaultFlow">
+        <!--      user can add his own phases to this area  -->
+        <phase name="OperationOutFaultPhase"/>
+        <phase name="RMPhase"/>
+        <phase name="PolicyDetermination"/>
+        <phase name="MessageOut"/>
+        <phase name="Security"/>
+    </phaseOrder>
+</axisconfig>
Index: conf/axis2.xml
===================================================================
--- conf/axis2.xml	(revision 948315)
+++ conf/axis2.xml	(working copy)
@@ -137,11 +137,13 @@
     <!--</targetResolvers>-->
 
     <transportReceiver name="tcp"
-                       class="org.apache.axis2.transport.tcp.TCPServer">
-        <parameter name="port">6060</parameter>
+                       class="org.apache.axis2.transport.tcp.TCPTransportListener">
+        <parameter name="transport.tcp.port">5555</parameter>
         <!--If you want to give your own host address for EPR generation-->
         <!--uncommet following paramter , and set as you required.-->
-        <!--<parameter name="hostname">tcp://myApp.com/ws</parameter>-->
+        <!--<parameter name="transport.tcp.hostname">tcp://myApp.com/ws</parameter>-->
+        <!--parameter name="transport.tcp.contentType">text/xml</parameter-->
+        <!--<parameter name="transport.tcp.backlog">50</parameter>-->
     </transportReceiver>
 
     <transportSender name="tcp"
Index: src/org/apache/axis2/transport/tcp/TCPWorker.java
===================================================================
--- src/org/apache/axis2/transport/tcp/TCPWorker.java	(revision 948315)
+++ src/org/apache/axis2/transport/tcp/TCPWorker.java	(working copy)
@@ -17,101 +17,81 @@
  * under the License.
  */
 
-
 package org.apache.axis2.transport.tcp;
 
-import org.apache.axiom.om.OMXMLParserWrapper;
 import org.apache.axiom.soap.SOAPEnvelope;
-import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
-import org.apache.axis2.builder.BuilderUtil;
-import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.transport.TransportUtils;
 import org.apache.axis2.context.MessageContext;
-import org.apache.axis2.description.TransportInDescription;
-import org.apache.axis2.description.TransportOutDescription;
-import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.axis2.engine.AxisEngine;
-import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.util.MessageContextBuilder;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.Reader;
 import java.net.Socket;
 
 /**
  * This Class is the work hoarse of the TCP request, this process the incomming SOAP Message.
  */
 public class TCPWorker implements Runnable {
+
     private static final Log log = LogFactory.getLog(TCPWorker.class);
-    private ConfigurationContext configurationContext;
+
+    private TCPEndpoint endpoint;
     private Socket socket;
 
-    public TCPWorker(ConfigurationContext configurationContext, Socket socket) {
-        this.configurationContext = configurationContext;
+    public TCPWorker(TCPEndpoint endpoint, Socket socket) {
+        this.endpoint = endpoint;
         this.socket = socket;
     }
 
     public void run() {
+
         MessageContext msgContext = null;
 
         try {
-            AxisConfiguration axisConf = configurationContext.getAxisConfiguration();
-            TransportOutDescription transportOut =
-                    axisConf.getTransportOut(Constants.TRANSPORT_TCP);
-            TransportInDescription transportIn =
-                    axisConf.getTransportIn(Constants.TRANSPORT_TCP);
+            msgContext = endpoint.createMessageContext();
+            msgContext.setIncomingTransportName(Constants.TRANSPORT_TCP);
+            //msgContext.setTransportIn(endpoint.getListener().getTransportInDescription());
 
-            if ((transportOut != null) && (transportIn != null)) {
+            TCPOutTransportInfo outInfo = new TCPOutTransportInfo();
+            outInfo.setSocket(socket);
+            outInfo.setContentType(endpoint.getContentType());
+            msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outInfo);
 
-                // create the Message Context and fill in the values
-                msgContext = configurationContext.createMessageContext();
-                msgContext.setIncomingTransportName(Constants.TRANSPORT_TCP);
-                msgContext.setTransportIn(transportIn);
-                msgContext.setTransportOut(transportOut);
-                msgContext.setServerSide(true);
+            // create the SOAP Envelope
+            SOAPEnvelope envelope = TransportUtils.createSOAPMessage(msgContext,
+                    socket.getInputStream(), endpoint.getContentType());
+            msgContext.setEnvelope(envelope);
 
-                OutputStream out = socket.getOutputStream();
+            AxisEngine.receive(msgContext);
 
-                msgContext.setProperty(MessageContext.TRANSPORT_OUT, out);
+        } catch (Exception e) {
+            sendFault(msgContext, e);
 
-                // create the SOAP Envelope
-                Reader in = new InputStreamReader(socket.getInputStream());
-                OMXMLParserWrapper builder = BuilderUtil.getBuilder(in);
-                SOAPEnvelope envelope = (SOAPEnvelope) builder.getDocumentElement();
-
-                msgContext.setEnvelope(envelope);
-                AxisEngine.receive(msgContext);
-            } else {
-                throw new AxisFault(Messages.getMessage("unknownTransport",
-                                                        Constants.TRANSPORT_TCP));
-            }
-        } catch (Throwable e) {
-            log.error(e.getMessage(), e);
+        } finally {
             try {
+                socket.close();
+            } catch (IOException e) {
+                log.error("Error while closing a TCP socket", e);
+            }
+        }
+    }
 
-                if (msgContext != null) {
-                    msgContext.setProperty(MessageContext.TRANSPORT_OUT, socket.getOutputStream());
+    private void sendFault(MessageContext msgContext, Exception fault) {
+        log.error("Error while processing TCP request through the Axis2 engine", fault);
+        try {
+            if (msgContext != null) {
+                msgContext.setProperty(MessageContext.TRANSPORT_OUT, socket.getOutputStream());
 
-                    MessageContext faultContext =
-                            MessageContextBuilder.createFaultMessageContext(msgContext, e);
+                MessageContext faultContext =
+                        MessageContextBuilder.createFaultMessageContext(msgContext, fault);
 
-                    AxisEngine.sendFault(faultContext);
-                }
-            } catch (Exception e1) {
-                log.error(e1.getMessage(), e1);
+                AxisEngine.sendFault(faultContext);
             }
-        } finally {
-            if (socket != null) {
-                try {
-                    this.socket.close();
-                } catch (IOException e1) {
-                    // Do nothing
-                }
-            }
+        } catch (Exception e) {
+            log.error("Error while sending the fault response", e);
         }
     }
 }
Index: src/org/apache/axis2/transport/tcp/TCPConstants.java
===================================================================
--- src/org/apache/axis2/transport/tcp/TCPConstants.java	(revision 0)
+++ src/org/apache/axis2/transport/tcp/TCPConstants.java	(revision 0)
@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.transport.tcp;
+
+public class TCPConstants {
+
+    public static final String PARAM_PORT = "transport.tcp.port";
+    public static final String PARAM_HOST = "transport.tcp.hostname";
+    public static final String PARAM_BACKLOG = "transport.tcp.backlog";
+    public static final String PARAM_CONTENT_TYPE = "transport.tcp.contentType";
+
+    public static final int TCP_DEFAULT_BACKLOG = 50;
+    public static final String TCP_DEFAULT_CONTENT_TYPE = "text/xml";
+}
Index: src/org/apache/axis2/transport/tcp/TCPTransportSender.java
===================================================================
--- src/org/apache/axis2/transport/tcp/TCPTransportSender.java	(revision 948315)
+++ src/org/apache/axis2/transport/tcp/TCPTransportSender.java	(working copy)
@@ -21,113 +21,135 @@
 package org.apache.axis2.transport.tcp;
 
 import org.apache.axis2.AxisFault;
-import org.apache.axis2.addressing.EndpointReference;
-import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.description.OutInAxisOperation;
+import org.apache.axis2.engine.AxisEngine;
 import org.apache.axis2.context.MessageContext;
-import org.apache.axis2.description.TransportOutDescription;
-import org.apache.axis2.handlers.AbstractHandler;
-import org.apache.axis2.i18n.Messages;
-import org.apache.axis2.transport.TransportSender;
+import org.apache.axis2.transport.OutTransportInfo;
 import org.apache.axis2.transport.TransportUtils;
-import org.apache.axis2.util.URL;
+import org.apache.axis2.transport.base.AbstractTransportSender;
+import org.apache.axiom.soap.SOAPEnvelope;
 
 import java.io.IOException;
-import java.io.OutputStream;
-import java.io.Writer;
-import java.net.InetSocketAddress;
-import java.net.MalformedURLException;
-import java.net.Socket;
-import java.net.SocketAddress;
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.io.ByteArrayInputStream;
+import java.net.*;
+import java.util.Map;
+import java.util.HashMap;
 
-public class TCPTransportSender extends AbstractHandler implements TransportSender {
-    protected Writer out;
-    private Socket socket;
+public class TCPTransportSender extends AbstractTransportSender {
 
-    public void init(ConfigurationContext confContext, TransportOutDescription transportOut)
-            throws AxisFault {
-    }
+    public void sendMessage(MessageContext msgContext, String targetEPR,
+                            OutTransportInfo outTransportInfo) throws AxisFault {
 
-    public void stop() {
-    }
+        if (targetEPR != null) {
+            Map<String,String> params = getURLParameters(targetEPR);
+            int timeout = -1;
+            if (params.containsKey("timeout")) {
+                timeout = Integer.parseInt(params.get("timeout"));
+            }
+            Socket socket = openTCPConnection(targetEPR, timeout);
 
-    public void cleanup(MessageContext msgContext) throws AxisFault {
-        try {
-            if (socket != null) {
-                socket.close();
-                socket = null;
+            try {
+                TransportUtils.writeMessage(msgContext, socket.getOutputStream());
+                if (!msgContext.getOptions().isUseSeparateListener() && !msgContext.isServerSide()){
+                    waitForReply(msgContext, socket, params.get("contentType"));
+                }
+            } catch (IOException e) {
+                handleException("Error while sending a TCP request", e);
+            } finally {
+                closeConnection(socket);
             }
-        } catch (IOException e) {
-            // TODO: Log this?
+
+        } else if (outTransportInfo != null && (outTransportInfo instanceof TCPOutTransportInfo)) {
+            TCPOutTransportInfo outInfo = (TCPOutTransportInfo) outTransportInfo;
+            try {
+                TransportUtils.writeMessage(msgContext, outInfo.getSocket().getOutputStream());
+            } catch (IOException e) {
+                handleException("Error while sending a TCP response", e);
+            } finally {
+                closeConnection(outInfo.getSocket());
+            }
         }
     }
 
-    /**
-     * Method invoke
-     *
-     * @param msgContext
-     * @throws AxisFault
-     */
-    public InvocationResponse invoke(MessageContext msgContext) throws AxisFault {
+    private void waitForReply(MessageContext msgContext, Socket socket,
+                              String contentType) throws AxisFault {
 
-        // Check for the REST behaviour, if you desire rest beahaviour
-        // put a <parameter name="doREST" value="true"/> at the axis2.xml
-        msgContext.setDoingMTOM(TransportUtils.doWriteMTOM(msgContext));
-        msgContext.setDoingSwA(TransportUtils.doWriteSwA(msgContext));
+        if (!(msgContext.getAxisOperation() instanceof OutInAxisOperation) &&
+                msgContext.getProperty(org.apache.axis2.Constants.PIGGYBACK_MESSAGE) == null) {
+            return;
+        }
 
-        OutputStream out;
-        EndpointReference epr = null;
+        if (contentType == null) {
+            contentType = "text/xml";
+        }
 
-        if (msgContext.getTo() != null && !msgContext.getTo().hasAnonymousAddress()) {
-            epr = msgContext.getTo();
+        try {
+            MessageContext responseMsgCtx = createResponseMessageContext(msgContext);
+            BufferedReader reader = new BufferedReader(new InputStreamReader(
+                    socket.getInputStream()));
+
+            char[] cbuf = new char[1024];
+            int len;
+            StringBuffer buff = new StringBuffer();
+            while ((len = reader.read(cbuf)) != -1) {
+                buff.append(cbuf, 0, len);
+            }
+
+            ByteArrayInputStream bais = new ByteArrayInputStream(buff.toString().getBytes());
+            SOAPEnvelope envelope = TransportUtils.createSOAPMessage(msgContext,
+                        bais, contentType);
+            responseMsgCtx.setEnvelope(envelope);
+            AxisEngine.receive(responseMsgCtx);
+        } catch (Exception e) {
+            handleException("Error while processing response", e);
         }
+    }
 
-        if (epr != null) {
-            if (!epr.hasNoneAddress()) {
-                out = openTheConnection(epr, msgContext);
-                TransportUtils.writeMessage(msgContext, out);
-                try {
-                    socket.shutdownOutput();
-                    msgContext.setProperty(MessageContext.TRANSPORT_IN, socket.getInputStream());
-                } catch (IOException e) {
-                    throw AxisFault.makeFault(e);
+    private Map<String,String> getURLParameters(String url) throws AxisFault {
+        try {
+            Map<String,String> params = new HashMap<String,String>();
+            URI tcpUrl = new URI(url);
+            String query = tcpUrl.getQuery();
+            if (query != null) {
+                String[] paramStrings = query.split("&");
+                for (String p : paramStrings) {
+                    int index = p.indexOf('=');
+                    params.put(p.substring(0, index), p.substring(index+1));
                 }
             }
-        } else {
-            out = (OutputStream) msgContext.getProperty(MessageContext.TRANSPORT_OUT);
+            return params;
+        } catch (URISyntaxException e) {
+            handleException("Malformed tcp url", e);
+        }
+        return null;
+    }
 
-            if (out != null) {
-                TransportUtils.writeMessage(msgContext, out);
-            } else {
-                throw new AxisFault(
-                        "Both the TO and Property MessageContext.TRANSPORT_OUT is Null, No where to send");
+    private Socket openTCPConnection(String url, int timeout) throws AxisFault {
+        try {
+            URI tcpUrl = new URI(url);
+            if (!tcpUrl.getScheme().equals("tcp")) {
+                throw new Exception("Invalid protocol prefix : " + tcpUrl.getScheme());
             }
+            SocketAddress address = new InetSocketAddress(tcpUrl.getHost(), tcpUrl.getPort());
+            Socket socket = new Socket();
+            if (timeout != -1) {
+                socket.setSoTimeout(timeout);
+            }
+            socket.connect(address);
+            return socket;
+        } catch (Exception e) {
+            handleException("Error while opening TCP connection to : " + url, e);
         }
-
-        TransportUtils.setResponseWritten(msgContext, true);
-        
-        return InvocationResponse.CONTINUE;
+        return null;
     }
 
-    protected OutputStream openTheConnection(EndpointReference toURL, MessageContext msgContext)
-            throws AxisFault {
-        if (toURL != null) {
-            try {
-                URL url = new URL(toURL.getAddress());
-                SocketAddress add = new InetSocketAddress(url.getHost(), (url.getPort() == -1)
-                        ? 80
-                        : url.getPort());
-
-                socket = new Socket();
-                socket.connect(add);
-
-                return socket.getOutputStream();
-            } catch (MalformedURLException e) {
-                throw AxisFault.makeFault(e);
-            } catch (IOException e) {
-                throw AxisFault.makeFault(e);
-            }
-        } else {
-            throw new AxisFault(Messages.getMessage("canNotBeNull", "End point reference"));
+    private void closeConnection(Socket socket) {
+        try {
+            socket.close();
+        } catch (IOException e) {
+            log.error("Error while closing a TCP socket", e);
         }
     }
 }
Index: src/org/apache/axis2/transport/tcp/TCPEndpoint.java
===================================================================
--- src/org/apache/axis2/transport/tcp/TCPEndpoint.java	(revision 0)
+++ src/org/apache/axis2/transport/tcp/TCPEndpoint.java	(revision 0)
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package org.apache.axis2.transport.tcp;
+
+import org.apache.axis2.transport.base.ProtocolEndpoint;
+import org.apache.axis2.transport.base.ParamUtils;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.util.Utils;
+import org.apache.axis2.description.ParameterInclude;
+import org.apache.axis2.description.AxisService;
+
+import java.net.SocketException;
+
+public class TCPEndpoint extends ProtocolEndpoint {
+
+    private String host = null;
+    private int port = -1;
+    private int backlog = TCPConstants.TCP_DEFAULT_BACKLOG;
+    private String contentType;
+
+    public TCPEndpoint() {
+
+    }
+
+    public TCPEndpoint(String host, int port, int backlog) {
+        this.host = host;
+        this.port = port;
+        this.backlog = backlog;
+    }
+
+    public int getPort() {
+        return port;
+    }
+
+    public String getHost() {
+        return host;
+    }
+
+    public int getBacklog() {
+        return backlog;
+    }
+
+    public String getContentType() {
+        return contentType;
+    }
+
+    public boolean loadConfiguration(ParameterInclude params) throws AxisFault {
+        port = ParamUtils.getOptionalParamInt(params, TCPConstants.PARAM_PORT, -1);
+        if (port == -1) {
+            return false;
+        }
+
+        contentType = ParamUtils.getOptionalParam(params, TCPConstants.PARAM_CONTENT_TYPE);
+        if (contentType == null) {
+            contentType = TCPConstants.TCP_DEFAULT_CONTENT_TYPE;
+        }
+
+        host = ParamUtils.getOptionalParam(params, TCPConstants.PARAM_HOST);
+        backlog = ParamUtils.getOptionalParamInt(params, TCPConstants.PARAM_BACKLOG,
+                TCPConstants.TCP_DEFAULT_BACKLOG);
+        return true;
+    }
+
+    public EndpointReference[] getEndpointReferences(AxisService service,
+                                                     String ip) throws AxisFault {
+        if (host == null && ip == null) {
+            try {
+                ip = Utils.getIpAddress(getListener().getConfigurationContext().
+                        getAxisConfiguration());
+            } catch (SocketException ex) {
+                throw new AxisFault("Unable to determine the host's IP address", ex);
+            }
+        }
+
+        String url = "tcp://" + (host != null ? host : ip) + ":" + port;
+        if (getService() != null) {
+            String context = getListener().getConfigurationContext().getServiceContextPath();
+            url +=  (context.startsWith("/") ? "" : "/") + context + "/" +
+                    getServiceName();
+        }
+        return new EndpointReference[] { new EndpointReference(url) };
+    }
+    
+}
Index: src/org/apache/axis2/transport/tcp/TCPOutTransportInfo.java
===================================================================
--- src/org/apache/axis2/transport/tcp/TCPOutTransportInfo.java	(revision 0)
+++ src/org/apache/axis2/transport/tcp/TCPOutTransportInfo.java	(revision 0)
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.transport.tcp;
+
+import org.apache.axis2.transport.OutTransportInfo;
+
+import java.io.OutputStream;
+import java.net.Socket;
+
+public class TCPOutTransportInfo implements OutTransportInfo {
+
+    private Socket socket;
+    private String contentType;
+
+    public Socket getSocket() {
+        return socket;
+    }
+
+    public void setSocket(Socket socket) {
+        this.socket = socket;
+    }
+
+    public void setContentType(String contentType) {
+        this.contentType = contentType;
+    }
+
+    public String getContentType() {
+        return contentType;
+    }
+}
Index: src/org/apache/axis2/transport/tcp/TCPTransportListener.java
===================================================================
--- src/org/apache/axis2/transport/tcp/TCPTransportListener.java	(revision 0)
+++ src/org/apache/axis2/transport/tcp/TCPTransportListener.java	(revision 0)
@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.transport.tcp;
+
+import org.apache.axis2.transport.base.AbstractTransportListenerEx;
+import org.apache.axis2.AxisFault;
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class TCPTransportListener extends AbstractTransportListenerEx<TCPEndpoint> {
+
+    private Map<TCPEndpoint, TCPServer> serverTable = new ConcurrentHashMap<TCPEndpoint, TCPServer>();
+
+    protected void doInit() throws AxisFault {
+
+    }
+
+    protected TCPEndpoint createEndpoint() {
+        return new TCPEndpoint();
+    }
+
+    protected void startEndpoint(TCPEndpoint endpoint) throws AxisFault {
+        try {
+            TCPServer server = new TCPServer(endpoint, workerPool);
+            server.startServer();
+            serverTable.put(endpoint, server);
+        } catch (IOException e) {
+            handleException("Error while starting the TCP endpoint", e);
+        }
+    }
+
+    protected void stopEndpoint(TCPEndpoint endpoint) {
+        try {
+            TCPServer server = serverTable.get(endpoint);
+            if (server != null) {
+                server.stopServer();
+            }
+        } catch (IOException e) {
+            log.error("Error while stopping the TCP endpoint", e);
+        } finally {
+            serverTable.remove(endpoint);
+        }
+    }
+}
Index: src/org/apache/axis2/transport/tcp/TCPServer.java
===================================================================
--- src/org/apache/axis2/transport/tcp/TCPServer.java	(revision 948315)
+++ src/org/apache/axis2/transport/tcp/TCPServer.java	(working copy)
@@ -20,212 +20,66 @@
 
 package org.apache.axis2.transport.tcp;
 
-import org.apache.axis2.AxisFault;
-import org.apache.axis2.Constants;
-import org.apache.axis2.util.Utils;
-import org.apache.axis2.addressing.EndpointReference;
-import org.apache.axis2.context.ConfigurationContext;
-import org.apache.axis2.context.ConfigurationContextFactory;
-import org.apache.axis2.context.MessageContext;
-import org.apache.axis2.context.SessionContext;
-import org.apache.axis2.description.Parameter;
-import org.apache.axis2.description.TransportInDescription;
-import org.apache.axis2.engine.ListenerManager;
-import org.apache.axis2.i18n.Messages;
-import org.apache.axis2.transport.TransportListener;
-import org.apache.commons.logging.Log;
+import org.apache.axis2.transport.base.threads.WorkerPool;
 import org.apache.commons.logging.LogFactory;
+import org.apache.commons.logging.Log;
 
-import java.io.File;
-import java.io.IOException;
 import java.net.ServerSocket;
 import java.net.Socket;
-import java.net.SocketException;
+import java.net.InetAddress;
+import java.io.IOException;
 
-/**
- * Class TCPServer
- */
-public class TCPServer implements Runnable, TransportListener {
-    private int port = 8000;
+public class TCPServer implements Runnable {
+    
+    private TCPEndpoint endpoint;
+    private ServerSocket serverSocket;
+    private WorkerPool workerPool;
     private boolean started = false;
+
     private static final Log log = LogFactory.getLog(TCPServer.class);
-    private ConfigurationContext configContext;
-    private ServerSocket serversocket;
-    private String hostAddress = null;
-    private String contextPath;
 
-    public TCPServer() {
+    public TCPServer(TCPEndpoint endpoint, WorkerPool workerPool) {
+        this.endpoint = endpoint;
+        this.workerPool = workerPool;
     }
 
-    public TCPServer(int port, ConfigurationContext configContext) throws AxisFault {
-        try {
-            this.configContext = configContext;
-            serversocket = new ServerSocket(port);
-
-            ListenerManager listenerManager = configContext.getListenerManager();
-            TransportInDescription trsIn = new TransportInDescription(Constants.TRANSPORT_TCP);
-            trsIn.setReceiver(this);
-            if (listenerManager == null) {
-                listenerManager = new ListenerManager();
-                listenerManager.init(configContext);
-            }
-            listenerManager.addListener(trsIn, true);
-            contextPath = configContext.getServiceContextPath();
-
-        } catch (IOException e1) {
-            throw AxisFault.makeFault(e1);
-        }
-    }
-
-    public TCPServer(int port, String dir) throws AxisFault {
-        this(port, ConfigurationContextFactory.createConfigurationContextFromFileSystem(dir, null));
-    }
-
-    public void init(ConfigurationContext axisConf, TransportInDescription transprtIn)
-            throws AxisFault {
-        this.configContext = axisConf;
-
-        Parameter param = transprtIn.getParameter(PARAM_PORT);
-
-        if (param != null) {
-            this.port = Integer.parseInt((String) param.getValue());
-        }
-        param = transprtIn.getParameter(HOST_ADDRESS);
-        if (param != null) {
-            hostAddress = ((String) param.getValue()).trim();
-        }
-        contextPath = configContext.getServiceContextPath();
-    }
-
-    public static void main(String[] args) throws AxisFault, NumberFormatException {
-        if (args.length != 2) {
-            System.out.println("TCPServer repositoryLocation port");
-        } else {
-            File repository = new File(args[0]);
-
-            if (!repository.exists()) {
-                System.out.print("Repository file does not exists .. initializing repository");
-            }
-
-            TCPServer tcpServer = new TCPServer(Integer.parseInt(args[1]),
-                                                repository.getAbsolutePath());
-
-            System.out.println("[Axis2] Using the Repository " + repository.getAbsolutePath());
-            System.out.println("[Axis2] Starting the TCP Server on port " + args[1]);
-            tcpServer.start();
-            Runtime.getRuntime().addShutdownHook(new Thread(tcpServer));
-        }
-    }
-
     public void run() {
         while (started) {
             Socket socket = null;
 
             try {
-                socket = serversocket.accept();
-            } catch (java.io.InterruptedIOException iie) {
-            }
-            catch (Exception e) {
-                log.debug(e);
+                socket = serverSocket.accept();
+            } catch (java.io.InterruptedIOException ignored) {
 
+            } catch (Exception e) {
+                log.debug(e);
                 break;
             }
 
             if (socket != null) {
-                configContext.getThreadPool().execute(new TCPWorker(configContext, socket));
+                workerPool.execute(new TCPWorker(endpoint, socket));
             }
         }
     }
 
-    public synchronized void start() throws AxisFault {
-        if (serversocket == null) {
-            serversocket = openSocket(port);
-        }
-        started = true;
-        this.configContext.getThreadPool().execute(this);
-    }
-
-
-    /**
-     * Controls the number of server sockets kept open.
-     */
-    public ServerSocket openSocket(int port) throws AxisFault {
-        for (int i = 0; i < 5; i++) {
-            try {
-                return new ServerSocket(port + i);
-            } catch (IOException e) {
-                // What I'm gonna do here. Try again.
-            }
-        }
-
-        throw new AxisFault(Messages.getMessage("failedToOpenSocket"));
-    }
-
-
-    /*
-    *  (non-Javadoc)
-    * @see org.apache.axis2.transport.TransportListener#stop()
-    */
-    public void stop() throws AxisFault {
-        try {
-            this.serversocket.close();
-            started = false;
-        } catch (IOException e) {
-            throw AxisFault.makeFault(e);
-        }
-    }
-
-    public ConfigurationContext getConfigurationContext() {
-        return this.configContext;
-    }
-
-    /**
-     * I fthe hostAddress parameter is present in axis2.xml then the EPR will be
-     * created by taking the hostAddres into account
-     * (non-Javadoc)
-     *
-     * @see org.apache.axis2.transport.TransportListener#getEPRForService(String, String)
-     */
-    public EndpointReference getEPRForService(String serviceName, String ip) throws AxisFault {
-        EndpointReference[] epRsForService = getEPRsForService(serviceName, ip);
-        return epRsForService != null ? epRsForService[0] : null;
-    }
-
-    public EndpointReference[] getEPRsForService(String serviceName, String ip) throws AxisFault {
-        //if host address is present
-        if (hostAddress != null) {
-            if (serversocket != null) {
-                // todo this has to fix
-                return new EndpointReference[]{
-                        new EndpointReference(hostAddress + "/" + contextPath + serviceName)};
+    public void startServer() throws IOException {
+        if (serverSocket == null) {
+            if (endpoint.getHost() != null) {
+                InetAddress address = InetAddress.getByName(endpoint.getHost());
+                serverSocket = new ServerSocket(endpoint.getPort(), endpoint.getBacklog(), address);
             } else {
-                log.debug("Unable to generate EPR for the transport tcp");
-                return null;
+                serverSocket = new ServerSocket(endpoint.getPort(), endpoint.getBacklog());
             }
         }
-        if (ip == null) {
-            try {
-                ip = Utils.getIpAddress(configContext.getAxisConfiguration());
-            } catch (SocketException e) {
-                throw AxisFault.makeFault(e);
-            }
-        }
-        if (serversocket != null) {
-            // todo this has to fix
-            return new EndpointReference[]{
-                    new EndpointReference("tcp://" + ip + ":" + (serversocket.getLocalPort())
-                                          + "/" + contextPath + "/" + serviceName)};
-        } else {
-            log.debug("Unable to generate EPR for the transport tcp");
-            return null;
-        }
+        started = true;
+        endpoint.getListener().getConfigurationContext().getThreadPool().execute(this);
+        log.info("TCP server started on port : " + endpoint.getPort());
     }
 
-    public SessionContext getSessionContext(MessageContext messageContext) {
-        return null;
+    public void stopServer() throws IOException {
+        started = false;
+        serverSocket.close();
+        serverSocket = null;
+        log.info("TCP server stopped on port : " + endpoint.getPort());
     }
-
-    public void destroy() {
-        this.configContext = null;
-    }
 }
Index: pom.xml
===================================================================
--- pom.xml	(revision 948315)
+++ pom.xml	(working copy)
@@ -67,6 +67,8 @@
     	                              tofile="target/test-resources/samples/modules/addressing.mar"/>
                                 <copy file="conf/axis2.xml"
     	                              tofile="target/test-resources/samples/conf/axis2.xml"/>
+                                <copy file="conf/client_axis2.xml"
+    	                              tofile="target/test-resources/samples/conf/client_axis2.xml"/>
                             </tasks>
                         </configuration>
                        <goals>