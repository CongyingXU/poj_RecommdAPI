Index: modules/json/test/org/apache/axis2/json/JSONDataSourceTest.java
===================================================================
--- modules/json/test/org/apache/axis2/json/JSONDataSourceTest.java	(revision 508347)
+++ modules/json/test/org/apache/axis2/json/JSONDataSourceTest.java	(working copy)
@@ -51,14 +51,13 @@
     }
 
     public void testMappedSerialize3() throws XMLStreamException {
-//        String jsonString = getMappedJSONString();
-//        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
-//        XMLStreamWriter writer = StAXUtils.createXMLStreamWriter(outStream);
-//        JSONDataSource source = getMappedDataSource(jsonString);
-//        source.serialize(writer);
-//        writer.flush();
-//        assertEquals("<?xml version='1.0' encoding='UTF-8'?><mapping><inner><first>test string one</first></inner><inner>test string two</inner><name>foo</name></mapping>", new String(outStream.toByteArray()));
-        //<mapping><inner>test string one</inner><inner>test string two</inner><name>foo</name></mapping>
+        String jsonString = getMappedJSONString();
+        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
+        XMLStreamWriter writer = StAXUtils.createXMLStreamWriter(outStream);
+        JSONDataSource source = getMappedDataSource(jsonString);
+        source.serialize(writer);
+        writer.flush();
+        assertEquals("<?xml version='1.0' encoding='UTF-8'?><mapping><inner><first>test string one</first></inner><inner>test string two</inner><name>foo</name></mapping>", new String(outStream.toByteArray()));
     }
 
     public void testBadgerfishSerialize1() throws XMLStreamException {
@@ -104,11 +103,7 @@
     }
 
     private String getMappedJSONString() {
-//        {"mapping":{"inner":[{"first":"test string one"},"test string two"],"name":"foo"}}
-//          <mapping><inner><first>test string one</first></inner><inner>test string two</inner><name>foo</name></mapping>
-//        return "{\"mapping\":{\"inner\":[{\"first\":\"test string one\"},\"test string two\"],\"name\":\"foo\"}}";
-        return "{\"mapping\":{\"inner\":[\"test string one\",\"test string two\"],\"name\":\"foo\"}}";
-//        return "{\"mapping\":{\"inner\":\"foo\"}}";
+        return "{\"mapping\":{\"inner\":[{\"first\":\"test string one\"},\"test string two\"],\"name\":\"foo\"}}";
     }
 
     private InputStream readLocalName(InputStream in) {

Index: modules/json/src/org/apache/axis2/json/JSONMessageFormatter.java
===================================================================
--- modules/json/src/org/apache/axis2/json/JSONMessageFormatter.java	(revision 508347)
+++ modules/json/src/org/apache/axis2/json/JSONMessageFormatter.java	(working copy)
@@ -54,15 +54,11 @@
 public class JSONMessageFormatter implements MessageFormatter {
 
     public String getContentType(MessageContext msgCtxt, OMOutputFormat format, String soapActionString) {
-        String contentType;
+        String contentType = (String) msgCtxt.getProperty(Constants.Configuration.CONTENT_TYPE);
         String encoding = format.getCharSetEncoding();
-        if (msgCtxt.getProperty(Constants.Configuration.CONTENT_TYPE) != null) {
-            contentType = (String) msgCtxt.getProperty(Constants.Configuration.CONTENT_TYPE);
-            //if the content type is not set useing the MESSAGE_TYPE as the content type
-        } else {
+        if (contentType == null) {
             contentType = (String) msgCtxt.getProperty(Constants.Configuration.MESSAGE_TYPE);
         }
-
         if (encoding != null) {
             contentType += "; charset=" + encoding;
         }
@@ -74,22 +70,24 @@
      * and it contains a JSONDataSource with a correctly formatted JSON String, gets it directly from the
      * DataSource and returns as a byte array. If not, the OM tree is expanded and it is serialized
      * into the output stream and byte array is returned.
+     *
      * @param msgCtxt Message context which contains the soap envelope to be written
-     * @param format format of the message, this is ignored
+     * @param format  format of the message, this is ignored
      * @return the payload as a byte array
      * @throws AxisFault if there is an error in writing the message using StAX writer or IF THE USER
-     *                      TRIES TO SEND A JSON MESSAGE WITH NAMESPACES USING THE "MAPPED" CONVENTION.
+     *                   TRIES TO SEND A JSON MESSAGE WITH NAMESPACES USING THE "MAPPED" CONVENTION.
      */
 
     public byte[] getBytes(MessageContext msgCtxt, OMOutputFormat format) throws AxisFault {
         OMElement element = msgCtxt.getEnvelope().getBody().getFirstElement();
         //if the element is an OMSourcedElementImpl and it contains a JSONDataSource with correct convention,
         //directly get the JSON string.
+
         if (element instanceof OMSourcedElementImpl && getStringToWrite(((OMSourcedElementImpl) element).getDataSource()) != null)
         {
             String jsonToWrite = getStringToWrite(((OMSourcedElementImpl) element).getDataSource());
             return jsonToWrite.getBytes();
-        //otherwise serialize the OM by expanding the tree
+            //otherwise serialize the OM by expanding the tree
         } else {
             try {
                 ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
@@ -123,6 +121,7 @@
     /**
      * If the data source is a "Mapped" formatted data source, gives the JSON string by
      * directly taking from the data source.
+     *
      * @param dataSource data source to be checked
      * @return the JSON string to write
      */
@@ -138,13 +137,14 @@
      * Writes the JSON message to the output stream with the correct convention. If the payload is an
      * OMSourcedElementImpl and it contains a JSONDataSource with a correctly formatted JSON String,
      * gets it directly from the DataSource and writes to the output stream. If not, the OM tree is expanded
-     * and it is serialized into the output stream.
-     * @param msgCtxt Message context which contains the soap envelope to be written
-     * @param format format of the message, this is ignored
-     * @param out output stream to be written in to
+     * and it is serialized into the output stream.              *
+     *
+     * @param msgCtxt  Message context which contains the soap envelope to be written
+     * @param format   format of the message, this is ignored
+     * @param out      output stream to be written in to
      * @param preserve ignored
      * @throws AxisFault if there is an error in writing the message using StAX writer or IF THE USER
-     *                      TRIES TO SEND A JSON MESSAGE WITH NAMESPACES USING THE "MAPPED" CONVENTION.
+     *                   TRIES TO SEND A JSON MESSAGE WITH NAMESPACES USING THE "MAPPED" CONVENTION.
      */
 
     public void writeTo(MessageContext msgCtxt, OMOutputFormat format,
Index: modules/json/src/org/apache/axis2/json/JSONDataSource.java
===================================================================
--- modules/json/src/org/apache/axis2/json/JSONDataSource.java	(revision 508347)
+++ modules/json/src/org/apache/axis2/json/JSONDataSource.java	(working copy)
@@ -102,7 +102,7 @@
             int x = reader.next();
             switch (x) {
                 case XMLStreamConstants.START_ELEMENT:
-                    xmlStreamWriter.writeStartElement(reader.getPrefix(), reader.getLocalName(), reader.getNamespaceURI(reader.getPrefix()));
+                    xmlStreamWriter.writeStartElement(reader.getPrefix(), reader.getLocalName(), reader.getNamespaceURI());
                     int namespaceCount = reader.getNamespaceCount();
                     for (int i = namespaceCount - 1; i >= 0; i--) {
                         xmlStreamWriter.writeNamespace(reader.getNamespacePrefix(i), reader.getNamespaceURI(i));
