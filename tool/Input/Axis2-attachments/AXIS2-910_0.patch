Index: C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/Dispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/Dispatch.java	(revision 424366)
+++ C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/Dispatch.java	(working copy)
@@ -111,6 +111,8 @@
     }
     
     public Object invoke(Object obj) throws WebServiceException {
+        /*
+        
         // Create the InvocationContext instance for this request/response flow.
         InvocationContext invocationContext = InvocationContextFactory.createInvocationContext(null);
         invocationContext.setServiceClient(axisController.getServiceClient());
@@ -157,6 +159,10 @@
         rspParam = fromOM(rspEnvelope, rspParam, axisController.getServiceClient().getOptions().getSoapVersionURI());
         
         return rspParam.getValue();
+        
+        */
+        
+        return null;
     }
     
    public void invokeOneWay(Object obj) throws WebServiceException{
Index: C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/ClientMediator.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/ClientMediator.java	(revision 424366)
+++ C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/ClientMediator.java	(working copy)
@@ -20,7 +20,9 @@
 
 import javax.xml.namespace.QName;
 import javax.xml.ws.BindingProvider;
+import javax.xml.ws.Service;
 import javax.xml.ws.WebServiceException;
+import javax.xml.ws.Service.Mode;
 
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.client.ServiceClient;
@@ -64,7 +66,13 @@
             axisController.setClientContext(clientContext);
             
             JAXBDispatch<T> dispatch = new JAXBDispatch<T>(axisController);
+            if (clientContext.getServiceMode() != null) {
             dispatch.setMode(clientContext.getServiceMode());
+            }
+            else {
+                dispatch.setMode(Service.Mode.PAYLOAD);
+            }
+
             dispatch.setJAXBContext(clientContext.getJAXBContext());
             return dispatch;
         }catch(AxisFault e){
@@ -88,7 +96,13 @@
 			AxisController axisController = buildAxisController();
 			axisController.setClientContext(clientContext);
 			XMLDispatch<T> dispatch = new XMLDispatch<T>(axisController);
+            if (clientContext.getServiceMode() != null) {
             dispatch.setMode(clientContext.getServiceMode());
+            }
+            else {
+                dispatch.setMode(Service.Mode.PAYLOAD);
+            }
+            
 			return dispatch;
 		}catch(AxisFault e){
 			throw new WebServiceException(e.getMessage());
Index: C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/core/controller/AxisInvocationController.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/core/controller/AxisInvocationController.java	(revision 424366)
+++ C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/core/controller/AxisInvocationController.java	(working copy)
@@ -17,67 +17,51 @@
 package org.apache.axis2.jaxws.core.controller;
 
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 
+import javax.xml.namespace.QName;
 import javax.xml.ws.AsyncHandler;
 import javax.xml.ws.Response;
-import javax.xml.ws.WebServiceException;
-import javax.xml.ws.Service.Mode;
 
 import org.apache.axiom.om.OMElement;
+import org.apache.axiom.soap.SOAPEnvelope;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.client.OperationClient;
 import org.apache.axis2.client.ServiceClient;
 import org.apache.axis2.jaxws.AxisCallback;
 import org.apache.axis2.jaxws.BindingProvider;
 import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.core.InvocationContext;
 import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.impl.AsyncListener;
 import org.apache.axis2.jaxws.impl.AsyncListenerWrapper;
-import org.apache.axis2.jaxws.impl.AsyncListener;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.MessageException;
+import org.apache.axis2.jaxws.message.factory.MessageFactory;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
 import org.apache.axis2.jaxws.util.Constants;
+import org.apache.axis2.wsdl.WSDLConstants;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 /**
- * The <tt>AxisInvocationController</tt> is a stateless entity used to
- * invoke the Axis2 client APIs.  All of the information that the 
- * AxisInvocationController needs should exist within the InvocatonContext
- * that is passed in.  
+ * The <tt>AxisInvocationController</tt> is an implementation of the 
+ * {@link org.apache.axis2.jaxws.core.controller.InvocationController}
+ * interface.  This implemenation uses the Axis2 engine to drive the
+ * request to the target service.  
  * 
- * The request information is passed in within the InvocationContext.  The
- * AxisInvocationController assumes that there is a MessageContext within that
- * InvocationContext that is populated with all of the information that it
- * needs to invoke.  If not, an error will be returned.  Once the response 
- * comes back, the information for that response will be held inside of the
- * MessageContext representing the response, that exists in the 
- * InvocationContext.
- * 
- * The AxisInvocationController supports four different invocation patterns:
- * 
- * 1) synchronous - This is represented by the {@link #invoke(InvocationContext)}
- * method.  This is a blocking call to the Axis2 client.
- * 
- * 2) one-way - This is represented by the {@link #invokeOneWay(InvocationContext)}
- * method.  This is a one-way invocation that only returns errors related
- * to sending the message.  If an error occurs while processing, the client
- * will not be notified.
- * 
- * 3) asynchronous (callback) - {@link #invokeAsync(InvocationContext, AsyncHandler)}
- * 
- * 4) asynchronous (polling) - {@link #invokeAsync(InvocationContext)}
+ * For more information on how to invoke this class, please see the 
+ * InvocationController interface comments.
  */
 public class AxisInvocationController implements InvocationController {
     
     private static Log log = LogFactory.getLog(AxisInvocationController.class);
     
-    /**
-     * Performs a synchronous (blocking) invocation of the client.
-     * 
-     * @param ic
-     * @return
+    /*
+     *  (non-Javadoc)
+     * @see org.apache.axis2.jaxws.core.controller.InvocationController#invoke(org.apache.axis2.jaxws.core.InvocationContext)
      */
     public InvocationContext invoke(InvocationContext ic) {
         if (log.isDebugEnabled()) {
@@ -93,46 +77,83 @@
             throw ExceptionFactory.makeWebServiceException("Cannot invoke; request MessageContext was null");
         }
         
-        // Setup the MessageContext for the response
+        // Get the request MessageContext
         MessageContext requestMsgCtx = ic.getRequestMessageContext();
-        MessageContext responseMsgCtx = new MessageContext();
-        ic.setResponseMessageContext(responseMsgCtx);
+        MessageContext responseMsgCtx = null;
         
-        ServiceClient client = ic.getServiceClient();        
-        if (client != null) {
+        // We need the qname of the operation being invoked to know which 
+        // AxisOperation the OperationClient should be based on.
+        // TODO: Need to get the operation qname from the MessageContext
+        QName operationName = ServiceClient.ANON_OUT_IN_OP;
+        
+        // TODO: Will the ServiceClient stick around on the InvocationContext
+        // or will we need some other mechanism of creating this?
+        // Try to create an OperationClient from the passed in ServiceClient
+        ServiceClient svcClient = ic.getServiceClient();
+        OperationClient opClient = createOperationClient(svcClient, operationName);
+        
+        if (opClient != null) {
             // Get the target endpoint address and setup the TO endpoint 
             // reference.  This tells us where the request is going.
             String targetUrl = (String) requestMsgCtx.getProperties().get(BindingProvider.ENDPOINT_ADDRESS_PROPERTY);
             EndpointReference toEPR = new EndpointReference(targetUrl);
-            client.getOptions().setTo(toEPR);
+            opClient.getOptions().setTo(toEPR);
             
             // Get the SOAP Action (if needed)
-            String soapAction = getSOAPAction(requestMsgCtx);
-            client.getOptions().setAction(soapAction);
+            String soapAction = configureSOAPAction(requestMsgCtx);
+            opClient.getOptions().setAction(soapAction);
             
-            // Use the ServiceClient to send the request.
-            OMElement rspEnvelope = null;
+            // Use the OperationClient to send the request and put the contents
+            // of the response in the response MessageContext.
             try {
-                OMElement reqEnvelope = requestMsgCtx.getMessageAsOM();
-                rspEnvelope = client.sendReceive(ServiceClient.ANON_OUT_IN_OP, reqEnvelope);
+                // The MessageContext will contain a Message object with the
+                // contents that need to be sent.  We need to get those contents
+                // in a form that Axis2 can consume them, an AXIOM SOAPEnvelope.
+                Message requestMsg = requestMsgCtx.getMessage();
+                SOAPEnvelope requestOM = (SOAPEnvelope) requestMsg.getAsOMElement();
+                
+                org.apache.axis2.context.MessageContext axisRequestMsgCtx = 
+                    requestMsgCtx.getAxisMessageContext();
+                axisRequestMsgCtx.setEnvelope(requestOM);
+                
+                // Setting the ServiceContext will create the association between 
+                // the OperationClient it's MessageContexts and the 
+                // AxisService/AxisOperation that they are tied to.
+                axisRequestMsgCtx.setServiceContext(svcClient.getServiceContext());
+
+                // Set the Axis2 request MessageContext
+                opClient.addMessageContext(axisRequestMsgCtx);
+                opClient.execute(true);
+                
+                // Collect the response MessageContext and envelope
+                org.apache.axis2.context.MessageContext axisResponseMsgCtx = 
+                    opClient.getMessageContext(WSDLConstants.MESSAGE_LABEL_IN_VALUE);
+                
+                SOAPEnvelope rspEnvelope = axisResponseMsgCtx.getEnvelope();
+                Message responseMsg = null;
+                if (rspEnvelope != null) {
+                    responseMsg = createMessageFromOM(rspEnvelope);
+                }
+                
+                // Setup the response MessageContext
+                responseMsgCtx = new MessageContext(axisResponseMsgCtx);
+                responseMsgCtx.setMessage(responseMsg);
             } catch (AxisFault e) {
                 throw ExceptionFactory.makeWebServiceException(e);
+            } catch (MessageException e) { 
+                throw ExceptionFactory.makeWebServiceException(e);
             }
             
-            // Set the response message on the response MessageContext
-            responseMsgCtx.setMessageAsOM(rspEnvelope);
+            // Set the response MessageContext on the InvocationContext
+            ic.setResponseMessageContext(responseMsgCtx);
         }
 
         return ic;
     }
     
-    /**
-     * Performs a one-way invocation of the client.  This is NOT a robust
-     * invocation, so any fault that occurs during the processing of the request
-     * will not be returned to the client.  Errors returned to the client are
-     * problems that occurred during the sending of the message to the server.
-     * 
-     * @param ic
+    /*
+     *  (non-Javadoc)
+     * @see org.apache.axis2.jaxws.core.controller.InvocationController#invokeOneWay(org.apache.axis2.jaxws.core.InvocationContext)
      */
     public void invokeOneWay(InvocationContext ic) {
         if (log.isDebugEnabled()) {
@@ -157,39 +178,54 @@
         MessageContext responseMsgCtx = new MessageContext();
         ic.setResponseMessageContext(responseMsgCtx);
         
-        ServiceClient client = ic.getServiceClient();        
-        if (client != null) {
+        // Try to create an OperationClient from the passed in ServiceClient
+        ServiceClient svcClient = ic.getServiceClient();
+        OperationClient opClient = createOperationClient(svcClient, ServiceClient.ANON_OUT_ONLY_OP);
+        
+        if (opClient != null) {
             // Get the target endpoint address and setup the TO endpoint 
             // reference.  This tells us where the request is going.
             String targetUrl = (String) requestMsgCtx.getProperties().get(BindingProvider.ENDPOINT_ADDRESS_PROPERTY);
             EndpointReference toEPR = new EndpointReference(targetUrl);
-            client.getOptions().setTo(toEPR);
+            opClient.getOptions().setTo(toEPR);
             
             // Get the SOAP Action (if needed)
-            String soapAction = getSOAPAction(requestMsgCtx);
-            client.getOptions().setAction(soapAction);
+            String soapAction = configureSOAPAction(requestMsgCtx);
+            opClient.getOptions().setAction(soapAction);
             
-            // Use the ServiceClient to send the request.
+            // Use the OperationClient to send the request.
+            Message responseMsg = null;
+            org.apache.axis2.context.MessageContext axisResponseMsgCtx = null;
             try {
-                OMElement reqEnvelope = requestMsgCtx.getMessageAsOM();
-                client.fireAndForget(ServiceClient.ANON_OUT_ONLY_OP, reqEnvelope);
+                // We need to prepare the contents of the Message from the request 
+                // MessageContext to be sent
+                Message requestMsg = requestMsgCtx.getMessage();
+                SOAPEnvelope requestOM = (SOAPEnvelope) requestMsg.getAsOMElement();
+                
+                org.apache.axis2.context.MessageContext axisRequestMsgCtx = 
+                    requestMsgCtx.getAxisMessageContext();
+                
+                axisRequestMsgCtx.setEnvelope(requestOM);
+                
+                // Setting the ServiceContext will create the association between 
+                // the OperationClient it's MessageContexts and the 
+                // AxisService/AxisOperation that they are tied to.
+                axisRequestMsgCtx.setServiceContext(svcClient.getServiceContext());
+                opClient.addMessageContext(axisRequestMsgCtx);
+                opClient.execute(true);
             } catch (AxisFault e) {
                 throw ExceptionFactory.makeWebServiceException(e);
+            } catch (MessageException e) {
+                throw ExceptionFactory.makeWebServiceException(e);
             }
         }
         
         return;
     }
     
-    /**
-     * Performs an asynchronous (non-blocking) invocation of the client based 
-     * on a callback model.  The AsyncHandler that is passed in is the callback
-     * that the client programmer supplied when they invoked their JAX-WS
-     * Dispatch or their SEI-based dynamic proxy.  
-     * 
-     * @param ic
-     * @param callback
-     * @return
+    /*
+     *  (non-Javadoc)
+     * @see org.apache.axis2.jaxws.core.controller.InvocationController#invokeAsync(org.apache.axis2.jaxws.core.InvocationContext, javax.xml.ws.AsyncHandler)
      */
     public Future<?> invokeAsync(InvocationContext ic, AsyncHandler callback) {
         if (log.isDebugEnabled()) {
@@ -207,29 +243,29 @@
         
         // Setup the MessageContext for the response
         MessageContext requestMsgCtx = ic.getRequestMessageContext();
-        MessageContext responseMsgCtx = new MessageContext();
-        ic.setResponseMessageContext(responseMsgCtx);
         
-        ServiceClient client = ic.getServiceClient();        
-        if (client != null) {
+        ServiceClient svcClient = ic.getServiceClient();
+        OperationClient opClient = createOperationClient(svcClient, ServiceClient.ANON_OUT_IN_OP);
+        
+        if (opClient != null) {
             // Get the target endpoint address and setup the TO endpoint 
             // reference.  This tells us where the request is going.
             String targetUrl = (String) requestMsgCtx.getProperties().get(BindingProvider.ENDPOINT_ADDRESS_PROPERTY);
             EndpointReference toEPR = new EndpointReference(targetUrl);
-            client.getOptions().setTo(toEPR);
+            opClient.getOptions().setTo(toEPR);
             
             // Get the SOAP Action (if needed)
-            String soapAction = getSOAPAction(requestMsgCtx);
-            client.getOptions().setAction(soapAction);
+            String soapAction = configureSOAPAction(requestMsgCtx);
+            opClient.getOptions().setAction(soapAction);
             
             // Setup the client so that it knows whether the underlying call to
             // Axis2 knows whether or not to start a listening port for an
             // asynchronous response.
             Boolean useAsyncMep = (Boolean) requestMsgCtx.getProperties().get(Constants.USE_ASYNC_MEP);
             if((useAsyncMep != null && useAsyncMep.booleanValue()) 
-                    || client.getOptions().isUseSeparateListener()) {
-                client.getOptions().setUseSeparateListener(true);
-                client.getOptions().setTransportInProtocol("http");
+                    || opClient.getOptions().isUseSeparateListener()) {
+                opClient.getOptions().setUseSeparateListener(true);
+                opClient.getOptions().setTransportInProtocol("http");
             }
             
             // There should be an AsyncListener that is configured and set on the
@@ -240,6 +276,7 @@
             AsyncListener listener = ic.getAsyncListener();
             AxisCallback axisCallback = new AxisCallback();
             listener.setAxisCallback(axisCallback);
+            listener.setInvocationContext(ic);
             
             // Once the AsyncListener is configured, we must include that in an 
             // AsyncListenerWrapper.  The wrapper is what will handle the lifecycle 
@@ -257,14 +294,29 @@
                 throw ExceptionFactory.makeWebServiceException("Cannot call asynchronous invoke with null callback");
             }
             
-            // Get the request message from the MessageContext and send it
-            // using the ServiceClient API.
-            OMElement reqEnvelope = requestMsgCtx.getMessageAsOM();
             try {
-                client.sendReceiveNonBlocking(ServiceClient.ANON_OUT_IN_OP, reqEnvelope, axisCallback);
+                // Get the request message from the MessageContext and send it
+                // using the OperationClient API.
+                Message requestMsg = requestMsgCtx.getMessage();
+                SOAPEnvelope requestOM = (SOAPEnvelope) requestMsg.getAsOMElement();
+                
+                // The envelope must be set on the Axis2 MessageContext as a
+                // OM-based SOAPEnvelope
+                org.apache.axis2.context.MessageContext axisRequestMsgCtx = 
+                    requestMsgCtx.getAxisMessageContext();
+                axisRequestMsgCtx.setEnvelope(requestOM);
+                
+                // Setting the ServiceContext will create the association between 
+                // the OperationClient it's MessageContexts and the 
+                // AxisService/AxisOperation that they are tied to.
+                axisRequestMsgCtx.setServiceContext(svcClient.getServiceContext());
+                opClient.addMessageContext(axisRequestMsgCtx);
+                opClient.setCallback(axisCallback);
+                opClient.execute(false);
             } catch (AxisFault e) {
-                e.printStackTrace();
                 throw ExceptionFactory.makeWebServiceException(e);
+            } catch (MessageException e) {
+                throw ExceptionFactory.makeWebServiceException(e);
             }
             
             // Now that the request has been sent, start the listener thread so that it can
@@ -290,63 +342,40 @@
             
             return wrapper;
         }
-
+        
         return null;
     }
     
-    /**
-     * Performs an asynchronous (non-blocking) invocation of the client based 
-     * on a polling model.  The Response object that is returned allows the 
-     * client programmer to poll against it to see if a response has been sent
-     * back by the server.
-     * 
-     * @param ic
-     * @return
+    /*
+     *  (non-Javadoc)
+     * @see org.apache.axis2.jaxws.core.controller.InvocationController#invokeAsync(org.apache.axis2.jaxws.core.InvocationContext)
      */
     public Response invokeAsync(InvocationContext ic) {
         if (log.isDebugEnabled()) {
             log.debug("Invocation pattern: async (polling)");
         }
-        return null;
+        
+        throw ExceptionFactory.makeWebServiceException("Aysnchronous polling invocations are not supported yet.");
     }
     
     /**
-     * Creates the OperationClient instance that will be invoked upon.
+     * Returns the SOAPAction that should be used for the invocation.  This
+     * method will get the information from the MessageContext passed in
+     * either from :
      * 
-     * This will be used instead of the ServiceClient as we mature the 
-     * AxisInvocationController
+     * a) the JAX-WS properties available on the MessageContext or
+     * b) the WSDL configuration information available from the MessageContext 
+     * 
+     * @param ctx
+     * @return
      */
-    /*
-    private OperationClient createOperationClient(MessageContext mc) {
-        OperationClient client = null;
-        String operationName = mc.getOperationName();
+    private String configureSOAPAction(MessageContext ctx) {
+        //TODO: Need to get SOAPAction information from the WSDL config
         
-        if (operationName != null) {
-            AxisService service = mc.getMetadata();
-            AxisOperation operation = service.getOperation(new QName(operationName));
-            
-            if (operation == null) {
-                throw ExceptionFactory.makeWebServiceException("Operation not found.");
-            }
-            
-            try {
-                ServiceContext ctx = new ServiceContext(service, );
-                client = operation.createClient(ctx, null);
-                client.addMessageContext(null);
-            }
-            catch (AxisFault af) {
-                throw new WebServiceException(af);
-            }            
-        }
-        else {
-            throw ExceptionFactory.makeWebServiceException("Operation name not set.");
-        }
-        
-        return client;
-    }
-    */
-    
-    private String getSOAPAction(MessageContext ctx){
+        //TODO: Need to determine what the story is with using the SOAPAction
+        // declared in the WSDL.  If the property says not to use it, but it's
+        // listed in the WSDL, do we still include it?  Do we include it if
+        // the property is not even set?
         Boolean useSoapAction = (Boolean) ctx.getProperties().get(BindingProvider.SOAPACTION_USE_PROPERTY);
         if(useSoapAction != null && useSoapAction.booleanValue()){
             return (String) ctx.getProperties().get(BindingProvider.SOAPACTION_URI_PROPERTY);
@@ -354,4 +383,43 @@
         
         return null;
     }
-}
+    
+    /**
+     * Use the provided ServiceClient instance to create an OperationClient identified 
+     * by the operation QName provided.
+     * 
+     * @param sc
+     * @param operation
+     * @return
+     */
+    private OperationClient createOperationClient(ServiceClient sc, QName operation) {
+        if (sc == null) {
+            throw ExceptionFactory.makeWebServiceException("Cannot create OperationClient, ServiceClient was null");
+        }
+        if (operation == null) {
+            throw ExceptionFactory.makeWebServiceException("Cannot create OperationClient, QName was null");
+        }
+        
+        if (log.isDebugEnabled()) {
+            log.debug("Creating OperationClient for operation: " + operation);
+        }
+        
+        try {
+            OperationClient client = sc.createClient(ServiceClient.ANON_OUT_IN_OP);
+            return client;
+        } catch (AxisFault e) {
+            //TODO: NLS and ExceptionFactory
+            throw ExceptionFactory.makeWebServiceException(e);
+        }
+    }
+    
+    private Message createMessageFromOM(OMElement om) throws MessageException {
+        try {
+            MessageFactory mf = (MessageFactory) FactoryRegistry.getFactory(MessageFactory.class);
+            Message msg = mf.createFrom(om);
+            return msg;
+        } catch (Exception e) {
+            throw ExceptionFactory.makeWebServiceException(e);
+        }
+    }
+}
Index: C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/core/controller/InvocationController.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/core/controller/InvocationController.java	(revision 424366)
+++ C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/core/controller/InvocationController.java	(working copy)
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2006 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.axis2.jaxws.core.controller;
 
 import java.util.concurrent.Future;
@@ -7,13 +23,79 @@
 
 import org.apache.axis2.jaxws.core.InvocationContext;
 
+/**
+ * The <tt>InvocationController</tt> is an interface for an entity used to
+ * invoke a target web service.  All of the information that the 
+ * InvocationController needs should exist within the InvocatonContext
+ * that is passed in to the various invoke methods.  
+ * 
+ * The request information is passed in within the InvocationContext.  The
+ * InvocationController assumes that there is a MessageContext within that
+ * InvocationContext that is populated with all of the information that it
+ * needs to invoke.  If not, an error will be returned.  Once the response 
+ * comes back, the information for that response will be held inside of the
+ * MessageContext representing the response, that exists in the 
+ * InvocationContext.
+ * 
+ * The InvocationController supports four different invocation patterns:
+ * 
+ * 1) synchronous - This is represented by the {@link #invoke(InvocationContext)}
+ * method.  This is a blocking, request/response call to the web service.
+ * 
+ * 2) one-way - This is represented by the {@link #invokeOneWay(InvocationContext)}
+ * method.  This is a one-way invocation that only returns errors related
+ * to sending the message.  If an error occurs while processing, the client
+ * will not be notified.
+ * 
+ * 3) asynchronous (callback) - {@link #invokeAsync(InvocationContext, AsyncHandler)}
+ * 
+ * 4) asynchronous (polling) - {@link #invokeAsync(InvocationContext)}
+ */
 public interface InvocationController {
     
+    /**
+     * Performs a synchronous (blocking) invocation of a target service.  The 
+     * InvocationContext passed in should contain a valid MessageContext 
+     * containing the properties and message to be sent for the request.  The
+     * response contents will be processed and placed in the InvocationContext
+     * as well.
+     * 
+     * @param ic
+     * @return
+     */
     public InvocationContext invoke(InvocationContext ic);
     
+    /**
+     * Performs a one-way invocation of the client.  This is SHOULD NOT be a 
+     * robust invocation, so any fault that occurs during the processing of 
+     * the request will not be returned to the client.  Errors returned to the
+     * client are problems that occurred during the sending of the message to 
+     * the server.
+     * 
+     * @param ic
+     */
     public void invokeOneWay(InvocationContext ic);
     
+    /**
+     * Performs an asynchronous (non-blocking) invocation of the client based 
+     * on a callback model.  The AsyncHandler that is passed in is the callback
+     * that the client programmer supplied when they invoked their JAX-WS
+     * Dispatch or their SEI-based dynamic proxy.  
+     * 
+     * @param ic
+     * @param callback
+     * @return
+     */
     public Response invokeAsync(InvocationContext ic);
     
+    /**
+     * Performs an asynchronous (non-blocking) invocation of the client based 
+     * on a polling model.  The Response object that is returned allows the 
+     * client programmer to poll against it to see if a response has been sent
+     * back by the server.
+     * 
+     * @param ic
+     * @return
+     */
     public Future<?> invokeAsync(InvocationContext ic, AsyncHandler asyncHandler);
 }
Index: C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/core/MessageContext.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/core/MessageContext.java	(revision 424366)
+++ C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/core/MessageContext.java	(working copy)
@@ -23,6 +23,7 @@
 
 import org.apache.axiom.om.OMElement;
 import org.apache.axis2.jaxws.description.ServiceDescription;
+import org.apache.axis2.jaxws.message.Message;
 
 /**
  * The <code>org.apache.axis2.jaxws.core.MessageContext</code> is
@@ -41,9 +42,10 @@
     private org.apache.axis2.context.MessageContext axisMsgCtx;
     private Map<String, Object> properties;
     private ServiceDescription serviceDesc;
+    private Message message;
     private Mode mode;
         
-    private OMElement message;  //FIXME: This is temporary until we integrate with the Message Model
+    private OMElement omMessage;  //FIXME: This is temporary until we integrate with the Message Model
     
     public MessageContext() {
         axisMsgCtx = new org.apache.axis2.context.MessageContext();
@@ -81,15 +83,15 @@
     
     //FIXME: This is a temporary mechanism until the Message Model 
     //implementation is available.
-    public void setMessageAsOM(OMElement msg) {
+    public void setMessage(Message msg) {
         message = msg;
     }
     
-    public OMElement getMessageAsOM() {
+    public Message getMessage() {
         return message;
     }
     
-    protected org.apache.axis2.context.MessageContext getAxisMessageContext() {
+    public org.apache.axis2.context.MessageContext getAxisMessageContext() {
         return axisMsgCtx;
     }
 }
Index: C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/param/JAXBParameter.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/param/JAXBParameter.java	(revision 424366)
+++ C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/param/JAXBParameter.java	(working copy)
@@ -102,8 +102,11 @@
 	public void fromOM(OMElement omElement) {
 		createUnmarshaller();
         
+        String omString = omElement.toString();
+        System.out.println(">> [OMSTRING] " + omString);
+        
         try {
-            ByteArrayInputStream bais = new ByteArrayInputStream(omElement.toString().getBytes());
+            ByteArrayInputStream bais = new ByteArrayInputStream(omString.getBytes());
             value = unmarshaller.unmarshal(bais);
             
         } catch (JAXBException e) {
Index: C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/impl/AsyncListener.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/impl/AsyncListener.java	(revision 424366)
+++ C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/impl/AsyncListener.java	(working copy)
@@ -22,7 +22,11 @@
 
 import org.apache.axiom.om.OMElement;
 import org.apache.axis2.jaxws.AxisCallback;
+import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.core.InvocationContext;
 import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.MessageException;
 
 
 /**
@@ -38,6 +42,7 @@
 
     protected AxisCallback axisCallback;
     protected Mode mode;
+    protected InvocationContext invocationCtx;
     
     public AsyncListener() {
         //do nothing
@@ -51,6 +56,10 @@
         axisCallback = cb;
     }
     
+    public void setInvocationContext(InvocationContext ic) {
+        invocationCtx = ic;
+    }
+    
     //TODO: This will probably be removed or at least made a little more 
     //clear since it's only the Dispatch that's concerned with the mode.
     public void setMode(Mode m) {
@@ -68,6 +77,7 @@
             }
             
             MessageContext responseMsgCtx = axisCallback.getResponseMessageContext();
+            
             Object responseObj = getResponseValueObject(responseMsgCtx);
             return responseObj;            
         }
@@ -85,7 +95,12 @@
      * @param msg
      */
     protected Object getResponseValueObject(MessageContext mc) {
-        OMElement msg = mc.getMessageAsOM();
-        return msg.toString();
+        try {
+            Message msg = mc.getMessage();
+            OMElement om = msg.getAsOMElement();
+            return om.toString();
+        } catch (MessageException e) {
+            throw ExceptionFactory.makeWebServiceException(e);
+        }
     }
 }
Index: C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/AxisCallback.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/AxisCallback.java	(revision 424366)
+++ C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/AxisCallback.java	(working copy)
@@ -21,6 +21,9 @@
 import org.apache.axis2.client.async.AsyncResult;
 import org.apache.axis2.client.async.Callback;
 import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.factory.MessageFactory;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
 
 /**
  * The AxisCallback is the touch point for asynchronous invocations 
@@ -47,7 +50,11 @@
         
         try {
             OMElement responseEnv = result.getResponseEnvelope();
-            responseMsgCtx.setMessageAsOM(responseEnv);
+            
+            MessageFactory mf = (MessageFactory) FactoryRegistry.getFactory(MessageFactory.class);
+            Message msg = mf.createFrom(responseEnv);
+            
+            responseMsgCtx.setMessage(msg);
         } catch (Exception e) {
             e.printStackTrace();
         }
Index: C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/XMLDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/XMLDispatch.java	(revision 424366)
+++ C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/XMLDispatch.java	(working copy)
@@ -16,16 +16,33 @@
  */
 package org.apache.axis2.jaxws.client;
 
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.transform.Source;
+import javax.xml.ws.Service.Mode;
+
 import org.apache.axiom.om.OMElement;
 import org.apache.axis2.jaxws.AxisController;
+import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.impl.AsyncListener;
-import org.apache.axis2.jaxws.param.Parameter;
-import org.apache.axis2.jaxws.param.ParameterFactory;
+import org.apache.axis2.jaxws.message.Block;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.MessageException;
+import org.apache.axis2.jaxws.message.Protocol;
+import org.apache.axis2.jaxws.message.factory.BlockFactory;
+import org.apache.axis2.jaxws.message.factory.MessageFactory;
+import org.apache.axis2.jaxws.message.factory.SourceBlockFactory;
+import org.apache.axis2.jaxws.message.factory.XMLStringBlockFactory;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 
 public class XMLDispatch<T> extends BaseDispatch<T> {
-
-    public Class type;
+    private static final Log log = LogFactory.getLog(XMLDispatch.class);
     
+    private Class type;
+    private Class blockFactoryType;
+    
     public XMLDispatch() {
         super();
     }
@@ -34,39 +51,136 @@
         super(ac);
     }
     
+    public Class getType() {
+        return type;
+    }
+    
+    public void setType(Class c) {
+        type = c;
+    }
+    
     public AsyncListener createAsyncListener() {
+        if (log.isDebugEnabled()) {
+            log.debug("Creating new AsyncListener for XMLDispatch");
+        }
         XMLDispatchAsyncListener al = new XMLDispatchAsyncListener();
         al.setMode(mode);
         al.setType(type);
+        al.setBlockFactoryType(blockFactoryType);
         return al;
     }
     
-    public OMElement createMessageFromValue(Object value) {
+    public Message createMessageFromValue(Object value) {
         type = value.getClass();
+        if (log.isDebugEnabled()) {
+            log.debug("Parameter type: " + type.getName());
+            log.debug("Message mode: " + mode.name());
+        }
         
-        // FIXME: This is where the Message Model will be integrated instead of 
-        // the ParameterFactory/Parameter APIs.
-        Parameter param = ParameterFactory.createParameter(type);
-        param.setValue(value);
-        OMElement envelope = toOM(param, 
-                axisController.getServiceClient().getOptions().getSoapVersionURI());
-        return envelope;
+        Block block = null;
+        blockFactoryType = getBlockFactory(value);
+        BlockFactory factory = (BlockFactory) FactoryRegistry.getFactory(blockFactoryType);
+        if (log.isDebugEnabled()) {
+            log.debug("Loaded block factory type [" + blockFactoryType.getName());
+        }
+        
+        Message message = null;
+        if (mode.equals(Mode.PAYLOAD)) {
+            try {
+                MessageFactory mf = (MessageFactory) FactoryRegistry.getFactory(MessageFactory.class);
+                block = factory.createFrom(value, null, null);
+                
+                // FIXME: The protocol should actually come from the binding information included in
+                // either the WSDL or an annotation.
+                message = mf.create(Protocol.soap11);
+                message.setBodyBlock(0, block);
+            } catch (XMLStreamException e) {
+                e.printStackTrace();
+            } catch (MessageException e) {
+                e.printStackTrace();
+            }
+        }
+        else if (mode.equals(Mode.MESSAGE)) {
+            try {
+                QName soapEnvQname = new QName("http://schemas.xmlsoap.org/soap/envelope/", "Envelope");
+                block = factory.createFrom(value, null, soapEnvQname);
+                
+                MessageFactory mf = (MessageFactory) FactoryRegistry.getFactory(MessageFactory.class);
+                message = mf.createFrom(block.getXMLStreamReader(true));
+            } catch (XMLStreamException e) {
+                e.printStackTrace();
+            } catch (MessageException e) {
+                e.printStackTrace();
+            }
+        }
+
+        return message;
     }
 
-    public Object getValueFromMessage(OMElement message) {
-        // FIXME: This is where the Message Model will be integrated instead of 
-        // the ParameterFactory/Parameter APIs.
-        Parameter param = ParameterFactory.createParameter(type);
-        param = fromOM(message, param, 
-                axisController.getServiceClient().getOptions().getSoapVersionURI());
-        return param.getValue();
+    public Object getValueFromMessage(Message message) {
+        Object value = null;
+        Block block = null;
+        
+        if (log.isDebugEnabled()) {
+            log.debug("Attempting to get the value object from the returned message");
+        }
+        
+        try {
+            if (mode.equals(Mode.PAYLOAD)) {
+                    BlockFactory factory = (BlockFactory) FactoryRegistry.getFactory(blockFactoryType);
+                    block = message.getBodyBlock(0, null, factory);
+            }
+            else if (mode.equals(Mode.MESSAGE)) {
+                    // TODO: Make this conversion more efficient
+                    OMElement messageOM = message.getAsOMElement();
+                    QName soapEnvQname = new QName("http://schemas.xmlsoap.org/soap/envelope/", "Envelope");
+                    
+                    XMLStringBlockFactory stringFactory = (XMLStringBlockFactory) FactoryRegistry.getFactory(XMLStringBlockFactory.class);
+                    Block stringBlock = stringFactory.createFrom(messageOM.toString(), null, soapEnvQname);
+                    
+                    BlockFactory factory = (BlockFactory) FactoryRegistry.getFactory(blockFactoryType);
+                    block = factory.createFrom(stringBlock, null);
+            }
+
+            if (log.isDebugEnabled()) {
+                if (block == null) {
+                    log.debug("Block type: " + block.getClass());
+                    log.debug("Block contents: " + block.traceString(""));
+                }
+                else {
+                    log.debug("A null block was created");
+                }
+            }
+
+            value = block.getBusinessObject(true);
+        } catch (Exception e) {
+            if (log.isDebugEnabled()) {
+                log.debug("An error occured while creating the block");
+            }
+            throw ExceptionFactory.makeWebServiceException(e);
+        }
+        
+        if (log.isDebugEnabled()) {
+            if (value == null) 
+                log.debug("Returning a null value");
+            else 
+                log.debug("Returning value of type: " + value.getClass().getName());
+        }
+        
+        return value;
     }
     
-    public Class getType() {
-        return type;
+    private Class getBlockFactory(Object o) {
+        if (o instanceof String) {
+            System.out.println(">> returning XMLStringBlockFactory");
+            return XMLStringBlockFactory.class;
+        }
+        else if (Source.class.isAssignableFrom(o.getClass())) {
+            System.out.println(">> returning SourceBlockFactory");
+            return SourceBlockFactory.class;
+        }
+        
+        System.out.println(">> ERROR: Factory not found");
+        return null;
     }
-    
-    public void setType(Class c) {
-        type = c;
-    }
 }
Index: C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/DocLitProxyHandler.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/DocLitProxyHandler.java	(revision 424366)
+++ C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/DocLitProxyHandler.java	(working copy)
@@ -35,6 +35,7 @@
 import org.apache.axis2.jaxws.core.MessageContext;
 import org.apache.axis2.jaxws.core.controller.AxisInvocationController;
 import org.apache.axis2.jaxws.message.Block;
+import org.apache.axis2.jaxws.message.Message;
 import org.apache.axis2.jaxws.message.MessageException;
 import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
 import org.apache.axis2.jaxws.registry.FactoryRegistry;
@@ -132,10 +133,16 @@
 		String resultName = proxyDescriptor.getWebResultName();
 		JAXBContext ctx = JAXBContext.newInstance(new Class[]{wrapperClazz});
 		//TODO: I should go away from using messageAsOM and see if I can fetch Block from messageContext!!
-		OMElement om = response.getMessageAsOM();
-		Block resBlock = createJAXBBlock(om, ctx);
+		
+        // Get a JAXBBlockFactory instance.  We'll need this to get the JAXBBlock
+        // out of the Message
+        JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
+        
+        Message responseMsg = response.getMessage();
+        Block resBlock = responseMsg.getBodyBlock(0, ctx, factory);
 		Object bo = resBlock.getBusinessObject(true);
-		return getWebResultObject(wrapperClazz, bo, resultName);
+		
+        return getWebResultObject(wrapperClazz, bo, resultName);
 	}
 	
 	private Block createJAXBBlock(Object jaxbObject, JAXBContext context) throws MessageException{
@@ -215,7 +222,7 @@
 	
 	private MessageContext initializeRequest(Block messageBlock) throws XMLStreamException, MessageException{
 		MessageContext request = new MessageContext();
-		request.setMessageAsOM(messageBlock.getOMElement());
+		//request.setMessageAsOM(messageBlock.getOMElement());
 		request.getProperties().putAll(getRequestContext());
 	
 		return request;
Index: C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatch.java	(revision 424366)
+++ C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatch.java	(working copy)
@@ -18,18 +18,22 @@
 
 import javax.xml.bind.JAXBContext;
 
-import org.apache.axiom.om.OMElement;
 import org.apache.axis2.jaxws.AxisController;
+import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.impl.AsyncListener;
-import org.apache.axis2.jaxws.param.JAXBParameter;
-import org.apache.axis2.jaxws.param.Parameter;
+import org.apache.axis2.jaxws.message.Block;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.Protocol;
+import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
+import org.apache.axis2.jaxws.message.factory.MessageFactory;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
 
 public class JAXBDispatch<T> extends BaseDispatch<T> {
 
     private JAXBContext jaxbContext;
     
     public JAXBDispatch() {
-        //do nothing
+        super();
     }
     
     public JAXBDispatch(AxisController ac) {
@@ -51,25 +55,37 @@
         return listener;
     }
     
-    public OMElement createMessageFromValue(Object value) {
-        // FIXME: This is where the Message Model will be integrated instead of 
-        // the ParameterFactory/Parameter APIs.
-        JAXBParameter param = new JAXBParameter();
-        param.setValue(value);
-        param.setJAXBContext(jaxbContext);
+    public Message createMessageFromValue(Object value) {
+        Message message = null;
+        try {
+            MessageFactory mf = (MessageFactory) FactoryRegistry.getFactory(MessageFactory.class);
+
+            // FIXME: The protocol should actually come from the binding information included in
+            // either the WSDL or an annotation.
+            message = mf.create(Protocol.soap11);
+            
+            JAXBBlockFactory factory = (JAXBBlockFactory) FactoryRegistry.getFactory(JAXBBlockFactory.class);
+            Block block = factory.createFrom(value, jaxbContext, null);
+            
+            message.setBodyBlock(0, block);
+        } catch (Exception e) {
+            throw ExceptionFactory.makeWebServiceException(e);
+        }
         
-        OMElement envelope = toOM(param, 
-                axisController.getServiceClient().getOptions().getSoapVersionURI());
-        return envelope;
+        return message;
     }
 
-    public Object getValueFromMessage(OMElement message) {
-        // FIXME: This is where the Message Model will be integrated instead of 
-        // the ParameterFactory/Parameter APIs.
-        JAXBParameter param = new JAXBParameter();
-        param.setJAXBContext(jaxbContext);
-        Parameter p = fromOM(message, param, 
-                axisController.getServiceClient().getOptions().getSoapVersionURI());
-        return p.getValue();
+    public Object getValueFromMessage(Message message) {
+        Object value = null;
+        try {
+            JAXBBlockFactory factory = (JAXBBlockFactory) FactoryRegistry.getFactory(JAXBBlockFactory.class);
+            
+            Block block = message.getBodyBlock(0, jaxbContext, factory);
+            value = block.getBusinessObject(true);
+        } catch (Exception e) {
+            throw ExceptionFactory.makeWebServiceException(e);
+        }
+        
+        return value;
     }
 }
Index: C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/XMLDispatchAsyncListener.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/XMLDispatchAsyncListener.java	(revision 424366)
+++ C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/XMLDispatchAsyncListener.java	(working copy)
@@ -1,13 +1,22 @@
 package org.apache.axis2.jaxws.client;
 
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
 import javax.xml.ws.Service.Mode;
 
+import org.apache.axiom.om.OMElement;
 import org.apache.axiom.soap.SOAPEnvelope;
 import org.apache.axis2.jaxws.core.MessageContext;
 import org.apache.axis2.jaxws.impl.AsyncListener;
+import org.apache.axis2.jaxws.message.Block;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.MessageException;
+import org.apache.axis2.jaxws.message.factory.BlockFactory;
+import org.apache.axis2.jaxws.message.factory.XMLStringBlockFactory;
 import org.apache.axis2.jaxws.param.Parameter;
 import org.apache.axis2.jaxws.param.ParameterFactory;
 import org.apache.axis2.jaxws.param.ParameterUtils;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
 
 /**
  * The XMLDispatchAsyncListener is an extension of the  
@@ -18,6 +27,7 @@
 
     private Mode mode;
     private Class type;
+    private Class blockFactoryType;
     
     public XMLDispatchAsyncListener() {
         super();
@@ -31,13 +41,44 @@
         type = t;
     }
     
+    public void setBlockFactoryType(Class t) {
+        blockFactoryType = t;
+    }
+    
     protected Object getResponseValueObject(MessageContext mc) {
-        // FIXME: This is where the Message Model will be integrated instead of 
-        // the ParameterFactory/Parameter APIs.
-        SOAPEnvelope msg = (SOAPEnvelope) mc.getMessageAsOM();
+        Object value = null;
+
+        Message message = mc.getMessage();
+        if (mode.equals(Mode.PAYLOAD)) {
+            try {
+                BlockFactory factory = (BlockFactory) FactoryRegistry.getFactory(blockFactoryType);
+                Block block = message.getBodyBlock(0, null, factory);
+                value = block.getBusinessObject(true);
+            } catch (MessageException e) {
+                e.printStackTrace();
+            } catch (XMLStreamException e) {
+                e.printStackTrace();
+            }
+        }
+        else if (mode.equals(Mode.MESSAGE)) {
+            try {
+                OMElement messageOM = message.getAsOMElement();
+                QName soapEnvQname = new QName("http://schemas.xmlsoap.org/soap/envelope/", "Envelope");
+                
+                XMLStringBlockFactory stringFactory = (XMLStringBlockFactory) FactoryRegistry.getFactory(XMLStringBlockFactory.class);
+                Block stringBlock = stringFactory.createFrom(messageOM.toString(), null, soapEnvQname);
+                
+                BlockFactory factory = (BlockFactory) FactoryRegistry.getFactory(blockFactoryType);
+                Block block = factory.createFrom(stringBlock, null);
+                
+                value = block.getBusinessObject(true);
+            } catch (MessageException e) {
+                e.printStackTrace();
+            } catch (XMLStreamException e) {
+                e.printStackTrace();
+            }
+        }
         
-        Parameter param = ParameterFactory.createParameter(type);
-        ParameterUtils.fromEnvelope(mode, msg, param);
-        return param.getValue();
+        return value;
     }
 }
Index: C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatchAsyncListener.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatchAsyncListener.java	(revision 424366)
+++ C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatchAsyncListener.java	(working copy)
@@ -20,10 +20,15 @@
 import javax.xml.ws.Service.Mode;
 
 import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.core.MessageContext;
 import org.apache.axis2.jaxws.impl.AsyncListener;
+import org.apache.axis2.jaxws.message.Block;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
 import org.apache.axis2.jaxws.param.JAXBParameter;
 import org.apache.axis2.jaxws.param.ParameterUtils;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
 
 /**
  * The JAXBDispatchAsyncListener is an extension of the  
@@ -48,14 +53,18 @@
     }
     
     public Object getResponseValueObject(MessageContext mc) {
-        // FIXME: This is where the Message Model will be integrated instead of 
-        // the ParameterFactory/Parameter APIs.
-        SOAPEnvelope msg = (SOAPEnvelope) mc.getMessageAsOM();
+        Object value = null;
         
-        JAXBParameter param = new JAXBParameter();
-        param.setJAXBContext(jaxbContext);
-        ParameterUtils.fromEnvelope(mode, msg, param);
+        Message message = mc.getMessage();
+        try {
+            JAXBBlockFactory factory = (JAXBBlockFactory) FactoryRegistry.getFactory(JAXBBlockFactory.class);
+            
+            Block block = message.getBodyBlock(0, jaxbContext, factory);
+            value = block.getBusinessObject(true);
+        } catch (Exception e) {
+            throw ExceptionFactory.makeWebServiceException(e);
+        }
         
-        return param.getValue();
+        return value;
     }
 }
Index: C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/BaseDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/BaseDispatch.java	(revision 424366)
+++ C:/work/apps/eclipse/workspace/axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/BaseDispatch.java	(working copy)
@@ -37,6 +37,7 @@
 import org.apache.axis2.jaxws.core.controller.AxisInvocationController;
 import org.apache.axis2.jaxws.core.controller.InvocationController;
 import org.apache.axis2.jaxws.impl.AsyncListener;
+import org.apache.axis2.jaxws.message.Message;
 import org.apache.axis2.jaxws.param.Parameter;
 import org.apache.axis2.jaxws.param.ParameterFactory;
 import org.apache.axis2.jaxws.param.ParameterUtils;
@@ -79,7 +80,7 @@
      * @param value
      * @return
      */
-    protected abstract OMElement createMessageFromValue(Object value);
+    protected abstract Message createMessageFromValue(Object value);
     
     /**
      * Given a message, return the business object based on the requestor's
@@ -88,7 +89,7 @@
      * @param message
      * @return
      */
-    protected abstract Object getValueFromMessage(OMElement message);
+    protected abstract Object getValueFromMessage(Message message);
     
     /**
      * Creates an instance of the AsyncListener that is to be used for waiting
@@ -112,8 +113,8 @@
         MessageContext requestMsgCtx = new MessageContext();
         invocationContext.setRequestMessageContext(requestMsgCtx);
         
-        OMElement reqEnvelope = createMessageFromValue(obj);
-        requestMsgCtx.setMessageAsOM(reqEnvelope);
+        Message requestMsg = createMessageFromValue(obj);
+        requestMsgCtx.setMessage(requestMsg);
         
         // Copy the properties from the request context into the MessageContext
         requestMsgCtx.getProperties().putAll(requestContext);
@@ -124,8 +125,8 @@
         MessageContext responseMsgCtx = invocationContext.getResponseMessageContext();
         
         //FIXME: This is temporary until more of the Message model is available
-        OMElement rspEnvelope = responseMsgCtx.getMessageAsOM();
-        Object returnObj = getValueFromMessage(rspEnvelope);
+        Message responseMsg = responseMsgCtx.getMessage();
+        Object returnObj = getValueFromMessage(responseMsg);
         
         if (log.isDebugEnabled()) {
             log.debug("Synchronous invocation completed: BaseDispatch.invoke()");
@@ -148,8 +149,8 @@
         MessageContext requestMsgCtx = new MessageContext();
         invocationContext.setRequestMessageContext(requestMsgCtx);
        
-        OMElement reqEnvelope = createMessageFromValue(obj);
-        requestMsgCtx.setMessageAsOM(reqEnvelope);
+        Message requestMsg = createMessageFromValue(obj);
+        requestMsgCtx.setMessage(requestMsg);
        
         // Copy the properties from the request context into the MessageContext
         requestMsgCtx.getProperties().putAll(requestContext);
@@ -178,8 +179,8 @@
         MessageContext requestMsgCtx = new MessageContext();
         invocationContext.setRequestMessageContext(requestMsgCtx);
         
-        OMElement reqEnvelope = createMessageFromValue(obj);
-        requestMsgCtx.setMessageAsOM(reqEnvelope);
+        Message requestMsg = createMessageFromValue(obj);
+        requestMsgCtx.setMessage(requestMsg);
         
         // Copy the properties from the request context into the MessageContext
         requestMsgCtx.getProperties().putAll(requestContext);
@@ -199,7 +200,7 @@
         Future<?> asyncResponse = ic.invokeAsync(invocationContext, asynchandler);
         
         if (log.isDebugEnabled()) {
-            log.debug("Asynchronous (callback) invocation sent: BaseDispatch.invokeOneWay()");
+            log.debug("Asynchronous (callback) invocation sent: BaseDispatch.invokeAsync()");
         }
         
         return asyncResponse;
