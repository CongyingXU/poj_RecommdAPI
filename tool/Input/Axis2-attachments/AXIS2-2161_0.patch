Index: modules/json/test/org/apache/axis2/json/JSONDataSourceTest.java
===================================================================
--- modules/json/test/org/apache/axis2/json/JSONDataSourceTest.java	(revision 506281)
+++ modules/json/test/org/apache/axis2/json/JSONDataSourceTest.java	(working copy)
@@ -31,37 +31,86 @@
 
 public class JSONDataSourceTest extends TestCase {
 
-    public void testSerialize1() throws XMLStreamException {
-        String jsonString = "{\"p\":{\"name\":{\"kamal\":{\"$\":\"yes\"},\"$\":\"innername\"},\"@pp\":\"value\"}}";
-        InputStream jsonInputStream = new ByteArrayInputStream(jsonString.getBytes());
+    public void testMappedSerialize1() throws XMLStreamException {
+        String jsonString = getMappedJSONString();
         ByteArrayOutputStream outStream = new ByteArrayOutputStream();
-        JSONBadgerfishDataSource source = new JSONBadgerfishDataSource(readLocalName(jsonInputStream), "p");
+        JSONDataSource source = getMappedDataSource(jsonString);
         source.serialize(outStream, null);
         assertEquals(jsonString, new String(outStream.toByteArray()));
     }
 
-    public void testSerialize2() throws XMLStreamException, IOException {
-        String jsonString = "{\"p\":{\"name\":{\"kamal\":[{\"$\":\"yes\"},{\"$\":\"second\"}],\"$\":\"innername\"},\"@pp\":\"value\"}}";
-        InputStream jsonInputStream = new ByteArrayInputStream(jsonString.getBytes());
+    public void testMappedSerialize2() throws XMLStreamException, IOException {
+        String jsonString = getMappedJSONString();
         ByteArrayOutputStream outStream = new ByteArrayOutputStream();
         OutputStreamWriter writer = new OutputStreamWriter(outStream);
-        JSONBadgerfishDataSource source = new JSONBadgerfishDataSource(readLocalName(jsonInputStream), "p");
+        JSONDataSource source = getMappedDataSource(jsonString);
         source.serialize(writer, null);
         writer.flush();
         assertEquals(jsonString, new String(outStream.toByteArray()));
+
     }
 
-    public void testSerialize3() throws XMLStreamException, JSONException {
-        String jsonString = "{\"p\":{\"@xmlns\":{\"bb\":\"http://other.nsb\",\"aa\":\"http://other.ns\",\"$\":\"http://def.ns\"},\"sam\":{\"$\":\"555\", \"@att\":\"lets\"}}}";
-        InputStream jsonInputStream = new ByteArrayInputStream(jsonString.getBytes());
+    public void testMappedSerialize3() throws XMLStreamException {
+//        String jsonString = getMappedJSONString();
+//        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
+//        XMLStreamWriter writer = StAXUtils.createXMLStreamWriter(outStream);
+//        JSONDataSource source = getMappedDataSource(jsonString);
+//        source.serialize(writer);
+//        writer.flush();
+//        assertEquals("<?xml version='1.0' encoding='UTF-8'?><mapping><inner><first>test string one</first></inner><inner>test string two</inner><name>foo</name></mapping>", new String(outStream.toByteArray()));
+        //<mapping><inner>test string one</inner><inner>test string two</inner><name>foo</name></mapping>
+    }
+
+    public void testBadgerfishSerialize1() throws XMLStreamException {
+        String jsonString = getBadgerfishJSONString();
         ByteArrayOutputStream outStream = new ByteArrayOutputStream();
+        JSONBadgerfishDataSource source = getBadgerfishDataSource(jsonString);
+        source.serialize(outStream, null);
+        assertEquals(jsonString, new String(outStream.toByteArray()));
+    }
+
+    public void testBadgerfishSerialize2() throws XMLStreamException, IOException {
+        String jsonString = getBadgerfishJSONString();
+        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
+        OutputStreamWriter writer = new OutputStreamWriter(outStream);
+        JSONBadgerfishDataSource source = getBadgerfishDataSource(jsonString);
+        source.serialize(writer, null);
+        writer.flush();
+        assertEquals(jsonString, new String(outStream.toByteArray()));
+    }
+
+    public void testBadgerfishSerialize3() throws XMLStreamException, JSONException {
+        String jsonString = getBadgerfishJSONString();
+        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
         XMLStreamWriter writer = StAXUtils.createXMLStreamWriter(outStream);
-        JSONBadgerfishDataSource source = new JSONBadgerfishDataSource(readLocalName(jsonInputStream), "p");
+        JSONBadgerfishDataSource source = getBadgerfishDataSource(jsonString);
         source.serialize(writer);
         writer.flush();
         assertEquals("<?xml version='1.0' encoding='UTF-8'?><p xmlns=\"http://def.ns\" xmlns:bb=\"http://other.nsb\" xmlns:aa=\"http://other.ns\"><sam att=\"lets\">555</sam></p>", new String(outStream.toByteArray()));
     }
 
+    private JSONBadgerfishDataSource getBadgerfishDataSource(String jsonString) {
+        InputStream jsonInputStream = new ByteArrayInputStream(jsonString.getBytes());
+        return new JSONBadgerfishDataSource(readLocalName(jsonInputStream), "\"p\"");
+    }
+
+    private String getBadgerfishJSONString() {
+        return "{\"p\":{\"@xmlns\":{\"bb\":\"http://other.nsb\",\"aa\":\"http://other.ns\",\"$\":\"http://def.ns\"},\"sam\":{\"$\":\"555\", \"@att\":\"lets\"}}}";
+    }
+
+    private JSONDataSource getMappedDataSource(String jsonString) {
+        InputStream jsonInputStream = new ByteArrayInputStream(jsonString.getBytes());
+        return new JSONDataSource(readLocalName(jsonInputStream), "\"mapping\"");
+    }
+
+    private String getMappedJSONString() {
+//        {"mapping":{"inner":[{"first":"test string one"},"test string two"],"name":"foo"}}
+//          <mapping><inner><first>test string one</first></inner><inner>test string two</inner><name>foo</name></mapping>
+//        return "{\"mapping\":{\"inner\":[{\"first\":\"test string one\"},\"test string two\"],\"name\":\"foo\"}}";
+        return "{\"mapping\":{\"inner\":[\"test string one\",\"test string two\"],\"name\":\"foo\"}}";
+//        return "{\"mapping\":{\"inner\":\"foo\"}}";
+    }
+
     private InputStream readLocalName(InputStream in) {
         try {
             while ((char) in.read() != ':') {
@@ -71,4 +120,5 @@
         }
         return in;
     }
+
 }
Index: modules/json/src/org/apache/axis2/json/JSONBadgerfishMessageFormatter.java
===================================================================
--- modules/json/src/org/apache/axis2/json/JSONBadgerfishMessageFormatter.java	(revision 506281)
+++ modules/json/src/org/apache/axis2/json/JSONBadgerfishMessageFormatter.java	(working copy)
@@ -23,12 +23,26 @@
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 
+/**
+ * This JSONBadgerfishMessageFormatter is the formatter for "Badgerfish" formatted JSON in Axis2.
+ * Eg:  &lt;out&gt;&lt;in&gt;mapped JSON&lt;/in&gt;&lt;/out&gt; is converted to...
+ * {"out":{"in":{"$":"mapped JSON"}}}
+ * This can be used when you want to send messages with namespaces with JSON
+ */
+
 public class JSONBadgerfishMessageFormatter extends JSONMessageFormatter {
 
+    //returns the writer for the badgerfish format
     protected XMLStreamWriter getJSONWriter(OutputStream outStream) {
         return new BadgerFishXMLStreamWriter(new OutputStreamWriter(outStream));
     }
 
+    /**
+     * If the data source is a "Badgerfish" formatted data source, gives the JSON string by
+     * directly taking from the data source.
+     * @param dataSource data source to be checked
+     * @return the JSON string to write
+     */
     protected String getStringToWrite(OMDataSource dataSource) {
         if (dataSource instanceof JSONBadgerfishDataSource) {
             return ((JSONDataSource) dataSource).getCompleteJOSNString();
Index: modules/json/src/org/apache/axis2/json/JSONMessageFormatter.java
===================================================================
--- modules/json/src/org/apache/axis2/json/JSONMessageFormatter.java	(revision 506281)
+++ modules/json/src/org/apache/axis2/json/JSONMessageFormatter.java	(working copy)
@@ -37,7 +37,20 @@
 import org.codehaus.jettison.mapped.MappedNamespaceConvention;
 import org.codehaus.jettison.mapped.MappedXMLStreamWriter;
 
+/**
+ * This JSONMessageFormatter is the formatter for "Mapped" formatted JSON in Axis2.
+ * This type of JSON strings are really easy to use in Javascript.
+ * Eg:  &lt;out&gt;&lt;in&gt;mapped JSON&lt;/in&gt;&lt;/out&gt; is converted to...
+ * {"out":{"in":"mapped JSON"}}
+ * WARNING: We do not support "Mapped" JSON Strings with *namespaces* in Axis2.
+ * This convention is supported in Axis2, with the aim of making Javascript users'
+ * life easy (services written in Javascript). There are no namespaces used in
+ * Javascript.
+ * If you want to use JSON with namespaces, use the JSONBadgerfishMessageForatter
+ * (for "Badgerfish" formatted JSON) which supports JSON with namespaces.
+ */
 
+
 public class JSONMessageFormatter implements MessageFormatter {
 
     public String getContentType(MessageContext msgCtxt, OMOutputFormat format, String soapActionString) {
@@ -45,6 +58,7 @@
         String encoding = format.getCharSetEncoding();
         if (msgCtxt.getProperty(Constants.Configuration.CONTENT_TYPE) != null) {
             contentType = (String) msgCtxt.getProperty(Constants.Configuration.CONTENT_TYPE);
+            //if the content type is not set useing the MESSAGE_TYPE as the content type
         } else {
             contentType = (String) msgCtxt.getProperty(Constants.Configuration.MESSAGE_TYPE);
         }
@@ -55,12 +69,27 @@
         return contentType;
     }
 
+    /**
+     * Gives the JSON message as an array of bytes. If the payload is an OMSourcedElementImpl
+     * and it contains a JSONDataSource with a correctly formatted JSON String, gets it directly from the
+     * DataSource and returns as a byte array. If not, the OM tree is expanded and it is serialized
+     * into the output stream and byte array is returned.
+     * @param msgCtxt Message context which contains the soap envelope to be written
+     * @param format format of the message, this is ignored
+     * @return the payload as a byte array
+     * @throws AxisFault if there is an error in writing the message using StAX writer or IF THE USER
+     *                      TRIES TO SEND A JSON MESSAGE WITH NAMESPACES USING THE "MAPPED" CONVENTION.
+     */
+
     public byte[] getBytes(MessageContext msgCtxt, OMOutputFormat format) throws AxisFault {
         OMElement element = msgCtxt.getEnvelope().getBody().getFirstElement();
+        //if the element is an OMSourcedElementImpl and it contains a JSONDataSource with correct convention,
+        //directly get the JSON string.
         if (element instanceof OMSourcedElementImpl && getStringToWrite(((OMSourcedElementImpl) element).getDataSource()) != null)
         {
             String jsonToWrite = getStringToWrite(((OMSourcedElementImpl) element).getDataSource());
             return jsonToWrite.getBytes();
+        //otherwise serialize the OM by expanding the tree
         } else {
             try {
                 ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
@@ -74,6 +103,9 @@
                 throw new AxisFault(e);
             } catch (FactoryConfigurationError e) {
                 throw new AxisFault(e);
+            } catch (IllegalStateException e) {
+                throw new AxisFault("Mapped formatted JSON with namespaces are not supported in Axis2. Make sure that your" +
+                        " request doesn't include namespaces or use the Badgerfish convention");
             }
         }
     }
@@ -82,11 +114,18 @@
         return null;
     }
 
+    //returns the "Mapped" JSON writer
     protected XMLStreamWriter getJSONWriter(OutputStream outStream) {
         MappedNamespaceConvention mnc = new MappedNamespaceConvention();
         return new MappedXMLStreamWriter(mnc, new OutputStreamWriter(outStream));
     }
 
+    /**
+     * If the data source is a "Mapped" formatted data source, gives the JSON string by
+     * directly taking from the data source.
+     * @param dataSource data source to be checked
+     * @return the JSON string to write
+     */
     protected String getStringToWrite(OMDataSource dataSource) {
         if (dataSource instanceof JSONDataSource) {
             return ((JSONDataSource) dataSource).getCompleteJOSNString();
@@ -95,6 +134,19 @@
         }
     }
 
+    /**
+     * Writes the JSON message to the output stream with the correct convention. If the payload is an
+     * OMSourcedElementImpl and it contains a JSONDataSource with a correctly formatted JSON String,
+     * gets it directly from the DataSource and writes to the output stream. If not, the OM tree is expanded
+     * and it is serialized into the output stream.
+     * @param msgCtxt Message context which contains the soap envelope to be written
+     * @param format format of the message, this is ignored
+     * @param out output stream to be written in to
+     * @param preserve ignored
+     * @throws AxisFault if there is an error in writing the message using StAX writer or IF THE USER
+     *                      TRIES TO SEND A JSON MESSAGE WITH NAMESPACES USING THE "MAPPED" CONVENTION.
+     */
+
     public void writeTo(MessageContext msgCtxt, OMOutputFormat format,
                         OutputStream out, boolean preserve) throws AxisFault {
         OMElement element = msgCtxt.getEnvelope().getBody().getFirstElement();
@@ -112,6 +164,9 @@
             throw new AxisFault(e);
         } catch (XMLStreamException e) {
             throw new AxisFault(e);
+        } catch (IllegalStateException e) {
+            throw new AxisFault("Mapped formatted JSON with namespaces are not supported in Axis2. Make sure that your" +
+                    " request doesn't include namespaces or use the Badgerfish convention");
         }
     }
 
@@ -120,6 +175,7 @@
         String httpMethod =
                 (String) msgCtxt.getProperty(Constants.Configuration.HTTP_METHOD);
 
+        //if the http method is GET, parameters are attached to the target URL
         if ((httpMethod != null)
                 && Constants.Configuration.HTTP_METHOD_GET.equalsIgnoreCase(httpMethod)) {
             String param = getParam(msgCtxt);
Index: modules/json/src/org/apache/axis2/json/JSONBadgerfishDataSource.java
===================================================================
--- modules/json/src/org/apache/axis2/json/JSONBadgerfishDataSource.java	(revision 506281)
+++ modules/json/src/org/apache/axis2/json/JSONBadgerfishDataSource.java	(working copy)
@@ -1,4 +1,3 @@
-package org.apache.axis2.json;
 /*
  * Copyright 2004,2005 The Apache Software Foundation.
  *
@@ -15,28 +14,34 @@
  * limitations under the License.
  */
 
-import org.apache.axiom.om.OMDataSource;
-import org.apache.axiom.om.OMOutputFormat;
-import org.apache.axiom.om.OMException;
-import org.json.JSONObject;
+package org.apache.axis2.json;
+
+
 import org.json.JSONTokener;
-import org.json.JSONException;
 import org.codehaus.jettison.badgerfish.BadgerFishXMLInputFactory;
-import org.codehaus.jettison.mapped.MappedXMLInputFactory;
-
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.stream.XMLStreamConstants;
 import java.io.*;
-import java.util.HashMap;
 
+/**
+ * JSONDataSource keeps the JSON String inside and consumes it when needed.
+ * This is to be kept in the OMSourcedElementImpl and can be used either to
+ * expand the tree or get the JSON String directly without expanding.
+ * This uses the "Badgerfish" JSON convention.
+ */
+
 public class JSONBadgerfishDataSource extends JSONDataSource{
 
     public JSONBadgerfishDataSource(InputStream jsonInputStream, String localName){
         super(jsonInputStream, localName);
     }
 
+    /**
+     * Gives the StAX reader using the "Badgerfish" formatted input JSON String.
+     * @return The XMLStreamReader according to the JSON String.
+     * @throws javax.xml.stream.XMLStreamException if there is an error while making the StAX reader.
+     */
     public javax.xml.stream.XMLStreamReader getReader() throws javax.xml.stream.XMLStreamException {
 
+        //input factory for "Badgerfish"
         BadgerFishXMLInputFactory inputFactory = new BadgerFishXMLInputFactory();
         return inputFactory.createXMLStreamReader(new JSONTokener("{" + localName + ":" + this.getJSONString()));
 
Index: modules/json/src/org/apache/axis2/json/JSONDataSource.java
===================================================================
--- modules/json/src/org/apache/axis2/json/JSONDataSource.java	(revision 506281)
+++ modules/json/src/org/apache/axis2/json/JSONDataSource.java	(working copy)
@@ -1,4 +1,4 @@
-package org.apache.axis2.json;
+
 /*
  * Copyright 2004,2005 The Apache Software Foundation.
  *
@@ -15,6 +15,8 @@
  * limitations under the License.
  */
 
+package org.apache.axis2.json;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -34,6 +36,13 @@
 import org.json.JSONObject;
 import org.json.JSONTokener;
 
+/**
+ * JSONDataSource keeps the JSON String inside and consumes it when needed.
+ * This is to be kept in the OMSourcedElementImpl and can be used either to
+ * expand the tree or get the JSON String directly without expanding.
+ * This uses the "Mapped" JSON convention.
+ */
+
 public class JSONDataSource implements OMDataSource {
 
     private InputStream jsonInputStream;
@@ -46,29 +55,46 @@
         this.localName = localName;
     }
 
-    //gives json
+    /**
+     * Writes JSON into the output stream. As this should write JSON, it directly
+     * gets the JSON string and writes it without expanding the tree.
+     * @param outputStream the stream to be written into
+     * @param omOutputFormat format of the message, this is ignored.
+     * @throws javax.xml.stream.XMLStreamException if there is an error while writing the message
+     *                                 in to the output stream.
+     */
     public void serialize(OutputStream outputStream, OMOutputFormat omOutputFormat) throws javax.xml.stream.XMLStreamException {
-        OutputStreamWriter writer = new OutputStreamWriter(outputStream);
-        serialize(writer, omOutputFormat);
         try {
-            writer.flush();
+            outputStream.write(getCompleteJOSNString().getBytes());
         } catch (IOException e) {
             throw new OMException();
         }
     }
 
-    //gives json
+    /**
+     * Writes JSON through the writer. As this should write JSON, it directly
+     * gets the JSON string and writes it without expanding the tree.
+     * @param writer Writer to be written into
+     * @param omOutputFormat format of the message, this is ignored.
+     * @throws javax.xml.stream.XMLStreamException if there is an error while writing the message through the
+     *                                            writer.
+     */
     public void serialize(Writer writer, OMOutputFormat omOutputFormat) throws javax.xml.stream.XMLStreamException {
         try {
-            JSONTokener jsonTokener = new JSONTokener("{" + localName + ":" + this.getJSONString());
-            JSONObject jsonObject = new JSONObject(jsonTokener);
-            jsonObject.write(writer);
-        } catch (JSONException e) {
+            writer.write(getCompleteJOSNString());
+        } catch (IOException e) {
             throw new OMException();
         }
     }
 
-    //gives xml
+    /**
+     * Writes XML through the XMLStreamWriter. As the input data source is JSON, this
+     * method needs to get a StAX reader from that JSON String. Therefore this uses the
+     * getReader() method to get the StAX reader writes the events into the XMLStreamWriter.
+     * @param xmlStreamWriter StAX writer to be written into
+     * @throws javax.xml.stream.XMLStreamException if there is an error while writing the message through the
+     *                                           StAX writer.
+     */
     public void serialize(javax.xml.stream.XMLStreamWriter xmlStreamWriter) throws javax.xml.stream.XMLStreamException {
         XMLStreamReader reader = getReader();
         xmlStreamWriter.writeStartDocument();
@@ -123,16 +149,24 @@
         xmlStreamWriter.writeEndDocument();
     }
 
+    /**
+     * Gives the StAX reader using the "Mapped" formatted input JSON String.
+     * @return The XMLStreamReader according to the JSON String.
+     * @throws javax.xml.stream.XMLStreamException if there is an error while making the StAX reader.
+     */
+
     public javax.xml.stream.XMLStreamReader getReader() throws javax.xml.stream.XMLStreamException {
 
-        HashMap nstojns = new HashMap();
-        nstojns.put("", "");
+        HashMap XMLToJSNNamespaceMap = new HashMap();
+        XMLToJSNNamespaceMap.put("", "");
 
-        MappedXMLInputFactory inputFactory = new MappedXMLInputFactory(nstojns);
+        //input factory for "Mapped" convention
+        MappedXMLInputFactory inputFactory = new MappedXMLInputFactory(XMLToJSNNamespaceMap);
         String jsonString = "{" + localName + ":" + this.getJSONString();
         return inputFactory.createXMLStreamReader(new JSONTokener(jsonString));         
     }
 
+    //returns the json string by consuming the JSON input stream.
     protected String getJSONString() {
         if (isRead) {
             return jsonString;
@@ -153,6 +187,6 @@
     }
 
     public String getCompleteJOSNString(){
-        return localName + getJSONString();
+        return "{" + localName + ":" + getJSONString();
     }
 }
Index: modules/json/src/org/apache/axis2/json/JSONBadgerfishOMBuilder.java
===================================================================
--- modules/json/src/org/apache/axis2/json/JSONBadgerfishOMBuilder.java	(revision 506281)
+++ modules/json/src/org/apache/axis2/json/JSONBadgerfishOMBuilder.java	(working copy)
@@ -20,6 +20,6 @@
 public class JSONBadgerfishOMBuilder extends JSONOMBuilder{
 
     protected JSONDataSource getDataSource(){
-        return new JSONBadgerfishDataSource(this.jsonInputStream, localName);
+        return new JSONBadgerfishDataSource(this.jsonInputStream, "\"" + prefix + localName + "\"");
     }
 }
Index: modules/json/src/org/apache/axis2/json/JSONOMBuilder.java
===================================================================
--- modules/json/src/org/apache/axis2/json/JSONOMBuilder.java	(revision 506281)
+++ modules/json/src/org/apache/axis2/json/JSONOMBuilder.java	(working copy)
@@ -19,38 +19,42 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-import org.apache.axiom.om.OMElement;
-import org.apache.axiom.om.OMNamespace;
+import org.apache.axiom.om.*;
 import org.apache.axiom.om.impl.OMNamespaceImpl;
 import org.apache.axiom.om.impl.builder.OMBuilder;
 import org.apache.axiom.om.impl.llom.OMSourcedElementImpl;
 import org.apache.axiom.om.impl.llom.factory.OMLinkedListImplFactory;
 
+/**
+ * Makes the OMSourcedElementImpl object with the JSONDataSource inside.
+ */
+
 public class JSONOMBuilder implements OMBuilder {
     InputStream jsonInputStream = null;
     String localName = null;
+    String prefix = "";
 
     public JSONOMBuilder() {
     }
 
 	public void init(InputStream inputStream, String chatSetEncoding) {
 		this.jsonInputStream = inputStream;
-		
-	}
 
+    }
+
+    //returns the OMSourcedElementImpl with JSONDataSource inside
     public OMElement getDocumentElement() {
-
-        OMLinkedListImplFactory factory = new OMLinkedListImplFactory();
+        OMFactory factory = OMAbstractFactory.getOMFactory();
         OMNamespace ns = new OMNamespaceImpl("", "");
         if (localName == null) {
             localName = getLocalName();
         }
         JSONDataSource jsonDataSource = getDataSource();
-        return new OMSourcedElementImpl(localName.substring(1, localName.length() - 1), ns, factory, jsonDataSource);
+        return new OMSourcedElementImpl(localName, ns, factory, jsonDataSource);
     }
 
-    protected JSONDataSource getDataSource(){
-        return new JSONDataSource(this.jsonInputStream, localName);
+    protected JSONDataSource getDataSource() {
+        return new JSONDataSource(this.jsonInputStream, "\"" + prefix + localName + "\"");
     }
 
     private String getLocalName() {
@@ -58,18 +62,36 @@
         try {
             char temp = (char) jsonInputStream.read();
             while (temp != ':') {
-                if (temp != '{' && temp != ' ') {
+                if (temp != ' ' && temp != '{') {
                     localName += temp;
                 }
                 temp = (char) jsonInputStream.read();
             }
+
+            if (localName.charAt(0) == '"') {
+                if (localName.charAt(localName.length() - 1) == '"') {
+                    localName = localName.substring(1, localName.length() - 1);
+                } else {
+                    prefix = localName.substring(1, localName.length()) + ":";
+                    localName = "";
+                    temp = (char) jsonInputStream.read();
+                    while (temp != ':') {
+                        if (temp != ' ') {
+                            localName += temp;
+                        }
+                        temp = (char) jsonInputStream.read();
+                    }
+                    localName = localName.substring(0, localName.length() - 1);
+                }
+            }
         } catch (IOException e) {
-            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+            throw new OMException(e);
         }
-        return localName.trim();
+        return localName;
     }
 
-	public String getCharsetEncoding() {
-		return "UTF-8";
-	}
+    public String getCharsetEncoding() {
+        return "UTF-8";
+    }
+
 }
