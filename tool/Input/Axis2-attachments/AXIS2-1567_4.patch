Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/test/org/apache/axis2/engine/OperationContextSaveTest.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/test/org/apache/axis2/engine/OperationContextSaveTest.java	(revision 0)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/test/org/apache/axis2/engine/OperationContextSaveTest.java	(revision 0)
@@ -0,0 +1,404 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.engine;
+
+import junit.framework.TestCase;
+
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.axiom.soap.SOAPFactory;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.OperationContext;
+import org.apache.axis2.context.ServiceContext;
+import org.apache.axis2.context.ServiceGroupContext;
+import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.AxisServiceGroup;
+import org.apache.axis2.description.HandlerDescription;
+import org.apache.axis2.description.InOutAxisOperation;
+import org.apache.axis2.description.TransportInDescription;
+import org.apache.axis2.description.TransportOutDescription;
+import org.apache.axis2.handlers.AbstractHandler;
+import org.apache.axis2.receivers.RawXMLINOnlyMessageReceiver;
+import org.apache.axis2.receivers.RawXMLINOutMessageReceiver;
+import org.apache.axis2.transport.http.CommonsHTTPTransportSender;
+import org.apache.axis2.util.UUIDGenerator;
+
+import javax.xml.namespace.QName;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+
+public class OperationContextSaveTest extends TestCase
+{
+
+    private QName serviceName   = new QName("TestService");
+    private QName operationName = new QName("Operation_1");
+
+    private ConfigurationContext configurationContext = null;
+    private ServiceGroupContext  serviceGroupContext  = null;
+    private ServiceContext       serviceContext       = null;
+    private OperationContext     operationContext     = null;
+
+    private AxisConfiguration  axisConfiguration = null;
+    private AxisServiceGroup   axisServiceGroup  = null;
+    private AxisService        axisService       = null;
+    private AxisOperation      axisOperation     = null;
+
+    private TransportOutDescription transportOut = null;
+    private TransportInDescription  transportIn  = null;
+
+    private MessageContext mc = null;
+
+    private ArrayList executedHandlers = null;
+
+    private String testArg = null;
+
+
+    public OperationContextSaveTest(String arg0)
+    {
+        super(arg0);
+        testArg = new String(arg0);
+
+        try
+        {
+            prepare();
+        }
+        catch (Exception e)
+        {
+            System.out.println("OperationContextSaveTest:constructor:  error in setting up object graph ["+e.getClass().getName()+" : "+e.getMessage()+"]");
+        }
+    }
+
+                                               
+    //
+    // prepare the object hierarchy for testing
+    //
+    private void prepare() throws Exception
+    {
+        //-----------------------------------------------------------------
+
+        axisConfiguration = new AxisConfiguration();
+
+        configurationContext = new ConfigurationContext(axisConfiguration);
+
+        configurationContext.getAxisConfiguration().addMessageReceiver("http://www.w3.org/2004/08/wsdl/in-only", new RawXMLINOnlyMessageReceiver()); 
+        configurationContext.getAxisConfiguration().addMessageReceiver("http://www.w3.org/2004/08/wsdl/in-out", new RawXMLINOutMessageReceiver()); 
+                                                               
+        DispatchPhase dispatchPhase = new DispatchPhase();
+        dispatchPhase.setName("Dispatch");
+
+        AddressingBasedDispatcher abd = new AddressingBasedDispatcher();
+        abd.initDispatcher();
+
+        RequestURIBasedDispatcher rud = new RequestURIBasedDispatcher();
+        rud.initDispatcher();
+
+        SOAPActionBasedDispatcher sabd = new SOAPActionBasedDispatcher();
+        sabd.initDispatcher();
+
+        SOAPMessageBodyBasedDispatcher smbd = new SOAPMessageBodyBasedDispatcher();
+        smbd.initDispatcher();
+
+        InstanceDispatcher id = new InstanceDispatcher();
+        id.init(new HandlerDescription(new String("InstanceDispatcher")));
+
+        dispatchPhase.addHandler(abd);
+        dispatchPhase.addHandler(rud);
+        dispatchPhase.addHandler(sabd);
+        dispatchPhase.addHandler(smbd);
+        dispatchPhase.addHandler(id);
+
+        configurationContext.getAxisConfiguration().getGlobalInFlow().add(dispatchPhase);
+
+        //-----------------------------------------------------------------
+
+        axisServiceGroup = new AxisServiceGroup(axisConfiguration);
+        axisServiceGroup.setServiceGroupName("ServiceGroupTest");
+
+
+        axisService = new AxisService(serviceName.getLocalPart());
+        axisServiceGroup.addService(axisService);
+
+
+        axisOperation = new InOutAxisOperation(operationName);
+        axisOperation.setMessageReceiver(new MessageReceiver()
+                                  {
+                                      public void receive(MessageContext messageCtx)
+                                      {
+
+                                      }
+                                  });
+
+        axisService.addOperation(axisOperation);
+        axisService.mapActionToOperation(operationName.getLocalPart(), axisOperation);
+
+
+        configurationContext.getAxisConfiguration().addService(axisService);
+
+        //-----------------------------------------------------------------
+
+        serviceGroupContext = new ServiceGroupContext(configurationContext, (AxisServiceGroup) axisService.getParent()); 
+        serviceGroupContext.setId("ServiceGroupContextTest");
+
+        serviceContext = serviceGroupContext.getServiceContext(axisService); 
+                
+        operationContext = serviceContext.createOperationContext(operationName); 
+                
+        //-----------------------------------------------------------------
+
+        transportOut = new TransportOutDescription(new QName("null"));
+        transportOut.setSender(new CommonsHTTPTransportSender());
+
+        transportIn = new TransportInDescription(new QName("null"));
+
+        //-----------------------------------------------------------------
+
+        mc = new MessageContext();
+        mc.setConfigurationContext(configurationContext);
+        mc.setTransportIn(transportIn);
+        mc.setTransportOut(transportOut);
+        mc.setTransportOut(transportOut);
+
+        mc.setServerSide(true);
+        mc.setProperty(MessageContext.TRANSPORT_OUT, System.out);
+        SOAPFactory omFac = OMAbstractFactory.getSOAP11Factory();
+        mc.setEnvelope(omFac.getDefaultEnvelope());
+
+        Phase phase1 = new Phase("beginPhase1");
+        phase1.addHandler(new TempHandler(1));
+        phase1.addHandler(new TempHandler(2));
+        phase1.addHandler(new TempHandler(3));
+
+        Phase phase2 = new Phase("middlePhase2");
+        phase2.addHandler(new TempHandler(4));
+        phase2.addHandler(new TempHandler(5));
+        phase2.addHandler(new TempHandler(6));
+        phase2.addHandler(new TempHandler(7));
+        phase2.addHandler(new TempHandler(8));
+
+        Phase phase3 = new Phase("lastPhase3");
+        phase3.addHandler(new TempHandler(9));
+        phase3.addHandler(new TempHandler(10));
+
+        axisOperation.getRemainingPhasesInFlow().add(phase1);
+        axisOperation.getRemainingPhasesInFlow().add(phase2);
+        axisOperation.getRemainingPhasesInFlow().add(phase3);
+
+        mc.setWSAAction(operationName.getLocalPart());
+        mc.setSoapAction(operationName.getLocalPart());
+        System.out.flush();
+
+        mc.setMessageID(UUIDGenerator.getUUID());
+
+        //operationContext.addMessageContext(mc);  gets done via the register
+        axisOperation.registerOperationContext(mc,operationContext);
+        mc.setOperationContext(operationContext);
+        mc.setServiceContext(serviceContext);
+
+        mc.setTo(new EndpointReference("axis2/services/NullService")); 
+        mc.setWSAAction("DummyOp");
+
+
+        //-----------------------------------------------------------------
+
+        executedHandlers = new ArrayList();
+
+    }
+
+
+    protected void setUp() throws Exception 
+    {
+        //org.apache.log4j.BasicConfigurator.configure();
+    }
+
+
+    public void testSaveAndRestore() throws Exception 
+    {
+        File    theFile     = null;
+        String  theFilename = null;
+        boolean saved       = false;
+        boolean restored    = false;
+        boolean done        = false;
+        boolean comparesOk  = false;
+
+        System.out.println("OperationContextSaveTest:testSaveAndRestore():  BEGIN ---------------");
+
+        // ---------------------------------------------------------
+        // setup a temporary file to use
+        // ---------------------------------------------------------
+        try
+        {
+            theFile = File.createTempFile("OpCtxSave",null);
+            theFilename = theFile.getName();
+            System.out.println("OperationContextSaveTest:testSaveAndRestore(): temp file = ["+theFilename+"]");
+        }
+        catch (Exception ex)
+        {
+            System.out.println("OperationContextSaveTest:testSaveAndRestore(): error creating temp file = ["+ex.getMessage()+"]");
+            theFile = null;
+        }
+
+        if (theFile != null)
+        {
+            // ---------------------------------------------------------
+            // save to the temporary file
+            // ---------------------------------------------------------
+            try
+            {
+                // setup an output stream to a physical file
+                FileOutputStream outStream = new FileOutputStream(theFile);
+
+                // attach a stream capable of writing objects to the 
+                // stream connected to the file
+                ObjectOutputStream outObjStream = new ObjectOutputStream(outStream);
+
+                // try to save the message context
+                System.out.println("OperationContextSaveTest:testSaveAndRestore(): saving .....");
+                saved = false;
+                outObjStream.writeObject(operationContext);
+
+                // close out the streams
+                outObjStream.flush();
+                outObjStream.close();
+                outStream.flush();
+                outStream.close();
+
+                saved = true;
+                System.out.println("OperationContextSaveTest:testSaveAndRestore(): ....save operation completed.....");
+
+                long filesize = theFile.length();
+                System.out.println("OperationContextSaveTest:testSaveAndRestore(): file size after save ["+filesize+"]   temp file = ["+theFilename+"]");
+
+            }
+            catch (Exception ex2)
+            {
+                System.out.println("OperationContextSaveTest:testSaveAndRestore(): error during save ["+ex2.getClass().getName()+" : "+ex2.getMessage()+"]");
+                ex2.printStackTrace();
+            }
+
+            assertTrue(saved);
+
+            // ---------------------------------------------------------
+            // restore from the temporary file
+            // ---------------------------------------------------------
+            try
+            {
+                // setup an input stream to the file
+                FileInputStream inStream = new FileInputStream(theFile);
+
+                // attach a stream capable of reading objects from the 
+                // stream connected to the file
+                ObjectInputStream inObjStream = new ObjectInputStream(inStream);
+
+                // try to restore the context
+                System.out.println("OperationContextSaveTest:testSaveAndRestore(): restoring .....");
+                restored = false;
+                OperationContext opctx_restored = (OperationContext) inObjStream.readObject();
+                inObjStream.close();
+                inStream.close();
+
+                opctx_restored.activate(configurationContext);
+
+                restored = true;
+                System.out.println("OperationContextSaveTest:testSaveAndRestore(): ....restored operation completed.....");
+
+                // compare to original
+                comparesOk = opctx_restored.isEquivalent(operationContext);
+                System.out.println("OperationContextSaveTest:testSaveAndRestore():  OperationContext equivalency ["+comparesOk+"]");
+                assertTrue(comparesOk);
+
+                ServiceContext restored_srvCtx = opctx_restored.getServiceContext();
+                comparesOk = restored_srvCtx.isEquivalent(serviceContext);
+                System.out.println("OperationContextSaveTest:testSaveAndRestore():  ServiceContext equivalency ["+comparesOk+"]");
+                assertTrue(comparesOk);
+
+                ServiceGroupContext restored_sgCtx = restored_srvCtx.getServiceGroupContext();
+                comparesOk = restored_sgCtx.isEquivalent(serviceGroupContext);
+                System.out.println("OperationContextSaveTest:testSaveAndRestore():  ServiceGroupContext equivalency ["+comparesOk+"]");
+                assertTrue(comparesOk);
+
+            }
+            catch (Exception ex2)
+            {
+                System.out.println("OperationContextSaveTest:testSaveAndRestore(): error during restore ["+ex2.getClass().getName()+" : "+ex2.getMessage()+"]");
+                ex2.printStackTrace();
+            }
+
+            assertTrue(restored);
+
+            // if the save/restore of the operation context succeeded,
+            // then don't keep the temporary file around
+            boolean removeTmpFile = saved && restored && comparesOk;
+            if (removeTmpFile)
+            {
+                try
+                {
+                    theFile.delete();
+                }
+                catch (Exception e)
+                {
+                    // just absorb it
+                }
+            }
+            
+            // indicate that the temp file was created ok
+            done = true;
+        }
+
+        // this is false when there are problems with the temporary file
+        assertTrue(done);
+
+        System.out.println("OperationContextSaveTest:testSaveAndRestore():  END ---------------");
+    }
+
+
+    public class TempHandler extends AbstractHandler
+    {
+        private Integer index;
+
+        //-----------------------------------------------------------------
+        // constructors
+        //-----------------------------------------------------------------
+
+        public TempHandler(int index)
+        {
+            this.index = new Integer(index);
+            init(new HandlerDescription(new String("handler" + index)));
+        }
+
+        //-----------------------------------------------------------------
+        // methods
+        //-----------------------------------------------------------------
+
+        public InvocationResponse invoke(MessageContext msgContext) throws AxisFault 
+        {
+            System.out.println("TempHandler:invoke(): index = ["+index+"]");
+            executedHandlers.add(index);
+            return InvocationResponse.CONTINUE;
+        }
+
+    }
+
+}
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/test/org/apache/axis2/engine/MessageContextSaveTest.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/test/org/apache/axis2/engine/MessageContextSaveTest.java	(revision 0)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/test/org/apache/axis2/engine/MessageContextSaveTest.java	(revision 0)
@@ -0,0 +1,844 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.engine;
+
+import junit.framework.TestCase;
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.axiom.soap.SOAPFactory;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.OperationContext;
+import org.apache.axis2.context.ServiceContext;
+import org.apache.axis2.context.ServiceGroupContext;
+import org.apache.axis2.description.AxisMessage;
+import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.AxisServiceGroup;
+import org.apache.axis2.description.HandlerDescription;
+import org.apache.axis2.description.InOutAxisOperation;
+import org.apache.axis2.description.TransportInDescription;
+import org.apache.axis2.description.TransportOutDescription;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.axis2.handlers.AbstractHandler;
+import org.apache.axis2.receivers.RawXMLINOnlyMessageReceiver;
+import org.apache.axis2.receivers.RawXMLINOutMessageReceiver;
+import org.apache.axis2.transport.http.CommonsHTTPTransportSender;
+import org.apache.axis2.transport.http.SimpleHTTPServer;
+import org.apache.axis2.util.ObjectStateUtils;
+import org.apache.axis2.util.UUIDGenerator;
+import org.apache.axis2.wsdl.WSDLConstants;
+
+import javax.xml.namespace.QName;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.ArrayList;
+import java.util.Iterator;
+
+public class MessageContextSaveTest extends TestCase 
+{
+
+    private QName serviceName   = new QName("TestService");
+    private QName operationName = new QName("Operation_1");
+
+    private ConfigurationContext configurationContext = null;
+    private ServiceGroupContext  serviceGroupContext  = null;
+    private ServiceContext       serviceContext       = null;
+    private OperationContext     operationContext     = null;
+
+    private AxisConfiguration  axisConfiguration = null;
+    private AxisServiceGroup   axisServiceGroup  = null;
+    private AxisService        axisService       = null;
+    private AxisOperation      axisOperation     = null;
+    private AxisMessage        axisMessage       = null;
+
+    private TransportOutDescription transportOut  = null;
+    private TransportOutDescription transportOut2 = null;
+    private TransportOutDescription transportOut3 = null;
+    private TransportInDescription  transportIn   = null;
+    private TransportInDescription  transportIn2  = null;
+    private TransportInDescription  transportIn3  = null;
+
+    private Phase phase1 = null;
+    private Phase phase2 = null;
+    private Phase phase3 = null;
+    private Phase phase4 = null;
+    private Phase phase5 = null;
+    private Phase phase6 = null;
+    private Phase phase7 = null;
+
+    private MessageContext mc  = null;
+    private MessageContext mc2 = null;
+
+    private ArrayList executedHandlers = null;
+
+    private String testArg = null;
+
+
+
+    public MessageContextSaveTest(String arg0)
+    {
+        super(arg0);
+        testArg = new String(arg0);
+
+        try
+        {
+            prepare();
+        }
+        catch (Exception e)
+        {
+            System.out.println("MessageContextSaveTest:constructor:  error in setting up object graph ["+e.getClass().getName()+" : "+e.getMessage()+"]");
+        }
+    }
+
+
+    //
+    // prepare the object hierarchy for testing
+    //
+    private void prepare() throws Exception
+    {
+        //-----------------------------------------------------------------
+
+        axisConfiguration = new AxisConfiguration();
+
+        configurationContext = new ConfigurationContext(axisConfiguration);
+
+        configurationContext.getAxisConfiguration().addMessageReceiver("http://www.w3.org/2004/08/wsdl/in-only", new RawXMLINOnlyMessageReceiver()); 
+        configurationContext.getAxisConfiguration().addMessageReceiver("http://www.w3.org/2004/08/wsdl/in-out", new RawXMLINOutMessageReceiver()); 
+
+        DispatchPhase dispatchPhase = new DispatchPhase();
+        dispatchPhase.setName("Dispatch");
+
+        AddressingBasedDispatcher abd = new AddressingBasedDispatcher();
+        abd.initDispatcher();
+
+        RequestURIBasedDispatcher rud = new RequestURIBasedDispatcher();
+        rud.initDispatcher();
+
+        SOAPActionBasedDispatcher sabd = new SOAPActionBasedDispatcher();
+        sabd.initDispatcher();
+
+        SOAPMessageBodyBasedDispatcher smbd = new SOAPMessageBodyBasedDispatcher();
+        smbd.initDispatcher();
+
+        InstanceDispatcher id = new InstanceDispatcher();
+        id.init(new HandlerDescription(new String("InstanceDispatcher")));
+
+        dispatchPhase.addHandler(abd);
+        dispatchPhase.addHandler(rud);
+        dispatchPhase.addHandler(sabd);
+        dispatchPhase.addHandler(smbd);
+        dispatchPhase.addHandler(id);
+
+        configurationContext.getAxisConfiguration().getGlobalInFlow().add(dispatchPhase);
+
+        //-----------------------------------------------------------------
+
+        axisServiceGroup = new AxisServiceGroup(axisConfiguration);
+        axisServiceGroup.setServiceGroupName("ServiceGroupTest");
+
+
+        axisService = new AxisService(serviceName.getLocalPart());
+        axisServiceGroup.addService(axisService);
+
+
+        axisOperation = new InOutAxisOperation(operationName);
+        axisOperation.setMessageReceiver(new MessageReceiver()
+                                         {
+                                             public void receive(MessageContext messageCtx)
+                                             {
+
+                                             }
+                                         });
+
+        axisService.addOperation(axisOperation);
+        axisService.mapActionToOperation(operationName.getLocalPart(), axisOperation);
+
+
+        configurationContext.getAxisConfiguration().addService(axisService);
+
+        //-----------------------------------------------------------------
+
+        serviceGroupContext = new ServiceGroupContext(configurationContext, (AxisServiceGroup) axisService.getParent()); 
+        serviceGroupContext.setId("ServiceGroupContextTest");
+
+        serviceContext = serviceGroupContext.getServiceContext(axisService); 
+
+        operationContext = serviceContext.createOperationContext(operationName); 
+
+        //-----------------------------------------------------------------
+
+        transportOut  = new TransportOutDescription(new QName("null"));
+        transportOut2 = new TransportOutDescription(new QName("happy"));
+        transportOut3 = new TransportOutDescription(new QName("golucky"));
+        transportOut.setSender(new CommonsHTTPTransportSender());
+        transportOut2.setSender(new CommonsHTTPTransportSender());
+        transportOut3.setSender(new CommonsHTTPTransportSender());
+        axisConfiguration.addTransportOut(transportOut3);
+        axisConfiguration.addTransportOut(transportOut2);
+        axisConfiguration.addTransportOut(transportOut);
+
+        transportIn = new TransportInDescription(new QName("null"));
+        transportIn2 = new TransportInDescription(new QName("always"));
+        transportIn3 = new TransportInDescription(new QName("thebest"));
+        transportIn.setReceiver(new SimpleHTTPServer());
+        transportIn2.setReceiver(new SimpleHTTPServer());
+        transportIn3.setReceiver(new SimpleHTTPServer());
+        axisConfiguration.addTransportIn(transportIn2);
+        axisConfiguration.addTransportIn(transportIn);
+        axisConfiguration.addTransportIn(transportIn3);
+
+        //-----------------------------------------------------------------
+
+        mc = new MessageContext();
+        mc.setConfigurationContext(configurationContext);
+        mc.setTransportIn(transportIn);
+        mc.setTransportOut(transportOut);
+
+        mc.setServerSide(true);
+        mc.setProperty(MessageContext.TRANSPORT_OUT, System.out);
+
+        SOAPFactory omFac = OMAbstractFactory.getSOAP11Factory();
+        mc.setEnvelope(omFac.getDefaultEnvelope());
+
+        phase1 = new Phase("beginPhase1");
+        phase1.addHandler(new TempHandler(1));
+        phase1.addHandler(new TempHandler(2));
+        phase1.addHandler(new TempHandler(3));
+        phase1.addHandler(new TempHandler(4));
+        phase1.addHandler(new TempHandler(5));
+        phase1.addHandler(new TempHandler(6));
+        phase1.addHandler(new TempHandler(7));
+        phase1.addHandler(new TempHandler(8));
+        phase1.addHandler(new TempHandler(9));
+
+        phase2 = new Phase("middlePhase2");
+        phase2.addHandler(new TempHandler(10));
+        phase2.addHandler(new TempHandler(11));
+        phase2.addHandler(new TempHandler(12));
+        phase2.addHandler(new TempHandler(13));
+        phase2.addHandler(new TempHandler(14));
+        phase2.addHandler(new TempHandler(15, true));
+        phase2.addHandler(new TempHandler(16));
+        phase2.addHandler(new TempHandler(17));
+        phase2.addHandler(new TempHandler(18));
+
+        phase3 = new Phase("lastPhase3");
+        phase3.addHandler(new TempHandler(19));
+        phase3.addHandler(new TempHandler(20));
+        phase3.addHandler(new TempHandler(21));
+        phase3.addHandler(new TempHandler(22));
+        phase3.addHandler(new TempHandler(23));
+        phase3.addHandler(new TempHandler(24));
+        phase3.addHandler(new TempHandler(25));
+        phase3.addHandler(new TempHandler(26));
+        phase3.addHandler(new TempHandler(27));
+
+        phase4 = new Phase("extraPhase1");
+        phase4.addHandler(new TempHandler(28));
+        phase4.addHandler(new TempHandler(29));
+
+        phase5 = new Phase("extraPhase2");
+        phase5.addHandler(new TempHandler(30));
+
+        phase6 = new Phase("extraPhase3");
+        phase6.addHandler(new TempHandler(31, true));
+        phase6.addHandler(new TempHandler(32));
+
+        phase7 = new Phase("extraPhase4");
+        phase7.addHandler(new TempHandler(33));
+        phase7.addHandler(new TempHandler(34));
+        phase7.addHandler(new TempHandler(35));
+
+        axisOperation.getRemainingPhasesInFlow().add(phase1);
+        axisOperation.getRemainingPhasesInFlow().add(phase2);
+        axisOperation.getRemainingPhasesInFlow().add(phase3);
+        axisOperation.getRemainingPhasesInFlow().add(phase4);
+        axisOperation.getRemainingPhasesInFlow().add(phase5);
+        axisOperation.getRemainingPhasesInFlow().add(phase6);
+        axisOperation.getRemainingPhasesInFlow().add(phase7);
+
+        ArrayList phases = new ArrayList();
+        phases.add(phase1);
+        phases.add(phase2);
+        phases.add(phase3);
+        phases.add(phase4);
+        phases.add(phase5);
+        phases.add(phase6);
+        phases.add(phase7);
+        axisConfiguration.setInPhasesUptoAndIncludingPostDispatch(phases);
+
+        mc.setWSAAction(operationName.getLocalPart());
+        mc.setSoapAction(operationName.getLocalPart());
+        System.out.flush();
+
+        mc.setMessageID(UUIDGenerator.getUUID());
+
+        //operationContext.addMessageContext(mc);  gets done via the register
+        axisOperation.registerOperationContext(mc,operationContext);
+        mc.setOperationContext(operationContext);
+        mc.setServiceContext(serviceContext);
+
+        mc.setTo(new EndpointReference("axis2/services/NullService")); 
+        mc.setWSAAction("DummyOp");
+
+        axisMessage = axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE);
+        mc.setAxisMessage(axisMessage);
+
+        //-----------------------------------------------------------------
+
+        executedHandlers = new ArrayList();
+    }
+
+
+    protected void setUp() throws Exception 
+    {
+        //org.apache.log4j.BasicConfigurator.configure();
+    }
+
+
+    public void testReceive() throws Exception 
+    {
+        AxisEngine engine = new AxisEngine(configurationContext);
+
+        System.out.println("MessageContextSaveTest:testReceive(): start - - engine.receive(mc) - - - - - - - - - - - - - - - -");
+        engine.receive(mc);
+
+        System.out.println("MessageContextSaveTest:testReceive(): resume - - engine.resume(mc) - - - - - - - - - - - - - - - -");
+        engine.resume(mc);
+
+        assertEquals(30, executedHandlers.size());
+        for (int i = 15; i < 30; i++)
+        {
+            assertEquals(((Integer)executedHandlers.get(i)).intValue(), i+1);
+        }
+
+        // get the phase lists and see if they match up
+        ArrayList restoredPhases = mc2.getExecutionChain();
+        int it_count = 0;
+
+        Iterator it = restoredPhases.iterator();
+        while (it.hasNext())
+        {
+            // we know everything at this level is a Phase.  
+            // if you change it, you might get a ClassCastException 
+            Phase restored_phase = (Phase)it.next();
+
+            Phase original_phase = null;
+
+            it_count++;
+
+            if (it_count == 1)
+            {
+                original_phase = phase1;
+            }
+            else if (it_count == 2)
+            {
+                original_phase = phase2;
+            }
+            else if (it_count == 3)
+            {
+                original_phase = phase3;
+            }
+            else if (it_count == 4)
+            {
+                original_phase = phase4;
+            }
+            else if (it_count == 5)
+            {
+                original_phase = phase5;
+            }
+            else if (it_count == 6)
+            {
+                original_phase = phase6;
+            }
+            else if (it_count == 7)
+            {
+                original_phase = phase7;
+            }
+            else
+            {
+                // unexpected
+                assertTrue(false);
+            }
+
+            boolean isOk = comparePhases(restored_phase, original_phase);
+            assertTrue(isOk);
+        }
+
+        // -------------------------------------------------------------------
+        // second resume to start the second pause
+        // -------------------------------------------------------------------
+        System.out.println("MessageContextSaveTest:testReceive(): resume - - engine.resume(mc) - - - - - - - - - - - - - - - -");
+        engine.resume(mc);
+
+        assertEquals(35, executedHandlers.size());
+        for (int i = 31; i < 35; i++)
+        {
+            assertEquals(((Integer)executedHandlers.get(i)).intValue(), i+1);
+        }
+
+        // get the phase lists and see if they match up
+        restoredPhases = mc2.getExecutionChain();
+        it_count = 0;
+
+        it = restoredPhases.iterator();
+        while (it.hasNext())
+        {
+            // we know everything at this level is a Phase.  
+            // if you change it, you might get a ClassCastException 
+            Phase restored_phase = (Phase)it.next();
+
+            Phase original_phase = null;
+
+            it_count++;
+
+            if (it_count == 1)
+            {
+                original_phase = phase1;
+            }
+            else if (it_count == 2)
+            {
+                original_phase = phase2;
+            }
+            else if (it_count == 3)
+            {
+                original_phase = phase3;
+            }
+            else if (it_count == 4)
+            {
+                original_phase = phase4;
+            }
+            else if (it_count == 5)
+            {
+                original_phase = phase5;
+            }
+            else if (it_count == 6)
+            {
+                original_phase = phase6;
+            }
+            else if (it_count == 7)
+            {
+                original_phase = phase7;
+            }
+            else
+            {
+                // unexpected
+                assertTrue(false);
+            }
+
+            boolean isOk = comparePhases(restored_phase, original_phase);
+            assertTrue(isOk);
+        }
+
+    }
+
+
+    /**
+     * Gets the ID associated with the handler object.
+     * 
+     * @param o      The handler object
+     * @return The ID associated with the handler,
+     *         -1 otherwise
+     */
+    private int getHandlerID(Object o)
+    {
+        int id = -1;
+
+        if (o instanceof TempHandler)
+        {
+            id = ((TempHandler)o).getHandlerID();
+        }
+
+        return id;
+    }
+
+
+    /**
+     * Check the handler objects to see if they are equivalent.
+     * 
+     * @param o1     The first handler
+     * @param o2     The second handler
+     * @return TRUE if the handler objects are equivalent,
+     *         FALSE otherwise
+     */
+    private boolean compareHandlers(Object o1, Object o2)
+    {
+        if ((o1 == null) && (o2 == null))
+        {
+            return true;
+        }
+
+        if ((o1 != null) && (o2 != null))
+        {
+            String c1 = o1.getClass().getName();
+            String c2 = o2.getClass().getName();
+
+            if (c1.equals(c2))
+            {
+                System.out.println("MessagecontextSaveTest::compareHandlers:  class ["+c1+"] match ");
+
+                int id1 = getHandlerID(o1);
+                int id2 = getHandlerID(o2);
+
+                if (id1 == id2)
+                {
+                    System.out.println("MessagecontextSaveTest::compareHandlers:  id ["+id1+"] match");
+                    return true;
+                }
+                else
+                {
+                    System.out.println("MessagecontextSaveTest::compareHandlers:  id1 ["+id1+"] != id2 ["+id2+"] ");
+                    return false;
+                }
+            }
+            else
+            {
+                System.out.println("MessagecontextSaveTest::compareHandlers:  class1 ["+c1+"] != class2 ["+c2+"]   ");
+                return false;
+            }
+        }
+
+        return false;
+    }
+
+
+    /**
+     * Compare two phases.
+     * 
+     * @param o1     The first phase object
+     * @param o2     The second phase object
+     * @return TRUE if the phases are equivalent,
+     *         FALSE otherwise
+     */
+    private boolean comparePhases(Object o1, Object o2)
+    {
+        if ((o1 == null) && (o2 == null))
+        {
+            System.out.println("MessageContextSaveTest: comparePhases:  Phase1[] == Phase2[] - both null objects");
+            return true;
+        }
+
+        if (  ((o1 != null) && (o2 != null))
+              && ((o1 instanceof Phase) && (o2 instanceof Phase))
+           )
+        {
+
+            try
+            {
+                Phase p1 = (Phase) o1;
+                Phase p2 = (Phase) o2;
+
+                String name1 = p1.getName();
+                String name2 = p2.getName();
+
+                ArrayList list1 = p1.getHandlers();
+                ArrayList list2 = p2.getHandlers();
+
+                if ((list1 == null) && (list2 == null))
+                {
+                    System.out.println("MessageContextSaveTest: comparePhases:  Phase1["+name1+"] == Phase2["+name2+"]");
+                    return true;
+                }
+
+                if ((list1 != null) && (list2 != null))
+                {
+                    int size1 = list1.size();
+                    int size2 = list2.size();
+
+                    if (size1 != size2)
+                    {
+                        System.out.println("MessageContextSaveTest: comparePhases:  Phase1["+name1+"] != Phase2["+name2+"] - mismatched size of handler lists");
+                        return false;
+                    }
+
+                    for (int j=0; j<size1; j++)
+                    {
+                        Object obj1 = list1.get(j);
+                        Object obj2 = list2.get(j);
+
+                        if ((obj1 == null) && (obj2 == null))
+                        {
+                            // ok
+                        }
+                        else if ((obj1 != null) && (obj2 != null))
+                        {
+                            boolean check = false;
+
+                            if (obj1 instanceof Phase)
+                            {
+                                check = comparePhases(obj1, obj2);
+                            }
+                            else
+                            {
+                                // must be a handler
+                                check = compareHandlers(obj1, obj2);
+                            }
+
+                            if (check == false)
+                            {
+                                System.out.println("MessageContextSaveTest: comparePhases:  Phase1["+name1+"] != Phase2["+name2+"] - mismatched handler lists");
+                                return false;
+                            }
+                        }
+                        else
+                        {
+                            // mismatch
+                            System.out.println("MessageContextSaveTest: comparePhases:  Phase1["+name1+"] != Phase2["+name2+"] - mismatched handler lists");
+                            return false;
+                        }
+                    }
+
+                    // if we got here, the comparison completed ok
+                    // with a match
+
+                    System.out.println("MessageContextSaveTest: comparePhases:  Phase1["+name1+"] == Phase2["+name2+"] - matched handler lists");
+                    return true;
+                }
+
+            }
+            catch (Exception e)
+            {
+                // some error
+                e.printStackTrace();
+            }
+        }
+
+        System.out.println("MessageContextSaveTest: comparePhases:  Phase1[] != Phase2[]");
+        return false;
+    }
+
+
+    public class TempHandler extends AbstractHandler
+    {
+        private Integer handlerID = null;
+
+        private File   theFile     = null;
+        private String theFilename = null;
+
+        private boolean pause                  = false;
+        private boolean savedMessageContext    = false;
+        private boolean restoredMessageContext = false;
+        private boolean comparesOk             = false;
+
+        //-----------------------------------------------------------------
+        // constructors
+        //-----------------------------------------------------------------
+
+        public TempHandler()
+        {
+            this.handlerID = new Integer(-5);
+        }
+
+        public TempHandler(int index, boolean pause)
+        {
+            this.handlerID = new Integer(index);
+            this.pause = pause;
+            init(new HandlerDescription(new String("handler" + index)));
+        }
+
+        public TempHandler(int index)
+        {
+            this.handlerID = new Integer(index);
+            init(new HandlerDescription(new String("handler" + index)));
+        }
+
+
+
+        //-----------------------------------------------------------------
+        // methods
+        //-----------------------------------------------------------------
+
+        public int getHandlerID()
+        {
+            if (handlerID != null)
+            {
+                return handlerID.intValue();
+            }
+
+            return -5;
+        }
+
+
+        public InvocationResponse invoke(MessageContext msgContext) throws AxisFault
+        {
+            String title = "TempHandler["+getHandlerID()+"]:invoke(): ";
+            System.out.println(title + "pause = ["+pause+"]");
+            savedMessageContext    = false;
+            restoredMessageContext = false;
+
+            if (pause)
+            {
+                System.out.println(title + "msgContext.pause()");
+                msgContext.pause();
+                pause = false;
+
+                try
+                {
+                    theFile = File.createTempFile("mcSave",null);
+                    theFilename = theFile.getName();
+                    System.out.println(title + "temp file = ["+theFilename+"]");
+                }
+                catch (Exception ex)
+                {
+                    System.out.println(title + "error creating temp file = ["+ex.getMessage()+"]");
+                    theFile = null;
+                }
+
+                if (theFile != null)
+                {
+                    // ---------------------------------------------------------
+                    // save to the temporary file
+                    // ---------------------------------------------------------
+                    try
+                    {
+                        // setup an output stream to a physical file
+                        FileOutputStream outStream = new FileOutputStream(theFile);
+
+                        // attach a stream capable of writing objects to the 
+                        // stream connected to the file
+                        ObjectOutputStream outObjStream = new ObjectOutputStream(outStream);
+
+                        // try to save the message context
+                        System.out.println(title + "saving message context.....");
+                        savedMessageContext = false;
+                        outObjStream.writeObject(msgContext);
+
+                        // close out the streams
+                        outObjStream.flush();
+                        outObjStream.close();
+                        outStream.flush();
+                        outStream.close();
+
+                        savedMessageContext = true;
+                        System.out.println(title + "....saved message context.....");
+
+                        long filesize = theFile.length();
+                        System.out.println(title + "file size after save ["+filesize+"]   temp file = ["+theFilename+"]");
+
+                    }
+                    catch (Exception ex2)
+                    {
+                        System.out.println(title + "error with saving message context = ["+ex2.getClass().getName()+" : "+ex2.getMessage()+"]");
+                        ex2.printStackTrace();
+                    }
+
+                    assertTrue(savedMessageContext);
+
+                    // ---------------------------------------------------------
+                    // restore from the temporary file
+                    // ---------------------------------------------------------
+                    try
+                    {
+                        // setup an input stream to the file
+                        FileInputStream inStream = new FileInputStream(theFile);
+
+                        // attach a stream capable of reading objects from the 
+                        // stream connected to the file
+                        ObjectInputStream inObjStream = new ObjectInputStream(inStream);
+
+                        // try to restore the message context
+                        System.out.println(title + "restoring a message context.....");
+                        restoredMessageContext = false;
+
+                        MessageContext msgContext2 = (MessageContext) inObjStream.readObject();
+                        inObjStream.close();
+                        inStream.close();
+
+                        msgContext2.activate(configurationContext);
+
+                        restoredMessageContext = true;
+                        System.out.println(title + "....restored message context.....");
+
+                        // compare to original execution chain
+                        ArrayList restored_execChain = msgContext2.getExecutionChain();
+                        ArrayList orig_execChain     = msgContext.getExecutionChain();
+
+                        comparesOk = ObjectStateUtils.isEquivalent(restored_execChain, orig_execChain, false);
+                        System.out.println(title + "execution chain equivalency ["+comparesOk+"]");
+                        assertTrue(comparesOk);
+
+                        // check executed list
+                        Iterator restored_executed_it = msgContext2.getInboundExecutedPhases();
+                        Iterator orig_executed_it     = msgContext.getInboundExecutedPhases();
+                        if ((restored_executed_it != null) && (orig_executed_it != null))
+                        {
+                            while (restored_executed_it.hasNext() && orig_executed_it.hasNext())
+                            {
+                                Object p1 = restored_executed_it.next();
+                                Object p2 = orig_executed_it.next();
+
+                                comparesOk = comparePhases(p1, p2);
+                                System.out.println(title + "executed phase list:  compare phases ["+comparesOk+"]");
+                                assertTrue(comparesOk);
+                            }
+                        }
+                        else
+                        {
+                            // problem with the executed lists
+                            assertTrue(false);
+                        }
+
+
+
+                        // now put the restored message context in the global
+                        // variable for the test 
+                        mc2 = msgContext2;
+                    }
+                    catch (Exception ex2)
+                    {
+                        System.out.println(title + "error with saving message context = ["+ex2.getClass().getName()+" : "+ex2.getMessage()+"]");
+                        ex2.printStackTrace();
+                    }
+
+                    assertTrue(restoredMessageContext);
+
+                    // if the save/restore of the message context succeeded,
+                    // then don't keep the temporary file around
+                    boolean removeTmpFile = savedMessageContext && restoredMessageContext && comparesOk;
+                    if (removeTmpFile)
+                    {
+                        try
+                        {
+                            theFile.delete();
+                        }
+                        catch (Exception e)
+                        {
+                            // just absorb it
+                        }
+                    }
+                }
+
+                return InvocationResponse.SUSPEND;
+
+            }
+            else
+            {
+                System.out.println(title + "executedHandlers.add("+handlerID+")");
+                executedHandlers.add(handlerID);
+            }
+
+            return InvocationResponse.CONTINUE;
+        }
+
+    }
+}
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/test/org/apache/axis2/engine/OptionsSaveTest.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/test/org/apache/axis2/engine/OptionsSaveTest.java	(revision 0)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/test/org/apache/axis2/engine/OptionsSaveTest.java	(revision 0)
@@ -0,0 +1,267 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.engine;
+
+import junit.framework.TestCase;
+
+import org.apache.axis2.addressing.AddressingConstants;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.client.Options;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.description.TransportInDescription;
+import org.apache.axis2.description.TransportOutDescription;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.axis2.receivers.RawXMLINOnlyMessageReceiver;
+import org.apache.axis2.receivers.RawXMLINOutMessageReceiver;
+import org.apache.axis2.transport.http.CommonsHTTPTransportSender;
+import org.apache.axis2.transport.http.SimpleHTTPServer;
+import org.apache.axiom.soap.SOAP12Constants;
+
+import javax.xml.namespace.QName;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+
+public class OptionsSaveTest extends TestCase
+{
+
+    private transient QName serviceName = new QName("NullService");
+    private transient QName operationName = new QName("DummyOp");
+
+
+    private String testArg = null;
+
+
+    public OptionsSaveTest(String arg0)
+    {
+        super(arg0);
+        testArg = new String(arg0);
+
+        initAll();
+    }
+
+
+    protected void initAll()
+    {
+    }
+
+
+    protected void setUp() throws Exception 
+    {
+        //org.apache.log4j.BasicConfigurator.configure();
+    }
+
+    public void testSaveAndRestore() throws Exception 
+    {
+        File    theFile     = null;
+        String  theFilename = null;
+        boolean saved       = false;
+        boolean restored    = false;
+        boolean done        = false;
+        boolean comparesOk  = false;
+
+        AxisConfiguration axisConfiguration       = new AxisConfiguration();
+        ConfigurationContext configurationContext = new ConfigurationContext(axisConfiguration);
+
+
+        System.out.println("OptionsSaveTest:testSaveAndRestore():  BEGIN ---------------");
+
+        // ---------------------------------------------------------
+        // setup an options object to use
+        // ---------------------------------------------------------
+        Options options = new Options();
+
+        options.setSoapVersionURI(SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI);
+        options.setExceptionToBeThrownOnSOAPFault(true);
+        options.setTimeOutInMilliSeconds(5000L);
+        options.setUseSeparateListener(false);
+        options.setAction("SoapAction");
+        options.setFaultTo(new EndpointReference("http://ws.apache.org/axis2/faultTo"));
+        options.setFrom(new EndpointReference("http://ws.apache.org/axis2/from"));
+        options.setTo(new EndpointReference("http://ws.apache.org/axis2/to"));
+        options.setReplyTo(new EndpointReference(AddressingConstants.Final.WSA_ANONYMOUS_URL));
+
+        TransportOutDescription transportOut  = new TransportOutDescription(new QName("null"));
+        TransportOutDescription transportOut2 = new TransportOutDescription(new QName("happy"));
+        TransportOutDescription transportOut3 = new TransportOutDescription(new QName("golucky"));
+        transportOut.setSender(new CommonsHTTPTransportSender());
+        transportOut2.setSender(new CommonsHTTPTransportSender());
+        transportOut3.setSender(new CommonsHTTPTransportSender());
+        options.setTransportOut(transportOut);
+        axisConfiguration.addTransportOut(transportOut3);
+        axisConfiguration.addTransportOut(transportOut2);
+        axisConfiguration.addTransportOut(transportOut);
+
+        TransportInDescription transportIn  = new TransportInDescription(new QName("null"));
+        TransportInDescription transportIn2 = new TransportInDescription(new QName("always"));
+        TransportInDescription transportIn3 = new TransportInDescription(new QName("thebest"));
+        transportIn.setReceiver(new SimpleHTTPServer());
+        transportIn2.setReceiver(new SimpleHTTPServer());
+        transportIn3.setReceiver(new SimpleHTTPServer());
+        options.setTransportIn(transportIn);
+        axisConfiguration.addTransportIn(transportIn2);
+        axisConfiguration.addTransportIn(transportIn);
+        axisConfiguration.addTransportIn(transportIn3);
+
+        options.setMessageId("msgId012345");
+
+        options.setProperty("key01", "value01");
+        options.setProperty("key02", "value02");
+        options.setProperty("key03", "value03");
+        options.setProperty("key04", "value04");
+        options.setProperty("key05", "value05");
+        options.setProperty("key06", "value06");
+        options.setProperty("key07", "value07");
+        options.setProperty("key08", "value08");
+        options.setProperty("key09", "value09");
+        options.setProperty("key10", "value10");
+
+        // TODO: setup a parent
+
+
+        // ---------------------------------------------------------
+        // setup a temporary file to use
+        // ---------------------------------------------------------
+        try
+        {
+            theFile = File.createTempFile("optionsSave",null);
+            theFilename = theFile.getName();
+            System.out.println("OptionsSaveTest:testSaveAndRestore(): temp file = ["+theFilename+"]");
+        }
+        catch (Exception ex)
+        {
+            System.out.println("OptionsSaveTest:testSaveAndRestore(): error creating temp file = ["+ex.getMessage()+"]");
+            theFile = null;
+        }
+
+        if (theFile != null)
+        {
+            // ---------------------------------------------------------
+            // save to the temporary file
+            // ---------------------------------------------------------
+            try
+            {
+                // setup an output stream to a physical file
+                FileOutputStream outStream = new FileOutputStream(theFile);
+
+                // attach a stream capable of writing objects to the 
+                // stream connected to the file
+                ObjectOutputStream outObjStream = new ObjectOutputStream(outStream);
+
+                // try to save the message context
+                System.out.println("OptionsSaveTest:testSaveAndRestore(): saving .....");
+                saved = false;
+                outObjStream.writeObject(options);
+
+                // close out the streams
+                outObjStream.flush();
+                outObjStream.close();
+                outStream.flush();
+                outStream.close();
+
+                saved = true;
+                System.out.println("OptionsSaveTest:testSaveAndRestore(): ....save operation completed.....");
+
+                long filesize = theFile.length();
+                System.out.println("OptionsSaveTest:testSaveAndRestore(): file size after save ["+filesize+"]   temp file = ["+theFilename+"]");
+            }
+            catch (Exception ex2)
+            {
+                if (saved != true)
+                {
+                    System.out.println("OptionsSaveTest:testSaveAndRestore(): error during save ["+ex2.getClass().getName()+" : "+ex2.getMessage()+"]");
+                    ex2.printStackTrace();
+                }
+                else
+                {
+                    System.out.println("OptionsSaveTest:testSaveAndRestore(): error during restore ["+ex2.getClass().getName()+" : "+ex2.getMessage()+"]");
+                    ex2.printStackTrace();
+                }
+            }
+
+            assertTrue(saved);
+
+            // ---------------------------------------------------------
+            // restore from the temporary file
+            // ---------------------------------------------------------
+            try
+            {
+                // setup an input stream to the file
+                FileInputStream inStream = new FileInputStream(theFile);
+
+                // attach a stream capable of reading objects from the 
+                // stream connected to the file
+                ObjectInputStream inObjStream = new ObjectInputStream(inStream);
+
+                // try to restore the options
+                System.out.println("OptionsSaveTest:testSaveAndRestore(): restoring .....");
+                restored = false;
+                Options options_restored = (Options) inObjStream.readObject();
+                inObjStream.close();
+                inStream.close();
+
+                options_restored.activate(configurationContext);
+
+                restored = true;
+                System.out.println("OptionsSaveTest:testSaveAndRestore(): ....restored operation completed.....");
+
+                comparesOk = options_restored.isEquivalent(options);
+                System.out.println("OptionsSaveTest:testSaveAndRestore():   Options equivalency ["+comparesOk+"]");
+            }
+            catch (Exception ex2)
+            {
+                System.out.println("OptionsSaveTest:testSaveAndRestore(): error during restore ["+ex2.getClass().getName()+" : "+ex2.getMessage()+"]");
+                ex2.printStackTrace();
+            }
+
+            assertTrue(restored);
+
+            assertTrue(comparesOk);
+
+            // if the save/restore of the object succeeded,
+            // then don't keep the temporary file around
+            boolean removeTmpFile = saved && restored && comparesOk;
+            if (removeTmpFile)
+            {
+                try
+                {
+                    theFile.delete();
+                }
+                catch (Exception e)
+                {
+                    // just absorb it
+                }
+            }
+            
+            // indicate that the temp file was created ok
+            done = true;
+        }
+
+        // this is false when there are problems with the temporary file
+        assertTrue(done);
+
+        System.out.println("OptionsSaveTest:testSaveAndRestore():  END ---------------");
+    }
+
+
+
+}
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/test/org/apache/axis2/engine/MessageContextSelfManagedDataTest.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/test/org/apache/axis2/engine/MessageContextSelfManagedDataTest.java	(revision 0)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/test/org/apache/axis2/engine/MessageContextSelfManagedDataTest.java	(revision 0)
@@ -0,0 +1,1694 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.engine;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.ArrayList;
+import java.util.Iterator;
+
+import javax.xml.namespace.QName;
+
+import junit.framework.TestCase;
+
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.axiom.soap.SOAPFactory;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.OperationContext;
+import org.apache.axis2.context.SelfManagedDataManager;
+import org.apache.axis2.context.ServiceContext;
+import org.apache.axis2.context.ServiceGroupContext;
+import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.AxisServiceGroup;
+import org.apache.axis2.description.HandlerDescription;
+import org.apache.axis2.description.InOutAxisOperation;
+import org.apache.axis2.description.TransportInDescription;
+import org.apache.axis2.description.TransportOutDescription;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.axis2.handlers.AbstractHandler;
+import org.apache.axis2.receivers.RawXMLINOnlyMessageReceiver;
+import org.apache.axis2.receivers.RawXMLINOutMessageReceiver;
+import org.apache.axis2.transport.http.CommonsHTTPTransportSender;
+import org.apache.axis2.transport.http.SimpleHTTPServer;
+import org.apache.axis2.util.UUIDGenerator;
+
+public class MessageContextSelfManagedDataTest extends TestCase
+{
+
+    private File theFile = null;
+    boolean savedMessageContext = false;
+    boolean restoredMessageContext = false;
+
+    private String serviceGroupName = new String("NullServiceGroup");
+    private QName serviceName = new QName("NullService");
+    private QName operationName = new QName("DummyOp");
+
+    private ConfigurationContext cfgContext           = null;
+    private ServiceGroupContext  serviceGroupContext  = null;
+    private ServiceContext       serviceContext       = null;
+    private OperationContext     operationContext     = null;
+
+    private AxisConfiguration  axisConfiguration = null;
+    private AxisServiceGroup   axisServiceGroup  = null;
+    private AxisService        axisService       = null;
+    private AxisOperation      axisOperation     = null;
+
+    private TransportOutDescription transportOut  = null;
+    private TransportOutDescription transportOut2 = null;
+    private TransportOutDescription transportOut3 = null;
+    private TransportInDescription  transportIn   = null;
+    private TransportInDescription  transportIn2  = null;
+    private TransportInDescription  transportIn3  = null;
+
+    private MessageContext mc = null;
+
+    private TempHandler01 handler01;
+    private TempHandler02 handler02;
+    private TempHandler02 subhandler;  // this handler is intended to be a few levels down in executionChain
+    private TempHandler03 handler03;
+    private TempHandler04 handler04;
+    private Phase phase1;
+    private Phase phase2;
+    private Phase phase3;
+    private Phase subPhase;
+
+    // use this to count how many times methods get called for a particular test
+    private int invokecallcount = 0;
+
+
+    // key-value pairs to be used for self managed data
+
+    private  String key01 = "key01";
+    private  String testData01 = "TempHandler01_01";
+
+    private  String key02 = "key02";
+    private  String testData02 = "TempHandler01_02";
+
+    private  String  key03 = "key03";
+    private  byte [] testData03 = { 0x1A,0x1B,0x1C,0x1D,0x1E,0x1B,0x1C,0x1D,0x1E,0x1F,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F};
+
+    private  String  key04 = "key04";
+    private  long [] testData04 = {0L,1L,-6601664200673063531L,-7753637088257391858L};
+
+    private  String  key05 = "key05";
+    private  int     testData05 = 123456;
+
+
+
+    public MessageContextSelfManagedDataTest(String arg0)
+    {
+        super(arg0);
+        initAll();
+    }
+
+
+    protected void initAll()
+    {
+        try
+        {
+            prepare();
+        }
+        catch (Exception e)
+        {
+            System.out.println("MessageContextSelfManagedDataTest:initAll:  error in setting up object graph ["+e.getClass().getName()+" : "+e.getMessage()+"]");
+        }
+
+        if (handler01 == null)
+        {
+            handler01 = new TempHandler01(101);
+        }
+
+        if (handler02 == null)
+        {
+            handler02 = new TempHandler02(102);
+        }
+
+        if (handler03 == null)
+        {
+            handler03 = new TempHandler03(103);
+        }
+
+        if (handler04 == null)
+        {
+            handler04 = new TempHandler04(104);
+        }
+
+        if (subhandler == null)
+        {
+            subhandler = new TempHandler02(1000);
+        }
+
+    }
+
+
+    //
+    // prepare the object hierarchy for testing
+    //
+    private void prepare() throws Exception
+    {
+        //-----------------------------------------------------------------
+
+        axisConfiguration = new AxisConfiguration();
+
+        cfgContext = new ConfigurationContext(axisConfiguration);
+
+        cfgContext.getAxisConfiguration().addMessageReceiver("http://www.w3.org/2004/08/wsdl/in-only", new RawXMLINOnlyMessageReceiver()); 
+        cfgContext.getAxisConfiguration().addMessageReceiver("http://www.w3.org/2004/08/wsdl/in-out", new RawXMLINOutMessageReceiver()); 
+
+        DispatchPhase dispatchPhase = new DispatchPhase();
+        dispatchPhase.setName("Dispatch");
+
+        AddressingBasedDispatcher abd = new AddressingBasedDispatcher();
+        abd.initDispatcher();
+
+        RequestURIBasedDispatcher rud = new RequestURIBasedDispatcher();
+        rud.initDispatcher();
+
+        SOAPActionBasedDispatcher sabd = new SOAPActionBasedDispatcher();
+        sabd.initDispatcher();
+
+        SOAPMessageBodyBasedDispatcher smbd = new SOAPMessageBodyBasedDispatcher();
+        smbd.initDispatcher();
+
+        InstanceDispatcher id = new InstanceDispatcher();
+        id.init(new HandlerDescription(new String("InstanceDispatcher")));
+
+        dispatchPhase.addHandler(abd);
+        dispatchPhase.addHandler(rud);
+        dispatchPhase.addHandler(sabd);
+        dispatchPhase.addHandler(smbd);
+        dispatchPhase.addHandler(id);
+
+        cfgContext.getAxisConfiguration().getGlobalInFlow().add(dispatchPhase);
+
+        //-----------------------------------------------------------------
+
+        axisServiceGroup = new AxisServiceGroup(axisConfiguration);
+        axisServiceGroup.setServiceGroupName("ServiceGroupTest");
+
+
+        axisService = new AxisService(serviceName.getLocalPart());
+        axisServiceGroup.addService(axisService);
+
+
+        axisOperation = new InOutAxisOperation(operationName);
+        axisOperation.setMessageReceiver(new MessageReceiver()
+                                         {
+                                             public void receive(MessageContext messageCtx)
+                                             {
+
+                                             }
+                                         });
+
+        axisService.addOperation(axisOperation);
+        axisService.mapActionToOperation(operationName.getLocalPart(), axisOperation);
+
+
+        cfgContext.getAxisConfiguration().addService(axisService);
+
+        //-----------------------------------------------------------------
+
+        serviceGroupContext = new ServiceGroupContext(cfgContext, (AxisServiceGroup) axisService.getParent()); 
+        serviceGroupContext.setId("ServiceGroupContextTest");
+
+        serviceContext = serviceGroupContext.getServiceContext(axisService); 
+
+        operationContext = serviceContext.createOperationContext(operationName); 
+
+        //-----------------------------------------------------------------
+
+        transportOut  = new TransportOutDescription(new QName("null"));
+        transportOut2 = new TransportOutDescription(new QName("happy"));
+        transportOut3 = new TransportOutDescription(new QName("golucky"));
+        transportOut.setSender(new CommonsHTTPTransportSender());
+        transportOut2.setSender(new CommonsHTTPTransportSender());
+        transportOut3.setSender(new CommonsHTTPTransportSender());
+        axisConfiguration.addTransportOut(transportOut3);
+        axisConfiguration.addTransportOut(transportOut2);
+        axisConfiguration.addTransportOut(transportOut);
+
+        transportIn = new TransportInDescription(new QName("null"));
+        transportIn2 = new TransportInDescription(new QName("always"));
+        transportIn3 = new TransportInDescription(new QName("thebest"));
+        transportIn.setReceiver(new SimpleHTTPServer());
+        transportIn2.setReceiver(new SimpleHTTPServer());
+        transportIn3.setReceiver(new SimpleHTTPServer());
+        axisConfiguration.addTransportIn(transportIn2);
+        axisConfiguration.addTransportIn(transportIn);
+        axisConfiguration.addTransportIn(transportIn3);
+
+    }
+
+
+    /*
+     * (non-Javadoc)
+     * @see junit.framework.TestCase#setUp()
+     * 
+     * setUp gets called before each test* method.  In this class, a new
+     * MessageContext object is created for each test* method.  The test*
+     * methods are responsible for adding whichever handler they may need
+     * in order to run the desired test.  See the handler class comments
+     * for their respective functions.
+     */
+    protected void setUp() throws Exception 
+    {
+        //org.apache.log4j.BasicConfigurator.configure();
+
+        invokecallcount = 0;
+
+        mc = new MessageContext();
+
+        mc.setConfigurationContext(cfgContext);
+        mc.setTransportIn(transportIn);
+        mc.setTransportOut(transportOut);
+
+        mc.setServerSide(true);
+        mc.setProperty(MessageContext.TRANSPORT_OUT, System.out);
+
+        SOAPFactory omFac = OMAbstractFactory.getSOAP11Factory();
+        mc.setEnvelope(omFac.getDefaultEnvelope());
+
+        phase1 = new Phase("1");
+        phase1.addHandler(new TempHandler02(0));
+        phase1.addHandler(new TempHandler02(1));
+
+        phase2 = new Phase("2");
+        phase2.addHandler(new TempHandler02(2));
+        phase2.addHandler(handler02);
+        phase2.addHandler(new TempHandler02(3));
+
+        phase3 = new Phase("3");
+        phase3.addHandler(new TempHandler02(4));
+        phase3.addHandler(subhandler);
+        phase3.addHandler(handler02);  // same instance, second insertion
+        phase3.addHandler(new TempHandler02(5));
+
+        /*
+         * TODO:  WARNING WARNING WARNING
+         * Ideally inserting subPhase here would make the axis2 engine call
+         * the invoke of nested subhandler.  It does not do this.  Please see the
+         * warning at bottom of testPause06 method.
+         */
+        subPhase = new Phase("sub");
+        subPhase.addHandler(subhandler);
+        phase3.addHandler(subPhase);
+        phase3.addHandler(new TempHandler02(6));
+        phase3.addHandler(new TempHandler02(7));
+
+        axisOperation.getRemainingPhasesInFlow().add(phase1);
+        axisOperation.getRemainingPhasesInFlow().add(phase2);
+        axisOperation.getRemainingPhasesInFlow().add(phase3);
+
+
+        mc.setMessageID(UUIDGenerator.getUUID());
+
+        //operationContext.addMessageContext(mc);  gets done via the register
+        axisOperation.registerOperationContext(mc,operationContext);
+        mc.setOperationContext(operationContext);
+        mc.setServiceContext(serviceContext);
+
+        mc.setTo(new EndpointReference("axis2/services/NullService")); 
+
+        mc.setWSAAction(operationName.getLocalPart());
+        mc.setSoapAction(operationName.getLocalPart());
+
+    }
+
+    //-------------------------------------------------------------------------
+    // test cases
+    //-------------------------------------------------------------------------
+
+
+    /**
+     * Test case for setting and removing data from a message context
+     */
+    public void testSelfManagedData01() 
+    {
+        System.out.println("MessageContextSelfManagedDataTest::testSelfManagedData01()=======================================");
+        try
+        {
+            ArrayList handlers = new ArrayList();
+            handlers.add(handler01);
+            cfgContext.getAxisConfiguration().setInPhasesUptoAndIncludingPostDispatch(handlers);
+
+            mc.setTo(new EndpointReference("axis2/services/NullService")); 
+            mc.setWSAAction("DummyOp");
+
+            AxisEngine engine = new AxisEngine(cfgContext);
+            engine.receive(mc);
+
+        }
+        catch (Exception e)
+        {
+            e.printStackTrace();
+        }
+
+        assertEquals(testData01, handler01.getTestData01FromMessageContext(mc));
+        assertEquals(testData02, handler01.getTestData02FromMessageContext(mc));
+
+        boolean isOk3 = isEquals(testData03, handler01.getTestData03FromMessageContext(mc) );
+        assertTrue(isOk3);
+
+        boolean isOk4 = isEquals(testData04, handler01.getTestData04FromMessageContext(mc) );
+        assertTrue(isOk4);
+
+        assertEquals(1, invokecallcount);
+    }
+
+
+
+    /**
+     * Test for setting, saving, restoring self managed data with no exceptions
+     */
+    public void testPause01_noExceptions()
+    {
+        System.out.println("MessageContextSelfManagedDataTest::testPause01_noExceptions()=======================================");
+
+        try
+        {
+            ArrayList handlers = new ArrayList();
+            handlers.add(handler02);
+            cfgContext.getAxisConfiguration().setInPhasesUptoAndIncludingPostDispatch(handlers);
+
+            mc.setTo(new EndpointReference("axis2/services/NullService")); 
+            mc.setWSAAction("DummyOp");
+
+            AxisEngine engine = new AxisEngine(cfgContext);
+            engine.receive(mc);
+        }
+        catch (Exception e)
+        {
+            e.printStackTrace();
+        }
+
+        // if we didn't get any exceptions during save/restore, these will be true
+        assertTrue(savedMessageContext);
+        assertTrue(restoredMessageContext);
+        assertEquals(1, invokecallcount);
+    }
+
+
+    /**
+     * Test for verifying the self managed data used during the save and restore
+     */
+    public void testPause02_saveRestoreSelfManagedData()
+    {
+        System.out.println("MessageContextSelfManagedDataTest::testPause02_saveRestoreSelfManagedData()=======================================");
+
+        try
+        {
+            ArrayList handlers = new ArrayList();
+            handlers.add(handler02);
+            cfgContext.getAxisConfiguration().setInPhasesUptoAndIncludingPostDispatch(handlers);
+
+            mc.setTo(new EndpointReference("axis2/services/NullService")); 
+            mc.setWSAAction("DummyOp");
+
+            AxisEngine engine = new AxisEngine(cfgContext);
+            engine.receive(mc);
+        }
+        catch (Exception e)
+        {
+            e.printStackTrace();
+        }
+
+        // make sure the data in our handler got restored
+        assertEquals(handler02.testData, handler02.getTestDataFromMessageContext(mc));
+        assertEquals(1, invokecallcount);
+    }
+
+    /**
+     * Test for save and restore of self managed data and the AxisOperation
+     */
+    public void testPause03_saveRestoreOperation()
+    {
+        System.out.println("MessageContextSelfManagedDataTest::testPause03_saveRestoreOperation()=======================================");
+
+        try
+        {
+            ArrayList handlers = new ArrayList();
+            handlers.add(handler02);
+            cfgContext.getAxisConfiguration().setInPhasesUptoAndIncludingPostDispatch(handlers);
+
+            mc.setTo(new EndpointReference("axis2/services/NullService")); 
+            mc.setWSAAction("DummyOp");
+
+            AxisEngine engine = new AxisEngine(cfgContext);
+            engine.receive(mc);
+        }
+        catch (Exception e)
+        {
+            e.printStackTrace();
+        }
+
+        // make sure the operation got restored in the MessageContext object
+        assertEquals(operationName.toString(), mc.getAxisOperation().getName().toString());
+        assertEquals(1, invokecallcount);
+
+    }
+
+
+    /**
+     * Test for save and restore of self managed data and the AxisService
+     */
+    public void testPause04_saveRestoreAxisService()
+    {
+        System.out.println("MessageContextSelfManagedDataTest::testPause04_saveRestoreAxisService()=======================================");
+
+        try
+        {
+            ArrayList handlers = new ArrayList();
+            handlers.add(handler02);
+            cfgContext.getAxisConfiguration().setInPhasesUptoAndIncludingPostDispatch(handlers);
+
+            mc.setTo(new EndpointReference("axis2/services/NullService")); 
+            mc.setWSAAction("DummyOp");
+
+            AxisEngine engine = new AxisEngine(cfgContext);
+            engine.receive(mc);
+        }
+        catch (Exception e)
+        {
+            e.printStackTrace();
+        }
+
+        // make sure the service got restored in the MessageContext object
+        assertEquals(serviceName.toString(), mc.getAxisService().getName().toString());
+        assertEquals(1, invokecallcount);
+    }
+
+
+    /**
+     * Test for save and restore of self managed data and the AxisServiceGroup
+     */
+    public void testPause05_saveRestoreAxisServiceGroup()
+    {
+        System.out.println("MessageContextSelfManagedDataTest::testPause05_saveRestoreAxisServiceGroup()=======================================");
+
+        try
+        {
+            ArrayList handlers = new ArrayList();
+            handlers.add(handler02);
+            cfgContext.getAxisConfiguration().setInPhasesUptoAndIncludingPostDispatch(handlers);
+
+            mc.setTo(new EndpointReference("axis2/services/NullService")); 
+            mc.setWSAAction("DummyOp");
+
+            AxisEngine engine = new AxisEngine(cfgContext);
+            engine.receive(mc);
+
+        }
+        catch (Exception e)
+        {
+            e.printStackTrace();
+        }
+
+        // make sure the serviceGroup got restored in the MessageContext object
+        //assertEquals(serviceGroupName.toString(), mc.getAxisServiceGroup().getServiceGroupName());
+        assertEquals(1, invokecallcount);
+    }
+
+
+    /**
+     * Test for phases
+     */
+    public void testPause06_saveRestorePhases()
+    {
+        System.out.println("MessageContextSelfManagedDataTest::testPause06_saveRestorePhases()=======================================");
+
+        TempHandler02 handlerA = new TempHandler02(666);
+
+        Phase phase601 = new Phase("01");
+        phase601.addHandler(new TempHandler02(61)); // slot 1
+        phase601.addHandler(new TempHandler03(62)); // slot 2
+
+        Phase phase602 = new Phase("02");
+        phase602.addHandler(new TempHandler02(63)); // slot 3
+        phase602.addHandler(handlerA);              // slot 4
+        phase602.addHandler(new TempHandler03(64)); // slot 5
+
+        Phase phase603 = new Phase("03");
+        phase603.addHandler(new TempHandler02(65)); // slot 6
+        phase603.addHandler(subhandler);            // slot 7
+        phase603.addHandler(handlerA);              // slot 8 - same instance, second insertion
+        phase603.addHandler(new TempHandler03(66)); // slot 9
+
+        /*
+         * TODO:  WARNING WARNING WARNING
+         * Ideally inserting subPhase here would make the axis2 engine call
+         * the invoke of nested subhandler.  It does not do this.  
+         * Please see the warning later in this method.
+         */
+        Phase subPhase601 = new Phase("sub6");
+        subPhase601.addHandler(subhandler);
+        phase603.addHandler(subPhase601);           // slot 10
+        phase603.addHandler(new TempHandler02(67)); // slot 11
+        phase603.addHandler(new TempHandler03(68)); // slot 12
+
+        try
+        {
+            ArrayList phases = new ArrayList();
+            phases.add(phase601);
+            phases.add(phase602);
+            phases.add(phase603);
+
+            cfgContext.getAxisConfiguration().setInPhasesUptoAndIncludingPostDispatch(phases);
+
+            mc.setTo(new EndpointReference("axis2/services/NullService")); 
+            mc.setWSAAction("DummyOp");
+
+            AxisEngine engine = new AxisEngine(cfgContext);
+            engine.receive(mc);
+        }
+        catch (Exception e)
+        {
+            e.printStackTrace();
+        }
+
+        // get the phase lists and see if they match up
+        ArrayList restoredPhases = mc.getExecutionChain();
+        int it_count = 0;
+
+        Iterator it = restoredPhases.iterator();
+        while (it.hasNext())
+        {
+            // we know everything at this level is a Phase.  
+            // if you change it, you might get a ClassCastException 
+            Phase restored_phase = (Phase)it.next();
+
+            Phase original_phase = null;
+
+            it_count++;
+
+            if (it_count == 1)
+            {
+                original_phase = phase601;
+            }
+            else if (it_count == 2)
+            {
+                original_phase = phase602;
+            }
+            else if (it_count == 3)
+            {
+                original_phase = phase603;
+            }
+
+            //comparePhases(restored_phase.getHandlers().iterator(), original_phase.getHandlers());
+
+            boolean isOk = comparePhases(restored_phase, original_phase);
+            assertTrue(isOk);
+        }
+
+        // TODO WARNING WARNING WARNING
+        // The axis2 engine is not calling the invoke on nested handlers!  
+        // The way this testcase works is that the handler's invoke() method is 
+        // what sets the data.  So, any handlers that are in subPhase will 
+        // not get called, and thus will not set or restore any data.  
+        // Notice we do currently have a subhandler in the subPhase object.
+        // When axis2 decides to support nested handlers, the
+        // first three assertEquals below will fail.
+        System.out.println("MessageContextSelfManagedDataTest::testPause06_saveRestorePhases()::  invokecallcount ["+invokecallcount+"]");
+        assertEquals(11, invokecallcount);
+
+        
+        // even though there are two occurrances of the same instance of 
+        // handlerA in the executionChain, its serialize and deserialize 
+        // should only be called once per unique instance in the list
+        int count_s = handlerA.getSerializecallcount();
+        System.out.println("MessageContextSelfManagedDataTest::testPause06_saveRestorePhases()::  handlerA serialize call count ["+count_s+"]");
+        assertEquals(11, count_s);
+
+
+        // here comes some fun math...  
+        // Since a handler (TempHandler02) in this case 
+        // doesn't add any data until its invoke method gets called, 
+        // and the invoke is what causes the save/restore (and thus 
+        // the serialize/deserialize) there is no data for handlerA 
+        // to deserialize until the first occurance of handlerA 
+        // invoke is called in the executionChain.  Observing our phases, 
+        // we see it is in slot #3.  11 - 3 = 8
+        int count_d = handlerA.getDeserializecallcount();
+        System.out.println("MessageContextSelfManagedDataTest::testPause06_saveRestorePhases()::  handlerA deserialize call count ["+count_d+"]");
+        assertEquals(8, count_d);
+        assertEquals(subhandler.testData, subhandler.getTestDataFromMessageContext(mc));
+
+    }
+
+
+    /**
+     * Test for save and restore of binary self managed data
+     */
+    public void testSelfManagedData07()
+    {
+        System.out.println("MessageContextSelfManagedDataTest::testSelfManagedData07()=======================================");
+        try
+        {
+            ArrayList handlers = new ArrayList();
+            handlers.add(handler03);
+            cfgContext.getAxisConfiguration().setInPhasesUptoAndIncludingPostDispatch(handlers);
+
+            mc.setTo(new EndpointReference("axis2/services/NullService")); 
+            mc.setWSAAction("DummyOp");
+
+            AxisEngine engine = new AxisEngine(cfgContext);
+            engine.receive(mc);
+        }
+        catch (Exception e)
+        {
+            e.printStackTrace();
+        }
+
+        boolean isOk3 = isEquals(testData03, (byte []) handler03.getTestDataFromMessageContext(mc) );
+        assertTrue(isOk3);
+
+        assertEquals(1, invokecallcount);
+    }
+
+
+
+    /**
+     * Test for handler04
+     */
+    public void testSelfManagedData08()
+    {
+        System.out.println("MessageContextSelfManagedDataTest::testSelfManagedData08()=======================================");
+        try
+        {
+
+            ArrayList handlers = new ArrayList();
+            handlers.add(handler04);
+            cfgContext.getAxisConfiguration().setInPhasesUptoAndIncludingPostDispatch(handlers);
+
+            mc.setTo(new EndpointReference("axis2/services/NullService")); 
+            mc.setWSAAction("DummyOp");
+
+            AxisEngine engine = new AxisEngine(cfgContext);
+            engine.receive(mc);
+
+        }
+        catch (Exception e)
+        {
+            e.printStackTrace();
+        }
+
+        boolean isOk4 = isEquals(testData04, (long []) handler04.getTestDataFromMessageContext(mc) );
+        assertTrue(isOk4);
+
+        assertEquals(1, invokecallcount);
+    }
+
+
+    /**
+     * Test for handler03 and handler04
+     */
+    public void testSelfManagedData09()
+    {
+        System.out.println("MessageContextSelfManagedDataTest::testSelfManagedData09()=======================================");
+        try
+        {
+
+            ArrayList handlers = new ArrayList();
+            handlers.add(handler03);
+            handlers.add(handler04);
+            cfgContext.getAxisConfiguration().setInPhasesUptoAndIncludingPostDispatch(handlers);
+
+            mc.setTo(new EndpointReference("axis2/services/NullService")); 
+            mc.setWSAAction("DummyOp");
+
+            AxisEngine engine = new AxisEngine(cfgContext);
+            engine.receive(mc);
+
+        }
+        catch (Exception e)
+        {
+            e.printStackTrace();
+        }
+
+        boolean isOk3 = isEquals(testData03, (byte []) handler03.getTestDataFromMessageContext(mc) );
+        assertTrue(isOk3);
+
+        boolean isOk4 = isEquals(testData04, (long []) handler04.getTestDataFromMessageContext(mc) );
+        assertTrue(isOk4);
+
+        assertEquals(2, invokecallcount);
+    }
+
+    //-------------------------------------------------------------------------
+    // internal helper methods
+    //-------------------------------------------------------------------------
+
+    /**
+     * Saves the specified message context to a temporary
+     * file, then restores it.  
+     * 
+     * @param mc1       The message context object to save
+     * @param fnprefix  A prefix for the filename of the temporary file
+     * @param desc      Text that describes the caller's situation
+     * @return The restored message context object or NULL
+     */
+    private MessageContext saveAndRestore(MessageContext mc1, String fnprefix, String desc)
+    {
+        MessageContext msgContext2 = null;
+        String title = "MessageContextSelfManagedDataTest::saveAndRestore::["+desc+"]   ";
+        System.out.println(title);
+
+        try
+        {
+            theFile = File.createTempFile(fnprefix,null);
+            System.out.println(title + "temp file = ["+theFile.getName()+"]");
+        }
+        catch (Exception ex)
+        {
+            System.out.println(title + "error creating temp file = ["+ex.getMessage()+"]");
+            theFile = null;
+        }
+
+        if (theFile != null)
+        {
+            try
+            {
+                // setup an output stream to a physical file
+                FileOutputStream outStream = new FileOutputStream(theFile);
+
+                // attach a stream capable of writing objects to the 
+                // stream connected to the file
+                ObjectOutputStream outObjStream = new ObjectOutputStream(outStream);
+
+                // try to save the message context
+                System.out.println(title + "saving message context ....");
+                savedMessageContext = false;
+
+                outObjStream.writeObject(mc1);
+                outObjStream.close();
+                outStream.close();
+
+                // no exceptions, set savedMessageContext to true
+                savedMessageContext = true;
+
+                System.out.println(title + "....saved message context .....");
+
+                // setup an input stream to the file
+                FileInputStream inStream = new FileInputStream(theFile);
+
+                // attach a stream capable of reading objects from the 
+                // stream connected to the file
+                ObjectInputStream inObjStream = new ObjectInputStream(inStream);
+
+                // try to restore the message context
+                System.out.println(title + "restoring message context .....");
+                restoredMessageContext = false;
+                msgContext2 = (MessageContext) inObjStream.readObject();
+                inObjStream.close();
+                inStream.close();
+                msgContext2.activate(mc1.getConfigurationContext());
+
+                // no exceptions, set restoredMessageContext to true
+                restoredMessageContext = true;
+
+                // VERY IMPORTANT: replace testcase's messagecontext object with the new restored one
+                mc = msgContext2;
+
+                System.out.println(title + "....restored message context .....");
+
+            }
+            catch (Exception ex2)
+            {
+                if (savedMessageContext != true)
+                {
+                    System.out.println(title + "Error with saving message context = ["+ex2.getClass().getName()+" : "+ex2.getMessage()+"]");
+                    ex2.printStackTrace();
+                }
+                else
+                {
+                    System.out.println(title + "Error with restoring message context = ["+ex2.getClass().getName()+" : "+ex2.getMessage()+"]");
+                    ex2.printStackTrace();
+                }
+            }
+
+            // if the save/restore of the message context succeeded,
+            // then don't keep the temporary file around
+            boolean removeTmpFile = savedMessageContext && restoredMessageContext;
+            if (removeTmpFile)
+            {
+                try
+                {
+                    theFile.delete();
+                }
+                catch (Exception e)
+                {
+                    // just absorb it
+                }
+            }
+        }
+
+        return msgContext2;
+    }
+
+
+    /**
+     * Gets the ID associated with the handler object.
+     * 
+     * @param o      The handler object
+     * @return The ID associated with the handler,
+     *         -1 otherwise
+     */
+    private int getHandlerID(Object o)
+    {
+        int id = -1;
+
+        if (o instanceof TempHandler01)
+        {
+            id = ((TempHandler01)o).getID();
+        }
+        else if (o instanceof TempHandler02)
+        {
+            id = ((TempHandler02)o).getID();
+        }
+        else if (o instanceof TempHandler03)
+        {
+            id = ((TempHandler03)o).getID();
+        }
+        else if (o instanceof TempHandler04)
+        {
+            id = ((TempHandler04)o).getID();
+        }
+
+        return id;
+    }
+
+
+    /**
+     * Check the handler objects to see if they are equivalent.
+     * 
+     * @param o1     The first handler
+     * @param o2     The second handler
+     * @return TRUE if the handler objects are equivalent,
+     *         FALSE otherwise
+     */
+    private boolean compareHandlers(Object o1, Object o2)
+    {
+        if ((o1 == null) && (o2 == null))
+        {
+            return true;
+        }
+
+        if ((o1 != null) && (o2 != null))
+        {
+            String c1 = o1.getClass().getName();
+            String c2 = o2.getClass().getName();
+
+            if (c1.equals(c2))
+            {
+                System.out.println("MessagecontextSelfManagedDataTest::compareHandlers:  class ["+c1+"] match ");
+
+                int id1 = getHandlerID(o1);
+                int id2 = getHandlerID(o2);
+
+                if (id1 == id2)
+                {
+                    System.out.println("MessagecontextSelfManagedDataTest::compareHandlers:  id ["+id1+"] match");
+                    return true;
+                }
+                else
+                {
+                    System.out.println("MessagecontextSelfManagedDataTest::compareHandlers:  id1 ["+id1+"] != id2 ["+id2+"] ");
+                    return false;
+                }
+            }
+            else
+            {
+                System.out.println("MessagecontextSelfManagedDataTest::compareHandlers:  class1 ["+c1+"] != class2 ["+c2+"]   ");
+                return false;
+            }
+        }
+
+        return false;
+    }
+
+
+    /**
+     * Compare two phases.
+     * 
+     * @param o1     The first phase object
+     * @param o2     The second phase object
+     * @return TRUE if the phases are equivalent,
+     *         FALSE otherwise
+     */
+    private boolean comparePhases(Object o1, Object o2)
+    {
+        if ((o1 == null) && (o2 == null))
+        {
+            return true;
+        }
+
+        try
+        {
+            if (  ((o1 != null) && (o2 != null))
+               && ((o1 instanceof Phase) && (o2 instanceof Phase))
+               )
+            {
+                Phase p1 = (Phase) o1;
+                Phase p2 = (Phase) o2;
+
+                ArrayList list1 = p1.getHandlers();
+                ArrayList list2 = p2.getHandlers();
+
+                if ((list1 == null) && (list2 == null))
+                {
+                    return true;
+                }
+
+                if ((list1 != null) && (list2 != null))
+                {
+                    int size1 = list1.size();
+                    int size2 = list2.size();
+
+                    if (size1 != size2)
+                    {
+                        return false;
+                    }
+
+                    for (int j=0; j<size1; j++)
+                    {
+                        Object obj1 = list1.get(j);
+                        Object obj2 = list2.get(j);
+
+                        if ((obj1 == null) && (obj2 == null))
+                        {
+                            // ok
+                        }
+                        else if ((obj1 != null) && (obj2 != null))
+                        {
+                            boolean check = false;
+
+                            if (obj1 instanceof Phase)
+                            {
+                                check = comparePhases(obj1, obj2);
+                            }
+                            else
+                            {
+                                // must be a handler
+                                check = compareHandlers(obj1, obj2);
+                            }
+
+                            if (check == false)
+                            {
+                                return false;
+                            }
+                        }
+                        else
+                        {
+                            // mismatch
+                            return false;
+                        }
+                    }
+
+                    // if we got here, the comparison completed ok
+                    // with a match
+
+                    return true;
+                }
+
+            }
+        }
+        catch (Exception e)
+        {
+            // some error
+            e.printStackTrace();
+        }
+
+        return false;
+    }
+
+/*
+    private void comparePhases(Iterator it, ArrayList al)
+    {
+        int it_count = -1;
+
+        while (it.hasNext())
+        {
+            it_count++;
+            Handler handler = (Handler)it.next();
+            if (handler instanceof Phase)
+            {
+                comparePhases(((Phase)handler).getHandlers().iterator(), ((Phase)al.get(it_count)).getHandlers());
+            }
+            else
+            {
+                assertEquals(handler, (TempHandler02)al.get(it_count));
+            }
+        }
+    }
+
+*/
+
+    //-------------------------------------------------------------------------
+    // internal handlers
+    //-------------------------------------------------------------------------
+
+
+    /*
+     * TempHandler01 simply sets and/or removes data from the MessageContext
+     * object.
+     */
+    public class TempHandler01 extends AbstractHandler
+    {
+        private int id = -2;
+
+        public TempHandler01()
+        {
+            id = -1;
+        }
+
+        public TempHandler01(int id)
+        {
+            this.id = id;
+        }
+
+        public int getID()
+        {
+            return this.id;
+        }
+
+        public String getName()
+        {
+            return new String(Integer.toString(id));
+        }
+
+        public String getTestData01FromMessageContext(MessageContext _mc)
+        {
+            return(String)_mc.getSelfManagedData(this.getClass(), key01);
+        }
+
+        public String getTestData02FromMessageContext(MessageContext _mc)
+        {
+            return(String)_mc.getSelfManagedData(this.getClass(), key02);
+        }
+
+        public byte [] getTestData03FromMessageContext(MessageContext _mc)
+        {
+            return(byte [])_mc.getSelfManagedData(this.getClass(), key03);
+        }
+
+        public long [] getTestData04FromMessageContext(MessageContext _mc)
+        {
+            return(long [])_mc.getSelfManagedData(this.getClass(), key04);
+        }
+
+        /* we're just using the invoke to set/change/remove data
+         * Tests:
+         * for key01:  set, remove, set, get
+         * for key02:  set, get, set
+         * for key03:  set, remove, set, get
+         * for key04:  set, get, set, get
+         */
+        public InvocationResponse invoke(MessageContext _mc) throws AxisFault
+        {
+
+            String desc = "TempHandler01[id="+id+"].invoke()";
+            String title = "MessageContextSelfManagedDataTest::"+desc;
+            System.out.println(title);
+
+            String tmp = "whaaa?";
+            _mc.setSelfManagedData(this.getClass(), key02, tmp);
+            String data2 = (String)_mc.getSelfManagedData(this.getClass(), key02); 
+            assertEquals(tmp, data2);
+
+            _mc.setSelfManagedData(this.getClass(), key01, testData01);
+            _mc.removeSelfManagedData(this.getClass(), key01);
+            _mc.setSelfManagedData(this.getClass(), key01, testData01);
+            String data1 = (String)_mc.getSelfManagedData(this.getClass(), key01);
+            assertEquals(data1, testData01);
+
+            _mc.setSelfManagedData(this.getClass(), key02, testData02);
+
+            _mc.setSelfManagedData(this.getClass(), key03, testData03);
+            byte [] data3 = (byte []) _mc.getSelfManagedData(this.getClass(), key03);
+            boolean isOk3 = isEquals(data3, testData03);
+            assertTrue(isOk3);
+
+            _mc.removeSelfManagedData(this.getClass(), key03);
+            _mc.setSelfManagedData(this.getClass(), key03, testData03);
+
+            _mc.setSelfManagedData(this.getClass(), key04, testData04);
+            long [] data4 = (long []) _mc.getSelfManagedData(this.getClass(), key04);
+            boolean isOk4 = isEquals(data4, testData04);
+            assertTrue(isOk4);
+
+            invokecallcount++;
+
+            System.out.println(title+": Completed");
+            return InvocationResponse.CONTINUE;
+        }
+
+    }
+
+
+    /*
+     * TempHandler02 sets data, saves it (via the serializeSelfManagedData method
+     * called by the MessageContext object when saved in this handler's invoke()),
+     * 
+     */
+    public class TempHandler02 extends AbstractHandler implements SelfManagedDataManager
+    {
+        private int id = -2;
+        private int serializecallcount = 0;
+        private int deserializecallcount = 0;
+        public String testData = new String("this is some test data");
+
+        /*
+         * constructor
+         */
+        public TempHandler02()
+        {
+            this.id = -1;
+            this.serializecallcount = 0;
+            this.deserializecallcount = 0;
+        }
+
+        /*
+         * constructor
+         */
+        public TempHandler02(int id)
+        {
+            this.id = id;
+            this.serializecallcount = 0;
+            this.deserializecallcount = 0;
+        }
+
+        public int getID()
+        {
+            return this.id;
+        }
+
+        public String getName()
+        {
+            return new String(Integer.toString(id));
+        }
+
+        public String getTestDataFromMessageContext(MessageContext _mc)
+        {
+            return(String)_mc.getSelfManagedData(this.getClass(), Integer.toString(id));
+        }
+
+        /*
+         *  (non-Javadoc)
+         * @see org.apache.axis2.engine.Handler#invoke(org.apache.axis2.context.MessageContext)
+         * 
+         * This invoke() method will test several things:
+         * 1.  verify that serializeSelfManagedData is actually called when saving the MessageContext object
+         * 2.  verify that deserializeSelfManagedData is actually called when restoring the MessageContext object
+         * 3.  verify that any SelfManagedData stored in the MessageContext is properly saved/restored (via serializeSelfManagedData/deserializeSelfManagedData)
+         */
+        public InvocationResponse invoke(MessageContext _mc) throws AxisFault
+        {
+            String desc = "TempHandler02[id="+id+"].invoke()";
+            String title = "MessageContextSelfManagedDataTest::"+desc;
+            System.out.println(title);
+
+            MessageContext msgContext2 = null;  // this will be the restored one
+
+            _mc.setSelfManagedData(this.getClass(), Integer.toString(id), testData + Integer.toString(id));
+
+            System.out.println(title+":   Setting self managed data using key ["+Integer.toString(id)+"]");
+
+            msgContext2 = saveAndRestore(_mc, "TempHandler02_", desc);
+
+            boolean result = (msgContext2 != null);
+            assertTrue(result);
+
+            invokecallcount++;
+
+            System.out.println(title+": Completed");
+            return InvocationResponse.CONTINUE;
+        }
+
+
+        public void deserializeSelfManagedData(ByteArrayInputStream data, MessageContext _mc) throws IOException
+        {
+            deserializecallcount++;
+
+            String desc = "TempHandler02[id="+id+"].deserializeSelfManagedData()   count ["+deserializecallcount+"]";
+            String title = "MessageContextSelfManagedDataTest::"+desc;
+            System.out.println(title);
+
+            ObjectInputStream ois = new ObjectInputStream(data);
+            testData = ois.readUTF().concat(" with extra text " + Integer.toString(id));
+            _mc.setSelfManagedData(this.getClass(), Integer.toString(id), testData);
+        }
+
+
+        public void restoreTransientData(MessageContext _mc)
+        {
+            // not necessary to test
+        }
+
+
+        public ByteArrayOutputStream serializeSelfManagedData(MessageContext _mc) throws IOException 
+        {
+            serializecallcount++;
+
+            String desc = "TempHandler02[id="+id+"].serializeSelfManagedData()   count ["+serializecallcount+"]";
+            String title = "MessageContextSelfManagedDataTest::"+desc;
+            System.out.println(title);
+
+            String storedTestData = (String)_mc.getSelfManagedData(this.getClass(), Integer.toString(id));
+            if (storedTestData == null)
+            {
+                System.out.println(title+":  No self managed data to serialize");
+                return null;
+            }
+
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            ObjectOutputStream oos = new ObjectOutputStream(baos);
+            oos.writeUTF(storedTestData);
+            oos.close();
+            int baos_size = baos.size();
+            baos.close();
+
+            System.out.println(title+": saved self managed data string length ["+storedTestData.length()+"]");
+            System.out.println(title+": saved self managed data byte array output stream (UTF) length ["+baos_size+"]");
+            return baos;
+        }
+
+        public int getDeserializecallcount()
+        {
+            return deserializecallcount;
+        }
+
+        public int getSerializecallcount()
+        {
+            return serializecallcount;
+        }
+    }
+
+
+    /*
+     * TempHandler03 sets binary data, saves it (via the serializeSelfManagedData method
+     * called by the MessageContext object when saved in this handler's invoke()),
+     * 
+     */
+    public class TempHandler03 extends AbstractHandler implements SelfManagedDataManager
+    {
+        private int id = -2;
+        private int serializecallcount = 0;
+        private int deserializecallcount = 0;
+
+        public TempHandler03()
+        {
+            id = -1;
+        }
+
+        public TempHandler03(int id)
+        {
+            this.id = id;
+        }
+
+        public int getID()
+        {
+            return this.id;
+        }
+
+        public String getName()
+        {
+            return new String(Integer.toString(id));
+        }
+
+        public Object getTestDataFromMessageContext(MessageContext _mc)
+        {
+            return _mc.getSelfManagedData(this.getClass(), Integer.toString(id));
+        }
+
+        /*
+         *  (non-Javadoc)
+         * @see org.apache.axis2.engine.Handler#invoke(org.apache.axis2.context.MessageContext)
+         * 
+         * This invoke() method will test several things:
+         * 1.  verify that serializeSelfManagedData is actually called when saving the MessageContext object
+         * 2.  verify that deserializeSelfManagedData is actually called when restoring the MessageContext object
+         * 3.  verify that any SelfManagedData stored in the MessageContext is properly saved/restored (via serializeSelfManagedData/deserializeSelfManagedData)
+         */
+        public InvocationResponse invoke(MessageContext _mc) throws AxisFault {
+
+            String desc = "TempHandler03[id="+id+"].invoke()";
+            String title = "MessageContextSelfManagedDataTest::"+desc;
+            System.out.println(title);
+
+            MessageContext msgContext2 = null;  // this will be the restored one
+
+            // add the byte [] of data
+            _mc.setSelfManagedData(this.getClass(), Integer.toString(id), testData03);
+
+            System.out.println(title+":   Setting self managed data using key ["+Integer.toString(id)+"]");
+
+            msgContext2 = saveAndRestore(_mc, "TempHandler03_", desc);
+
+            boolean result = (msgContext2 != null);
+            assertTrue(result);
+
+            invokecallcount++;
+
+            System.out.println(title+": Completed");
+            return InvocationResponse.CONTINUE;
+        }
+
+        public void deserializeSelfManagedData(ByteArrayInputStream data, MessageContext _mc) throws IOException
+        {
+            boolean isOK = true;
+
+            deserializecallcount++;
+
+            String desc = "TempHandler03[id="+id+"].deserializeSelfManagedData()   count ["+deserializecallcount+"]";
+            String title = "MessageContextSelfManagedDataTest::"+desc;
+            System.out.println(title);
+
+            int expected = testData03.length;
+
+            byte [] tmp = new byte [expected];
+
+            boolean keepGoing = true;
+            int index = 0;
+
+            while (keepGoing)
+            {
+                int tmpdata = data.read();
+
+                if (tmpdata != -1)
+                {
+                    Integer value = new Integer(tmpdata);
+                    tmp[index] = value.byteValue();
+                    index++;
+
+                    if (index > expected)
+                    {
+                        isOK = false;
+                        assertTrue(isOK);
+                    }
+                }
+                else
+                {
+                    keepGoing = false;
+                }
+            }
+
+            isOK = isEquals(tmp, testData03);
+            assertTrue(isOK);
+
+            _mc.setSelfManagedData(this.getClass(), Integer.toString(id), tmp);
+        }
+
+        public void restoreTransientData(MessageContext _mc)
+        {
+            // not necessary to test
+        }
+
+        public ByteArrayOutputStream serializeSelfManagedData(MessageContext _mc) throws IOException {
+
+            serializecallcount++;
+
+            String desc = "TempHandler03[id="+id+"].serializeSelfManagedData()   count ["+serializecallcount+"]";
+            String title = "MessageContextSelfManagedDataTest::"+desc;
+            System.out.println(title);
+
+            byte [] tmp = (byte []) _mc.getSelfManagedData(this.getClass(), Integer.toString(id)); 
+
+            if (tmp == null)
+            {
+                System.out.println(title+":  No self managed data to serialize");
+                return null;
+            }
+
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            baos.write(tmp, 0, tmp.length);
+            int baos_size = baos.size();
+            baos.close();
+
+            System.out.println(title+": saved self managed data byte [] length ["+tmp.length+"]");
+            System.out.println(title+": saved self managed data byte array output stream length ["+baos_size+"]");
+            return baos;
+        }
+
+
+        public int getDeserializecallcout()
+        {
+            return deserializecallcount;
+        }
+
+        public int getSerializecallcount()
+        {
+            return serializecallcount;
+        }
+    }
+
+
+    /*
+     * TempHandler04 sets binary data, saves it (via the serializeSelfManagedData method
+     * called by the MessageContext object when saved in this handler's invoke()),
+     * 
+     */
+    public class TempHandler04 extends AbstractHandler implements SelfManagedDataManager
+    {
+        private int id = -2;
+        private int serializecallcount = 0;
+        private int deserializecallcount = 0;
+
+
+        public TempHandler04()
+        {
+            id = -1;
+        }
+
+        public TempHandler04(int id)
+        {
+            this.id = id;
+        }
+
+        public int getID()
+        {
+            return this.id;
+        }
+
+        public String getName()
+        {
+            return new String(Integer.toString(id));
+        }
+
+        public Object getTestDataFromMessageContext(MessageContext _mc)
+        {
+            return _mc.getSelfManagedData(this.getClass(), Integer.toString(id));
+        }
+
+        /*
+         *  (non-Javadoc)
+         * @see org.apache.axis2.engine.Handler#invoke(org.apache.axis2.context.MessageContext)
+         * 
+         * This invoke() method will test several things:
+         * 1.  verify that serializeSelfManagedData is actually called when saving the MessageContext object
+         * 2.  verify that deserializeSelfManagedData is actually called when restoring the MessageContext object
+         * 3.  verify that any SelfManagedData stored in the MessageContext is properly saved/restored (via serializeSelfManagedData/deserializeSelfManagedData)
+         */
+        public InvocationResponse invoke(MessageContext _mc) throws AxisFault {
+
+            String desc = "TempHandler04[id="+id+"].invoke()";
+            String title = "MessageContextSelfManagedDataTest::"+desc;
+            System.out.println(title);
+
+            MessageContext msgContext2 = null;  // this will be the restored one
+
+            // add the byte [] of data
+            _mc.setSelfManagedData(this.getClass(), Integer.toString(id), testData04);
+
+            System.out.println(title+":   Setting self managed data using key ["+Integer.toString(id)+"]");
+
+            msgContext2 = saveAndRestore(_mc, "TempHandler04_", desc);
+
+            boolean result = (msgContext2 != null);
+            assertTrue(result);
+
+            invokecallcount++;
+
+            System.out.println(title+": Completed");
+            return InvocationResponse.CONTINUE;
+        }
+
+        public void deserializeSelfManagedData(ByteArrayInputStream data, MessageContext _mc) throws IOException
+        {
+            boolean isOK = true;
+
+            deserializecallcount++;
+
+            String desc = "TempHandler04[id="+id+"].deserializeSelfManagedData()   count ["+deserializecallcount+"]";
+            String title = "MessageContextSelfManagedDataTest::"+desc;
+            System.out.println(title);
+
+            int expected = testData04.length;
+
+            long [] tmp = new long [expected];
+
+            ObjectInputStream ois = new ObjectInputStream(data);
+
+            boolean keepGoing = true;
+            int index = 0;
+
+            int sizeWritten = ois.readInt();
+
+            if (sizeWritten > 0)
+            {
+                while (keepGoing)
+                {
+                    try
+                    {
+                        long tmpdata = ois.readLong();
+
+                        tmp[index] = tmpdata;
+                        index++;
+
+                        if (index > expected)
+                        {
+                            isOK = false;
+                            assertTrue(isOK);
+                        }
+                    }
+                    catch (Exception exc)
+                    {
+                        keepGoing = false;
+                    }
+                }
+
+                isOK = isEquals(tmp, testData04);
+                assertTrue(isOK);
+
+                _mc.setSelfManagedData(this.getClass(), Integer.toString(id), tmp);
+            }
+
+        }
+
+        public void restoreTransientData(MessageContext _mc)
+        {
+            // not necessary to test
+        }
+
+        public ByteArrayOutputStream serializeSelfManagedData(MessageContext _mc) throws IOException {
+
+            serializecallcount++;
+
+            String desc = "TempHandler04[id="+id+"].serializeSelfManagedData()   count ["+serializecallcount+"]";
+            String title = "MessageContextSelfManagedDataTest::"+desc;
+            System.out.println(title);
+
+            long [] tmp = (long []) _mc.getSelfManagedData(this.getClass(), Integer.toString(id)); 
+
+            if (tmp == null)
+            {
+                System.out.println(title+":  No self managed data to serialize");
+                return null;
+            }
+
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            ObjectOutputStream    oos  = new ObjectOutputStream(baos);
+
+            int size = tmp.length;
+
+            oos.writeInt(size);
+
+            for (int i=0; i<size; i++)
+            {
+                oos.writeLong(tmp[i]);
+            }
+
+            oos.close();
+            int baos_size = baos.size();
+            baos.close();
+
+            System.out.println(title+": saved self managed data byte [] length ["+tmp.length+"]");
+            System.out.println(title+": saved self managed data byte array output stream length ["+baos_size+"]");
+            return baos;
+        }
+
+
+        public int getDeserializecallcount()
+        {
+            return deserializecallcount;
+        }
+
+        public int getSerializecallcount()
+        {
+            return serializecallcount;
+        }
+    }
+
+
+    /*
+     * compares the two byte arrays to see if they are equal
+     */
+    private boolean isEquals(byte [] b1, byte [] b2)
+    {
+        int size1 = b1.length;
+        int size2 = b2.length;
+
+        if (size1 != size2)
+        {
+            return false;
+        }
+
+        for (int i=0; i<size1; i++)
+        {
+            if (b1[i] != b2[i])
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    /*
+     * compares the two long arrays to see if they are equal
+     */
+    private boolean isEquals(long [] L1, long [] L2)
+    {
+        int size1 = L1.length;
+        int size2 = L2.length;
+
+        if (size1 != size2)
+        {
+            return false;
+        }
+
+        for (int i=0; i<size1; i++)
+        {
+            if (L1[i] != L2[i])
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+
+}
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/OutInAxisOperation.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/OutInAxisOperation.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/OutInAxisOperation.java	(working copy)
@@ -42,8 +42,12 @@
 import java.util.Map;
 
 public class OutInAxisOperation extends InOutAxisOperation {
+
     public OutInAxisOperation() {
         super();
+        //setup a temporary name
+        QName tmpName = new QName(this.getClass().getName()+"_"+UUIDGenerator.getUUID());
+        this.setName(tmpName);
         setMessageExchangePattern(WSDL20_2004Constants.MEP_URI_OUT_IN);
     }
 
@@ -325,9 +329,11 @@
     }
 
     /**
+     * Sends the message using a two way transport and waits for a response
+     *
      * @param msgctx
      * @return Returns MessageContext.
-     * @throws AxisFault Sends the message using a two way transport and waits for a response
+     * @throws AxisFault
      */
     protected MessageContext send(MessageContext msgctx) throws AxisFault {
 
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/Parameter.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/Parameter.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/Parameter.java	(working copy)
@@ -16,13 +16,64 @@
 package org.apache.axis2.description;
 
 import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.axiom.om.impl.builder.StAXOMBuilder;
+import org.apache.axis2.util.ObjectStateUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 
+import java.io.ByteArrayInputStream;
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutput;
+import java.io.ObjectOutputStream;
+
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+import java.io.InputStream;
+
+
 /**
- * Class ParameterImpl
+ * Class Parameter
  */
-public class Parameter {
+public class Parameter implements Externalizable {
 
+    /*
+     * setup for logging
+     */
+    private static final Log log = LogFactory.getLog(Parameter.class);
+
+    private static final String myClassName = "Parameter";
+
     /**
+     * @serial The serialization version ID tracks the version of the class.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. If a change to the class is made which is
+     * not compatible with the serialization/externalization of the class,
+     * then the serialization version ID should be updated.
+     * Refer to the "serialVer" utility to compute a serialization
+     * version ID.
+     */
+    private static final long serialVersionUID = -6601664200673063531L;
+
+    /**
+     * @serial Tracks the revision level of a class to identify changes to the 
+     * class definition that are compatible to serialization/externalization.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. 
+     * Refer to the writeExternal() and readExternal() methods.
+     */
+    // supported revision levels, add a new level to manage compatible changes
+    private static final int REVISION_1 = 1;
+    // current revision level of this object
+    private static final int revisionID = REVISION_1;
+
+
+
+    /**
      * Field TEXT_PARAMETER
      */
     public static int TEXT_PARAMETER = 0;
@@ -168,4 +219,186 @@
     public int hashCode() {
         return name.hashCode();
     }
+
+
+    /* ===============================================================
+     * Externalizable support 
+     * ===============================================================
+     */
+    
+
+    /**
+     * Save the contents of this object.
+     * <p>
+     * NOTE: Transient fields and static fields are not saved.
+     *       Also, objects that represent "static" data are
+     *       not saved, except for enough information to be
+     *       able to find matching objects when the message
+     *       context is re-constituted.
+     *
+     * @param out    The stream to write the object contents to
+     * 
+     * @exception IOException
+     */
+    public void writeExternal(ObjectOutput out) throws IOException
+    {
+        // write out contents of this object
+
+        //---------------------------------------------------------
+        // in order to handle future changes to the message 
+        // context definition, be sure to maintain the 
+        // object level identifiers
+        //---------------------------------------------------------
+        // serialization version ID
+        out.writeLong(serialVersionUID);
+
+        // revision ID
+        out.writeInt(revisionID);
+
+        //---------------------------------------------------------
+        // simple fields
+        //---------------------------------------------------------
+
+        out.writeInt(type);
+        out.writeBoolean(locked);
+
+        ObjectStateUtils.writeString(out, name, "Parameter.name");
+
+
+        //---------------------------------------------------------
+        // object fields
+        //---------------------------------------------------------
+
+        // TODO: investigate serializing the OMElement more efficiently
+        // This currently will basically serialize the given OMElement
+        // to a String but will build the OMTree in the memory
+
+        String tmp = null;
+
+        if (parameterElement != null)
+        {
+            tmp = parameterElement.toString();
+        }
+
+        // treat as an object, don't do UTF
+        ObjectStateUtils.writeObject(out, tmp, "Parameter.parameterElement");
+
+
+        // TODO: error handling if this can't be serialized
+        ObjectStateUtils.writeObject(out, value, "Parameter.value");
+
+    }
+
+
+    /**
+     * Restore the contents of the object that was previously saved.
+     * <p> 
+     * NOTE: The field data must read back in the same order and type
+     * as it was written.  Some data will need to be validated when 
+     * resurrected.
+     *
+     * @param in    The stream to read the object contents from 
+     * 
+     * @exception IOException
+     * @exception ClassNotFoundException
+     */
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
+    {
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal():  BEGIN  bytes available in stream ["+in.available()+"]  ");
+        }
+        //System.out.println(myClassName+":readExternal():  BEGIN  bytes available in stream ["+in.available()+"]  ");
+
+
+        // serialization version ID
+        long suid = in.readLong();
+
+        // revision ID
+        int  revID = in.readInt();
+
+        // make sure the object data is in a version we can handle
+        if (suid != serialVersionUID)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+        }
+
+        // make sure the object data is in a revision level we can handle
+        if (revID != REVISION_1)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        }
+
+        //---------------------------------------------------------
+        // simple fields
+        //---------------------------------------------------------
+
+        type = in.readInt();
+        locked = in.readBoolean();
+
+        name = ObjectStateUtils.readString(in, "Parameter.name");
+
+
+        //---------------------------------------------------------
+        // object fields
+        //---------------------------------------------------------
+
+        // TODO: investigate serializing the OMElement more efficiently
+        // This currently will basically serialize the given OMElement
+        // to a String but will build the OMTree in the memory
+
+        // treat as an object, don't do UTF
+        String tmp = (String) ObjectStateUtils.readObject(in, "Parameter.parameterElement");
+
+        // convert to an OMElement
+        if (tmp != null)
+        {
+            try
+            {
+                ByteArrayInputStream bais = new ByteArrayInputStream(tmp.getBytes());
+
+                XMLStreamReader parser = XMLInputFactory.newInstance().createXMLStreamReader(bais);
+
+                // TODO: the StAXOMBuilder is an impl class - is there a better mechanism rather than an impl class ?
+                StAXOMBuilder builder = new StAXOMBuilder(OMAbstractFactory.getOMFactory(), parser);  
+
+                OMElement docElement = builder.getDocumentElement();
+
+                if (docElement != null)
+                {
+                    parameterElement = docElement;
+                }
+                else
+                {
+                    // TODO: error handling if can't create an OMElement
+                    parameterElement = null;
+                }
+            }
+            catch (Exception exc)
+            {
+                // TODO: error handling if can't create an OMElement
+                parameterElement = null;
+            }
+        }
+        else
+        {
+            parameterElement = null;
+        }
+
+        // TODO: error handling if this can't be serialized
+        value = ObjectStateUtils.readObject(in, "Parameter.value");
+
+        //---------------------------------------------------------
+        // done
+        //---------------------------------------------------------
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal():  END");
+        }
+        //System.out.println(myClassName+":readExternal():  END");
+
+    }
 }
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/AxisOperation.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/AxisOperation.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/AxisOperation.java	(working copy)
@@ -29,34 +29,51 @@
 import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.modules.Module;
 import org.apache.axis2.phaseresolver.PhaseResolver;
+import org.apache.axis2.util.UUIDGenerator;
 import org.apache.axis2.wsdl.WSDLConstants;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import javax.xml.namespace.QName;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Set;
 
 public abstract class AxisOperation extends AxisDescription
         implements WSDLConstants {
+
     public static final String STYLE_RPC = "rpc";
     public static final String STYLE_MSG = "msg";
     public static final String STYLE_DOC = "doc";
+
     private static final Log log = LogFactory.getLog(AxisOperation.class);
+
+
+    /**
+     * message exchange pattern
+     */
     private int mep = WSDL20_2004Constants.MEP_CONSTANT_INVALID;
 
     public static final String SOAP_ACTION = "soapaction";
 
 
-    // to store engaged modules
+    /**
+     * list of engaged modules
+     */
     private ArrayList engagedModules = new ArrayList();
 
     // to hide control operation , operation which added by RM like module
     private boolean controlOperation = false;
+
     private String style = STYLE_DOC;
 
     // to store mepURL
     private String mepURI;
+
     private MessageReceiver messageReceiver;
+
     private HashMap moduleConfigmap;
 
     // To store deploy-time module refs
@@ -72,11 +89,18 @@
 
     private String soapAction;
 
+
+    /**
+     * constructor
+     */
     public AxisOperation() {
         mepURI = WSDL20_2004Constants.MEP_URI_IN_OUT;
         modulerefs = new ArrayList();
         moduleConfigmap = new HashMap();
         faultMessages = new ArrayList();
+        //setup a temporary name
+        QName tmpName = new QName(this.getClass().getName()+"_"+UUIDGenerator.getUUID());
+        this.setName(tmpName);
     }
 
     public AxisOperation(QName name) {
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/AxisService.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/AxisService.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/AxisService.java	(working copy)
@@ -103,7 +103,7 @@
     //to store default message receivers
     private HashMap messageReceivers;
 
-// to set the handler chain available in phase info
+    // to set the handler chain available in phase info
     private boolean useDefaultChains = true;
 
     //to keep the status of the service , since service can stop at the run time
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/PhaseRule.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/PhaseRule.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/PhaseRule.java	(working copy)
@@ -17,10 +17,12 @@
 
 package org.apache.axis2.description;
 
+import java.io.Serializable;
+
 /**
  * Class PhaseRule
  */
-public class PhaseRule {
+public class PhaseRule implements Serializable {
 
     /**
      * Field after
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/AxisServiceGroup.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/AxisServiceGroup.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/AxisServiceGroup.java	(working copy)
@@ -84,6 +84,15 @@
     }
 
     public void addService(AxisService service) throws AxisFault {
+        if (service == null) {
+            return;
+        }
+
+        if (serviceGroupName == null) {
+            // setup a temporary name based on the first service under this group
+            serviceGroupName = new String(service.getName());
+        }
+
         service.setParent(this);
 
         AxisConfiguration axisConfig = (AxisConfiguration) getParent();
@@ -183,6 +192,9 @@
     }
 
     public String getServiceGroupName() {
+        // Note: if the serviceGroupName is not set, then this could be null.
+        // If the serviceGroupName has not been set and a service is added to this group, 
+        // then the serviceGroupName will default to the name of the first service
         return serviceGroupName;
     }
 
@@ -204,6 +216,9 @@
     }
 
     public Object getKey() {
+        // Note: if the serviceGroupName is not set, then this could be null.
+        // If the serviceGroupName has not been set and a service is added to this group, 
+        // then the serviceGroupName will default to the name of the first service
         return this.serviceGroupName;
     }
 
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/InOutAxisOperation.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/InOutAxisOperation.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/InOutAxisOperation.java	(working copy)
@@ -20,12 +20,14 @@
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.context.OperationContext;
 import org.apache.axis2.i18n.Messages;
+import org.apache.axis2.util.UUIDGenerator;
 
 import javax.xml.namespace.QName;
 import java.util.ArrayList;
 import java.util.HashMap;
 
 public class InOutAxisOperation extends AxisOperation {
+
     private AxisMessage inFaultMessage;
 //    private AxisMessage inMessage;
     private AxisMessage outFaultMessage;
@@ -33,6 +35,9 @@
 
     public InOutAxisOperation() {
         super();
+        //setup a temporary name
+        QName tmpName = new QName(this.getClass().getName()+"_"+UUIDGenerator.getUUID());
+        this.setName(tmpName);
         createMessages();
     }
 
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/ParameterIncludeImpl.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/ParameterIncludeImpl.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/ParameterIncludeImpl.java	(working copy)
@@ -21,8 +21,17 @@
 import org.apache.axiom.om.OMElement;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.deployment.DeploymentConstants;
+import org.apache.axis2.util.ObjectStateUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 
 import javax.xml.namespace.QName;
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutput;
+import java.io.ObjectOutputStream;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -31,9 +40,40 @@
 /**
  * Class ParameterIncludeImpl
  */
-public class ParameterIncludeImpl implements ParameterInclude {
+public class ParameterIncludeImpl implements ParameterInclude, Externalizable {
 
+    /*
+     * setup for logging
+     */
+    private static final Log log = LogFactory.getLog(ParameterIncludeImpl.class);
+
+    private static final String myClassName = "ParameterIncludeImpl";
+
     /**
+     * @serial The serialization version ID tracks the version of the class.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. If a change to the class is made which is
+     * not compatible with the serialization/externalization of the class,
+     * then the serialization version ID should be updated.
+     * Refer to the "serialVer" utility to compute a serialization
+     * version ID.
+     */
+    private static final long serialVersionUID = 8153736719090126891L;
+
+    /**
+     * @serial Tracks the revision level of a class to identify changes to the 
+     * class definition that are compatible to serialization/externalization.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. 
+     * Refer to the writeExternal() and readExternal() methods.
+     */
+    // supported revision levels, add a new level to manage compatible changes
+    private static final int REVISION_1 = 1;
+    // current revision level of this object
+    private static final int revisionID = REVISION_1;
+
+
+    /**
      * Field parmeters
      */
     protected final HashMap parameters;
@@ -144,4 +184,122 @@
     public boolean isParameterLocked(String parameterName) {
         return false;
     }
+
+    /* ===============================================================
+     * Externalizable support 
+     * ===============================================================
+     */
+    
+
+    /**
+     * Save the contents of this object.
+     * <p>
+     * NOTE: Transient fields and static fields are not saved.
+     *       Also, objects that represent "static" data are
+     *       not saved, except for enough information to be
+     *       able to find matching objects when the message
+     *       context is re-constituted.
+     *
+     * @param out    The stream to write the object contents to
+     * 
+     * @exception IOException
+     */
+    public void writeExternal(ObjectOutput out) throws IOException
+    {
+        // write out contents of this object
+
+        //---------------------------------------------------------
+        // in order to handle future changes to the message 
+        // context definition, be sure to maintain the 
+        // object level identifiers
+        //---------------------------------------------------------
+        // serialization version ID
+        out.writeLong(serialVersionUID);
+
+        // revision ID
+        out.writeInt(revisionID);
+
+        //---------------------------------------------------------
+        // collection of parameters
+        //---------------------------------------------------------
+        ObjectStateUtils.writeHashMap(out, parameters, "ParameterIncludeImpl.parameters");
+
+    }
+
+
+    /**
+     * Restore the contents of the object that was previously saved.
+     * <p> 
+     * NOTE: The field data must read back in the same order and type
+     * as it was written.  Some data will need to be validated when 
+     * resurrected.
+     *
+     * @param in    The stream to read the object contents from 
+     * 
+     * @exception IOException
+     * @exception ClassNotFoundException
+     */
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
+    {
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal():  BEGIN  bytes available in stream ["+in.available()+"]  ");
+        }
+        //System.out.println(myClassName+":readExternal():  BEGIN  bytes available in stream ["+in.available()+"]  ");
+
+
+        // serialization version ID
+        long suid = in.readLong();
+
+        // revision ID
+        int  revID = in.readInt();
+
+        // make sure the object data is in a version we can handle
+        if (suid != serialVersionUID)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+        }
+
+        // make sure the object data is in a revision level we can handle
+        if (revID != REVISION_1)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        }
+
+        //---------------------------------------------------------
+        // collection of parameters
+        //---------------------------------------------------------
+
+        HashMap tmp = ObjectStateUtils.readHashMap(in, "ParameterIncludeImpl.parameters");
+
+        if (tmp != null)
+        {
+            if (parameters != null)
+            {
+                parameters.putAll(tmp);
+            }
+            else
+            {
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":readExternal():  WARNING: parameters doesnot have a defined HashMap ");
+                }
+                //System.out.println(myClassName+":readExternal():  WARNING: parameters doesnot have a defined HashMap ");
+            }
+        }
+
+        //---------------------------------------------------------
+        // done
+        //---------------------------------------------------------
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal():  END");
+        }
+        //System.out.println(myClassName+":readExternal():  END");
+
+    }
+
 }
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/RobustOutOnlyAxisOperation.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/RobustOutOnlyAxisOperation.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/RobustOutOnlyAxisOperation.java	(working copy)
@@ -25,14 +25,19 @@
 import org.apache.axis2.context.ServiceContext;
 import org.apache.axis2.engine.AxisEngine;
 import org.apache.axis2.transport.TransportUtils;
+import org.apache.axis2.util.UUIDGenerator;
 import org.apache.axis2.wsdl.WSDLConstants;
 
 import javax.xml.namespace.QName;
 import java.io.InputStream;
 
 public class RobustOutOnlyAxisOperation extends OutInAxisOperation {
+
     public RobustOutOnlyAxisOperation() {
         super();
+        //setup a temporary name
+        QName tmpName = new QName(this.getClass().getName()+"_"+UUIDGenerator.getUUID());
+        this.setName(tmpName);
         setMessageExchangePattern(WSDL20_2004Constants.MEP_URI_ROBUST_OUT_ONLY);
     }
 
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/InOnlyAxisOperation.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/InOnlyAxisOperation.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/InOnlyAxisOperation.java	(working copy)
@@ -20,11 +20,14 @@
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.context.OperationContext;
 import org.apache.axis2.i18n.Messages;
+import org.apache.axis2.util.UUIDGenerator;
 
 import javax.xml.namespace.QName;
 import java.util.ArrayList;
 import java.util.HashMap;
+
 public class InOnlyAxisOperation extends AxisOperation {
+
     private AxisMessage inFaultMessage;
 //    private AxisMessage inMessage;
     private AxisMessage outFaultMessage;
@@ -34,6 +37,9 @@
 
     public InOnlyAxisOperation() {
         super();
+        //setup a temporary name
+        QName tmpName = new QName(this.getClass().getName()+"_"+UUIDGenerator.getUUID());
+        this.setName(tmpName);
         createMessage();
         setMessageExchangePattern(WSDL20_2004Constants.MEP_URI_IN_ONLY);
     }
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/OutOnlyAxisOperation.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/OutOnlyAxisOperation.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/description/OutOnlyAxisOperation.java	(working copy)
@@ -49,6 +49,9 @@
 
     public OutOnlyAxisOperation() {
         super();
+        //setup a temporary name
+        QName tmpName = new QName(this.getClass().getName()+"_"+UUIDGenerator.getUUID());
+        this.setName(tmpName);
         createMessage();
         setMessageExchangePattern(WSDL20_2004Constants.MEP_URI_OUT_ONLY);
     }
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/addressing/EndpointReference.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/addressing/EndpointReference.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/addressing/EndpointReference.java	(working copy)
@@ -367,4 +367,148 @@
     }
 
 
+    /**
+     * Compares key parts of the state from the current instance of 
+     * this class with the specified instance to see if they are 
+     * equivalent. 
+     * <P>
+     * This differs from the java.lang.Object.equals() method in
+     * that the equals() method generally looks at both the 
+     * object identity (location in memory) and the object state
+     * (data).
+     * <P>
+     * 
+     * @param epr  The object to compare with
+     * @return TRUE if this object is equivalent with the specified object
+     *              that is, key fields match
+     *         FALSE, otherwise
+     */
+    public boolean isEquivalent(EndpointReference epr)
+    {
+        // NOTE: the input object is expected to exist (ie, be non-null)
+
+        if ((this.name != null) && (epr.getName() != null)) 
+        {
+            if (!this.name.equals(epr.getName()))
+            {
+                return false;
+            }
+        }
+        else if ((this.name == null) && (epr.getName() == null)) 
+        {
+            // continue
+        }
+        else
+        {
+            // mismatch
+            return false;
+        }
+
+
+        if ((this.address != null) && (epr.getAddress() != null))
+        {
+            if (!this.address.equals(epr.getAddress()))
+            {
+                return false;
+            }
+        }
+        else if ((this.address == null) && (epr.getAddress() == null))
+        {
+            // continue
+        }
+        else
+        {
+            // mismatch
+            return false;
+        }
+
+
+        // TODO: is a strict test ok to use? 
+
+        ArrayList eprMetaData = epr.getMetaData();
+
+        if ( (this.metaData != null) && (eprMetaData != null) )
+        {
+            if (!this.metaData.equals(eprMetaData))
+            {
+                // This is a strict test
+                // Returns true if and only if the specified object 
+                // is also a list, both lists have the same size, and 
+                // all corresponding pairs of elements in the two lists
+                // are equal, ie, two lists are defined to be equal if 
+                // they contain the same elements in the same order.
+
+                return false;
+            }
+        }
+        else if ((this.metaData == null) && (eprMetaData == null))
+        {
+            // keep going
+        }
+        else
+        {
+            // one of the lists is null
+            return false;
+        }
+
+
+
+        ArrayList eprExtensibleElements = epr.getExtensibleElements();
+
+        if ( (this.extensibleElements != null) && (eprExtensibleElements != null) )
+        {
+            if (!this.extensibleElements.equals(eprExtensibleElements))
+            {
+                // This is a strict test
+                // Returns true if and only if the specified object 
+                // is also a list, both lists have the same size, and 
+                // all corresponding pairs of elements in the two lists
+                // are equal, ie, two lists are defined to be equal if 
+                // they contain the same elements in the same order.
+
+                return false;
+            }
+        }
+        else if ((this.extensibleElements == null) && (eprExtensibleElements == null))
+        {
+            // keep going
+        }
+        else
+        {
+            // one of the lists is null
+            return false;
+        }
+
+
+
+        ArrayList eprAttributes = epr.getAttributes();
+
+        if ( (this.attributes != null) && (eprAttributes != null) )
+        {
+            if (!this.attributes.equals(eprAttributes))
+            {
+                // This is a strict test
+                // Returns true if and only if the specified object 
+                // is also a list, both lists have the same size, and 
+                // all corresponding pairs of elements in the two lists
+                // are equal, ie, two lists are defined to be equal if 
+                // they contain the same elements in the same order.
+
+                return false;
+            }
+        }
+        else if ((this.attributes == null) && (eprAttributes == null))
+        {
+            // keep going
+        }
+        else
+        {
+            // one of the lists is null
+            return false;
+        }
+
+        // TODO: check the Map referenceParameters for equivalency
+
+        return true;
+    }
 }
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/ServiceGroupContext.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/ServiceGroupContext.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/ServiceGroupContext.java	(working copy)
@@ -20,18 +20,91 @@
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.AxisServiceGroup;
+import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.axis2.i18n.Messages;
+import org.apache.axis2.util.ObjectStateUtils;
+import org.apache.axis2.util.MetaDataEntry;
+import org.apache.axis2.util.UUIDGenerator;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutput;
+import java.io.ObjectOutputStream;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.HashMap;
 import java.util.Map;
 
-public class ServiceGroupContext extends AbstractContext {
+public class ServiceGroupContext extends AbstractContext implements Externalizable {
 
+    /*
+     * setup for logging
+     */
+    private static final Log log = LogFactory.getLog(ServiceGroupContext.class);
+
+    private static final String myClassName = "ServiceGroupContext";
+
+    /**
+     * @serial The serialization version ID tracks the version of the class.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. If a change to the class is made which is
+     * not compatible with the serialization/externalization of the class,
+     * then the serialization version ID should be updated.
+     * Refer to the "serialVer" utility to compute a serialization
+     * version ID.
+     */
+    private static final long serialVersionUID = 9014471144479928885L;
+
+    /**
+     * @serial Tracks the revision level of a class to identify changes to the 
+     * class definition that are compatible to serialization/externalization.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. 
+     * Refer to the writeExternal() and readExternal() methods.
+     */
+    // supported revision levels, add a new level to manage compatible changes
+    private static final int REVISION_1 = 1;
+    // current revision level of this object
+    private static final int revisionID = REVISION_1;
+
+
     private transient AxisServiceGroup axisServiceGroup;
     private String id;
     private Map serviceContextMap;
 
+    //----------------------------------------------------------------
+    // MetaData for data to be restored in activate after readExternal
+    //----------------------------------------------------------------
+    
+    /**
+     * Indicates whether the message context has been reconstituted
+     * and needs to have its object references reconciled
+     */
+    private transient boolean needsToBeReconciled = false;
+
+
+    /**
+     * The AxisServiceContext metadata will be used during
+     * activate to match up with an existing object
+     */
+    private transient MetaDataEntry metaAxisServiceGroup = null;
+    
+
+    //----------------------------------------------------------------
+    // end MetaData section
+    //----------------------------------------------------------------
+
+    // simple constructor
+    public ServiceGroupContext() {
+        super(null);
+        serviceContextMap = new HashMap();
+    }
+
+
     public ServiceGroupContext(ConfigurationContext parent, AxisServiceGroup axisServiceGroup) {
         super(parent);
         this.axisServiceGroup = axisServiceGroup;
@@ -39,6 +112,13 @@
     }
 
     public AxisServiceGroup getDescription() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getDescription(): ****WARNING**** ServiceGroupContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getDescription(): ****WARNING**** ServiceGroupContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return axisServiceGroup;
     }
 
@@ -61,6 +141,9 @@
             throw new AxisFault(Messages.getMessage("invalidserviceinagroup",
                     service.getName(), axisServiceGroup.getServiceGroupName()));
         }
+        if (serviceContextMap == null) {
+            serviceContextMap = new HashMap();
+        }
         ServiceContext serviceContext = (ServiceContext) serviceContextMap.get(service.getName());
         if (serviceContext == null) {
             serviceContext = new ServiceContext(service, this);
@@ -70,10 +153,376 @@
     }
 
     public Iterator getServiceContexts() {
+        if (serviceContextMap == null) {
+            serviceContextMap = new HashMap();
+        }
+        if (serviceContextMap.isEmpty()) {
+            return null;
+        }
         return serviceContextMap.values().iterator();
     }
 
     public void setId(String id) {
         this.id = id;
     }
+
+
+
+    /**
+     * Adds the specified service context object to the
+     * lists of service contexts for this service group
+     * context.
+     * 
+     * @param srvctx The ServiceContext object to add
+     */
+    public void addServiceContext(ServiceContext srvctx)
+    {
+        if (srvctx == null)
+        {
+            return;
+        }
+
+        AxisService axisService = srvctx.getAxisService();
+        
+        if (axisService == null)
+        {
+            return;
+        }
+
+        if (serviceContextMap == null)
+        {
+            serviceContextMap = new HashMap();
+        }
+
+        serviceContextMap.put(axisService.getName(), srvctx);
+
+    }
+
+
+
+    /* ===============================================================
+     * Externalizable support 
+     * ===============================================================
+     */
+    
+
+    /**
+     * Save the contents of this object.
+     * <p>
+     * NOTE: Transient fields and static fields are not saved.
+     *       Also, objects that represent "static" data are
+     *       not saved, except for enough information to be
+     *       able to find matching objects when the message
+     *       context is re-constituted.
+     *
+     * @param out    The stream to write the object contents to
+     * 
+     * @exception IOException
+     */
+    public void writeExternal(ObjectOutput out) throws IOException
+    {
+        // write out contents of this object
+
+        //---------------------------------------------------------
+        // in order to handle future changes to the message 
+        // context definition, be sure to maintain the 
+        // object level identifiers
+        //---------------------------------------------------------
+        // serialization version ID
+        out.writeLong(serialVersionUID);
+
+        // revision ID
+        out.writeInt(revisionID);
+
+        //---------------------------------------------------------
+        // various simple fields
+        //---------------------------------------------------------
+
+        out.writeLong(getLastTouchedTime());
+
+        if (id == null)
+        {
+            // generate an ID to use when this object is restored
+            id = UUIDGenerator.getUUID();
+        }
+
+        ObjectStateUtils.writeString(out, id, "ServiceGroupContext.id");
+
+        //---------------------------------------------------------
+        // properties
+        //---------------------------------------------------------
+        Map tmpMap = getProperties();
+
+        HashMap tmpHashMap = null;
+
+        if ((tmpMap != null) && (tmpMap.isEmpty()==false))
+        {
+            tmpHashMap = new HashMap(tmpMap);
+        }
+
+        ObjectStateUtils.writeHashMap(out, tmpHashMap, "ServiceGroupContext.properties");
+
+
+        //---------------------------------------------------------
+        // AxisServiceGroup
+        //---------------------------------------------------------
+
+        String axisServGrpMarker = "ServiceGroupContext.axisServiceGroup";
+        ObjectStateUtils.writeString(out, axisServGrpMarker, axisServGrpMarker);
+
+        if (axisServiceGroup == null)
+        {
+        	out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+        }
+        else
+        {
+        	out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+        	metaAxisServiceGroup = new MetaDataEntry(axisServiceGroup.getClass().getName(), axisServiceGroup.getServiceGroupName());
+        	ObjectStateUtils.writeObject(out, metaAxisServiceGroup, "ServiceGroupContext.metaAxisServiceGroup");
+        }
+        
+
+        //---------------------------------------------------------
+        // parent 
+        //---------------------------------------------------------
+
+        // the parent is the ConfigurationContext object, which
+        // at this time, is not being saved.
+        // instead, we will need to register this ServiceGroupObject
+        // with the existing ConfigurationContext object when
+        // this object is reconstituted
+
+    }
+
+
+    /**
+     * Restore the contents of the object that was previously saved.
+     * <p> 
+     * NOTE: The field data must read back in the same order and type
+     * as it was written.  Some data will need to be validated when 
+     * resurrected.
+     *
+     * @param in    The stream to read the object contents from 
+     * 
+     * @exception IOException
+     * @exception ClassNotFoundException
+     */
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
+    {
+        // set the flag to indicate that the message context is being
+        // reconstituted and will need to have certain object references 
+        // to be reconciled with the current engine setup
+        needsToBeReconciled = true;
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal():  BEGIN  bytes available in stream ["+in.available()+"]  ");
+        }
+        //System.out.println(myClassName+":readExternal():  BEGIN  bytes available in stream ["+in.available()+"]  ");
+
+
+        // serialization version ID
+        long suid = in.readLong();
+
+        // revision ID
+        int  revID = in.readInt();
+
+        // make sure the object data is in a version we can handle
+        if (suid != serialVersionUID)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+        }
+
+        // make sure the object data is in a revision level we can handle
+        if (revID != REVISION_1)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        }
+
+
+        //---------------------------------------------------------
+        // various simple fields
+        //---------------------------------------------------------
+
+        long time = in.readLong();
+        setLastTouchedTime(time);
+
+        id = ObjectStateUtils.readString(in, "ServiceGroupContext.id");
+
+
+        //---------------------------------------------------------
+        // properties
+        //---------------------------------------------------------
+
+        HashMap tmpHashMap = ObjectStateUtils.readHashMap(in,"ServiceGroupContext.properties");
+
+        properties = new HashMap();
+        if (tmpHashMap != null)
+        {
+            setProperties(tmpHashMap);
+        }
+
+        //---------------------------------------------------------
+        // AxisServiceGroup
+        //---------------------------------------------------------
+
+        // axisServiceGroup is not usable until the meta data has been reconciled
+        axisServiceGroup = null;
+
+        String axisServGrpMarker = ObjectStateUtils.readString(in, "ServiceGroupContext.axisServiceGroup");
+        
+        boolean metaAxisServiceGrpIsActive = in.readBoolean();
+
+        if (metaAxisServiceGrpIsActive == ObjectStateUtils.ACTIVE_OBJECT)
+        {
+        	metaAxisServiceGroup = (MetaDataEntry) ObjectStateUtils.readObject(in, "ServiceGroupContext.metaAxisServiceGroup");
+        }
+        else
+        {
+        	metaAxisServiceGroup = null;
+        }
+        
+
+
+        //---------------------------------------------------------
+        // parent 
+        //---------------------------------------------------------
+
+        // the parent is the ConfigurationContext object, whic
+        // at this time, is not being saved.
+        // instead, we will need to register this ServiceGroupObject
+        // with the existing ConfigurationContext object when
+        // this object is reconstituted
+
+
+        //---------------------------------------------------------
+        // other
+        //---------------------------------------------------------
+        serviceContextMap = new HashMap();
+
+
+        //---------------------------------------------------------
+        // done
+        //---------------------------------------------------------
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal():  END");
+        }
+        //System.out.println(myClassName+":readExternal():  END");
+
+    }
+
+    
+    /**                     
+     * Some parts of the object restored from the 
+     * readExternal deserialization work cannot be completed until
+     * we have a configurationContext.  This method checks to see
+     * if additional work needs to be done in order to complete
+     * the object reconstitution.
+     */
+    public void activate(ConfigurationContext cc)
+    {
+        // see if there's any work to do
+        if (needsToBeReconciled == false)
+        {
+            // return quick
+            return;
+        }
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":activate():  BEGIN");
+        }
+        //System.out.println(myClassName+":activate():  BEGIN");
+
+
+
+        // get the axis configuration 
+        AxisConfiguration axisConfig = cc.getAxisConfiguration();
+
+        // We previously saved metaAxisServiceGroup; restore it
+        if (metaAxisServiceGroup != null) {
+        	axisServiceGroup = ObjectStateUtils.findServiceGroup(axisConfig, metaAxisServiceGroup.getClassName(), metaAxisServiceGroup.getQNameAsString());
+        }
+        else
+        {
+            axisServiceGroup = null;
+        }
+
+        // set parent 
+        this.setParent(cc);
+
+        // register with the parent
+        cc.registerServiceGroupContext(this);
+
+
+        //-------------------------------------------------------
+        // done, reset the flag
+        //-------------------------------------------------------
+        needsToBeReconciled = false;
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":activate():  END");
+        }
+        //System.out.println(myClassName+":activate():  END");
+    }
+
+    /**
+     * Compares key parts of the state from the current instance of 
+     * this class with the specified instance to see if they are 
+     * equivalent. 
+     * <P>
+     * This differs from the java.lang.Object.equals() method in
+     * that the equals() method generally looks at both the 
+     * object identity (location in memory) and the object state
+     * (data).
+     * <P>
+     * 
+     * @param ctx  The object to compare with
+     * @return TRUE if this object is equivalent with the specified object
+     *              that is, key fields match
+     *         FALSE, otherwise
+     */
+    public boolean isEquivalent(ServiceGroupContext ctx)
+    {
+        // NOTE: the input object is expected to exist (ie, be non-null)
+
+        if (!this.axisServiceGroup.equals(ctx.getDescription()))
+        {
+            return false;
+        }
+
+        String ctxid = ctx.getId();
+
+        if ((this.id != null) && (ctxid != null))
+        {
+            if (!this.id.equals(ctxid))
+            {
+                return false;
+            }
+
+        }
+        else if ((this.id == null) && (ctxid == null)) 
+        {
+            // keep going
+        }
+        else
+        {
+            // mismatch
+            return false;
+        }
+
+
+
+        // TODO: consider checking the parent objects for equivalency
+
+        // TODO: consider checking fields from the super class for equivalency
+
+        return true;
+    }
 }
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/OperationContext.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/OperationContext.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/OperationContext.java	(working copy)
@@ -19,7 +19,19 @@
 
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.axis2.util.ObjectStateUtils;
+import org.apache.axis2.util.MetaDataEntry;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutput;
+import java.io.ObjectOutputStream;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -31,27 +43,117 @@
  * exchanged the OperationContext remembers the state of where in the message
  * exchange pattern it is in.
  * <p/>
- * OperationContextFactory factory. The base implementation of OperationContext
+ * The base implementation of OperationContext
  * supports MEPs which have one input message and/or one output message. That
  * is, it supports the all the MEPs that are in the WSDL 2.0 specification. In
  * order to support another MEP one must extend this class and register its
  * creation in the OperationContexFactory.
  */
-public class OperationContext extends AbstractContext {
+public class OperationContext extends AbstractContext implements Externalizable {
+
+    /*
+     * setup for logging
+     */
+    private static final Log log = LogFactory.getLog(OperationContext.class);
+
+    private static final String myClassName = "OperationContext";
+
+    /**
+     * @serial The serialization version ID tracks the version of the class.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. If a change to the class is made which is
+     * not compatible with the serialization/externalization of the class,
+     * then the serialization version ID should be updated.
+     * Refer to the "serialVer" utility to compute a serialization
+     * version ID.
+     */
+    private  static final long serialVersionUID = -7264782778333554350L;
+
+    /**
+     * @serial Tracks the revision level of a class to identify changes to the 
+     * class definition that are compatible to serialization/externalization.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. 
+     * Refer to the writeExternal() and readExternal() methods.
+     */
+    // supported revision levels, add a new level to manage compatible changes
+    private static final int REVISION_1 = 1;
+    // current revision level of this object
+    private static final int revisionID = REVISION_1;
+
+
+    /**
+     * @serial isComplete flag
+     */
     private boolean isComplete;
 
+    /**
+     * @serial key string
+     */
     //The key value of the operationContextMap;
     private String key;
 
     // the AxisOperation of which this is a running instance. The MEP of this
     // AxisOperation must be one of the 8 predefined ones in WSDL 2.0.
     private transient AxisOperation axisOperation;
-    private HashMap messageContexts;
 
+    /**
+     * the set of message contexts associated with this operation
+     */
+    private transient HashMap messageContexts;
+
     // this is the global MessageID -> OperationContext map which is stored in
     // the EngineContext. We're caching it here for faster access.
-    private Map operationContextMap;
+    private transient Map operationContextMap;
 
+
+    //----------------------------------------------------------------
+    // MetaData for data to be restored in activate after readExternal
+    //----------------------------------------------------------------
+    
+    /**
+     * Indicates whether the message context has been reconstituted
+     * and needs to have its object references reconciled
+     */
+    private transient boolean needsToBeReconciled = false;
+
+    /**
+     * The AxisOperation metadata will be used during
+     * activate to match up with an existing object
+     */
+    private transient MetaDataEntry metaAxisOperation = null;
+    
+    /**
+     * The AxisService metadata will be used during
+     * activate to match up with an existing object
+     */
+    private transient MetaDataEntry metaAxisService = null;
+    
+    /**
+     * The ServiceContext metadata will be used during
+     * activate to match up with an existing object
+     */
+    private transient ServiceContext metaParent = null;
+    
+
+    //----------------------------------------------------------------
+    // end MetaData section
+    //----------------------------------------------------------------
+
+    /**
+     *  Simple constructor
+     */
+    public OperationContext() {
+        super(null);
+        this.messageContexts = new HashMap();
+    }
+
+
+
+
+    /**
+     *  Constructs a new OperationContext associated with the specified AxisOperation
+     */
     public OperationContext(AxisOperation axisOperation) {
         super(null);
         this.messageContexts = new HashMap();
@@ -71,9 +173,15 @@
         super(serviceContext);
         this.messageContexts = new HashMap();
         this.axisOperation = axisOperation;
-        this.operationContextMap =
-                getServiceContext().getConfigurationContext()
-                        .getOperationContextMap();
+
+        ServiceContext serv = getServiceContext();
+
+        if (serv != null)
+        {
+            this.operationContextMap =
+                    serv.getConfigurationContext()
+                            .getOperationContextMap();
+        }
     }
 
     /**
@@ -104,6 +212,15 @@
      */
     public void cleanup() {
         if (key != null) {
+            if (operationContextMap == null) {
+                ServiceContext serv = getServiceContext();
+
+                if (serv != null) {
+                    this.operationContextMap =
+                            serv.getConfigurationContext()
+                                    .getOperationContextMap();
+                }
+            }
             operationContextMap.remove(key);
         }
     }
@@ -112,6 +229,13 @@
      * @return Returns the axisOperation.
      */
     public AxisOperation getAxisOperation() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getAxisOperation(): ****WARNING**** OperationContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getAxisOperation(): ****WARNING**** OperationContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return axisOperation;
     }
 
@@ -121,9 +245,17 @@
      * @return Returns parent ServiceContext's parent EngineContext.
      */
     public ConfigurationContext getConfigurationContext() {
-        return ((ServiceContext) parent).getConfigurationContext();
+        if (parent != null)
+        {
+            return ((ServiceContext) parent).getConfigurationContext();
+        }
+        else
+        {
+            return null;
+        }
     }
 
+
     /**
      * @param messageLabel
      * @return Returns MessageContext.
@@ -131,6 +263,9 @@
      */
     public MessageContext getMessageContext(String messageLabel)
             throws AxisFault {
+        if (messageContexts == null) {
+            return null;
+        }
         return (MessageContext) messageContexts.get(messageLabel);
     }
 
@@ -161,12 +296,387 @@
 
     public void setParent(AbstractContext context) {
         super.setParent(context);
-        this.operationContextMap =
-                getServiceContext().getConfigurationContext()
-                        .getOperationContextMap();
+
+        ServiceContext serv = getServiceContext();
+
+        if (serv != null) {
+            this.operationContextMap =
+                    serv.getConfigurationContext()
+                            .getOperationContextMap();
+        }
     }
 
     public void setKey(String key) {
         this.key = key;
     }
+
+
+    /* ===============================================================
+     * Externalizable support 
+     * ===============================================================
+     */
+    
+
+    /**
+     * Save the contents of this object.
+     * <p>
+     * NOTE: Transient fields and static fields are not saved.
+     *       Also, objects that represent "static" data are
+     *       not saved, except for enough information to be
+     *       able to find matching objects when the message
+     *       context is re-constituted.
+     *
+     * @param out    The stream to write the object contents to
+     * 
+     * @exception IOException
+     */
+    public void writeExternal(ObjectOutput out) throws IOException
+    {
+        //---------------------------------------------------------
+        // in order to handle future changes to the message 
+        // context definition, be sure to maintain the 
+        // object level identifiers
+        //---------------------------------------------------------
+        // serialization version ID
+        out.writeLong(serialVersionUID);
+
+        // revision ID
+        out.writeInt(revisionID);
+
+        //---------------------------------------------------------
+        // various simple fields
+        //---------------------------------------------------------
+
+        out.writeLong(getLastTouchedTime());
+
+        out.writeBoolean(isComplete);
+
+        //---------------------------------------------------------
+        // properties
+        //---------------------------------------------------------
+        Map tmpMap = getProperties();
+
+        HashMap tmpHashMap = null;
+
+        if ((tmpMap != null) && (tmpMap.isEmpty()==false))
+        {
+            tmpHashMap = new HashMap(tmpMap);
+        }
+
+        ObjectStateUtils.writeHashMap(out, tmpHashMap, "OperationContext.properties");
+
+
+        //---------------------------------------------------------
+        // AxisOperation axisOperation
+        //---------------------------------------------------------
+        String axisOpMarker = "OperationContext.axisOperation";
+        ObjectStateUtils.writeString(out, axisOpMarker, axisOpMarker);
+
+        if (axisOperation == null)
+        {
+        	out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+        }
+        else
+        {
+        	out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+        	metaAxisOperation = new MetaDataEntry(axisOperation.getClass().getName(), axisOperation.getName().toString());
+        	ObjectStateUtils.writeObject(out, metaAxisOperation, "OperationContext.metaAxisOperation");
+        }
+
+        // save the meta data for the corresponding axis service to better
+        // match up the axis operation 
+
+        String axisServMarker = "OperationContext.metaAxisService";
+        ObjectStateUtils.writeString(out, axisServMarker, axisServMarker);
+
+        AxisService axisService = (AxisService) axisOperation.getParent();
+
+        if (axisService == null)
+        {
+        	out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+        }
+        else
+        {
+        	out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+        	metaAxisService = new MetaDataEntry(axisService.getClass().getName(), axisService.getName().toString());
+        	ObjectStateUtils.writeObject(out, metaAxisService, "OperationContext.metaAxisService");
+        }
+        
+
+        //---------------------------------------------------------
+        // parent 
+        //---------------------------------------------------------
+        ServiceContext myParent = (ServiceContext) this.getServiceContext();
+
+        ObjectStateUtils.writeObject(out, myParent, "OperationContext.parent ServiceContext"); 
+
+    }
+
+
+    /**
+     * Restore the contents of the object that was previously saved.
+     * <p> 
+     * NOTE: The field data must read back in the same order and type
+     * as it was written.  Some data will need to be validated when 
+     * resurrected.
+     *
+     * @param in    The stream to read the object contents from 
+     * 
+     * @exception IOException
+     * @exception ClassNotFoundException
+     */
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
+    {
+        // set the flag to indicate that the message context is being
+        // reconstituted and will need to have certain object references 
+        // to be reconciled with the current engine setup
+        needsToBeReconciled = true;
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal():  BEGIN  bytes available in stream ["+in.available()+"]  ");
+        }
+        //System.out.println(myClassName+":readExternal():  BEGIN  bytes available in stream ["+in.available()+"]  ");
+
+
+        //---------------------------------------------------------
+        // object level identifiers
+        //---------------------------------------------------------
+
+        // serialization version ID
+        long suid = in.readLong();
+
+        // revision ID
+        int  revID = in.readInt();
+
+        // make sure the object data is in a version we can handle
+        if (suid != serialVersionUID)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+        }
+
+        // make sure the object data is in a revision level we can handle
+        if (revID != REVISION_1)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        }
+
+
+        //---------------------------------------------------------
+        // various simple fields
+        //---------------------------------------------------------
+
+        long time = in.readLong();
+        setLastTouchedTime(time);
+
+        isComplete = in.readBoolean();
+
+        //---------------------------------------------------------
+        // properties
+        //---------------------------------------------------------
+
+        HashMap tmpHashMap = ObjectStateUtils.readHashMap(in,"OperationContext.properties");
+
+        properties = new HashMap();
+        if (tmpHashMap != null)
+        {
+            setProperties(tmpHashMap);
+        }
+
+
+        //---------------------------------------------------------
+        // axis operation meta data
+        //---------------------------------------------------------
+
+        // axisOperation is not usable until the meta data has been reconciled
+        axisOperation = null;
+
+        String axisOpMarker = ObjectStateUtils.readString(in, "OperationContext.axisOperation");
+
+        boolean metaAxisOperationIsActive = in.readBoolean();
+
+        if (metaAxisOperationIsActive == ObjectStateUtils.ACTIVE_OBJECT)
+        {
+        	metaAxisOperation = (MetaDataEntry) ObjectStateUtils.readObject(in, "OperationContext.metaAxisOperation");
+        }
+        else
+        {
+        	metaAxisOperation = null;
+        }
+
+
+        // axisService is not usable until the meta data has been reconciled
+
+        String axisServMarker = ObjectStateUtils.readString(in, "OperationContext.axisService");
+        
+        boolean metaAxisServiceIsActive = in.readBoolean();
+
+        if (metaAxisServiceIsActive == ObjectStateUtils.ACTIVE_OBJECT)
+        {
+        	metaAxisService = (MetaDataEntry) ObjectStateUtils.readObject(in, "OperationContext.metaAxisService");
+        }
+        else
+        {
+        	metaAxisService = null;
+        }
+        
+
+
+        //---------------------------------------------------------
+        // parent 
+        //---------------------------------------------------------
+
+        // ServiceContext is not usable until it has been activated 
+
+        metaParent = (ServiceContext) ObjectStateUtils.readObject(in, "OperationContext.parent ServiceContext");
+        
+
+        //---------------------------------------------------------
+        // other
+        //---------------------------------------------------------
+
+        // reset the key
+        key = null;
+
+        operationContextMap = null;  //need to reseed from config context ?
+
+        messageContexts = new HashMap();
+
+
+        //---------------------------------------------------------
+        // done
+        //---------------------------------------------------------
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal():  END");
+        }
+        //System.out.println(myClassName+":readExternal():  END");
+
+    }
+
+    
+    /**
+     * This method checks to see if additional work needs to be
+     * done in order to complete the object reconstitution.
+     * Some parts of the object restored from the readExternal()
+     * cannot be completed until we have a configurationContext
+     * from the active engine. The configurationContext is used
+     * to help this object to plug back into the engine's
+     * configuration and deployment objects.
+     * 
+     * @param cc     The configuration context object representing the active configuration
+     */
+    public void activate(ConfigurationContext cc)
+    {
+        // see if there's any work to do
+        if (needsToBeReconciled == false)
+        {
+            // return quick
+            return;
+        }
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":activate():  BEGIN");
+        }
+        //System.out.println(myClassName+":activate():  BEGIN");
+
+
+        // get the axis configuration 
+        AxisConfiguration axisConfig = cc.getAxisConfiguration();
+
+
+        // We previously saved metaAxisService; restore it
+        AxisService axisService = null;
+
+        if (metaAxisService != null) 
+        {
+        	axisService = ObjectStateUtils.findService(axisConfig, metaAxisService.getClassName(), metaAxisService.getQNameAsString());
+        }
+
+        // We previously saved metaAxisOperation; restore it
+        if (metaAxisOperation != null)
+        {
+            if (axisService != null)
+            {
+                this.axisOperation = ObjectStateUtils.findOperation(axisService, metaAxisOperation.getClassName(), metaAxisOperation.getQName());
+            }
+            else
+            {
+                this.axisOperation = ObjectStateUtils.findOperation(axisConfig, metaAxisOperation.getClassName(), metaAxisOperation.getQName());
+            }
+        }
+        
+        // we saved our parent; activate it
+        if (metaParent != null)
+        {
+            metaParent.activate(cc);
+        }
+
+        // set parent 
+        this.setParent(metaParent);
+
+
+        // reseed the operation context map
+
+        ServiceContext serv = getServiceContext();
+        if (serv != null)
+        {
+            this.operationContextMap =
+                    serv.getConfigurationContext()
+                            .getOperationContextMap();
+        }
+
+        //-------------------------------------------------------
+        // done, reset the flag
+        //-------------------------------------------------------
+        needsToBeReconciled = false;
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":activate():  END");
+        }
+        //System.out.println(myClassName+":activate():  END");
+    }
+
+    /**
+     * Compares key parts of the state from the current instance of 
+     * this class with the specified instance to see if they are 
+     * equivalent. 
+     * <P>
+     * This differs from the java.lang.Object.equals() method in
+     * that the equals() method generally looks at both the 
+     * object identity (location in memory) and the object state
+     * (data).
+     * <P>
+     * 
+     * @param ctx  The object to compare with
+     * @return TRUE if this object is equivalent with the specified object
+     *              that is, key fields match
+     *         FALSE, otherwise
+     */
+    public boolean isEquivalent(OperationContext ctx)
+    {
+        // NOTE: the input object is expected to exist (ie, be non-null)
+
+        if (this.isComplete != ctx.isComplete())
+        {
+            return false;
+        }
+
+        if (!this.axisOperation.equals(ctx.getAxisOperation()))
+        {
+            return false;
+        }
+
+        // TODO: consider checking the parent objects for equivalency
+
+        // TODO: consider checking fields from the super class for equivalency
+
+        return true;
+    }
 }
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/ServiceContext.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/ServiceContext.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/ServiceContext.java	(working copy)
@@ -22,25 +22,107 @@
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.TransportInDescription;
+import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.axis2.engine.ListenerManager;
 import org.apache.axis2.i18n.Messages;
+import org.apache.axis2.util.ObjectStateUtils;
+import org.apache.axis2.util.MetaDataEntry;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 
 import javax.xml.namespace.QName;
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutput;
+import java.io.ObjectOutputStream;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * Well this is never clearly defined, what it does or the life-cycle.
  * So do NOT use this as it might not live up to your expectation.
  */
-public class ServiceContext extends AbstractContext {
+public class ServiceContext extends AbstractContext implements Externalizable {
 
+    /*
+     * setup for logging
+     */
+    private static final Log log = LogFactory.getLog(ServiceContext.class);
+
+    private static final String myClassName = "ServiceContext";
+
+    /**
+     * @serial The serialization version ID tracks the version of the class.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. If a change to the class is made which is
+     * not compatible with the serialization/externalization of the class,
+     * then the serialization version ID should be updated.
+     * Refer to the "serialVer" utility to compute a serialization
+     * version ID.
+     */
+    private static final long serialVersionUID = 8265625275015738957L;
+
+    /**
+     * @serial Tracks the revision level of a class to identify changes to the 
+     * class definition that are compatible to serialization/externalization.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. 
+     * Refer to the writeExternal() and readExternal() methods.
+     */
+    // supported revision levels, add a new level to manage compatible changes
+    private static final int REVISION_1 = 1;
+    // current revision level of this object
+    private static final int revisionID = REVISION_1;
+
+
     public static final String SERVICE_OBJECT = "serviceObject";
+
     private EndpointReference targetEPR;
     private EndpointReference myEPR;
 
     private transient AxisService axisService;
-    private ServiceGroupContext serviceGroupContext;
-    private ConfigurationContext configContext;
 
+    // the service group context is the same as the parent
+    private transient ServiceGroupContext serviceGroupContext;
+
+    private transient ConfigurationContext configContext;
+
+
+    //----------------------------------------------------------------
+    // MetaData for data to be restored in activate after readExternal
+    //----------------------------------------------------------------
+    
+    /**
+     * Indicates whether the message context has been reconstituted
+     * and needs to have its object references reconciled
+     */
+    private transient boolean needsToBeReconciled = false;
+
+    /**
+     * The AxisService metadata will be used during
+     * activate to match up with an existing object
+     */
+    private transient MetaDataEntry metaAxisService = null;
+    
+    /**
+     * The ServiceGroupContext object will be used during
+     * activate to finish its restoration 
+     */
+    private transient ServiceGroupContext  metaParent = null;
+    
+    
+    //----------------------------------------------------------------
+    // end MetaData section
+    //----------------------------------------------------------------
+
+    // simple constructor
+    public ServiceContext() {
+        super(null);
+    }
+
+
     public ServiceContext(AxisService serviceConfig, ServiceGroupContext serviceGroupContext) {
         super(serviceGroupContext);
         this.serviceGroupContext = serviceGroupContext;
@@ -55,14 +137,35 @@
     }
 
     public AxisService getAxisService() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getAxisService(): ****WARNING**** ServiceContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getAxisService(): ****WARNING**** ServiceContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return axisService;
     }
 
     public ConfigurationContext getConfigurationContext() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getConfigurationContext(): ****WARNING**** ServiceContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getConfigurationContext(): ****WARNING**** ServiceContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return configContext;
     }
 
     public ServiceGroupContext getServiceGroupContext() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getServiceGroupContext(): ****WARNING**** ServiceContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getServiceGroupContext(): ****WARNING**** ServiceContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return serviceGroupContext;
     }
 
@@ -73,6 +176,7 @@
      * for a given service
      *
      * @param transport : Name of the transport
+     * @return
      * @throws AxisFault
      */
     public EndpointReference getMyEPR(String transport) throws AxisFault {
@@ -124,4 +228,363 @@
     public void setMyEPR(EndpointReference myEPR) {
         this.myEPR = myEPR;
     }
+
+
+    /* ===============================================================
+     * Externalizable support 
+     * ===============================================================
+     */
+    
+
+    /**
+     * Save the contents of this object.
+     * <p>
+     * NOTE: Transient fields and static fields are not saved.
+     *       Also, objects that represent "static" data are
+     *       not saved, except for enough information to be
+     *       able to find matching objects when the message
+     *       context is re-constituted.
+     *
+     * @param out    The stream to write the object contents to
+     * 
+     * @exception IOException
+     */
+    public void writeExternal(ObjectOutput out) throws IOException
+    {
+        //---------------------------------------------------------
+        // in order to handle future changes to the message 
+        // context definition, be sure to maintain the 
+        // object level identifiers
+        //---------------------------------------------------------
+        // serialization version ID
+        out.writeLong(serialVersionUID);
+
+        // revision ID
+        out.writeInt(revisionID);
+
+        //---------------------------------------------------------
+        // various simple fields
+        //---------------------------------------------------------
+
+        out.writeLong(getLastTouchedTime());
+
+        // EndpointReference targetEPR
+        ObjectStateUtils.writeObject(out, targetEPR, "ServiceContext.targetEPR");
+
+        // EndpointReference myEPR
+        ObjectStateUtils.writeObject(out, myEPR, "ServiceContext.myEPR");
+
+
+        //---------------------------------------------------------
+        // properties
+        //---------------------------------------------------------
+        Map tmpMap = getProperties();
+
+        HashMap tmpHashMap = null;
+
+        if ((tmpMap != null) && (tmpMap.isEmpty()==false))
+        {
+            tmpHashMap = new HashMap(tmpMap);
+        }
+
+        ObjectStateUtils.writeHashMap(out, tmpHashMap, "ServiceContext.properties");
+
+
+        //---------------------------------------------------------
+        // AxisService
+        //---------------------------------------------------------
+
+        String axisServMarker = "ServiceContext.metaAxisService";
+        ObjectStateUtils.writeString(out, axisServMarker, axisServMarker);
+
+        if (axisService == null)
+        {
+        	out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+        }
+        else
+        {
+        	out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+        	metaAxisService = new MetaDataEntry(axisService.getClass().getName(), axisService.getName().toString());
+        	ObjectStateUtils.writeObject(out, metaAxisService, "ServiceContext.metaAxisService");
+        }
+        
+
+        //---------------------------------------------------------
+        // parent 
+        //---------------------------------------------------------
+        // ServiceGroupContext serviceGroupContext;
+
+        ServiceGroupContext myParent = (ServiceGroupContext) getParent();
+
+        ObjectStateUtils.writeObject(out, myParent, "ServiceContext.parent ServiceGroupContext");
+
+    }
+
+
+    /**
+     * Restore the contents of the object that was previously saved.
+     * <p> 
+     * NOTE: The field data must read back in the same order and type
+     * as it was written.  Some data will need to be validated when 
+     * resurrected.
+     *
+     * @param in    The stream to read the object contents from 
+     * 
+     * @exception IOException
+     * @exception ClassNotFoundException
+     */
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
+    {
+        // set the flag to indicate that the message context is being
+        // reconstituted and will need to have certain object references 
+        // to be reconciled with the current engine setup
+        needsToBeReconciled = true;
+
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal():  BEGIN  bytes available in stream ["+in.available()+"]  ");
+        }
+        //System.out.println(myClassName+":readExternal():  BEGIN  bytes available in stream ["+in.available()+"]  ");
+
+
+        //---------------------------------------------------------
+        // object level identifiers
+        //---------------------------------------------------------
+
+        // serialization version ID
+        long suid = in.readLong();
+
+        // revision ID
+        int  revID = in.readInt();
+
+        // make sure the object data is in a version we can handle
+        if (suid != serialVersionUID)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+        }
+
+        // make sure the object data is in a revision level we can handle
+        if (revID != REVISION_1)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        }
+
+
+        //---------------------------------------------------------
+        // various simple fields
+        //---------------------------------------------------------
+
+        long time = in.readLong();
+        setLastTouchedTime(time);
+
+
+        // EndpointReference targetEPR
+        targetEPR = (EndpointReference) ObjectStateUtils.readObject(in, "ServiceContext.targetEPR");
+
+        // EndpointReference myEPR
+        myEPR = (EndpointReference) ObjectStateUtils.readObject(in, "ServiceContext.myEPR");
+
+
+        //---------------------------------------------------------
+        // properties
+        //---------------------------------------------------------
+
+        HashMap tmpHashMap = ObjectStateUtils.readHashMap(in,"ServiceContext.properties");
+
+        properties = new HashMap();
+        if (tmpHashMap != null)
+        {
+            setProperties(tmpHashMap);
+        }
+
+
+        //---------------------------------------------------------
+        // AxisService
+        //---------------------------------------------------------
+
+        // axisService is not usable until the meta data has been reconciled
+
+        String axisServMarker = ObjectStateUtils.readString(in, "ServiceContext.axisService");
+        
+        boolean metaAxisServiceIsActive = in.readBoolean();
+
+        if (metaAxisServiceIsActive == ObjectStateUtils.ACTIVE_OBJECT)
+        {
+        	metaAxisService = (MetaDataEntry) ObjectStateUtils.readObject(in, "ServiceContext.metaAxisService");
+        }
+        else
+        {
+        	metaAxisService = null;
+        }
+        
+
+
+        //---------------------------------------------------------
+        // parent 
+        //---------------------------------------------------------
+
+        // ServiceGroupContext is not usable until it has been activated 
+
+        metaParent = (ServiceGroupContext) ObjectStateUtils.readObject(in, "ServiceContext.parent ServiceGroupContext");
+        
+
+        //---------------------------------------------------------
+        // done
+        //---------------------------------------------------------
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal():  END");
+        }
+        //System.out.println(myClassName+":readExternal():  END");
+
+    }
+
+    
+    /**
+     * This method checks to see if additional work needs to be
+     * done in order to complete the object reconstitution.
+     * Some parts of the object restored from the readExternal()
+     * cannot be completed until we have a configurationContext
+     * from the active engine. The configurationContext is used
+     * to help this object to plug back into the engine's
+     * configuration and deployment objects.
+     * 
+     * @param cc     The configuration context object representing the active configuration
+     */
+    public void activate(ConfigurationContext cc)
+    {
+        // see if there's any work to do
+        if (needsToBeReconciled == false)
+        {
+            // return quick
+            return;
+        }
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":activate():  BEGIN");
+        }
+        //System.out.println(myClassName+":activate():  BEGIN");
+
+
+        // use the supplied configuration context
+        configContext = cc;
+
+        // get the axis configuration 
+        AxisConfiguration axisConfig = cc.getAxisConfiguration();
+
+        // We previously saved metaAxisService; restore it
+        axisService = null;
+
+        if (metaAxisService != null) 
+        {
+        	axisService = ObjectStateUtils.findService(axisConfig, metaAxisService.getClassName(), metaAxisService.getQNameAsString());
+        }
+
+        // we saved our parent; activate it
+        if (metaParent != null)
+        {
+            metaParent.activate(cc);
+        }
+
+        // set parent 
+        this.setParent(metaParent);
+        serviceGroupContext = (ServiceGroupContext) this.getParent();
+
+
+        //-------------------------------------------------------
+        // done, reset the flag
+        //-------------------------------------------------------
+        needsToBeReconciled = false;
+
+        // make sure this restored object is in the parent's list
+        if (metaParent != null)
+        {
+            // make sure this restored object is in the parent's list
+            metaParent.addServiceContext(this);
+        }
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":activate():  END");
+        }
+        //System.out.println(myClassName+":activate():  END");
+    }
+
+
+    /**
+     * Compares key parts of the state from the current instance of 
+     * this class with the specified instance to see if they are 
+     * equivalent. 
+     * <P>
+     * This differs from the java.lang.Object.equals() method in
+     * that the equals() method generally looks at both the 
+     * object identity (location in memory) and the object state
+     * (data).
+     * <P>
+     * 
+     * @param srvctx  The object to compare with
+     * @return TRUE if this object is equivalent with the specified object
+     *              that is, key fields match
+     *         FALSE, otherwise
+     */
+    public boolean isEquivalent(ServiceContext ctx)
+    {
+        // NOTE: the input object is expected to exist (ie, be non-null)
+
+        if (!this.axisService.equals(ctx.getAxisService()))
+        {
+            return false;
+        }
+
+
+        EndpointReference targetEPR2 = ctx.getTargetEPR();
+
+        if ( (this.targetEPR != null) && (targetEPR2 != null) )
+        {
+            if (!this.targetEPR.isEquivalent(targetEPR2))
+            {
+                return false;
+            }
+        }
+        else if ((this.targetEPR == null) && (targetEPR2 == null))
+        {
+            // keep going
+        }
+        else
+        {
+            // one of the objects is null
+            return false;
+        }
+
+        EndpointReference myEPR2 = ctx.getMyEPR();
+
+        if ( (this.myEPR != null) && (myEPR2 != null) )
+        {
+            if (!this.myEPR.isEquivalent(myEPR2))
+            {
+                return false;
+            }
+        }
+        else if ((this.myEPR == null) && (myEPR2 == null))
+        {
+            // keep going
+        }
+        else
+        {
+            // one of the objects is null
+            return false;
+        }
+
+        // TODO: consider checking the parent objects for equivalency
+
+        // TODO: consider checking fields from the super class for equivalency
+
+        return true;
+    }
 }
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/AbstractContext.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/AbstractContext.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/AbstractContext.java	(working copy)
@@ -136,4 +136,7 @@
         return lastTouchedTime;
     }
 
+    public void setLastTouchedTime(long t) {
+        lastTouchedTime = t;
+    }
 }
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/SessionContext.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/SessionContext.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/SessionContext.java	(working copy)
@@ -21,26 +21,62 @@
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.axis2.engine.DependencyManager;
+import org.apache.axis2.util.ObjectStateUtils;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutput;
+import java.io.ObjectOutputStream;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.Map;
 
 /**
  * All the engine components are stateless across the executions and all the states should be kept in the
  * Contexts, there are three context Global, Session and Message.
  */
-public class SessionContext extends AbstractContext {
+public class SessionContext extends AbstractContext implements Externalizable {
 
+    /**
+     * @serial The serialization version ID tracks the version of the class.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. If a change to the class is made which is
+     * not compatible with the serialization/externalization of the class,
+     * then the serialization version ID should be updated.
+     * Refer to the "serialVer" utility to compute a serialization
+     * version ID.
+     */
+    private static final long serialVersionUID = -1100610673067568556L;
+
+    /**
+     * @serial Tracks the revision level of a class to identify changes to the 
+     * class definition that are compatible to serialization/externalization.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. 
+     * Refer to the writeExternal() and readExternal() methods.
+     */
+    // supported revision levels, add a new level to manage compatible changes
+    private static final int REVISION_1 = 1;
+    // current revision level of this object
+    private static final int revisionID = REVISION_1;
+
+
+    // TODO: investigate whether these collections need to be saved
     private transient HashMap serviceContextMap = new HashMap();
     private transient HashMap serviceGroupContextMap = new HashMap();
-    private transient String cookieID;
-	private static final Log log = LogFactory.getLog(SessionContext.class);
 
+    private String cookieID;
+
+    private static final Log log = LogFactory.getLog(SessionContext.class);
+    private static final String myClassName = "SessionContext";
+
     // current time out interval is 30 secs. Need to make this configurable
-    public transient long sessionContextTimeoutInterval = 30 * 1000;
+    public long sessionContextTimeoutInterval = 30 * 1000;
 
     /**
      * @param parent
@@ -53,19 +89,31 @@
     }
 
     public ServiceContext getServiceContext(AxisService axisService) {
+        if (serviceContextMap == null) {
+            serviceContextMap = new HashMap();
+        }
         return (ServiceContext) serviceContextMap.get(axisService.getName());
     }
 
     public void addServiceContext(ServiceContext serviceContext) {
+        if (serviceContextMap == null) {
+            serviceContextMap = new HashMap();
+        }
         serviceContextMap.put(serviceContext.getAxisService().getName(), serviceContext);
     }
 
     public void addServiceGroupContext(ServiceGroupContext serviceGroupContext,
                                        String serviceGroupID) {
+        if (serviceGroupContextMap == null) {
+            serviceGroupContextMap = new HashMap();
+        }
         serviceGroupContextMap.put(serviceGroupID, serviceGroupContext);
     }
 
     public ServiceGroupContext getServiceGroupContext(String serviceGroupID) {
+        if (serviceGroupContextMap == null) {
+            serviceGroupContextMap = new HashMap();
+        }
         return (ServiceGroupContext) serviceGroupContextMap.get(serviceGroupID);
     }
 
@@ -99,6 +147,9 @@
 
     public Iterator getServiceGroupContext() {
         if (serviceGroupContextMap != null) {
+            if (serviceGroupContextMap.isEmpty()) {
+                return null;
+            }
             return serviceGroupContextMap.values().iterator();
         } else {
             return null;
@@ -129,4 +180,173 @@
     }
 
 
+    /* ===============================================================
+     * Externalizable support 
+     * ===============================================================
+     */
+    
+    /**
+     * Save the contents of this object.
+     * <p>
+     * NOTE: Transient fields and static fields are not saved.
+     *
+     * @param out    The stream to write the object contents to
+     * 
+     * @exception IOException
+     */
+    public void writeExternal(ObjectOutput out) throws IOException
+    {
+        // write out contents of this object
+
+        // NOTES: For each item, where appropriate,
+        //        write out the following information, IN ORDER:
+        //           the class name
+        //           the active or empty flag
+        //           the data length, if appropriate
+        //           the data   
+
+        //---------------------------------------------------------
+        // in order to handle future changes to the message 
+        // context definition, be sure to maintain the 
+        // object level identifiers
+        //---------------------------------------------------------
+        // serialization version ID
+        out.writeLong(serialVersionUID);
+
+        // revision ID
+        out.writeInt(revisionID);
+
+        //---------------------------------------------------------
+        // various simple fields
+        //---------------------------------------------------------
+        out.writeLong(getLastTouchedTime());
+
+        out.writeLong(sessionContextTimeoutInterval);
+
+        ObjectStateUtils.writeString(out, cookieID, "SessionContext.cookieID");
+
+
+        //---------------------------------------------------------
+        // properties
+        //---------------------------------------------------------
+        Map tmpMap = getProperties();
+
+        HashMap tmpHashMap = null;
+
+        if ((tmpMap != null) && (tmpMap.isEmpty()==false))
+        {
+            tmpHashMap = new HashMap(tmpMap);
+        }
+
+        ObjectStateUtils.writeHashMap(out, tmpHashMap, "SessionContext.properties");
+
+
+
+        //---------------------------------------------------------
+        // "nested"
+        //---------------------------------------------------------
+
+        // Options parent
+        ObjectStateUtils.writeObject(out, parent, "SessionContext.parent");
+
+
+    }
+
+
+    /**
+     * Restore the contents of the MessageContext that was 
+     * previously saved. 
+     * <p> 
+     * NOTE: The field data must read back in the same order and type
+     * as it was written.  Some data will need to be validated when 
+     * resurrected.
+     *
+     * @param in    The stream to read the object contents from 
+     * 
+     * @exception IOException
+     * @exception ClassNotFoundException
+     */
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
+    {
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal():  BEGIN  bytes available in stream ["+in.available()+"]  ");
+        }
+        //System.out.println(myClassName+":readExternal():  BEGIN  bytes available in stream ["+in.available()+"]  ");
+
+
+        // serialization version ID
+        long suid = in.readLong();
+
+        // revision ID
+        int  revID = in.readInt();
+
+        // make sure the object data is in a version we can handle
+        if (suid != serialVersionUID)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+        }
+
+        // make sure the object data is in a revision level we can handle
+        if (revID != REVISION_1)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        }
+
+
+        //---------------------------------------------------------
+        // various simple fields
+        //---------------------------------------------------------
+        long time = in.readLong();
+        setLastTouchedTime(time);
+
+        sessionContextTimeoutInterval = in.readLong();
+
+        cookieID = ObjectStateUtils.readString(in, "SessionContext.cookieID");
+
+
+        //---------------------------------------------------------
+        // properties
+        //---------------------------------------------------------
+
+        HashMap tmpHashMap = ObjectStateUtils.readHashMap(in,"SessionContext.properties");
+
+        properties = new HashMap();
+        if (tmpHashMap != null)
+        {
+            setProperties(tmpHashMap);
+        }
+
+
+        //---------------------------------------------------------
+        // "nested"
+        //---------------------------------------------------------
+
+        // parent
+        Object tmpParent = ObjectStateUtils.readObject(in, "SessionContext.parent"); 
+
+        if (tmpParent != null)
+        {
+            parent = (AbstractContext) tmpParent;
+        }
+        else
+        {
+            parent = null;
+        }
+
+        //---------------------------------------------------------
+        // done
+        //---------------------------------------------------------
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal():  END");
+        }
+        //System.out.println(myClassName+":readExternal():  END");
+
+    }
+
+
 }
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/MessageContext.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/MessageContext.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/MessageContext.java	(working copy)
@@ -18,36 +18,110 @@
 
 import org.apache.axiom.attachments.Attachments;
 import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.OMOutputFormat;
+import org.apache.axiom.om.impl.MTOMConstants;
+import org.apache.axiom.om.impl.builder.StAXBuilder;
+import org.apache.axiom.om.util.StAXUtils;
 import org.apache.axiom.om.util.UUIDGenerator;
 import org.apache.axiom.soap.SOAP11Constants;
 import org.apache.axiom.soap.SOAP12Constants;
 import org.apache.axiom.soap.SOAPConstants;
 import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axiom.soap.impl.builder.StAXSOAPModelBuilder;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.addressing.RelatesTo;
 import org.apache.axis2.client.Options;
-import org.apache.axis2.description.*;
+import org.apache.axis2.description.AxisMessage;
+import org.apache.axis2.description.AxisModule;
+import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.AxisServiceGroup;
+import org.apache.axis2.description.HandlerDescription;
+import org.apache.axis2.description.ModuleConfiguration;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.description.TransportInDescription;
+import org.apache.axis2.description.TransportOutDescription;
 import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.axis2.engine.Handler;
+import org.apache.axis2.engine.Phase;
+import org.apache.axis2.handlers.AbstractHandler;
+import org.apache.axis2.transport.TransportUtils;
+import org.apache.axis2.util.ObjectStateUtils;
+import org.apache.axis2.util.MetaDataEntry;
+import org.apache.axis2.util.SelfManagedDataHolder;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.apache.neethi.Policy;
 
 import javax.activation.DataHandler;
 import javax.xml.namespace.QName;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutput;
+import java.io.ObjectOutputStream;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedHashMap;
 import java.util.LinkedList;
 import java.util.Map;
+import java.util.Set;
+import java.util.StringTokenizer;
 
 /**
  * MessageContext holds service specific state information.
  */
-public class MessageContext extends AbstractContext {
+public class MessageContext extends AbstractContext implements Externalizable {
 
+    /*
+     * setup for logging
+     */
+    private static final Log log = LogFactory.getLog(MessageContext.class);
+
+    private static final String myClassName = "MessageContext";
+
+    /**
+     * @serial The serialization version ID tracks the version of the class.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. If a change to the class is made which is
+     * not compatible with the serialization/externalization of the class,
+     * then the serialization version ID should be updated.
+     * Refer to the "serialVer" utility to compute a serialization
+     * version ID.
+     */
+    private static final long serialVersionUID = -7753637088257391858L;
+
+    /**
+     * @serial Tracks the revision level of a class to identify changes to the 
+     * class definition that are compatible to serialization/externalization.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. 
+     * Refer to the writeExternal() and readExternal() methods.
+     */
+    // supported revision levels, add a new level to manage compatible changes
+    private static final int REVISION_1 = 1;
+    // current revision level of this object
+    private static final int revisionID = REVISION_1;
+
+
+
+    /**
+     * @serial Options on the message
+     */
     protected Options options;
 
+
     public final static int IN_FLOW = 1;
     public final static int IN_FAULT_FLOW = 3;
 
@@ -58,9 +132,17 @@
 
     public static final String TRANSPORT_HEADERS = "TRANSPORT_HEADERS";
     
-    public Attachments attachments = new Attachments();
 
     /**
+     * message attachments
+     * NOTE: Serialization of message attachments is handled as part of the
+     *       overall message serialization.  If this needs to change, then
+     *       investigate having the Attachment class implement the 
+     *       java.io.Externalizable interface.
+     */
+    public transient Attachments attachments = new Attachments();
+
+    /**
      * Field TRANSPORT_OUT
      */
     public static final String TRANSPORT_OUT = "TRANSPORT_OUT";
@@ -98,8 +180,10 @@
      */
     public static final String DEFAULT_CHAR_SET_ENCODING = UTF_8;
 
-    // to keep a ref to figure out which path your are in the execution (send or
-    // receive)
+    /**
+     * @serial The direction flow in use to figure out which path the message is in
+     * (send or receive)
+     */
     public int FLOW = IN_FLOW;
 
     /**
@@ -110,102 +194,303 @@
     public static final String TRANSPORT_NON_BLOCKING = "transportNonBlocking";
 
     /**
-     * Field processingFault
+     * @serial processingFault
      */
     private boolean processingFault;
 
+    /**
+     * @serial paused
+     */
     private boolean paused;
 
+    /**
+     * @serial outputWritten
+     */
     public boolean outputWritten;
 
     /**
-     * Field newThreadRequired
+     * @serial newThreadRequired
      */
     private boolean newThreadRequired;
 
+    /**
+     * @serial isSOAP11
+     */
     private boolean isSOAP11 = true;
 
     /**
-     * The chain of Handlers/Phases for processing this message
+     * @serial The chain of Handlers/Phases for processing this message
      */
     private ArrayList executionChain = new ArrayList();
 
+    /**
+     * @serial The chain of executed Handlers/Phases from inbound processing
+     */
     private LinkedList inboundExecutedPhases = new LinkedList();
+
+    /**
+     * @serial The chain of executed Handlers/Phases from outbound processing
+     */
     private LinkedList outboundExecutedPhases = new LinkedList();
 
-    // Are we doing REST now?
+    /**
+     * @serial Flag to indicate if we are doing REST
+     */
     private boolean doingREST;
 
-    // Are we doing MTOM now?
+    /**
+     * @serial Flag to indicate if we are doing MTOM
+     */
     private boolean doingMTOM;
     
-    // Are we doing SwA now?
+    /**
+     * @serial Flag to indicate if we are doing SWA
+     */
     private boolean doingSwA;
 
+    /**
+     * AxisMessage associated with this message context
+     */
     private transient AxisMessage axisMessage;
 
+    /**
+     * AxisOperation associated with this message context
+     */
     private transient AxisOperation axisOperation;
 
+    /**
+     * AxisService
+     */
     private transient AxisService axisService;
 
+    /**
+     * AxisServiceGroup
+     * <P>
+     * Note the service group can be set independently of the service
+     * so the service might not match up with this serviceGroup
+     */
     private transient AxisServiceGroup axisServiceGroup;
 
-    private ConfigurationContext configurationContext;
+    /**
+     * ConfigurationContext
+     */
+    private transient ConfigurationContext configurationContext;
 
     /**
-     * Index into the execution chain of the currently executing handler
+     * @serial Index into the executuion chain of the currently executing handler
      */
     private int currentHandlerIndex;
 
     /**
-     * Index into the current Phase of the currently executing handler (if any)
+     * @serial Index into the current Phase of the currently executing handler (if any)
      */
     private int currentPhaseIndex;
 
     /**
-     * Field service
+     * @serial SOAP envelope
      */
+    private SOAPEnvelope envelope;
 
     /**
-     * Field envelope
+     * @serial OperationContext
      */
-    private SOAPEnvelope envelope;
-
     private OperationContext operationContext;
 
     /**
-     * Field responseWritten
+     * @serial responseWritten
      */
     private boolean responseWritten;
 
     /**
-     * Field serverSide
+     * @serial serverSide
      */
     private boolean serverSide;
 
+    /**
+     * @serial ServiceContext
+     */
     private ServiceContext serviceContext;
 
+    /**
+     * @serial service context ID
+     */
     private String serviceContextID;
 
+    /**
+     * @serial service group context
+     */
     private ServiceGroupContext serviceGroupContext;
 
     /**
-     * This will hold a key to retrieve the correct ServiceGroupContext.
+     * @serial Holds a key to retrieve the correct ServiceGroupContext.
      */
     private String serviceGroupContextId;
 
     /**
-     * Field sessionContext
+     * @serial sessionContext
      */
     private SessionContext sessionContext;
 
+
+    /**
+     * transport out description
+     */
     private transient TransportOutDescription transportOut;
+
+    /**
+     * transport in description
+     */
     private transient TransportInDescription transportIn;
 
+
+    /**
+     * @serial incoming transport name
+     */
     //The value will be set by the transport receiver and there will be validation for the transport
     //at the dispatch phase (its post condition)
     private String incomingTransportName;
 
+
+    /*
+     * SelfManagedData will hold message-specific data set by handlers 
+     * Note that this list is not explicitly saved by the MessageContext, but
+     * rather through the SelfManagedDataManager interface implemented by handlers
+     */
+    private transient LinkedHashMap selfManagedDataMap = null;
+    
+
+    //-------------------------------------------------------------------------
+    // MetaData for data to be restored in activate() after readExternal()
+    //-------------------------------------------------------------------------
+    
+    /**
+     * Indicates whether the message context has been reconstituted
+     * and needs to have its object references reconciled
+     */
+    private transient boolean needsToBeReconciled = false;
+
+    /**
+     * selfManagedDataHandlerCount is a count of the number of handlers
+     * that actually saved data during serialization
+     */
+    private transient int selfManagedDataHandlerCount = 0;
+    
+    /**
+     * SelfManagedData cannot be restored until the configurationContext
+     * is available, so we have to hold the data from readExternal until
+     * activate is called.
+     */
+    private transient ArrayList selfManagedDataListHolder = null;
+
+    /**
+     * The ordered list of metadata for handlers/phases 
+     * used during re-constitution of the message context
+     */
+    private transient ArrayList metaExecutionChain = null;
+    
+    /**
+     * The ordered list of metadata for inbound executed phases 
+     * used during re-constitution of the message context
+     */
+    private transient LinkedList metaInboundExecuted = null;
+    
+    /**
+     * The ordered list of metadata for outbound executed phases 
+     * used during re-constitution of the message context
+     */
+    private transient LinkedList metaOutboundExecuted = null;
+    
+    /**
+     * Index into the executuion chain of the currently executing handler
+     */
+    private transient int metaHandlerIndex = 0;
+
+    /**
+     * Index into the current Phase of the currently executing handler (if any)
+     */
+    private transient int metaPhaseIndex = 0;
+
+    /**
+     * The AxisOperation metadata will be used during
+     * activate to match up with an existing object
+     */
+    private transient MetaDataEntry metaAxisOperation = null;
+    
+    /**
+     * The AxisService metadata will be used during
+     * activate to match up with an existing object
+     */
+    private transient MetaDataEntry metaAxisService = null;
+    
+    /**
+     * The AxisServiceGroup metadata will be used during
+     * activate to match up with an existing object
+     */
+    private transient MetaDataEntry metaAxisServiceGroup = null;
+    
+    /**
+     * The OperationContext metadata will be used during
+     * activate to finish restoring the object
+     */
+    private transient OperationContext metaOperationContext = null;
+    
+    /**
+     * The ServiceContext metadata will be used during
+     * activate to finish restoring the object, if needed
+     */
+    private transient ServiceContext metaServiceContext = null;
+    
+    /**
+     * The ServiceGroupContext metadata will be used during
+     * activate to finish restoring the object, if needed
+     */
+    private transient ServiceGroupContext metaServiceGroupContext = null;
+    
+    /**
+     * The TransportOutDescription metadata will be used during
+     * activate to match up with an existing object
+     */
+    private transient MetaDataEntry metaTransportOut = null;
+    
+    /**
+     * The TransportInDescription metadata will be used during
+     * activate to match up with an existing object
+     */
+    private transient MetaDataEntry metaTransportIn = null;
+    
+    /**
+     * The AxisMessage metadata will be used during
+     * activate to match up with an existing object
+     */
+    private transient MetaDataEntry metaAxisMessage = null;
+    
+    /**
+     * Indicates whether this message context has an 
+     * AxisMessage object associated with it that needs to 
+     * be reconciled
+     */
+    private transient boolean reconcileAxisMessage = false;
+    
+    /**
+     * Indicates whether the inbound executed phase list
+     * was reset before the restored list has been reconciled
+     */
+    private transient boolean inboundReset = false;
+    
+    /**
+     * Indicates whether the outbound executed phase list
+     * was reset before the restored list has been reconciled
+     */
+    private transient boolean outboundReset = false;
+    
+    //----------------------------------------------------------------
+    // end MetaData section
+    //----------------------------------------------------------------
+
+
+    /**
+     * Constructor
+     */
     public MessageContext() {
         super(null);
         options = new Options();
@@ -219,18 +504,51 @@
     }
 
     public AxisOperation getAxisOperation() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getAxisOperation(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getAxisOperation(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return axisOperation;
     }
 
     public AxisService getAxisService() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getAxisService(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getAxisService(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return axisService;
     }
 
+    /*
+     * <P>
+     * Note the service group can be set independently of the service
+     * so the service might not match up with this serviceGroup
+    */
     public AxisServiceGroup getAxisServiceGroup() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getAxisServiceGroup(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getAxisServiceGroup(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return axisServiceGroup;
     }
 
     public ConfigurationContext getConfigurationContext() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getConfigurationContext(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getConfigurationContext(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return configurationContext;
     }
 
@@ -250,6 +568,13 @@
     }
 
     public ArrayList getExecutionChain() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getExecutionChain(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getExecutionChain(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return executionChain;
     }
 
@@ -260,16 +585,43 @@
      */
     public void addInboundExecutedPhase(Handler phase)
     {
-      inboundExecutedPhases.addFirst(phase); 
+        if (inboundExecutedPhases == null)
+        {
+            inboundExecutedPhases = new LinkedList();
+        }
+        inboundExecutedPhases.addFirst(phase); 
     }
     
     /**
+     * Remove the first Phase in the collection of executed phases for the
+     * inbound path.
+     */
+    public void removeFirstInboundExecutedPhase()
+    {
+      if (inboundExecutedPhases != null)
+      {
+        inboundExecutedPhases.removeFirst();
+      }
+    }
+
+    /**
      * Get an iterator over the inbound executed phase list.
      * @return An Iterator over the LIFO data structure.
      */
     public Iterator getInboundExecutedPhases()
     {
-      return inboundExecutedPhases.iterator();
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getInboundExecutedPhases(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getInboundExecutedPhases(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
+        if (inboundExecutedPhases == null)
+        {
+            inboundExecutedPhases = new LinkedList();
+        }
+        return inboundExecutedPhases.iterator();
     }
       
     /**
@@ -280,7 +632,8 @@
      */
     public void resetInboundExecutedPhases()
     {
-      inboundExecutedPhases = new LinkedList();
+        inboundReset = true;
+        inboundExecutedPhases = new LinkedList();
     }
     
     /**
@@ -290,16 +643,43 @@
      */
     public void addOutboundExecutedPhase(Handler phase)
     {
-      outboundExecutedPhases.addFirst(phase); 
+        if (outboundExecutedPhases == null)
+        {
+            outboundExecutedPhases = new LinkedList();
+        }
+        outboundExecutedPhases.addFirst(phase); 
     }
     
     /**
+     * Remove the first Phase in the collection of executed phases for the
+     * outbound path.
+     */
+    public void removeFirstOutboundExecutedPhase()
+    {
+      if (outboundExecutedPhases != null)
+      {
+        outboundExecutedPhases.removeFirst();
+      }
+    }
+
+    /**
      * Get an iterator over the outbound executed phase list.
      * @return An Iterator over the LIFO data structure.
      */
     public Iterator getOutboundExecutedPhases()
     {
-      return outboundExecutedPhases.iterator();
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getOutboundExecutedPhases(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getOutboundExecutedPhases(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
+        if (outboundExecutedPhases == null)
+        {
+            outboundExecutedPhases = new LinkedList();
+        }
+        return outboundExecutedPhases.iterator();
     }
     
     /**
@@ -310,7 +690,8 @@
      */
     public void resetOutboundExecutedPhases()
     {
-      outboundExecutedPhases = new LinkedList();
+        outboundReset = true;
+        outboundExecutedPhases = new LinkedList();
     }
       
     /**
@@ -465,6 +846,13 @@
     }
 
     public OperationContext getOperationContext() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getOperationContext(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getOperationContext(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return operationContext;
     }
 
@@ -525,6 +913,13 @@
      * @return the value of the property, or null if the property is not found
      */
     public Object getProperty(String name) {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getProperty(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getProperty(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         // search in my own options
         Object obj = options.getProperty(name);
         if (obj != null) {
@@ -618,6 +1013,13 @@
      * @return Returns ServiceContext.
      */
     public ServiceContext getServiceContext() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getServiceContext(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getServiceContext(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return serviceContext;
     }
 
@@ -629,6 +1031,13 @@
     }
 
     public ServiceGroupContext getServiceGroupContext() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getServiceGroupContext(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getServiceGroupContext(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return serviceGroupContext;
     }
 
@@ -666,6 +1075,13 @@
      * @return Returns TransportInDescription.
      */
     public TransportInDescription getTransportIn() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getTransportIn(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getTransportIn(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return transportIn;
     }
 
@@ -673,6 +1089,13 @@
      * @return Returns TransportOutDescription.
      */
     public TransportOutDescription getTransportOut() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getTransportOut(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getTransportOut(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return transportOut;
     }
 
@@ -752,6 +1175,13 @@
     }
 
     public AxisMessage getAxisMessage() {
+        if (reconcileAxisMessage) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getAxisMessage(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getAxisMessage(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return axisMessage;
     }
 
@@ -765,9 +1195,15 @@
 
     public void setAxisService(AxisService axisService) {
         this.axisService = axisService;
-        this.axisServiceGroup = (AxisServiceGroup) this.axisService.getParent();
+        if (this.axisService != null)
+        	this.axisServiceGroup = (AxisServiceGroup)this.axisService.getParent();
+        else
+        	this.axisServiceGroup = null;
     }
 
+    /*
+     * note setAxisServiceGroup() does not verify that the service is associated with the service group!
+     */
     public void setAxisServiceGroup(AxisServiceGroup axisServiceGroup) {
         if (axisServiceGroup != null) {
             this.axisServiceGroup = axisServiceGroup;
@@ -999,7 +1435,7 @@
     }
 
     /**
-     * Method getExecutionChain
+     * setWSAAction
      */
     public void setWSAAction(String actionURI) {
         options.setAction(actionURI);
@@ -1019,6 +1455,13 @@
     }
 
     public Options getOptions() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getOptions(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getOptions(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         return options;
     }
 
@@ -1048,6 +1491,13 @@
 
 
     public Policy getEffectivePolicy() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getEffectivePolicy(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getEffectivePolicy(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         if (axisMessage != null) {
             return axisMessage.getPolicyInclude().getEffectivePolicy();
         }
@@ -1062,6 +1512,13 @@
 
 
     public boolean isEngaged(QName moduleName) {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":isEngaged(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":isEngaged(): ****WARNING**** MessageContext.activate(configurationContext) needs to be invoked.");
+        }
+
         boolean enegage;
         if (configurationContext != null) {
             AxisConfiguration axisConfig = configurationContext.getAxisConfiguration();
@@ -1143,4 +1600,2763 @@
 	public DataHandler getAttachment(String contentID) {
 		return attachments.getDataHandler(contentID);
 	}
+
+
+
+    
+    /* ===============================================================
+     * SelfManagedData Section
+     * ===============================================================
+     */
+    
+    /*
+     * character to delimit strings
+     */
+    private static final String selfManagedDataDelimiter = "*";
+    
+
+    /**
+     * Set up a unique key in the form of
+     * <OL>
+     * <LI>the class name for the class that owns the key
+     * <LI>delimitor
+     * <LI>the key as a string
+     * <LI>delimitor
+     * <LI>the key's hash code as a string
+     * </OL>
+     * 
+     * @param clazz  The class that owns the supplied key
+     * @param key    The key
+     * 
+     * @return A string key
+     */
+    private String generateSelfManagedDataKey(Class clazz, Object key) 
+    {
+    	return clazz.getName()+selfManagedDataDelimiter+key.toString()+selfManagedDataDelimiter+Integer.toString(key.hashCode());
+    }
+    
+    /**
+     * Get the class name from the key generated by generateSelfManagedDataKey()
+     * 
+     * @param key    The key
+     * 
+     * @return The class name
+     */
+    private String getClassNameFromSelfManagedDataKey(String key) 
+    {
+    	StringTokenizer tokenizer = new StringTokenizer(key, selfManagedDataDelimiter);
+    	return tokenizer.nextToken();
+    }
+    
+    /**
+     * Add a key-value pair of self managed data to the set associated with 
+     * this message context.  
+     * <P>
+     * This is primarily intended to allow handlers to manage their own 
+     * message-specific data when the message context is saved/restored.
+     * 
+     * @param clazz   The class of the caller that owns the key-value pair
+     * @param key     The key for this data object
+     * @param value   The data object 
+     */
+    public void setSelfManagedData(Class clazz, Object key, Object value)
+    {
+    	if (selfManagedDataMap == null)
+        {
+    		selfManagedDataMap = new LinkedHashMap();
+    	}
+
+    	// make sure we have a unique key and a delimiter so we can
+    	// get the classname and hashcode for serialization/deserialization
+    	selfManagedDataMap.put(generateSelfManagedDataKey(clazz, key), value);
+    }
+    
+    /**
+     * Retrieve a value of self managed data previously saved with the specified key.
+     * 
+     * @param clazz  The class of the caller that owns the key-value pair
+     * @param key    The key for the data
+     *
+     * @return The data object associated with the key, or NULL if not found
+     */
+    public Object getSelfManagedData(Class clazz, Object key)
+    {
+    	if (selfManagedDataMap != null)
+        {
+    		return selfManagedDataMap.get(generateSelfManagedDataKey(clazz, key));
+        }
+    	return null;
+    }
+    
+    /**
+     * Check to see if the key for the self managed data is available
+     *
+     * @param clazz  The class of the caller that owns the key-value pair
+     * @param key    The key to look for 
+     *
+     * @return TRUE if the key exists, FALSE otherwise
+     */
+    public boolean containsSelfManagedDataKey(Class clazz, Object key)
+    {
+    	if (selfManagedDataMap != null)
+        {
+    		return selfManagedDataMap.containsKey(generateSelfManagedDataKey(clazz, key));
+        }
+    	return false;
+    }
+    
+    /**
+     * Removes the mapping of the specified key if the specified key 
+     * has been set for self managed data
+     * 
+     * @param clazz   The class of the caller that owns the key-value pair
+     * @param key     The key of the object to be removed 
+     */
+    public void removeSelfManagedData(Class clazz, Object key) 
+    {
+    	if (selfManagedDataMap != null)
+        {
+    		selfManagedDataMap.remove(generateSelfManagedDataKey(clazz, key));
+        }
+    }
+    
+    /**
+     * Flatten the phase list into a list of just unique handler instances
+     *
+     * @param list   the list of handlers
+     * @param map    users should pass null as this is just a holder for the recursion
+     *
+     * @return a list of unigue object instances
+     */
+    private ArrayList flattenPhaseListToHandlers(ArrayList list, LinkedHashMap map)
+    {
+    	
+    	if (map == null)
+        {
+    		map = new LinkedHashMap();
+        }
+    	
+        Iterator it = list.iterator();
+		while( it.hasNext() )
+        {
+			Handler handler = (Handler)it.next();
+
+            String key = null;
+            if (handler != null)
+            {
+                key = handler.getClass().getName() +"@"+ handler.hashCode();
+            }
+
+			if (handler instanceof Phase)
+            {
+                // add its handlers to the list
+				flattenHandlerList(((Phase)handler).getHandlers(), map);
+            }
+			else
+            {
+                // if the same object is already in the list,
+                // then it won't be in the list multiple times
+				map.put(key, handler);
+            }
+		}
+		
+		return new ArrayList(map.values());
+    }
+
+
+    /**
+     * Flatten the handler list into just unique handler instances
+     * including phase instances.
+     *
+     * @param list   the list of handlers/phases
+     * @param map    users should pass null as this is just a holder for the recursion
+     *
+     * @return a list of unigue object instances
+     */
+    private ArrayList flattenHandlerList(ArrayList list, LinkedHashMap map)
+    {
+    	
+    	if (map == null)
+        {
+    		map = new LinkedHashMap();
+        }
+    	
+        Iterator it = list.iterator();
+		while( it.hasNext() )
+        {
+			Handler handler = (Handler)it.next();
+
+            String key = null;
+            if (handler != null)
+            {
+                key = handler.getClass().getName() +"@"+ handler.hashCode();
+            }
+
+			if (handler instanceof Phase)
+            {
+                // put the phase in the list
+				map.put(key, handler);
+
+                // add its handlers to the list
+				flattenHandlerList(((Phase)handler).getHandlers(), map);
+            }
+			else
+            {
+                // if the same object is already in the list,
+                // then it won't be in the list multiple times
+				map.put(key, handler);
+            }
+		}
+		
+		return new ArrayList(map.values());
+    }
+
+
+    /**
+     * Calls the serializeSelfManagedData() method of each handler that 
+     * implements the <bold>SelfManagedDataManager</bold> interface.
+     * Handlers for this message context are identified via the 
+     * executionChain list.
+     *
+     * @param out The output stream
+	 * 
+	 */
+    private void serializeSelfManagedData(ObjectOutput out) 
+    {
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":serializeSelfManagedData(): BEGIN");
+        }
+        //System.out.println(myClassName+":serializeSelfManagedData(): BEGIN");
+
+
+        selfManagedDataHandlerCount = 0;
+
+        try
+        {
+            if ((selfManagedDataMap == null)
+                || (executionChain == null)
+                || (selfManagedDataMap.size() == 0)
+                || (executionChain.size() == 0))
+            {
+                out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":serializeSelfManagedData(): No data : END");
+                }
+                //System.out.println(myClassName+":serializeSelfManagedData(): No data : END");
+
+                return;
+            }
+
+            // let's create a temporary list with the handler
+            ArrayList flatExecChain = flattenPhaseListToHandlers(executionChain, null);
+
+            ArrayList selfManagedDataHolderList = serializeSelfManagedData(flatExecChain.iterator(), new ArrayList()); 
+
+            if (selfManagedDataHolderList.size() == 0)
+            {
+                out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":serializeSelfManagedData(): No data : END");
+                }
+                //System.out.println(myClassName+":serializeSelfManagedData(): No data : END");
+
+                return;
+            }
+
+            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+
+            // SelfManagedData can be binary so won't be able to treat it as a 
+            // string - need to treat it as a byte []
+
+            // how many handlers actually 
+            // returned serialized SelfManagedData
+            out.writeInt(selfManagedDataHolderList.size()); 
+
+            for (int i = 0; i < selfManagedDataHolderList.size(); i++)
+            {
+                out.writeObject(selfManagedDataHolderList.get(i));
+            }
+
+        }
+        catch (IOException e)
+        {
+            if (log.isTraceEnabled())
+            {
+                log.trace("MessageContext:serializeSelfManagedData(): Exception ["+e.getClass().getName()+"]  description ["+e.getMessage()+"]"); 
+
+                e.printStackTrace();
+            }
+            //System.out.println("MessageContext:serializeSelfManagedData(): Exception ["+e.getClass().getName()+"]  description ["+e.getMessage()+"]"); 
+
+        }
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":serializeSelfManagedData(): END");
+        }
+        //System.out.println(myClassName+":serializeSelfManagedData(): END");
+    }
+    
+
+    /**
+	 * This is the helper method to do the recursion for serializeSelfManagedData()
+     *
+     * @param it                         The Iterator
+     * @param selfManagedDataHolderList  The array list
+	 * 
+	 * @return ArrayList
+	 */
+    private ArrayList serializeSelfManagedData(Iterator it, ArrayList selfManagedDataHolderList)
+    {
+    	try 
+        {
+    		while (it.hasNext())
+            {
+    			Handler handler = (Handler)it.next();
+
+    			if (handler instanceof Phase)
+                {
+    				selfManagedDataHolderList = serializeSelfManagedData(((Phase)handler).getHandlers().iterator(), selfManagedDataHolderList);
+                }
+    			else if (SelfManagedDataManager.class.isAssignableFrom(handler.getClass()))
+                {
+                    // only call the handler's serializeSelfManagedData if it implements SelfManagedDataManager
+
+                    if (log.isTraceEnabled())
+                    {
+                        log.trace("MessageContext:serializeSelfManagedData(): calling handler  ["+handler.getClass().getName()+"]  name ["+handler.getName().toString()+"]   serializeSelfManagedData method");
+                    }
+                    //System.out.println("MessageContext:serializeSelfManagedData(): calling handler  ["+handler.getClass().getName()+"]  name ["+handler.getName().toString()+"]   serializeSelfManagedData method");
+
+
+            		ByteArrayOutputStream baos_fromHandler = ((SelfManagedDataManager)handler).serializeSelfManagedData(this);
+
+            		if (baos_fromHandler != null)
+                    {
+            			baos_fromHandler.close();
+
+            			try
+                        {
+            				SelfManagedDataHolder selfManagedDataHolder = new SelfManagedDataHolder(handler.getClass().getName(), handler.getName().toString(), baos_fromHandler.toByteArray());
+            				selfManagedDataHolderList.add(selfManagedDataHolder);
+            				selfManagedDataHandlerCount++;
+                        }
+            			catch (Exception exc)
+                        {
+            				log.warn("MessageContext:serializeSelfManagedData(): exception ["+exc.getClass().getName()+"]["+exc.getMessage()+"]  in setting up SelfManagedDataHolder object for ["+handler.getClass().getName()+" / "+handler.getName().toString()+"] ");
+
+            				//System.out.println("MessageContext:serializeSelfManagedData(): exception ["+exc.getClass().getName()+"]["+exc.getMessage()+"]  in setting up SelfManagedDataHolder object for ["+handler.getClass().getName()+" / "+handler.getName().toString()+"] ");
+
+            				exc.printStackTrace();
+
+            			}
+            		}
+            	}
+    		}
+
+    		return selfManagedDataHolderList;
+        }
+        catch (Exception ex)
+        {
+        	log.warn("MessageContext:serializeSelfManagedData(): exception ["+ex.getClass().getName()+"]["+ex.getMessage()+"]");
+
+        	//System.out.println("MessageContext:serializeSelfManagedData(): exception ["+ex.getClass().getName()+"]["+ex.getMessage()+"]");
+
+            ex.printStackTrace();
+
+            return null;
+        }
+        
+    }
+    
+    /**
+     * During deserialization, the executionChain will be
+     * re-constituted before the SelfManagedData is restored.
+     * This means the handler instances are already available.
+     * This method lets us find the handler instance from the
+     * executionChain so we can call each one's
+     * deserializeSelfManagedData method.
+     * 
+     * @param it             The iterator from the executionChain object
+     * @param classname      The class name
+     * @param qNameAsString  The QName in string form 
+     *                  
+     * @return SelfManagedDataManager handler
+     */
+    private SelfManagedDataManager deserialize_getHandlerFromExecutionChain(Iterator it, String classname, String qNameAsString)
+    {
+    	SelfManagedDataManager handler_toreturn = null;
+
+    	try 
+        {
+    		while ((it.hasNext()) && (handler_toreturn == null)) 
+            {
+    			Handler handler = (Handler)it.next();
+
+    			if (handler instanceof Phase)
+                {
+    				handler_toreturn = deserialize_getHandlerFromExecutionChain(((Phase)handler).getHandlers().iterator(), classname, qNameAsString);
+    			}
+    			else if ((handler.getClass().getName().equals(classname))
+    					&& (handler.getName().toString().equals(qNameAsString)))
+                {
+    				handler_toreturn = (SelfManagedDataManager)handler;
+    			}
+    		}
+    		return handler_toreturn;
+        }
+    	catch (ClassCastException e) 
+        {
+    		// Doesn't seem likely to happen, but just in case...
+    		// A handler classname in the executionChain matched up with our parameter
+    		// classname, but the existing class in the executionChain is a different
+    		// implementation than the one we saved during serializeSelfManagedData.
+    		// NOTE: the exception gets absorbed!
+
+        	log.warn("MessageContext:deserialize_getHandlerFromExecutionChain(): ClassCastException thrown: " + e.getMessage());
+
+        	//System.out.println("MessageContext:deserialize_getHandlerFromExecutionChain(): ClassCastException thrown: " + e.getMessage());
+
+            e.printStackTrace();
+
+            return null;
+    	}
+    }
+    
+
+    /*
+     * We don't need to create new instances of the handlers
+     * since the executionChain is rebuilt after readExternal().
+     * We just have to find them in the executionChain and
+     * call each handler's deserializeSelfManagedData method.
+     */
+    private void deserializeSelfManagedData() throws IOException
+    {
+    	try 
+        {
+    		for (int i = 0; (selfManagedDataListHolder != null) && (i < selfManagedDataListHolder.size()); i++)
+            {
+    			SelfManagedDataHolder selfManagedDataHolder = (SelfManagedDataHolder)selfManagedDataListHolder.get(i);
+
+    			String classname = selfManagedDataHolder.getClassname();
+    			String qNameAsString = selfManagedDataHolder.getId();
+
+    			SelfManagedDataManager handler = deserialize_getHandlerFromExecutionChain(executionChain.iterator(), classname, qNameAsString);
+
+    			if (handler == null)
+                {
+    				log.warn(myClassName+":deserializeSelfManagedData():  ["+classname+"]  was not found in the executionChain associated with the message context.");
+
+    				//System.out.println(myClassName+":deserializeSelfManagedData():  ["+classname+"]  was not found in the executionChain associated with the message context.");
+
+    				throw new IOException("The class ["+classname+"] was not found in the executionChain associated with the message context.");
+    			}
+
+    			ByteArrayInputStream handlerData = new ByteArrayInputStream(selfManagedDataHolder.getData());
+
+    			// the handler implementing SelfManagedDataManager is responsible for repopulating
+    			// the SelfManagedData in the MessageContext (this)
+
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":deserializeSelfManagedData(): calling handler ["+classname+"] ["+qNameAsString+"]  deserializeSelfManagedData method");
+                }
+    			//System.out.println(myClassName+":deserializeSelfManagedData(): calling handler ["+classname+"] ["+qNameAsString+"]  deserializeSelfManagedData method");
+
+    			handler.deserializeSelfManagedData(handlerData, this);
+    			handler.restoreTransientData(this);
+    		}
+        }
+    	catch (IOException ioe)
+        {
+        	log.warn(myClassName+":deserializeSelfManagedData(): IOException thrown: " + ioe.getMessage());
+
+        	//System.out.println(myClassName+":deserializeSelfManagedData(): IOException thrown: " + ioe.getMessage());
+
+            ioe.printStackTrace();
+
+    		throw ioe;
+    	}
+    	
+    }
+
+
+
+    /* ===============================================================
+     * Externalizable support 
+     * ===============================================================
+     */
+    
+
+    /**
+     * Save the contents of this MessageContext instance.
+     * <p>
+     * NOTE: Transient fields and static fields are not saved.
+     *       Also, objects that represent "static" data are
+     *       not saved, except for enough information to be
+     *       able to find matching objects when the message
+     *       context is re-constituted.
+     *
+     * @param out    The stream to write the object contents to
+     * 
+     * @exception IOException
+     */
+    public void writeExternal(ObjectOutput out) throws IOException
+    {
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":writeExternal():  BEGIN  ");
+        }
+        //System.out.println(myClassName+":writeExternal():  BEGIN  ");
+
+
+        //---------------------------------------------------------
+        // in order to handle future changes to the message 
+        // context definition, be sure to maintain the 
+        // object level identifiers
+        //---------------------------------------------------------
+        // serialization version ID
+        out.writeLong(serialVersionUID);
+
+        // revision ID
+        out.writeInt(revisionID);
+
+        //---------------------------------------------------------
+        // various simple fields
+        //---------------------------------------------------------
+
+        // the type of execution flow for the message context
+        out.writeInt(FLOW);
+
+        // various flags
+        out.writeBoolean(processingFault);
+        out.writeBoolean(paused);
+        out.writeBoolean(outputWritten);
+        out.writeBoolean(newThreadRequired);
+        out.writeBoolean(isSOAP11);
+        out.writeBoolean(doingREST);
+        out.writeBoolean(doingMTOM);
+        out.writeBoolean(doingSwA);
+        out.writeBoolean(responseWritten);
+        out.writeBoolean(serverSide);
+
+        out.writeLong(getLastTouchedTime());
+
+        boolean persistWithOptimizedMTOM = (getProperty(MTOMConstants.ATTACHMENTS) != null);
+        out.writeBoolean(persistWithOptimizedMTOM);
+        
+        //---------------------------------------------------------
+        // message
+        //---------------------------------------------------------
+
+        // Just in case anything else is added here, notice that in the case
+        // of MTOM, something is written to the stream in middle of the envelope
+        // serialization logic below
+
+        // make sure message attachments are handled
+
+        if (envelope != null)
+        {
+            String msgClass = envelope.getClass().getName();
+
+            ByteArrayOutputStream msgBuffer = new ByteArrayOutputStream();
+
+            try 
+            {
+                // use a non-destructive method on the soap message
+
+                // We don't need to write to a separate byte array
+                // unless we want to log the message
+                ByteArrayOutputStream msgData = new ByteArrayOutputStream();
+
+                OMOutputFormat outputFormat = new OMOutputFormat();
+
+                outputFormat.setSOAP11(isSOAP11);
+
+                if (persistWithOptimizedMTOM)
+                {
+                    outputFormat.setDoOptimize(true);
+
+                    //Notice that we're writing this next bit out to the
+                    //serialized stream and not the baos
+                    out.writeUTF(outputFormat.getContentType());
+                }
+
+                // this will be expensive because it builds the OM tree
+                envelope.serialize(msgData, outputFormat);
+                
+                msgBuffer.write(msgData.toByteArray() ,0, msgData.size());
+
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":writeExternal(): msg data ["+msgData+"]");
+                }
+
+                //System.out.println(myClassName+":writeExternal(): msg data ["+msgData+"]");
+
+            }
+            catch (Exception e) 
+            {
+                log.warn(myClassName+":writeExternal(): can not serialize the SOAP message ***Exception***  ["+e.getClass().getName()+" : "+e.getMessage()+"]");
+
+                //System.out.println(myClassName+":writeExternal(): can not serialize the SOAP message ***Exception***  ["+e.getClass().getName()+" : "+e.getMessage()+"]");
+            }
+
+            //---------------------------------------------
+            // get the character encoding for the message
+            //---------------------------------------------
+            String charSetEnc = (String) getProperty(MessageContext.CHARACTER_SET_ENCODING); 
+
+            if (charSetEnc == null) 
+            {
+                OperationContext opContext = getOperationContext();
+                if (opContext != null)
+                {
+                    charSetEnc = (String) opContext.getProperty(MessageContext.CHARACTER_SET_ENCODING);
+                }
+            }
+
+            if (charSetEnc == null)
+            {
+                charSetEnc = MessageContext.DEFAULT_CHAR_SET_ENCODING;
+            }
+
+            //---------------------------------------------
+            // get the soap namespace uri
+            //---------------------------------------------
+            String namespaceURI = envelope.getNamespace().getName();
+
+
+            // write out the following information, IN ORDER:
+            //           the class name
+            //           the active or empty flag
+            //           the data length
+            //           the data   
+            out.writeUTF(msgClass);
+
+            int msgSize = msgBuffer.size();
+
+            if (msgSize != 0)
+            {
+                out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+                out.writeUTF(charSetEnc);
+                out.writeUTF(namespaceURI);
+                out.writeInt(msgSize);
+                out.write(msgBuffer.toByteArray());
+
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":writeExternal(): msg  charSetEnc=["+charSetEnc+"]  namespaceURI=["+namespaceURI+"]  msgSize=["+msgSize+"]");
+                }
+                //System.out.println(myClassName+":writeExternal(): msg  charSetEnc=["+charSetEnc+"]  namespaceURI=["+namespaceURI+"]  msgSize=["+msgSize+"]");
+            }
+            else
+            {
+                // the envelope is null
+                out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":writeExternal(): msg  is Empty");
+                }
+                //System.out.println(myClassName+":writeExternal(): msg  is Empty");
+            }
+
+            // close out internal stream
+            msgBuffer.close();
+        }
+        else
+        {
+            // the envelope is null
+            out.writeUTF("MessageContext.envelope");
+            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":writeExternal(): msg  is Empty");
+            }
+            //System.out.println(myClassName+":writeExternal(): msg  is Empty");
+        }
+
+
+        //---------------------------------------------------------
+        // ArrayList executionChain 
+        //     handler and phase related data 
+        //---------------------------------------------------------
+        // The strategy is to save some metadata about each
+        // member of the list and the order of the list.
+        // Then when the message context is re-constituted,
+        // try to match up with phases and handlers on the 
+        // engine.
+        //    
+        // Non-null list:
+        //    UTF          - description string
+        //    boolean      - active flag
+        //    int          - current handler index
+        //    int          - current phase index
+        //    int          - expected number of entries in the list
+        //    objects      - MetaDataEntry object per list entry
+        //                        last entry will be empty MetaDataEntry
+        //                        with MetaDataEntry.LAST_ENTRY marker
+        //    int          - adjusted number of entries in the list
+        //                        includes the last empty entry
+        //    
+        // Empty list:
+        //    UTF          - description string
+        //    boolean      - empty flag
+        //---------------------------------------------------------
+        String execChainDesc = "Messagecontext.executionChain";
+
+        int listSize = 0;
+
+        if (executionChain != null)
+        {
+            listSize = executionChain.size();
+        }
+
+        if (listSize > 0)
+        {
+            // start writing data to the output stream
+            out.writeUTF(execChainDesc);
+            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+            out.writeInt(currentHandlerIndex);
+            out.writeInt(currentPhaseIndex);
+            out.writeInt(listSize);
+
+            // put the metadata on each member of the list into a buffer
+
+            // match the current index with the actual saved list
+            int executionChainEntry = 0;
+            int nextIndex = 0;
+
+            Iterator i = executionChain.iterator();
+
+            while (i.hasNext())
+            {
+                Object obj = i.next();
+                String objClass = obj.getClass().getName();
+                int objClassLength = objClass.length();
+
+                // start the meta data entry for this object
+                MetaDataEntry mdEntry = new MetaDataEntry();
+                mdEntry.setClassName(objClass);
+
+                // get the correct object-specific name
+                String qnameAsString = null;
+
+                if (obj instanceof Phase)
+                {
+                    Phase phaseObj = (Phase)obj;
+                    qnameAsString = phaseObj.getName().toString();
+
+                    // add the list of handlers to the meta data
+                    setupPhaseList(phaseObj, mdEntry);
+                }
+                else if (obj instanceof Handler)
+                {
+                    Handler handlerObj = (Handler)obj;
+                    qnameAsString = handlerObj.getName().toString();
+                }
+                else
+                {
+                    // TODO: will there be any other kinds of objects in the execution Chain?
+                    qnameAsString = "NULL";
+                }
+
+                mdEntry.setQName(qnameAsString);
+
+
+                // update the index for the entry in the chain
+                executionChainEntry++;
+
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":writeExternal(): ***BEFORE OBJ WRITE*** executionChain entry class ["+objClass+"] qname ["+qnameAsString+"]");
+                }
+                //System.out.println(myClassName+":writeExternal(): ***BEFORE OBJ WRITE*** executionChain entry class ["+objClass+"] qname ["+qnameAsString+"]");
+
+                ObjectStateUtils.writeObject(out, mdEntry, "Messagecontext.executionChain:entry class ["+objClass+"] qname ["+qnameAsString+"]");
+
+                // update the index so that the index 
+                // now indicates the next entry that
+                // will be attempted
+                nextIndex++;
+
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":writeExternal(): ***AFTER OBJ WRITE*** executionChain entry class ["+objClass+"] qname ["+qnameAsString+"]");
+                }
+                //System.out.println(myClassName+":writeExternal(): ***AFTER OBJ WRITE*** executionChain entry class ["+objClass+"] qname ["+qnameAsString+"]");
+
+            } // end while entries in execution chain
+
+            // done with the entries in the execution chain
+            // add the end-of-list marker
+            MetaDataEntry lastEntry = new MetaDataEntry();
+            lastEntry.setClassName(MetaDataEntry.END_OF_LIST);
+
+            ObjectStateUtils.writeObject(out, lastEntry, "Messagecontext.executionChain:  last entry ");
+            nextIndex++;
+
+            // nextIndex also gives us the number of entries 
+            // that were actually saved as opposed to the 
+            // number of entries in the executionChain
+            out.writeInt(nextIndex);         
+
+        }
+        else
+        {
+            // general case: handle "null" or "empty"
+
+            out.writeUTF(execChainDesc);
+            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":writeExternal(): executionChain is NULL");
+            }
+            //System.out.println(myClassName+":writeExternal(): executionChain is NULL");
+
+        }
+
+
+        //---------------------------------------------------------
+        // LinkedList inboundExecutedPhases 
+        //---------------------------------------------------------
+        // The strategy is to save some metadata about each
+        // member of the list and the order of the list.
+        // Then when the message context is re-constituted,
+        // try to match up with phases and handlers on the 
+        // engine.
+        //    
+        // Non-null list:
+        //    UTF          - description string
+        //    boolean      - active flag
+        //    int          - expected number of entries in the list
+        //    objects      - MetaDataEntry object per list entry
+        //                        last entry will be empty MetaDataEntry
+        //                        with MetaDataEntry.LAST_ENTRY marker
+        //    int          - adjusted number of entries in the list
+        //                        includes the last empty entry
+        //    
+        // Empty list:
+        //    UTF          - description string
+        //    boolean      - empty flag
+        //---------------------------------------------------------
+        String inExecListDesc = "Messagecontext.inboundExecutedPhases";
+
+        int inExecListSize = 0;
+
+        if (inboundExecutedPhases != null)
+        {
+            inExecListSize = inboundExecutedPhases.size();
+        }
+
+        if (inExecListSize > 0)
+        {
+            // start writing data to the output stream
+            out.writeUTF(inExecListDesc);
+            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+            out.writeInt(inExecListSize);
+
+            // put the metadata on each member of the list into a buffer
+
+            int inExecNextIndex = 0;
+
+            Iterator inIterator = inboundExecutedPhases.iterator();
+
+            while (inIterator.hasNext())
+            {
+                Object inObj = inIterator.next();
+                String inObjClass = inObj.getClass().getName();
+                int inObjClassLength = inObjClass.length();
+
+                // start the meta data entry for this object
+                MetaDataEntry inMdEntry = new MetaDataEntry();
+                inMdEntry.setClassName(inObjClass);
+
+                // get the correct object-specific name
+                String inQnameAsString = null;
+
+                if (inObj instanceof Phase)
+                {
+                    Phase inPhaseObj = (Phase)inObj;
+                    inQnameAsString = inPhaseObj.getName().toString();
+
+                    // add the list of handlers to the meta data
+                    setupPhaseList(inPhaseObj, inMdEntry);
+                }
+                else if (inObj instanceof Handler)
+                {
+                    Handler inHandlerObj = (Handler)inObj;
+                    inQnameAsString = inHandlerObj.getName().toString();
+                }
+                else
+                {
+                    // TODO: will there be any other kinds of objects in the list
+                    inQnameAsString = "NULL";
+                }
+
+                inMdEntry.setQName(inQnameAsString);
+
+
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":writeExternal(): ***BEFORE Inbound Executed List OBJ WRITE*** inboundExecutedPhases entry class ["+inObjClass+"] qname ["+inQnameAsString+"]");
+                }
+                //System.out.println(myClassName+":writeExternal(): ***BEFORE Inbound Executed List OBJ WRITE*** inboundExecutedPhases entry class ["+inObjClass+"] qname ["+inQnameAsString+"]");
+
+                ObjectStateUtils.writeObject(out, inMdEntry, "Messagecontext.inboundExecutedPhases:entry class ["+inObjClass+"] qname ["+inQnameAsString+"]");
+
+                // update the index so that the index 
+                // now indicates the next entry that
+                // will be attempted
+                inExecNextIndex++;
+
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":writeExternal(): ***AFTER Inbound Executed List OBJ WRITE*** inboundExecutedPhases entry class ["+inObjClass+"] qname ["+inQnameAsString+"]");
+                }
+                //System.out.println(myClassName+":writeExternal(): ***AFTER Inbound Executed List OBJ WRITE*** inboundExecutedPhases entry class ["+inObjClass+"] qname ["+inQnameAsString+"]");
+
+            } // end while entries in execution chain
+
+            // done with the entries in the execution chain
+            // add the end-of-list marker
+            MetaDataEntry inLastEntry = new MetaDataEntry();
+            inLastEntry.setClassName(MetaDataEntry.END_OF_LIST);
+
+            ObjectStateUtils.writeObject(out, inLastEntry, "Messagecontext.inboundExecutedPhases:  last entry ");
+            inExecNextIndex++;
+
+            // inExecNextIndex also gives us the number of entries 
+            // that were actually saved as opposed to the 
+            // number of entries in the inboundExecutedPhases
+            out.writeInt(inExecNextIndex);         
+
+        }
+        else
+        {
+            // general case: handle "null" or "empty"
+
+            out.writeUTF(inExecListDesc);
+            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":writeExternal(): inboundExecutedPhases is NULL");
+            }
+            //System.out.println(myClassName+":writeExternal(): inboundExecutedPhases is NULL");
+
+        }
+
+
+        //---------------------------------------------------------
+        // LinkedList outboundExecutedPhases 
+        //---------------------------------------------------------
+        // The strategy is to save some metadata about each
+        // member of the list and the order of the list.
+        // Then when the message context is re-constituted,
+        // try to match up with phases and handlers on the 
+        // engine.
+        //    
+        // Non-null list:
+        //    UTF          - description string
+        //    boolean      - active flag
+        //    int          - expected number of entries in the list
+        //    objects      - MetaDataEntry object per list entry
+        //                        last entry will be empty MetaDataEntry
+        //                        with MetaDataEntry.LAST_ENTRY marker
+        //    int          - adjusted number of entries in the list
+        //                        includes the last empty entry
+        //    
+        // Empty list:
+        //    UTF          - description string
+        //    boolean      - empty flag
+        //---------------------------------------------------------
+        String outExecListDesc = "Messagecontext.outboundExecutedPhases";
+
+        int outExecListSize = 0;
+
+        if (outboundExecutedPhases != null)
+        {
+            outExecListSize = outboundExecutedPhases.size();
+        }
+
+        if (outExecListSize > 0)
+        {
+            // start writing data to the output stream
+            out.writeUTF(outExecListDesc);
+            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+            out.writeInt(outExecListSize);
+
+            // put the metadata on each member of the list into a buffer
+
+            int outExecNextIndex = 0;
+
+            Iterator outIterator = outboundExecutedPhases.iterator();
+
+            while (outIterator.hasNext())
+            {
+                Object outObj = outIterator.next();
+                String outObjClass = outObj.getClass().getName();
+                int outObjClassLength = outObjClass.length();
+
+                // start the meta data entry for this object
+                MetaDataEntry outMdEntry = new MetaDataEntry();
+                outMdEntry.setClassName(outObjClass);
+
+                // get the correct object-specific name
+                String outQnameAsString = null;
+
+                if (outObj instanceof Phase)
+                {
+                    Phase outPhaseObj = (Phase)outObj;
+                    outQnameAsString = outPhaseObj.getName().toString();
+
+                    // add the list of handlers to the meta data
+                    setupPhaseList(outPhaseObj, outMdEntry);
+                }
+                else if (outObj instanceof Handler)
+                {
+                    Handler outHandlerObj = (Handler)outObj;
+                    outQnameAsString = outHandlerObj.getName().toString();
+                }
+                else
+                {
+                    // TODO: will there be any other kinds of objects in the list
+                    outQnameAsString = "NULL";
+                }
+
+                outMdEntry.setQName(outQnameAsString);
+
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":writeExternal(): ***BEFORE Outbound Executed List OBJ WRITE*** outboundExecutedPhases entry class ["+outObjClass+"] qname ["+outQnameAsString+"]");
+                }
+                //System.out.println(myClassName+":writeExternal(): ***BEFORE Outbound Executed List OBJ WRITE*** outboundExecutedPhases entry class ["+outObjClass+"] qname ["+outQnameAsString+"]");
+
+                ObjectStateUtils.writeObject(out, outMdEntry, "Messagecontext.outboundExecutedPhases:entry class ["+outObjClass+"] qname ["+outQnameAsString+"]");
+
+                // update the index so that the index 
+                // now indicates the next entry that
+                // will be attempted
+                outExecNextIndex++;
+
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":writeExternal(): ***AFTER Outbound Executed List OBJ WRITE*** outboundExecutedPhases entry class ["+outObjClass+"] qname ["+outQnameAsString+"]");
+                }
+                //System.out.println(myClassName+":writeExternal(): ***AFTER Outbound Executed List OBJ WRITE*** outboundExecutedPhases entry class ["+outObjClass+"] qname ["+outQnameAsString+"]");
+
+            } // end while entries 
+
+            // done with the entries 
+            // add the end-of-list marker
+            MetaDataEntry outLastEntry = new MetaDataEntry();
+            outLastEntry.setClassName(MetaDataEntry.END_OF_LIST);
+
+            ObjectStateUtils.writeObject(out, outLastEntry, "Messagecontext.outboundExecutedPhases:  last entry ");
+            outExecNextIndex++;
+
+            // outExecNextIndex also gives us the number of entries 
+            // that were actually saved as opposed to the 
+            // number of entries in the outboundExecutedPhases
+            out.writeInt(outExecNextIndex);         
+
+        }
+        else
+        {
+            // general case: handle "null" or "empty"
+
+            out.writeUTF(outExecListDesc);
+            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":writeExternal(): outboundExecutedPhases is NULL");
+            }
+            //System.out.println(myClassName+":writeExternal(): outboundExecutedPhases is NULL");
+
+        }
+
+
+        //---------------------------------------------------------
+        // options
+        //---------------------------------------------------------
+        // before saving the Options, make sure there is a message ID
+        String tmpID = getMessageID();
+        if (tmpID == null)
+        {
+            // get an id to use when restoring this object
+            tmpID = org.apache.axis2.util.UUIDGenerator.getUUID();
+            setMessageID(tmpID);
+        }
+
+        if (log.isInfoEnabled())
+        {
+            log.info(myClassName+":writeExternal():   message ID ["+tmpID+"]");
+        }
+        //System.out.println(myClassName+":writeExternal():   message ID ["+tmpID+"]");
+
+        ObjectStateUtils.writeObject(out, options, "MessageContext.options");
+
+
+        //---------------------------------------------------------
+        // operation
+        //---------------------------------------------------------
+        // axis operation 
+        //---------------------------------------------------------
+        String axisOpMarker = "MessageContext.axisOperation";
+        ObjectStateUtils.writeString(out, axisOpMarker, axisOpMarker);
+
+        if (axisOperation == null)
+        {
+        	out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+        }
+        else
+        {
+            // TODO: may need to include the meta data for the axis service that is 
+            //       the parent of the axis operation
+
+        	out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+
+            // make sure the axis operation has a name associated with it
+            QName aoTmpQName = axisOperation.getName();
+
+            if (aoTmpQName == null)
+            {
+                aoTmpQName = new QName(ObjectStateUtils.EMPTY_MARKER);
+                axisOperation.setName(aoTmpQName);
+            }
+
+        	metaAxisOperation = new MetaDataEntry(axisOperation.getClass().getName(), axisOperation.getName().toString());
+        	ObjectStateUtils.writeObject(out, metaAxisOperation, "MessageContext.metaAxisOperation");
+        }
+
+        //---------------------------------------------------------
+        // operation context
+        //---------------------------------------------------------
+        // NOTE: expect this to be the parent of the message context
+        ObjectStateUtils.writeObject(out, operationContext, "MessageContext.operationContext" );
+
+
+        //---------------------------------------------------------
+        // service
+        //---------------------------------------------------------
+        // axis service
+        //-------------------------
+        // this is expected to be the parent of the axis operation object
+        String axisServMarker = "MessageContext.axisService";
+        ObjectStateUtils.writeString(out, axisServMarker, axisServMarker);
+
+        if (axisService == null)
+        {
+        	out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+        }
+        else
+        {
+        	out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+        	metaAxisService = new MetaDataEntry(axisService.getClass().getName(), axisService.getName().toString());
+        	ObjectStateUtils.writeObject(out, metaAxisService, "MessageContext.metaAxisService");
+        }
+        
+
+        //-------------------------
+        // serviceContextID string
+        //-------------------------
+        ObjectStateUtils.writeString(out, serviceContextID, "MessageContext.serviceContextID");
+
+
+        //-------------------------
+        // serviceContext
+        //-------------------------
+        // is this the same as the parent of the OperationContext?
+        boolean isParent = false;
+
+        if (operationContext != null)
+        {
+            ServiceContext opctxParent = operationContext.getServiceContext();
+
+            if (serviceContext != null)
+            {
+                if (serviceContext.equals(opctxParent))
+                {
+                    // the ServiceContext is the parent of the OperationContext
+                    isParent = true;
+                }
+            }
+        }
+
+        String servCtxMarker = "MessageContext.serviceContext";
+        ObjectStateUtils.writeString(out, servCtxMarker, servCtxMarker);
+
+        if (serviceContext == null)
+        {
+        	out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+        }
+        else
+        {
+        	out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+            out.writeBoolean(isParent);
+
+            // only write out the object if it is not the parent
+            if (!isParent)
+            {
+                ObjectStateUtils.writeObject(out, serviceContext, "MessageContext.serviceContext");
+            }
+        }
+
+
+        //---------------------------------------------------------
+        // serviceGroup
+        //---------------------------------------------------------
+
+        String axisServGrpMarker = "MessageContext.axisServiceGroup";
+        ObjectStateUtils.writeString(out, axisServGrpMarker, axisServGrpMarker);
+
+        if (axisServiceGroup == null)
+        {
+        	out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+        }
+        else
+        {
+        	out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+        	metaAxisServiceGroup = new MetaDataEntry(axisServiceGroup.getClass().getName(), axisServiceGroup.getServiceGroupName());
+        	ObjectStateUtils.writeObject(out, metaAxisServiceGroup, "MessageContext.metaAxisServiceGroup");
+        }
+        
+        //-----------------------------
+        // serviceGroupContextId string
+        //-----------------------------
+        ObjectStateUtils.writeString(out, serviceGroupContextId, "MessageContext.serviceGroupContextId");
+
+        
+        //-------------------------
+        // serviceGroupContext
+        //-------------------------
+
+        // is this the same as the parent of the ServiceContext?
+        isParent = false;
+
+        if (serviceContext != null)
+        {
+            ServiceGroupContext srvgrpctxParent = (ServiceGroupContext) serviceContext.getParent();
+
+            if (serviceGroupContext != null)
+            {
+                if (serviceGroupContext.equals(srvgrpctxParent))
+                {
+                    // the ServiceGroupContext is the parent of the ServiceContext
+                    isParent = true;
+                }
+            }
+        }
+
+        String servGrpCtxMarker = "MessageContext.serviceGroupContext";
+        ObjectStateUtils.writeString(out, servGrpCtxMarker, servGrpCtxMarker);
+
+        if (serviceGroupContext == null)
+        {
+        	out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+        }
+        else
+        {
+        	out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+            out.writeBoolean(isParent);
+
+            // only write out the object if it is not the parent
+            if (!isParent)
+            {
+                ObjectStateUtils.writeObject(out, serviceGroupContext, "MessageContext.serviceGroupContext");
+            }
+        }
+
+
+
+        //---------------------------------------------------------
+        // axis message
+        //---------------------------------------------------------
+        String axisMsgMarker = "MessageContext.axisMessage";
+        ObjectStateUtils.writeString(out, axisMsgMarker, axisMsgMarker);
+
+        if (axisMessage == null)
+        {
+        	out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+        }
+        else
+        {
+            // This AxisMessage is expected to belong to the AxisOperation
+            // that has already been recorded for this MessageContext.
+            // If an AxisMessage associated with this Messagecontext is
+            // associated with a different AxisOperation, then more 
+            // meta information would need to be saved
+
+        	out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+
+            // make sure the axis message has a name associated with it
+            String amTmpName = axisMessage.getName();
+
+            if (amTmpName == null)
+            {
+                amTmpName = new String(ObjectStateUtils.EMPTY_MARKER);
+                axisMessage.setName(amTmpName);
+            }
+
+            // get the element name if there is one
+            QName amTmpElementQName = axisMessage.getElementQName();
+            String amTmpElemQNameString = null;
+
+            if (amTmpElementQName != null)
+            {
+                amTmpElemQNameString = amTmpElementQName.toString();
+            }
+
+        	metaAxisMessage = new MetaDataEntry(axisMessage.getClass().getName(), axisMessage.getName(), amTmpElemQNameString);
+
+        	ObjectStateUtils.writeObject(out, metaAxisMessage, "MessageContext.metaAxisMessage");
+        }
+
+        //---------------------------------------------------------
+        // configuration context
+        //---------------------------------------------------------
+
+        // TODO: check to see if there is any runtime data important to this
+        //       message context in the configuration context 
+        //       if so, then need to save that runtime data and reconcile
+        //       it with the configuration context on the system when
+        //       this message context object is restored
+
+
+
+        //---------------------------------------------------------
+        // session context
+        //---------------------------------------------------------
+        ObjectStateUtils.writeObject(out, sessionContext, "MessageContext.sessionContext" );
+        
+
+        //---------------------------------------------------------
+        // transport
+        //---------------------------------------------------------
+
+        //------------------------------
+        // incomingTransportName string
+        //------------------------------
+        ObjectStateUtils.writeString(out, incomingTransportName, "MessageContext.incomingTransportName");
+
+        // TransportInDescription transportIn
+        if (transportIn != null)
+        {
+            metaTransportIn = new MetaDataEntry(null, transportIn.getName().toString());
+        }
+        else
+        {
+            metaTransportIn = null;
+        }
+        ObjectStateUtils.writeObject(out, metaTransportIn, "MessageContext.transportIn");
+
+
+        // TransportOutDescription transportOut
+        if (transportOut != null)
+        {
+            metaTransportOut = new MetaDataEntry(null, transportOut.getName().toString());
+        }
+        else
+        {
+            metaTransportOut = null;
+        }
+        ObjectStateUtils.writeObject(out, metaTransportOut, "MessageContext.transportOut");
+
+
+
+        //---------------------------------------------------------
+        // properties
+        //---------------------------------------------------------
+        Map tmpMap = getProperties();
+
+        HashMap tmpHashMap = null;
+
+        if ((tmpMap != null) && (tmpMap.isEmpty()==false))
+        {
+            tmpHashMap = new HashMap(tmpMap);
+        }
+
+        ObjectStateUtils.writeHashMap(out, tmpHashMap, "MessageContext.properties");
+
+
+        //---------------------------------------------------------
+        // special data
+        //---------------------------------------------------------
+
+        String selfManagedDataMarker = "MessageContext.selfManagedData";
+        ObjectStateUtils.writeString(out, selfManagedDataMarker, selfManagedDataMarker);
+
+        // save the data, which the handlers themselves will serialize
+        //ByteArrayOutputStream baos_fromSelfManagedData = serializeSelfManagedData();
+        serializeSelfManagedData(out);
+
+
+
+        //---------------------------------------------------------
+        // done
+        //---------------------------------------------------------
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":writeExternal():  END  ");
+        }
+        //System.out.println(myClassName+":writeExternal():  END  ");
+
+    }
+
+
+
+
+    /**
+     * Restore the contents of the MessageContext that was 
+     * previously saved. 
+     * <p> 
+     * NOTE: The field data must read back in the same order and type
+     * as it was written.  Some data will need to be validated when 
+     * resurrected.
+     *
+     * @param in    The stream to read the object contents from 
+     * 
+     * @exception IOException
+     * @exception ClassNotFoundException
+     */
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
+    {
+        // set the flag to indicate that the message context is being
+        // reconstituted and will need to have certain object references 
+        // to be reconciled with the current engine setup
+        needsToBeReconciled = true;
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal():  BEGIN  bytes available in stream ["+in.available()+"]  ");
+        }
+        //System.out.println(myClassName+":readExternal():  BEGIN  bytes available in stream ["+in.available()+"]  ");
+
+
+        //---------------------------------------------------------
+        // object level identifiers
+        //---------------------------------------------------------
+
+        // serialization version ID
+        long suid = in.readLong();
+
+        // revision ID
+        int  revID = in.readInt();
+
+        // make sure the object data is in a version we can handle
+        if (suid != serialVersionUID)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+        }
+
+        // make sure the object data is in a revision level we can handle
+        if (revID != REVISION_1)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        }
+
+
+        //---------------------------------------------------------
+        // various simple fields
+        //---------------------------------------------------------
+
+        // the type of execution flow for the message context
+        FLOW = in.readInt();
+
+        // various flags
+        processingFault   = in.readBoolean();
+        paused            = in.readBoolean();
+        outputWritten     = in.readBoolean();
+        newThreadRequired = in.readBoolean();
+        isSOAP11          = in.readBoolean();
+        doingREST         = in.readBoolean();
+        doingMTOM         = in.readBoolean();
+        doingSwA          = in.readBoolean();
+        responseWritten   = in.readBoolean();
+        serverSide        = in.readBoolean();
+
+        long time = in.readLong();
+        setLastTouchedTime(time);
+
+        boolean persistedWithOptimizedMTOM = in.readBoolean();
+        
+        String contentType = null;
+        if (persistedWithOptimizedMTOM)
+        {
+          contentType = in.readUTF();
+        }
+
+        //---------------------------------------------------------
+        // message
+        //---------------------------------------------------------
+
+        String msgDesc = in.readUTF();
+        boolean gotMsg = in.readBoolean();
+
+        if (gotMsg == ObjectStateUtils.ACTIVE_OBJECT)
+        {
+            String charSetEnc = in.readUTF();
+            String namespaceURI = in.readUTF();
+
+            int msgSize = in.readInt();
+            byte [] buffer = new byte [msgSize];
+
+            int bytesRead = 0;
+            int numberOfBytesLastRead = 0;
+
+            while (bytesRead < msgSize)
+            {
+              numberOfBytesLastRead = in.read(buffer, bytesRead, msgSize-bytesRead);
+
+              if (numberOfBytesLastRead == -1)
+              {
+                  // TODO: What should we do if the reconstitution fails?
+                  // For now, log the event
+                  log.warn(myClassName+":readExternal(): ***WARNING*** unexpected end to message   bytesRead ["+bytesRead+"]    msgSize ["+msgSize+"]");
+                  //System.out.println(myClassName+":readExternal(): ***WARNING*** unexpected end to message   bytesRead ["+bytesRead+"]    msgSize ["+msgSize+"]");
+                  break;
+              }
+
+              bytesRead += numberOfBytesLastRead;
+            }
+
+
+            String tmpMsg = new String(buffer);
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":readExternal(): msg  charSetEnc=["+charSetEnc+"]  namespaceURI=["+namespaceURI+"]  msgSize=["+msgSize+"]   bytesRead ["+bytesRead+"]");
+                log.trace(myClassName+":readExternal(): msg  ["+tmpMsg+"]");
+            }
+            //System.out.println(myClassName+":readExternal(): msg  charSetEnc=["+charSetEnc+"]  namespaceURI=["+namespaceURI+"]  msgSize=["+msgSize+"]   bytesRead ["+bytesRead+"]");
+            //System.out.println(myClassName+":readExternal(): msg  ["+tmpMsg+"]");
+
+
+            ByteArrayInputStream msgBuffer = null;
+
+            if (bytesRead > 0)
+            {
+                msgBuffer = new ByteArrayInputStream(buffer);
+
+                // convert what was saved into the soap envelope
+
+                XMLStreamReader xmlreader = null;
+
+                try
+                {
+                    if (persistedWithOptimizedMTOM)
+                    {
+                        boolean isSOAP = true;
+                        StAXBuilder builder = TransportUtils.selectBuilderForMIME(this, msgBuffer,contentType,isSOAP);
+                        envelope = (SOAPEnvelope) builder.getDocumentElement();
+                    }
+                    else
+                    {
+                        xmlreader = StAXUtils.createXMLStreamReader(msgBuffer, charSetEnc); 
+                        StAXBuilder builder = new StAXSOAPModelBuilder(xmlreader, namespaceURI);
+                        envelope = (SOAPEnvelope) builder.getDocumentElement();
+                    }
+                }
+                catch (Exception ex)
+                {
+                    // TODO: what to do if can't get the XML stream reader
+                    // For now, log the event
+                    log.error(myClassName+":readExternal(): Error when deserializing persisted envelope: ["+ex.getClass().getName()+" : "+ex.getLocalizedMessage()+"]");
+                    //System.out.println(myClassName+":readExternal(): Error when deserializing persisted envelope: ["+ex.getClass().getName()+" : "+ex.getLocalizedMessage()+"]");
+                    ex.printStackTrace(System.err);
+                    envelope = null;
+                }
+
+                msgBuffer.close();
+            }
+            else
+            {
+                // no message
+                envelope = null;
+
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":readExternal(): no message from the input stream");
+                }
+                //System.out.println(myClassName+":readExternal(): no message from the input stream");
+            }
+
+        }
+        else
+        {
+            // no message
+            envelope = null;
+
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":readExternal(): no message present");
+            }
+            //System.out.println(myClassName+":readExternal(): no message present");
+        }
+
+
+        //---------------------------------------------------------
+        // ArrayList executionChain 
+        //     handler and phase related data 
+        //---------------------------------------------------------
+        // Restore the metadata about each member of the list
+        // and the order of the list.
+        // This metadata will be used to match up with phases
+        // and handlers on the engine.
+        //    
+        // Non-null list:
+        //    UTF          - description string
+        //    boolean      - active flag
+        //    int          - current handler index
+        //    int          - current phase index
+        //    int          - expected number of entries in the list
+        //                        not including the last entry marker
+        //    objects      - MetaDataEntry object per list entry
+        //                        last entry will be empty MetaDataEntry
+        //                        with MetaDataEntry.LAST_ENTRY marker
+        //    int          - adjusted number of entries in the list
+        //                        includes the last empty entry
+        //    
+        // Empty list:
+        //    UTF          - description string
+        //    boolean      - empty flag
+        //---------------------------------------------------------
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal(): BEGIN EXECUTION CHAIN PROCESSING");
+        }
+        //System.out.println(myClassName+":readExternal(): BEGIN EXECUTION CHAIN PROCESSING");
+
+
+        // the local chain is not enabled until the 
+        // list has been reconstituted
+        executionChain = null;
+        currentHandlerIndex = -1;
+        currentPhaseIndex = 0;
+        metaExecutionChain = null;
+
+        String execChainDesc = in.readUTF();
+        boolean gotChain = in.readBoolean();
+
+        if (gotChain == ObjectStateUtils.ACTIVE_OBJECT)
+        {
+            metaHandlerIndex  = in.readInt();
+            metaPhaseIndex    = in.readInt();
+
+            int expectedNumberEntries = in.readInt();
+
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":readExternal(): execution chain:  expected number of entries ["+expectedNumberEntries+"]");
+            }
+            //System.out.println(myClassName+":readExternal(): execution chain:  expected number of entries ["+expectedNumberEntries+"]");
+
+            // setup the list
+            metaExecutionChain = new ArrayList();
+
+            // process the objects
+            boolean keepGoing = true;
+            int     count     = 0;
+
+            while (keepGoing)
+            {
+                // stop when we get to the end-of-list marker
+
+                // get the object
+                Object tmpObj = ObjectStateUtils.readObject(in, "MessageContext.metaExecutionChain MetaDataEntry"); 
+
+                count++;
+
+                MetaDataEntry mdObj = (MetaDataEntry)tmpObj;
+
+                // get the class name, then add it to the list
+                String tmpClassNameStr = "null";
+                String tmpQNameAsStr   = "null";
+                String tmpHasList      = "no list";
+
+                if (mdObj != null)
+                {
+                    tmpClassNameStr = mdObj.getClassName();
+
+                    if (tmpClassNameStr.equalsIgnoreCase(MetaDataEntry.END_OF_LIST))
+                    {
+                        // this is the last entry
+                        keepGoing = false;
+                    }
+                    else
+                    {
+                        // add the entry to the meta data list
+                        metaExecutionChain.add(mdObj);
+
+                        tmpQNameAsStr   = mdObj.getQNameAsString();
+
+                        if (mdObj.isListEmpty() == false)
+                        {
+                            tmpHasList = "has list";
+                        }
+
+                        if (log.isTraceEnabled())
+                        {
+                            log.trace(myClassName+":readExternal(): meta data class ["+tmpClassNameStr+"] qname ["+tmpQNameAsStr+"]  index ["+count+"]   ["+tmpHasList+"]");
+                        }
+                        //System.out.println(myClassName+":readExternal(): meta data class ["+tmpClassNameStr+"] qname ["+tmpQNameAsStr+"]  index ["+count+"]   ["+tmpHasList+"]");
+                    }
+                }
+                else
+                {
+                    // some error occurred
+                    keepGoing = false;
+                }
+
+            } // end while keep going
+
+            int adjustedNumberEntries = in.readInt();
+
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":readExternal(): adjusted number of entries ExecutionChain ["+adjustedNumberEntries+"]    ");
+            }
+            //System.out.println(myClassName+":readExternal(): adjusted number of entries ExecutionChain ["+adjustedNumberEntries+"]    ");
+        }
+
+        if ((metaExecutionChain == null) || (metaExecutionChain.isEmpty()))
+        {
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":readExternal(): meta data for Execution Chain is NULL");
+            }
+            //System.out.println(myClassName+":readExternal(): meta data for Execution Chain is NULL");
+        }
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal(): END EXECUTION CHAIN PROCESSING");
+        }
+        //System.out.println(myClassName+":readExternal(): END EXECUTION CHAIN PROCESSING");
+
+
+        //---------------------------------------------------------
+        // LinkedList inboundExecutedPhases
+        //---------------------------------------------------------
+        // Restore the metadata about each member of the list
+        // and the order of the list.
+        // This metadata will be used to match up with phases
+        // and handlers on the engine.
+        //    
+        // Non-null list:
+        //    UTF          - description string
+        //    boolean      - active flag
+        //    int          - expected number of entries in the list
+        //                        not including the last entry marker
+        //    objects      - MetaDataEntry object per list entry
+        //                        last entry will be empty MetaDataEntry
+        //                        with MetaDataEntry.LAST_ENTRY marker
+        //    int          - adjusted number of entries in the list
+        //                        includes the last empty entry
+        //    
+        // Empty list:
+        //    UTF          - description string
+        //    boolean      - empty flag
+        //---------------------------------------------------------
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal(): BEGIN Inbound Executed Phases List PROCESSING");
+        }
+        //System.out.println(myClassName+":readExternal(): BEGIN Inbound Executed Phases List PROCESSING");
+
+
+        // the local chain is not enabled until the 
+        // list has been reconstituted
+        inboundExecutedPhases = null;
+        metaInboundExecuted = null;
+
+        String inExecDesc = in.readUTF();
+        boolean gotInExecList = in.readBoolean();
+
+        if (gotInExecList == ObjectStateUtils.ACTIVE_OBJECT)
+        {
+            int expectedNumberInExecList = in.readInt();
+
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":readExternal(): inbound executed phases:  expected number of entries ["+expectedNumberInExecList+"]");
+            }
+            //System.out.println(myClassName+":readExternal(): inbound executed phases:  expected number of entries ["+expectedNumberInExecList+"]");
+
+            // setup the list
+            metaInboundExecuted = new LinkedList();
+
+            // process the objects
+            boolean keepGoing = true;
+            int     count     = 0;
+
+            while (keepGoing)
+            {
+                // stop when we get to the end-of-list marker
+
+                // get the object
+                Object tmpObj = ObjectStateUtils.readObject(in, "MessageContext.metaInboundExecuted MetaDataEntry"); 
+
+                count++;
+
+                MetaDataEntry mdObj = (MetaDataEntry)tmpObj;
+
+                // get the class name, then add it to the list
+                String tmpClassNameStr = "null";
+                String tmpQNameAsStr   = "null";
+                String tmpHasList      = "no list";
+
+                if (mdObj != null)
+                {
+                    tmpClassNameStr = mdObj.getClassName();
+
+                    if (tmpClassNameStr.equalsIgnoreCase(MetaDataEntry.END_OF_LIST))
+                    {
+                        // this is the last entry
+                        keepGoing = false;
+                    }
+                    else
+                    {
+                        // add the entry to the meta data list
+                        metaInboundExecuted.add(mdObj);
+
+                        tmpQNameAsStr   = mdObj.getQNameAsString();
+
+                        if (mdObj.isListEmpty() == false)
+                        {
+                            tmpHasList = "has list";
+                        }
+
+                        if (log.isTraceEnabled())
+                        {
+                            log.trace(myClassName+":readExternal(): meta data class ["+tmpClassNameStr+"] qname ["+tmpQNameAsStr+"]  index ["+count+"]   ["+tmpHasList+"]");
+                        }
+                        //System.out.println(myClassName+":readExternal(): meta data class ["+tmpClassNameStr+"] qname ["+tmpQNameAsStr+"]  index ["+count+"]   ["+tmpHasList+"]");
+                    }
+                }
+                else
+                {
+                    // some error occurred
+                    keepGoing = false;
+                }
+
+            } // end while keep going
+
+            int adjustedNumberInExecList = in.readInt();
+
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":readExternal(): adjusted number of entries InboundExecutedPhases ["+adjustedNumberInExecList+"]    ");
+            }
+            //System.out.println(myClassName+":readExternal(): adjusted number of entries InboundExecutedPhases ["+adjustedNumberInExecList+"]    ");
+        }
+
+        if ((metaInboundExecuted == null) || (metaInboundExecuted.isEmpty()))
+        {
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":readExternal(): meta data for InboundExecutedPhases list is NULL");
+            }
+            //System.out.println(myClassName+":readExternal(): meta data for InboundExecutedPhases list is NULL");
+        }
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal(): END Inbound Executed Phases list PROCESSING");
+        }
+        //System.out.println(myClassName+":readExternal(): END Inbound Executed Phases list PROCESSING");
+
+
+        //---------------------------------------------------------
+        // LinkedList outboundExecutedPhases
+        //---------------------------------------------------------
+        // Restore the metadata about each member of the list
+        // and the order of the list.
+        // This metadata will be used to match up with phases
+        // and handlers on the engine.
+        //    
+        // Non-null list:
+        //    UTF          - description string
+        //    boolean      - active flag
+        //    int          - expected number of entries in the list
+        //                        not including the last entry marker
+        //    objects      - MetaDataEntry object per list entry
+        //                        last entry will be empty MetaDataEntry
+        //                        with MetaDataEntry.LAST_ENTRY marker
+        //    int          - adjusted number of entries in the list
+        //                        includes the last empty entry
+        //    
+        // Empty list:
+        //    UTF          - description string
+        //    boolean      - empty flag
+        //---------------------------------------------------------
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal(): BEGIN Outbound Executed Phases List PROCESSING");
+        }
+        //System.out.println(myClassName+":readExternal(): BEGIN Outbound Executed Phases List PROCESSING");
+
+
+        // the local chain is not enabled until the 
+        // list has been reconstituted
+        outboundExecutedPhases = null;
+        metaOutboundExecuted = null;
+
+        String outExecDesc = in.readUTF();
+        boolean gotOutExecList = in.readBoolean();
+
+        if (gotOutExecList == ObjectStateUtils.ACTIVE_OBJECT)
+        {
+            int expectedNumberOutExecList = in.readInt();
+
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":readExternal(): outbound executed phases:  expected number of entries ["+expectedNumberOutExecList+"]");
+            }
+            //System.out.println(myClassName+":readExternal(): outbound executed phases:  expected number of entries ["+expectedNumberOutExecList+"]");
+
+            // setup the list
+            metaOutboundExecuted = new LinkedList();
+
+            // process the objects
+            boolean keepGoing = true;
+            int     count     = 0;
+
+            while (keepGoing)
+            {
+                // stop when we get to the end-of-list marker
+
+                // get the object
+                Object tmpObj = ObjectStateUtils.readObject(in, "MessageContext.metaOutboundExecuted MetaDataEntry"); 
+
+                count++;
+
+                MetaDataEntry mdObj = (MetaDataEntry)tmpObj;
+
+                // get the class name, then add it to the list
+                String tmpClassNameStr = "null";
+                String tmpQNameAsStr   = "null";
+                String tmpHasList      = "no list";
+
+                if (mdObj != null)
+                {
+                    tmpClassNameStr = mdObj.getClassName();
+
+                    if (tmpClassNameStr.equalsIgnoreCase(MetaDataEntry.END_OF_LIST))
+                    {
+                        // this is the last entry
+                        keepGoing = false;
+                    }
+                    else
+                    {
+                        // add the entry to the meta data list
+                        metaOutboundExecuted.add(mdObj);
+
+                        tmpQNameAsStr   = mdObj.getQNameAsString();
+
+                        if (mdObj.isListEmpty() == false)
+                        {
+                            tmpHasList = "has list";
+                        }
+
+                        if (log.isTraceEnabled())
+                        {
+                            log.trace(myClassName+":readExternal(): OutboundExecutedPhases: meta data class ["+tmpClassNameStr+"] qname ["+tmpQNameAsStr+"]  index ["+count+"]   ["+tmpHasList+"]");
+                        }
+                        //System.out.println(myClassName+":readExternal(): OutboundExecutedPhases: meta data class ["+tmpClassNameStr+"] qname ["+tmpQNameAsStr+"]  index ["+count+"]   ["+tmpHasList+"]");
+                    }
+                }
+                else
+                {
+                    // some error occurred
+                    keepGoing = false;
+                }
+
+            } // end while keep going
+
+            int adjustedNumberOutExecList = in.readInt();
+
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":readExternal(): adjusted number of entries OutboundExecutedPhases ["+adjustedNumberOutExecList+"]    ");
+            }
+            //System.out.println(myClassName+":readExternal(): adjusted number of entries OutboundExecutedPhases ["+adjustedNumberOutExecList+"]    ");
+        }
+
+        if ((metaOutboundExecuted == null) || (metaOutboundExecuted.isEmpty()))
+        {
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+":readExternal(): meta data for OutboundExecutedPhases list is NULL");
+            }
+            //System.out.println(myClassName+":readExternal(): meta data for OutboundExecutedPhases list is NULL");
+        }
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal(): END Outbound Executed Phases list PROCESSING");
+        }
+        //System.out.println(myClassName+":readExternal(): END Outbound Executed Phases list PROCESSING");
+
+
+        //---------------------------------------------------------
+        // options
+        //---------------------------------------------------------
+
+        options = (Options) ObjectStateUtils.readObject(in, "MessageContext.options");
+
+
+        //---------------------------------------------------------
+        // operation
+        //---------------------------------------------------------
+
+        // axisOperation is not usable until the meta data has been reconciled
+        axisOperation = null;
+
+        String axisOpMarker = ObjectStateUtils.readString(in, "MessageContext.axisOperation");
+
+        boolean metaAxisOperationIsActive = in.readBoolean();
+
+        if (metaAxisOperationIsActive == ObjectStateUtils.ACTIVE_OBJECT)
+        {
+        	metaAxisOperation = (MetaDataEntry) ObjectStateUtils.readObject(in, "MessageContext.metaAxisOperation");
+        }
+        else
+        {
+        	metaAxisOperation = null;
+        }
+
+        // operation context is not usable until it has been activated
+        // NOTE: expect this to be the parent
+        operationContext = (OperationContext) ObjectStateUtils.readObject(in, "MessageContext.operationContext");
+
+
+        //---------------------------------------------------------
+        // service
+        //---------------------------------------------------------
+
+        // axisService is not usable until the meta data has been reconciled
+        axisService = null;
+
+        String axisServMarker = ObjectStateUtils.readString(in, "MessageContext.axisService");
+        
+        boolean metaAxisServiceIsActive = in.readBoolean();
+
+        if (metaAxisServiceIsActive == ObjectStateUtils.ACTIVE_OBJECT)
+        {
+        	metaAxisService = (MetaDataEntry) ObjectStateUtils.readObject(in, "MessageContext.metaAxisService");
+        }
+        else
+        {
+        	metaAxisService = null;
+        }
+        
+        
+        //-------------------------
+        // serviceContextID string
+        //-------------------------
+
+        serviceContextID = ObjectStateUtils.readString(in, "MessageContext.serviceContextID");
+
+
+        //-------------------------
+        // serviceContext
+        //-------------------------
+
+        String servCtxMarker = ObjectStateUtils.readString(in, "MessageContext.serviceContext"); 
+        
+        boolean servCtxActive = in.readBoolean();
+
+        if (servCtxActive == ObjectStateUtils.EMPTY_OBJECT)
+        {
+            // empty object
+
+            serviceContext = null;
+        }
+        else
+        {
+            // active object
+
+            boolean isParent = in.readBoolean();
+
+            // there's an object to read in if it is not the parent of the operation context
+            if (!isParent)
+            {
+                serviceContext = (ServiceContext) ObjectStateUtils.readObject(in, "MessageContext.serviceContext");
+            }
+            else
+            {
+                // the service context is the parent of the operation context
+                // so get it from the operation context during activate
+                serviceContext = null;
+            }
+        }
+
+        //---------------------------------------------------------
+        // serviceGroup
+        //---------------------------------------------------------
+
+        // axisServiceGroup is not usable until the meta data has been reconciled
+        axisServiceGroup = null;
+
+        String axisServGrpMarker = ObjectStateUtils.readString(in, "MessageContext.axisServiceGroup");
+        
+        boolean metaAxisServiceGrpIsActive = in.readBoolean();
+
+        if (metaAxisServiceGrpIsActive == ObjectStateUtils.ACTIVE_OBJECT)
+        {
+        	metaAxisServiceGroup = (MetaDataEntry) ObjectStateUtils.readObject(in, "MessageContext.metaAxisServiceGroup");
+        }
+        else
+        {
+        	metaAxisServiceGroup = null;
+        }
+        
+        //-----------------------------
+        // serviceGroupContextId string
+        //-----------------------------
+        serviceGroupContextId = ObjectStateUtils.readString(in, "MessageContext.serviceGroupContextId");
+
+
+        //-----------------------------
+        // serviceGroupContext
+        //-----------------------------
+
+        String servGrpCtxMarker = ObjectStateUtils.readString(in, "MessageContext.serviceGroupContext"); 
+        
+        boolean servGrpCtxActive = in.readBoolean();
+
+        if (servGrpCtxActive == ObjectStateUtils.EMPTY_OBJECT)
+        {
+            // empty object
+
+            serviceGroupContext = null;
+        }
+        else
+        {
+            // active object
+
+            boolean isParentSGC = in.readBoolean();
+
+            // there's an object to read in if it is not the parent of the service group context
+            if (!isParentSGC)
+            {
+                serviceGroupContext = (ServiceGroupContext) ObjectStateUtils.readObject(in, "MessageContext.serviceGroupContext");
+            }
+            else
+            {
+                // the service group context is the parent of the service context
+                // so get it from the service context during activate
+                serviceGroupContext = null;
+            }
+        }
+
+
+
+        //---------------------------------------------------------
+        // axis message
+        //---------------------------------------------------------
+
+        // axisMessage is not usable until the meta data has been reconciled
+        axisMessage = null;
+
+        String axisMsgMarker = ObjectStateUtils.readString(in, "MessageContext.axisMessage");
+
+        boolean metaAxisMessageIsActive = in.readBoolean();
+
+        if (metaAxisMessageIsActive == ObjectStateUtils.ACTIVE_OBJECT)
+        {
+        	metaAxisMessage = (MetaDataEntry) ObjectStateUtils.readObject(in, "MessageContext.metaAxisMessage");
+            reconcileAxisMessage = true;
+        }
+        else
+        {
+        	metaAxisMessage = null;
+            reconcileAxisMessage = false;
+        }
+
+        //---------------------------------------------------------
+        // configuration context
+        //---------------------------------------------------------
+
+        // TODO: check to see if there is any runtime data important to this
+        //       message context in the configuration context 
+        //       if so, then need to restore the saved runtime data and reconcile
+        //       it with the configuration context on the system when
+        //       this message context object is restored
+
+
+        //---------------------------------------------------------
+        // session context
+        //---------------------------------------------------------
+
+        sessionContext = (SessionContext) ObjectStateUtils.readObject(in, "MessageContext.sessionContext" );
+
+
+        //---------------------------------------------------------
+        // transport
+        //---------------------------------------------------------
+
+        //------------------------------
+        // incomingTransportName string
+        //------------------------------
+        incomingTransportName = ObjectStateUtils.readString(in, "MessageContext.incomingTransportName");
+
+        // TransportInDescription transportIn
+        // is not usable until the meta data has been reconciled
+        transportIn = null;
+        metaTransportIn = (MetaDataEntry) ObjectStateUtils.readObject(in, "MessageContext.metaTransportIn");
+
+        // TransportOutDescription transportOut
+        // is not usable until the meta data has been reconciled
+        transportOut = null;
+        metaTransportOut = (MetaDataEntry) ObjectStateUtils.readObject(in, "MessageContext.metaTransportOut");
+
+
+
+        //---------------------------------------------------------
+        // properties
+        //---------------------------------------------------------
+
+        HashMap tmpHashMap = ObjectStateUtils.readHashMap(in,"MessageContext.properties");
+
+        properties = new HashMap();
+        if (tmpHashMap != null)
+        {
+            setProperties(tmpHashMap);
+        }
+
+
+        //---------------------------------------------------------
+        // special data
+        //---------------------------------------------------------
+
+        String selfManagedDataMarker = ObjectStateUtils.readString(in, "MessageContext.selfManagedData");
+
+        boolean gotSelfManagedData = in.readBoolean();
+
+        if (gotSelfManagedData == ObjectStateUtils.ACTIVE_OBJECT)
+        {
+        	selfManagedDataHandlerCount = in.readInt();
+
+        	if (selfManagedDataListHolder == null)
+            {
+        		selfManagedDataListHolder = new ArrayList();
+            }
+        	else
+            {
+        		selfManagedDataListHolder.clear();
+            }
+
+        	for (int i = 0; i < selfManagedDataHandlerCount; i++)
+            {
+        		selfManagedDataListHolder.add(in.readObject());
+            }
+        }
+
+
+        //---------------------------------------------------------
+        // done
+        //---------------------------------------------------------
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":readExternal():  END");
+        }
+        //System.out.println(myClassName+":readExternal():  END");
+
+    }
+
+    
+    /**
+     * This method checks to see if additional work needs to be
+     * done in order to complete the object reconstitution.
+     * Some parts of the object restored from the readExternal()
+     * cannot be completed until we have a configurationContext
+     * from the active engine. The configurationContext is used
+     * to help this object to plug back into the engine's
+     * configuration and deployment objects.
+     * 
+     * @param cc     The configuration context object representing the active configuration
+     */
+    public void activate(ConfigurationContext cc)
+    {
+        // see if there's any work to do
+        if (needsToBeReconciled == false)
+        {
+            // return quick
+            return;
+        }
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":activate():  BEGIN");
+        }
+        //System.out.println(myClassName+":activate():  BEGIN");
+
+        // use the supplied configuration context
+        setConfigurationContext(cc);
+
+        // get the axis configuration 
+        AxisConfiguration axisConfig = configurationContext.getAxisConfiguration();
+
+        // We previously saved metaAxisService; restore it
+        if (metaAxisService != null)
+        {
+        	this.setAxisService(ObjectStateUtils.findService(axisConfig, metaAxisService.getClassName(), metaAxisService.getQNameAsString()));
+        }
+
+        // We previously saved metaAxisServiceGroup; restore it
+        if (metaAxisServiceGroup != null)
+        {
+        	this.setAxisServiceGroup(ObjectStateUtils.findServiceGroup(axisConfig, metaAxisServiceGroup.getClassName(), metaAxisServiceGroup.getQNameAsString()));
+        }
+
+        // We previously saved metaAxisOperation; restore it
+        if (metaAxisOperation != null)
+        {
+            AxisService serv = axisService;
+
+            if (serv != null)
+            {
+                // TODO: check for the empty name 
+                this.setAxisOperation(ObjectStateUtils.findOperation(serv, metaAxisOperation.getClassName(), metaAxisOperation.getQName()));
+            }
+            else
+            {
+                this.setAxisOperation(ObjectStateUtils.findOperation(axisConfig, metaAxisOperation.getClassName(), metaAxisOperation.getQName()));
+            }
+        }
+        
+        // We previously saved metaAxisMessage; restore it
+        if (metaAxisMessage != null)
+        {
+            AxisOperation op = axisOperation;
+
+            if (op != null)
+            {
+                // TODO: check for the empty name 
+                this.setAxisMessage(ObjectStateUtils.findMessage(op, metaAxisMessage.getQNameAsString(), metaAxisMessage.getExtraName()));
+            }
+        }
+        
+        //---------------------------------------------------------------------
+        // operation context
+        //---------------------------------------------------------------------
+        // this will do a full hierarchy, so do it first
+        // then we can re-use its objects
+
+        if (operationContext != null)
+        {
+            operationContext.activate(cc);
+
+            // this will be set as the parent of the message context
+            // after the other context objects have been activated
+        }
+
+        //---------------------------------------------------------------------
+        // service context
+        //---------------------------------------------------------------------
+
+        if (serviceContext == null)
+        {
+            // get the parent serviceContext of the operationContext
+            if (operationContext != null)
+            {
+                serviceContext = operationContext.getServiceContext();
+            }
+        }
+
+        // if we have a service context, make sure it is usable
+        if (serviceContext != null)
+        {
+            // for some reason, the service context might be set differently from
+            // the operation context parent
+            serviceContext.activate(cc);
+        }
+
+        //---------------------------------------------------------------------
+        // service group context
+        //---------------------------------------------------------------------
+
+        if (serviceGroupContext == null)
+        {
+            // get the parent serviceGroupContext of the serviceContext
+            if (serviceContext != null)
+            {
+                serviceGroupContext = (ServiceGroupContext) serviceContext.getParent();
+            }
+        }
+
+        // if we have a service group context, make sure it is usable
+        if (serviceGroupContext != null)
+        {
+            // for some reason, the service group context might be set differently from
+            // the service context parent
+            serviceGroupContext.activate(cc);
+        }
+
+
+        //---------------------------------------------------------------------
+        // other context-related reconciliation
+        //---------------------------------------------------------------------
+
+        this.setParent(operationContext);
+
+
+
+        //---------------------------------------------------------------------
+        // options
+        //---------------------------------------------------------------------
+        if (options != null)
+        {
+            options.activate(cc);
+        }
+
+        String tmpID = getMessageID();
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":activate():   message ID ["+tmpID+"]");
+        }
+        //System.out.println(myClassName+":activate():   message ID ["+tmpID+"]");
+
+
+        //---------------------------------------------------------------------
+        // transports
+        //---------------------------------------------------------------------
+
+        // We previously saved metaTransportIn; restore it
+        if (metaTransportIn != null)
+        {
+            QName qin = metaTransportIn.getQName();
+            TransportInDescription tmpIn = null;
+            try
+            {
+                tmpIn = axisConfig.getTransportIn(qin);
+            }
+            catch (Exception exin)
+            {
+                // if a fault is thrown, log it and continue
+                log.info(myClassName+"activate():  exception caught when getting the TransportInDescription ["+qin.toString()+"]  from the AxisConfiguration ["+exin.getClass().getName()+" : "+exin.getMessage()+"]");
+
+                //System.out.println(myClassName+"activate():  exception caught when getting the TransportInDescription ["+qin.toString()+"]  from the AxisConfiguration ["+exin.getClass().getName()+" : "+exin.getMessage()+"]");
+            }
+
+            if (tmpIn != null)
+            {
+                transportIn = tmpIn;
+            }
+            else
+            {
+                transportIn = null;
+            }
+        }
+        else
+        {
+            transportIn = null;
+        }
+
+        // We previously saved metaTransportOut; restore it
+        if (metaTransportOut != null)
+        {
+            QName qout = metaTransportOut.getQName();
+            TransportOutDescription tmpOut = null;
+            try
+            {
+                tmpOut = axisConfig.getTransportOut(qout);
+            }
+            catch (Exception exout)
+            {
+                // if a fault is thrown, log it and continue
+                log.info(myClassName+"activate():  exception caught when getting the TransportOutDescription ["+qout.toString()+"]  from the AxisConfiguration ["+exout.getClass().getName()+" : "+exout.getMessage()+"]");
+
+                //System.out.println(myClassName+"activate():  exception caught when getting the TransportOutDescription ["+qout.toString()+"]  from the AxisConfiguration ["+exout.getClass().getName()+" : "+exout.getMessage()+"]");
+            }
+
+            if (tmpOut != null)
+            {
+                transportOut = tmpOut;
+            }
+            else
+            {
+                transportOut = null;
+            }
+        }
+        else
+        {
+            transportOut = null;
+        }
+
+
+        //-------------------------------------------------------
+        // reconcile the execution chain
+        //-------------------------------------------------------
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":activate(): reconciling the execution chain...");
+        }
+        //System.out.println(myClassName+":activate(): reconciling the execution chain...");
+
+        currentHandlerIndex = metaHandlerIndex;
+        currentPhaseIndex   = metaPhaseIndex;
+
+        executionChain = restoreHandlerList(metaExecutionChain);
+
+        try
+        {
+            deserializeSelfManagedData();
+        }
+        catch (Exception ex) 
+        {
+            //System.out.println(myClassName+":activate(): *** WARNING *** deserializing the self managed data encountered Exception ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+
+            // log the exception
+            log.warn(myClassName+":activate(): *** WARNING *** deserializing the self managed data encountered Exception ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+            ex.printStackTrace();
+        }
+
+
+        //-------------------------------------------------------
+        // reconcile the lists for the executed phases
+        //-------------------------------------------------------
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":activate(): reconciling the inbound executed chain...");
+        }
+        //System.out.println(myClassName+":activate(): reconciling the inbound executed chain...");
+
+        if (inboundReset == false)
+        {
+            inboundExecutedPhases = restoreExecutedList(inboundExecutedPhases, metaInboundExecuted);
+        }
+
+        if (inboundExecutedPhases == null)
+        {
+            inboundExecutedPhases = new LinkedList();
+        }
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":activate(): reconciling the outbound executed chain...");
+        }
+        //System.out.println(myClassName+":activate(): reconciling the outbound executed chain...");
+
+        if (outboundReset == false)
+        {
+            outboundExecutedPhases = restoreExecutedList(outboundExecutedPhases, metaOutboundExecuted);
+        }
+
+        if (outboundExecutedPhases == null)
+        {
+            outboundExecutedPhases = new LinkedList();
+        }
+
+        //-------------------------------------------------------
+        // done, reset the flag
+        //-------------------------------------------------------
+        needsToBeReconciled = false;
+
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":activate():  END");
+        }
+        //System.out.println(myClassName+":activate():  END");
+    }
+
+
+    /**
+     * 
+     * @param metaDataEntries ArrayList of MetaDataEntry objects
+     * @return ArrayList of Handlers based on our list of handlers from the reconstituted deserialized list, and the existing handlers in the AxisConfiguration object.  May return null.
+     */
+    private ArrayList restoreHandlerList(ArrayList metaDataEntries)
+    {
+    	AxisConfiguration axisConfig = configurationContext.getAxisConfiguration();
+
+    	ArrayList existingHandlers = null;
+
+    	// TODO: I'm using clone for the ArrayList returned from axisConfig object.
+        //     Does it do a deep clone of the Handlers held there?  Does it matter? 
+    	switch (FLOW) 
+        {
+    		case IN_FLOW:
+    			existingHandlers = (ArrayList)axisConfig.getGlobalInFlow().clone();
+    			break;
+
+    		case OUT_FLOW:
+    			existingHandlers = (ArrayList)axisConfig.getGlobalOutPhases().clone();
+    			break;
+
+    		case IN_FAULT_FLOW:
+    			existingHandlers = (ArrayList)axisConfig.getInFaultFlow().clone();
+    			break;
+
+    		case OUT_FAULT_FLOW:
+    			existingHandlers = (ArrayList)axisConfig.getOutFaultFlow().clone();
+    			break;
+    	}
+    	
+        existingHandlers = flattenHandlerList(existingHandlers, null);
+
+    	ArrayList handlerListToReturn = new ArrayList();
+    	
+    	for (int i=0; i < metaDataEntries.size(); i++)
+        {
+    		Handler handler = (Handler) ObjectStateUtils.findHandler(existingHandlers, (MetaDataEntry)metaDataEntries.get(i));
+
+    		if (handler != null)
+            {
+    			handlerListToReturn.add(handler);
+            }
+    	}
+    	
+    	return handlerListToReturn;
+    }
+    
+
+    /**
+     * Using meta data for phases/handlers, create a linked list of actual
+     * phase/handler objects.  The created list is composed of the objects 
+     * from the base list at the top of the created list followed by the 
+     * restored objects.
+     * 
+     * @param base            Linked list of phase/handler objects
+     * @param metaDataEntries Linked list of MetaDataEntry objects
+     * @return LinkedList of objects or NULL if none available
+     */
+    private LinkedList restoreExecutedList(LinkedList base, LinkedList metaDataEntries)
+    {
+        if (metaDataEntries == null)
+        {
+            return base;
+        }
+
+        // get a list of existing handler/phase objects for the restored objects
+
+        ArrayList tmpMetaDataList = new ArrayList((Collection)metaDataEntries);
+
+    	ArrayList existingList = restoreHandlerList(tmpMetaDataList);
+
+        if ((existingList == null) || (existingList.isEmpty()))
+        {
+            return base;
+        }
+
+        // set up a list to return
+
+        LinkedList returnedList = new LinkedList();
+
+        if (base != null)
+        {
+            returnedList.addAll((Collection)base);
+        }
+
+        returnedList.addAll((Collection)existingList);
+
+        return returnedList;
+    }
+    
+
+    /**
+     * Process the list of handlers from the Phase object
+     * into the appropriate meta data.
+     * 
+     * @param pObj The Phase object containing a list of handlers
+     * @param mdEntry  The meta data object associated with the specified Phase object
+     */
+    private void setupPhaseList(Phase phase, MetaDataEntry mdPhase)
+    {
+        // get the list from the phase object
+        ArrayList handlers = phase.getHandlers();
+
+        if (handlers.isEmpty())
+        {
+            // done, make sure there is no list in the given meta data
+            mdPhase.removeList();
+            return;
+        }
+
+        // get the metadata on each member of the list
+
+        int listSize = handlers.size();
+
+        if (listSize > 0)
+        {
+            int nextIndex = 0;
+
+            Iterator i = handlers.iterator();
+
+            while (i.hasNext())
+            {
+                Object obj = i.next();
+                String objClass = obj.getClass().getName();
+                int objClassLength = objClass.length();
+
+                // start the meta data entry for this object
+                MetaDataEntry mdEntry = new MetaDataEntry();
+                mdEntry.setClassName(objClass);
+
+                // get the correct object-specific name
+                String qnameAsString = null;
+
+                if (obj instanceof Phase)
+                {
+                    // nested condition, the phase object contains another phase!
+                    Phase phaseObj = (Phase)obj;
+                    qnameAsString = phaseObj.getName().toString();
+
+                    // add the list of handlers to the meta data
+                    setupPhaseList(phaseObj, mdEntry);
+                }
+                else if (obj instanceof Handler)
+                {
+                    Handler handlerObj = (Handler)obj;
+                    qnameAsString = handlerObj.getName().toString();
+                }
+                else
+                {
+                    // TODO: will there be any other kinds of objects 
+                    // in the list?
+                    qnameAsString = "NULL";
+                }
+
+                mdEntry.setQName(qnameAsString);
+
+                // done with setting up the meta data for the list entry
+                // so add it to the parent
+                mdPhase.addToList(mdEntry);
+
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+":setupPhaseList(): list entry class ["+objClass+"] qname ["+qnameAsString+"]");
+                }
+                //System.out.println(myClassName+":setupPhaseList(): list entry class ["+objClass+"] qname ["+qnameAsString+"]");
+
+            } // end while entries in list
+        }
+        else
+        {
+            // a list with no entries
+            // done, make sure there is no list in the given meta data
+            mdPhase.removeList();
+        }
+    }
+
 }
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/SelfManagedDataManager.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/SelfManagedDataManager.java	(revision 0)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/SelfManagedDataManager.java	(revision 0)
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.context;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+
+/**
+ * An interface for use by a message handler to allow 
+ * it to save and restore any message-specific data.
+ * <P>
+ * A handler can have message-specific data that 
+ * needs to be associated the message being processed.
+ * The handler can keep this message-specific data 
+ * in the Messagecontext object by adding the 
+ * data to the user data table via the 
+ * MessageContext method.  When the MessageContext 
+ * object is saved (for example, to persistent storage),
+ * and restored, this interface <B>SelfManagedDataManager</B>
+ * provides a way for the handler to save and restore
+ * the handler's message-specific data.
+ * 
+ * @see org.apache.axis2.context.MessageContext
+ */
+public interface SelfManagedDataManager {
+
+    /**
+     * This method is invoked when the MessageContext object is being saved.
+     *
+     * Implementors are expected to iterate through the data objects they wish
+     * to save and return it in a ByteArrayOutputStream.  This data will
+     * later be passed to the implementor's deserializeSelfManagedData method when
+     * the data object is to be restored.
+     * 
+     * The data being saved may be the data stored by the implementor
+     * in the MessageContext object's SelfManagedData list and may include
+     * additional information such as the implementor's fields.
+     * Note that data stored by the implementor in the MessageContext object's SelfManagedData
+     * list is retrievable by calling the MessageContext.getSelfManagedData() method
+     * for EACH key/value pair.
+     * 
+     * @param mc     the MessageContext that is being saved
+     * @return The saved data in the output stream. Note that the
+     *         format of the data in the output stream is defined
+     *         by the implementor.
+     * @exception IOException
+     */
+	public ByteArrayOutputStream serializeSelfManagedData(MessageContext mc) throws IOException;
+
+    /**
+     * This method is invoked when the MessageContext object is being restored.
+     *
+     * Implementors will receive the data they had previously saved in the
+     * serializeSelfManagedData() method. Implementors are responsible for
+     * reconstituting their message-specific data.
+     * 
+     * @param data   ByteArrayInputStream consisting of the data that this handler had previously saved
+     * @param mc     the MessageContext object being restored
+     * @exception IOException
+     */
+	public void deserializeSelfManagedData(ByteArrayInputStream data, MessageContext mc) throws IOException;
+
+
+	/**
+     * This method is invoked when the MessageContext object is being restored and
+     * after the deserializeSelfManagedData() method.
+     *
+     * Implementors use this method to re-establish transient message-specific data,
+     * particularly if the implementor did not save any user data in the 
+     * serializeSelfManagedData() method.
+	 * 
+	 * @param mc the MessageContext object being restored
+	 */
+	public void restoreTransientData(MessageContext mc);
+
+}
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/ConfigurationContext.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/ConfigurationContext.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/context/ConfigurationContext.java	(working copy)
@@ -51,8 +51,8 @@
     private final Map operationContextMap = new HashMap();
     private Hashtable serviceGroupContextMap = new Hashtable();
     private Hashtable applicationSessionServiceGroupContextTable = new Hashtable();
-    private transient AxisConfiguration axisConfiguration;
-    private transient ThreadFactory threadPool;
+    private AxisConfiguration axisConfiguration;
+    private ThreadFactory threadPool;
     //To keep TransportManager instance
     private ListenerManager listenerManager;
 
@@ -114,15 +114,21 @@
         if (serviceContext == null) {
             if (Constants.SCOPE_APPLICATION.equals(axisService.getScope())) {
                 String serviceGroupName = ((AxisServiceGroup) axisService.getParent()).getServiceGroupName();
-                serviceGroupContext = (ServiceGroupContext) applicationSessionServiceGroupContextTable.get(
-                        serviceGroupName);
+                serviceGroupContext = null;
+                if (applicationSessionServiceGroupContextTable != null) {
+                    serviceGroupContext = (ServiceGroupContext) applicationSessionServiceGroupContextTable.get(
+                            serviceGroupName);
+                }
                 if (serviceGroupContext == null) {
                     AxisServiceGroup axisServiceGroup = messageContext.getAxisServiceGroup();
                     if (axisServiceGroup == null) {
                         axisServiceGroup = (AxisServiceGroup) messageContext.getAxisService().getParent();
                     }
                     serviceGroupContext = new ServiceGroupContext(messageContext.getConfigurationContext(),
-                            axisServiceGroup);
+                                                                  axisServiceGroup);
+                    if (applicationSessionServiceGroupContextTable == null) {
+                        applicationSessionServiceGroupContextTable = new Hashtable();
+                    }
                     applicationSessionServiceGroupContextTable.put(serviceGroupName, serviceGroupContext);
                 }
                 serviceContext = serviceGroupContext.getServiceContext(axisService);
@@ -200,7 +206,11 @@
     public synchronized void registerServiceGroupContext(ServiceGroupContext serviceGroupContext) {
         String id = serviceGroupContext.getId();
 
-        if (serviceGroupContextMap.get(id) == null) {
+        if (serviceGroupContextMap == null) {
+            serviceGroupContextMap = new Hashtable();
+        }
+
+        if ((serviceGroupContextMap.isEmpty()) || (serviceGroupContextMap.get(id) == null)) {
             serviceGroupContextMap.put(id, serviceGroupContext);
             serviceGroupContext.touch();
             serviceGroupContext.setParent(this);
@@ -212,6 +222,9 @@
 
     public synchronized void addServiceGroupContextintoApplicatoionScopeTable(
             ServiceGroupContext serviceGroupContext) {
+        if (applicationSessionServiceGroupContextTable == null) {
+            applicationSessionServiceGroupContextTable = new Hashtable();
+        }
         applicationSessionServiceGroupContextTable.put(
                 serviceGroupContext.getDescription().getServiceGroupName(), serviceGroupContext);
     }
@@ -226,6 +239,9 @@
      * @return Returns OperationContext <code>OperationContext<code>
      */
     public OperationContext getOperationContext(String id) {
+        if (operationContextMap == null) {
+            return null;
+        }
         return (OperationContext) this.operationContextMap.get(id);
     }
 
@@ -257,8 +273,8 @@
             }
         }
         if (serviceGroupContext == null
-                && msgContext != null
-                && msgContext.getSessionContext() != null) {
+            && msgContext != null
+            && msgContext.getSessionContext() != null) {
             serviceGroupContext = msgContext.getSessionContext().getServiceGroupContext(
                     serviceGroupContextId);
         }
@@ -267,8 +283,10 @@
             if (axisService != null) {
                 AxisServiceGroup asg = (AxisServiceGroup) axisService.getParent();
                 if (asg != null) {
-                    serviceGroupContext = (ServiceGroupContext)
-                            applicationSessionServiceGroupContextTable.get(asg.getServiceGroupName());
+                    if (applicationSessionServiceGroupContextTable != null) {
+                        serviceGroupContext = (ServiceGroupContext)
+                                applicationSessionServiceGroupContextTable.get(asg.getServiceGroupName());
+                    }
                 }
             }
 
@@ -325,6 +343,9 @@
 
     private void cleanupServiceGroupContexts() {
         synchronized (serviceGroupContextMap) {
+            if (serviceGroupContextMap == null) {
+                return;
+            }
             long currentTime = new Date().getTime();
             Iterator sgCtxtMapKeyIter = serviceGroupContextMap.keySet().iterator();
             while (sgCtxtMapKeyIter.hasNext()) {
@@ -349,7 +370,13 @@
     }
 
     private void cleanupServiceContexts(ServiceGroupContext serviceGroupContext) {
+        if (serviceGroupContext == null) {
+            return;
+        }
         Iterator serviceContecxtes = serviceGroupContext.getServiceContexts();
+        if (serviceContecxtes == null) {
+            return;
+        }
         while (serviceContecxtes.hasNext()) {
             ServiceContext serviceContext = (ServiceContext) serviceContecxtes.next();
             try {
@@ -361,20 +388,19 @@
     }
 
     public void cleanupContexts() {
-        if (applicationSessionServiceGroupContextTable.size() > 0) {
-            Iterator applicationScopeSgs =
-                    applicationSessionServiceGroupContextTable.values().iterator();
+        if ((applicationSessionServiceGroupContextTable != null) &&
+            (applicationSessionServiceGroupContextTable.size() > 0)) {
+            Iterator applicationScopeSgs = applicationSessionServiceGroupContextTable.values().iterator();
             while (applicationScopeSgs.hasNext()) {
                 ServiceGroupContext serviceGroupContext =
                         (ServiceGroupContext) applicationScopeSgs.next();
                 cleanupServiceContexts(serviceGroupContext);
             }
         }
-        if (serviceGroupContextMap.size() > 0) {
+        if ((serviceGroupContextMap != null) && (serviceGroupContextMap.size() > 0)) {
             Iterator sopaSessionSgs = serviceGroupContextMap.values().iterator();
             while (sopaSessionSgs.hasNext()) {
-                ServiceGroupContext serviceGroupContext =
-                        (ServiceGroupContext) sopaSessionSgs.next();
+                ServiceGroupContext serviceGroupContext = (ServiceGroupContext) sopaSessionSgs.next();
                 cleanupServiceContexts(serviceGroupContext);
             }
         }
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/engine/AxisEngine.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/engine/AxisEngine.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/engine/AxisEngine.java	(working copy)
@@ -20,7 +20,18 @@
 import org.apache.axiom.om.OMAbstractFactory;
 import org.apache.axiom.om.OMElement;
 import org.apache.axiom.om.OMNamespace;
-import org.apache.axiom.soap.*;
+import org.apache.axiom.soap.SOAP11Constants;
+import org.apache.axiom.soap.SOAP12Constants;
+import org.apache.axiom.soap.SOAPConstants;
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axiom.soap.SOAPFault;
+import org.apache.axiom.soap.SOAPFaultCode;
+import org.apache.axiom.soap.SOAPFaultDetail;
+import org.apache.axiom.soap.SOAPFaultNode;
+import org.apache.axiom.soap.SOAPFaultReason;
+import org.apache.axiom.soap.SOAPFaultRole;
+import org.apache.axiom.soap.SOAPHeaderBlock;
+import org.apache.axiom.soap.SOAPProcessingException;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.addressing.AddressingConstants;
@@ -74,6 +85,8 @@
     }
 
     private void checkMustUnderstand(MessageContext msgContext) throws AxisFault {
+        activateMessageContext(msgContext);
+
         if (!msgContext.isHeaderPresent()) {
             return;
         }
@@ -147,6 +160,8 @@
             throw new AxisFault(Messages.getMessage("errorwhileProcessingFault"));
         }
 
+        activateMessageContext(processingContext);
+
         MessageContext faultContext = new MessageContext();
         faultContext.setConfigurationContext(engineContext);
         faultContext.setSessionContext(processingContext.getSessionContext());
@@ -318,6 +333,7 @@
         // user can set the fault information to the message context or to the AxisFault itself.
         // whatever user sets to the message context, supercedes eerything.
 
+        activateMessageContext(context);
         Object faultCode = context.getProperty(SOAP12Constants.SOAP_FAULT_CODE_LOCAL_NAME);
         String soapFaultCode = "";
 
@@ -457,6 +473,8 @@
      * @param e
      */
     private String getFaultReasonFromException(Throwable e, MessageContext context) {
+
+        activateMessageContext(context);
         Throwable throwable = e;
         Parameter param = context.getParameter(Constants.Configuration.DRILL_DOWN_TO_ROOT_CAUSE_FOR_FAULT_REASON);
         boolean drillDownToRootCauseForFaultReason = param != null && ((String) param.getValue()).equalsIgnoreCase("true");
@@ -479,6 +497,8 @@
      * @see Handler
      */
     public void receive(MessageContext msgContext) throws AxisFault {
+
+        activateMessageContext(msgContext);
         ConfigurationContext confContext = msgContext.getConfigurationContext();
         ArrayList preCalculatedPhases =
                 confContext.getAxisConfiguration().getGlobalInFlow();
@@ -538,6 +558,8 @@
      * @throws AxisFault
      */
     public InvocationResponse invoke(MessageContext msgContext, boolean inbound, boolean resuming) throws AxisFault {
+
+        activateMessageContext(msgContext);
         if (msgContext.getCurrentHandlerIndex() == -1) {
             msgContext.setCurrentHandlerIndex(0);
         }
@@ -550,11 +572,29 @@
                         
             try
             {
+              if (!resuming)
+              {
+                if (inbound)
+                {
+                  msgContext.addInboundExecutedPhase(currentHandler);
+                }
+                else
+                {
+                  msgContext.addOutboundExecutedPhase(currentHandler);
+                }
+              }
+              else
+              {
+                /* If we are resuming the flow, we don't want to add the phase 
+                 * again, as it has already been added.
+                 */
+                resuming = false;
+              }
               pi = currentHandler.invoke(msgContext);
             }
             catch (AxisFault e)
             {
-              if (msgContext.getCurrentPhaseIndex() != 0)
+              if (msgContext.getCurrentPhaseIndex() == 0)
               {
                 /* If we got a fault, we still want to add the phase to the
                  list to be executed for flowComplete(...) unless this was
@@ -566,34 +606,16 @@
                  executed.*/ 
                 if (inbound)
                 {
-                  msgContext.addInboundExecutedPhase(currentHandler);
+                  msgContext.removeFirstInboundExecutedPhase();
                 }
                 else
                 {
-                  msgContext.addOutboundExecutedPhase(currentHandler);
+                  msgContext.removeFirstOutboundExecutedPhase();
                 }
               }
               throw e;
             }
               
-            if (resuming)
-            {
-              /*If we are resuming the flow, we don't want to add the phase again, as it has already
-               *been added.*/
-              resuming = false;
-            }
-            else
-            {
-              if (inbound)
-              {
-                msgContext.addInboundExecutedPhase(currentHandler);
-              }
-              else
-              {
-                msgContext.addOutboundExecutedPhase(currentHandler);
-              }
-            }
-
             if (pi.equals(InvocationResponse.SUSPEND) ||
                 pi.equals(InvocationResponse.ABORT))
             {
@@ -641,6 +663,9 @@
      * @throws AxisFault
      */
     public InvocationResponse resumeReceive(MessageContext msgContext) throws AxisFault {
+
+        activateMessageContext(msgContext);
+
       //REVIEW: This name is a little misleading, as it seems to indicate that there should be a resumeReceiveFault as well, when, in fact, this does both 
       //REVIEW: Unlike with receive, there is no wrapping try/catch clause which would
       //fire off the flowComplete on an error, as we have to assume that the
@@ -676,6 +701,9 @@
      * @throws AxisFault
      */
     public InvocationResponse resumeSend(MessageContext msgContext) throws AxisFault {
+
+        activateMessageContext(msgContext);
+
       //REVIEW: This name is a little misleading, as it seems to indicate that there should be a resumeSendFault as well, when, in fact, this does both 
       //REVIEW: Unlike with send, there is no wrapping try/catch clause which would
       //fire off the flowComplete on an error, as we have to assume that the
@@ -706,6 +734,7 @@
      */
     public void receiveFault(MessageContext msgContext) throws AxisFault {
 
+        activateMessageContext(msgContext);
     	log.debug(Messages.getMessage("receivederrormessage",
                 msgContext.getMessageID()));
         ConfigurationContext confContext = msgContext.getConfigurationContext();
@@ -765,6 +794,7 @@
      * @throws AxisFault
      */
     public InvocationResponse resume(MessageContext msgctx) throws AxisFault {
+        activateMessageContext(msgctx);
         msgctx.setPaused(false);
         if (msgctx.getFLOW() == MessageContext.IN_FLOW) {
             return resumeReceive(msgctx);
@@ -786,6 +816,7 @@
      */
     public void send(MessageContext msgContext) throws AxisFault {
 
+        activateMessageContext(msgContext);
         // find and invoke the Phases
         OperationContext operationContext = msgContext.getOperationContext();
         ArrayList executionChain = operationContext.getAxisOperation().getPhasesOutFlow();
@@ -852,6 +883,8 @@
      * @throws AxisFault
      */
     public void sendFault(MessageContext msgContext) throws AxisFault {
+
+        activateMessageContext(msgContext);
         OperationContext opContext = msgContext.getOperationContext();
 
         //FIXME: If this gets paused in the operation-specific phases, the resume is not going to function correctly as the phases will not have all been set 
@@ -934,6 +967,22 @@
     }
 
     /**
+     * Make sure that the MessageContext is in an active state.
+     * This means that the MessageContext is fully usable.
+     * If a message context had been re-constituted from 
+     * persistent storage, the message context may need
+     * to complete the restoration in order to be fully
+     * usable.
+     * 
+     * @param mc     MessageContext
+     */
+    private void activateMessageContext(MessageContext mc)
+    {
+        // make sure that the message context is in an active state
+        mc.activate(engineContext);
+    }
+
+    /**
      * This class is the workhorse for a non-blocking invocation that uses a two
      * way transport.
      */
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/util/MetaDataEntry.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/util/MetaDataEntry.java	(revision 0)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/util/MetaDataEntry.java	(revision 0)
@@ -0,0 +1,353 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.util;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import javax.xml.namespace.QName;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutput;
+import java.io.ObjectOutputStream;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.StringTokenizer;
+
+
+
+/**
+ * An internal class for holding a set of information 
+ * about an object.  
+ */
+public class MetaDataEntry implements Externalizable
+{
+    // serialization identifier
+    private static final long serialVersionUID = 8978361069526299875L;
+
+    // supported revision levels, add a new level to manage compatible changes
+    private static final int REVISION_1 = 1;
+    // current revision level of this object
+    private static final int revisionID = REVISION_1;
+
+    // data to keep on an object
+
+    private String className = null;
+    private String qnameAsString = null;
+    private String extraName = null;
+
+    // list of MetaDataEntry objects that are owned by the
+    // original object referred to by this MetaDataEntry
+    private ArrayList list = null;
+
+    // marker to indicate end-of-list
+    public static String END_OF_LIST = "LAST_ENTRY";
+
+    /**
+     * Simple constructor
+     */
+    public MetaDataEntry()
+    {
+    }
+
+    /**
+     * Constructor
+     */
+    public MetaDataEntry(String c, String n)
+    {
+        className = c;
+        qnameAsString = n;
+    }
+
+    /**
+     * Constructor
+     */
+    public MetaDataEntry(String c, String n, String e)
+    {
+        className = c;
+        qnameAsString = n;
+        extraName = e;
+    }
+
+    /**
+     * Constructor
+     */
+    public MetaDataEntry(String c, String n, ArrayList l)
+    {
+        className = c;
+        qnameAsString = n;
+        list = l;
+    }
+
+
+    /**
+     * Get the class name
+     * 
+     * @return the class name string
+     */
+    public String getClassName()
+    {
+        return className;
+    }
+
+
+    /**
+     * Set the class name
+     * 
+     * @param c      the class name string
+     */
+    public void setClassName(String c)
+    {
+        className = c;
+    }
+
+
+    /**
+     * Get the QName
+     * 
+     * @return the QName based on the qnameAsString value
+     */
+    public QName getQName()
+    {
+    	if (qnameAsString != null)
+        {
+    		return QName.valueOf(qnameAsString);
+        }
+        else
+        {
+    	    return null;
+        }
+    }
+
+
+    /**
+     * Set the QName
+     *
+     * @param q      the QName
+     */
+    public void setQName(QName q)
+    {
+    	if (q != null)
+        {
+    		qnameAsString = q.toString();
+        }
+    	else
+        {
+    		qnameAsString = null;
+        }
+    }
+
+    /**
+     * Set the QName
+     *
+     * @param n      the QName as a string
+     */
+    public void setQName(String n)
+    {
+        qnameAsString = n;
+    }
+
+
+    /**
+     * Get the QName as a string
+     * 
+     * @return the QName as a string
+     */
+    public String getQNameAsString()
+    {
+        return qnameAsString;
+    }
+
+
+    /**
+     * Get the additional name associated with the object
+     * 
+     * @return the additional name string
+     */
+    public String getExtraName()
+    {
+        return extraName;
+    }
+
+
+    /**
+     * Set the additional name associated with the object
+     * 
+     * @param c      the extra name string
+     */
+    public void setExtraName(String e)
+    {
+        extraName = e;
+    }
+
+
+    /**
+     * Indicates whether the list is empty or not
+     * 
+     * @return false for a non-empty list, true for an empty list
+     */
+    public boolean isListEmpty()
+    {
+        if (list == null)
+        {
+            return true;
+        }
+
+        return list.isEmpty();
+    }
+
+
+    /**
+     * Get the list
+     * 
+     * @return the array list
+     */
+    public ArrayList getList()
+    {
+        return list;
+    }
+
+
+    /**
+     * Set the list
+     * 
+     * @param L      the ArrayList of MetaDataEntry objects
+     */
+    public void setList(ArrayList L)
+    {
+        list = L;
+    }
+
+    /**
+     * Add to the list
+     * 
+     * @param e      the MetaDataEntry object to add to the list
+     */
+    public void addToList(MetaDataEntry e)
+    {
+        if (list == null)
+        {
+            list = new ArrayList();
+        }
+        list.add(e);
+    }
+
+    /**
+     * Remove the list
+     * 
+     */
+    public void removeList()
+    {
+        list = null;
+    }
+
+
+
+
+    // message strings 
+    private static final String UNSUPPORTED_SUID  = "Serialization version ID is not supported.";
+    private static final String UNSUPPORTED_REVID = "Revision ID is not supported.";
+
+
+    /**
+     * Save the contents of this object
+     *
+     * @param out    The stream to write the object contents to
+     * 
+     * @exception IOException
+     */
+    public void writeExternal(ObjectOutput out) throws IOException
+    {
+        // write out contents of this object
+
+        //---------------------------------------------------------
+        // in order to handle future changes to the message 
+        // context definition, be sure to maintain the 
+        // object level identifiers
+        //---------------------------------------------------------
+        // serialization version ID
+        out.writeLong(serialVersionUID);
+
+        // revision ID
+        out.writeInt(revisionID);
+
+        //---------------------------------------------------------
+        // various simple fields
+        //---------------------------------------------------------
+        ObjectStateUtils.writeString(out, className, "MetaDataEntry.className");
+        ObjectStateUtils.writeString(out, qnameAsString, "MetaDataEntry.qnameAsString");
+        ObjectStateUtils.writeString(out, extraName, "MetaDataEntry.extraName");
+        ObjectStateUtils.writeArrayList(out, list, "MetaDataEntry.list");
+
+    }
+
+
+    /**
+     * Restore the contents of the object that was 
+     * previously saved. 
+     * <p> 
+     * NOTE: The field data must read back in the same order and type
+     * as it was written.
+     *
+     * @param in    The stream to read the object contents from 
+     * 
+     * @exception IOException
+     * @exception ClassNotFoundException
+     */
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
+    {
+
+        // serialization version ID
+        long suid = in.readLong();
+
+        // revision ID
+        int  revID = in.readInt();
+
+        // make sure the object data is in a version we can handle
+        if (suid != serialVersionUID)
+        {
+            throw new ClassNotFoundException(UNSUPPORTED_SUID);
+        }
+
+        // make sure the object data is in a revision level we can handle
+        if (revID != REVISION_1)
+        {
+            throw new ClassNotFoundException(UNSUPPORTED_REVID);
+        }
+
+
+        //---------------------------------------------------------
+        // various simple fields
+        //---------------------------------------------------------
+
+        className = ObjectStateUtils.readString(in, "MetaDataEntry.className");
+        qnameAsString = ObjectStateUtils.readString(in, "MetaDataEntry.qnameAsString");
+        extraName = ObjectStateUtils.readString(in, "MetaDataEntry.extraName");
+        list = ObjectStateUtils.readArrayList(in, "MetaDataEntry.list");
+
+    }
+
+}
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/util/SelfManagedDataHolder.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/util/SelfManagedDataHolder.java	(revision 0)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/util/SelfManagedDataHolder.java	(revision 0)
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.util;
+
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+
+public class SelfManagedDataHolder implements Externalizable
+{
+
+    private transient String classname;
+    private transient String id;
+    private transient byte[] data;
+
+    public SelfManagedDataHolder()
+    {
+        // should only be used by the ObjectStateUtils
+    }
+
+    // TODO better exception
+    public SelfManagedDataHolder(String classname, String id, byte[] data) throws Exception {
+        if ((classname == null)
+            || (id == null))
+            throw new Exception("Argument cannot be null: classname = " + classname + ", id = " + id);
+        this.classname = classname;
+        this.id = id;
+
+        // TODO deep copy necessary?
+        this.data = new byte[data.length];
+        for (int i = 0; i < data.length; i++)
+            this.data[i] = data[i];
+    }
+
+
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+        classname = (String)in.readUTF();
+        id = (String)in.readUTF();
+        int datalength = in.readInt();
+        data = new byte[datalength];
+        in.read(data);
+
+    }
+
+    public void writeExternal(ObjectOutput out) throws IOException {
+        out.writeUTF(classname);
+        out.writeUTF(id);
+        out.writeInt(data.length);
+        out.write(data);
+    }
+
+
+    public String getClassname()
+    {
+        return classname;
+    }
+
+    public byte[] getData()
+    {
+        return data;
+    }
+
+    public String getId()
+    {
+        return id;
+    }
+
+}
\ No newline at end of file
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/util/ObjectStateUtils.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/util/ObjectStateUtils.java	(revision 0)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/util/ObjectStateUtils.java	(revision 0)
@@ -0,0 +1,2120 @@
+/*
+* Copyright 2004,2005 The Apache Software Foundation.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.apache.axis2.util;
+
+
+import org.apache.axis2.description.AxisMessage;
+import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.AxisServiceGroup;
+import org.apache.axis2.description.TransportInDescription;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.axis2.engine.Handler;
+import org.apache.axis2.transport.TransportListener;
+import org.apache.axis2.wsdl.WSDLConstants;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import javax.xml.namespace.QName;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutput;
+import java.io.ObjectOutputStream;
+import java.io.UTFDataFormatException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Provides functions for saving and restoring an
+ * object's state.
+ */
+public class ObjectStateUtils 
+{
+    /*
+     * setup for logging
+     */
+    private static final Log log = LogFactory.getLog(ObjectStateUtils.class);
+
+
+    // used as part of the metadata written out 
+    // indicating a null or empty object
+    public static boolean EMPTY_OBJECT = false;
+
+    // used as part of the metadata written out 
+    // indicating a non-null or live object
+    public static boolean ACTIVE_OBJECT = true;
+
+    // used to indicate the end of a list
+    public static String LAST_ENTRY = "LAST_ENTRY";
+
+    // used to indicate an "empty" object
+    public static String EMPTY_MARKER = "EMPTY_MARKER";
+
+    // message strings
+    public static final String UNSUPPORTED_SUID  = "Serialization version ID is not supported.";
+    public static final String UNSUPPORTED_REVID = "Revision ID is not supported.";
+
+
+    //--------------------------------------------------------------------
+    // Save/Restore methods
+    //--------------------------------------------------------------------
+
+    /**
+     * Write a string to the specified output stream.
+     * <P>
+     * The format of the information written to the output stream is:
+     * <BOLD>Non-Null String</BOLD>
+     * <LI> UTF     - class name string 
+     * <LI> boolean - active flag
+     * <LI> int     - number of string sections
+     * <LI> int     - byte buffer size
+     * <LI> bytes(UTF) - string data
+     * <P>
+     * <BOLD>Null String</BOLD>
+     * <LI> UTF     - description
+     * <LI> boolean - empty flag
+     * <P>
+     * 
+     * @param out    The output stream
+     * @param str    The string to write
+     * @param desc   A text description to use for logging
+     * @exception IOException
+     *                   Exception
+     */
+    public static void writeString(ObjectOutput out, String str, String desc) throws IOException
+    {
+        // The total number of bytes needed to represent all 
+        // the characters of a string is calculated when the string
+        // is serialized. If this number is larger than 65535 (ie, 64 KB)
+        // then a java.io.UTFDataFormatException is thrown 
+
+        if (str != null)
+        {
+            String str_desc = str.getClass().getName();
+            // this string is expected to fit the writeUTF limitations
+            out.writeUTF(str_desc);
+
+            out.writeBoolean(ACTIVE_OBJECT);
+
+            // set the number of sections for the string to be processed
+            // for now, the string will be treated as a single section
+            // notes: this would be used for strings that don't fit the
+            // writeUTF(string) limitations
+            int numberStringSections = 1;
+
+            // set up a temporary stream to use for the string
+            ByteArrayOutputStream outBuffer = new ByteArrayOutputStream();
+
+            // -------------------------------------------------------------
+            // notes: there is some problem with the writeUTF(str) below
+            //        the ObjectOutputStream is getting the UTF string
+            //        but isn't reporting the correct size or converting
+            //        to the correct byte array with the UTF data
+            // -------------------------------------------------------------
+            //ObjectOutputStream objOut = new ObjectOutputStream(outBuffer);
+            //
+            //try
+            //{
+            //    objOut.writeUTF(str);
+            //}
+            //catch (java.io.UTFDataFormatException udfe)
+            //{
+            //    // break string into sections and write the sections
+            //    log.trace("ObjectStateUtils:writeString(): ACTIVE string: UTFDataFormatException ["+udfe.getMessage()+"]");
+            //}
+            // -------------------------------------------------------------
+
+            outBuffer.write(str.getBytes() ,0, str.length());
+
+            out.writeInt(numberStringSections);
+            int outSize = outBuffer.size();
+            out.writeInt(outSize);
+            out.write(outBuffer.toByteArray());
+
+            outBuffer.close();
+
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:writeString(): ACTIVE string: str_desc ["+str_desc+"]    string ["+str+"]   desc ["+desc+"]   output byte buffer size ["+outSize+"]");
+                log.trace("ObjectStateUtils:writeString(): ACTIVE string: outBuffer ["+outBuffer.toString()+"]");
+            }
+            //System.out.println("ObjectStateUtils:writeString(): ACTIVE string: str_desc ["+str_desc+"]    string ["+str+"]   desc ["+desc+"]   output byte buffer size ["+outSize+"]");
+            //System.out.println("ObjectStateUtils:writeString(): ACTIVE string: outBuffer ["+outBuffer.toString()+"]");
+
+        }
+        else
+        {
+            // this string is expected to fit the writeUTF limitations
+            out.writeUTF(desc);
+
+            out.writeBoolean(EMPTY_OBJECT);
+
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:writeString(): EMPTY String    desc ["+desc+"]  ");
+            }
+            //System.out.println("ObjectStateUtils:writeString(): EMPTY String   desc ["+desc+"]  ");
+        }
+    }
+
+
+    /**
+     * Read a string from the specified input stream. Returns null if no string
+     * is available.
+     * <P>
+     * The format of the information to be read from the input stream should be
+     * <BOLD>Non-Null String</BOLD>
+     * <LI> UTF     - class name string 
+     * <LI> boolean - active flag
+     * <LI> int     - number of string sections
+     * <LI> int     - byte buffer size
+     * <LI> bytes(UTF) - string data
+     * <P>
+     * <BOLD>Null String</BOLD>
+     * <LI> UTF     - description
+     * <LI> boolean - empty flag
+     * <P>
+     * 
+     * @param in     The input stream
+     * @param desc   A text description to use for logging
+     * 
+     * @return The string or null, if not available
+     * 
+     * @exception IOException
+     * @exception ClassNotFoundException
+     */
+    public static String readString(ObjectInput in, String desc) throws IOException, ClassNotFoundException 
+    {
+        String str = null;
+
+        // get the marker
+        String str_desc = in.readUTF();
+
+        // get the flag
+        boolean isActive = in.readBoolean();
+
+        if (isActive == ACTIVE_OBJECT)
+        {
+            // then should have one or more sections of the string to get
+            int numberStringSections = in.readInt();
+
+            if (numberStringSections > 1)
+            {
+                // trace point
+                if (log.isTraceEnabled())
+                {
+                    log.trace("ObjectStateUtils:readString(): ACTIVE string: the ["+desc+"] string with saved description ["+str_desc+"] has ["+numberStringSections+"] sections");
+                }
+                //System.out.println("ObjectStateUtils:readString(): ACTIVE string: the ["+desc+"] string with saved description ["+str_desc+"] has ["+numberStringSections+"] sections");
+
+
+                // TODO: read the sections and concatenate them together
+                //       may need to adjust the saved information to make 
+                //       putting the sections back together easier
+
+                StringBuffer sbuff = new StringBuffer();
+
+                for (int k=0; k<numberStringSections; k++)
+                {
+                    String section = in.readUTF();
+                    sbuff.append(section);
+                }
+
+                str = sbuff.toString();
+            }
+            else
+            {
+                // one string section
+
+                // get the size of the string in bytes
+                int bufSize = in.readInt();
+
+                // set up a byte buffer to read into
+                byte [] buffer = new byte [bufSize];
+
+                int bytesRead = in.read(buffer, 0, bufSize);
+
+                // trace point
+                if (log.isTraceEnabled())
+                {
+                    log.trace("ObjectStateUtils:readString(): ACTIVE string: str_desc ["+str_desc+"]    bufSize ["+bufSize+"]   bytesRead ["+bytesRead+"]   desc ["+desc+"]");
+                }
+                //System.out.println("ObjectStateUtils:readString(): ACTIVE string: str_desc ["+str_desc+"]    bufSize ["+bufSize+"]   bytesRead ["+bytesRead+"]   desc ["+desc+"]");
+
+
+                if (bytesRead > 0)
+                {
+                    // -------------------------------------------------------------
+                    // notes: there is some problem with the writeUTF(str) 
+                    //        the ObjectOutputStream is getting the UTF string
+                    //        but isn't reporting the correct size or converting
+                    //        to the correct byte array with the UTF data
+                    // -------------------------------------------------------------
+                    //ByteArrayInputStream strBuffer = null;
+                    //ObjectInputStream    objin = null;
+                    //
+                    //// use a byte array input stream to read the UTF
+                    //strBuffer = new ByteArrayInputStream(buffer);
+                    //objin = new ObjectInputStream(strBuffer);
+                    //
+                    // read the UTF data
+                    //str = objin.readUTF();
+                    //
+                    //log.trace("ObjectStateUtils:readString(): UTF str from buffer  ["+str+"]");
+                    //
+                    // close internal streams
+                    //objin.close();
+                    //strBuffer.close();
+                    // -------------------------------------------------------------
+
+                    str = new String(buffer);
+                }
+            }
+        }
+
+        String value = "null";
+        if (str != null)
+        {
+            value = str;
+        }
+
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:readString(): ["+desc+"]  returning  ["+value+"]");
+        }
+        //System.out.println("ObjectStateUtils:readString(): ["+desc+"]  returning  ["+value+"]");
+
+        return str;
+    }
+
+
+
+    /**
+     * Write an object to the specified output stream.
+     * <P>
+     * The format of the information written to the output stream is
+     * <P>
+     * <BOLD>Non-Null Object</BOLD>
+     * <LI> UTF     - class name string 
+     * <LI> boolean - active flag
+     * <LI> object  - object
+     * <P>
+     * <BOLD>Null Object</BOLD>
+     * <LI> UTF     - description
+     * <LI> boolean - empty flag
+     * <P>
+     * 
+     * @param out    The output stream
+     * @param obj    The object to write
+     * @param desc   A text description to use for logging
+     * @exception IOException
+     *                   Exception
+     */
+    public static void writeObject(ObjectOutput out, Object obj, String desc) throws IOException
+    {
+        if (obj != null)
+        {
+            String objClassName = obj.getClass().getName();
+            String fullDesc     = desc +":"+ objClassName;
+            // this string is expected to fit the writeUTF limitations
+            out.writeUTF(fullDesc);
+
+            out.writeBoolean(ACTIVE_OBJECT);
+            out.writeObject(obj);
+
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:writeObject(): Object ["+objClassName+"]  desc ["+desc+"]");
+            }
+            //System.out.println("ObjectStateUtils:writeObject(): Object ["+objClassName+"]  desc ["+desc+"]");
+        }
+        else
+        {
+            // this string is expected to fit the writeUTF limitations
+            out.writeUTF(desc);
+
+            out.writeBoolean(EMPTY_OBJECT);
+
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:writeObject(): EMPTY Object ["+desc+"]  ");
+            }
+            //System.out.println("ObjectStateUtils:writeObject(): EMPTY Object ["+desc+"]  ");
+        }
+    }
+
+
+    /**
+     * Read an object from the specified input stream. Returns null if no object
+     * is available.
+     * <P>
+     * The format of the information to be read from the input stream should be
+     * <BOLD>Non-Null Object</BOLD>
+     * <LI> UTF     - class name string 
+     * <LI> boolean - active flag
+     * <LI> object  - object
+     * <P>
+     * <BOLD>Null Object</BOLD>
+     * <LI> UTF     - description
+     * <LI> boolean - empty flag
+     * <P>
+     * 
+     * @param in     The input stream
+     * @param desc   A text description to use for logging
+     * 
+     * @return The object or null, if not available
+     * 
+     * @exception IOException
+     * @exception ClassNotFoundException
+     */
+    public static Object readObject(ObjectInput in, String desc) throws IOException, ClassNotFoundException  
+    {
+        Object obj = null;
+
+        String str_desc = in.readUTF();
+
+        boolean isActive = in.readBoolean();
+
+        if (isActive == ACTIVE_OBJECT)
+        {
+            obj = in.readObject();
+        }
+
+        String value = "null";
+
+        if (obj != null)
+        {
+            value = str_desc + ":" + obj.getClass().getName();
+        }
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:readObject(): ["+desc+"]  returning  ["+value+"]");
+        }
+        //System.out.println("ObjectStateUtils:readObject(): ["+desc+"]  returning  ["+value+"]");
+
+        return obj;
+    }
+
+
+    /**
+     * Write an array of objects to the specified output stream.
+     * <P>
+     * The format of the information written to the output stream is
+     * <LI> class name of the array
+     * <LI> active or empty
+     * <LI> data
+     * <P>
+     * NOTE: each object in the array should implement either 
+     * java.io.Serializable or java.io.Externalizable in order to be
+     * saved
+     * <P>
+     * @param out    The output stream
+     * @param al     The ArrayList to write
+     * @param desc   A text description to use for logging
+     * @exception IOException
+     *                   Exception
+     */
+    public static void writeArrayList(ObjectOutput out, ArrayList al, String desc) throws IOException
+    {
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:writeArrayList(): BEGIN    List ["+desc+"]  ");
+        }
+        //System.out.println("ObjectStateUtils:writeArrayList(): BEGIN    List ["+desc+"]  ");
+
+
+        // The format of the data is
+        //
+        //  Non-null list:
+        //    UTF          - description string
+        //    boolean      - active flag
+        //    int          - expected number of entries in the list
+        //                        not including the last entry marker
+        //    objects      - objects from list
+        //                        last entry will be the LAST_ENTRY marker
+        //    int          - adjusted number of entries in the list
+        //                        includes the last entry
+        //    
+        //  Empty list:
+        //    UTF          - description string
+        //    boolean      - empty flag
+        //
+
+        out.writeUTF(desc);
+
+        if ((al == null) || (al.isEmpty()))
+        {
+            // handle null or empty
+
+            out.writeBoolean(EMPTY_OBJECT);
+
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:writeArrayList(): EMPTY List ["+desc+"]  ");
+            }
+            //System.out.println("ObjectStateUtils:writeArrayList(): EMPTY List ["+desc+"]  ");
+        }
+        else
+        {
+            // active flag
+            out.writeBoolean(ACTIVE_OBJECT);
+
+            int listSize = al.size();
+            int savedListSize = 0;
+
+            // expected list size
+            out.writeInt(listSize);
+
+            // setup an iterator for the list
+            Iterator i = al.iterator();
+
+            while (i.hasNext())
+            {
+                Object obj = i.next();
+                String tmpClassName = obj.getClass().getName();
+
+                try
+                {
+                    out.writeObject(obj);
+                    savedListSize++;
+
+                    // trace point
+                    if (log.isTraceEnabled())
+                    {
+                        log.trace("ObjectStateUtils:writeArrayList(): "+desc+" ["+obj.getClass().getName()+"]");
+                    }
+                    //System.out.println("ObjectStateUtils:writeArrayList(): "+desc+" ["+obj.getClass().getName()+"]");
+
+                }
+                catch (Exception ex)
+                {
+                    // use this as a generic point for all exceptions
+
+                    // trace point
+                    log.warn("ObjectStateUtils:writeArrayList(): "+desc+" ["+obj.getClass().getName()+"]  ***Exception***  ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+                    //System.out.println("ObjectStateUtils:writeArrayList(): "+desc+" ["+obj.getClass().getName()+"]  ***Exception***  ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+
+                    if (log.isTraceEnabled())
+                    {
+                        // informational
+                        ex.printStackTrace();
+                    }
+                }
+            }
+
+            // put the end-of-marker in the stream
+            out.writeObject(LAST_ENTRY);
+            savedListSize++;
+
+            out.writeInt(savedListSize);
+
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:writeArrayList(): List ["+desc+"]   members saved ["+savedListSize+"]");
+            }
+            //System.out.println("ObjectStateUtils:writeArrayList(): List ["+desc+"]   members saved ["+savedListSize+"]");
+        }
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:writeArrayList(): END    List ["+desc+"]  ");
+        }
+        //System.out.println("ObjectStateUtils:writeArrayList(): END    List ["+desc+"]  ");
+
+    }
+
+
+    /**
+     * Reads an array of objects from the specified input stream.  Returns
+     * null if no array is available.
+     * <P>
+     * The format of the information to be read from the input stream should be
+     * <LI> class name
+     * <LI> active or empty
+     * <LI> data
+     * <P>
+     * NOTE: each object in the array should implement either 
+     * java.io.Serializable or java.io.Externalizable in order to be
+     * saved
+     * <P>
+     * 
+     * @param in     The input stream
+     * @param desc   A text description to use for logging
+     * 
+     * @return The ArrayList or null, if not available
+     * 
+     * @exception IOException
+     * @exception ClassNotFoundException
+     */
+    public static ArrayList readArrayList(ObjectInput in, String desc) throws IOException
+    {
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:readArrayList(): BEGIN    List  ["+desc+"]");
+        }
+        //System.out.println("ObjectStateUtils:readArrayList(): BEGIN    ["+desc+"]");
+
+
+        // The format of the data is
+        //
+        //  Non-null list:
+        //    UTF          - description string
+        //    boolean      - active flag
+        //    int          - expected number of entries in the list
+        //                        not including the last entry marker
+        //    objects      - objects from list
+        //                        last entry will be the LAST_ENTRY marker
+        //    int          - adjusted number of entries in the list
+        //                        includes the last entry
+        //    
+        //  Empty list:
+        //    UTF          - description string
+        //    boolean      - empty flag
+        //
+
+        ArrayList list = new ArrayList();
+
+        String str_desc = in.readUTF();
+
+        boolean isActive = in.readBoolean();
+
+        if (isActive == ACTIVE_OBJECT)
+        {
+            // get the expected number of entries
+            int expectedListSize = in.readInt();
+
+            // process the objects
+            boolean keepGoing = true;
+            int     count     = 0;
+            Object  obj       = null;
+
+            while (keepGoing)
+            {
+                // stop when we get to the end-of-list marker
+
+                // get the object
+                try
+                {
+                    obj = in.readObject();
+                    count++;
+
+                    if (obj != null)
+                    {
+                        if (obj instanceof String)
+                        {
+                            String tmp = (String) obj;
+                            if (tmp.equalsIgnoreCase(LAST_ENTRY))
+                            {
+                                // this is the last entry
+                                keepGoing = false;
+
+                            } //end if last entry marker
+                        } // end if a String object
+
+                        if (keepGoing)
+                        {
+                            String tmpClassName = obj.getClass().getName();
+
+                            // not at the end of the list so
+                            // add the entry to the list
+                            list.add(obj);
+
+                            // trace point
+                            if (log.isTraceEnabled())
+                            {
+                                log.trace("ObjectStateUtils:readArrayList(): ["+desc+"]  index ["+count+"]  object ["+tmpClassName+"] ");
+                            }
+                            //System.out.println("ObjectStateUtils:readArrayList(): ["+desc+"]  index ["+count+"]  object ["+tmpClassName+"]  ");
+                        }
+                    }
+                    else
+                    {
+                        // some other problem occurred
+                        // the object to be read is null
+                        // trace point
+                        if (log.isTraceEnabled())
+                        {
+                            log.trace("ObjectStateUtils:readArrayList(): ["+desc+"]  object index ["+count+"] ***Unexpected null object***");
+                        }
+                        //System.out.println("ObjectStateUtils:readArrayList(): ["+desc+"]  object index ["+count+"] ***Unexpected null object***");
+                        keepGoing = false;
+                    }
+                }
+                catch (Exception ex)
+                {
+                    // use this as a generic point for all exceptions
+
+                    // trace point
+                    log.warn("ObjectStateUtils:readArrayList(): ["+desc+"]  object index ["+count+"] ***Exception***  ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+                    //System.out.println("ObjectStateUtils:readArrayList(): ["+desc+"]  object index ["+count+"] ***Exception***  ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+
+                    ex.printStackTrace();
+
+                    keepGoing = false;
+                }
+
+            } // end while keep going
+
+            int adjustedNumberEntries = in.readInt();
+
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:readArrayList(): adjusted number of entries ["+adjustedNumberEntries+"]    ");
+            }
+            //System.out.println("ObjectStateUtils:readArrayList(): adjusted number of entries ["+adjustedNumberEntries+"]    ");
+
+
+            if (list.isEmpty())
+            {
+                // trace point
+                if (log.isTraceEnabled())
+                {
+                    log.trace("ObjectStateUtils:readArrayList(): ["+desc+"]  returning  [null]");
+                    log.trace("ObjectStateUtils:readArrayList(): END    List  ["+desc+"]");
+                }
+                //System.out.println("ObjectStateUtils:readArrayList(): ["+desc+"]  returning  [null]");
+                //System.out.println("ObjectStateUtils:readArrayList(): END    ["+desc+"]");
+
+                return null;
+            }
+            else
+            {
+                // trace point
+                if (log.isTraceEnabled())
+                {
+                    log.trace("ObjectStateUtils:readArrayList(): ["+desc+"]  returning  [listsize="+list.size()+"]");
+                    log.trace("ObjectStateUtils:readArrayList(): END    List  ["+desc+"]");
+                }
+                //System.out.println("ObjectStateUtils:readArrayList(): ["+desc+"]  returning  [listsize="+list.size()+"]");
+                //System.out.println("ObjectStateUtils:readArrayList(): END    ["+desc+"]");
+
+                return list;
+            }
+        }
+        else
+        {
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:readArrayList(): ["+desc+"]  returning  [null]");
+                log.trace("ObjectStateUtils:readArrayList(): END    List  ["+desc+"]");
+            }
+            //System.out.println("ObjectStateUtils:readArrayList(): ["+desc+"]  returning  [null]");
+            //System.out.println("ObjectStateUtils:readArrayList(): END    ["+desc+"]");
+
+            return null;
+        }
+    }
+
+
+    /**
+     * Write a hashmap of objects to the specified output stream.
+     * <P>
+     * The format of the information written to the output stream is
+     * <LI> class name of the array
+     * <LI> active or empty
+     * <LI> data
+     * <P>
+     * NOTE: each object in the map should implement either 
+     * java.io.Serializable or java.io.Externalizable in order to be
+     * saved
+     * <P>
+     * @param out    The output stream
+     * @param map    The HashMap to write
+     * @param desc   A text description to use for logging
+     * @exception IOException
+     *                   Exception
+     */
+    public static void writeHashMap(ObjectOutput out, HashMap map, String desc) throws IOException
+    {
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:writeHashMap(): BEGIN    map ["+desc+"]  ");
+        }
+        //System.out.println("ObjectStateUtils:writeHashMap(): BEGIN    map ["+desc+"]  ");
+
+
+        // The format of the data is
+        //
+        //  Non-null list:
+        //    UTF          - description string
+        //    boolean      - active flag
+        //    int          - expected number of entries in the list
+        //                        not including the last entry marker
+        //    objects      - object,object pairs from list
+        //                        last entry will be a single LAST_ENTRY marker object
+        //    int          - adjusted number of entries in the list
+        //                        includes the last entry
+        //    
+        //  Empty list:
+        //    UTF          - description string
+        //    boolean      - empty flag
+        //
+
+        out.writeUTF(desc);
+
+        if ((map == null) || (map.isEmpty()))
+        {
+            // handle null or empty
+
+            out.writeBoolean(EMPTY_OBJECT);
+
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:writeHashMap(): EMPTY map ["+desc+"]  ");
+            }
+            //System.out.println("ObjectStateUtils:writeHashMap(): EMPTY map ["+desc+"]  ");
+        }
+        else
+        {
+            out.writeBoolean(ACTIVE_OBJECT);
+
+            // the expected number of pairs in the map
+            int listSize = map.size();
+            out.writeInt(listSize);
+
+            // this will be the actual number of pairs saved
+            int savedListSize = 0;
+
+            // put each pair into a buffer to see if they can be saved
+            ByteArrayOutputStream pair_outBuffer = new ByteArrayOutputStream();
+            ObjectOutputStream pair_objOut = new ObjectOutputStream(pair_outBuffer);
+
+            Set keyset = map.keySet();
+            Iterator i = keyset.iterator();
+
+            while (i.hasNext())
+            {
+                // handle errors when can't access the value for the key
+
+                Object key = i.next();
+                Object value = map.get(key);
+
+                boolean  canWritePair = false;
+
+                try
+                {
+                    // write the objects in pairs
+                    pair_objOut.writeObject(key);
+
+                    try
+                    {
+                        pair_objOut.writeObject(value);
+
+                        // ok, the pair can be saved so write them to our "real" buffer
+                        canWritePair = true;
+                    }
+                    catch (Exception ex)
+                    {
+                        // use this as a generic point for all exceptions
+
+                        // trace point
+                        log.warn("ObjectStateUtils:writeHashMap(): map value ["+value.getClass().getName()+"]  ***Exception***  ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+                        //System.out.println("ObjectStateUtils:writeHashMap(): map value ["+value.getClass().getName()+"]  ***Exception***  ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+
+                        if (log.isTraceEnabled())
+                        {
+                            // informational message
+                            ex.printStackTrace();
+                        }
+                    }
+                }
+                catch (Exception exc)
+                {
+                    // use this as a generic point for all exceptions
+
+                    // trace point
+                    log.warn("ObjectStateUtils:writeHashMap(): map key ["+key.getClass().getName()+"]  ***Exception***  ["+exc.getClass().getName()+" : "+exc.getMessage()+"]");
+                    //System.out.println("ObjectStateUtils:writeHashMap(): map key ["+key.getClass().getName()+"]  ***Exception***  ["+exc.getClass().getName()+" : "+exc.getMessage()+"]");
+
+                    exc.printStackTrace();
+                }
+
+                if (canWritePair)
+                {
+                    try
+                    {
+                        // write the objects in pairs
+                        out.writeObject(key);
+
+                        // TODO: what if there is an error with the real output stream?
+                        try
+                        {
+                            out.writeObject(value);
+                        }
+                        catch (Exception excp)
+                        {
+                            // trace point
+                            log.warn("ObjectStateUtils:writeHashMap(): output error: map value ["+value.getClass().getName()+"]  ***Exception***  ["+excp.getClass().getName()+" : "+excp.getMessage()+"]");
+                            //System.out.println("ObjectStateUtils:writeHashMap(): output error: map value ["+value.getClass().getName()+"]  ***Exception***  ["+excp.getClass().getName()+" : "+excp.getMessage()+"]");
+
+                            if (log.isTraceEnabled())
+                            {
+                                // informational
+                                excp.printStackTrace();
+                            }
+
+                            // put an "null" marker here
+                            out.writeObject(EMPTY_MARKER);
+                        }
+
+                        savedListSize++;
+                    }
+                    catch (Exception ex)
+                    {
+                        // there was an error with the key to the real output stream
+                        // so skip to the next pair
+
+                        // trace point
+                        log.warn("ObjectStateUtils:writeHashMap(): output error: map key ["+key.getClass().getName()+"]  ***Exception***  ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+                        //System.out.println("ObjectStateUtils:writeHashMap(): output error: map key ["+key.getClass().getName()+"]  ***Exception***  ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+
+                        ex.printStackTrace();
+                    }
+                }
+
+
+                // reset the temporary buffer for the next round
+                pair_objOut.reset();
+            }
+
+            // write out a marker for the end of list
+            out.writeObject(LAST_ENTRY);
+            savedListSize++;
+
+            // put what we got into our stream
+            out.writeInt(savedListSize);
+
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:writeHashMap(): map ["+desc+"]   members saved ["+savedListSize+"]");
+            }
+            //System.out.println("ObjectStateUtils:writeHashMap(): map ["+desc+"]   members saved ["+savedListSize+"]");
+
+            pair_outBuffer.close();
+            pair_objOut.close();
+
+        }
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:writeHashMap(): END      map ["+desc+"]  ");
+        }
+        //System.out.println("ObjectStateUtils:writeHashMap(): END      map ["+desc+"]  ");
+    }
+
+
+    /**
+     * Read a hashmap of objects from the specified input stream. Returns
+     * null if no hashmap is available.
+     * <P>
+     * The format of the information to be read from the input stream should be
+     * <LI> class name
+     * <LI> active or empty
+     * <LI> data
+     * <P>
+     * NOTE: each object in the array should implement either 
+     * java.io.Serializable or java.io.Externalizable in order to be
+     * saved
+     * <P>
+     * 
+     * @param in     The input stream
+     * @param desc   A text description to use for logging
+     * 
+     * @return The HashMap or null, if not available
+     * 
+     * @exception IOException
+     * @exception ClassNotFoundException
+     */
+    public static HashMap readHashMap(ObjectInput in, String desc) throws IOException
+    {
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:readHashMap(): BEGIN   ["+desc+"]  ");
+        }
+        //System.out.println("ObjectStateUtils:readHashMap(): BEGIN   ["+desc+"]  ");
+
+
+        // The format of the data is
+        //
+        //  Non-null list:
+        //    UTF          - description string
+        //    boolean      - active flag
+        //    int          - expected number of entries in the list
+        //                        not including the last entry marker
+        //    objects      - object,object pairs from list
+        //                        last entry will be a single LAST_ENTRY marker object
+        //    int          - adjusted number of entries in the list
+        //                        includes the last entry
+        //    
+        //  Empty list:
+        //    UTF          - description string
+        //    boolean      - empty flag
+        //
+
+        HashMap map = new HashMap();
+
+        String str_desc = in.readUTF();
+
+        boolean isActive = in.readBoolean();
+
+        if (isActive == ACTIVE_OBJECT)
+        {
+            // get the hashmap
+
+            // first, get the expected number of pairs
+            int expectedListSize = in.readInt();
+
+            // count the pairs as we get them from the in buffer,
+            // including pairs that we don't keep
+            int obtainedListSize = 0;
+
+            // process the object pairs
+            boolean keepGoing = true;
+
+            while (keepGoing)
+            {
+                Object key = null;
+                Object value = null;
+
+                try
+                {
+
+                    key = in.readObject();
+
+                    if (key instanceof String)
+                    {
+                        String tmpkey = (String) key;
+
+                        // check to see if this is the last entry
+                        if (tmpkey.equalsIgnoreCase(LAST_ENTRY) == true)
+                        {
+                            // stop here
+                            keepGoing = false;
+                            break;
+                        }
+                    }
+
+                    // that object was not the last entry marker,
+                    // so get the next object in the pair
+
+                    value = in.readObject();
+
+                    boolean keepPair = true;
+
+                    if (value instanceof String)
+                    {
+                        String tmpvalue = (String) value;
+
+                        // if the value object is not available, then
+                        // don't preserve the key-value setting
+                        if (tmpvalue.equalsIgnoreCase(EMPTY_MARKER) == true)
+                        {
+                            // an empty value, so skip pair
+                            keepPair = false;
+
+                            // trace point
+                            if (log.isTraceEnabled())
+                            {
+                                log.trace("ObjectStateUtils:readHashMap(): ["+desc+"]  object pair index ["+obtainedListSize+"]  will be skipped because the value object is unavailable.");
+                            }
+                            //System.out.println("ObjectStateUtils:readHashMap(): ["+desc+"]  object pair index ["+obtainedListSize+"]  will be skipped because the value object is unavailable.");
+                        }
+                    }
+
+                    if (keepPair)
+                    {
+                        map.put(key,value);
+
+                        // trace point
+                        if (log.isTraceEnabled())
+                        {
+                            log.trace("ObjectStateUtils:readHashMap(): ["+desc+"]  object pair index ["+obtainedListSize+"] ");
+                        }
+                        //System.out.println("ObjectStateUtils:readHashMap(): ["+desc+"]  object pair index ["+obtainedListSize+"] ");
+                    }
+
+                    obtainedListSize++;
+
+                }
+                catch (Exception ex)
+                {
+                    // use this as a generic point for all exceptions
+
+                    // trace point
+                    log.warn("ObjectStateUtils:readHashMap(): ["+desc+"]  object pair index ["+obtainedListSize+"] ***Exception***  ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+                    //System.out.println("ObjectStateUtils:readHashMap(): ["+desc+"]  object pair index ["+obtainedListSize+"] ***Exception***  ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+
+                    ex.printStackTrace();
+                }
+
+            }
+
+            // get the adjusted list size from the buffer
+            int savedListSize = in.readInt();
+
+
+            if (map.isEmpty())
+            {
+                // trace point
+                if (log.isTraceEnabled())
+                {
+                    log.trace("ObjectStateUtils:readHashMap(): ["+desc+"]  returning  [null]");
+                    log.trace("ObjectStateUtils:readHashMap(): END     ["+desc+"]  ");
+                }
+                //System.out.println("ObjectStateUtils:readHashMap(): ["+desc+"]  returning  [null]");
+                //System.out.println("ObjectStateUtils:readHashMap(): END     ["+desc+"]  ");
+
+                return null;
+            }
+            else
+            {
+                // trace point
+                if (log.isTraceEnabled())
+                {
+                    log.trace("ObjectStateUtils:readHashMap(): ["+desc+"]  returning  [mapsize="+map.size()+"]");
+                    log.trace("ObjectStateUtils:readHashMap(): END     ["+desc+"]  ");
+                }
+                //System.out.println("ObjectStateUtils:readHashMap(): ["+desc+"]  returning  [mapsize="+map.size()+"]");
+                //System.out.println("ObjectStateUtils:readHashMap(): END     ["+desc+"]  ");
+
+                return map;
+            }
+
+        }
+        else
+        {
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:readHashMap(): ["+desc+"]  returning  [null]");
+                log.trace("ObjectStateUtils:readHashMap(): END     ["+desc+"]  ");
+            }
+            //System.out.println("ObjectStateUtils:readHashMap(): ["+desc+"]  returning  [null]");
+            //System.out.println("ObjectStateUtils:readHashMap(): END     ["+desc+"]  ");
+
+            return null;
+        }
+
+    }
+
+    /**
+     * Write a linked list of objects to the specified output stream.
+     * <P>
+     * The format of the information written to the output stream is
+     * <LI> class name of the array
+     * <LI> active or empty
+     * <LI> data
+     * <P>
+     * NOTE: each object in the array should implement either 
+     * java.io.Serializable or java.io.Externalizable in order to be
+     * saved
+     * <P>
+     * @param out    The output stream
+     * @param list   The LinkedList to write
+     * @param desc   A text description to use for logging
+     * @exception IOException
+     *                   Exception
+     */
+    public static void writeLinkedList(ObjectOutput out, LinkedList objlist, String desc) throws IOException
+    {
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:writeLinkedList(): BEGIN    List ["+desc+"]  ");
+        }
+        //System.out.println("ObjectStateUtils:writeLinkedList(): BEGIN    List ["+desc+"]  ");
+
+
+        // The format of the data is
+        //
+        //  Non-null list:
+        //    UTF          - description string
+        //    boolean      - active flag
+        //    int          - expected number of entries in the list
+        //                        not including the last entry marker
+        //    objects      - objects from list
+        //                        last entry will be the LAST_ENTRY marker
+        //    int          - adjusted number of entries in the list
+        //                        includes the last entry
+        //    
+        //  Empty list:
+        //    UTF          - description string
+        //    boolean      - empty flag
+        //
+
+        out.writeUTF(desc);
+
+        if ((objlist == null) || (objlist.isEmpty()))
+        {
+            // handle null or empty
+
+            out.writeBoolean(EMPTY_OBJECT);
+
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:writeLinkedList(): EMPTY List ["+desc+"]  ");
+            }
+            //System.out.println("ObjectStateUtils:writeLinkedList(): EMPTY List ["+desc+"]  ");
+        }
+        else
+        {
+            // active flag
+            out.writeBoolean(ACTIVE_OBJECT);
+
+            int listSize = objlist.size();
+            int savedListSize = 0;
+
+            // expected list size
+            out.writeInt(listSize);
+
+            // setup an iterator for the list
+            Iterator i = objlist.iterator();
+
+            while (i.hasNext())
+            {
+                Object obj = i.next();
+                String tmpClassName = obj.getClass().getName();
+
+                try
+                {
+                    out.writeObject(obj);
+                    savedListSize++;
+
+                    // trace point
+                    if (log.isTraceEnabled())
+                    {
+                        log.trace("ObjectStateUtils:writeLinkedList(): "+desc+" ["+obj.getClass().getName()+"]");
+                    }
+                    //System.out.println("ObjectStateUtils:writeLinkedList(): "+desc+" ["+obj.getClass().getName()+"]");
+
+                }
+                catch (Exception ex)
+                {
+                    // use this as a generic point for all exceptions
+
+                    // trace point
+                    log.warn("ObjectStateUtils:writeLinkedList(): "+desc+" ["+obj.getClass().getName()+"]  ***Exception***  ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+                    //System.out.println("ObjectStateUtils:writeLinkedList(): "+desc+" ["+obj.getClass().getName()+"]  ***Exception***  ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+
+                    if (log.isTraceEnabled())
+                    {
+                        // informational
+                        ex.printStackTrace();
+                    }
+                }
+            }
+
+            // put the end-of-marker in the stream
+            out.writeObject(LAST_ENTRY);
+            savedListSize++;
+
+            out.writeInt(savedListSize);
+
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:writeLinkedList(): List ["+desc+"]   members saved ["+savedListSize+"]");
+            }
+            //System.out.println("ObjectStateUtils:writeLinkedList(): List ["+desc+"]   members saved ["+savedListSize+"]");
+        }
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:writeLinkedList(): END    List ["+desc+"]  ");
+        }
+        //System.out.println("ObjectStateUtils:writeLinkedList(): END    List ["+desc+"]  ");
+
+    }
+
+
+    /**
+     * Reads a linked list of objects from the specified input stream.  Returns
+     * null if no array is available.
+     * <P>
+     * The format of the information to be read from the input stream should be
+     * <LI> class name
+     * <LI> active or empty
+     * <LI> data
+     * <P>
+     * NOTE: each object in the array should implement either 
+     * java.io.Serializable or java.io.Externalizable in order to be
+     * saved
+     * <P>
+     * 
+     * @param in     The input stream
+     * @param desc   A text description to use for logging
+     * 
+     * @return The linked list or null, if not available
+     * 
+     * @exception IOException
+     * @exception ClassNotFoundException
+     */
+    public static LinkedList readLinkedList(ObjectInput in, String desc) throws IOException
+    {
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:readLinkedList(): BEGIN    List  ["+desc+"]");
+        }
+        //System.out.println("ObjectStateUtils:readLinkedList(): BEGIN    ["+desc+"]");
+
+
+        // The format of the data is
+        //
+        //  Non-null list:
+        //    UTF          - description string
+        //    boolean      - active flag
+        //    int          - expected number of entries in the list
+        //                        not including the last entry marker
+        //    objects      - objects from list
+        //                        last entry will be the LAST_ENTRY marker
+        //    int          - adjusted number of entries in the list
+        //                        includes the last entry
+        //    
+        //  Empty list:
+        //    UTF          - description string
+        //    boolean      - empty flag
+        //
+
+        LinkedList list = new LinkedList();
+
+        String str_desc = in.readUTF();
+
+        boolean isActive = in.readBoolean();
+
+        if (isActive == ACTIVE_OBJECT)
+        {
+            // get the expected number of entries
+            int expectedListSize = in.readInt();
+
+            // process the objects
+            boolean keepGoing = true;
+            int     count     = 0;
+            Object  obj       = null;
+
+            while (keepGoing)
+            {
+                // stop when we get to the end-of-list marker
+
+                // get the object
+                try
+                {
+                    obj = in.readObject();
+                    count++;
+
+                    if (obj != null)
+                    {
+                        if (obj instanceof String)
+                        {
+                            String tmp = (String) obj;
+                            if (tmp.equalsIgnoreCase(LAST_ENTRY))
+                            {
+                                // this is the last entry
+                                keepGoing = false;
+
+                            } //end if last entry marker
+                        } // end if a String object
+
+                        if (keepGoing)
+                        {
+                            String tmpClassName = obj.getClass().getName();
+
+                            // not at the end of the list so
+                            // add the entry to the list
+                            list.add(obj);
+
+                            // trace point
+                            if (log.isTraceEnabled())
+                            {
+                                log.trace("ObjectStateUtils:readLinkedList(): ["+desc+"]  index ["+count+"]  object ["+tmpClassName+"] ");
+                            }
+                            //System.out.println("ObjectStateUtils:readLinkedList(): ["+desc+"]  index ["+count+"]  object ["+tmpClassName+"]  ");
+                        }
+                    }
+                    else
+                    {
+                        // some other problem occurred
+                        // the object to be read is null
+                        // trace point
+                        if (log.isTraceEnabled())
+                        {
+                            log.trace("ObjectStateUtils:readLinkedList(): ["+desc+"]  object index ["+count+"] ***Unexpected null object***");
+                        }
+                        //System.out.println("ObjectStateUtils:readLinkedList(): ["+desc+"]  object index ["+count+"] ***Unexpected null object***");
+                        keepGoing = false;
+                    }
+                }
+                catch (Exception ex)
+                {
+                    // use this as a generic point for all exceptions
+
+                    // trace point
+                    log.warn("ObjectStateUtils:readLinkedList(): ["+desc+"]  object index ["+count+"] ***Exception***  ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+                    //System.out.println("ObjectStateUtils:readLinkedList(): ["+desc+"]  object index ["+count+"] ***Exception***  ["+ex.getClass().getName()+" : "+ex.getMessage()+"]");
+
+                    ex.printStackTrace();
+
+                    keepGoing = false;
+                }
+
+            } // end while keep going
+
+            int adjustedNumberEntries = in.readInt();
+
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:readLinkedList(): adjusted number of entries ["+adjustedNumberEntries+"]    ");
+            }
+            //System.out.println("ObjectStateUtils:readLinkedList(): adjusted number of entries ["+adjustedNumberEntries+"]    ");
+
+
+            if (list.isEmpty())
+            {
+                // trace point
+                if (log.isTraceEnabled())
+                {
+                    log.trace("ObjectStateUtils:readLinkedList(): ["+desc+"]  returning  [null]");
+                    log.trace("ObjectStateUtils:readLinkedList(): END    List  ["+desc+"]");
+                }
+                //System.out.println("ObjectStateUtils:readLinkedList(): ["+desc+"]  returning  [null]");
+                //System.out.println("ObjectStateUtils:readLinkedList(): END    ["+desc+"]");
+
+                return null;
+            }
+            else
+            {
+                // trace point
+                if (log.isTraceEnabled())
+                {
+                    log.trace("ObjectStateUtils:readLinkedList(): ["+desc+"]  returning  [listsize="+list.size()+"]");
+                    log.trace("ObjectStateUtils:readLinkedList(): END    List  ["+desc+"]");
+                }
+                //System.out.println("ObjectStateUtils:readLinkedList(): ["+desc+"]  returning  [listsize="+list.size()+"]");
+                //System.out.println("ObjectStateUtils:readLinkedList(): END    ["+desc+"]");
+
+                return list;
+            }
+        }
+        else
+        {
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:readLinkedList(): ["+desc+"]  returning  [null]");
+                log.trace("ObjectStateUtils:readLinkedList(): END    List  ["+desc+"]");
+            }
+            //System.out.println("ObjectStateUtils:readLinkedList(): ["+desc+"]  returning  [null]");
+            //System.out.println("ObjectStateUtils:readLinkedList(): END    ["+desc+"]");
+
+            return null;
+        }
+    }
+
+
+
+    //--------------------------------------------------------------------
+    // Finder methods
+    //--------------------------------------------------------------------
+
+    /**
+     * Find the AxisOperation object that matches the criteria
+     * 
+     * @param axisConfig The AxisConfiguration object
+     * @param opClassName
+     *                   the class name string for the target object
+     *                   (could be a derived class)
+     * @param opQName    the name associated with the operation
+     * 
+     * @return the AxisOperation object that matches the given criteria
+     */
+    public static AxisOperation findOperation(AxisConfiguration axisConfig, String opClassName, QName opQName)
+    {
+        HashMap services = axisConfig.getServices();
+
+        Iterator its = services.values().iterator();
+
+        while (its.hasNext())
+        {
+            AxisService service = (AxisService)its.next();
+
+            Iterator ito = service.getOperations();
+
+            while (ito.hasNext())
+            {
+                AxisOperation operation = (AxisOperation)ito.next();
+
+                String tmpOpName  = operation.getClass().getName();
+                QName  tmpOpQName = operation.getName();
+
+                if ((tmpOpName.equals(opClassName)) && (tmpOpQName.equals(opQName)))
+                {
+                    // trace point
+                    if (log.isTraceEnabled())
+                    {
+                        log.trace("ObjectStateUtils:findOperation(axisCfg): returning  ["+opClassName+"]   ["+opQName.toString()+"]");
+                    }
+                    //System.out.println("ObjectStateUtils:findOperation(axisCfg): returning  ["+opClassName+"]   ["+opQName.toString()+"]");
+
+                    return operation;
+                }
+            }
+        }
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:findOperation(axisCfg): ["+opClassName+"]   ["+opQName.toString()+"]  returning  [null]");
+        }
+        //System.out.println("ObjectStateUtils:findOperation(axisCfg): ["+opClassName+"]   ["+opQName.toString()+"]  returning  [null]");
+
+        return null;
+    }
+
+
+    /**
+     * Find the AxisOperation object that matches the criteria
+     * 
+     * @param service    The AxisService object
+     * @param opClassName
+     *                   The class name string for the target object
+     *                   (could be a derived class)
+     * @param opQName    the name associated with the operation
+     * 
+     * @return the AxisOperation object that matches the given criteria
+     */
+    public static AxisOperation findOperation(AxisService service, String opClassName, QName opQName)
+    {
+        if (service == null)
+        {
+            return null;
+        }
+
+        Iterator ito = service.getOperations();
+
+        while (ito.hasNext())
+        {
+            AxisOperation operation = (AxisOperation)ito.next();
+
+            String tmpOpName  = operation.getClass().getName();
+            QName  tmpOpQName = operation.getName();
+
+            if ((tmpOpName.equals(opClassName)) && (tmpOpQName.equals(opQName)))
+            {
+                // trace point
+                if (log.isTraceEnabled())
+                {
+                    log.trace("ObjectStateUtils:findOperation(service): returning  ["+opClassName+"]   ["+opQName.toString()+"]");
+                }
+                //System.out.println("ObjectStateUtils:findOperation(service): returning  ["+opClassName+"]   ["+opQName.toString()+"]");
+
+                return operation;
+            }
+        }
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:findOperation(service): ["+opClassName+"]   ["+opQName.toString()+"]  returning  [null]");
+        }
+        //System.out.println("ObjectStateUtils:findOperation(service): ["+opClassName+"]   ["+opQName.toString()+"]  returning  [null]");
+
+        return null;
+    }
+
+
+    /**
+     * Find the AxisService object that matches the criteria
+     * 
+     * @param axisConfig The AxisConfiguration object
+     * @param serviceClassName
+     *                   the class name string for the target object
+     *                   (could be a derived class)
+     * @param serviceName
+     *                   the name associated with the service
+     *
+     * @return the AxisService object that matches the criteria
+     */
+    public static AxisService findService(AxisConfiguration axisConfig, String serviceClassName, String serviceName)
+    {
+        HashMap services = axisConfig.getServices();
+
+        Iterator its = services.values().iterator();
+
+        while (its.hasNext())
+        {
+            AxisService service = (AxisService)its.next();
+
+            String tmpServClassName = service.getClass().getName();
+            String tmpServName      = service.getName();
+
+            if ((tmpServClassName.equals(serviceClassName)) && (tmpServName.equals(serviceName)))
+            {
+                // trace point
+                if (log.isTraceEnabled())
+                {
+                    log.trace("ObjectStateUtils:findService(): returning  ["+serviceClassName+"]   ["+serviceName+"]");
+                }
+                //System.out.println("ObjectStateUtils:findService(): returning  ["+serviceClassName+"]   ["+serviceName+"]");
+
+                return service;
+            }
+        }
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:findService(): ["+serviceClassName+"]   ["+serviceName+"]  returning  [null]");
+        }
+        //System.out.println("ObjectStateUtils:findService(): ["+serviceClassName+"]   ["+serviceName+"]  returning  [null]");
+
+        return null;
+    }
+
+    /**
+     * Find the AxisServiceGroup object that matches the criteria
+     * 
+     * <B>Note<B> the saved service group meta information may not
+     * match up with any of the serviceGroups that
+     * are in the current AxisConfiguration object.
+     * 
+     * @param axisConfig The AxisConfiguration object
+     * @param serviceGrpClassName
+     *                   the class name string for the target object
+     *                   (could be a derived class)
+     * @param serviceGrpName
+     *                   the name associated with the service group
+     * @return the AxisServiceGroup object that matches the criteria
+     */
+    public static AxisServiceGroup findServiceGroup(AxisConfiguration axisConfig, String serviceGrpClassName, String serviceGrpName)
+    {
+        Iterator its = axisConfig.getServiceGroups();
+
+        while (its.hasNext())
+        {
+            AxisServiceGroup serviceGroup = (AxisServiceGroup)its.next();
+
+            String tmpSGClassName = serviceGroup.getClass().getName();
+            String tmpSGName      = serviceGroup.getServiceGroupName();
+
+            if (tmpSGClassName.equals(serviceGrpClassName))
+            {
+                boolean found = false;
+
+                // the serviceGroupName can be null, so either both the 
+                // service group names are null or they match
+                if ((tmpSGName == null) && (serviceGrpName == null))
+                {
+                    found = true;
+                }
+                else if ((tmpSGName != null) && (tmpSGName.equals(serviceGrpName)))
+                {
+                    found = true;
+                }
+
+                if (found)
+                {
+                    // trace point
+                    if (log.isTraceEnabled())
+                    {
+                        log.trace("ObjectStateUtils:findServiceGroup(): returning  ["+serviceGrpClassName+"]   ["+serviceGrpName+"]");
+                    }
+                    //System.out.println("ObjectStateUtils:findServiceGroup(): returning  ["+serviceGrpClassName+"]   ["+serviceGrpName+"]");
+
+                    return serviceGroup;
+                }
+            }
+        }
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:findServiceGroup(): ["+serviceGrpClassName+"]   ["+serviceGrpName+"]  returning  [null]");
+        }
+        //System.out.println("ObjectStateUtils:findServiceGroup(): ["+serviceGrpClassName+"]   ["+serviceGrpName+"]  returning  [null]");
+
+        return null;
+    }
+
+
+    /**
+     * Find the AxisMessage object that matches the criteria
+     * 
+     * @param op             The AxisOperation object
+     * @param msgName        The name associated with the message
+     * @param msgElementName The name associated with the message element
+     * 
+     * @return the AxisMessage object that matches the given criteria
+     */
+    public static AxisMessage findMessage(AxisOperation op, String msgName, String msgElementName)
+    {
+        // Several kinds of AxisMessages can be associated with a particular 
+        // AxisOperation.  The kinds of AxisMessages that are typically
+        // accessible are associated with "in" and "out".  
+        // There are also different kinds of AxisOperations, and each
+        // type of AxisOperation can have its own mix of AxisMessages
+        // depending on the style of message exchange pattern (mep)
+
+        if (op == null)
+        {
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:findMessage(): ["+msgName+"]  ["+msgElementName+"] returning  [null] - no AxisOperation");
+            }
+            //System.out.println("ObjectStateUtils:findMessage(): ["+msgName+"]  ["+msgElementName+"] returning  [null] - no AxisOperation");
+
+            return null;
+        }
+
+        if (msgName == null)
+        {
+            // nothing to match with, expect to match against a name
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:findMessage(): ["+msgName+"]  ["+msgElementName+"] returning  [null] - message name is not set");
+            }
+            //System.out.println("ObjectStateUtils:findMessage(): ["+msgName+"]  ["+msgElementName+"] returning  [null] - message name is not set");
+
+            return null;
+        }
+
+
+        String  tmpName        = null;
+        String  tmpElementName = null;
+
+        //-------------------------------------
+        // first try the "out" message
+        //-------------------------------------
+        AxisMessage out = null;
+        try
+        {
+            out = op.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
+        }
+        catch (Exception ex)
+        {
+            // just absorb the exception
+        }
+
+        if (out != null)
+        {
+            tmpName = out.getName();
+
+            QName tmpQout = out.getElementQName();
+            if (tmpQout != null)
+            {
+                tmpElementName = tmpQout.toString();
+            }
+        }
+
+        // check the criteria for a match
+
+        boolean matching = matchMessageNames(tmpName, tmpElementName, msgName, msgElementName);
+
+        if (matching)
+        {
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:findMessage(): returning OUT message  ["+msgName+"]  ["+msgElementName+"] ");
+            }
+            //System.out.println("ObjectStateUtils:findMessage(): returning OUT message  ["+msgName+"]  ["+msgElementName+"] ");
+
+            return out;
+        }
+
+        //-------------------------------------
+        // next, try the "in" message 
+        //-------------------------------------
+        AxisMessage in = null;
+        try
+        {
+            in = op.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE);
+        }
+        catch (Exception ex)
+        {
+            // just absorb the exception
+        }
+
+        if (in != null)
+        {
+            tmpName = in.getName();
+
+            QName tmpQin = in.getElementQName();
+            if (tmpQin != null)
+            {
+                tmpElementName = tmpQin.toString();
+            }
+        }
+        else
+        {
+            tmpName        = null;
+            tmpElementName = null;
+        }
+
+        // check the criteria for a match
+
+        matching = matchMessageNames(tmpName, tmpElementName, msgName, msgElementName);
+
+        if (matching)
+        {
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:findMessage(): returning IN message ["+msgName+"]  ["+msgElementName+"] ");
+            }
+            //System.out.println("ObjectStateUtils:findMessage(): returning IN message  ["+msgName+"]  ["+msgElementName+"] ");
+
+            return in;
+        }
+
+        // if we got here, then no match was found
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:findMessage(): ["+msgName+"]  ["+msgElementName+"] returning  [null]");
+        }
+        //System.out.println("ObjectStateUtils:findMessage(): ["+msgName+"]  ["+msgElementName+"] returning  [null]");
+
+        return null;
+    }
+
+    /**
+     * Check the first set of names for a match against
+     * the second set of names.  These names are 
+     * associated with AxisMessage objects. Message names
+     * are expected to be non-null.  Element names could
+     * be either null or non-null.
+     * 
+     * @param name1  The name for the first message
+     * @param elementName1
+     *               The element name for the first message
+     * @param name2  The name for the second message
+     * @param elementName2
+     *               The element name for the second message
+     * @return TRUE if there's a match,
+     *         FALSE otherwise
+     */
+    private static boolean matchMessageNames(String name1, String elementName1, String name2, String elementName2)
+    {
+        // the name for the message must exist
+        if ((name1 != null) && (name2 != null) && (name1.equals(name2)))
+        {
+            // there's a match on the name associated with the message object
+
+            // element names need to match, including being null
+            if ((elementName1 == null) && (elementName2 == null))
+            {
+                // there's a match for the nulls
+                return true;
+            }
+            else if ((elementName1 != null) && (elementName2 != null) && (elementName1.equals(elementName2)))
+            {
+                // there's a match for the element names
+                return true;
+            }
+            else
+            {
+                // there's some mismatch
+                return false;
+            }
+        }
+        else
+        {
+            // either a message name is null or the names don't match
+            return false;
+        }
+    }
+
+
+    /**
+     * Find the Handler object that matches the criteria
+     * 
+     * @param existingHandlers The list of existing handlers and phases
+     * @param handlerClassName
+     *                   the class name string for the target object
+     *                   (could be a derived class)
+     *
+     * @return the Handler object that matches the criteria
+     */
+    public static Object findHandler(ArrayList existingHandlers, MetaDataEntry metaDataEntry) //String handlerClassName)
+    {
+
+        String title = "ObjectStateUtils:findHandler(): ";
+
+    	String handlerClassName = metaDataEntry.getClassName();
+    	String qNameAsString = metaDataEntry.getQNameAsString();
+    	
+        for (int i=0; i < existingHandlers.size(); i++)
+        {
+            if (existingHandlers.get(i) != null)
+            {
+                String tmpClassName = existingHandlers.get(i).getClass().getName();
+                String tmpName      = ((Handler)existingHandlers.get(i)).getName().toString();
+
+                if ( (tmpClassName.equals(handlerClassName))
+                   && (tmpName.equals(qNameAsString)))
+                {
+                    // trace point
+                    if (log.isTraceEnabled())
+                    {
+                        log.trace(title+" ["+handlerClassName+"]  name ["+qNameAsString+"]  returned");
+                    }
+                    //System.out.println(title+" ["+handlerClassName+"]  name ["+qNameAsString+"]  returned");
+
+                    return(Handler)(existingHandlers.get(i));
+                }
+            }
+        }
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(title + " ["+handlerClassName+"]  name ["+qNameAsString+"] was not found in the existingHandlers list");
+        }
+        //System.out.println(title + " ["+handlerClassName+"]  name ["+qNameAsString+"] was not found in the existingHandlers list");
+        
+        return null;
+    }
+
+
+    /**
+     * Find the TransportListener object that matches the criteria
+     * 
+     * <B>Note<B> the saved meta information may not
+     * match up with any of the objects that
+     * are in the current AxisConfiguration object.
+     * 
+     * @param axisConfig The AxisConfiguration object
+     * @param listenerClassName
+     *                   the class name string for the target object
+     *                   (could be a derived class)
+     * @return the TransportListener object that matches the criteria
+     */
+    public static TransportListener findTransportListener(AxisConfiguration axisConfig, String listenerClassName)
+    {
+        // TODO: investigate a better technique to match up with a TransportListener
+
+        HashMap transportsIn = axisConfig.getTransportsIn();
+
+        // get a collection of the values in the map
+        Collection values = transportsIn.values();
+
+        Iterator i = values.iterator();
+        
+        while (i.hasNext())
+        {
+            TransportInDescription ti = (TransportInDescription)i.next();
+
+            TransportListener tl = ti.getReceiver();
+            String tlClassName = tl.getClass().getName();
+
+            if (tlClassName.equals(listenerClassName))
+            {
+                // trace point
+                if (log.isTraceEnabled())
+                {
+                    log.trace("ObjectStateUtils:findTransportListener():  ["+listenerClassName+"]  returned");
+                }
+                //System.out.println("ObjectStateUtils:findTransportListener():  ["+listenerClassName+"]  returned");
+
+                return tl;
+            }
+        }
+
+        // trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace("ObjectStateUtils:findTransportListener(): returning  [null]");
+        }
+        //System.out.println("ObjectStateUtils:findTransportListener(): returning  [null]");
+
+        return null;
+    }
+
+    /**
+     * Compares the two collections to see if they are equivalent.
+     * 
+     * @param a1  The first collection
+     * @param a2  The second collection
+     * @param strict  Indicates whether strict checking is required.  Strict
+     *                checking means that the two collections must have the
+     *                same elements in the same order.  Non-strict checking
+     *                means that the two collections must have the same 
+     *                elements, but the order is not significant.
+     * @return TRUE if the two collections are equivalent
+     *         FALSE, otherwise
+     */
+    public static boolean isEquivalent(ArrayList a1, ArrayList a2, boolean strict)
+    {
+        if ((a1 != null) && (a2 != null))
+        {
+            // check number of elements in lists
+            int size1 = a1.size();
+            int size2 = a2.size();
+
+            if (size1 != size2)
+            {
+                // trace point
+                if (log.isTraceEnabled())
+                {
+                    log.trace("ObjectStateUtils:isEquivalent(ArrayList,ArrayList): FALSE - size mismatch ["+size1+"] != ["+size2+"]");
+                }
+                //System.out.println("ObjectStateUtils:isEquivalent(ArrayList,ArrayList): FALSE - size mismatch ["+size1+"] != ["+size2+"]");
+                return false;
+            }
+
+            if (strict)
+            {
+                // Strict checking
+                // The lists must contain the same elements in the same order.
+                return (a1.equals(a2));
+            }
+            else
+            {
+                // Non-strict checking
+                // The lists must contain the same elements but the order is not required.
+                Iterator i1 = a1.iterator();
+
+                while (i1.hasNext())
+                {
+                    Object obj1 = i1.next();
+
+                    if (!a2.contains(obj1))
+                    {
+                        // trace point
+                        if (log.isTraceEnabled())
+                        {
+                            log.trace("ObjectStateUtils:isEquivalent(ArrayList,ArrayList): FALSE - mismatch with element ["+obj1.getClass().getName()+"] ");
+                        }
+                        //System.out.println("ObjectStateUtils:isEquivalent(ArrayList,ArrayList): FALSE - mismatch with element ["+obj1.getClass().getName()+"] ");
+                        return false;
+                    }
+                }
+
+                return true;
+            }
+
+        }
+        else if ((a1 == null) && (a2 == null))
+        {
+            return true;
+        }
+        else
+        {
+            // mismatch
+
+            // trace point
+            if (log.isTraceEnabled())
+            {
+                log.trace("ObjectStateUtils:isEquivalent(ArrayList,ArrayList): FALSE - mismatch in lists");
+            }
+            //System.out.println("ObjectStateUtils:isEquivalent(ArrayList,ArrayList): FALSE - mismatch in lists");
+            return false;
+        }
+    }
+
+    /**
+     * Compares the two collections to see if they are equivalent.
+     * 
+     * @param m1  The first collection
+     * @param m2  The second collection
+     * @return TRUE if the two collections are equivalent
+     *         FALSE, otherwise
+     */
+    public static boolean isEquivalent(Map m1, Map m2)
+    {
+        if ((m1 != null) && (m2 != null))
+        {
+            // This is a strict test.
+            // Returns true if the given object is also a map and the two Maps 
+            // represent the same mappings. 
+            return (m1.equals(m2));
+        }
+        else if ((m1 == null) && (m2 == null))
+        {
+            return true;
+        }
+        else
+        {
+            // mismatch
+            return false;
+        }
+    }
+
+
+    /**
+     * Compares the two collections to see if they are equivalent.
+     * 
+     * @param l1  The first collection
+     * @param l2  The second collection
+     * @return TRUE if the two collections are equivalent
+     *         FALSE, otherwise
+     */
+    public static boolean isEquivalent(LinkedList l1, LinkedList l2)
+    {
+        if ((l1 != null) && (l2 != null))
+        {
+            // This is a strict test.
+            // Returns true if the specified object is also a list, 
+            // both lists have the same size, and all corresponding pairs 
+            // of elements in the two lists are equal where
+            // they contain the same elements in the same order.
+            return (l1.equals(l2));
+        }
+        else if ((l1 == null) && (l2 == null))
+        {
+            return true;
+        }
+        else
+        {
+            // mismatch
+            return false;
+        }
+    }
+}
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/client/Options.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/client/Options.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/kernel/src/org/apache/axis2/client/Options.java	(working copy)
@@ -1,3 +1,18 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.axis2.client;
 
 import org.apache.axiom.om.OMElement;
@@ -7,30 +22,31 @@
 import org.apache.axis2.addressing.AddressingConstants;
 import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.addressing.RelatesTo;
+import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.description.TransportInDescription;
 import org.apache.axis2.description.TransportOutDescription;
 import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.transport.TransportListener;
+import org.apache.axis2.util.MetaDataEntry;
+import org.apache.axis2.util.ObjectStateUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 
 import javax.xml.namespace.QName;
-import java.util.*;
+import java.io.ByteArrayOutputStream;
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutput;
+import java.io.ObjectOutputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
-/*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 
 /**
  * Holder for operation client options. This is used by the other classes in
@@ -42,20 +58,61 @@
  * property inheritance, so that if a property is not set in one instance it
  * will check its parent for a setting.
  */
-public class Options {
+public class Options implements Externalizable {
 
+    /*
+     * setup for logging
+     */
+    private static final Log log = LogFactory.getLog(Options.class);
+
+    private static final String myClassName = "Options";
+
     /**
+     * @serial The serialization version ID tracks the version of the class.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. If a change to the class is made which is
+     * not compatible with the serialization/externalization of the class,
+     * then the serialization version ID should be updated.
+     * Refer to the "serialVer" utility to compute a serialization
+     * version ID.
+     */
+    private static final long serialVersionUID = -8318751890845181507L;
+
+    /**
+     * @serial Tracks the revision level of a class to identify changes to the 
+     * class definition that are compatible to serialization/externalization.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected. 
+     * Refer to the writeExternal() and readExternal() methods.
+     */
+    // supported revision levels, add a new level to manage compatible changes
+    private static final int REVISION_1 = 1;
+    // current revision level of this object
+    private static final int revisionID = REVISION_1;
+
+    
+    /**
      * Default blocking timeout value.
      */
     public static final int DEFAULT_TIMEOUT_MILLISECONDS = 30 * 1000;
 
+
+    /**
+     * @serial parent
+     */
     private Options parent;
 
+
+    /**
+     * @serial properties
+     */
     private Map properties = new HashMap();
 
+
     // ==========================================================================
     //                  Parameters that can be set via Options
     // ==========================================================================
+
     private String soapVersionURI; // defaults to
     // SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI;
 
@@ -96,10 +153,45 @@
     private EndpointReference to;
 
     //To control , session management , default is set to true , if user wants he can set that to true
-    // There operation client will manage session using ServiceGroupID if it is there in the response
+    // The operation client will manage session using ServiceGroupID if it is there in the response
     private boolean manageSession = false;
 
+
+    //----------------------------------------------------------------
+    // MetaData for data to be restored in activate after readExternal
+    //----------------------------------------------------------------
+    
     /**
+     * Indicates whether this object has been reconstituted
+     * and needs to have its object references reconciled
+     */
+    private transient boolean needsToBeReconciled = false;
+
+    /**
+     * The TransportOutDescription metadata will be used during
+     * activate to match up with an existing object
+     */
+    private transient MetaDataEntry metaTransportOut = null;
+    
+    /**
+     * The TransportInDescription metadata will be used during
+     * activate to match up with an existing object
+     */
+    private transient MetaDataEntry metaTransportIn = null;
+    
+    /**
+     * The TransportListener metadata will be used during
+     * activate to match up with an existing object, if possible
+     */
+    private transient MetaDataEntry metaListener = null;
+    
+    //----------------------------------------------------------------
+    // end MetaData section
+    //----------------------------------------------------------------
+
+
+
+    /**
      * Default constructor
      */
     public Options() {
@@ -158,6 +250,13 @@
      * @return listener
      */
     public TransportListener getListener() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getListener(): ****WARNING**** Options.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getListener(): ****WARNING**** Options.activate(configurationContext) needs to be invoked.");
+        }
+
         if (listener == null && parent != null) {
             return parent.getListener();
         }
@@ -170,6 +269,13 @@
      * @return transport information
      */
     public TransportInDescription getTransportIn() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getTransportIn(): ****WARNING**** Options.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getTransportIn(): ****WARNING**** Options.activate(configurationContext) needs to be invoked.");
+        }
+
         if (transportIn == null && parent != null) {
             return parent.getTransportIn();
         }
@@ -215,6 +321,11 @@
      * @return copy of general properties
      */
     public Map getProperties() {
+        // make sure that the Options properties exists
+        if (this.properties == null) {
+            this.properties = new HashMap();
+        }
+
         if (parent == null) {
             return new HashMap(properties);
         } else {
@@ -231,6 +342,11 @@
      * @return the value related to this key. <code>null</code>, if not found.
      */
     public Object getProperty(String key) {
+        // make sure that the Options properties exists
+        if (this.properties == null) {
+            this.properties = new HashMap();
+        }
+
         Object myPropValue = properties.get(key);
         if (myPropValue == null && parent != null) {
             return parent.getProperty(key);
@@ -252,7 +368,10 @@
         if (relationships == null && parent != null) {
             return parent.getRelatesTo(type);
         }
-        for (int i = 0; relationships != null && i < relationships.size(); i++) {
+        if (relationships == null) {
+            return null;
+        }
+        for (int i = 0;i < relationships.size(); i++) {
             RelatesTo relatesTo = (RelatesTo) relationships.get(i);
             String relationshipType = relatesTo.getRelationshipType();
             if (relationshipType.equals(type)) {
@@ -273,7 +392,10 @@
         if (relationships == null && parent != null) {
             return parent.getRelatesTo();
         }
-        for (int i = 0; relationships != null && i < relationships.size(); i++) {
+        if (relationships == null) {
+            return null;
+        }
+        for (int i = 0;i < relationships.size(); i++) {
             RelatesTo relatesTo = (RelatesTo) relationships.get(i);
             String relationshipType = relatesTo.getRelationshipType();
             if (relationshipType.equals(AddressingConstants.Final.WSA_DEFAULT_RELATIONSHIP_TYPE)
@@ -327,6 +449,13 @@
      * @return description
      */
     public TransportOutDescription getTransportOut() {
+        if (needsToBeReconciled) {
+            if (log.isWarnEnabled()) {
+                log.warn(myClassName+":getTransportOut(): ****WARNING**** Options.activate(configurationContext) needs to be invoked.");
+            }
+            //System.out.println(myClassName+":getTransportOut(): ****WARNING**** Options.activate(configurationContext) needs to be invoked.");
+        }
+
         if (transportOut == null && parent != null) {
             return parent.getTransportOut();
         }
@@ -708,6 +837,10 @@
      * @param property
      */
     public void setProperty(String propertyKey, Object property) {
+        // make sure that the Options properties exists
+        if (this.properties == null) {
+            this.properties = new HashMap();
+        }
         properties.put(propertyKey, property);
     }
 
@@ -891,4 +1024,730 @@
     public void setManageSession(boolean manageSession) {
         this.manageSession = manageSession;
     }
+
+
+
+    /* ===============================================================
+     * Externalizable support 
+     * ===============================================================
+     */
+    
+    /**
+     * Save the contents of this object.
+     * <p>
+     * NOTE: Transient fields and static fields are not saved.
+     *
+     * @param out    The stream to write the object contents to
+     * 
+     * @exception IOException
+     */
+    public void writeExternal(ObjectOutput out) throws IOException
+    {
+        // write out contents of this object
+
+        // NOTES: For each item, where appropriate,
+        //        write out the following information, IN ORDER:
+        //           the class name
+        //           the active or empty flag
+        //           the data length, if appropriate
+        //           the data   
+
+        //---------------------------------------------------------
+        // in order to handle future changes to the message 
+        // context definition, be sure to maintain the 
+        // object level identifiers
+        //---------------------------------------------------------
+        // serialization version ID
+        out.writeLong(serialVersionUID);
+
+        // revision ID
+        out.writeInt(revisionID);
+
+        //---------------------------------------------------------
+        // various simple fields
+        //---------------------------------------------------------
+        out.writeLong(timeOutInMilliSeconds);
+
+        out.writeBoolean(manageSession);
+
+        // the following objects could be null
+        ObjectStateUtils.writeObject(out, isExceptionToBeThrownOnSOAPFault, "Options.isExceptionToBeThrownOnSOAPFault");
+        ObjectStateUtils.writeObject(out, useSeparateListener, "Options.useSeparateListener");
+
+
+        //---------------------------------------------------------
+        // various strings
+        //---------------------------------------------------------
+
+        // String soapVersionURI
+        ObjectStateUtils.writeString(out, soapVersionURI, "Options.soapVersionURI");
+
+        // String action
+        ObjectStateUtils.writeString(out, action, "Options.action");
+
+        // String transportInProtocol
+        ObjectStateUtils.writeString(out, transportInProtocol, "Options.transportInProtocol");
+
+        // String messageId
+        ObjectStateUtils.writeString(out, messageId, "Options.messageId");
+
+
+        //---------------------------------------------------------
+        // various objects
+        //---------------------------------------------------------
+
+        // EndpointReference faultTo
+        ObjectStateUtils.writeObject(out, faultTo, "Options.faultTo");
+
+        // EndpointReference from
+        ObjectStateUtils.writeObject(out, from, "Options.from");
+
+        // EndpointReference replyTo
+        ObjectStateUtils.writeObject(out, replyTo, "Options.replyTo");
+
+        // EndpointReference to
+        ObjectStateUtils.writeObject(out, to, "Options.to");
+
+
+        // TransportListener listener
+        if (listener != null)
+        {
+            metaListener = new MetaDataEntry(listener.getClass().getName(), null);
+        }
+        else
+        {
+            metaListener = null;
+        }
+        ObjectStateUtils.writeObject(out, metaListener, "Options.listener");
+
+
+        // TransportInDescription transportIn
+        if (transportIn != null)
+        {
+            metaTransportIn = new MetaDataEntry(null, transportIn.getName().toString());
+        }
+        else
+        {
+            metaTransportIn = null;
+        }
+        ObjectStateUtils.writeObject(out, metaTransportIn, "Options.transportIn");
+
+
+        // TransportOutDescription transportOut
+        if (transportOut != null)
+        {
+            metaTransportOut = new MetaDataEntry(null, transportOut.getName().toString());
+        }
+        else
+        {
+            metaTransportOut = null;
+        }
+        ObjectStateUtils.writeObject(out, metaTransportOut, "Options.transportOut");
+
+
+
+
+        //---------------------------------------------------------
+        // collections and lists
+        //---------------------------------------------------------
+
+        // List relationships, which is an array of RelatesTo objects 
+        ArrayList tmp = null;
+
+        if (relationships != null)
+        {
+            // make sure this is an array list
+            tmp = new ArrayList(relationships);
+        }
+
+        ObjectStateUtils.writeArrayList(out, tmp, "Options.relationships");
+
+        // ArrayList referenceParameters
+        ObjectStateUtils.writeArrayList(out, referenceParameters, "Options.referenceParameters");
+
+        //---------------------------------------------------------
+        // properties
+        //---------------------------------------------------------
+                                     
+        // HashMap properties
+        HashMap tmpHM = new HashMap(properties);
+
+        ObjectStateUtils.writeHashMap(out, tmpHM, "Options.properties");
+
+
+        //---------------------------------------------------------
+        // "nested"
+        //---------------------------------------------------------
+
+        // Options parent
+        ObjectStateUtils.writeObject(out, parent, "Options.parent");
+
+
+    }
+
+
+    /**
+     * Restore the contents of the MessageContext that was 
+     * previously saved. 
+     * <p> 
+     * NOTE: The field data must read back in the same order and type
+     * as it was written.  Some data will need to be validated when 
+     * resurrected.
+     *
+     * @param in    The stream to read the object contents from 
+     * 
+     * @exception IOException
+     * @exception ClassNotFoundException
+     */
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
+    {
+        // serialization version ID
+        long suid = in.readLong();
+
+        // revision ID
+        int  revID = in.readInt();
+
+        // make sure the object data is in a version we can handle
+        if (suid != serialVersionUID)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+        }
+
+        // make sure the object data is in a revision level we can handle
+        if (revID != REVISION_1)
+        {
+            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        }
+
+
+        //---------------------------------------------------------
+        // various simple fields
+        //---------------------------------------------------------
+        timeOutInMilliSeconds = in.readLong();
+
+        manageSession = in.readBoolean();
+
+        // the following objects could be null
+        Object tmp1 = ObjectStateUtils.readObject(in, "Options.isExceptionToBeThrownOnSOAPFault"); 
+        if (tmp1 != null)
+        {
+            isExceptionToBeThrownOnSOAPFault = (Boolean) tmp1;
+        }
+
+        Object tmp2 = ObjectStateUtils.readObject(in, "Options.useSeparateListener"); 
+        if (tmp2 != null)
+        {
+            useSeparateListener = (Boolean) tmp2;
+        }
+
+
+        //---------------------------------------------------------
+        // various strings
+        //---------------------------------------------------------
+
+        // String soapVersionURI
+        soapVersionURI = ObjectStateUtils.readString(in,"Options.soapVersionURI");
+
+        // String action
+        action = ObjectStateUtils.readString(in, "Options.action");
+
+        // String transportInProtocol
+        transportInProtocol = ObjectStateUtils.readString(in, "Options.transportInProtocol");
+
+        // String messageId
+        messageId = ObjectStateUtils.readString(in, "Options.messageId");
+
+
+        //---------------------------------------------------------
+        // various objects
+        //---------------------------------------------------------
+
+        // EndpointReference faultTo
+        faultTo = (EndpointReference) ObjectStateUtils.readObject(in, "Options.faultTo");
+
+        // EndpointReference from
+        from = (EndpointReference) ObjectStateUtils.readObject(in, "Options.from");
+
+        // EndpointReference replyTo
+        replyTo = (EndpointReference) ObjectStateUtils.readObject(in, "Options.replyTo");
+
+        // EndpointReference to
+        to = (EndpointReference) ObjectStateUtils.readObject(in, "Options.to");
+
+
+        // TransportListener listener
+        // is not usable until the meta data has been reconciled
+        listener = null;
+        metaListener = (MetaDataEntry) ObjectStateUtils.readObject(in, "Options.metaListener");
+
+        // TransportInDescription transportIn
+        // is not usable until the meta data has been reconciled
+        transportIn = null;
+        metaTransportIn = (MetaDataEntry) ObjectStateUtils.readObject(in, "Options.metaTransportIn");
+
+        // TransportOutDescription transportOut
+        // is not usable until the meta data has been reconciled
+        transportOut = null;
+        metaTransportOut = (MetaDataEntry) ObjectStateUtils.readObject(in, "Options.metaTransportOut");
+
+
+        //---------------------------------------------------------
+        // collections and lists
+        //---------------------------------------------------------
+
+        // List relationships, which is an array of RelatesTo objects 
+        ArrayList tmpAL1 = ObjectStateUtils.readArrayList(in, "Options.relationships");
+        if (tmpAL1 != null)
+        {
+            relationships = new ArrayList(tmpAL1);
+        }
+        else
+        {
+            relationships = null;
+        }
+
+        // ArrayList referenceParameters
+        ArrayList tmpAL2 = ObjectStateUtils.readArrayList(in, "Options.referenceParameters");
+        if (tmpAL2 != null)
+        {
+            referenceParameters = new ArrayList(tmpAL2);
+        }
+        else
+        {
+            referenceParameters = null;
+        }
+
+        //---------------------------------------------------------
+        // properties
+        //---------------------------------------------------------
+                                      
+        // HashMap properties
+        HashMap tmpHM = ObjectStateUtils.readHashMap(in, "Options.properties"); 
+
+        if (tmpHM != null)
+        {
+            properties = new HashMap(tmpHM);
+        }
+        else
+        {
+            properties = new HashMap();
+        }
+
+
+        //---------------------------------------------------------
+        // "nested"
+        //---------------------------------------------------------
+
+        // Options parent
+        Object tmpParent = ObjectStateUtils.readObject(in, "Options.parent"); 
+
+        if (tmpParent != null)
+        {
+            parent = (Options) tmpParent;
+        }
+        else
+        {
+            parent = null;
+        }
+
+        
+    }
+
+    /**
+     * This method checks to see if additional work needs to be
+     * done in order to complete the object reconstitution.
+     * Some parts of the object restored from the readExternal()
+     * cannot be completed until we have a configurationContext
+     * from the active engine. The configurationContext is used
+     * to help this object to plug back into the engine's
+     * configuration and deployment objects.
+     * 
+     * @param cc     The configuration context object representing the active configuration
+     */
+    public void activate(ConfigurationContext cc)
+    {
+        // see if there's any work to do
+        if (needsToBeReconciled == false)
+        {
+            // return quick
+            return;
+        }
+
+        // do a trace point
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":activate():  BEGIN");
+        }
+        //System.out.println(myClassName+":activate():  BEGIN");
+
+
+        // use the supplied configuration context
+
+        // get the axis configuration 
+        AxisConfiguration axisConfig = cc.getAxisConfiguration();
+
+        // We previously saved metaTransportIn; restore it
+        if (metaTransportIn != null)
+        {
+            QName qin = metaTransportIn.getQName();
+            TransportInDescription tmpIn = null;
+            try
+            {
+                tmpIn = axisConfig.getTransportIn(qin);
+            }
+            catch (Exception exin)
+            {
+                // if a fault is thrown, log it and continue
+                log.warn(myClassName+"activate():  exception caught when getting the TransportInDescription ["+qin.toString()+"]  from the AxisConfiguration ["+exin.getClass().getName()+" : "+exin.getMessage()+"]");
+
+                //System.out.println(myClassName+"activate():  exception caught when getting the TransportInDescription ["+qin.toString()+"]  from the AxisConfiguration ["+exin.getClass().getName()+" : "+exin.getMessage()+"]");
+            }
+
+            if (tmpIn != null)
+            {
+                transportIn = tmpIn;
+            }
+            else
+            {
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+"activate():  No TransportInDescription found for ["+qin.toString()+"]");
+                }
+
+                //System.out.println(myClassName+"activate():  No TransportInDescription found for ["+qin.toString()+"]");
+
+                transportIn = null;
+            }
+        }
+        else
+        {
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+"activate():  No TransportInDescription ");
+            }
+
+            //System.out.println(myClassName+"activate():  No TransportInDescription ");
+
+            transportIn = null;
+        }
+
+        // We previously saved metaTransportOut; restore it
+        if (metaTransportOut != null)
+        {
+            QName qout = metaTransportOut.getQName();
+            TransportOutDescription tmpOut = null;
+            try
+            {
+                tmpOut = axisConfig.getTransportOut(qout);
+            }
+            catch (Exception exout)
+            {
+                // if a fault is thrown, log it and continue
+                log.warn(myClassName+"activate():  exception caught when getting the TransportOutDescription ["+qout.toString()+"]  from the AxisConfiguration ["+exout.getClass().getName()+" : "+exout.getMessage()+"]");
+
+                //System.out.println(myClassName+"activate():  exception caught when getting the TransportOutDescription ["+qout.toString()+"]  from the AxisConfiguration ["+exout.getClass().getName()+" : "+exout.getMessage()+"]");
+            }
+
+            if (tmpOut != null)
+            {
+                transportOut = tmpOut;
+            }
+            else
+            {
+                if (log.isTraceEnabled())
+                {
+                    log.trace(myClassName+"activate():  No TransportOutDescription found for ["+qout.toString()+"]");
+                }
+
+                //System.out.println(myClassName+"activate():  No TransportOutDescription found for ["+qout.toString()+"]");
+
+
+                transportOut = null;
+            }
+        }
+        else
+        {
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+"activate():  No TransportOutDescription ");
+            }
+
+            //System.out.println(myClassName+"activate():  No TransportOutDescription ");
+
+            transportOut = null;
+        }
+
+
+
+        // We previously saved metaListener; restore it
+        if (metaListener != null)
+        {
+            // see if we can find an existing object
+            String listenerClass = metaListener.getClassName();
+            TransportListener tmpListener = ObjectStateUtils.findTransportListener(axisConfig, listenerClass);
+
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+"activate():  TransportListener found for ["+listenerClass+"] ");
+            }
+
+            //System.out.println(myClassName+"activate():  TransportListener found for ["+listenerClass+"] ");
+
+        }
+        else
+        {
+            listener = null;
+
+            if (log.isTraceEnabled())
+            {
+                log.trace(myClassName+"activate():  No TransportListener ");
+            }
+
+            //System.out.println(myClassName+"activate():  No TransportListener ");
+        }
+
+
+        //-------------------------------------------------------
+        // done, reset the flag
+        //-------------------------------------------------------
+        needsToBeReconciled = false;
+
+        if (log.isTraceEnabled())
+        {
+            log.trace(myClassName+":activate():  END");
+        }
+
+        //System.out.println(myClassName+":activate():  END");
+    }
+
+
+    /**
+     * Compares key parts of the state from the current instance of 
+     * this class with the specified instance to see if they are 
+     * equivalent. 
+     * <P>
+     * This differs from the java.lang.Object.equals() method in
+     * that the equals() method generally looks at both the 
+     * object identity (location in memory) and the object state
+     * (data).
+     * <P>
+     * 
+     * @param  obj  The object to compare with
+     * @return TRUE if this object is equivalent with the specified object
+     *              that is, key fields match
+     *         FALSE, otherwise
+     */
+    public boolean isEquivalent(Options obj)
+    {
+        // NOTE: the input object is expected to exist (ie, be non-null)
+
+        if (this.timeOutInMilliSeconds != obj.getTimeOutInMilliSeconds())
+        {
+            return false;
+        }
+
+        if (this.isExceptionToBeThrownOnSOAPFault.booleanValue() != obj.isExceptionToBeThrownOnSOAPFault())
+        {
+            return false;
+        }
+
+        if (this.useSeparateListener.booleanValue() != obj.isUseSeparateListener())
+        {
+            return false;
+        }
+
+        if (this.manageSession != obj.isManageSession())
+        {
+            return false;
+        }
+
+        // --------------------------------------------------------------------
+
+        if ((this.soapVersionURI != null) && (obj.getSoapVersionURI() != null))
+        {
+            if (!this.soapVersionURI.equals(obj.getSoapVersionURI()))
+            {
+                return false;
+            }
+        }
+        else if ((this.soapVersionURI == null) && (obj.getSoapVersionURI() == null))
+        {
+            // continue
+        }
+        else
+        {
+            // mismatch
+            return false;
+        }
+        
+        // --------------------------------------------------------------------
+
+        if ((this.action != null) && (obj.getAction() != null))
+        {
+            if (!this.action.equals(obj.getAction()))
+            {
+                return false;
+            }
+        }
+        else if ((this.action == null) && (obj.getAction() == null))
+        {
+            // continue
+        }
+        else
+        {
+            // mismatch
+            return false;
+        }
+        
+        // --------------------------------------------------------------------
+
+        if ((this.transportInProtocol != null) && (obj.getTransportInProtocol() != null))
+        {
+            if (!this.transportInProtocol.equals(obj.getTransportInProtocol()))
+            {
+                return false;
+            }
+        }
+        else if ((this.transportInProtocol == null) && (obj.getTransportInProtocol() == null))
+        {
+            // continue
+        }
+        else
+        {
+            // mismatch
+            return false;
+        }
+        
+        // --------------------------------------------------------------------
+
+        if ((this.messageId != null) && (obj.getMessageId() != null))
+        {
+            if (!this.messageId.equals(obj.getMessageId()))
+            {
+                return false;
+            }
+        }
+        else if ((this.messageId == null) && (obj.getMessageId() == null))
+        {
+            // continue
+        }
+        else
+        {
+            // mismatch
+            return false;
+        }
+        
+        // --------------------------------------------------------------------
+
+        if ((this.faultTo != null) && (obj.getFaultTo() != null))
+        {
+            if (!this.faultTo.isEquivalent(obj.getFaultTo()))
+            {
+                return false;
+            }
+        }
+        else if ((this.faultTo == null) && (obj.getFaultTo() == null))
+        {
+            // continue
+        }
+        else
+        {
+            // mismatch
+            return false;
+        }
+        
+        // --------------------------------------------------------------------
+
+        if ((this.from != null) && (obj.getFrom() != null))
+        {
+            if (!this.from.isEquivalent(obj.getFrom()))
+            {
+                return false;
+            }
+        }
+        else if ((this.from == null) && (obj.getFrom() == null))
+        {
+            // continue
+        }
+        else
+        {
+            // mismatch
+            return false;
+        }
+        
+        // --------------------------------------------------------------------
+
+        if ((this.replyTo != null) && (obj.getReplyTo() != null))
+        {
+            if (!this.replyTo.isEquivalent(obj.getReplyTo()))
+            {
+                return false;
+            }
+        }
+        else if ((this.replyTo == null) && (obj.getReplyTo() == null))
+        {
+            // continue
+        }
+        else
+        {
+            // mismatch
+            return false;
+        }
+        
+        // --------------------------------------------------------------------
+
+        if ((this.to != null) && (obj.getTo() != null))
+        {
+            if (!this.to.isEquivalent(obj.getTo()))
+            {
+                return false;
+            }
+        }
+        else if ((this.to == null) && (obj.getTo() == null))
+        {
+            // continue
+        }
+        else
+        {
+            // mismatch
+            return false;
+        }
+        
+        // --------------------------------------------------------------------
+
+        if ((this.properties != null) && (obj.getProperties() != null))
+        {
+            if (!this.properties.equals(obj.getProperties()))
+            {
+                // This is a strict test.
+                // Returns true if the given object is also a map 
+                // and the two maps represent the same mappings. 
+                return false;
+            }
+        }
+        else if ((this.properties == null) && (obj.getProperties() == null))
+        {
+            // continue
+        }
+        else
+        {
+            // mismatch
+            return false;
+        }
+        
+        // --------------------------------------------------------------------
+
+        // TODO: consider checking the following objects for equivalency
+        //        List relationships;
+        //        ArrayList referenceParameters;
+        //        TransportListener listener;
+        //        TransportInDescription transportIn;
+        //        TransportOutDescription transportOut;
+
+        // TODO: consider checking the parent objects for equivalency
+
+
+        return true;
+    }
+
 }
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/integration/test/org/apache/axis2/engine/PausingHandlerExecutionTest.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/integration/test/org/apache/axis2/engine/PausingHandlerExecutionTest.java	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/integration/test/org/apache/axis2/engine/PausingHandlerExecutionTest.java	(working copy)
@@ -36,8 +36,17 @@
 
 import javax.xml.namespace.QName;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Iterator;
 import java.util.List;
 
 import junit.framework.Test;
@@ -70,6 +79,8 @@
 
   protected void setUp() throws Exception
   {
+    //org.apache.log4j.BasicConfigurator.configure();
+
     testResults = new ArrayList();
 
     if (!initDone)
@@ -81,10 +92,12 @@
         Phase globalInPhase = (Phase)globalInPhases.get(i);
         if (PhaseMetadata.PHASE_PRE_DISPATCH.equals(globalInPhase.getPhaseName()))
         {
+          System.out.println("Adding handlers to  globalInPhase   name ["+globalInPhase.getPhaseName()+"]  ...");
           globalInPhase.addHandler(new TestHandler("In1"));
           middleGlobalInHandler = new TestHandler("In2");
           globalInPhase.addHandler(middleGlobalInHandler);
           globalInPhase.addHandler(new TestHandler("In3"));
+          System.out.println("...done adding handlers to  globalInPhase   name ["+globalInPhase.getPhaseName()+"]  ...");
         }
       }
     }
@@ -169,17 +182,38 @@
 
     /*Since the response is going back separately, we need to give the server
      *time to unwind the rest of the invocation.*/
-    Thread.sleep(5000);
+    //Thread.sleep(5000);
+    Thread.sleep(7000);
 
+    Iterator it = testResults.iterator();
+    int count = 0;
+    while (it.hasNext())
+    {
+        count ++;
+        String tmp = (String) it.next();
+        System.out.println("Test Results ["+count+"] = ["+tmp+"]");
+    }
+
+    //-----------------------------------------------------------------------
+    // uncomment/comment out the desired results based on whether pausing
+    // the message context
+
+    // expected results when not pausing
+    //List expectedExecutionState = Arrays.asList(new String[] {"In1", "In2", "In3", "In4", "In5", "In6", "Out1", "Out2", "Out3", "FCOut3", "FCOut2", "FCOut1", "FCIn6", "FCIn5", "FCIn4", "FCIn3", "FCIn2", "FCIn1"});
+
+    // expected results when pausing
     List expectedExecutionState = Arrays.asList(new String[] {"In1", "In2", "In2", "In3", "In4", "In5", "In6", "Out1", "Out2", "Out3", "FCOut3", "FCOut2", "FCOut1", "FCIn6", "FCIn5", "FCIn4", "FCIn3", "FCIn2", "FCIn1"});
+    //-----------------------------------------------------------------------
     assertEquals(expectedExecutionState, testResults);
+
   }
   
   private class TestHandler extends AbstractHandler
   {
     private String handlerName;
-    private boolean shouldFail;
-    private boolean shouldPause;
+    private boolean shouldFail = false;
+    private boolean shouldPause = false;
+    private boolean shouldSave = true;
 
     public TestHandler(String handlerName)
     {
@@ -188,6 +222,7 @@
 
     public void shouldFail(boolean fail)
     {
+      System.out.println("Setting shouldFail to "+fail+" for "+handlerName);
       this.shouldFail = fail;
     }
 
@@ -199,50 +234,274 @@
 
     public InvocationResponse invoke(MessageContext msgContext) throws AxisFault
     {
-      System.out.println("TestHandler " + handlerName + " invoked");
+      String title = "TestHandler["+handlerName+"] ";
+      System.out.println(title+" invoked:");
+      
+      // check if the handler should fail
       if (shouldFail)
       {
-        testResults.add("kaboom");
-        System.out.println("Handler went kaboom");
-        throw new AxisFault("Handler failed");
+        String failmsg = title +" kaboom";
+        System.out.println(title+" adding ["+failmsg+"] to testResults list");
+        testResults.add(failmsg);
+        System.out.println(failmsg);
+        throw new AxisFault(failmsg + "   Handler failed");
       }
+
+      // add this handler to the list of invoked handlers
+      System.out.println(title+" adding this handler to testResults list");
       testResults.add(handlerName);
+
+      boolean isPaused = msgContext.isPaused();
+      if (isPaused)
+      {
+          System.out.println(title+"   message context is paused   *****");
+      }
+      else
+      {
+          System.out.println(title+"   message context is not paused");
+      }
+
+      checkLists(msgContext);
+
+      // check if the handler should pause
       if (shouldPause)
       {
-        System.out.println("Handler pausing");
+        String pausemsg = title +" - pausing the message context";
+        System.out.println(pausemsg);
         msgContext.pause();
         shouldPause = false;
-        new Worker(msgContext).start();
+
+        File   theFile     = null;
+        String theFilename = null;
+
+        try
+        {
+            theFile = File.createTempFile("pHexec",null);
+            theFilename = theFile.getName();
+            System.out.println(title + "temp file = ["+theFilename+"]");
+        }
+        catch (Exception ex)
+        {
+            System.out.println(title + "error creating temp file = ["+ex.getMessage()+"]");
+            theFile = null;
+        }
+
+        if (theFile != null)
+        {
+            // save to the temporary file
+            try
+            {
+                // setup an output stream to a physical file
+                FileOutputStream outStream = new FileOutputStream(theFile);
+
+                // attach a stream capable of writing objects to the 
+                // stream connected to the file
+                ObjectOutputStream outObjStream = new ObjectOutputStream(outStream);
+
+                // try to save the message context
+                System.out.println(title + "saving message context.....");
+                outObjStream.writeObject(msgContext);
+
+                // close out the streams
+                outObjStream.flush();
+                outObjStream.close();
+                outStream.flush();
+                outStream.close();
+
+                System.out.println(title + "....saved message context.....");
+
+                long filesize = theFile.length();
+                System.out.println(title + "file size after save ["+filesize+"]   temp file = ["+theFilename+"]");
+
+                new Worker(theFile, msgContext.getConfigurationContext()).start();
+            }
+            catch (IOException e)
+            {
+                e.printStackTrace();
+                fail("An error occurred when serializing the MessageContext");
+            }
+        }
+        else
+        {
+            // couldn't get a temporary file
+            new Worker(msgContext, msgContext.getConfigurationContext()).start();
+        }
         return InvocationResponse.SUSPEND;
-      }
+      } // end if should pause
+
       return InvocationResponse.CONTINUE;      
     }
 
     public void flowComplete(MessageContext msgContext)
     {
-      System.out.println("TestHandler " + handlerName
-          + " called for flowComplete()");
+      String title = "TestHandler["+handlerName+"] ";
+      String label = "FC" + handlerName;
+      System.out.println(title + " flowComplete(): adding ["+label+"] to testResults list"); 
       testResults.add("FC" + handlerName);
     }
+
+    private void checkLists(MessageContext mc)
+    {
+        if (mc == null)
+        {
+            return;
+        }
+
+        String title = "TestHandler["+handlerName+"] ";
+
+        System.out.println(title + "Checking execution chain.....");
+        ArrayList execList = mc.getExecutionChain();
+        Iterator execIt = null;
+        if (execList != null)
+        {
+            execIt = execList.iterator();
+        }
+        checkHandler(execIt);
+
+        System.out.println(title + "Checking inbound executed phases list.....");
+        Iterator inboundIt = mc.getInboundExecutedPhases();
+        checkHandler(inboundIt);
+
+        System.out.println(title + "Checking outbound executed phases list.....");
+        Iterator outboundIt = mc.getOutboundExecutedPhases();
+        checkHandler(outboundIt);
+    }
+
+    private void checkHandler(Iterator it)
+    {
+        if (it == null)
+        {
+            return;
+        }
+
+        while (it.hasNext())
+        {
+            Handler handler = (Handler) it.next();
+
+            if (handler instanceof Handler)
+            {
+                System.out.println("Handler name ["+handler.getName()+"]");
+            }
+            else if (handler instanceof Phase)
+            {
+                Phase phase = (Phase) handler;
+                System.out.println("Phase name ["+phase.getName()+"]");
+
+                ArrayList list2 = phase.getHandlers();
+                Iterator it2 = list2.iterator();
+                checkHandler(it2);
+            }
+        }
+
+    }
+
+
   }
   
   private class Worker extends Thread
   {
-    private MessageContext msgContext;
+    private byte[] serializedMessageContext = null;
+    private ConfigurationContext configurationContext = null;  
+    private File theFile = null;
+    private String theFilename = null;
+    private MessageContext msgContext = null;
     
     public Worker(MessageContext msgContext)
     {
       this.msgContext = msgContext;
+      this.configurationContext = msgContext.getConfigurationContext();
     }
     
+    public Worker(byte[] serializedMessageContext, ConfigurationContext configurationContext)
+    {
+      this.serializedMessageContext = serializedMessageContext;
+      this.configurationContext = configurationContext;
+    }       
+
+    public Worker(File theFile, ConfigurationContext configurationContext)
+    {
+      this.theFile = theFile;
+      this.configurationContext = configurationContext;
+    }       
+
+    public Worker(MessageContext mc, ConfigurationContext configurationContext)
+    {
+      this.msgContext = mc;
+      this.configurationContext = configurationContext;
+    }       
+
+
     public void run()
     {
       try
       {
         System.out.println("Worker thread started");
         Thread.sleep(5000);
-        AxisEngine axisEngine = new AxisEngine(msgContext.getConfigurationContext());
-        axisEngine.resume(msgContext);
+        AxisEngine axisEngine = new AxisEngine(configurationContext);
+
+        FileInputStream inStream = null;
+        ObjectInputStream objectInputStream = null;
+        MessageContext reconstitutedMessageContext = null;
+
+        if (theFile != null)
+        {
+            // setup an input stream to the file
+            inStream = new FileInputStream(theFile);
+
+            // attach a stream capable of reading objects from the 
+            // stream connected to the file
+            objectInputStream = new ObjectInputStream(inStream);
+
+            System.out.println("Worker thread restoring message context from file");
+            reconstitutedMessageContext = (MessageContext)objectInputStream.readObject();
+        }
+        else if (serializedMessageContext != null)
+        {
+            // use the byte array
+            objectInputStream = new ObjectInputStream(new ByteArrayInputStream(serializedMessageContext));
+
+            System.out.println("Worker thread restoring message context from byte array");
+            reconstitutedMessageContext = (MessageContext)objectInputStream.readObject();
+        }
+        else if (msgContext != null)
+        {
+            System.out.println("Worker thread using message context");
+            reconstitutedMessageContext = msgContext;
+        }
+        
+        if (inStream != null)
+        {
+            inStream.close();
+        }
+
+        if (objectInputStream != null)
+        {
+            objectInputStream.close();
+        }
+
+        if (theFile != null)
+        {
+            // remove the temporary file
+            try
+            {
+                theFile.delete();
+            }
+            catch (Exception e)
+            {
+                // just absorb it
+            }
+        }
+
+        if (reconstitutedMessageContext != null)
+        {
+            System.out.println("Worker thread resuming message context");
+            axisEngine.resume(reconstitutedMessageContext);
+        }
+        else
+        {
+            fail("An error occurred in the worker thread - no message context");
+        }
+
       }
       catch (Exception e)
       {
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/integration/test/org/apache/axis2/engine/MessageSaveAndRestoreTest.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/integration/test/org/apache/axis2/engine/MessageSaveAndRestoreTest.java	(revision 0)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/integration/test/org/apache/axis2/engine/MessageSaveAndRestoreTest.java	(revision 0)
@@ -0,0 +1,216 @@
+/*
+ * Copyright 2006 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.engine;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.soap.SOAP12Constants;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.client.Options;
+import org.apache.axis2.client.ServiceClient;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.engine.util.TestConstants;
+import org.apache.axis2.handlers.AbstractHandler;
+import org.apache.axis2.integration.TestingUtils;
+import org.apache.axis2.integration.UtilServer;
+import org.apache.axis2.integration.UtilServerBasedTestCase;
+import org.apache.axis2.phaseresolver.PhaseMetadata;
+import org.apache.axis2.util.Utils;
+
+import javax.xml.namespace.QName;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.ArrayList;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+/**
+ * This tests the saving and restoring of the Axis2 contexts from within a
+ * handler.  This is a more thorough test of the serialization mechanisms
+ * than the other unit tests, as the contexts are populated from the beginning
+ * of the Axis2 execution path.
+ */
+public class MessageSaveAndRestoreTest extends UtilServerBasedTestCase implements TestConstants 
+{
+    public MessageSaveAndRestoreTest()
+    {
+        super(MessageSaveAndRestoreTest.class.getName());
+    }
+
+    public MessageSaveAndRestoreTest(String testName)
+    {
+        super(testName);
+    }
+
+    public static Test suite()
+    {
+        return getTestSetup(new TestSuite(MessageSaveAndRestoreTest.class));
+    }
+
+    protected void setUp() throws Exception
+    {
+        AxisService service = Utils.createSimpleService(TestConstants.serviceName,
+                                                        Echo.class.getName(),
+                                                        TestConstants.operationName);
+        UtilServer.deployService(service);
+
+        AxisOperation operation = service.getOperation(TestConstants.operationName);
+
+        ArrayList phases = new ArrayList();
+        phases.add(new Phase(PhaseMetadata.PHASE_POLICY_DETERMINATION));
+        operation.setRemainingPhasesInFlow(phases);
+        ArrayList phase = operation.getRemainingPhasesInFlow();
+        for (int i = 0; i < phase.size(); i++)
+        {
+            Phase phase1 = (Phase)phase.get(i);
+            if (PhaseMetadata.PHASE_POLICY_DETERMINATION.equals(phase1.getPhaseName()))
+            {
+                phase1.addHandler(inboundHandler);
+            }
+        }
+
+        phases = new ArrayList();
+        phases.add(new Phase(PhaseMetadata.PHASE_POLICY_DETERMINATION));
+        operation.setPhasesOutFlow(phases);
+        phase = operation.getPhasesOutFlow();
+        for (int i = 0; i < phase.size(); i++)
+        {
+            Phase phase1 = (Phase)phase.get(i);
+            if (PhaseMetadata.PHASE_POLICY_DETERMINATION.equals(phase1.getPhaseName()))
+            {
+                phase1.addHandler(outboundHandler);
+            }
+        }
+    }
+
+    protected void tearDown() throws Exception
+    {
+        UtilServer.unDeployService(TestConstants.serviceName);
+        UtilServer.unDeployClientService();
+    }
+
+    public void testSaveAndRestoreOfMessage() throws Exception
+    {
+        OMElement payload = TestingUtils.createDummyOMElement();
+        Options options = new Options();
+        options.setTo(TestConstants.targetEPR);
+        options.setSoapVersionURI(SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI);
+        options.setTransportInProtocol(Constants.TRANSPORT_HTTP);
+        options.setAction(TestConstants.operationName.getLocalPart());
+        options.setUseSeparateListener(true);
+
+        ConfigurationContext configContext = UtilServer.createClientConfigurationContext();
+
+        ServiceClient sender = new ServiceClient(configContext, null);
+        sender.setOptions(options);
+        sender.engageModule(new QName("addressing"));
+
+        OMElement result = sender.sendReceive(payload);
+
+        TestingUtils.campareWithCreatedOMElement(result);
+    }
+
+    private Handler inboundHandler = new AbstractHandler()
+    {
+        private static final long serialVersionUID = 1L;
+        private String stateProperty = "InboundHandlerState";
+
+        public InvocationResponse invoke(MessageContext messageContext) throws AxisFault
+        {
+            System.out.println("MessageSaveAndRestoreTest:Inbound handler invoked");
+            if (messageContext.getProperty(stateProperty) == null)
+            {
+                System.out.println("MessageSaveAndRestoreTest:Suspending processing");
+                messageContext.setProperty(stateProperty, new Object());
+                messageContext.pause();
+                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+                try
+                {
+                    ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
+                    objectOutputStream.writeObject(messageContext);
+                    objectOutputStream.flush();
+                    objectOutputStream.close();
+                    byteArrayOutputStream.flush();
+                    byteArrayOutputStream.close();
+                }
+                catch (IOException e)
+                {
+                    e.printStackTrace();
+                    fail("An error occurred when serializing the MessageContext");
+                }
+                new Worker(byteArrayOutputStream.toByteArray(), messageContext.getConfigurationContext()).start();
+                return InvocationResponse.SUSPEND;
+            }
+            else
+            {
+                System.out.println("MessageSaveAndRestoreTest:Skipping previously invoked Inbound handler");
+            }
+
+            return InvocationResponse.CONTINUE;
+        }
+    };  
+
+    private Handler outboundHandler = new AbstractHandler()
+    {
+        private static final long serialVersionUID = 1L;
+
+        public InvocationResponse invoke(MessageContext messageContext) throws AxisFault
+        {
+            System.out.println("MessageSaveAndRestoreTest:Outbound handler invoked");
+            return InvocationResponse.CONTINUE;
+        }
+    };
+
+    private class Worker extends Thread
+    {
+        private byte[] serializedMessageContext;
+        private ConfigurationContext configurationContext;
+
+        public Worker(byte[] serializedMessageContext, ConfigurationContext configurationContext)
+        {
+            this.serializedMessageContext = serializedMessageContext;
+            this.configurationContext = configurationContext;
+        }
+
+        public void run()
+        {
+            try
+            {
+                System.out.println("MessageSaveAndRestoreTest:Worker thread started");
+                Thread.sleep(5000);
+                AxisEngine axisEngine = new AxisEngine(configurationContext);
+                System.out.println("MessageSaveAndRestoreTest:Resuming processing");
+                ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(serializedMessageContext));
+                MessageContext reconstitutedMessageContext = (MessageContext)objectInputStream.readObject();
+                axisEngine.resume(reconstitutedMessageContext);
+            }
+            catch (Exception e)
+            {
+                e.printStackTrace();
+                fail("An error occurred in the worker thread");
+            }
+        }
+    }
+}
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/integration/test/org/apache/axis2/mtom/MessageSaveAndRestoreWithMTOMTest.java
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/integration/test/org/apache/axis2/mtom/MessageSaveAndRestoreWithMTOMTest.java	(revision 0)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/integration/test/org/apache/axis2/mtom/MessageSaveAndRestoreWithMTOMTest.java	(revision 0)
@@ -0,0 +1,273 @@
+/*
+ * Copyright 2006 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.mtom;
+
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.OMFactory;
+import org.apache.axiom.om.OMNamespace;
+import org.apache.axiom.om.OMText;
+import org.apache.axiom.om.impl.llom.OMTextImpl;
+import org.apache.axiom.soap.SOAP12Constants;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.client.Options;
+import org.apache.axis2.client.ServiceClient;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.ConfigurationContextFactory;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.engine.AxisEngine;
+import org.apache.axis2.engine.Echo;
+import org.apache.axis2.engine.Handler;
+import org.apache.axis2.engine.Phase;
+import org.apache.axis2.engine.util.TestConstants;
+import org.apache.axis2.handlers.AbstractHandler;
+import org.apache.axis2.integration.UtilServer;
+import org.apache.axis2.integration.UtilServerBasedTestCase;
+import org.apache.axis2.phaseresolver.PhaseMetadata;
+import org.apache.axis2.util.Utils;
+
+import javax.activation.DataHandler;
+import javax.activation.FileDataSource;
+import javax.imageio.ImageIO;
+import javax.xml.namespace.QName;
+
+import java.awt.Image;
+import java.awt.image.BufferedImage;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.ArrayList;
+
+import junit.framework.Test;
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+/**
+ * This tests the saving and restoring of the Axis2 contexts from within a
+ * handler when MTOM is used.  This is a more thorough test of the serialization
+ * mechanisms than the other unit tests, as the contexts are populated from the
+ * beginning of the Axis2 codepath.
+ */
+public class MessageSaveAndRestoreWithMTOMTest extends UtilServerBasedTestCase implements TestConstants 
+{
+    private OMTextImpl expectedTextData = null;
+
+    public MessageSaveAndRestoreWithMTOMTest()
+    {
+        super(MessageSaveAndRestoreWithMTOMTest.class.getName());
+
+        org.apache.log4j.BasicConfigurator.configure();
+    }
+
+    public MessageSaveAndRestoreWithMTOMTest(String testName)
+    {
+        super(testName);
+
+        org.apache.log4j.BasicConfigurator.configure();
+    }
+
+    public static Test suite()
+    {
+        return getTestSetup2(new TestSuite(MessageSaveAndRestoreWithMTOMTest.class),Constants.TESTING_PATH + "MTOM-enabledRepository");
+    }
+
+    protected void setUp() throws Exception
+    {
+
+        AxisService service = Utils.createSimpleService(TestConstants.serviceName,
+                                                        Echo.class.getName(),
+                                                        TestConstants.operationName);
+        UtilServer.deployService(service);
+
+        AxisOperation operation = service.getOperation(TestConstants.operationName);
+
+        ArrayList phases = new ArrayList();
+        phases.add(new Phase(PhaseMetadata.PHASE_POLICY_DETERMINATION));
+        operation.setRemainingPhasesInFlow(phases);
+        ArrayList phase = operation.getRemainingPhasesInFlow();
+        for (int i = 0; i < phase.size(); i++)
+        {
+            Phase phase1 = (Phase)phase.get(i);
+            if (PhaseMetadata.PHASE_POLICY_DETERMINATION.equals(phase1.getPhaseName()))
+            {
+                phase1.addHandler(inboundHandler);
+            }
+        }
+
+        phases = new ArrayList();
+        phases.add(new Phase(PhaseMetadata.PHASE_POLICY_DETERMINATION));
+        operation.setPhasesOutFlow(phases);
+        phase = operation.getPhasesOutFlow();
+        for (int i = 0; i < phase.size(); i++)
+        {
+            Phase phase1 = (Phase)phase.get(i);
+            if (PhaseMetadata.PHASE_POLICY_DETERMINATION.equals(phase1.getPhaseName()))
+            {
+                phase1.addHandler(outboundHandler);
+            }
+        }
+    }
+
+    protected void tearDown() throws Exception
+    {
+        UtilServer.unDeployService(TestConstants.serviceName);
+        UtilServer.unDeployClientService();
+    }
+
+    public void testSaveAndRestoreOfMessage() throws Exception
+    {
+        OMElement payload = createEnvelope();
+
+        Options options = new Options();
+        options.setTo(TestConstants.targetEPR);
+        options.setProperty(Constants.Configuration.ENABLE_MTOM, Constants.VALUE_TRUE);
+        options.setTransportInProtocol(Constants.TRANSPORT_HTTP);
+        options.setSoapVersionURI(SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI);
+        options.setAction(Constants.AXIS2_NAMESPACE_URI+"/"+TestConstants.operationName.getLocalPart());
+        options.setUseSeparateListener(true);
+
+        ConfigurationContext configurationContext = ConfigurationContextFactory.createConfigurationContextFromFileSystem("target/test-resources/integrationRepo",null); 
+
+        ServiceClient sender = new ServiceClient(configurationContext,null);
+        sender.setOptions(options);
+        sender.engageModule(new QName("addressing"));
+
+        OMElement result = sender.sendReceive(payload);
+
+        OMElement element = (OMElement) result.getFirstOMChild();
+        OMText binaryNode = (OMText) element.getFirstOMChild();
+
+        compareWithCreatedOMText(binaryNode);
+
+        DataHandler actualDH = (DataHandler) binaryNode.getDataHandler();
+        BufferedImage bi = ImageIO.read(actualDH.getDataSource().getInputStream());
+    }
+
+    protected OMElement createEnvelope() throws Exception
+    {
+        OMFactory omFactory = OMAbstractFactory.getOMFactory();
+        OMNamespace omNamespace = omFactory.createOMNamespace("http://localhost/my", "my");
+        OMElement rpcWrapperElement = omFactory.createOMElement("echoOMElement", omNamespace);
+        OMElement data = omFactory.createOMElement("data", omNamespace);
+
+        FileDataSource fileDataSource = new FileDataSource("test-resources/mtom/test.jpg");
+        DataHandler expectedDataHandler = new DataHandler(fileDataSource);
+        expectedTextData = new OMTextImpl(expectedDataHandler, true, omFactory);
+        data.addChild(expectedTextData);
+        rpcWrapperElement.addChild(data);
+        return rpcWrapperElement;
+
+    }
+
+    protected InputStream getResourceAsStream(String path)
+    {
+        return Thread.currentThread().getContextClassLoader().getResourceAsStream(path);
+    }
+
+    protected void compareWithCreatedOMText(OMText actualTextData)
+    {
+        String originalTextValue = expectedTextData.getText();
+        String returnedTextValue = actualTextData.getText();
+        TestCase.assertEquals(returnedTextValue, originalTextValue);
+    }
+
+    private Handler inboundHandler = new AbstractHandler()
+    {
+        private static final long serialVersionUID = 1L;
+        private String stateProperty = "InboundHandlerState";
+
+        public InvocationResponse invoke(MessageContext messageContext) throws AxisFault
+        {
+            System.out.println("MessageSaveAndRestoreWithMTOMTest:Inbound handler invoked");
+            if (messageContext.getProperty(stateProperty) == null)
+            {
+                System.out.println("MessageSaveAndRestoreWithMTOMTest:Suspending processing");
+                messageContext.setProperty(stateProperty, new Object());
+                messageContext.pause();
+                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+                try
+                {
+                    ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
+                    objectOutputStream.writeObject(messageContext);
+                    objectOutputStream.flush();
+                    objectOutputStream.close();
+                    byteArrayOutputStream.flush();
+                    byteArrayOutputStream.close();
+                }
+                catch (IOException e)
+                {
+                    e.printStackTrace();
+                    fail("An error occurred when serializing the MessageContext");
+                }
+                new Worker(byteArrayOutputStream.toByteArray(), messageContext.getConfigurationContext()).start();
+            }
+            else
+            {
+                System.out.println("MessageSaveAndRestoreWithMTOMTest:Skipping previously invoked Inbound handler");
+            }
+            return InvocationResponse.CONTINUE;
+        }
+    };  
+
+    private Handler outboundHandler = new AbstractHandler()
+    {
+        private static final long serialVersionUID = 1L;
+
+        public InvocationResponse invoke(MessageContext messageContext) throws AxisFault
+        {
+            System.out.println("MessageSaveAndRestoreWithMTOMTest:Outbound handler invoked");
+            return InvocationResponse.CONTINUE;
+        }
+    };
+
+    private class Worker extends Thread
+    {
+        private byte[] serializedMessageContext;
+        private ConfigurationContext configurationContext;
+
+        public Worker(byte[] serializedMessageContext, ConfigurationContext configurationContext)
+        {
+            this.serializedMessageContext = serializedMessageContext;
+            this.configurationContext = configurationContext;
+        }
+
+        public void run()
+        {
+            try
+            {
+                System.out.println("MessageSaveAndRestoreWithMTOMTest:Worker thread started");
+                Thread.sleep(5000);
+                AxisEngine axisEngine = new AxisEngine(configurationContext);
+                System.out.println("MessageSaveAndRestoreWithMTOMTest:Resuming processing");
+                ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(serializedMessageContext));
+                MessageContext reconstitutedMessageContext = (MessageContext)objectInputStream.readObject();
+                axisEngine.resume(reconstitutedMessageContext);
+            }
+            catch (Exception e)
+            {
+                e.printStackTrace();
+                fail("An error occurred in the worker thread");
+            }
+        }
+    }
+}
Index: C:/WS2/apache/axis2/r468097.mcs2/modules/integration/maven.xml
===================================================================
--- C:/WS2/apache/axis2/r468097.mcs2/modules/integration/maven.xml	(revision 468097)
+++ C:/WS2/apache/axis2/r468097.mcs2/modules/integration/maven.xml	(working copy)
@@ -595,6 +595,7 @@
            <!-- MTOM enabled Repository -->
             <mkdir dir="target/test-resources/MTOM-enabledRepository"/>
             <mkdir dir="target/test-resources/MTOM-enabledRepository/conf"/>
+            <mkdir dir="target/test-resources/MTOM-enabledRepository/modules"/>
             <copy file="test-resources/mtom/MTOM-enabled-axis2.xml"
                   tofile="target/test-resources/MTOM-enabledRepository/conf/axis2.xml"/>
         	<copy file="../addressing/target/addressing-${addressing_version}.mar"
