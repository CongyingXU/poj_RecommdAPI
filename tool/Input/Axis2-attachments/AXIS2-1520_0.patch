Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointDescription.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointDescription.java	(revision 468124)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointDescription.java	(working copy)
@@ -82,6 +82,7 @@
  *         
  *  </pre>       
  */
+
 /*
  * TODO: EndpointDescription should be created via AxisService objects and not directly from WSDL
  * IMPORTANT NOTE: Axis2 currently only supports 1 service and 1 port under that service.  When that is
@@ -216,8 +217,6 @@
      *                 since they don't use an SEI
      */
     public EndpointDescription(ServiceDescription parent, String serviceImplName) {
-//TODO: This constructor is similar to the first one, other than it is getting its annotation
-//from the MDQInput List rather than the annotated class.
     	
     	// TODO: This and the other constructor will (eventually) take the same args, so the logic needs to be combined
         // TODO: If there is WSDL, could compare the namespace of the defn against the portQName.namespace
@@ -245,7 +244,10 @@
         addToAxisService();	//Add a reference to this EndpointDescription to the AxisService
 
         //TODO: Need to remove operations from AxisService that have 'exclude = true
-        //      then call 'validateOperations' to verify that WSDL and AxisService match up
+        //      then call 'validateOperations' to verify that WSDL and AxisService match up,
+        //      Remember that this will only happen when we generate an AxisService from existing
+        //		WSDL and then need to perform further processing because we have annotations as well
+        //		If there is no WSDL, we would never process the Method to begin with.
         
         buildDescriptionHierachy();
         
@@ -255,10 +257,14 @@
         //	addAnonymousAxisOperations();
         
         // This will set the serviceClient field after adding the AxisService 
-        // to the AxisConfig
-        getServiceClient();
+        // to the AxisConfig...probably not necessary on server side
+        //getServiceClient();
         
         // Give the configuration builder a chance to finalize configuration for this service
+        
+        //Supposedly, this call should only be made for the client, comment out
+        //for now. Be careful, this may be needed for finalizing configuration
+/*
         try {
             getServiceDescription().getClientConfigurationFactory().completeAxis2Configuration(axisService);
         } catch (DeploymentException e) {
@@ -276,6 +282,7 @@
             e.printStackTrace();
 //            throw ExceptionFactory.makeWebServiceException("ServiceDescription caught " + e);
         }
+        */
     }
     
     /**
@@ -389,9 +396,11 @@
     			}
     			endpointInterfaceDescription = new EndpointInterfaceDescription(seiClass, this);
     		} else {
-    			//we are processing annotations from the class itself
-    			if (DescriptionUtils.isEmpty(seiClassName)){
-    				
+    			//TODO: Determine if we need logic here to determine implied SEI or not. This logic
+    			//		may be handled by EndpointInterfaceDescription
+    			
+    			if (DescriptionUtils.isEmpty(getWebServiceEndpointInterface())) {
+    			    				
     				//TODO: Build the EndpointInterfaceDesc based on the class itself
     				endpointInterfaceDescription = new EndpointInterfaceDescription(composite, true, this);
     				
@@ -403,16 +412,18 @@
     							this);
     			}
     		}
+    	} else {
+    		//TODO: process a WebServiceProvider
     	}
     }
     
-    
     public QName getPortQName() {
         if (portQName == null) {
             // The name was not set by the constructors, so get it from the
-            // appropriate annotaion.
+            // appropriate annotation.
             String name = getWebServicePortName();
             String tns = getWebServiceTargetNamespace();
+            
             // TODO: Check for name &/| tns null or empty string and add tests for same
             portQName = new QName(tns, name);
         }
@@ -523,6 +534,11 @@
                     + createAxisServiceName());
         }
 
+        //Save the Port Type name
+        Parameter portTypeNameParameter = new Parameter();
+        portTypeNameParameter.setName(MDQConstants.WSDL_PORTTYPE_NAME);
+        portTypeNameParameter.setValue(getWebServiceName());
+        
         // Save the Service QName as a parameter.
         Parameter serviceNameParameter = new Parameter();
         serviceNameParameter.setName(MDQConstants.WSDL_SERVICE_QNAME);
@@ -536,9 +552,15 @@
 
         //Save the WSDL Definition
         Parameter wsdlDefParameter = new Parameter();
-        wsdlDefParameter.setName(MDQConstants.WSDL_DEFINITION);
-        wsdlDefParameter.setValue(getServiceDescription().getWSDLWrapper().getDefinition());
+        wsdlDefParameter.setName(MDQConstants.WSDL_DEFINITION);       
         
+        //TODO: At some point this should always return a valid WSDL definition, for now just
+        //  	make sure we don't get an NPE
+        if (getServiceDescription().getWSDLWrapper() != null) 
+            wsdlDefParameter.setValue(getServiceDescription().getWSDLWrapper().getDefinition());
+        else
+            wsdlDefParameter.setValue(getServiceDescription().getWSDLWrapper());
+        
         //Save the WSDL Location
         Parameter wsdlLocationParameter = new Parameter();
         wsdlDefParameter.setName(MDQConstants.WSDL_LOCATION);
@@ -547,9 +569,10 @@
         //Save the fully qualified class name for the serviceImpl
         Parameter serviceClassNameParameter = new Parameter();
         serviceClassNameParameter.setName(MDQConstants.SERVICE_CLASS);
-        serviceClassNameParameter.setValue(javifyClassName(composite.getClassName()));
+        serviceClassNameParameter.setValue(DescriptionUtils.javifyClassName(composite.getClassName()));
            
-        try {
+         try {        	 
+            axisService.addParameter(portTypeNameParameter);
             axisService.addParameter(serviceNameParameter);
             axisService.addParameter(portParameter);                        
             axisService.addParameter(wsdlDefParameter);
@@ -602,6 +625,9 @@
             serviceName = ServiceClient.ANON_SERVICE + this.hashCode() + System.currentTimeMillis();
         }
         axisService = new AxisService(serviceName);
+        
+        //TODO: Set other things on AxisService here, this function may have to be
+        //      moved to after we create all the AxisOperations
     }
     
     private void buildDescriptionHierachy() {
@@ -713,13 +739,6 @@
         return getServiceDescription().getServiceQName().getLocalPart() + "." + portName;
     }
 
-    private String javifyClassName(String className) {
-    	if(className.indexOf("/") != -1) {
-    		return className.replaceAll("/", ".");
-    	}
-    	return className;
-    }
-
     public boolean isProviderBased() {
         return webServiceProviderAnnotation != null;
     }
@@ -844,7 +863,31 @@
         }
         return returnName;
     }
+    
     /**
+     * Return the name of the class without any package qualifier.
+     * @param theClass
+     * @return the name of the class sans package qualification.
+     */
+    private static String getSimpleJavaClassName(String name) {
+        String returnName = null;
+        
+        if (name != null) {
+            String fqName = name;
+            
+            // We need the "simple name", so strip off any package information from the name
+            int endOfPackageIndex = fqName.lastIndexOf('.');
+            int startOfClassIndex = endOfPackageIndex + 1;
+            returnName = fqName.substring(startOfClassIndex);
+        }
+        else {
+            // TODO: RAS and NLS
+            throw new UnsupportedOperationException("Java class is null");
+        }
+        return returnName;
+    }
+    
+    /**
      * Returns the package name from the class.  If no package, then returns null
      * @param theClass
      * @return
@@ -932,24 +975,38 @@
     
     public String getWebServiceName() {
         // TODO: Validation: Not allowed on WebServiceProvider
-        if (webService_Name == null) {
-            if (!isProviderBased()) {
-                if (getWebServiceAnnotation() != null 
-                        && !DescriptionUtils.isEmpty(getWebServiceAnnotation().name())) {
-                    webService_Name = getWebServiceAnnotation().name();
-                }
-                else {
-                    // Default per JSR-181 Sec 4.1, pg 15
-                    webService_Name = getSimpleJavaClassName(implOrSEIClass);
-                }
-            }
-            else {
-                // This element is not valid on a WebServiceProvider annotation
-                // REVIEW: Is this a correct thing to return if this is called against a WebServiceProvier
-                //         which does not support this element?
-                webService_Name = "";
-            }
-        }
+    	
+    	//TODO: Per JSR109 v1.2 Sec. 5.3.2.1
+    	//      If not specified then we can use the default value as specified in JSR 181 
+    	//		(but only if it is unique within the module)...or If the name is 
+    	//		not specified in the Service Implementation Bean then fully 
+    	//		qualified name of the Bean class is used to guarantee uniqueness
+    	//		If the above is not unique then fully qualified name of the
+    	//		Bean class is used to guarantee uniqueness
+    	
+    	if (webService_Name == null) {
+    		if (!isProviderBased()) {
+    			if (getWebServiceAnnotation() != null 
+    					&& !DescriptionUtils.isEmpty(getWebServiceAnnotation().name())) {
+    				webService_Name = getWebServiceAnnotation().name();
+     			}
+    			else {
+    				if (getServiceDescription().isDBCMap()) {
+    					//The name is the simple name of the class or interface
+    					webService_Name = getSimpleJavaClassName(composite.getClassName());
+    				} else {
+    					// Default per JSR-181 Sec 4.1, pg 15
+    					webService_Name = getSimpleJavaClassName(implOrSEIClass);
+    				}
+    			}                	
+    		}
+    		else {
+    			// This element is not valid on a WebServiceProvider annotation
+    			// REVIEW: Is this a correct thing to return if this is called against a WebServiceProvier
+    			//         which does not support this element?
+    			webService_Name = "";
+    		}
+    	}
         return webService_Name;
     }
     
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/OperationDescription.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/OperationDescription.java	(revision 468124)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/OperationDescription.java	(working copy)
@@ -22,6 +22,8 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
 
 import javax.jws.Oneway;
 import javax.jws.WebMethod;
@@ -34,7 +36,30 @@
 import javax.xml.ws.ResponseWrapper;
 import javax.xml.ws.WebFault;
 
+import org.apache.axis2.AxisFault;
 import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.AxisOperationFactory;
+import org.apache.axis2.description.InOnlyAxisOperation;
+import org.apache.axis2.description.InOutAxisOperation;
+import org.apache.axis2.description.OutInAxisOperation;
+import org.apache.axis2.description.OutOnlyAxisOperation;
+import org.apache.axis2.engine.MessageReceiver;
+import org.apache.axis2.i18n.Messages;
+import org.apache.axis2.jaxws.description.builder.HandlerChainAnnot;
+import org.apache.axis2.jaxws.description.builder.MethodDescriptionComposite;
+import org.apache.axis2.jaxws.description.builder.OneWayAnnot;
+import org.apache.axis2.jaxws.description.builder.ParameterDescriptionComposite;
+import org.apache.axis2.jaxws.description.builder.RequestWrapperAnnot;
+import org.apache.axis2.jaxws.description.builder.ResponseWrapperAnnot;
+import org.apache.axis2.jaxws.description.builder.SoapBindingAnnot;
+import org.apache.axis2.jaxws.description.builder.WebEndpointAnnot;
+import org.apache.axis2.jaxws.description.builder.WebMethodAnnot;
+import org.apache.axis2.jaxws.description.builder.WebResultAnnot;
+import org.apache.axis2.jaxws.description.builder.WebServiceContextAnnot;
+import org.apache.axis2.jaxws.description.builder.WebServiceRefAnnot;
+import org.apache.axis2.wsdl.WSDLConstants;
+import org.apache.axis2.wsdl.WSDLConstants.WSDL20_2004Constants;
+import org.apache.axis2.wsdl.WSDLConstants.WSDL20_2006Constants;
 
 /**
  * An OperationDescripton corresponds to a method on an SEI.  That SEI could be explicit
@@ -85,6 +110,7 @@
     private AxisOperation axisOperation;
     private QName operationName;
     private Method seiMethod;
+    private MethodDescriptionComposite methodComposite;
     private ParameterDescription[] parameterDescriptions;
 
     // ===========================================
@@ -165,12 +191,88 @@
         
         this.operationName = new QName(getWebMethodOperationName());
     }
+    
     OperationDescription(AxisOperation operation, EndpointInterfaceDescription parent) {
         parentEndpointInterfaceDescription = parent;
         axisOperation = operation;
         this.operationName = axisOperation.getName();
     }
 
+    OperationDescription(MethodDescriptionComposite mdc, EndpointInterfaceDescription parent) {
+
+    	parentEndpointInterfaceDescription = parent;
+		methodComposite = mdc;
+		webMethodAnnotation = methodComposite.getWebMethodAnnot();
+
+		AxisOperation axisOperation = null;
+		
+		try {
+			if (isOneWay()) {				
+				axisOperation = AxisOperationFactory.getOperationDescription(WSDLConstants.WSDL20_2004Constants.MEP_URI_IN_ONLY);
+			} else {
+				axisOperation = AxisOperationFactory.getOperationDescription(WSDLConstants.WSDL20_2004Constants.MEP_URI_IN_OUT);
+			}
+			//TODO: There are several other MEP's, such as: OUT_ONLY, IN_OPTIONAL_OUT, OUT_IN, OUT_OPTIONAL_IN, ROBUST_OUT_ONLY,
+			//												ROBUST_IN_ONLY
+			//      Determine how these MEP's should be handled, if at all
+					
+		} catch (Exception e) {
+			AxisFault ex = new AxisFault("OperationDescription:cons - unable to build AxisOperation ");
+		}
+		    
+		if (axisOperation != null){
+			
+			axisOperation.setName(determineOperationQName(this.methodComposite));
+			axisOperation.setSoapAction(this.getWebMethodAction());
+
+		
+			//TODO: Determine other axisOperation values that may need to be set
+			//      Currently, the following values are being set on AxisOperation in 
+			//      ServiceBuilder.populateService which we are not setting:
+			//			AxisOperation.setPolicyInclude()
+			//			AxisOperation.setWsamappingList()
+			//			AxisOperation.setOutputAction()
+			//			AxisOperation.addFaultAction()
+			//			AxisOperation.setFaultMessages()
+			
+			// TODO: The WSMToAxisServiceBuilder sets the message receiver, not sure why this is done
+			//       since AxisService.addOperation does this as well by setting it to a default
+			//       MessageReceiver...it appears that this code is also setting it to a default
+			//       receiver..need to understand this
+
+			/*
+			String messageReceiverClass = "org.apache.axis2.rpc.receivers.RPCMessageReceiver";
+			if(wsmOperation.isOneWay()){
+				messageReceiverClass = "org.apache.axis2.rpc.receivers.RPCInOnlyMessageReceiver";
+			}
+			try{
+				MessageReceiver msgReceiver = (MessageReceiver)Class.forName(messageReceiverClass).newInstance();
+				axisOperation.setMessageReceiver(msgReceiver);
+
+			}catch(Exception e){
+			}
+			*/
+
+			parameterDescriptions = createParameterDescriptions();
+			
+			//TODO: Need to process the other annotations that can exist, on the server side
+			//      and at the method level.
+			//      They are, as follows: 		
+			//			WebResultAnnot (181)
+			//			HandlerChain
+			//			SoapBinding (181)
+			//			WebServiceRefAnnot (List) (JAXWS)
+			//			WebServiceContextAnnot (JAXWS via injection)
+			//			RequestWrapper (JAXWS)
+			//			ResponseWrapper (JAXWS)
+			
+//System.out.println("OperationDescription: Finished setting operation");
+			
+		}
+		
+		this.axisOperation = axisOperation;
+    }
+    
     public void setSEIMethod(Method method) {
         if (seiMethod != null) {
             // TODO: This is probably an error, but error processing logic is incorrect
@@ -197,20 +299,41 @@
     
     // Java-related getters
     public String getJavaMethodName() {
-        String returnString = null;
-        if (seiMethod != null) {
-            returnString = seiMethod.getName();
-        }
+    	String returnString = null;
+    	
+    	if (!isDBC()) {
+    		if (seiMethod != null) {
+                returnString = seiMethod.getName();
+    		}
+    	} else {
+    		if (methodComposite != null) {
+    			returnString = methodComposite.getMethodName();
+    		}
+    	}
+        
         return returnString;
     }
+    
     public String[] getJavaParameters() {
+    	
         ArrayList<String> returnParameters = new ArrayList<String>();
-        if (seiMethod != null) {
-            Class[] paramaters = seiMethod.getParameterTypes();
-            for (Class param:paramaters) {
-                returnParameters.add(param.getName());
+        
+        if (!isDBC()) {
+            if (seiMethod != null) {
+                Class[] paramaters = seiMethod.getParameterTypes();
+                for (Class param:paramaters) {
+                    returnParameters.add(param.getName());
+                }
             }
+	
+        } 
+        /*
+        else {
+        	if (methodComposite != null) {
+        		Class[] parameters = methodComposite.getP
+        	}
         }
+        */
         // TODO: This is different than the rest, which return null instead of an empty array
         return returnParameters.toArray(new String[0]);
     }
@@ -223,21 +346,45 @@
         return seiMethod;
     }
     
+    public MethodDescriptionComposite getMethodDescriptionComposite() {
+    	return methodComposite;
+    }
+    
     private boolean isWrappedParameters() {
         // TODO: WSDL may need to be considered in this check as well
         return getSoapBindingParameterStyle() == javax.jws.soap.SOAPBinding.ParameterStyle.WRAPPED;
     }
     
     private ParameterDescription[] createParameterDescriptions() {
-       Class[] parameters = seiMethod.getParameterTypes();
-       Type[] paramaterTypes = seiMethod.getGenericParameterTypes();
-       Annotation[][] annotations = seiMethod.getParameterAnnotations();
-       ArrayList<ParameterDescription> buildParameterList = new ArrayList<ParameterDescription>();
-       for(int i = 0; i < parameters.length; i++) {
-           ParameterDescription paramDesc = new ParameterDescription(i, parameters[i], paramaterTypes[i], annotations[i], this);
-           buildParameterList.add(paramDesc);
-       }
-       return buildParameterList.toArray(new ParameterDescription[buildParameterList.size()]);
+    	
+    	ArrayList<ParameterDescription> buildParameterList = new ArrayList<ParameterDescription>();
+	
+    	if (!isDBC()) {
+        	Class[] parameters = seiMethod.getParameterTypes();
+        	Type[] paramaterTypes = seiMethod.getGenericParameterTypes();
+        	Annotation[][] annotations = seiMethod.getParameterAnnotations();
+        	
+        	for(int i = 0; i < parameters.length; i++) {
+        		ParameterDescription paramDesc = new ParameterDescription(i, parameters[i], paramaterTypes[i], annotations[i], this);
+        		buildParameterList.add(paramDesc);
+        	}
+ 	
+    	} else {
+          	ParameterDescriptionComposite pdc = null;
+        	Iterator<ParameterDescriptionComposite> iter = 
+        						methodComposite.getParameterDescriptionCompositeList().iterator();
+        	
+        	for (int i = 0; i < methodComposite.getParameterDescriptionCompositeList().size(); i++) {
+           		ParameterDescription paramDesc = 
+           						new ParameterDescription (	i, 
+           													methodComposite.getParameterDescriptionComposite(i), 
+           													this);
+        		buildParameterList.add(paramDesc);
+    		}
+    	}
+    	
+       	return buildParameterList.toArray(new ParameterDescription[buildParameterList.size()]);
+  	
     }
 
     // =====================================
@@ -251,25 +398,53 @@
         return new QName(determineOperationName(javaMethod));
     }
     
+    //TODO: For now, we are overriding the above method only because it is static, these should
+    //be combined at some point
+    static QName determineOperationQName(MethodDescriptionComposite mdc) {
+    	return new QName(determineOperationName(mdc));
+    }
+    
+    //TODO: Deprecate this after we use only DBC objects
     private static String determineOperationName(Method javaMethod) {
+    	
+    	String operationName = null;
+    	
+    	WebMethod wmAnnotation = javaMethod.getAnnotation(WebMethod.class);
+    	// Per JSR-181 MR Sec 4.2 "Annotation: javax.jws.WebMethod" pg 17,
+    	// if @WebMethod specifies and operation name, use that.  Otherwise
+    	// default is the Java method name
+    	if (wmAnnotation != null && !DescriptionUtils.isEmpty(wmAnnotation.operationName())) {
+    		operationName = wmAnnotation.operationName();
+    	}
+    	else {
+    		operationName = javaMethod.getName();
+    	}
+    	
+    	return operationName;    
+    }
+
+    //TODO: For now, we are overriding the above method only because it is static, these should
+    //be combined at some point
+    private static String determineOperationName(MethodDescriptionComposite mdc) {
         String operationName = null;
-        WebMethod wmAnnotation = javaMethod.getAnnotation(WebMethod.class);
-        // Per JSR-181 MR Sec 4.2 "Annotation: javax.jws.WebMethod" pg 17,
-        // if @WebMethod specifies and operation name, use that.  Otherwise
-        // default is the Java method name
-        if (wmAnnotation != null && !DescriptionUtils.isEmpty(wmAnnotation.operationName())) {
-            operationName = wmAnnotation.operationName();
-        }
-        else {
-            operationName = javaMethod.getName();
-        }
-        return operationName;
         
+        WebMethod wmAnnotation = mdc.getWebMethodAnnot();
+   		if (wmAnnotation != null && !DescriptionUtils.isEmpty(wmAnnotation.operationName())) {
+			operationName = wmAnnotation.operationName();
+		}
+		else {
+			operationName = mdc.getMethodName();
+		}
+
+    	return operationName;
     }
     
     public String getWebMethodOperationName() {
         if (webMethodOperationName == null) {
-            webMethodOperationName = determineOperationName(seiMethod);
+        	if (!isDBC())
+        		webMethodOperationName = determineOperationName(seiMethod);
+        	else
+                webMethodOperationName = determineOperationName(this.methodComposite); 		
         }
         return webMethodOperationName;
     }
@@ -792,9 +967,18 @@
     // ANNOTATION: OneWay
     // ===========================================
     Oneway getOnewayAnnotation() {
-        if (onewayAnnotation == null) {
-            onewayAnnotation = seiMethod.getAnnotation(Oneway.class);
-        }
+    	//TODO: Shouldn't really do it this way...if there is not Oneway annotation, 
+    	//      we will always be calling the methods to try to retrieve it, since
+    	//      it will always be null, should consider relying on 'isOneWay'
+    	
+    	if (onewayAnnotation == null) {    		
+    		if (isDBC()) {
+    			if (methodComposite.isOneWay()) {
+    				onewayAnnotation = OneWayAnnot.createOneWayAnnotImpl();
+    			}
+    		} else
+    			onewayAnnotation = seiMethod.getAnnotation(Oneway.class);
+    	}
         return onewayAnnotation;
     }
 
@@ -811,4 +995,11 @@
         }
         return onewayIsOneway.booleanValue();   
     }
-}
+    
+    private boolean isDBC() {
+    	if (methodComposite != null)
+    		return true;
+    	else
+    		return false;
+    }
+}
\ No newline at end of file
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ParameterDescription.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ParameterDescription.java	(revision 468124)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ParameterDescription.java	(working copy)
@@ -27,6 +27,7 @@
 import javax.jws.WebParam;
 import javax.jws.soap.SOAPBinding;
 
+import org.apache.axis2.jaxws.description.builder.ParameterDescriptionComposite;
 import org.apache.axis2.jaxws.description.builder.WebParamAnnot;
 
 /**
@@ -79,6 +80,7 @@
         this.parameterNumber = parameterNumber;
         this.parentOperationDescription = parent;
         this.parameterType = parameterType;
+        
         // The Type argument could be a Type (if the parameter is a Paramaterized Generic) or
         // just a Class (if it is not).  We only need to keep track of Paramaterized Type information. 
         if (ParameterizedType.class.isInstance(parameterGenericType)) {   
@@ -87,6 +89,31 @@
         findWebParamAnnotation(parameterAnnotations);
     }
     
+    ParameterDescription(int parameterNumber, ParameterDescriptionComposite pdc, OperationDescription parent) {
+    	this.parameterNumber = parameterNumber;
+    	this.parentOperationDescription = parent;
+    	this.parameterType = pdc.getParameterTypeClass();
+    	
+    	
+        if (ParameterizedType.class.isInstance(pdc.getParameterGenericType())) {   
+            this.parameterGenericType = (ParameterizedType) pdc.getParameterGenericType();
+        }
+
+    	webParamAnnotation = pdc.getWebParamAnnot();
+    	
+    	//TODO: Need to build the schema map. Need to add logic to add this parameter
+    	//	    to the schema map.
+    	
+    	//TODO: Need to consider processing the following JAXWS annotations on this DBC
+    	// webServiceRef is probably only client, so shouldn't be here
+    	//webServiceContextAnnotation = pdc.getWebServiceContextAnnot();
+    	//webServiceRefAnnotation = pdc.getWebServiceRefAnnot();
+    }
+    
+    /*
+     * This grabs the WebParam annotation from the list of annotations for this parameter
+     * This should be DEPRECATED once DBC processing is complete.
+     */
     private void findWebParamAnnotation(Annotation[] annotations) {
         for (Annotation checkAnnotation:annotations) {
             // REVIEW: This may not work with the MDQInput.  From the java.lang.annotation.Annotation interface
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ServiceDescription.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ServiceDescription.java	(revision 468124)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ServiceDescription.java	(working copy)
@@ -22,16 +22,30 @@
 import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.Iterator;
+import java.util.Map;
+import java.util.List;
 
 import javax.xml.namespace.QName;
+import javax.xml.ws.WebServiceException;
+import javax.jws.WebService;
 import javax.wsdl.Definition;
 import javax.wsdl.Port;
 import javax.wsdl.Service;
 import javax.wsdl.WSDLException;
+import javax.xml.namespace.QName;
 
+import org.apache.axis2.AxisFault;
 import org.apache.axis2.client.ServiceClient;
 import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.deployment.DeploymentException;
 import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.OutInAxisOperation;
+import org.apache.axis2.description.OutOnlyAxisOperation;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.description.RobustOutOnlyAxisOperation;
+import org.apache.axis2.description.WSDL11ToAllAxisServicesBuilder;
+import org.apache.axis2.description.WSDL11ToAxisServiceBuilder;
+import org.apache.axis2.engine.AbstractDispatcher;
 import org.apache.axis2.jaxws.ClientConfigurationFactory;
 import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.description.builder.DescriptionBuilderComposite;
@@ -160,7 +174,6 @@
     ServiceDescription(	
     		HashMap<String, DescriptionBuilderComposite> dbcMap,
     		DescriptionBuilderComposite composite ) {
-    	
     	this.composite = composite;
     	
     	String serviceImplName = this.composite.getClassName();
@@ -191,8 +204,6 @@
     	}
 		this.serviceQName = new QName(targetNamespace, serviceName);
 
-        
-    	
         // Create the EndpointDescription hierachy from the service impl annotations; Since the PortQName is null, 
         // it will be set to the annotation value.
         //EndpointDescription endpointDescription = new EndpointDescription(null, this, serviceImplName);
@@ -445,6 +456,7 @@
     public WSDLWrapper getWSDLWrapper() {
         return wsdlWrapper;
     }
+    
     public URL getWSDLLocation() {
         return wsdlURL;
     }
@@ -471,6 +483,8 @@
     }
     
     public QName getServiceQName() {
+    	//It is assumed that this will always be set in the constructor rather than 
+    	//built up from the class or DBC 
         return serviceQName;
     }
 
@@ -483,12 +497,6 @@
     	return dbcMap;
     }
     
-	private AxisService processImplBean(){
-		//Process
-		AxisService axisService = null;
-		return axisService;
-	}
-	
 	private void validateDBCLIntegrity(){
 		
 		//First, check the integrity of this input composite
@@ -511,132 +519,221 @@
 		}
 	}
 
+	/*
+	 * Validates the integrity of an impl. class. This should not be called directly for an SEI composite
+	 */
 	public void validateIntegrity() {
-	//TODO: Consider moving this to a utils area, do we really want a public
-	//      method that checks integrity...possibly
-	
-	//TODO: This method will validate the integrity of this object. Basically, if 
-	//consumer set this up improperly, then we should fail fast, should consider placing
-	//this method in a utils class within the 'description' package
-	
-	if (composite.getWebServiceAnnot() != null && composite.getWebServiceProviderAnnot() != null) {
-		throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: WebService annotation and WebServiceProvider annotation cannot coexist");
-	}
-	
-//	Make sure that we're only validating against WSDL, if there is WSDL...duh
-	if (composite.getWebServiceProviderAnnot() != null ) {
-		//	TODO EDIT CHECK: valid only if is a provider class, what are these?
+		//TODO: Consider moving this to a utils area, do we really want a public
+		//      method that checks integrity...possibly
 		
-	} else if (composite.getWebServiceAnnot() != null) {
-		if (!composite.isInterface()) {
-			// TODO: Validate on the class that this.classModifiers Array does not contain the strings
-			//        FINAL or ABSTRACT, but does contain PUBLIC
-			// TODO: Validate on the class that a public constructor exists
-			// TODO: Validate on the class that a finalize() method does not exist
-			if (!composite.getWebServiceAnnot().wsdlLocation().equals("")) {
-				if (composite.getWsdlDefinition() == null || composite.getWsdlURL() ==  null) {
-					throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: cannot find WSDL Definition pertaining to this WebService annotation");
-				}
+		//In General, this integrity checker should do gross level checking
+		//It should not be setting spec-defined default values, but can look
+		//at things like empty strings or null values
+		
+		//TODO: This method will validate the integrity of this object. Basically, if 
+		//consumer set this up improperly, then we should fail fast, should consider placing
+		//this method in a utils class within the 'description' package
+		
+		
+		//Verify that WebService and WebServiceProvider are not both specified
+		//per JAXWS - Sec. 7.7
+		if (composite.getWebServiceAnnot() != null && composite.getWebServiceProviderAnnot() != null) {
+			throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: WebService annotation and WebServiceProvider annotation cannot coexist");
+		}
+		
+//		Make sure that we're only validating against WSDL, if there is WSDL...duh
+		if (composite.getWebServiceProviderAnnot() != null ) {
+			// TODO: Verify that this Provider based WebService has a method named invoke
+			
+		} else if (composite.getWebServiceAnnot() != null) {
+			
+			if ( composite.getServiceModeAnnot() != null) {
+				throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: ServiceMode annotation can only be specified for WebServiceProvider");
 			}
 			
-			//		setWebServiceAnnotDefaults(true=impl); Must happen before we start checking annot
-			if (composite.getWebServiceAnnot().endpointInterface() != null) {
-
-			//			Perform more validation with SEI
-				
-				DescriptionBuilderComposite seic = 
-					dbcMap.get(composite.getWebServiceAnnot().endpointInterface());
-
-				//Verify that we can find the SEI in the composite list
-				if (seic == null){
-					throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: cannot find SEI composite specified by the endpoint interface");
+			//TODO: hmmm, will we ever actually validate an interface directly...don't think so
+			if (!composite.isInterface()) {
+				// TODO: Validate on the class that this.classModifiers Array does not contain the strings
+				//        FINAL or ABSTRACT, but does contain PUBLIC
+				// TODO: Validate on the class that a public constructor exists
+				// TODO: Validate on the class that a finalize() method does not exist
+				if (!DescriptionUtils.isEmpty(composite.getWebServiceAnnot().wsdlLocation())) {
+					if (composite.getWsdlDefinition() == null || composite.getWsdlURL() == null) {
+						throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: cannot find WSDL Definition pertaining to this WebService annotation");
+					}
 				}
-			
-				//Verify that the only annotations are WebService and HandlerChain
-				//(per JSR181 Sec. 3.1)
-				if ( composite.getBindingTypeAnnot()!= null 
-					 || composite.getServiceModeAnnot() != null
-					 || composite.getSoapBindingAnnot() != null
-					 || composite.getWebFaultAnnot() != null
-					 || composite.getWebServiceClientAnnot() != null
-					 || composite.getWebServiceContextAnnot()!= null
-					 || composite.getAllWebServiceRefAnnots() != null
-					 ) {
-					throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: invalid annotations specified when WebService annotation specifies an endpoint interface");
-				}
 				
-				//Verify that WebService annotation does not contain a name attribute
-				//(per JSR181 Sec. 3.1)
-				if (composite.getWebServiceAnnot().name() != null) {
-					throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: invalid annotations specified when WebService annotation specifies an endpoint interface");
+				//		setWebServiceAnnotDefaults(true=impl); Must happen before we start checking annot
+				if (!DescriptionUtils.isEmpty(composite.getWebServiceAnnot().endpointInterface())) {
+					
+					DescriptionBuilderComposite seic = 
+						dbcMap.get(composite.getWebServiceAnnot().endpointInterface());
+					
+					//Verify that we can find the SEI in the composite list
+					if (seic == null){
+						throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: cannot find SEI composite specified by the endpoint interface");
+					}
+					
+					//Verify that the only class annotations are WebService and HandlerChain
+					//(per JSR181 Sec. 3.1)
+					if ( composite.getBindingTypeAnnot()!= null 
+							|| composite.getSoapBindingAnnot() != null
+							|| composite.getWebFaultAnnot() != null
+							|| composite.getWebServiceClientAnnot() != null
+							|| composite.getWebServiceContextAnnot()!= null
+							|| composite.getAllWebServiceRefAnnots() != null
+					) {
+						throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: invalid annotations specified when WebService annotation specifies an endpoint interface");
+					}
+					
+					//Verify that WebService annotation does not contain a name attribute
+					//(per JSR181 Sec. 3.1)
+					if (composite.getWebServiceAnnot().name() != null) {
+						throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: invalid annotations specified when WebService annotation specifies an endpoint interface");
+					}
+					
+					//Verify that that this implementation class implements all methods in the interface
+					validateImplementation(seic);
+					
+					//Verify that this impl. class does not contain any @WebMethod annotations
+					if (webMethodAnnotationsExist()) {
+						throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: WebMethod annotations cannot exist on class when WebService.endpointInterface is set");	
+					}
+					
+					//TODO: validateSEI() ...this should really be done here. No sense in validating
+					//		an interface just because its in the list
+					validateSEI(seic);
+					
+				} else { //this is an implicit SEI (i.e. impl w/out endpointInterface
+					
+					checkImplicitSEIAgainstWSDL();
+					//	TODO:	Call ValidateWebMethodAnnots()
+					//			- this method will check that all methods are public - ???
+					//
 				}
+			} else { //this is an interface...we should not be processing interfaces here
+				throw ExceptionFactory.makeWebServiceException("ValidateIntegrity: Improper usage: cannot invoke this method with an interface");	
+			}
+					
+			//TODO: don't think this is necessary
+			checkMethodsAgainstWSDL();
+		}
+	}
+	
+	private void validateImplementation(DescriptionBuilderComposite seic) {
+		/*
+		 *	Verify that an impl class implements all the methods of the SEI. We
+		 *  have to verify this because an impl class is not required to actually use
+		 *  the 'implements' clause. So, if it doesn't, the Java compiler won't 
+		 *	catch it. Don't need to worry about chaining because only one EndpointInterface
+		 *  can be specified, and the SEI cannot specify an EndpointInterface, so the Java
+		 *	compiler will take care of everything else.
+		 */
+		
+		HashMap compositeHashMap = new HashMap();
+		Iterator<MethodDescriptionComposite> compIterator = 
+					composite.getMethodDescriptionsList().iterator();
 
-				//Verify that that this implementation class implements all methods in the interface
-				validateImplementation(seic);
-				
-			} else {
-				//TODO: Fill out the validation below
-				//'endpoint interface' is null so validate against this class only
-				//			Validate hmmm something
-				//			WSDL Check: ?
-				//		Call ValidateWebMethodAnnots()
-				//			- this method will check that all methods are public - ???
-				//
+		while (compIterator.hasNext()) {
+			MethodDescriptionComposite mdc = compIterator.next();
+			compositeHashMap.put(mdc.getMethodName(),mdc);
+		}
+		
+		Iterator<MethodDescriptionComposite> seiIterator = 
+					seic.getMethodDescriptionsList().iterator();
+		
+		while (seiIterator.hasNext()) {
+			MethodDescriptionComposite mdc = seiIterator.next();
+
+			if (compositeHashMap.get(mdc.getMethodName()) == null) {
+				throw ExceptionFactory.makeWebServiceException("ServiceDescription: subclass does not implement method on specified interface");				
 			}
-		} else { //this is an interface
-			//TODO:	Validate that the interface is public 
-			
-			if (!composite.getWebServiceAnnot().endpointInterface().equals("")) {
-				throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: WebService annotation contains a non-empty field for the SEI");
-			}
-			//		Validate (Spec. JAXWS 2.0 Sec.3.4) all WebMethod annots have exclude to 'false' or null 
-			//		Call ValidateWebMethodAnnots()
-			//	
 		}
 		
-		CheckMethodsAgainstWSDL();
-		
 	}
-	//We made it through this round of validation, now set appropriate defaults
-	//within each annotation, Realize that we'll have to do this for the inherited classes
-	//as well.
 	
-	//!!!  TODO: Set Default field values for each annot, as well as, inherited classes
-	//TODO: We shouldn't try to set defaults for all annots...we need to be selective
-	//      based on what is being represented here (i.e. provider vs. impl. vs. SEI)
-	//      So, we may consider doing this at end of individual validation blocks above
-	//setWebServiceAnnotDefaults(true=impl);
-	//setWebMethodAnnotDefaults();
-	//setWebServiceProviderAnnotDefaults();
+	/*
+	 * This method verifies that, if there are any WebMethod with exclude == false, then
+	 * make sure that we find all of those methods represented in the wsdl. However, if 
+	 * there are no exclusions == false, or there are no WebMethod annotations, then verify
+	 * that all the public methods are in the wsdl
+	 */
+	private void checkMethodsAgainstWSDL() {	
+//Verify that, for ImplicitSEI, that all methods that should exist(if one false found, then
+//only look for WebMethods w/ False, else take all public methods but ignore those with
+//exclude == true
+		if (webMethodAnnotationsExist()) {
+			if (DescriptionUtils.falseExclusionsExist(composite))
+				verifyFalseExclusionsWithWSDL();
+			else
+				verifyPublicMethodsWithWSDL();
+		} else {
+			verifyPublicMethodsWithWSDL();
+		}
+	}
 	
-	// For each annot that is set within this composite
-	// If it is set, then check that its default values are appropriate, based
-	// on the spec.
+	private void checkImplicitSEIAgainstWSDL() {
+		
+		//TODO: If there is a WSDL, then verify that all WebMethods on this class and in the
+		//		superclasses chain are represented in the WSDL...Look at logic below to make
+		//		sure this really happening
+		
+		
+		if (webMethodAnnotationsExist()) {
+			if (DescriptionUtils.falseExclusionsExist(composite))
+				verifyFalseExclusionsWithWSDL();
+			else
+				verifyPublicMethodsWithWSDL();
+		} else {
+			verifyPublicMethodsWithWSDL();
+		}
+		
 	}
 	
-	private void validateImplementation(DescriptionBuilderComposite seic) {
-		//TODO: Currently, this may be unnecessary per JSR181, sec. 4.1.1, definition
-		//      of endpointInterface attribute
+	private void checkSEIAgainstWSDL() {
+		//TODO: Place logic here to verify that each publicMethod with WebMethod annot
+		//      is contained in the WSDL (If there is a WSDL) If we find
+		//	    a WebMethod annotation, use its values for looking in the WSDL
+
 	}
 	
-	private void CheckMethodsAgainstWSDL() {		
+	private void validateSEI(DescriptionBuilderComposite seic) {
+		
+		//TODO: Validate SEI superclasses -- hmmm, may be doing this below
+		//		
+		
+		if (!seic.getWebServiceAnnot().endpointInterface().equals("")) {
+			throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: WebService annotation contains a non-empty field for the SEI");
+		}
 
-		if (WebMethodAnnotationsExist()) {
-			if (WebMethodAnnotationsWithFalseExclusions())
-				VerifyFalseExclusionsWithWSDL();
-			else
-				VerifyPublicMethodsWithWSDL();
-		} else {
-			VerifyPublicMethodsWithWSDL();
+		checkSEIAgainstWSDL();
+		
+		//TODO: More validation here
+		
+		//TODO: Make sure we don't find any WebMethod annotations with exclude == true 
+		//		anywhere in the superclasses chain
+		
+		//TODO: Check that all WebMethod annotations in the superclass chain are represented in 
+		//		WSDL, assuming there is WSDL
+		
+		
+		//TODO:	Validate that the interface is public 
+		
+		if (!composite.getWebServiceAnnot().endpointInterface().equals("")) {
+			throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: WebService annotation contains a non-empty field for the SEI");
 		}
+		//		Call ValidateWebMethodAnnots()
+		//
+		
+		//This will perform validation for all methods, regardless of WebMethod annotations
+		//It is called for the SEI, and an impl. class that does not specify an endpointInterface
+		validateMethods();
 	}
 	
 	/**
 	 * @return Returns TRUE if we find just one WebMethod Annotation 
 	 */
-	private boolean WebMethodAnnotationsExist() {
-		
-		
+	private boolean webMethodAnnotationsExist() {
 		MethodDescriptionComposite mdc = null;
 		Iterator<MethodDescriptionComposite> iter = composite.getMethodDescriptionsList().iterator();
 		
@@ -650,12 +747,12 @@
 		return false;
 	}
 	
-	private void VerifyFalseExclusionsWithWSDL() {
+	private void verifyFalseExclusionsWithWSDL() {
 		//TODO: Place logic here to verify that each exclude==false WebMethod annot we find
 		//      is contained in the WSDL
 	}
 	
-	private void VerifyPublicMethodsWithWSDL() {
+	private void verifyPublicMethodsWithWSDL() {
 		//TODO: Place logic here to verify that each publicMethod with no WebMethod annot
 		//      is contained in the WSDL
 
@@ -663,24 +760,26 @@
 
 	
 	/**
-	 * @return Returns TRUE if we find just one WebMethod Annotation with exclude flag
-	 * set to false
 	 */
-	private boolean WebMethodAnnotationsWithFalseExclusions() {
+	private void validateMethods() {
+		//TODO: Fill this out to validate all MethodDescriptionComposite (and their inclusive
+		//      annotations on this SEI (SEI is assumed here)
+		//check oneway
+		//
 		
-		MethodDescriptionComposite mdc = null;
-		Iterator<MethodDescriptionComposite> iter = composite.getMethodDescriptionsList().iterator();
+		//This could be an SEI, or an impl. class that doesn' specify an EndpointInterface (so, it
+		//is implicitly an SEI...need to consider this
+		//
 		
-		while (iter.hasNext()) {
-			mdc = iter.next();
-
-			WebMethodAnnot wma = mdc.getWebMethodAnnot();
-			if (wma != null) {
-				if (wma.exclude() == false)
-					return true;
-			}
-		}
-		
-		return false;
+		//TODO: Verify that, if this is an interface...that there are no Methods with WebMethod
+		//      annotations that contain exclude == true
+	
+		//TODO: Verify that, if a SOAPBinding annotation exists, that its style be set to
+		//      only DOCUMENT JSR181-Sec 4.7.1
+	
 	}
+	
+	private void validateWSDLOperations() {
+		//Verifies that all operations on the wsdl are found in the impl/sei class
+	}
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/DescriptionUtils.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/DescriptionUtils.java	(revision 468124)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/DescriptionUtils.java	(working copy)
@@ -18,8 +18,16 @@
 
 package org.apache.axis2.jaxws.description;
 
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
 import javax.xml.namespace.QName;
 
+import org.apache.axis2.jaxws.description.builder.DescriptionBuilderComposite;
+import org.apache.axis2.jaxws.description.builder.MethodDescriptionComposite;
+import org.apache.axis2.jaxws.description.builder.WebMethodAnnot;
+
 /**
  * Utilities used throughout the Description package.
  */
@@ -47,5 +55,73 @@
         }
         return className;
     }
+    
+	/**
+	 * @return Returns TRUE if we find just one WebMethod Annotation with exclude flag
+	 * set to false
+	 */
+	public static boolean falseExclusionsExist(DescriptionBuilderComposite dbc) {
+		
+		MethodDescriptionComposite mdc = null;
+		Iterator<MethodDescriptionComposite> iter = dbc.getMethodDescriptionsList().iterator();
+		
+		while (iter.hasNext()) {
+			mdc = iter.next();
 
+			WebMethodAnnot wma = mdc.getWebMethodAnnot();
+			if (wma != null) {
+				if (wma.exclude() == false)
+					return true;
+			}
+		}
+		
+		return false;
+	}
+	
+	/**
+	 * Gathers all MethodDescriptionCompsite's that contain a WebMethod Annotation with the
+	 * exclude set to FALSE
+	 * @return Returns List<MethodDescriptionComposite> 
+	 */
+	public static ArrayList<MethodDescriptionComposite> getMethodsWithFalseExclusions(DescriptionBuilderComposite dbc) {
+		
+		ArrayList<MethodDescriptionComposite> mdcList = new ArrayList<MethodDescriptionComposite>();
+		Iterator<MethodDescriptionComposite> iter = dbc.getMethodDescriptionsList().iterator(); 
+		
+		if (DescriptionUtils.falseExclusionsExist(dbc)) {
+			while (iter.hasNext()) {
+				MethodDescriptionComposite mdc = iter.next();
+				if (mdc.getWebMethodAnnot() != null) {
+					if (mdc.getWebMethodAnnot().exclude() == false) {
+						mdcList.add(mdc);
+					}
+				}
+			}
+		}
+		
+		return mdcList;
+	}
+	
+	/*
+	 * Check whether a MethodDescriptionComposite contains a WebMethod annotation with 
+	 * exlude set to true
+	 */
+	public static boolean isExcludeTrue(MethodDescriptionComposite mdc) {
+	
+		if (mdc.getWebMethodAnnot() != null) {
+			if (mdc.getWebMethodAnnot().exclude() == true) {
+					return true;
+			}
+		}
+		
+		return false;
+	}
+	
+    public static String javifyClassName(String className) {
+    	if(className.indexOf("/") != -1) {
+    		return className.replaceAll("/", ".");
+    	}
+    	return className;
+    }
+
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointInterfaceDescription.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointInterfaceDescription.java	(revision 468124)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointInterfaceDescription.java	(working copy)
@@ -21,20 +21,20 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Hashtable;
 import java.util.Iterator;
 
 import javax.jws.soap.SOAPBinding;
-import javax.wsdl.Binding;
-import javax.wsdl.Port;
-import javax.wsdl.PortType;
 import javax.xml.namespace.QName;
 
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.description.builder.DescriptionBuilderComposite;
+import org.apache.axis2.jaxws.description.builder.MDQConstants;
+import org.apache.axis2.jaxws.description.builder.MethodDescriptionComposite;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.log4j.BasicConfigurator;
 
 /**
  * An EndpointInterfaceDescription corresponds to a particular SEI-based Service
@@ -100,6 +100,9 @@
     // specify an @WebService.endpointInterface.
     private Class seiClass;
     
+    //Logging setup
+    private static final Log log = LogFactory.getLog(EndpointInterfaceDescription.class);
+    
     // ===========================================
     // ANNOTATION related information
     // ===========================================
@@ -137,15 +140,84 @@
         parentEndpointDescription = parent;
     }
     
+    /**
+     * Build from AxisService
+     * @param parent
+     */
+    EndpointInterfaceDescription(EndpointDescription parent) {
+        parentEndpointDescription = parent;
+        
+        AxisService axisService = parentEndpointDescription.getAxisService();
+        if (axisService != null) {
+            ArrayList publishedOperations = axisService.getPublishedOperations();
+            Iterator operationsIterator = publishedOperations.iterator();
+            while (operationsIterator.hasNext()) {
+                AxisOperation axisOperation = (AxisOperation) operationsIterator.next();
+                addOperation(new OperationDescription(axisOperation, this));
+            }
+        }
+    }
+
+    /**
+     * Build an EndpointInterfaceDescription from a DescriptionBuilderComposite
+     * @param dbc
+     * @param isClass
+     * @param parent
+     */
 	EndpointInterfaceDescription(	DescriptionBuilderComposite dbc, 
 									boolean isClass,
 									EndpointDescription parent){
+		
+		parentEndpointDescription = parent;
+		BasicConfigurator.configure();
+		
 		//TODO: Determine if the isClass parameter is really necessary
 		
-		//Get all the 
+		// Per JSR-181 all methods on the SEI are mapped to operations regardless
+		// of whether they include an @WebMethod annotation.  That annotation may
+		// be present to customize the mapping, but is not required (p14)
+		
+		// TODO:  Testcases that do and do not include @WebMethod anno
+		
+		//We are processing the SEI composite
+		//For every MethodDescriptionComposite in this list, call OperationDescription 
+		//constructor for it, then add this operation
+		
+		//Retrieve the relevent method composites for this dbc (and those in the superclass chain)
+		Iterator<MethodDescriptionComposite> iter = retrieveReleventMethods(dbc);
+		
+		log.debug("EndpointInterfaceDescription: Finished retrieving methods");
+		MethodDescriptionComposite mdc = null;
+		
+		while (iter.hasNext()) {
+			mdc = iter.next();
+			
+			OperationDescription operation = new OperationDescription(mdc, this);
+	
+			//TODO: Do we need to worry about a null AxisOperation at this level?
+			
+			//Add this AxisOperation to the AxisService
+			getEndpointDescription().getAxisService().addOperation(operation.getAxisOperation());
+		
+			log.debug("EID: Just added operation= " +operation.getWebMethodOperationName());
+			addOperation(operation);
+		
+		}
+		
+		log.debug("EndpointInterfaceDescription: Finished Adding operations");
+		
+		//TODO: Need to process the other annotations that can exist, on the server side
+		//      and at the class level.
+		//      They are, as follows: 		
+		//			HandlerChain (181)
+		//			SoapBinding (181)
+		//			WebServiceRefAnnot (List) (JAXWS)
+		//			BindingTypeAnnot (JAXWS Sec. 7.8 -- Used to set either the AS.endpoint, or AS.SoapNSUri)
+		//			WebServiceContextAnnot (JAXWS via injection)
+		
+		BasicConfigurator.resetConfiguration();
 	}
 
-    
     private static Method[] getSEIMethods(Class sei) {
         // Per JSR-181 all methods on the SEI are mapped to operations regardless
         // of whether they include an @WebMethod annotation.  That annotation may
@@ -359,23 +431,6 @@
         return returnOperation;
     }
     
-    /**
-     * Build from AxisService
-     * @param parent
-     */
-    EndpointInterfaceDescription(EndpointDescription parent) {
-        parentEndpointDescription = parent;
-        
-        AxisService axisService = parentEndpointDescription.getAxisService();
-        if (axisService != null) {
-            ArrayList publishedOperations = axisService.getPublishedOperations();
-            Iterator operationsIterator = publishedOperations.iterator();
-            while (operationsIterator.hasNext()) {
-                AxisOperation axisOperation = (AxisOperation) operationsIterator.next();
-                addOperation(new OperationDescription(axisOperation, this));
-            }
-        }
-    }
     public Class getSEIClass() {
         return seiClass;
     }
@@ -427,4 +482,127 @@
         }
         return soapParameterStyle;
     }
+    
+    public Iterator<MethodDescriptionComposite> retrieveReleventMethods(DescriptionBuilderComposite dbc) {
+    	//Based on whether this is an implicit SEI, or an actual SEI, Gather up and build a 
+    	//list of MDC's. If this is an actual SEI, then starting with this DBC, build a list of all
+    	//MDC's that are public methods in the chain of extended classes.
+    	//If this is an implicit SEI, then starting with this DBC,
+    	//1. If a false exclude is found, then take only those that have false excludes
+    	//2. Assuming no false excludes, take all public methods that don't have exclude == true
+    	//3. For each super class, if 'WebService' present, take all MDC's according to rules 1&2
+    	//   But, if WebService not present, grab only MDC's that are annotated, hmmmm
+		
+    	if (log.isTraceEnabled()) {
+    		log.trace("retrieveReleventMethods: Enter");
+    	}
+    	
+		ArrayList<MethodDescriptionComposite> retrieveList = new ArrayList<MethodDescriptionComposite>();
+
+    	if (dbc.isInterface()) {
+    	
+    		retrieveList = retrieveSEIMethods(dbc);
+
+    		//Now gather methods off the chain of superclasses, if any
+    		DescriptionBuilderComposite tempDBC = dbc;    		
+			while (!DescriptionUtils.isEmpty(tempDBC.getSuperClassName())) {
+				DescriptionBuilderComposite superDBC = 
+									getEndpointDescription().getServiceDescription().getDBCMap().get(tempDBC.getSuperClassName());
+				retrieveList.addAll(retrieveSEIMethods(superDBC));
+				tempDBC = superDBC;
+			}
+    			
+    	} else {
+       		//this is an implied SEI...rules are more complicated
+    		
+			retrieveList = retrieveImplicitSEIMethods(dbc);
+					
+    		//Now, continue to build this list with relevent methods in the chain of
+			//superclasses. If the logic for processing superclasses is the same as for
+			//the original SEI, then we can combine this code with above code. But, its possible
+			//the logic is different for superclasses...keeping separate for now.
+			DescriptionBuilderComposite tempDBC = dbc;
+			
+			while (!DescriptionUtils.isEmpty(tempDBC.getSuperClassName())) {
+				
+				//verify that this superclass name is not
+				//		java.lang.object, if so, then we're done processing
+				if (DescriptionUtils.javifyClassName(tempDBC.getSuperClassName()).equals(MDQConstants.OBJECT_CLASS_NAME))
+					break;
+				
+				DescriptionBuilderComposite superDBC = 
+									getEndpointDescription().getServiceDescription().getDBCMap().get(tempDBC.getSuperClassName());
+					
+				if (log.isTraceEnabled())
+					log.trace("superclass name for this DBC is:" +tempDBC.getSuperClassName());
+
+				//Verify that we can find the SEI in the composite list
+				if (superDBC == null){
+					throw ExceptionFactory.makeWebServiceException("EndpointInterfaceDescription: cannot find super class that was specified for this class");
+				}
+				
+				if (superDBC.getWebServiceAnnot() != null) {
+					//Now, gather the list of Methods just like we do for the lowest subclass
+					retrieveList.addAll(retrieveImplicitSEIMethods(superDBC));
+				} else {
+					//This superclass does not contain a WebService annotation, add only the
+					//methods that are annotated with WebMethod
+					
+					Iterator<MethodDescriptionComposite> iterMethod = dbc.getMethodDescriptionsList().iterator();
+					
+					while (iterMethod.hasNext()) {
+						MethodDescriptionComposite mdc = iterMethod.next();
+						
+						if (!DescriptionUtils.isExcludeTrue(mdc)) {
+							retrieveList.add(mdc);
+						}
+					}					
+				}
+				tempDBC = superDBC;
+			} //Done with implied SEI's superclasses
+    			
+   		}//Done with implied SEI's
+    	
+    	return retrieveList.iterator();
+    }
+
+    private ArrayList<MethodDescriptionComposite> retrieveImplicitSEIMethods(DescriptionBuilderComposite dbc) {
+		
+    	ArrayList<MethodDescriptionComposite> retrieveList = new ArrayList<MethodDescriptionComposite>();
+
+		retrieveList = DescriptionUtils.getMethodsWithFalseExclusions(dbc);
+		
+		//If this list is empty, then there are no false exclusions, so gather
+		//all composites that don't have exclude == true
+		if (retrieveList == null) {
+			Iterator<MethodDescriptionComposite> iter = dbc.getMethodDescriptionsList().iterator();
+			
+			while (iter.hasNext()) {
+				MethodDescriptionComposite mdc = iter.next();
+				
+				if (!DescriptionUtils.isExcludeTrue(mdc)) {
+					retrieveList.add(mdc);
+				}
+			}
+		}
+
+		return retrieveList;
+    }
+
+    private ArrayList<MethodDescriptionComposite> retrieveSEIMethods(DescriptionBuilderComposite dbc) {
+		
+    	//Rules for retrieving Methods on an SEI (or a superclass of an SEI) are simple
+    	//Just retrieve all methods regardless of WebMethod annotations
+    	ArrayList<MethodDescriptionComposite> retrieveList = new ArrayList<MethodDescriptionComposite>();
+    	
+    	Iterator<MethodDescriptionComposite> iter = dbc.getMethodDescriptionsList().iterator();
+    	
+    	while (iter.hasNext()) {
+    		MethodDescriptionComposite mdc = iter.next();    		
+    		retrieveList.add(mdc);
+    	}
+    	
+    	return retrieveList;
+    }
+
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/OneWayAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/OneWayAnnot.java	(revision 0)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/OneWayAnnot.java	(revision 0)
@@ -0,0 +1,37 @@
+/* Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.jaxws.description.builder;
+
+import java.lang.annotation.Annotation;
+
+public class OneWayAnnot implements javax.jws.Oneway {
+
+		/**
+	     * A OneWayAnnot cannot be instantiated.
+	     */
+		private	OneWayAnnot()
+		{
+		}
+		
+	    public static OneWayAnnot createOneWayAnnotImpl() {
+	        return new OneWayAnnot();
+	    }
+
+	    public Class<Annotation> annotationType(){
+			return Annotation.class;
+		}
+}
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/MethodDescriptionComposite.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/MethodDescriptionComposite.java	(revision 468124)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/MethodDescriptionComposite.java	(working copy)
@@ -26,6 +26,8 @@
 	private ResponseWrapperAnnot 	responseWrapperAnnot;//TODO EDIT CHECK: only on methods of SEI
 	private List<ParameterDescriptionComposite> parameterDescriptions;//TODO EDIT CHECK: only on methods of SEI
 
+	private ClassLoader				classLoader;
+	
 	/*
 	 * Default Constructor
 	 */
@@ -152,7 +154,7 @@
 	public String[] getExceptions() {
 		return exceptions;
 	}
-
+	
 	/**
 	 * @param methodName The methodName to set.
 	 */
@@ -200,7 +202,7 @@
 	/**
 	 * @param webServiceContextAnnot The webServiceContextAnnot to set.
 	 */
-	private void setWebServiceContextAnnot(WebServiceContextAnnot webServiceContextAnnot) {
+	public void setWebServiceContextAnnot(WebServiceContextAnnot webServiceContextAnnot) {
 		this.webServiceContextAnnot = webServiceContextAnnot;
 	}
 
@@ -244,6 +246,7 @@
 	 *  @param parameterDescription The parameterDescription to add to the set.
 	 */
 	public void addParameterDescriptionComposite(ParameterDescriptionComposite parameterDescription) {
+		parameterDescription.setClassLoader(this.classLoader);
 		parameterDescriptions.add(parameterDescription);
 	}
 	
@@ -271,6 +274,12 @@
 	}
 
 	/**
+	 */
+	public List<ParameterDescriptionComposite> getParameterDescriptionCompositeList() {
+		return parameterDescriptions;
+	}
+
+	/**
 	 * @param exceptions The exceptions to set.
 	 */
 	public void setExceptions(String[] exceptions) {
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/ParameterDescriptionComposite.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/ParameterDescriptionComposite.java	(revision 468124)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/ParameterDescriptionComposite.java	(working copy)
@@ -3,31 +3,42 @@
  */
 package org.apache.axis2.jaxws.description.builder;
 
+import java.lang.reflect.Type;
+
+import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.i18n.Messages;
+
 public class ParameterDescriptionComposite {
 	
-	private String 					parameterType;	
+	private String					parameterType;
+	private Class					parameterTypeClass;
+	private Type					parameterGenericType;
 	private WebParamAnnot			webParamAnnot;
 	private WebServiceRefAnnot 		webServiceRefAnnot;
 	private WebServiceContextAnnot	webServiceContextAnnot;
-	private int listOrder; //represents this composites order in the list
+	private int 					listOrder;
+	private ClassLoader 			classLoader;
 
 	public ParameterDescriptionComposite () {
 		
 	}
 	
 	public ParameterDescriptionComposite (	
-			String 					parameterType,
+			String					parameterType,
+			Class 					parameterTypeClass,
+			Type					parameterGenericType,
 			WebParamAnnot 			webParamAnnot,
 			WebServiceRefAnnot 		webServiceRefAnnot,
 			WebServiceContextAnnot	webServiceContextAnnot) {
 
 		this.parameterType 			= parameterType;
+		this.parameterTypeClass		= parameterTypeClass;
+		this.parameterGenericType	= parameterGenericType;
 		this.webParamAnnot 			= webParamAnnot;
 		this.webServiceRefAnnot 	= webServiceRefAnnot;
 		this.webServiceContextAnnot = webServiceContextAnnot;
 	}
 	
-
 	/**
 	 * @return Returns the parameterType.
 	 */
@@ -36,6 +47,46 @@
 	}
 
 	/**
+	 * @return Returns the parameterTypeClass.
+	 * Do lazy loading
+	 */
+	public Class getParameterTypeClass() {
+		if (parameterTypeClass == null) {
+			if (getParameterType() != null) {
+				parameterTypeClass = getPrimitiveClass(getParameterType());
+				if (parameterTypeClass == null) {
+					
+					if (classLoader != null) {			
+						try {
+							parameterTypeClass = Class.forName(parameterType, false, classLoader);
+							
+						} catch (ClassNotFoundException ex) {
+							throw ExceptionFactory.makeWebServiceException("ParameterDescriptionComposite: Class not found for parameter: " +parameterType);
+						}
+					} else {
+						//Use the default classloader to get this strings class
+						try {
+							parameterTypeClass = Class.forName(parameterType);
+						} catch (ClassNotFoundException ex) {
+							throw ExceptionFactory.makeWebServiceException("ParameterDescriptionComposite: Class not found for parameter: " +parameterType);
+						}
+					}
+				}
+			}
+		}
+		return parameterTypeClass;
+	}
+
+	/**
+	 * @return Returns the parameterGenericType.
+	 * Do lazy loading
+	 */
+	public Type getParameterGenericType() {
+		//TODO: Need to set this based on the parameterTypeClass ...hmmm
+		return parameterGenericType;
+	}
+
+	/**
 	 * @return Returns the webParamAnnot.
 	 */
 	public WebParamAnnot getWebParamAnnot() {
@@ -63,6 +114,13 @@
 		return listOrder;
 	}
 
+	/*
+	 * @return Returns the classloader to use
+	 */
+	public ClassLoader getClassLoader() {
+		return this.classLoader;
+	}
+	
 	/**
 	 * @param parameterType The parameterType to set.
 	 */
@@ -71,6 +129,20 @@
 	}
 
 	/**
+	 * @param parameterTypeClass The parameterTypeClass to set.
+	 */
+	private void setParameterTypeClass(Class parameterTypeClass) {
+		this.parameterTypeClass = parameterTypeClass;
+	}
+
+	/**
+	 * @param parameterGenericType The parameterGenericType to set.
+	 */
+	private void setParameterGenericType(Type parameterGenericType) {
+		this.parameterGenericType = parameterGenericType;
+	}
+
+	/**
 	 * @param webParamAnnot The webParamAnnot to set.
 	 */
 	public void setWebParamAnnot(WebParamAnnot webParamAnnot) {
@@ -98,6 +170,39 @@
 		this.listOrder = listOrder;
 	}
 
+	/*
+	 * @param classLoader the class loader to set
+	 */
+	public void setClassLoader(ClassLoader classLoader) {
+		this.classLoader = classLoader;
+	}
+
+	private Class getPrimitiveClass(String classType) {
+		
+		Class paramClass = null;
+System.out.println("classType: " +classType);
+		if (classType.equals("int")) {
+			paramClass = int.class;
+		} else if (classType.equals("byte")) {
+			paramClass = byte.class;
+		} else if (classType.equals("char")) {
+			paramClass = char.class;
+		} else if (classType.equals("short")) {
+			paramClass = short.class;
+		} else if (classType.equals("boolean")) {
+			paramClass = boolean.class;
+		} else if (classType.equals("long")) {
+			paramClass = long.class;
+		} else if (classType.equals("float")) {
+			paramClass = float.class;
+		} else if (classType.equals("double")) {
+			paramClass = double.class;
+		} else if (classType.equals("void")) {
+			paramClass = void.class;
+		}
+		return paramClass;
+	}
+	
 	/**
 	 * Convenience method for unit testing. We will print all of the 
 	 * data members here.
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/DescriptionBuilderComposite.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/DescriptionBuilderComposite.java	(revision 468124)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/DescriptionBuilderComposite.java	(working copy)
@@ -203,10 +203,12 @@
 		while(iter.hasNext()) {
 			composite = iter.next();
 			
-			if (composite.getMethodName().equals(methodName)){
-				hits++;
-				if (hits == occurence)
-					return composite;
+			if (composite.getMethodName() != null) {
+				if (composite.getMethodName().equals(methodName)){
+					hits++;
+					if (hits == occurence)
+						return composite;
+				}
 			}
 		}
 		
@@ -367,7 +369,7 @@
 	public void setIsInterface(boolean isInterface){
 		this.isInterface = isInterface;
 	}
-
+	
 	/**
 	 *  @param methodDescription The methodDescription to add to the set.
 	 */
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/MDQConstants.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/MDQConstants.java	(revision 468124)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/MDQConstants.java	(working copy)
@@ -29,4 +29,7 @@
     public static final String WSDL_DEFINITION = WSDLConstants.WSDL_4_J_DEFINITION;
     public static final String WSDL_LOCATION = "WSDL_LOCATION";
     public static final String SERVICE_CLASS = "SERVICE_CLASS";
+    public static final String WSDL_PORTTYPE_NAME = "WSDL_PORTTYPE_NAME";
+    
+    public static final String OBJECT_CLASS_NAME = "java.lang.Object";
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/DescriptionFactory.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/DescriptionFactory.java	(revision 468124)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/DescriptionFactory.java	(working copy)
@@ -71,26 +71,11 @@
     		}
     	}
     	
-    	//For each impl class and each SEI, build a ServiceDescription
-    	//TODO: Probably not the best way to process SEI's ...need to look at this
-    	/*
-    	HashMap<String, DescriptionBuilderComposite> seiMap = 
-    		sortedDBCList.getMap(DBCInputListSorter.seiMapKey);
-
-    	for (int i=1; i < sortedDBCList.getImplClassesList().size(); i++ ) {
-    		//process this sei class
-    		
-    		String seiName = sortedDBCList.getSeiClassesList().get(i);
-    		DescriptionBuilderComposite seiComposite = seiMap.get(seiName);
-            
-    		if (seiComposite == null)
-            	throw ExceptionFactory.makeWebServiceException("ServiceDescription.constructor: Can not find DBC represents associated serviceImplName:  " + serviceImplName);
-    		
-    		ServiceDescription serviceDescription = new ServiceDescription( sortedDBCList, seiComposite);
-    	   	serviceDescriptionList.add(serviceDescription);
-    	}
-    	*/  	
+    	//TODO: Process all composites that are WebFaults...current thinking is that
+    	//      since WebFault annotations only exist on exception classes, then they 
+    	//      should be processed by themselves, and at this level
     	
+    	
     	return serviceDescriptionList;
     }
 
