Index: C:/workspace/live/os_axis2/modules/kernel/test/org/apache/axis2/engine/MessageContextChangeTest.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/test/org/apache/axis2/engine/MessageContextChangeTest.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/test/org/apache/axis2/engine/MessageContextChangeTest.java	(working copy)
@@ -35,7 +35,7 @@
             new FieldDescription("java.lang.String", "logCorrelationIDString"),
             new FieldDescription("java.lang.String", "myClassName"),
             new FieldDescription("long", "serialVersionUID"),
-            new FieldDescription("int", "REVISION_1"),
+            new FieldDescription("int", "REVISION_2"),
             new FieldDescription("int", "revisionID"),
             new FieldDescription("java.lang.ThreadLocal", "currentMessageContext"),
             new FieldDescription("org.apache.axis2.client.Options", "options"),
Index: C:/workspace/live/os_axis2/modules/kernel/test/org/apache/axis2/engine/ObjectSave2Test.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/test/org/apache/axis2/engine/ObjectSave2Test.java	(revision 0)
+++ C:/workspace/live/os_axis2/modules/kernel/test/org/apache/axis2/engine/ObjectSave2Test.java	(revision 0)
@@ -0,0 +1,818 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.engine;
+
+import org.apache.axis2.context.externalize.SafeObjectInputStream;
+import org.apache.axis2.context.externalize.SafeObjectOutputStream;
+import org.apache.axis2.util.MetaDataEntry;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.Externalizable;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.NotSerializableException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.PrintStream;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedList;
+
+import junit.framework.TestCase;
+
+public class ObjectSave2Test extends TestCase {
+    protected static final Log log = LogFactory.getLog(ObjectSave2Test.class);
+    
+    private String testArg = null;
+
+	// simple constructor needed for nested class Externalizable interface
+	public ObjectSave2Test() {
+	}
+
+	public ObjectSave2Test(String arg0) {
+		super(arg0);
+		testArg = new String(arg0);
+	}
+
+	protected void setUp() throws Exception {
+		// org.apache.log4j.BasicConfigurator.configure();
+	}
+
+	public void testObjectSerializable() throws Exception {
+		File theFile = null;
+		String theFilename = null;
+		boolean saved = false;
+		boolean restored = false;
+		boolean done = false;
+
+        log.debug("ObjectSaveTest:testObjectSerializable():  BEGIN ---------------");
+
+		// ---------------------------------------------------------
+		// setup an object to use
+		// ---------------------------------------------------------
+		MetaDataEntry obj = new MetaDataEntry("object_1", "object_1");
+
+		// ---------------------------------------------------------
+		// setup a temporary file to use
+		// ---------------------------------------------------------
+		try {
+			theFile = File.createTempFile("objectTest", null);
+			theFilename = theFile.getName();
+            log.debug("ObjectSaveTest:testObjectSerializable(): temp file = ["
+                    + theFilename + "]");
+		} catch (Exception ex) {
+            log.debug("ObjectSaveTest:testObjectSerializable(): error creating temp file = ["
+                    + ex.getMessage() + "]");
+			theFile = null;
+		}
+
+		if (theFile != null) {
+			// ---------------------------------------------------------
+			// save to the temporary file
+			// ---------------------------------------------------------
+			try {
+				// setup an output stream to a physical file
+				FileOutputStream outStream = new FileOutputStream(theFile);
+
+				// attach a stream capable of writing objects to the
+				// stream connected to the file
+				ObjectOutputStream outObjStream = new ObjectOutputStream(
+						outStream);
+                                SafeObjectOutputStream out = 
+                                    SafeObjectOutputStream.install(outObjStream);
+
+				// try to save
+                log.debug("ObjectSaveTest:testObjectSerializable(): saving .....");
+				saved = false;
+                                out.writeObject(obj);
+
+				// close out the streams
+				outObjStream.flush();
+				outObjStream.close();
+				outStream.flush();
+				outStream.close();
+
+				saved = true;
+                log.debug(
+                        "ObjectSaveTest:testObjectSerializable(): " +
+                        "....save operation completed.....");
+
+				long filesize = theFile.length();
+                log.debug("ObjectSaveTest:testObjectSerializable(): file size after save ["
+                        + filesize
+                        + "]   temp file = ["
+                        + theFilename
+                        + "]");
+			} catch (Exception ex2) {
+                log.debug("ObjectSaveTest:testObjectSerializable(): error during save ["
+                        + ex2.getClass().getName()
+                        + " : "
+                        + ex2.getMessage() + "]");
+				ex2.printStackTrace();
+			}
+
+			assertTrue(saved);
+
+			// ---------------------------------------------------------
+			// restore from the temporary file
+			// ---------------------------------------------------------
+			try {
+				// setup an input stream to the file
+				FileInputStream inStream = new FileInputStream(theFile);
+
+				// attach a stream capable of reading objects from the
+				// stream connected to the file
+				ObjectInputStream inObjStream = new ObjectInputStream(inStream);
+                                SafeObjectInputStream in = 
+                                    SafeObjectInputStream.install(inObjStream);
+
+				// try to restore the options
+                log.debug("ObjectSaveTest:testObjectSerializable(): restoring .....");
+				restored = false;
+                                MetaDataEntry restored_obj = (MetaDataEntry) in.readObject();
+				inObjStream.close();
+				inStream.close();
+
+				restored = true;
+                log.debug(
+                        "ObjectSaveTest:testObjectSerializable(): ....restored operation completed.....");
+
+			} catch (Exception ex2) {
+                log.debug("ObjectSaveTest:testObjectSerializable(): error during restore ["
+                        + ex2.getClass().getName()
+                        + " : "
+                        + ex2.getMessage() + "]");
+				ex2.printStackTrace();
+			}
+
+			assertTrue(restored);
+
+			// if the save/restore of the object succeeded,
+			// then don't keep the temporary file around
+			boolean removeTmpFile = saved && restored;
+			if (removeTmpFile) {
+				try {
+					theFile.delete();
+				} catch (Exception e) {
+					// just absorb it
+				}
+			}
+
+			// indicate that the temp file was created ok
+			done = true;
+		}
+
+		// this is false when there are problems with the temporary file
+		assertTrue(done);
+
+        log.debug("ObjectSaveTest:testObjectSerializable():  END ---------------");
+	}
+
+	public void testObjectNotSerializable() throws Exception {
+		File theFile = null;
+		String theFilename = null;
+		boolean saved = false;
+		boolean restored = false;
+		boolean expected_exception = false;
+		boolean done = false;
+
+        log.debug("ObjectSaveTest:testObjectNotSerializable():  BEGIN ---------------");
+
+		// ---------------------------------------------------------
+		// setup an object to use
+		// ---------------------------------------------------------
+		NotSerializableObject obj = new NotSerializableObject("nso_1");
+
+		// ---------------------------------------------------------
+		// setup a temporary file to use
+		// ---------------------------------------------------------
+		try {
+			theFile = File.createTempFile("objectTest", null);
+			theFilename = theFile.getName();
+            log.debug("ObjectSaveTest:testObjectNotSerializable(): temp file = ["
+                    + theFilename + "]");
+		} catch (Exception ex) {
+            log.debug("ObjectSaveTest:testObjectNotSerializable(): error creating temp file = ["
+                    + ex.getMessage() + "]");
+			theFile = null;
+		}
+
+		if (theFile != null) {
+			// ---------------------------------------------------------
+			// save to the temporary file
+			// ---------------------------------------------------------
+			FileOutputStream outStream = null;
+			ObjectOutputStream outObjStream = null;
+			try {
+				// setup an output stream to a physical file
+				outStream = new FileOutputStream(theFile);
+
+				// attach a stream capable of writing objects to the
+				// stream connected to the file
+				outObjStream = new ObjectOutputStream(outStream);
+                                SafeObjectOutputStream out = 
+                                    SafeObjectOutputStream.install(outObjStream);
+
+				// try to save
+                log.debug("ObjectSaveTest:testObjectNotSerializable(): saving .....");
+				saved = false;
+                                out.writeObject(obj);
+				saved = true;
+                log.debug(
+                        "ObjectSaveTest:testObjectNotSerializable(): " +
+                        "....save operation completed.....");
+
+				long filesize = theFile.length();
+                log.debug("ObjectSaveTest:testObjectNotSerializable(): file size after save ["
+                        + filesize
+                        + "]   temp file = ["
+                        + theFilename
+                        + "]");
+			} catch (Exception ex2) {
+				// expect an error here
+				// ObjectStateUtils catches the NotSerializableException and
+				// logs it
+				if (ex2 instanceof NotSerializableException) {
+					expected_exception = true;
+				} else {
+                    log.debug("ObjectSaveTest:testObjectNotSerializable():  save ["
+                            + ex2.getClass().getName()
+                            + " : "
+                            + ex2.getMessage() + "]");
+				}
+			}
+			// close out the streams
+			if (outObjStream != null)
+				outObjStream.close();
+			if (outStream != null)
+				outStream.close();
+
+			// ---------------------------------------------------------
+			// restore from the temporary file
+			// ---------------------------------------------------------
+			try {
+				// setup an input stream to the file
+				FileInputStream inStream = new FileInputStream(theFile);
+
+				// attach a stream capable of reading objects from the
+				// stream connected to the file
+				ObjectInputStream inObjStream = new ObjectInputStream(inStream);
+                                SafeObjectInputStream in = 
+                                    SafeObjectInputStream.install(inObjStream);
+
+				// try to restore the options
+                log.debug("ObjectSaveTest:testObjectSerializable(): restoring .....");
+				restored = false;
+                                Object restored_obj = in.readObject();
+				inObjStream.close();
+				inStream.close();
+
+				restored = true;
+                log.debug(
+                        "ObjectSaveTest:testObjectNotSerializable(): " +
+                        "....restored operation completed.....");
+
+			} catch (Exception ex) {
+                log.debug("ObjectSaveTest:testObjectNotSerializable(): error during restore ["
+                        + ex.getClass().getName()
+                        + " : "
+                        + ex.getMessage() + "]");
+				ex.printStackTrace();
+			}
+
+			assertTrue(restored);
+
+			// if the save/restore of the object succeeded,
+			// then don't keep the temporary file around
+			boolean removeTmpFile = saved && restored;
+			if (removeTmpFile) {
+				try {
+					theFile.delete();
+				} catch (Exception e) {
+					// just absorb it
+				}
+			}
+
+			assertTrue(expected_exception);
+		}
+
+        log.debug("ObjectSaveTest:testObjectNotSerializable():  END ---------------");
+	}
+
+	public void testArrayList() throws Exception {
+		File theFile = null;
+		String theFilename = null;
+		boolean saved = false;
+		boolean restored = false;
+		boolean done = false;
+		boolean comparesOK = false;
+
+        log.debug("ObjectSaveTest:testArrayList():  BEGIN ---------------");
+
+		// ---------------------------------------------------------
+		// setup the object to use
+		// ---------------------------------------------------------
+		ArrayList obj = new ArrayList();
+		obj.add(new Integer(1));
+		obj.add(new Integer(2));
+		obj.add(new Integer(3));
+		obj.add(new String("string1"));
+		obj.add(new String("string2"));
+		obj.add(System.out);
+		obj.add(new Integer(4));
+		obj.add(new Integer(5));
+		obj.add(new Integer(6));
+
+		int initial_size = obj.size();
+
+		// ---------------------------------------------------------
+		// setup a temporary file to use
+		// ---------------------------------------------------------
+		try {
+			theFile = File.createTempFile("arraylistTest", null);
+			theFilename = theFile.getName();
+            log.debug("ObjectSaveTest:testArrayList(): temp file = ["
+                    + theFilename + "]");
+		} catch (Exception ex) {
+            log.debug("ObjectSaveTest:testArrayList(): error creating temp file = ["
+                    + ex.getMessage() + "]");
+			theFile = null;
+		}
+
+		if (theFile != null) {
+			// ---------------------------------------------------------
+			// save to the temporary file
+			// ---------------------------------------------------------
+			try {
+				// setup an output stream to a physical file
+				FileOutputStream outStream = new FileOutputStream(theFile);
+
+				// attach a stream capable of writing objects to the
+				// stream connected to the file
+				ObjectOutputStream outObjStream = new ObjectOutputStream(
+						outStream);
+                                SafeObjectOutputStream out = 
+                                    SafeObjectOutputStream.install(outObjStream);
+
+				// try to save
+                log.debug("ObjectSaveTest:testArrayList(): saving .....");
+				saved = false;
+                                out.writeList(obj);
+
+				// close out the streams
+				outObjStream.flush();
+				outObjStream.close();
+				outStream.flush();
+				outStream.close();
+
+				saved = true;
+                log.debug("ObjectSaveTest:testArrayList(): ....save operation completed.....");
+
+				long filesize = theFile.length();
+                log.debug("ObjectSaveTest:testArrayList(): file size after save ["
+                        + filesize
+                        + "]   temp file = ["
+                        + theFilename
+                        + "]");
+			} catch (Exception ex2) {
+                log.debug("ObjectSaveTest:testArrayList(): error during save ["
+                        + ex2.getClass().getName()
+                        + " : "
+                        + ex2.getMessage() + "]");
+				ex2.printStackTrace();
+			}
+
+			assertTrue(saved);
+
+			// ---------------------------------------------------------
+			// restore from the temporary file
+			// ---------------------------------------------------------
+			ArrayList restored_obj = null;
+
+			try {
+				// setup an input stream to the file
+				FileInputStream inStream = new FileInputStream(theFile);
+
+				// attach a stream capable of reading objects from the
+				// stream connected to the file
+				ObjectInputStream inObjStream = new ObjectInputStream(inStream);
+                                SafeObjectInputStream in = 
+                                    SafeObjectInputStream.install(inObjStream);
+
+				// try to restore the options
+                log.debug("ObjectSaveTest:testArrayList(): restoring .....");
+				restored = false;
+                                restored_obj = in.readArrayList();
+				inObjStream.close();
+				inStream.close();
+
+				restored = true;
+                log.debug("ObjectSaveTest:testArrayList(): ....restored operation completed.....");
+
+			} catch (Exception ex2) {
+                log.debug("ObjectSaveTest:testArrayList(): error during restore ["
+                        + ex2.getClass().getName()
+                        + " : "
+                        + ex2.getMessage() + "]");
+				ex2.printStackTrace();
+			}
+
+			// if the save/restore of the object succeeded,
+			// then don't keep the temporary file around
+			boolean removeTmpFile = saved && restored;
+			if (removeTmpFile) {
+				try {
+					theFile.delete();
+				} catch (Exception e) {
+					// just absorb it
+				}
+			}
+
+			assertTrue(restored);
+
+			if (restored_obj != null) {
+				int restored_size = restored_obj.size();
+				if (restored_size == (initial_size - 1)) {
+					comparesOK = true;
+				}
+			}
+
+			// TODO: check for exact entries
+
+			assertTrue(comparesOK);
+
+			// indicate that the temp file was created ok
+			done = true;
+		}
+
+		// this is false when there are problems with the temporary file
+		assertTrue(done);
+
+        log.debug("ObjectSaveTest:testArrayList():  END ---------------");
+	}
+
+	public void testHashMap() throws Exception {
+		File theFile = null;
+		String theFilename = null;
+		boolean saved = false;
+		boolean restored = false;
+		boolean done = false;
+		boolean comparesOK = false;
+
+        log.debug("ObjectSaveTest:testHashMap():  BEGIN ---------------");
+
+		// ---------------------------------------------------------
+		// setup the object to use
+		// ---------------------------------------------------------
+		HashMap obj = new HashMap();
+		obj.put(new String("key1"), new Integer(1));
+		obj.put(new String("key2"), new Integer(2));
+		obj.put(new String("key3"), new String("value1"));
+		obj.put(new String("key4"), System.out);
+		obj.put(new String("key5"), new Integer(3));
+		obj.put(new String("key6"), new Integer(4));
+		obj.put(new String("key7"), System.err);
+		obj.put(new String("key8"), new Integer(5));
+		obj.put(new String("key9"), new Integer(6));
+		obj.put(new NotSerializableObject("TestForHashMapKey"), new Integer(7));
+		obj.put(new String("key10"), new Integer(8));
+
+		int initial_size = obj.size();
+
+		// ---------------------------------------------------------
+		// setup a temporary file to use
+		// ---------------------------------------------------------
+		try {
+			theFile = File.createTempFile("hashmapTest", null);
+			theFilename = theFile.getName();
+            log.debug("ObjectSaveTest:testHashMap(): temp file = ["
+                    + theFilename + "]");
+		} catch (Exception ex) {
+            log.debug("ObjectSaveTest:testHashMap(): error creating temp file = ["
+                    + ex.getMessage() + "]");
+			theFile = null;
+		}
+
+		if (theFile != null) {
+			// ---------------------------------------------------------
+			// save to the temporary file
+			// ---------------------------------------------------------
+			try {
+				// setup an output stream to a physical file
+				FileOutputStream outStream = new FileOutputStream(theFile);
+
+				// attach a stream capable of writing objects to the
+				// stream connected to the file
+				ObjectOutputStream outObjStream = new ObjectOutputStream(
+						outStream);
+                                SafeObjectOutputStream out = 
+                                    SafeObjectOutputStream.install(outObjStream);
+
+				// try to save
+                log.debug("ObjectSaveTest:testHashMap(): saving .....");
+				saved = false;
+                                out.writeMap(obj);
+
+				// close out the streams
+				outObjStream.flush();
+				outObjStream.close();
+				outStream.flush();
+				outStream.close();
+
+				saved = true;
+                log.debug("ObjectSaveTest:testHashMap(): ....save operation completed.....");
+
+				long filesize = theFile.length();
+                log.debug("ObjectSaveTest:testHashMap(): file size after save ["
+                        + filesize
+                        + "]   temp file = ["
+                        + theFilename
+                        + "]");
+			} catch (Exception ex2) {
+                log.debug("ObjectSaveTest:testHashMap(): error during save ["
+                        + ex2.getClass().getName()
+                        + " : "
+                        + ex2.getMessage() + "]");
+				ex2.printStackTrace();
+			}
+
+			assertTrue(saved);
+
+			// ---------------------------------------------------------
+			// restore from the temporary file
+			// ---------------------------------------------------------
+			HashMap restored_obj = null;
+
+			try {
+				// setup an input stream to the file
+				FileInputStream inStream = new FileInputStream(theFile);
+
+				// attach a stream capable of reading objects from the
+				// stream connected to the file
+				ObjectInputStream inObjStream = new ObjectInputStream(inStream);
+                                SafeObjectInputStream in = 
+                                    SafeObjectInputStream.install(inObjStream);
+
+				// try to restore the options
+                log.debug("ObjectSaveTest:testHashMap(): restoring .....");
+				restored = false;
+                                restored_obj = in.readHashMap();
+				inObjStream.close();
+				inStream.close();
+
+				restored = true;
+                log.debug("ObjectSaveTest:testHashMap(): ....restored operation completed.....");
+
+			} catch (Exception ex2) {
+                log.debug("ObjectSaveTest:testHashMap(): error during restore ["
+                        + ex2.getClass().getName()
+                        + " : "
+                        + ex2.getMessage() + "]");
+				ex2.printStackTrace();
+			}
+
+			// if the save/restore of the object succeeded,
+			// then don't keep the temporary file around
+			boolean removeTmpFile = saved && restored;
+			if (removeTmpFile) {
+				try {
+					theFile.delete();
+				} catch (Exception e) {
+					// just absorb it
+				}
+			}
+
+			assertTrue(restored);
+
+			if (restored_obj != null) {
+				int restored_size = restored_obj.size();
+				if (restored_size == (initial_size - 3)) {
+					// there are entries in the map that are not serializable
+					comparesOK = true;
+				}
+			}
+
+			// TODO: check for exact entries
+
+			assertTrue(comparesOK);
+
+			// indicate that the temp file was created ok
+			done = true;
+		}
+
+		// this is false when there are problems with the temporary file
+		assertTrue(done);
+
+        log.debug("ObjectSaveTest:testHashMap():  END ---------------");
+	}
+
+	public void testLinkedList() throws Exception {
+		File theFile = null;
+		String theFilename = null;
+		boolean saved = false;
+		boolean restored = false;
+		boolean done = false;
+		boolean comparesOK = false;
+
+        log.debug("ObjectSaveTest:testLinkedList():  BEGIN ---------------");
+
+		// ---------------------------------------------------------
+		// setup the object to use
+		// ---------------------------------------------------------
+		LinkedList obj = new LinkedList();
+		obj.add(new Integer(1));
+		obj.add(new Integer(2));
+		obj.add(new Integer(3));
+		obj.add(new String("string1"));
+		obj.add(new String("string2"));
+		obj.add(System.in);
+		obj.add(new Integer(4));
+		obj.add(new Integer(5));
+		obj.add(new Integer(6));
+
+		int initial_size = obj.size();
+
+		// ---------------------------------------------------------
+		// setup a temporary file to use
+		// ---------------------------------------------------------
+		try {
+			theFile = File.createTempFile("linkedlistTest", null);
+			theFilename = theFile.getName();
+            log.debug("ObjectSaveTest:testLinkedList(): temp file = ["
+                    + theFilename + "]");
+		} catch (Exception ex) {
+            log.debug("ObjectSaveTest:testLinkedList(): error creating temp file = ["
+                    + ex.getMessage() + "]");
+			theFile = null;
+		}
+
+		if (theFile != null) {
+			// ---------------------------------------------------------
+			// save to the temporary file
+			// ---------------------------------------------------------
+			try {
+				// setup an output stream to a physical file
+				FileOutputStream outStream = new FileOutputStream(theFile);
+
+				// attach a stream capable of writing objects to the
+				// stream connected to the file
+				ObjectOutputStream outObjStream = new ObjectOutputStream(
+						outStream);
+                                SafeObjectOutputStream out = 
+                                    SafeObjectOutputStream.install(outObjStream);
+
+				// try to save
+                log.debug("ObjectSaveTest:testLinkedList(): saving .....");
+				saved = false;
+                                out.writeList(obj);
+
+				// close out the streams
+				outObjStream.flush();
+				outObjStream.close();
+				outStream.flush();
+				outStream.close();
+
+				saved = true;
+                log.debug("ObjectSaveTest:testLinkedList(): ....save operation completed.....");
+
+				long filesize = theFile.length();
+                log.debug("ObjectSaveTest:testLinkedList(): file size after save ["
+                        + filesize
+                        + "]   temp file = ["
+                        + theFilename
+                        + "]");
+			} catch (Exception ex2) {
+                log.debug("ObjectSaveTest:testLinkedList(): error during save ["
+                        + ex2.getClass().getName()
+                        + " : "
+                        + ex2.getMessage() + "]");
+				ex2.printStackTrace();
+			}
+
+			assertTrue(saved);
+
+			// ---------------------------------------------------------
+			// restore from the temporary file
+			// ---------------------------------------------------------
+			LinkedList restored_obj = null;
+
+			try {
+				// setup an input stream to the file
+				FileInputStream inStream = new FileInputStream(theFile);
+
+				// attach a stream capable of reading objects from the
+				// stream connected to the file
+				ObjectInputStream inObjStream = new ObjectInputStream(inStream);
+                                SafeObjectInputStream in = 
+                                    SafeObjectInputStream.install(inObjStream);
+
+				// try to restore the options
+                log.debug("ObjectSaveTest:testLinkedList(): restoring .....");
+				restored = false;
+                                restored_obj = in.readLinkedList();
+				inObjStream.close();
+				inStream.close();
+
+				restored = true;
+                log.debug("ObjectSaveTest:testLinkedList(): ....restored operation completed.....");
+
+			} catch (Exception ex2) {
+                log.debug("ObjectSaveTest:testLinkedList(): error during restore ["
+                        + ex2.getClass().getName()
+                        + " : "
+                        + ex2.getMessage() + "]");
+				ex2.printStackTrace();
+			}
+
+			// if the save/restore of the object succeeded,
+			// then don't keep the temporary file around
+			boolean removeTmpFile = saved && restored;
+			if (removeTmpFile) {
+				try {
+					theFile.delete();
+				} catch (Exception e) {
+					// just absorb it
+				}
+			}
+
+			assertTrue(restored);
+
+			if (restored_obj != null) {
+				int restored_size = restored_obj.size();
+				if (restored_size == (initial_size - 1)) {
+					comparesOK = true;
+				}
+			}
+
+			// TODO: check for exact entries
+
+			assertTrue(comparesOK);
+
+			// indicate that the temp file was created ok
+			done = true;
+		}
+
+		// this is false when there are problems with the temporary file
+		assertTrue(done);
+
+        log.debug("ObjectSaveTest:testLinkedList():  END ---------------");
+	}
+
+	public class NotSerializableObject implements Externalizable {
+		private String label = "TestObject";
+
+		private String ID = null;
+
+		// make sure we have some objects that don't serialize
+		private PrintStream ps = System.out;
+
+		// default constructor needed for Externalizable interface
+		public NotSerializableObject() {
+		}
+
+		public NotSerializableObject(String identifier) {
+			ID = identifier;
+			ps = System.out;
+		}
+
+		public void setID(String s) {
+			ID = s;
+		}
+
+		public String getID() {
+			return ID;
+		}
+
+		public void writeExternal(java.io.ObjectOutput out) throws IOException {
+			throw new NotSerializableException(
+					"Test Object is not serializable");
+		}
+
+		public void readExternal(java.io.ObjectInput in) throws IOException,
+				ClassNotFoundException {
+			throw new IOException("Test object is not serializable");
+		}
+
+	}
+
+}
Index: C:/workspace/live/os_axis2/modules/kernel/test/org/apache/axis2/engine/MessageContextSaveATest.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/test/org/apache/axis2/engine/MessageContextSaveATest.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/test/org/apache/axis2/engine/MessageContextSaveATest.java	(working copy)
@@ -19,7 +19,6 @@
 
 package org.apache.axis2.engine;
 
-import junit.framework.TestCase;
 import org.apache.axiom.om.OMAbstractFactory;
 import org.apache.axiom.om.util.UUIDGenerator;
 import org.apache.axiom.soap.SOAPFactory;
@@ -30,6 +29,7 @@
 import org.apache.axis2.context.OperationContext;
 import org.apache.axis2.context.ServiceContext;
 import org.apache.axis2.context.ServiceGroupContext;
+import org.apache.axis2.context.externalize.ActivateUtils;
 import org.apache.axis2.description.AxisMessage;
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisService;
@@ -47,12 +47,12 @@
 import org.apache.axis2.receivers.RawXMLINOutMessageReceiver;
 import org.apache.axis2.transport.http.CommonsHTTPTransportSender;
 import org.apache.axis2.transport.http.SimpleHTTPServer;
-import org.apache.axis2.util.ObjectStateUtils;
 import org.apache.axis2.wsdl.WSDLConstants;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import javax.xml.namespace.QName;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -62,6 +62,8 @@
 import java.util.HashMap;
 import java.util.Iterator;
 
+import junit.framework.TestCase;
+
 public class MessageContextSaveATest extends TestCase {
     protected static final Log log = LogFactory.getLog(MessageContextSaveATest.class);
 
@@ -685,7 +687,7 @@
                 ArrayList orig_execChain = simpleMsg.getExecutionChain();
 
                 comparesOk =
-                        ObjectStateUtils.isEquivalent(restored_execChain, orig_execChain, false);
+                        ActivateUtils.isEquivalent(restored_execChain, orig_execChain, false);
                 log.debug(title + "execution chain equivalency [" + comparesOk + "]");
                 assertTrue(comparesOk);
 
@@ -834,7 +836,7 @@
                 ArrayList orig_execChain = simpleMsg.getExecutionChain();
 
                 comparesOk =
-                        ObjectStateUtils.isEquivalent(restored_execChain, orig_execChain, false);
+                    ActivateUtils.isEquivalent(restored_execChain, orig_execChain, false);
                 log.debug(title + "execution chain equivalency [" + comparesOk + "]");
                 assertTrue(comparesOk);
 
@@ -1241,7 +1243,7 @@
                         ArrayList restored_execChain = msgContext2.getExecutionChain();
                         ArrayList orig_execChain = msgContext.getExecutionChain();
 
-                        comparesOk = ObjectStateUtils
+                        comparesOk = ActivateUtils
                                 .isEquivalent(restored_execChain, orig_execChain, false);
                         log.debug(title + "execution chain equivalency [" + comparesOk + "]");
                         assertTrue(comparesOk);
Index: C:/workspace/live/os_axis2/modules/kernel/test/org/apache/axis2/engine/MessageContextSaveBTest.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/test/org/apache/axis2/engine/MessageContextSaveBTest.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/test/org/apache/axis2/engine/MessageContextSaveBTest.java	(working copy)
@@ -19,7 +19,6 @@
 
 package org.apache.axis2.engine;
 
-import junit.framework.TestCase;
 import org.apache.axiom.om.OMAbstractFactory;
 import org.apache.axiom.om.util.UUIDGenerator;
 import org.apache.axiom.soap.SOAPFactory;
@@ -30,6 +29,7 @@
 import org.apache.axis2.context.OperationContext;
 import org.apache.axis2.context.ServiceContext;
 import org.apache.axis2.context.ServiceGroupContext;
+import org.apache.axis2.context.externalize.ActivateUtils;
 import org.apache.axis2.description.AxisMessage;
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisService;
@@ -47,12 +47,12 @@
 import org.apache.axis2.receivers.RawXMLINOutMessageReceiver;
 import org.apache.axis2.transport.http.CommonsHTTPTransportSender;
 import org.apache.axis2.transport.http.SimpleHTTPServer;
-import org.apache.axis2.util.ObjectStateUtils;
 import org.apache.axis2.wsdl.WSDLConstants;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import javax.xml.namespace.QName;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -63,6 +63,8 @@
 import java.util.Iterator;
 import java.util.Map;
 
+import junit.framework.TestCase;
+
 public class MessageContextSaveBTest extends TestCase {
     protected static final Log log = LogFactory.getLog(MessageContextSaveBTest.class);
 
@@ -590,7 +592,7 @@
         showProperties(properties4, "service properties from other active MsgCtx");
 
         // the service level properties should be the same
-        boolean isOk = ObjectStateUtils.isEquivalent(properties3, properties4, true);
+        boolean isOk = ActivateUtils.isEquivalent(properties3, properties4, true);
         assertTrue(isOk);
 
     }
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/addressing/EndpointReference.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/addressing/EndpointReference.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/addressing/EndpointReference.java	(working copy)
@@ -30,16 +30,20 @@
 import org.apache.axiom.om.util.StAXUtils;
 import org.apache.axiom.om.util.UUIDGenerator;
 import org.apache.axis2.AxisFault;
-import org.apache.axis2.util.ObjectStateUtils;
+import org.apache.axis2.context.externalize.ExternalizeConstants;
+import org.apache.axis2.context.externalize.SafeObjectInputStream;
+import org.apache.axis2.context.externalize.SafeObjectOutputStream;
+import org.apache.axis2.context.externalize.SafeSerializable;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLStreamReader;
+
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import java.io.Externalizable;
 import java.io.IOException;
-import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -51,11 +55,16 @@
  * Since the models for this in Submission and Final versions are different, lets make this to comply with
  * WS-A Final version. So any information found with WS-A submission will be "pumped" in to this model.
  */
-public class EndpointReference implements Serializable {
+public class EndpointReference implements Externalizable, SafeSerializable {
 
     private static final long serialVersionUID = 5278892171162372439L;
 
     private static final Log log = LogFactory.getLog(EndpointReference.class);
+    
+    //  supported revision levels, add a new level to manage compatible changes
+    private static final int REVISION_2 = 2;
+    // current revision level of this object
+    private static final int revisionID = REVISION_2;
 
     private static final String myClassName = "EndpointReference";
 
@@ -84,6 +93,12 @@
     private ArrayList extensibleElements;
     private ArrayList attributes;
 
+    /**
+     * No-Arg Constructor
+     * Required for Externalizable objects
+     */
+    public EndpointReference() {}
+ 
 
     /**
      * @param address
@@ -561,14 +576,21 @@
      * OMElements/Attributes, we need to actually serialize the OM structures
      * (at least in some cases.)
      */
-    private void writeObject(java.io.ObjectOutputStream out)
+    public void writeExternal(java.io.ObjectOutput o)
             throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
+        
+        // revision ID
+        out.writeInt(revisionID);
+        
+        // Correlation ID
         String logCorrelationIDString = getLogCorrelationIDString();
 
         // String object id
-        ObjectStateUtils.writeString(out, logCorrelationIDString, logCorrelationIDString
-                + ".logCorrelationIDString");
+        out.writeObject(logCorrelationIDString);
 
+        // Write out the content as xml
+        out.writeUTF("start xml"); // write marker
         OMElement om =
                 EndpointReferenceHelper.toOM(OMAbstractFactory.getOMFactory(),
                                              this,
@@ -594,7 +616,8 @@
         }
 
         out.writeInt(baos.size());
-        out.write(baos.toByteArray());
+        out.write(baos.toByteArray());  
+        out.writeUTF("end xml"); // write marker
 
         if (log.isDebugEnabled()) {
             byte[] buffer = baos.toByteArray();
@@ -610,12 +633,23 @@
     /**
      * Read the EPR to the specified InputStream.
      */
-    private void readObject(java.io.ObjectInputStream in)
+    public void readExternal(java.io.ObjectInput inObject)
             throws IOException, ClassNotFoundException {
-
+        SafeObjectInputStream in = SafeObjectInputStream.install(inObject);
+        
+        // revision ID
+        int revID = in.readInt();
+        
+        // make sure the object data is in a revision level we can handle
+        if (revID != REVISION_2) {
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_REVID);
+        }
+        
         // String object id
-        logCorrelationIDString = ObjectStateUtils.readString(in, "EndpointReference.logCorrelationIDString");
+        logCorrelationIDString = (String) in.readObject();
 
+        // Read xml content
+        in.readUTF(); // read marker
         int numBytes = in.readInt();
 
         byte[] serBytes = new byte[numBytes];
@@ -655,6 +689,7 @@
 
             throw ioe;
         }
+        in.readUTF(); // read marker
 
         ByteArrayInputStream bais = new ByteArrayInputStream(serBytes);
 
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/addressing/RelatesTo.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/addressing/RelatesTo.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/addressing/RelatesTo.java	(working copy)
@@ -20,7 +20,10 @@
 
 package org.apache.axis2.addressing;
 
-import org.apache.axis2.util.ObjectStateUtils;
+import org.apache.axis2.context.externalize.ExternalizeConstants;
+import org.apache.axis2.context.externalize.SafeObjectInputStream;
+import org.apache.axis2.context.externalize.SafeObjectOutputStream;
+import org.apache.axis2.context.externalize.SafeSerializable;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -33,7 +36,7 @@
 /**
  * Class RelatesTo
  */
-public class RelatesTo implements Externalizable {
+public class RelatesTo implements Externalizable, SafeSerializable {
 
     /*
      * setup for logging
@@ -61,9 +64,9 @@
      * Refer to the writeExternal() and readExternal() methods.
      */
     // supported revision levels, add a new level to manage compatible changes
-    private static final int REVISION_1 = 1;
+    private static final int REVISION_2 = 2;
     // current revision level of this object
-    private static final int revisionID = REVISION_1;
+    private static final int revisionID = REVISION_2;
 
 
     /**
@@ -169,7 +172,8 @@
      * @param out The stream to write the object contents to
      * @throws IOException
      */
-    public void writeExternal(ObjectOutput out) throws IOException {
+    public void writeExternal(ObjectOutput o) throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
         // write out contents of this object
 
         // NOTES: For each item, where appropriate,
@@ -195,18 +199,16 @@
         //---------------------------------------------------------
 
         // String relationshipType
-        ObjectStateUtils.writeString(out, relationshipType, "RelatesTo.relationshipType");
+        out.writeObject(relationshipType);
 
         // String value
-        ObjectStateUtils.writeString(out, value, "RelatesTo.value");
+        out.writeObject(value);
 
         //---------------------------------------------------------
         // collections and lists
         //---------------------------------------------------------
+        out.writeList(extensibilityAttributes);
 
-        ObjectStateUtils
-                .writeArrayList(out, extensibilityAttributes, "RelatesTo.extensibilityAttributes");
-
     }
 
 
@@ -222,7 +224,8 @@
      * @throws IOException
      * @throws ClassNotFoundException
      */
-    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+    public void readExternal(ObjectInput inObject) throws IOException, ClassNotFoundException {
+        SafeObjectInputStream in = SafeObjectInputStream.install(inObject);
         // serialization version ID
         long suid = in.readLong();
 
@@ -231,12 +234,12 @@
 
         // make sure the object data is in a version we can handle
         if (suid != serialVersionUID) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_SUID);
         }
 
         // make sure the object data is in a revision level we can handle
-        if (revID != REVISION_1) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        if (revID != REVISION_2) {
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_REVID);
         }
 
         //---------------------------------------------------------
@@ -244,23 +247,17 @@
         //---------------------------------------------------------
 
         // String relationshipType
-        relationshipType = ObjectStateUtils.readString(in, "RelatesTo.relationshipType");
+        relationshipType = (String)in.readObject();
 
         // String value
-        value = ObjectStateUtils.readString(in, "RelatesTo.value");
+        value = (String) in.readObject();
 
         //---------------------------------------------------------
         // collections and lists
         //---------------------------------------------------------
 
         // ArrayList extensibilityAttributes
-        ArrayList tmpAL2 = ObjectStateUtils.readArrayList(in, "RelatesTo.extensibilityAttributes");
-        if (tmpAL2 != null) {
-            extensibilityAttributes = new ArrayList(tmpAL2);
-        } else {
-            extensibilityAttributes = null;
-        }
-
+        extensibilityAttributes = in.readArrayList();
     }
 
 }
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/description/Parameter.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/description/Parameter.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/description/Parameter.java	(working copy)
@@ -18,12 +18,16 @@
 import org.apache.axiom.om.OMAbstractFactory;
 import org.apache.axiom.om.OMElement;
 import org.apache.axiom.om.impl.builder.StAXOMBuilder;
-import org.apache.axis2.util.ObjectStateUtils;
+import org.apache.axis2.context.externalize.ExternalizeConstants;
+import org.apache.axis2.context.externalize.SafeObjectInputStream;
+import org.apache.axis2.context.externalize.SafeObjectOutputStream;
+import org.apache.axis2.context.externalize.SafeSerializable;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLStreamReader;
+
 import java.io.ByteArrayInputStream;
 import java.io.Externalizable;
 import java.io.IOException;
@@ -34,7 +38,7 @@
 /**
  * Class Parameter
  */
-public class Parameter implements Externalizable {
+public class Parameter implements Externalizable, SafeSerializable {
 
     /*
      * setup for logging
@@ -62,9 +66,9 @@
      * Refer to the writeExternal() and readExternal() methods.
      */
     // supported revision levels, add a new level to manage compatible changes
-    private static final int REVISION_1 = 1;
+    private static final int REVISION_2 = 2;
     // current revision level of this object
-    private static final int revisionID = REVISION_1;
+    private static final int revisionID = REVISION_2;
 
 
     /**
@@ -261,7 +265,8 @@
      * @param out The stream to write the object contents to
      * @throws IOException
      */
-    public void writeExternal(ObjectOutput out) throws IOException {
+    public void writeExternal(ObjectOutput o) throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
         // write out contents of this object
 
         //---------------------------------------------------------
@@ -281,9 +286,8 @@
 
         out.writeInt(type);
         out.writeBoolean(locked);
+        out.writeObject(name);
 
-        ObjectStateUtils.writeString(out, name, "Parameter.name");
-
         //---------------------------------------------------------
         // object fields
         //---------------------------------------------------------
@@ -297,13 +301,8 @@
         if (parameterElement != null) {
             tmp = parameterElement.toString();
         }
-
-        // treat as an object, don't do UTF
-        ObjectStateUtils.writeObject(out, tmp, "Parameter.parameterElement");
-
-        // TODO: error handling if this can't be serialized
-        ObjectStateUtils.writeObject(out, value, "Parameter.value");
-
+        out.writeObject(tmp); // parameterElement
+        out.writeObject(value);
     }
 
 
@@ -318,7 +317,8 @@
      * @throws IOException
      * @throws ClassNotFoundException
      */
-    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+    public void readExternal(ObjectInput inObject) throws IOException, ClassNotFoundException {
+        SafeObjectInputStream in = SafeObjectInputStream.install(inObject);
         // trace point
         if (log.isTraceEnabled()) {
             log.trace(myClassName + ":readExternal():  BEGIN  bytes available in stream [" +
@@ -333,12 +333,12 @@
 
         // make sure the object data is in a version we can handle
         if (suid != serialVersionUID) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_SUID);
         }
 
         // make sure the object data is in a revision level we can handle
-        if (revID != REVISION_1) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        if (revID != REVISION_2) {
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_REVID);
         }
 
         //---------------------------------------------------------
@@ -347,9 +347,8 @@
 
         type = in.readInt();
         locked = in.readBoolean();
+        name = (String) in.readObject();
 
-        name = ObjectStateUtils.readString(in, "Parameter.name");
-
         //---------------------------------------------------------
         // object fields
         //---------------------------------------------------------
@@ -359,7 +358,7 @@
         // to a String but will build the OMTree in the memory
 
         // treat as an object, don't do UTF
-        String tmp = (String) ObjectStateUtils.readObject(in, "Parameter.parameterElement");
+        String tmp = (String) in.readObject();
 
         // convert to an OMElement
         if (tmp != null) {
@@ -389,7 +388,7 @@
         }
 
         // TODO: error handling if this can't be serialized
-        value = ObjectStateUtils.readObject(in, "Parameter.value");
+        value = in.readObject();
 
         //---------------------------------------------------------
         // done
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/description/ParameterIncludeImpl.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/description/ParameterIncludeImpl.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/description/ParameterIncludeImpl.java	(working copy)
@@ -23,12 +23,16 @@
 import org.apache.axiom.om.OMAttribute;
 import org.apache.axiom.om.OMElement;
 import org.apache.axis2.AxisFault;
+import org.apache.axis2.context.externalize.ExternalizeConstants;
+import org.apache.axis2.context.externalize.SafeObjectInputStream;
+import org.apache.axis2.context.externalize.SafeObjectOutputStream;
+import org.apache.axis2.context.externalize.SafeSerializable;
 import org.apache.axis2.deployment.DeploymentConstants;
-import org.apache.axis2.util.ObjectStateUtils;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import javax.xml.namespace.QName;
+
 import java.io.Externalizable;
 import java.io.IOException;
 import java.io.ObjectInput;
@@ -41,7 +45,8 @@
 /**
  * Class ParameterIncludeImpl
  */
-public class ParameterIncludeImpl implements ParameterInclude, Externalizable {
+public class ParameterIncludeImpl 
+    implements ParameterInclude, Externalizable, SafeSerializable {
 
     /*
      * setup for logging
@@ -69,9 +74,9 @@
      * Refer to the writeExternal() and readExternal() methods.
      */
     // supported revision levels, add a new level to manage compatible changes
-    private static final int REVISION_1 = 1;
+    private static final int REVISION_2 = 2;
     // current revision level of this object
-    private static final int revisionID = REVISION_1;
+    private static final int revisionID = REVISION_2;
 
 
     /**
@@ -204,7 +209,8 @@
      * @param out The stream to write the object contents to
      * @throws IOException
      */
-    public void writeExternal(ObjectOutput out) throws IOException {
+    public void writeExternal(ObjectOutput o) throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
         // write out contents of this object
 
         //---------------------------------------------------------
@@ -221,7 +227,7 @@
         //---------------------------------------------------------
         // collection of parameters
         //---------------------------------------------------------
-        ObjectStateUtils.writeHashMap(out, parameters, "ParameterIncludeImpl.parameters");
+        out.writeMap(parameters);
 
     }
 
@@ -237,7 +243,8 @@
      * @throws IOException
      * @throws ClassNotFoundException
      */
-    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+    public void readExternal(ObjectInput inObject) throws IOException, ClassNotFoundException {
+        SafeObjectInputStream in = SafeObjectInputStream.install(inObject);
         // trace point
         if (log.isTraceEnabled()) {
             log.trace(myClassName + ":readExternal():  BEGIN  bytes available in stream [" +
@@ -252,35 +259,22 @@
 
         // make sure the object data is in a version we can handle
         if (suid != serialVersionUID) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_SUID);
         }
 
         // make sure the object data is in a revision level we can handle
-        if (revID != REVISION_1) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        if (revID != REVISION_2) {
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_REVID);
         }
 
         //---------------------------------------------------------
         // collection of parameters
         //---------------------------------------------------------
+        in.readMap(parameters);
 
-        HashMap tmp = ObjectStateUtils.readHashMap(in, "ParameterIncludeImpl.parameters");
-
-        if (tmp != null) {
-            if (parameters != null) {
-                parameters.putAll(tmp);
-            } else {
-                if (log.isTraceEnabled()) {
-                    log.trace(myClassName +
-                            ":readExternal():  WARNING: parameters doesnot have a defined HashMap ");
-                }
-            }
-        }
-
         //---------------------------------------------------------
         // done
         //---------------------------------------------------------
-
     }
 
 }
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/ServiceGroupContext.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/ServiceGroupContext.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/ServiceGroupContext.java	(working copy)
@@ -22,12 +22,16 @@
 
 import org.apache.axiom.om.util.UUIDGenerator;
 import org.apache.axis2.AxisFault;
+import org.apache.axis2.context.externalize.ActivateUtils;
+import org.apache.axis2.context.externalize.ExternalizeConstants;
+import org.apache.axis2.context.externalize.SafeObjectInputStream;
+import org.apache.axis2.context.externalize.SafeObjectOutputStream;
+import org.apache.axis2.context.externalize.SafeSerializable;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.AxisServiceGroup;
 import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.util.MetaDataEntry;
-import org.apache.axis2.util.ObjectStateUtils;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -39,7 +43,8 @@
 import java.util.Iterator;
 import java.util.Map;
 
-public class ServiceGroupContext extends AbstractContext implements Externalizable {
+public class ServiceGroupContext extends AbstractContext 
+    implements Externalizable, SafeSerializable {
 
     /*
      * setup for logging
@@ -67,9 +72,9 @@
      * Refer to the writeExternal() and readExternal() methods.
      */
     // supported revision levels, add a new level to manage compatible changes
-    private static final int REVISION_1 = 1;
+    private static final int REVISION_2 = 2;
     // current revision level of this object
-    private static final int revisionID = REVISION_1;
+    private static final int revisionID = REVISION_2;
 
 
     private transient AxisServiceGroup axisServiceGroup;
@@ -267,7 +272,8 @@
      * @param out The stream to write the object contents to
      * @throws IOException
      */
-    public void writeExternal(ObjectOutput out) throws IOException {
+    public void writeExternal(ObjectOutput o) throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
         // write out contents of this object
 
         //---------------------------------------------------------
@@ -291,38 +297,22 @@
             // generate an ID to use when this object is restored
             id = UUIDGenerator.getUUID();
         }
+        out.writeObject(id);
 
-        ObjectStateUtils.writeString(out, id, "ServiceGroupContext.id");
-
         //---------------------------------------------------------
         // properties
         //---------------------------------------------------------
-        Map tmpMap = getProperties();
+        out.writeMap(getProperties());
 
-        HashMap tmpHashMap = null;
-
-        if ((tmpMap != null) && (!tmpMap.isEmpty())) {
-            tmpHashMap = new HashMap(tmpMap);
-        }
-
-        ObjectStateUtils.writeHashMap(out, tmpHashMap, "ServiceGroupContext.properties");
-
         //---------------------------------------------------------
         // AxisServiceGroup
         //---------------------------------------------------------
-
-        String axisServGrpMarker = "ServiceGroupContext.axisServiceGroup";
-        ObjectStateUtils.writeString(out, axisServGrpMarker, axisServGrpMarker);
-
-        if (axisServiceGroup == null) {
-            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
-        } else {
-            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+        metaAxisServiceGroup = null;
+        if (axisServiceGroup != null) {
             metaAxisServiceGroup = new MetaDataEntry(axisServiceGroup.getClass().getName(),
                                                      axisServiceGroup.getServiceGroupName());
-            ObjectStateUtils.writeObject(out, metaAxisServiceGroup,
-                                         "ServiceGroupContext.metaAxisServiceGroup");
         }
+        out.writeObject(metaAxisServiceGroup);
 
         //---------------------------------------------------------
         // parent 
@@ -348,7 +338,8 @@
      * @throws IOException
      * @throws ClassNotFoundException
      */
-    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+    public void readExternal(ObjectInput inObject) throws IOException, ClassNotFoundException {
+        SafeObjectInputStream in = SafeObjectInputStream.install(inObject);
         // set the flag to indicate that the message context is being
         // reconstituted and will need to have certain object references 
         // to be reconciled with the current engine setup
@@ -368,12 +359,12 @@
 
         // make sure the object data is in a version we can handle
         if (suid != serialVersionUID) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_SUID);
         }
 
         // make sure the object data is in a revision level we can handle
-        if (revID != REVISION_1) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        if (revID != REVISION_2) {
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_REVID);
         }
 
         //---------------------------------------------------------
@@ -382,38 +373,21 @@
 
         long time = in.readLong();
         setLastTouchedTime(time);
+        id = (String) in.readObject();
 
-        id = ObjectStateUtils.readString(in, "ServiceGroupContext.id");
-
         //---------------------------------------------------------
         // properties
         //---------------------------------------------------------
+        properties = in.readHashMap();
 
-        HashMap tmpHashMap = ObjectStateUtils.readHashMap(in, "ServiceGroupContext.properties");
-
-        properties = new HashMap();
-        if (tmpHashMap != null) {
-            setProperties(tmpHashMap);
-        }
-
         //---------------------------------------------------------
         // AxisServiceGroup
         //---------------------------------------------------------
 
         // axisServiceGroup is not usable until the meta data has been reconciled
         axisServiceGroup = null;
+        metaAxisServiceGroup = (MetaDataEntry) in.readObject();
 
-        ObjectStateUtils.readString(in, "ServiceGroupContext.axisServiceGroup");
-
-        boolean metaAxisServiceGrpIsActive = in.readBoolean();
-
-        if (metaAxisServiceGrpIsActive == ObjectStateUtils.ACTIVE_OBJECT) {
-            metaAxisServiceGroup = (MetaDataEntry) ObjectStateUtils
-                    .readObject(in, "ServiceGroupContext.metaAxisServiceGroup");
-        } else {
-            metaAxisServiceGroup = null;
-        }
-
         //---------------------------------------------------------
         // parent 
         //---------------------------------------------------------
@@ -457,9 +431,10 @@
 
         // We previously saved metaAxisServiceGroup; restore it
         if (metaAxisServiceGroup != null) {
-            axisServiceGroup = ObjectStateUtils.findServiceGroup(axisConfig,
-                                                                 metaAxisServiceGroup.getClassName(),
-                                                                 metaAxisServiceGroup.getQNameAsString());
+            axisServiceGroup = 
+                ActivateUtils.findServiceGroup(axisConfig,
+                                               metaAxisServiceGroup.getClassName(),
+                                               metaAxisServiceGroup.getQNameAsString());
         } else {
             axisServiceGroup = null;
         }
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/OperationContext.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/OperationContext.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/OperationContext.java	(working copy)
@@ -22,24 +22,28 @@
 
 import org.apache.axiom.om.util.UUIDGenerator;
 import org.apache.axis2.AxisFault;
+import org.apache.axis2.context.externalize.ActivateUtils;
+import org.apache.axis2.context.externalize.ExternalizeConstants;
+import org.apache.axis2.context.externalize.SafeObjectInputStream;
+import org.apache.axis2.context.externalize.SafeObjectOutputStream;
+import org.apache.axis2.context.externalize.SafeSerializable;
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.axis2.util.MetaDataEntry;
-import org.apache.axis2.util.ObjectStateUtils;
 import org.apache.axis2.wsdl.WSDLConstants.WSDL20_2004_Constants;
 import org.apache.axis2.wsdl.WSDLConstants.WSDL20_2006Constants;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import javax.xml.namespace.QName;
+
 import java.io.Externalizable;
 import java.io.IOException;
 import java.io.ObjectInput;
 import java.io.ObjectOutput;
 import java.util.HashMap;
 import java.util.Iterator;
-import java.util.Map;
 import java.util.Set;
 
 /**
@@ -56,7 +60,8 @@
  * order to support another MEP one must extend this class and register its
  * creation in the OperationContexFactory.
  */
-public class OperationContext extends AbstractContext implements Externalizable {
+public class OperationContext extends AbstractContext 
+    implements Externalizable, SafeSerializable {
 
     /*
      * setup for logging
@@ -71,7 +76,7 @@
      * An ID which can be used to correlate operations on an instance of
      * this object in the log files
      */
-    private String logCorrelationIDString = myClassName + "@" + UUIDGenerator.getUUID();
+    private String logCorrelationIDString = null;
 
 
     /**
@@ -93,9 +98,9 @@
      * Refer to the writeExternal() and readExternal() methods.
      */
     // supported revision levels, add a new level to manage compatible changes
-    private static final int REVISION_1 = 1;
+    private static final int REVISION_2 = 2;
     // current revision level of this object
-    private static final int revisionID = REVISION_1;
+    private static final int revisionID = REVISION_2;
 
 
     /**
@@ -240,7 +245,7 @@
      */
     public AxisOperation getAxisOperation() {
         if (needsToBeReconciled && !suppressWarnings && debugEnabled) {
-            log.debug(logCorrelationIDString +
+            log.debug(getLogCorrelationIDString() +
                     ":getAxisOperation(): ****WARNING**** OperationContext.activate(configurationContext) needs to be invoked.");
         }
 
@@ -341,7 +346,8 @@
      * @param out The stream to write the object contents to
      * @throws IOException
      */
-    public void writeExternal(ObjectOutput out) throws IOException {
+    public void writeExternal(ObjectOutput o) throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
         //---------------------------------------------------------
         // in order to handle future changes to the message
         // context definition, be sure to maintain the
@@ -360,67 +366,47 @@
         out.writeLong(getLastTouchedTime());
 
         out.writeBoolean(isComplete);
+        out.writeObject(key);
+        out.writeObject(logCorrelationIDString);
 
-        ObjectStateUtils.writeString(out, key, logCorrelationIDString + ".key");
-
-        ObjectStateUtils.writeString(out, logCorrelationIDString,
-                                     logCorrelationIDString + ".logCorrelationIDString");
-
         //---------------------------------------------------------
         // properties
         //---------------------------------------------------------
-        Map tmpMap = getProperties();
+        out.writeUTF("properties");  // write marker
+        out.writeMap(getProperties());
 
-        HashMap tmpHashMap = null;
-
-        if ((tmpMap != null) && (!tmpMap.isEmpty())) {
-            tmpHashMap = new HashMap(tmpMap);
-        }
-
-        ObjectStateUtils.writeHashMap(out, tmpHashMap, logCorrelationIDString + ".properties");
-
         //---------------------------------------------------------
         // AxisOperation axisOperation
         //---------------------------------------------------------
-        String axisOpMarker = logCorrelationIDString + ".axisOperation";
-        ObjectStateUtils.writeString(out, axisOpMarker, axisOpMarker);
-
-        if (axisOperation == null) {
-            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
-        } else {
-            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+        out.writeUTF("metaAxisOperation"); // write marker
+        metaAxisOperation = null;
+        if (axisOperation != null) {
             metaAxisOperation = new MetaDataEntry(axisOperation.getClass().getName(),
                                                   axisOperation.getName().toString());
-            ObjectStateUtils.writeObject(out, metaAxisOperation,
-                                         logCorrelationIDString + ".metaAxisOperation");
         }
+        out.writeObject(metaAxisOperation);
 
+        //---------------------------------------------------------
+        // AxisOperation axisService
+        //---------------------------------------------------------
         // save the meta data for the corresponding axis service to better
         // match up the axis operation
-
-        String axisServMarker = logCorrelationIDString + ".metaAxisService";
-        ObjectStateUtils.writeString(out, axisServMarker, axisServMarker);
-
+        out.writeUTF("metaAxisService"); // write marker
+        metaAxisService = null;
         AxisService axisService = axisOperation.getAxisService();
 
-        if (axisService == null) {
-            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
-        } else {
-            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+        if (axisService != null) {
             metaAxisService =
                     new MetaDataEntry(axisService.getClass().getName(), axisService.getName());
-            ObjectStateUtils
-                    .writeObject(out, metaAxisService, logCorrelationIDString + ".metaAxisService");
         }
+        out.writeObject(metaAxisService);
 
         //---------------------------------------------------------
         // parent
         //---------------------------------------------------------
-        ServiceContext myParent = this.getServiceContext();
+        out.writeUTF("parent"); // write marker
+        out.writeObject(this.getServiceContext());
 
-        ObjectStateUtils
-                .writeObject(out, myParent, logCorrelationIDString + ".parent ServiceContext");
-
         //---------------------------------------------------------
         // HashMap messageContexts table
         //---------------------------------------------------------
@@ -490,30 +476,33 @@
                 String keyObj2 = (String) itKeys2.next();
 
                 // get the message context associated with that label
-                MessageContext value2 = (MessageContext) workingSet.get(keyObj2);
+                MessageContext mc = (MessageContext) workingSet.get(keyObj2);
 
                 // construct a copy of the message context
                 // that has been extracted from the object hierarchy
-                MessageContext modifiedValue2 = value2.extractCopyMessageContext();
+                MessageContext copyMC = mc.extractCopyMessageContext();
+                
+                // Don't persist the message of the other message contexts
+                copyMC.setEnvelope(null);
 
                 // put the modified entry in the list
-                tmpMsgCtxMap.put(keyObj2, modifiedValue2);
+                tmpMsgCtxMap.put(keyObj2, copyMC);
 
                 // trace point
-                log.trace(logCorrelationIDString +
-                        ":writeExternal():  getting working set entry  key [" + keyObj2 +
-                        "]   message context ID[" + modifiedValue2.getMessageID() + "]");
+                if (log.isTraceEnabled()) {
+                    log.trace(getLogCorrelationIDString() +
+                              ":writeExternal():  getting working set entry  key [" + keyObj2 +
+                              "]   message context ID[" + copyMC.getMessageID() + "]");
+                }
             }
 
         }
 
-        ObjectStateUtils.writeHashMap(out, tmpMsgCtxMap,
-                                      logCorrelationIDString + ".messageContexts working set");
+        out.writeUTF("messagecontexts"); // write marker
+        out.writeMap(tmpMsgCtxMap);
+        out.writeUTF("metaMessageContextMap");
+        out.writeMap(metaMessageContextMap);
 
-        // next, deal with the metadata table of messageContexts
-        ObjectStateUtils.writeHashMap(out, metaMessageContextMap, logCorrelationIDString +
-                ".metaMessageContextMap metadata table");
-
         //---------------------------------------------------------
         // done
         //---------------------------------------------------------
@@ -532,7 +521,8 @@
      * @throws IOException
      * @throws ClassNotFoundException
      */
-    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+    public void readExternal(ObjectInput inObject) throws IOException, ClassNotFoundException {
+        SafeObjectInputStream in = SafeObjectInputStream.install(inObject);
         // set the flag to indicate that the message context is being
         // reconstituted and will need to have certain object references
         // to be reconciled with the current engine setup
@@ -554,12 +544,12 @@
 
         // make sure the object data is in a version we can handle
         if (suid != serialVersionUID) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_SUID);
         }
 
         // make sure the object data is in a revision level we can handle
-        if (revID != REVISION_1) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        if (revID != REVISION_2) {
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_REVID);
         }
 
         //---------------------------------------------------------
@@ -570,85 +560,58 @@
         setLastTouchedTime(time);
 
         isComplete = in.readBoolean();
-
-        key = ObjectStateUtils.readString(in, "OperationContext.key");
-
-        logCorrelationIDString =
-                ObjectStateUtils.readString(in, "OperationContext.logCorrelationIDString");
-
+        key = (String) in.readObject();
+        logCorrelationIDString = (String) in.readObject();
+       
         // trace point
-        log.trace(myClassName + ":readExternal():  reading input stream for [" +
-                logCorrelationIDString + "]  ");
+        if (log.isTraceEnabled()) {
+            log.trace(myClassName + ":readExternal():  reading input stream for [" +
+                      getLogCorrelationIDString() + "]  ");
+        }
 
         //---------------------------------------------------------
         // properties
         //---------------------------------------------------------
+        in.readUTF(); // read marker
+        properties = in.readHashMap();
 
-        HashMap tmpHashMap = ObjectStateUtils.readHashMap(in, "OperationContext.properties");
-
-        properties = new HashMap();
-        if (tmpHashMap != null) {
-            setProperties(tmpHashMap);
-        }
-
         //---------------------------------------------------------
         // axis operation meta data
         //---------------------------------------------------------
 
         // axisOperation is not usable until the meta data has been reconciled
         axisOperation = null;
+        in.readUTF(); // read marker
+        metaAxisOperation = (MetaDataEntry) in.readObject();
 
-        ObjectStateUtils.readString(in, "OperationContext.axisOperation");
-
-        boolean metaAxisOperationIsActive = in.readBoolean();
-
-        if (metaAxisOperationIsActive == ObjectStateUtils.ACTIVE_OBJECT) {
-            metaAxisOperation = (MetaDataEntry) ObjectStateUtils
-                    .readObject(in, "OperationContext.metaAxisOperation");
-        } else {
-            metaAxisOperation = null;
-        }
-
+        //---------------------------------------------------------
+        // axis service meta data
+        //---------------------------------------------------------
         // axisService is not usable until the meta data has been reconciled
+        in.readUTF(); // read marker
+        metaAxisService = (MetaDataEntry) in.readObject();
 
-        ObjectStateUtils.readString(in, "OperationContext.axisService");
-
-        boolean metaAxisServiceIsActive = in.readBoolean();
-
-        if (metaAxisServiceIsActive == ObjectStateUtils.ACTIVE_OBJECT) {
-            metaAxisService = (MetaDataEntry) ObjectStateUtils
-                    .readObject(in, "OperationContext.metaAxisService");
-        } else {
-            metaAxisService = null;
-        }
-
         //---------------------------------------------------------
         // parent
         //---------------------------------------------------------
-
         // ServiceContext is not usable until it has been activated
+        in.readUTF(); // read marker
+        metaParent = (ServiceContext) in.readObject();
 
-        metaParent = (ServiceContext) ObjectStateUtils
-                .readObject(in, "OperationContext.parent ServiceContext");
-
         //---------------------------------------------------------
         // HashMap messageContexts table
         //---------------------------------------------------------
 
         // set to empty until this can be activiated
         messageContexts = new HashMap();
-
-        workingSet = ObjectStateUtils
-                .readHashMap(in, logCorrelationIDString + ".messageContexts working set");
-
-        metaMessageContextMap = ObjectStateUtils
-                .readHashMap(in, logCorrelationIDString + ".metaMessageContextMap metadata table");
-
+        in.readUTF(); // read marker
+        workingSet = in.readHashMap();
+        in.readUTF(); // read marker
+        metaMessageContextMap = in.readHashMap();
+        
         //---------------------------------------------------------
         // done
         //---------------------------------------------------------
-
-
     }
 
 
@@ -677,18 +640,18 @@
         AxisService axisService = null;
 
         if (metaAxisService != null) {
-            axisService = ObjectStateUtils.findService(axisConfig, metaAxisService.getClassName(),
+            axisService = ActivateUtils.findService(axisConfig, metaAxisService.getClassName(),
                                                        metaAxisService.getQNameAsString());
         }
 
         // We previously saved metaAxisOperation; restore it
         if (metaAxisOperation != null) {
             if (axisService != null) {
-                this.axisOperation = ObjectStateUtils.findOperation(axisService,
+                this.axisOperation = ActivateUtils.findOperation(axisService,
                                                                     metaAxisOperation.getClassName(),
                                                                     metaAxisOperation.getQName());
             } else {
-                this.axisOperation = ObjectStateUtils.findOperation(axisConfig,
+                this.axisOperation = ActivateUtils.findOperation(axisConfig,
                                                                     metaAxisOperation.getClassName(),
                                                                     metaAxisOperation.getQName());
             }
@@ -776,9 +739,13 @@
                 boolean registrationSuceeded = activeCC.registerOperationContext(key, this, true);
                 if (!registrationSuceeded) {
                     // trace point
-                    log.trace(logCorrelationIDString + ":activate():  OperationContext key [" + key
-                              + "] already exists in ConfigurationContext map.  This OperationContext ["
+                    if (log.isTraceEnabled()) {
+                        log.trace(getLogCorrelationIDString()+ ":activate():  " +
+                                        "OperationContext key [" + key
+                              + "] already exists in ConfigurationContext map.  " +
+                                        "This OperationContext ["
                               + this.toString() + "] was not added to the table.");
+                    }
                 }
             }
         }
@@ -805,8 +772,10 @@
                 // activate that object
                 if (value != null) {
                     // trace point
-                    log.trace(logCorrelationIDString + ":activate():  key [" + keyObj +
+                    if (log.isTraceEnabled()) {
+                        log.trace(getLogCorrelationIDString() + ":activate():  key [" + keyObj +
                             "]  message id [" + value.getMessageID() + "]");
+                    }
 
                     suppressWarnings = true;
                     value.activateWithOperationContext(this);
@@ -910,10 +879,12 @@
                     isolatedMessageContexts.put(keyObj, value);
 
                     // trace point
-                    log.trace(logCorrelationIDString +
+                    if (log.isTraceEnabled()) {
+                        log.trace(getLogCorrelationIDString() +
                             ":isolateMessageContext():  set up message context id[" + valueID +
                             "]  with key [" + keyObj.toString() +
                             "] from messageContexts table to prepare for serialization.");
+                    }
 
                     break;
                 }
@@ -934,7 +905,7 @@
         if (needsToBeReconciled) {
             // nope, need to do the activation first
             if (debugEnabled) {
-                log.debug(logCorrelationIDString +
+                log.debug(getLogCorrelationIDString() +
                           ":restoreMessageContext(): *** WARNING : need to invoke activate() prior to restoring the MessageContext to the list.");
             }
 
@@ -950,7 +921,7 @@
         if (msgID == null) {
             if (debugEnabled) {
                 // can't identify message context
-                log.debug(logCorrelationIDString +
+                log.debug(getLogCorrelationIDString() +
                         ":restoreMessageContext(): *** WARNING : MessageContext does not have a message ID.");
             }
             return;
@@ -985,9 +956,11 @@
                         // remove the metadata from the metadata table
                         metaMessageContextMap.remove(keyM);
 
-                        log.trace(logCorrelationIDString +
+                        if (log.isTraceEnabled()) {
+                            log.trace(getLogCorrelationIDString() +
                                 ":restoreMessageContext():  restored   label [" + label +
                                 "]    message ID [" + msg.getMessageID() + "]");
+                        }
 
                         break;
                     }
@@ -1121,6 +1094,9 @@
      *         entries.
      */
     public String getLogCorrelationIDString() {
+        if (logCorrelationIDString == null) {
+            logCorrelationIDString = myClassName + "@" + UUIDGenerator.getUUID();
+        }
         return logCorrelationIDString;
     }
 
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/ServiceContext.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/ServiceContext.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/ServiceContext.java	(working copy)
@@ -23,6 +23,11 @@
 import org.apache.axiom.om.util.UUIDGenerator;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.context.externalize.ActivateUtils;
+import org.apache.axis2.context.externalize.ExternalizeConstants;
+import org.apache.axis2.context.externalize.SafeObjectInputStream;
+import org.apache.axis2.context.externalize.SafeObjectOutputStream;
+import org.apache.axis2.context.externalize.SafeSerializable;
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.TransportInDescription;
@@ -31,23 +36,23 @@
 import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.util.LoggingControl;
 import org.apache.axis2.util.MetaDataEntry;
-import org.apache.axis2.util.ObjectStateUtils;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import javax.xml.namespace.QName;
+
 import java.io.Externalizable;
 import java.io.IOException;
 import java.io.ObjectInput;
 import java.io.ObjectOutput;
-import java.util.HashMap;
 import java.util.Map;
 
 /**
  * Well this is never clearly defined, what it does or the life-cycle.
  * So do NOT use this as it might not live up to your expectation.
  */
-public class ServiceContext extends AbstractContext implements Externalizable {
+public class ServiceContext extends AbstractContext 
+    implements Externalizable, SafeSerializable {
 
     /*
      * setup for logging
@@ -60,7 +65,7 @@
      * An ID which can be used to correlate operations on an instance of
      * this object in the log files
      */
-    private String logCorrelationIDString = myClassName + "@" + UUIDGenerator.getUUID();
+    private String logCorrelationIDString = null;
 
 
     /**
@@ -82,9 +87,9 @@
      * Refer to the writeExternal() and readExternal() methods.
      */
     // supported revision levels, add a new level to manage compatible changes
-    private static final int REVISION_1 = 1;
+    private static final int REVISION_2 = 2;
     // current revision level of this object
-    private static final int revisionID = REVISION_1;
+    private static final int revisionID = REVISION_2;
 
 
     public static final String SERVICE_OBJECT = "serviceObject";
@@ -313,7 +318,8 @@
      * @param out The stream to write the object contents to
      * @throws IOException
      */
-    public void writeExternal(ObjectOutput out) throws IOException {
+    public void writeExternal(ObjectOutput o) throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
         //---------------------------------------------------------
         // in order to handle future changes to the message 
         // context definition, be sure to maintain the 
@@ -330,75 +336,34 @@
         //---------------------------------------------------------
 
         out.writeLong(getLastTouchedTime());
-
         out.writeBoolean(cachingOperationContext);
+        out.writeObject(getLogCorrelationIDString());
 
-        ObjectStateUtils.writeString(out, logCorrelationIDString,
-                                     logCorrelationIDString + ".logCorrelationIDString");
-
-        // put some try..catch blocks around the following objects
-        // so that the writing to the output stream continues
-        // even if one of the objects can't be serialized
-
-        try {
-            // EndpointReference targetEPR
-            ObjectStateUtils.writeObject(out, targetEPR, "ServiceContext.targetEPR");
-        }
-        catch (Exception e1) {
-            // note that the utility class will provide the trace for the 
-            // exception so we won't have to
-            // so just consume the exception for now
-        }
-
-
-        try {
-            // EndpointReference myEPR
-            ObjectStateUtils.writeObject(out, myEPR, "ServiceContext.myEPR");
-        }
-        catch (Exception e2) {
-            // note that the utility class will provide the trace for the 
-            // exception so we won't have to
-            // so just consume the exception for now
-        }
-
+        // EndpointReference targetEPR
+        out.writeObject(targetEPR);
+       
+        // EndpointReference myEPR
+        out.writeObject(myEPR);
+        
         //---------------------------------------------------------
         // properties
         //---------------------------------------------------------
-        Map tmpMap = getProperties();
-
-        HashMap tmpHashMap = null;
-
-        if ((tmpMap != null) && (!tmpMap.isEmpty())) {
-            tmpHashMap = new HashMap(tmpMap);
-        }
-
-        ObjectStateUtils.writeHashMap(out, tmpHashMap, "ServiceContext.properties");
-
+        out.writeMap(getProperties());
+        
         //---------------------------------------------------------
         // AxisService
         //---------------------------------------------------------
-
-        String axisServMarker = "ServiceContext.metaAxisService";
-        ObjectStateUtils.writeString(out, axisServMarker, axisServMarker);
-
-        if (axisService == null) {
-            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
-        } else {
-            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+        metaAxisService = null;
+        if (axisService != null) {
             metaAxisService =
                     new MetaDataEntry(axisService.getClass().getName(), axisService.getName());
-            ObjectStateUtils.writeObject(out, metaAxisService, "ServiceContext.metaAxisService");
         }
+        out.writeObject(metaAxisService);
 
         //---------------------------------------------------------
         // parent 
         //---------------------------------------------------------
-        // ServiceGroupContext serviceGroupContext;
-
-        ServiceGroupContext myParent = (ServiceGroupContext) getParent();
-
-        ObjectStateUtils.writeObject(out, myParent, "ServiceContext.parent ServiceGroupContext");
-
+        out.writeObject(getParent());
     }
 
 
@@ -413,7 +378,8 @@
      * @throws IOException
      * @throws ClassNotFoundException
      */
-    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+    public void readExternal(ObjectInput inObject) throws IOException, ClassNotFoundException {
+        SafeObjectInputStream in = SafeObjectInputStream.install(inObject);
         // set the flag to indicate that the message context is being
         // reconstituted and will need to have certain object references 
         // to be reconciled with the current engine setup
@@ -437,12 +403,12 @@
 
         // make sure the object data is in a version we can handle
         if (suid != serialVersionUID) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_SUID);
         }
 
         // make sure the object data is in a revision level we can handle
-        if (revID != REVISION_1) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        if (revID != REVISION_2) {
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_REVID);
         }
 
         //---------------------------------------------------------
@@ -451,61 +417,40 @@
 
         long time = in.readLong();
         setLastTouchedTime(time);
-
         cachingOperationContext = in.readBoolean();
+        logCorrelationIDString = (String) in.readObject();
 
-        logCorrelationIDString =
-                ObjectStateUtils.readString(in, myClassName + ".logCorrelationIDString");
-
         // trace point
         if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
             log.trace(myClassName + ":readExternal():  reading input stream for [" +
-                logCorrelationIDString + "]  ");
+                      getLogCorrelationIDString()+ "]  ");
         }
 
         // EndpointReference targetEPR
-        targetEPR = (EndpointReference) ObjectStateUtils.readObject(in, "ServiceContext.targetEPR");
+        targetEPR = (EndpointReference) in.readObject();
 
         // EndpointReference myEPR
-        myEPR = (EndpointReference) ObjectStateUtils.readObject(in, "ServiceContext.myEPR");
+        myEPR = (EndpointReference) in.readObject();
 
         //---------------------------------------------------------
         // properties
         //---------------------------------------------------------
+        properties = in.readHashMap();
 
-        HashMap tmpHashMap = ObjectStateUtils.readHashMap(in, "ServiceContext.properties");
-
-        properties = new HashMap();
-        if (tmpHashMap != null) {
-            setProperties(tmpHashMap);
-        }
-
         //---------------------------------------------------------
         // AxisService
         //---------------------------------------------------------
 
         // axisService is not usable until the meta data has been reconciled
+        metaAxisService = (MetaDataEntry) in.readObject();
 
-        ObjectStateUtils.readString(in, "ServiceContext.axisService");
-
-        boolean metaAxisServiceIsActive = in.readBoolean();
-
-        if (metaAxisServiceIsActive == ObjectStateUtils.ACTIVE_OBJECT) {
-            metaAxisService = (MetaDataEntry) ObjectStateUtils
-                    .readObject(in, "ServiceContext.metaAxisService");
-        } else {
-            metaAxisService = null;
-        }
-
         //---------------------------------------------------------
         // parent 
         //---------------------------------------------------------
 
         // ServiceGroupContext is not usable until it has been activated 
+        metaParent = (ServiceGroupContext) in.readObject();
 
-        metaParent = (ServiceGroupContext) ObjectStateUtils
-                .readObject(in, "ServiceContext.parent ServiceGroupContext");
-
         //---------------------------------------------------------
         // other
         //---------------------------------------------------------
@@ -547,7 +492,7 @@
         axisService = null;
 
         if (metaAxisService != null) {
-            axisService = ObjectStateUtils.findService(axisConfig, metaAxisService.getClassName(),
+            axisService = ActivateUtils.findService(axisConfig, metaAxisService.getClassName(),
                                                        metaAxisService.getQNameAsString());
         }
 
@@ -714,6 +659,9 @@
      *         entries.
      */
     public String getLogCorrelationIDString() {
+        if (logCorrelationIDString == null) {
+            logCorrelationIDString = myClassName + "@" + UUIDGenerator.getUUID();
+        }
         return logCorrelationIDString;
     }
 
@@ -727,7 +675,7 @@
     private void checkActivateWarning(String methodname) {
         if (needsToBeReconciled) {
             if (LoggingControl.debugLoggingAllowed && log.isDebugEnabled()) {
-                log.debug(logCorrelationIDString + ":" + methodname + "(): ****WARNING**** "
+                log.debug(getLogCorrelationIDString()+ ":" + methodname + "(): ****WARNING**** "
                         + myClassName + ".activate(configurationContext) needs to be invoked.");
             }
         }
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/SessionContext.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/SessionContext.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/SessionContext.java	(working copy)
@@ -21,10 +21,13 @@
 package org.apache.axis2.context;
 
 import org.apache.axis2.AxisFault;
+import org.apache.axis2.context.externalize.ExternalizeConstants;
+import org.apache.axis2.context.externalize.SafeObjectInputStream;
+import org.apache.axis2.context.externalize.SafeObjectOutputStream;
+import org.apache.axis2.context.externalize.SafeSerializable;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.axis2.engine.DependencyManager;
-import org.apache.axis2.util.ObjectStateUtils;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -35,13 +38,13 @@
 import java.util.Date;
 import java.util.HashMap;
 import java.util.Iterator;
-import java.util.Map;
 
 /**
  * All the engine components are stateless across the executions and all the states should be kept in the
  * Contexts, there are three context Global, Session and Message.
  */
-public class SessionContext extends AbstractContext implements Externalizable {
+public class SessionContext extends AbstractContext 
+    implements Externalizable, SafeSerializable {
 
     /**
      * @serial The serialization version ID tracks the version of the class.
@@ -62,9 +65,9 @@
      * Refer to the writeExternal() and readExternal() methods.
      */
     // supported revision levels, add a new level to manage compatible changes
-    private static final int REVISION_1 = 1;
+    private static final int REVISION_2 = 2;
     // current revision level of this object
-    private static final int revisionID = REVISION_1;
+    private static final int revisionID = REVISION_2;
 
 
     // TODO: investigate whether these collections need to be saved
@@ -180,7 +183,8 @@
      * @param out The stream to write the object contents to
      * @throws IOException
      */
-    public void writeExternal(ObjectOutput out) throws IOException {
+    public void writeExternal(ObjectOutput o) throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
         // write out contents of this object
 
         // NOTES: For each item, where appropriate,
@@ -207,30 +211,18 @@
         out.writeLong(getLastTouchedTime());
 
         out.writeLong(sessionContextTimeoutInterval);
+        out.writeObject(cookieID);
 
-        ObjectStateUtils.writeString(out, cookieID, "SessionContext.cookieID");
-
         //---------------------------------------------------------
         // properties
         //---------------------------------------------------------
-        Map tmpMap = getProperties();
+        out.writeMap(getProperties());
 
-        HashMap tmpHashMap = null;
-
-        if ((tmpMap != null) && (!tmpMap.isEmpty())) {
-            tmpHashMap = new HashMap(tmpMap);
-        }
-
-        ObjectStateUtils.writeHashMap(out, tmpHashMap, "SessionContext.properties");
-
         //---------------------------------------------------------
         // "nested"
         //---------------------------------------------------------
+        out.writeObject(parent);
 
-        // Options parent
-        ObjectStateUtils.writeObject(out, parent, "SessionContext.parent");
-
-
     }
 
 
@@ -246,7 +238,8 @@
      * @throws IOException
      * @throws ClassNotFoundException
      */
-    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+    public void readExternal(ObjectInput inObject) throws IOException, ClassNotFoundException {
+        SafeObjectInputStream in = SafeObjectInputStream.install(inObject);
         // trace point
         if (log.isTraceEnabled()) {
             log.trace(myClassName + ":readExternal():  BEGIN  bytes available in stream [" +
@@ -261,12 +254,12 @@
 
         // make sure the object data is in a version we can handle
         if (suid != serialVersionUID) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_SUID);
         }
 
         // make sure the object data is in a revision level we can handle
-        if (revID != REVISION_1) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        if (revID != REVISION_2) {
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_REVID);
         }
 
         //---------------------------------------------------------
@@ -276,33 +269,20 @@
         setLastTouchedTime(time);
 
         sessionContextTimeoutInterval = in.readLong();
+        cookieID = (String) in.readObject();
 
-        cookieID = ObjectStateUtils.readString(in, "SessionContext.cookieID");
-
         //---------------------------------------------------------
         // properties
         //---------------------------------------------------------
+        properties = in.readHashMap();
 
-        HashMap tmpHashMap = ObjectStateUtils.readHashMap(in, "SessionContext.properties");
-
-        properties = new HashMap();
-        if (tmpHashMap != null) {
-            setProperties(tmpHashMap);
-        }
-
         //---------------------------------------------------------
         // "nested"
         //---------------------------------------------------------
 
         // parent
-        Object tmpParent = ObjectStateUtils.readObject(in, "SessionContext.parent");
+        parent = (AbstractContext) in.readObject();
 
-        if (tmpParent != null) {
-            parent = (AbstractContext) tmpParent;
-        } else {
-            parent = null;
-        }
-
         //---------------------------------------------------------
         // done
         //---------------------------------------------------------
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/MessageContext.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/MessageContext.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/MessageContext.java	(working copy)
@@ -30,6 +30,12 @@
 import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.addressing.RelatesTo;
 import org.apache.axis2.client.Options;
+import org.apache.axis2.context.externalize.ActivateUtils;
+import org.apache.axis2.context.externalize.ExternalizeConstants;
+import org.apache.axis2.context.externalize.MessageExternalizeUtils;
+import org.apache.axis2.context.externalize.SafeObjectInputStream;
+import org.apache.axis2.context.externalize.SafeObjectOutputStream;
+import org.apache.axis2.context.externalize.SafeSerializable;
 import org.apache.axis2.description.AxisMessage;
 import org.apache.axis2.description.AxisModule;
 import org.apache.axis2.description.AxisOperation;
@@ -46,9 +52,7 @@
 import org.apache.axis2.engine.Phase;
 import org.apache.axis2.util.JavaUtils;
 import org.apache.axis2.util.LoggingControl;
-import org.apache.axis2.util.MessageExternalizeUtils;
 import org.apache.axis2.util.MetaDataEntry;
-import org.apache.axis2.util.ObjectStateUtils;
 import org.apache.axis2.util.SelfManagedDataHolder;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -90,7 +94,8 @@
  *  options). You may set them at any level of context hierarchy and they will 
  *  affect invocations related to their child elements. </p>
  */
-public class MessageContext extends AbstractContext implements Externalizable {
+public class MessageContext extends AbstractContext 
+    implements Externalizable, SafeSerializable {
 
     /*
      * setup for logging
@@ -131,9 +136,9 @@
      * Refer to the writeExternal() and readExternal() methods.
      */
     // supported revision levels, add a new level to manage compatible changes
-    private static final int REVISION_1 = 1;
+    private static final int REVISION_2 = 2;
     // current revision level of this object
-    private static final int revisionID = REVISION_1;
+    private static final int revisionID = REVISION_2;
 
 
     /**
@@ -1829,7 +1834,7 @@
                     || (executionChain == null)
                     || (selfManagedDataMap.size() == 0)
                     || (executionChain.size() == 0)) {
-                out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+                out.writeBoolean(ExternalizeConstants.EMPTY_OBJECT);
 
                 if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
                     log.trace(getLogIDString() + ":serializeSelfManagedData(): No data : END");
@@ -1845,7 +1850,7 @@
             ArrayList selfManagedDataHolderList = serializeSelfManagedDataHelper(flatExecChain);
 
             if (selfManagedDataHolderList.size() == 0) {
-                out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+                out.writeBoolean(ExternalizeConstants.EMPTY_OBJECT);
 
                 if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
                     log.trace(getLogIDString() + ":serializeSelfManagedData(): No data : END");
@@ -1854,7 +1859,7 @@
                 return;
             }
 
-            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+            out.writeBoolean(ExternalizeConstants.ACTIVE_OBJECT);
 
             // SelfManagedData can be binary so won't be able to treat it as a
             // string - need to treat it as a byte []
@@ -2069,7 +2074,8 @@
      * @param out The stream to write the object contents to
      * @throws IOException
      */
-    public void writeExternal(ObjectOutput out) throws IOException {
+    public void writeExternal(ObjectOutput o) throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
         String logCorrelationIDString = getLogIDString();
 
         if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
@@ -2107,9 +2113,8 @@
         out.writeBoolean(serverSide);
 
         out.writeLong(getLastTouchedTime());
+        out.writeObject(getLogCorrelationID());
 
-        ObjectStateUtils.writeString(out, this.getLogCorrelationID(), "logCorrelationID");
-
         //-----------------------------------------------------------------------
         // Create and initialize the OMOutputFormat for Message Externalization
         //-----------------------------------------------------------------------
@@ -2164,21 +2169,13 @@
         //    UTF          - description string
         //    boolean      - empty flag
         //---------------------------------------------------------
-        String execChainDesc = logCorrelationIDString + ".executionChain";
-
-        int listSize = 0;
-
-        if (executionChain != null) {
-            listSize = executionChain.size();
-        }
-
-        if (listSize > 0) {
+        out.writeUTF("executionChain");
+        if (executionChain != null && executionChain.size() > 0) {
             // start writing data to the output stream
-            out.writeUTF(execChainDesc);
-            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+            out.writeBoolean(ExternalizeConstants.ACTIVE_OBJECT);
             out.writeInt(currentHandlerIndex);
             out.writeInt(currentPhaseIndex);
-            out.writeInt(listSize);
+            out.writeInt(executionChain.size());
 
             // put the metadata on each member of the list into a buffer
 
@@ -2221,9 +2218,7 @@
                             objClass + "] qname [" + qnameAsString + "]");
                 }
 
-                ObjectStateUtils.writeObject(out, mdEntry, logCorrelationIDString +
-                        ".executionChain:entry class [" + objClass + "] qname [" + qnameAsString +
-                        "]");
+                out.writeObject(mdEntry);
 
                 // update the index so that the index
                 // now indicates the next entry that
@@ -2243,8 +2238,7 @@
             MetaDataEntry lastEntry = new MetaDataEntry();
             lastEntry.setClassName(MetaDataEntry.END_OF_LIST);
 
-            ObjectStateUtils.writeObject(out, lastEntry,
-                                         logCorrelationIDString + ".executionChain:  last entry ");
+            out.writeObject(lastEntry);
             nextIndex++;
 
             // nextIndex also gives us the number of entries
@@ -2254,10 +2248,8 @@
 
         } else {
             // general case: handle "null" or "empty"
+            out.writeBoolean(ExternalizeConstants.EMPTY_OBJECT);
 
-            out.writeUTF(execChainDesc);
-            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
-
             if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
                 log.trace(logCorrelationIDString + ":writeExternal(): executionChain is NULL");
             }
@@ -2286,19 +2278,12 @@
         //    UTF          - description string
         //    boolean      - empty flag
         //---------------------------------------------------------
-        String execListDesc = logCorrelationIDString + ".executedPhases";
-
-        int execListSize = 0;
-
-        if (executedPhases != null) {
-            execListSize = executedPhases.size();
-        }
-
-        if (execListSize > 0) {
+        out.writeUTF("executedPhases");
+        if (executedPhases != null && executedPhases.size() > 0) {
+        
             // start writing data to the output stream
-            out.writeUTF(execListDesc);
-            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
-            out.writeInt(execListSize);
+            out.writeBoolean(ExternalizeConstants.ACTIVE_OBJECT);
+            out.writeInt(executedPhases.size());
 
             // put the metadata on each member of the list into a buffer
 
@@ -2338,9 +2323,7 @@
                             objClass + "] qname [" + qnameAsString + "]");
                 }
 
-                ObjectStateUtils.writeObject(out, mdEntry, logCorrelationIDString +
-                        ".executedPhases:entry class [" + objClass + "] qname [" +
-                        qnameAsString + "]");
+                out.writeObject(mdEntry);
 
                 // update the index so that the index
                 // now indicates the next entry that
@@ -2360,8 +2343,7 @@
             MetaDataEntry lastEntry = new MetaDataEntry();
             lastEntry.setClassName(MetaDataEntry.END_OF_LIST);
 
-            ObjectStateUtils.writeObject(out, lastEntry, logCorrelationIDString +
-                    ".executedPhases:  last entry ");
+            out.writeObject(lastEntry);
             execNextIndex++;
 
             // execNextIndex also gives us the number of entries
@@ -2371,10 +2353,8 @@
 
         } else {
             // general case: handle "null" or "empty"
+            out.writeBoolean(ExternalizeConstants.EMPTY_OBJECT);
 
-            out.writeUTF(execListDesc);
-            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
-
             if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
                 log.trace(
                         logCorrelationIDString + ":writeExternal(): executedPhases is NULL");
@@ -2396,38 +2376,31 @@
             log.trace(logCorrelationIDString + ":writeExternal():   message ID [" + tmpID + "]");
         }
 
-        ObjectStateUtils.writeObject(out, options, logCorrelationIDString + ".options   for  [" +
-                options.getLogCorrelationIDString() + "]");
-
+        out.writeUTF("options");
+        out.writeObject(options);
+        
         //---------------------------------------------------------
         // operation
         //---------------------------------------------------------
         // axis operation
         //---------------------------------------------------------
-        String axisOpMarker = logCorrelationIDString + ".axisOperation";
-        ObjectStateUtils.writeString(out, axisOpMarker, axisOpMarker);
-
-        if (axisOperation == null) {
-            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
-        } else {
+        out.writeUTF("axisOperation");
+        metaAxisOperation = null;
+        if (axisOperation != null) {
             // TODO: may need to include the meta data for the axis service that is
             //       the parent of the axis operation
-
-            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
-
             // make sure the axis operation has a name associated with it
             QName aoTmpQName = axisOperation.getName();
 
             if (aoTmpQName == null) {
-                aoTmpQName = new QName(ObjectStateUtils.EMPTY_MARKER);
+                aoTmpQName = new QName(ExternalizeConstants.EMPTY_MARKER);
                 axisOperation.setName(aoTmpQName);
             }
 
             metaAxisOperation = new MetaDataEntry(axisOperation.getClass().getName(),
                                                   axisOperation.getName().toString());
-            ObjectStateUtils.writeObject(out, metaAxisOperation,
-                                         logCorrelationIDString + ".metaAxisOperation");
         }
+        out.writeObject(metaAxisOperation);
 
         //---------------------------------------------------------
         // operation context
@@ -2436,14 +2409,13 @@
         // In order to avoid having multiple copies of the object graph
         // being saved at different points in the serialization,
         // it is important to isolate this message context object.
-        String oc_desc = logCorrelationIDString + ".operationContext";
+        out.writeUTF("operationContext");
         if (operationContext != null) {
             operationContext.isolateMessageContext(this);
-            oc_desc = oc_desc + "  for  [" + operationContext.getLogCorrelationIDString() + "]";
         }
 
-        // NOTE: expect this to be the parent of the message context
-        ObjectStateUtils.writeObject(out, operationContext, oc_desc);
+        out.writeObject(operationContext);
+   
 
         //---------------------------------------------------------
         // service
@@ -2451,30 +2423,25 @@
         // axis service
         //-------------------------
         // this is expected to be the parent of the axis operation object
-        String axisServMarker = logCorrelationIDString + ".axisService";
-        ObjectStateUtils.writeString(out, axisServMarker, axisServMarker);
-
-        if (axisService == null) {
-            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
-        } else {
-            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
-            metaAxisService =
-                    new MetaDataEntry(axisService.getClass().getName(), axisService.getName());
-            ObjectStateUtils
-                    .writeObject(out, metaAxisService, logCorrelationIDString + ".metaAxisService");
+        out.writeUTF("axisService");
+        metaAxisService = null;
+        if (axisService != null) {
+            metaAxisService = new MetaDataEntry(axisService.getClass().getName(), 
+                                                axisService.getName());
         }
+        out.writeObject(metaAxisService);
 
         //-------------------------
         // serviceContextID string
         //-------------------------
-        ObjectStateUtils
-                .writeString(out, serviceContextID, logCorrelationIDString + ".serviceContextID");
+        out.writeObject(serviceContextID);
 
         //-------------------------
         // serviceContext
         //-------------------------
         // is this the same as the parent of the OperationContext?
         boolean isParent = false;
+        out.writeUTF("serviceContext");
 
         if (operationContext != null) {
             ServiceContext opctxParent = operationContext.getServiceContext();
@@ -2487,51 +2454,40 @@
             }
         }
 
-        String servCtxMarker = logCorrelationIDString + ".serviceContext";
-        ObjectStateUtils.writeString(out, servCtxMarker, servCtxMarker);
-
         if (serviceContext == null) {
-            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+            out.writeBoolean(ExternalizeConstants.EMPTY_OBJECT);
         } else {
-            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+            out.writeBoolean(ExternalizeConstants.ACTIVE_OBJECT);
             out.writeBoolean(isParent);
 
             // only write out the object if it is not the parent
             if (!isParent) {
-                ObjectStateUtils.writeObject(out, serviceContext,
-                                             logCorrelationIDString + ".serviceContext");
+                out.writeObject(serviceContext);
             }
         }
 
         //---------------------------------------------------------
         // axisServiceGroup
         //---------------------------------------------------------
-
-        String axisServGrpMarker = logCorrelationIDString + ".axisServiceGroup";
-        ObjectStateUtils.writeString(out, axisServGrpMarker, axisServGrpMarker);
-
-        if (axisServiceGroup == null) {
-            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
-        } else {
-            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+        out.writeUTF("axisServiceGroup");
+        metaAxisServiceGroup = null;
+        if (axisServiceGroup != null) {
             metaAxisServiceGroup = new MetaDataEntry(axisServiceGroup.getClass().getName(),
                                                      axisServiceGroup.getServiceGroupName());
-            ObjectStateUtils.writeObject(out, metaAxisServiceGroup,
-                                         logCorrelationIDString + ".metaAxisServiceGroup");
         }
+        out.writeObject(metaAxisServiceGroup);
 
         //-----------------------------
         // serviceGroupContextId string
         //-----------------------------
-        ObjectStateUtils.writeString(out, serviceGroupContextId,
-                                     logCorrelationIDString + ".serviceGroupContextId");
+        out.writeObject(serviceGroupContextId);
 
         //-------------------------
         // serviceGroupContext
         //-------------------------
-
         // is this the same as the parent of the ServiceContext?
         isParent = false;
+        out.writeUTF("serviceGroupContext");
 
         if (serviceContext != null) {
             ServiceGroupContext srvgrpctxParent = (ServiceGroupContext) serviceContext.getParent();
@@ -2544,44 +2500,35 @@
             }
         }
 
-        String servGrpCtxMarker = logCorrelationIDString + ".serviceGroupContext";
-        ObjectStateUtils.writeString(out, servGrpCtxMarker, servGrpCtxMarker);
-
         if (serviceGroupContext == null) {
-            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
+            out.writeBoolean(ExternalizeConstants.EMPTY_OBJECT);
         } else {
-            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
+            out.writeBoolean(ExternalizeConstants.ACTIVE_OBJECT);
             out.writeBoolean(isParent);
 
             // only write out the object if it is not the parent
             if (!isParent) {
-                ObjectStateUtils.writeObject(out, serviceGroupContext,
-                                             logCorrelationIDString + ".serviceGroupContext");
+                out.writeObject(serviceGroupContext);
             }
         }
 
         //---------------------------------------------------------
         // axis message
         //---------------------------------------------------------
-        String axisMsgMarker = logCorrelationIDString + ".axisMessage";
-        ObjectStateUtils.writeString(out, axisMsgMarker, axisMsgMarker);
-
-        if (axisMessage == null) {
-            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT);
-        } else {
+        out.writeUTF("axisMessage");
+        metaAxisMessage = null;
+        if (axisMessage != null) {
             // This AxisMessage is expected to belong to the AxisOperation
             // that has already been recorded for this MessageContext.
             // If an AxisMessage associated with this Messagecontext is
             // associated with a different AxisOperation, then more
             // meta information would need to be saved
 
-            out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
-
             // make sure the axis message has a name associated with it
             String amTmpName = axisMessage.getName();
 
             if (amTmpName == null) {
-                amTmpName = ObjectStateUtils.EMPTY_MARKER;
+                amTmpName = ExternalizeConstants.EMPTY_MARKER;
                 axisMessage.setName(amTmpName);
             }
 
@@ -2596,9 +2543,8 @@
             metaAxisMessage = new MetaDataEntry(axisMessage.getClass().getName(),
                                                 axisMessage.getName(), amTmpElemQNameString);
 
-            ObjectStateUtils
-                    .writeObject(out, metaAxisMessage, logCorrelationIDString + ".metaAxisMessage");
         }
+        out.writeObject(metaAxisMessage);
 
         //---------------------------------------------------------
         // configuration context
@@ -2614,8 +2560,7 @@
         //---------------------------------------------------------
         // session context
         //---------------------------------------------------------
-        ObjectStateUtils
-                .writeObject(out, sessionContext, logCorrelationIDString + ".sessionContext");
+        out.writeObject(sessionContext);
 
         //---------------------------------------------------------
         // transport
@@ -2624,48 +2569,35 @@
         //------------------------------
         // incomingTransportName string
         //------------------------------
-        ObjectStateUtils.writeString(out, incomingTransportName,
-                                     logCorrelationIDString + ".incomingTransportName");
+        out.writeObject(incomingTransportName);
 
         // TransportInDescription transportIn
+        metaTransportIn = null;
         if (transportIn != null) {
             metaTransportIn = new MetaDataEntry(null, transportIn.getName());
-        } else {
-            metaTransportIn = null;
-        }
-        ObjectStateUtils.writeObject(out, metaTransportIn, logCorrelationIDString + ".transportIn");
+        } 
+        out.writeObject(metaTransportIn);
 
         // TransportOutDescription transportOut
+        metaTransportOut = null;
         if (transportOut != null) {
             metaTransportOut = new MetaDataEntry(null, transportOut.getName());
-        } else {
-            metaTransportOut = null;
         }
-        ObjectStateUtils
-                .writeObject(out, metaTransportOut, logCorrelationIDString + ".transportOut");
+        out.writeObject(metaTransportOut);
+        
 
         //---------------------------------------------------------
         // properties
         //---------------------------------------------------------
-        Map tmpMap = properties;
+        // Write out the local properties on the MessageContext
+        // Don't write out the properties from other hierarchical layers.
+        out.writeUTF("properties"); // write marker
+        out.writeMap(properties);
 
-        HashMap tmpHashMap = null;
-
-        if ((tmpMap != null) && (!tmpMap.isEmpty())) {
-            tmpHashMap = new HashMap(tmpMap);
-        }
-
-        ObjectStateUtils.writeHashMap(out, tmpHashMap, logCorrelationIDString + ".properties");
-
         //---------------------------------------------------------
         // special data
         //---------------------------------------------------------
-
-        String selfManagedDataMarker = logCorrelationIDString + ".selfManagedData";
-        ObjectStateUtils.writeString(out, selfManagedDataMarker, selfManagedDataMarker);
-
-        // save the data, which the handlers themselves will serialize
-        //ByteArrayOutputStream baos_fromSelfManagedData = serializeSelfManagedData();
+        out.writeUTF("selfManagedData");
         serializeSelfManagedData(out);
 
         //---------------------------------------------------------
@@ -2688,7 +2620,7 @@
         if (attachments != null && attachments.getContentIDList().size() > 1) {
             persistOptimized = true;
             if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled())
-                log.trace(logCorrelationIDString
+                log.trace(getLogIDString()
                         + ":getPersistOptimized(): attachments present; persist optimized");
         }
         if (!persistOptimized) {
@@ -2696,7 +2628,7 @@
             if (property != null && JavaUtils.isTrueExplicitly(property)) {
                 persistOptimized = true;
                 if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled())
-                    log.trace(logCorrelationIDString
+                    log.trace(getLogIDString()
                             + ":getPersistOptimized(): ENBABLE_MTOM is set; persist optimized");
             }
         }
@@ -2705,12 +2637,12 @@
             if (property != null && JavaUtils.isTrueExplicitly(property)) {
                 persistOptimized = true;
                 if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled())
-                    log.trace(logCorrelationIDString
+                    log.trace(getLogIDString()
                             + ":getPersistOptimized(): ENBABLE_SWA is set; persist optimized");
             }
         }
         if (!persistOptimized && LoggingControl.debugLoggingAllowed && log.isTraceEnabled())
-            log.trace(logCorrelationIDString
+            log.trace(getLogIDString()
                     + ":getPersistOptimized(): No attachments or attachment settings; persist non-optimized");
         return persistOptimized;
     }
@@ -2728,7 +2660,8 @@
      * @throws IOException
      * @throws ClassNotFoundException
      */
-    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+    public void readExternal(ObjectInput inObject) throws IOException, ClassNotFoundException {        
+        SafeObjectInputStream in = SafeObjectInputStream.install(inObject);
         // set the flag to indicate that the message context is being
         // reconstituted and will need to have certain object references
         // to be reconciled with the current engine setup
@@ -2752,12 +2685,12 @@
 
         // make sure the object data is in a version we can handle
         if (suid != serialVersionUID) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_SUID);
         }
 
         // make sure the object data is in a revision level we can handle
-        if (revID != REVISION_1) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        if (revID != REVISION_2) {
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_REVID);
         }
 
         //---------------------------------------------------------
@@ -2781,21 +2714,20 @@
 
         long time = in.readLong();
         setLastTouchedTime(time);
+        logCorrelationID = (String) in.readObject();
 
-        logCorrelationID = ObjectStateUtils.readString(in, "logCorrelationID");
-        logCorrelationIDString = "[MessageContext: logID=" + logCorrelationID + "]";
-
         // trace point
         if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
+            logCorrelationIDString = "[MessageContext: logID=" + getLogCorrelationID() + "]";
             log.trace(myClassName + ":readExternal():  reading the input stream for  " +
-                    logCorrelationIDString);
+                      getLogIDString());
         }
 
         //---------------------------------------------------------
         // Message
         // Read the message and attachments
         //---------------------------------------------------------
-        envelope = MessageExternalizeUtils.readExternal(in, this, logCorrelationIDString);
+        envelope = MessageExternalizeUtils.readExternal(in, this, getLogIDString());
 
         //---------------------------------------------------------
         // ArrayList executionChain
@@ -2834,14 +2766,14 @@
         in.readUTF();
         boolean gotChain = in.readBoolean();
 
-        if (gotChain == ObjectStateUtils.ACTIVE_OBJECT) {
+        if (gotChain == ExternalizeConstants.ACTIVE_OBJECT) {
             metaHandlerIndex = in.readInt();
             metaPhaseIndex = in.readInt();
 
             int expectedNumberEntries = in.readInt();
 
             if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-                log.trace(logCorrelationIDString +
+                log.trace(getLogIDString() +
                         ":readExternal(): execution chain:  expected number of entries [" +
                         expectedNumberEntries + "]");
             }
@@ -2857,8 +2789,7 @@
                 // stop when we get to the end-of-list marker
 
                 // get the object
-                Object tmpObj = ObjectStateUtils
-                        .readObject(in, "MessageContext.metaExecutionChain MetaDataEntry");
+                Object tmpObj = in.readObject();
 
                 count++;
 
@@ -2883,10 +2814,12 @@
                         if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
                             String tmpHasList = mdObj.isListEmpty() ? "no children" : "has children";
 
-                            log.trace(logCorrelationIDString +
+                            if (log.isTraceEnabled()) {
+                                log.trace(getLogIDString() +
                                     ":readExternal(): meta data class [" + tmpClassNameStr +
                                     "] qname [" + tmpQNameAsStr + "]  index [" + count + "]   [" +
                                     tmpHasList + "]");
+                            }
                         }
                     }
                 } else {
@@ -2899,7 +2832,7 @@
             int adjustedNumberEntries = in.readInt();
 
             if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-                log.trace(logCorrelationIDString +
+                log.trace(getLogIDString() +
                         ":readExternal(): adjusted number of entries ExecutionChain [" +
                         adjustedNumberEntries + "]    ");
             }
@@ -2907,7 +2840,7 @@
 
         if ((metaExecutionChain == null) || (metaExecutionChain.isEmpty())) {
             if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-                log.trace(logCorrelationIDString +
+                log.trace(getLogIDString() +
                         ":readExternal(): meta data for Execution Chain is NULL");
             }
         }
@@ -2944,11 +2877,11 @@
         in.readUTF();
         boolean gotInExecList = in.readBoolean();
 
-        if (gotInExecList == ObjectStateUtils.ACTIVE_OBJECT) {
+        if (gotInExecList == ExternalizeConstants.ACTIVE_OBJECT) {
             int expectedNumberInExecList = in.readInt();
 
             if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-                log.trace(logCorrelationIDString +
+                log.trace(getLogIDString() +
                         ":readExternal(): executed phases:  expected number of entries [" +
                         expectedNumberInExecList + "]");
             }
@@ -2964,8 +2897,7 @@
                 // stop when we get to the end-of-list marker
 
                 // get the object
-                Object tmpObj = ObjectStateUtils
-                        .readObject(in, "MessageContext.metaExecuted MetaDataEntry");
+                Object tmpObj = in.readObject();
 
                 count++;
 
@@ -2993,7 +2925,7 @@
                         }
 
                         if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-                            log.trace(logCorrelationIDString +
+                            log.trace(getLogIDString() +
                                     ":readExternal(): meta data class [" + tmpClassNameStr +
                                     "] qname [" + tmpQNameAsStr + "]  index [" + count + "]   [" +
                                     tmpHasList + "]");
@@ -3009,7 +2941,7 @@
             int adjustedNumberInExecList = in.readInt();
 
             if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-                log.trace(logCorrelationIDString +
+                log.trace(getLogIDString() +
                         ":readExternal(): adjusted number of entries executedPhases [" +
                         adjustedNumberInExecList + "]    ");
             }
@@ -3017,7 +2949,7 @@
 
         if ((metaExecuted == null) || (metaExecuted.isEmpty())) {
             if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-                log.trace(logCorrelationIDString +
+                log.trace(getLogIDString() +
                         ":readExternal(): meta data for executedPhases list is NULL");
             }
         }
@@ -3025,12 +2957,12 @@
         //---------------------------------------------------------
         // options
         //---------------------------------------------------------
+        in.readUTF(); // Read marker
+        options = (Options) in.readObject();
 
-        options = (Options) ObjectStateUtils.readObject(in, "MessageContext.options");
-
         if (options != null) {
             if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-                log.trace(logCorrelationIDString + ":readExternal(): restored Options [" +
+                log.trace(getLogIDString() + ":readExternal(): restored Options [" +
                         options.getLogCorrelationIDString() + "]");
             }
         }
@@ -3041,26 +2973,17 @@
 
         // axisOperation is not usable until the meta data has been reconciled
         axisOperation = null;
+        in.readUTF();  // Read Marker
+        metaAxisOperation = (MetaDataEntry) in.readObject();
 
-        ObjectStateUtils.readString(in, "MessageContext.axisOperation");
-
-        boolean metaAxisOperationIsActive = in.readBoolean();
-
-        if (metaAxisOperationIsActive == ObjectStateUtils.ACTIVE_OBJECT) {
-            metaAxisOperation = (MetaDataEntry) ObjectStateUtils
-                    .readObject(in, "MessageContext.metaAxisOperation");
-        } else {
-            metaAxisOperation = null;
-        }
-
         // operation context is not usable until it has been activated
         // NOTE: expect this to be the parent
-        operationContext = (OperationContext) ObjectStateUtils
-                .readObject(in, "MessageContext.operationContext");
+        in.readUTF();  // Read marker
+        operationContext = (OperationContext) in.readObject();
 
         if (operationContext != null) {
             if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-                log.trace(logCorrelationIDString + ":readExternal(): restored OperationContext [" +
+                log.trace(getLogIDString() + ":readExternal(): restored OperationContext [" +
                         operationContext.getLogCorrelationIDString() + "]");
             }
         }
@@ -3071,33 +2994,22 @@
 
         // axisService is not usable until the meta data has been reconciled
         axisService = null;
+        in.readUTF(); // Read marker
+        metaAxisService = (MetaDataEntry) in.readObject();
 
-        ObjectStateUtils.readString(in, "MessageContext.axisService");
-
-        boolean metaAxisServiceIsActive = in.readBoolean();
-
-        if (metaAxisServiceIsActive == ObjectStateUtils.ACTIVE_OBJECT) {
-            metaAxisService = (MetaDataEntry) ObjectStateUtils
-                    .readObject(in, "MessageContext.metaAxisService");
-        } else {
-            metaAxisService = null;
-        }
-
         //-------------------------
         // serviceContextID string
         //-------------------------
-
-        serviceContextID = ObjectStateUtils.readString(in, "MessageContext.serviceContextID");
-
+        serviceContextID = (String) in.readObject();
+        
         //-------------------------
         // serviceContext
         //-------------------------
+        in.readUTF(); // Read marker
 
-        ObjectStateUtils.readString(in, "MessageContext.serviceContext");
-
         boolean servCtxActive = in.readBoolean();
 
-        if (servCtxActive == ObjectStateUtils.EMPTY_OBJECT) {
+        if (servCtxActive == ExternalizeConstants.EMPTY_OBJECT) {
             // empty object
 
             serviceContext = null;
@@ -3108,8 +3020,7 @@
 
             // there's an object to read in if it is not the parent of the operation context
             if (!isParent) {
-                serviceContext = (ServiceContext) ObjectStateUtils
-                        .readObject(in, "MessageContext.serviceContext");
+                serviceContext = (ServiceContext) in.readObject();
             } else {
                 // the service context is the parent of the operation context
                 // so get it from the operation context during activate
@@ -3123,33 +3034,22 @@
 
         // axisServiceGroup is not usable until the meta data has been reconciled
         axisServiceGroup = null;
+        in.readUTF(); // Read marker
+        metaAxisServiceGroup = (MetaDataEntry) in.readObject();
 
-        ObjectStateUtils.readString(in, "MessageContext.axisServiceGroup");
-
-        boolean metaAxisServiceGrpIsActive = in.readBoolean();
-
-        if (metaAxisServiceGrpIsActive == ObjectStateUtils.ACTIVE_OBJECT) {
-            metaAxisServiceGroup = (MetaDataEntry) ObjectStateUtils
-                    .readObject(in, "MessageContext.metaAxisServiceGroup");
-        } else {
-            metaAxisServiceGroup = null;
-        }
-
         //-----------------------------
         // serviceGroupContextId string
         //-----------------------------
-        serviceGroupContextId =
-                ObjectStateUtils.readString(in, "MessageContext.serviceGroupContextId");
+        serviceGroupContextId = (String) in.readObject();
 
         //-----------------------------
         // serviceGroupContext
         //-----------------------------
+        in.readUTF();
 
-        ObjectStateUtils.readString(in, "MessageContext.serviceGroupContext");
-
         boolean servGrpCtxActive = in.readBoolean();
 
-        if (servGrpCtxActive == ObjectStateUtils.EMPTY_OBJECT) {
+        if (servGrpCtxActive == ExternalizeConstants.EMPTY_OBJECT) {
             // empty object
 
             serviceGroupContext = null;
@@ -3160,8 +3060,7 @@
 
             // there's an object to read in if it is not the parent of the service group context
             if (!isParentSGC) {
-                serviceGroupContext = (ServiceGroupContext) ObjectStateUtils
-                        .readObject(in, "MessageContext.serviceGroupContext");
+                serviceGroupContext = (ServiceGroupContext) in.readObject();
             } else {
                 // the service group context is the parent of the service context
                 // so get it from the service context during activate
@@ -3175,20 +3074,11 @@
 
         // axisMessage is not usable until the meta data has been reconciled
         axisMessage = null;
+        in.readUTF();  // Read marker
+        metaAxisMessage = (MetaDataEntry) in.readObject();
+        reconcileAxisMessage = (metaAxisMessage != null);
 
-        ObjectStateUtils.readString(in, "MessageContext.axisMessage");
 
-        boolean metaAxisMessageIsActive = in.readBoolean();
-
-        if (metaAxisMessageIsActive == ObjectStateUtils.ACTIVE_OBJECT) {
-            metaAxisMessage = (MetaDataEntry) ObjectStateUtils
-                    .readObject(in, "MessageContext.metaAxisMessage");
-            reconcileAxisMessage = true;
-        } else {
-            metaAxisMessage = null;
-            reconcileAxisMessage = false;
-        }
-
         //---------------------------------------------------------
         // configuration context
         //---------------------------------------------------------
@@ -3202,10 +3092,8 @@
         //---------------------------------------------------------
         // session context
         //---------------------------------------------------------
+        sessionContext = (SessionContext) in.readObject();
 
-        sessionContext =
-                (SessionContext) ObjectStateUtils.readObject(in, "MessageContext.sessionContext");
-
         //---------------------------------------------------------
         // transport
         //---------------------------------------------------------
@@ -3213,41 +3101,33 @@
         //------------------------------
         // incomingTransportName string
         //------------------------------
-        incomingTransportName =
-                ObjectStateUtils.readString(in, "MessageContext.incomingTransportName");
+        incomingTransportName = (String) in.readObject();
 
         // TransportInDescription transportIn
         // is not usable until the meta data has been reconciled
         transportIn = null;
-        metaTransportIn =
-                (MetaDataEntry) ObjectStateUtils.readObject(in, "MessageContext.metaTransportIn");
+        metaTransportIn = (MetaDataEntry) in.readObject();
 
         // TransportOutDescription transportOut
         // is not usable until the meta data has been reconciled
         transportOut = null;
-        metaTransportOut =
-                (MetaDataEntry) ObjectStateUtils.readObject(in, "MessageContext.metaTransportOut");
+        metaTransportOut = (MetaDataEntry) in.readObject();
 
         //---------------------------------------------------------
         // properties
         //---------------------------------------------------------
+        in.readUTF(); // Read marker
+        properties  = in.readHashMap();
 
-        HashMap tmpHashMap = ObjectStateUtils.readHashMap(in, "MessageContext.properties");
 
-        properties = new HashMap();
-        if (tmpHashMap != null) {
-            setProperties(tmpHashMap);
-        }
-
         //---------------------------------------------------------
         // special data
         //---------------------------------------------------------
+        in.readUTF(); // Read marker
 
-        ObjectStateUtils.readString(in, "MessageContext.selfManagedData");
-
         boolean gotSelfManagedData = in.readBoolean();
 
-        if (gotSelfManagedData == ObjectStateUtils.ACTIVE_OBJECT) {
+        if (gotSelfManagedData == ExternalizeConstants.ACTIVE_OBJECT) {
             selfManagedDataHandlerCount = in.readInt();
 
             if (selfManagedDataListHolder == null) {
@@ -3267,9 +3147,9 @@
 
         // trace point
         if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-            log.trace(logCorrelationIDString +
+            log.trace(getLogIDString() +
                     ":readExternal():  message context object created for  " +
-                    logCorrelationIDString);
+                    getLogIDString());
         }
     }
 
@@ -3300,16 +3180,17 @@
 
         // We previously saved metaAxisService; restore it
         if (metaAxisService != null) {
-            this.setAxisService(ObjectStateUtils.findService(axisConfig,
-                                                             metaAxisService.getClassName(),
-                                                             metaAxisService.getQNameAsString()));
+            this.setAxisService(ActivateUtils.findService(axisConfig,
+                                                metaAxisService.getClassName(),
+                                                metaAxisService.getQNameAsString()));
         }
 
         // We previously saved metaAxisServiceGroup; restore it
         if (metaAxisServiceGroup != null) {
-            this.setAxisServiceGroup(ObjectStateUtils.findServiceGroup(axisConfig,
-                                                                       metaAxisServiceGroup.getClassName(),
-                                                                       metaAxisServiceGroup.getQNameAsString()));
+            this.setAxisServiceGroup(
+                                     ActivateUtils.findServiceGroup(axisConfig,
+                                                metaAxisServiceGroup.getClassName(),
+                                                metaAxisServiceGroup.getQNameAsString()));
         }
 
         // We previously saved metaAxisOperation; restore it
@@ -3318,13 +3199,13 @@
 
             if (serv != null) {
                 // TODO: check for the empty name
-                this.setAxisOperation(ObjectStateUtils.findOperation(serv,
-                                                                     metaAxisOperation.getClassName(),
-                                                                     metaAxisOperation.getQName()));
+                this.setAxisOperation(ActivateUtils.findOperation(serv,
+                                                                  metaAxisOperation.getClassName(),
+                                                                  metaAxisOperation.getQName()));
             } else {
-                this.setAxisOperation(ObjectStateUtils.findOperation(axisConfig,
-                                                                     metaAxisOperation.getClassName(),
-                                                                     metaAxisOperation.getQName()));
+                this.setAxisOperation(ActivateUtils.findOperation(axisConfig,
+                                                                  metaAxisOperation.getClassName(),
+                                                                  metaAxisOperation.getQName()));
             }
         }
 
@@ -3334,9 +3215,9 @@
 
             if (op != null) {
                 // TODO: check for the empty name
-                this.setAxisMessage(ObjectStateUtils.findMessage(op,
-                                                                 metaAxisMessage.getQNameAsString(),
-                                                                 metaAxisMessage.getExtraName()));
+                this.setAxisMessage(ActivateUtils.findMessage(op,
+                                                              metaAxisMessage.getQNameAsString(),
+                                                              metaAxisMessage.getExtraName()));
             }
         }
 
@@ -3616,9 +3497,9 @@
         if (metaAxisMessage != null) {
             if (axisOp != null) {
                 // TODO: check for the empty name
-                this.setAxisMessage(ObjectStateUtils.findMessage(axisOp,
-                                                                 metaAxisMessage.getQNameAsString(),
-                                                                 metaAxisMessage.getExtraName()));
+                this.setAxisMessage(ActivateUtils.findMessage(axisOp,
+                                                 metaAxisMessage.getQNameAsString(),
+                                                 metaAxisMessage.getExtraName()));
             }
         }
 
@@ -3784,7 +3665,7 @@
         ArrayList handlerListToReturn = new ArrayList();
 
         for (int i = 0; i < metaDataEntries.size(); i++) {
-            Handler handler = (Handler) ObjectStateUtils
+            Handler handler = (Handler) ActivateUtils
                     .findHandler(existingHandlers, (MetaDataEntry) metaDataEntries.get(i));
 
             if (handler != null) {
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/MessageExternalizeUtils.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/MessageExternalizeUtils.java	(revision 0)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/MessageExternalizeUtils.java	(revision 0)
@@ -0,0 +1,455 @@
+/*
+ * Copyright 2004,2007 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.context.externalize;
+
+import org.apache.axiom.om.OMOutputFormat;
+import org.apache.axiom.om.impl.builder.StAXBuilder;
+import org.apache.axiom.om.util.StAXUtils;
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axiom.soap.impl.builder.StAXSOAPModelBuilder;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.builder.BuilderUtil;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.transport.MessageFormatter;
+import org.apache.axis2.transport.TransportUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import javax.xml.stream.XMLStreamReader;
+
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+import java.io.OutputStream;
+
+/**
+ * Utility to read/write the Message of a MessageContext
+ * Message Object Format.
+ * 
+ * <tt>
+ * Format := Prolog {DataBlocks} EndBlocks
+ * 
+ * Prolog :=
+ *   NAME      (UTF) 
+ *   REVISION  (INT)
+ *   ACTIVE    (BOOL)
+ *     [OPTIMIZED (BOOL)]  
+ *        [OPTIMIZED_CONTENT_TYPE (UTF)]    <--- If OPTIMIZED=TRUE
+ *     [CHARSET   (UTF)] 
+ *     [NAMESPACE (UTF)]
+ *   
+ * DataBlock :=
+ *   SIZE (INT >0)
+ *   DATA (BYTES)
+ *   
+ * EndBlocks
+ *   SIZE (INT)   {0 indicates end -1 indicates failure}
+ *     
+ *   
+ * </tt>
+ */
+public class MessageExternalizeUtils  implements ExternalizeConstants {
+    static final Log log = LogFactory.getLog(MessageExternalizeUtils.class);
+
+    /*
+     * @serial Tracks the revision level of a class to identify changes to the
+     * class definition that are compatible to serialization/externalization.
+     * If a class definition changes, then the serialization/externalization
+     * of the class is affected.
+     * Refer to the writeExternal() and readExternal() methods.
+     */
+    // supported revision levels, add a new level to manage compatible changes
+    private static final int REVISION_2 = 2;
+    // current revision level of this object
+    private static final int revisionID = REVISION_2;
+    
+    
+    /**
+     * Private Constructor.
+     * This class only supports static methods
+     */
+    private MessageExternalizeUtils() {}
+    
+    /**
+     * Write out the Message
+     * @param out
+     * @param mc
+     * @param correlationIDString
+     * @param outputFormat
+     * @throws IOException
+     */
+    public static void writeExternal(ObjectOutput out, 
+                                     MessageContext mc,
+                                     String correlationIDString,
+                                     OMOutputFormat outputFormat) throws IOException {
+        if (log.isDebugEnabled()) {
+            log.debug(correlationIDString + ":writeExternal(): start");
+        }
+        SOAPEnvelope envelope = mc.getEnvelope();
+        if (envelope == null) {
+            // Case: No envelope
+            out.writeUTF("NULL_ENVELOPE");
+            out.writeInt(revisionID);
+            out.writeBoolean(EMPTY_OBJECT); // Not Active
+            out.writeInt(0);  // EndBlocks
+            if (log.isDebugEnabled()) {
+                log.debug(correlationIDString + ":writeExternal(): end: msg is Empty");
+            }
+            return;
+        }
+        
+        // Write Prolog
+        String msgClass = envelope.getClass().getName();
+        out.writeUTF(msgClass);
+        out.writeInt(revisionID);
+        out.writeBoolean(ACTIVE_OBJECT);
+        if (outputFormat.isOptimized()) {
+            out.writeBoolean(true);
+            // Write out the contentType.
+            out.writeUTF(outputFormat.getContentType());
+        } else {
+            out.writeBoolean(false);
+        }
+        out.writeUTF(outputFormat.getCharSetEncoding());
+        out.writeUTF(envelope.getNamespace().getNamespaceURI());
+        if (log.isDebugEnabled()) {
+            log.debug(correlationIDString + ":writeExternal(): " + 
+                      "optimized=[" + outputFormat.isOptimized() + "]  " +
+                      "optimizedContentType " + outputFormat.getContentType() + "]  " +
+                      "charSetEnc=[" + outputFormat.getCharSetEncoding() + "]  " +
+                      "namespaceURI=[" + envelope.getNamespace().getNamespaceURI() + "]");
+        }
+        
+        // Write DataBlocks
+        // MessageOutputStream writes out the DataBlocks in chunks
+        // BufferedOutputStream buffers the data to prevent numerous, small blocks
+        MessageOutputStream mos = new MessageOutputStream(out);  
+        BufferedOutputStream bos = new BufferedOutputStream(mos);   
+        boolean errorOccurred = false;
+        try { 
+            // Write out the message using the same logic as the 
+            // transport layer.
+            MessageFormatter msgFormatter = TransportUtils.getMessageFormatter(mc);
+            msgFormatter.writeTo(mc, outputFormat, bos, 
+                                 true); // Preserve the original message
+            
+        } catch (IOException e) {
+            throw e;
+        } catch (Throwable t) {
+            throw AxisFault.makeFault(t);
+        } finally {
+            bos.flush();
+            bos.close();
+        }
+        
+        // Write End of Data Blocks
+        if (errorOccurred) {
+            out.writeInt(-1);
+        } else {
+            out.writeInt(0);
+        }
+        if (log.isDebugEnabled()) {
+            log.debug(correlationIDString + ":writeExternal(): end");
+        }
+    }
+    
+    /**
+     * Read the Message
+     * @param in
+     * @param mc
+     * @param correlationIDString
+     * @return
+     * @throws IOException
+     */
+    public static SOAPEnvelope readExternal(ObjectInput in,
+                                            MessageContext mc,
+                                            String correlationIDString) throws IOException, ClassNotFoundException {
+        if (log.isDebugEnabled()) {
+            log.debug(correlationIDString + ":readExternal(): start");
+        }
+        SOAPEnvelope envelope = null;
+        
+        // Read Prolog
+        // Read the class name and object state
+        String name = in.readUTF();
+        int revision = in.readInt();
+        
+        if (log.isDebugEnabled()) {
+            log.debug(correlationIDString + ":readExternal(): name= " + name  +
+                      " revision= " + revision);
+        }
+        // make sure the object data is in a revision level we can handle
+        if (revision != REVISION_2) {
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_REVID);
+        }
+        
+        
+        boolean gotMsg = in.readBoolean();
+        if (gotMsg != ACTIVE_OBJECT) {
+            if (log.isDebugEnabled()) {
+                log.debug(correlationIDString + ":readExternal(): end:" +
+                                "no message present");
+            }
+            in.readInt(); // Read end of data blocks
+            return envelope;
+        }
+        
+        // Read optimized, optimized content-type, charset encoding and namespace uri
+        boolean optimized= in.readBoolean();
+        String optimizedContentType = null;
+        if (optimized) {
+            optimizedContentType = in.readUTF();
+        }
+        String charSetEnc = in.readUTF();
+        String namespaceURI = in.readUTF();
+        if (log.isDebugEnabled()) {
+            log.debug(correlationIDString + ":readExternal(): " +
+                      "optimized=[" + optimized + "]  " +
+                      "optimizedContentType=[" + optimizedContentType + "]  " +
+                      "charSetEnc=[" + charSetEnc + "]  " +
+                      "namespaceURI=[" + namespaceURI + "]");
+        }
+        
+        MessageInputStream mis = new MessageInputStream(in);
+        StAXBuilder  builder = null;
+        try {
+            if (optimized) {
+                boolean isSOAP = true;
+                builder =
+                    BuilderUtil.getAttachmentsBuilder(mc,
+                                                      mis,
+                                                      optimizedContentType,
+                                                      isSOAP);
+                envelope = (SOAPEnvelope) builder.getDocumentElement();
+                envelope.buildWithAttachments();
+            } else {
+                XMLStreamReader xmlreader = StAXUtils.createXMLStreamReader(mis, charSetEnc);
+                builder = new StAXSOAPModelBuilder(xmlreader, namespaceURI);
+                envelope = (SOAPEnvelope) builder.getDocumentElement();
+                envelope.build();
+            }
+        } catch (Exception ex) {
+            // TODO: what to do if can't get the XML stream reader
+            // For now, log the event
+            log.error(correlationIDString
+                      + ":readExternal(): Error when deserializing persisted envelope: ["
+                      + ex.getClass().getName() + " : " + ex.getLocalizedMessage() + "]", ex);
+            envelope = null;
+        } finally {
+            if (builder != null) {
+                builder.close();
+            }
+            // Close the message input stream.  This will ensure that the
+            // underlying stream is advanced past the message.
+            mis.close();
+            if (log.isDebugEnabled()) {
+                log.debug(correlationIDString + ":readExternal(): end");
+            }
+        }
+        return envelope;
+    }
+    
+    /**
+     * MessageOutputStream writes DataBlock chunks to the ObjectOutput.
+     */
+    private static class MessageOutputStream extends OutputStream {
+        ObjectOutput out;
+        boolean isDebug;
+        MessageOutputStream(ObjectOutput out) {
+            this.out = out;
+            isDebug = log.isDebugEnabled();
+        }
+        
+         
+        public void close() throws IOException {
+            // NOOP: ObjectOutput will be closed externally
+        }
+        
+        public void flush() throws IOException {
+            out.flush();
+        }
+
+        /** 
+         * Writes a chunk of data to the ObjectOutput
+         */
+        public void write(byte[] b, int off, int len) throws IOException {
+            if (len > 0) {
+                if (isDebug) {
+                    log.debug("Write data chunk with len=" + len);
+                }
+                // Write out the length and the data chunk
+                out.writeInt(len);
+                out.write(b, off, len);
+            }
+        }
+
+         
+        /** 
+         * Writes a chunk of data to the ObjectOutput
+         */
+        public void write(byte[] b) throws IOException {
+            if (b != null &&  b.length > 0) {
+                if (isDebug) {
+                    log.debug("Write data chunk with size=" + b.length);
+                }
+                // Write out the length and the data chunk
+                out.writeInt(b.length);
+                out.write(b);
+            }
+        }
+
+         
+        /** 
+         * Writes a single byte chunk of data to the ObjectOutput
+         */
+        public void write(int b) throws IOException {
+            if (isDebug) {
+                log.debug("Write one byte data chunk");
+            }
+            // Write out the length and the data chunk
+            out.writeInt(1);
+            out.write(b);
+        }
+    }
+       
+    /**
+     * Provides a InputStream interface over ObjectInput.
+     * MessageInputStream controls the reading of the DataBlock chunks
+     *
+     */
+    private static class MessageInputStream extends InputStream {
+        
+        ObjectInput in;
+        boolean isDebug;
+        int chunkAvail = 0;
+        boolean isEOD = false;
+        
+        /**
+         * Constructor
+         * @param in
+         */
+        MessageInputStream(ObjectInput in) {
+            this.in = in;
+            isDebug = log.isDebugEnabled();
+        }
+
+         
+        /**
+         * Read a single logical byte
+         */
+        public int read() throws IOException {
+            if (isDebug) {
+                log.debug("invoking read()");
+            }
+            // Determine how many bytes are left in the current data chunk
+            updateChunkAvail();
+            int ret = 0;
+            if (isEOD) {
+                ret = -1;
+            } else {
+                chunkAvail--;
+                ret = in.readByte();
+            }
+            log.debug("returning " + ret);
+            return ret;
+        }
+
+         
+        /**
+         * Read an array of logical bytes
+         */
+        public int read(byte[] b, int off, int len) throws IOException {
+            if (isDebug) {
+                log.debug("invoking read with off=" + off + " and len=" + len);
+            }
+            if (isEOD) {
+                if (isDebug) {
+                    log.debug("EOD returning -1");
+                }
+                return -1;
+            }
+            int bytesRead = 0;
+            while ((len >0 && !isEOD)) {
+                // Determine how many bytes are left in the current data chunk
+                updateChunkAvail();
+                if (!isEOD) {
+                    // Read the amount of bytes requested or the number of bytes available in the current chunk
+                    int readLength = len < chunkAvail ? len : chunkAvail;
+                    int br = in.read(b, off, readLength);
+                    if (br < 0) {
+                        throw new IOException("End of File encountered");
+                    }
+                    // Update state with the number of bytes read
+                    off += br;
+                    len -= br;
+                    chunkAvail -= br;
+                    bytesRead += br;
+                }
+            }
+            if (isDebug) {
+                log.debug("bytes read = " + bytesRead);
+            }
+            return bytesRead;
+        }
+
+         
+        public int read(byte[] b) throws IOException {
+            return read(b, 0, b.length);
+        }
+        
+        public void close() throws IOException {
+            if (isDebug) {
+                log.debug("start close");
+            }
+            // Keep reading chunks until EOD
+            if (!isEOD) {
+                byte[] tempBuffer = new byte[4 * 1024];
+                while (!isEOD) {
+                    read(tempBuffer);
+                }
+            }
+            if (isDebug) {
+                log.debug("end close");
+            }
+        }
+        
+        /**
+         * updateChunkAvail updates the chunkAvail field with the
+         * amount of data in the chunk.
+         * @throws IOException
+         */
+        private void updateChunkAvail() throws IOException {
+            
+            // If there are no more bytes in the current chunk,
+            // read the size of the next datablock
+            if (chunkAvail == 0 && !isEOD) {
+                chunkAvail = in.readInt();
+                if (isDebug) {
+                    log.debug("New DataBlock with size=" + chunkAvail);
+                }
+                if (chunkAvail <= 0) {
+                    if (isDebug) {
+                        log.debug("End of data");
+                    }
+                    isEOD = true;
+                    chunkAvail = 0;
+                }
+            }
+        }
+    }
+}
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/ActivateUtils.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/ActivateUtils.java	(revision 0)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/ActivateUtils.java	(revision 0)
@@ -0,0 +1,645 @@
+/*
+ * Copyright 2004,2007 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.context.externalize;
+
+import org.apache.axis2.description.AxisMessage;
+import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.AxisServiceGroup;
+import org.apache.axis2.description.TransportInDescription;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.axis2.engine.Handler;
+import org.apache.axis2.transport.TransportListener;
+import org.apache.axis2.util.MetaDataEntry;
+import org.apache.axis2.wsdl.WSDLConstants;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import javax.xml.namespace.QName;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.Map;
+
+
+/**
+ * Some Externalize objects must be "activated" after they are read.
+ * Activation normally involves associating the object with objects in the current
+ * runtime.
+ * 
+ * ActivateUtils provides activation related utilities
+ */
+public class ActivateUtils {
+    
+    private static final Log log = LogFactory.getLog(ActivateUtils.class);
+    
+    /**
+     * Private Constructor
+     * All methods in ActivateUtils are static.
+     */
+    private ActivateUtils() {}
+
+    /**
+     * Find the AxisServiceGroup object that matches the criteria
+     * <p/>
+     * <B>Note<B> the saved service group meta information may not
+     * match up with any of the serviceGroups that
+     * are in the current AxisConfiguration object.
+     * 
+     * @param axisConfig The AxisConfiguration object
+     * @param serviceGrpClassName the class name string for the target object
+     *                   (could be a derived class)
+     * @param serviceGrpName      the name associated with the service group
+     * @return the AxisServiceGroup object that matches the criteria
+     */
+    public static AxisServiceGroup findServiceGroup(AxisConfiguration axisConfig,
+                                                    String serviceGrpClassName,
+                                                    String serviceGrpName) {
+        Iterator its = axisConfig.getServiceGroups();
+
+        while (its.hasNext()) {
+            AxisServiceGroup serviceGroup = (AxisServiceGroup) its.next();
+
+            String tmpSGClassName = serviceGroup.getClass().getName();
+            String tmpSGName = serviceGroup.getServiceGroupName();
+
+            if (tmpSGClassName.equals(serviceGrpClassName)) {
+                boolean found = false;
+
+                // the serviceGroupName can be null, so either both the 
+                // service group names are null or they match
+                if ((tmpSGName == null) && (serviceGrpName == null)) {
+                    found = true;
+                } else if ((tmpSGName != null) && (tmpSGName.equals(serviceGrpName))) {
+                    found = true;
+                }
+
+                if (found) {
+                    // trace point
+                    if (log.isTraceEnabled()) {
+                        log.trace("ObjectStateUtils:findServiceGroup(): returning  ["
+                                + serviceGrpClassName + "]   [" + serviceGrpName + "]");
+                    }
+
+                    return serviceGroup;
+                }
+            }
+        }
+
+        // trace point
+        if (log.isTraceEnabled()) {
+            log.trace("ObjectStateUtils:findServiceGroup(): [" + serviceGrpClassName + "]   ["
+                    + serviceGrpName + "]  returning  [null]");
+        }
+
+        return null;
+    }
+    
+    /**
+     * Find the AxisService object that matches the criteria
+     * 
+     * @param axisConfig The AxisConfiguration object
+     * @param serviceClassName the class name string for the target object
+     *                   (could be a derived class)
+     * @param serviceName      the name associated with the service
+     * @return the AxisService object that matches the criteria
+     */
+    public static AxisService findService(AxisConfiguration axisConfig, String serviceClassName,
+                                          String serviceName) {
+        HashMap services = axisConfig.getServices();
+
+        Iterator its = services.values().iterator();
+
+        while (its.hasNext()) {
+            AxisService service = (AxisService) its.next();
+
+            String tmpServClassName = service.getClass().getName();
+            String tmpServName = service.getName();
+
+            if ((tmpServClassName.equals(serviceClassName)) && (tmpServName.equals(serviceName))) {
+                // trace point
+                if (log.isTraceEnabled()) {
+                    log.trace("ObjectStateUtils:findService(): returning  [" + serviceClassName
+                            + "]   [" + serviceName + "]");
+                }
+
+                return service;
+            }
+        }
+
+        // trace point
+        if (log.isTraceEnabled()) {
+            log.trace("ObjectStateUtils:findService(): [" + serviceClassName + "]   ["
+                    + serviceName + "]  returning  [null]");
+        }
+
+        return null;
+    }
+    
+    /**
+     * Find the AxisOperation object that matches the criteria
+     * 
+     * @param axisConfig The AxisConfiguration object
+     * @param opClassName the class name string for the target object
+     *                   (could be a derived class)
+     * @param opQName    the name associated with the operation
+     * @return the AxisOperation object that matches the given criteria
+     */
+    public static AxisOperation findOperation(AxisConfiguration axisConfig, String opClassName,
+                                              QName opQName) {
+        HashMap services = axisConfig.getServices();
+
+        Iterator its = services.values().iterator();
+
+        while (its.hasNext()) {
+            AxisService service = (AxisService) its.next();
+
+            Iterator ito = service.getOperations();
+
+            while (ito.hasNext()) {
+                AxisOperation operation = (AxisOperation) ito.next();
+
+                String tmpOpName = operation.getClass().getName();
+                QName tmpOpQName = operation.getName();
+
+                if ((tmpOpName.equals(opClassName)) && (tmpOpQName.equals(opQName))) {
+                    // trace point
+                    if (log.isTraceEnabled()) {
+                        log.trace("ObjectStateUtils:findOperation(axisCfg): returning  ["
+                                + opClassName + "]   [" + opQName.toString() + "]");
+                    }
+
+                    return operation;
+                }
+            }
+        }
+
+        // trace point
+        if (log.isTraceEnabled()) {
+            log.trace("ObjectStateUtils:findOperation(axisCfg): [" + opClassName + "]   ["
+                    + opQName.toString() + "]  returning  [null]");
+        }
+
+        return null;
+    }
+
+
+    /**
+     * Find the AxisOperation object that matches the criteria
+     * 
+     * @param service    The AxisService object
+     * @param opClassName The class name string for the target object
+     *                   (could be a derived class)
+     * @param opQName    the name associated with the operation
+     * @return the AxisOperation object that matches the given criteria
+     */
+    public static AxisOperation findOperation(AxisService service, String opClassName,
+                                              QName opQName) {
+        if (service == null) {
+            return null;
+        }
+
+        Iterator ito = service.getOperations();
+
+        while (ito.hasNext()) {
+            AxisOperation operation = (AxisOperation) ito.next();
+
+            String tmpOpName = operation.getClass().getName();
+            QName tmpOpQName = operation.getName();
+
+            if ((tmpOpName.equals(opClassName)) && (tmpOpQName.equals(opQName))) {
+                // trace point
+                if (log.isTraceEnabled()) {
+                    log.trace("ObjectStateUtils:findOperation(service): returning  ["
+                            + opClassName + "]   [" + opQName.toString() + "]");
+                }
+
+                return operation;
+            }
+        }
+
+        // trace point
+        if (log.isTraceEnabled()) {
+            log.trace("ObjectStateUtils:findOperation(service): [" + opClassName + "]   ["
+                    + opQName.toString() + "]  returning  [null]");
+        }
+
+        return null;
+    }
+
+    /**
+     * Find the AxisMessage object that matches the criteria
+     * 
+     * @param op             The AxisOperation object
+     * @param msgName        The name associated with the message
+     * @param msgElementName The name associated with the message element
+     * @return the AxisMessage object that matches the given criteria
+     */
+    public static AxisMessage findMessage(AxisOperation op, String msgName, String msgElementName) {
+        // Several kinds of AxisMessages can be associated with a particular 
+        // AxisOperation.  The kinds of AxisMessages that are typically
+        // accessible are associated with "in" and "out".  
+        // There are also different kinds of AxisOperations, and each
+        // type of AxisOperation can have its own mix of AxisMessages
+        // depending on the style of message exchange pattern (mep)
+
+        if (op == null) {
+            // trace point
+            if (log.isTraceEnabled()) {
+                log.trace("ObjectStateUtils:findMessage(): [" + msgName + "]  [" + msgElementName
+                        + "] returning  [null] - no AxisOperation");
+            }
+
+            return null;
+        }
+
+        if (msgName == null) {
+            // nothing to match with, expect to match against a name
+            // trace point
+            if (log.isTraceEnabled()) {
+                log.trace("ObjectStateUtils:findMessage(): [" + msgName + "]  [" + msgElementName
+                        + "] returning  [null] - message name is not set");
+            }
+
+            return null;
+        }
+
+
+        String tmpName = null;
+        String tmpElementName = null;
+
+        //-------------------------------------
+        // first try the "out" message
+        //-------------------------------------
+        AxisMessage out = null;
+        try {
+            out = op.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
+        } catch (Exception ex) {
+            // just absorb the exception
+        }
+
+        if (out != null) {
+            tmpName = out.getName();
+
+            QName tmpQout = out.getElementQName();
+            if (tmpQout != null) {
+                tmpElementName = tmpQout.toString();
+            }
+        }
+
+        // check the criteria for a match
+
+        boolean matching = matchMessageNames(tmpName, tmpElementName, msgName, msgElementName);
+
+        if (matching) {
+            // trace point
+            if (log.isTraceEnabled()) {
+                log.trace("ObjectStateUtils:findMessage(): returning OUT message  [" + msgName
+                        + "]  [" + msgElementName + "] ");
+            }
+
+            return out;
+        }
+
+        //-------------------------------------
+        // next, try the "in" message 
+        //-------------------------------------
+        AxisMessage in = null;
+        try {
+            in = op.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE);
+        } catch (Exception ex) {
+            // just absorb the exception
+        }
+
+        if (in != null) {
+            tmpName = in.getName();
+
+            QName tmpQin = in.getElementQName();
+            if (tmpQin != null) {
+                tmpElementName = tmpQin.toString();
+            }
+        } else {
+            tmpName = null;
+            tmpElementName = null;
+        }
+
+        // check the criteria for a match
+
+        matching = matchMessageNames(tmpName, tmpElementName, msgName, msgElementName);
+
+        if (matching) {
+            // trace point
+            if (log.isTraceEnabled()) {
+                log.trace("ObjectStateUtils:findMessage(): returning IN message [" + msgName
+                        + "]  [" + msgElementName + "] ");
+            }
+
+            return in;
+        }
+
+        // if we got here, then no match was found
+
+        // trace point
+        if (log.isTraceEnabled()) {
+            log.trace("ObjectStateUtils:findMessage(): [" + msgName + "]  [" + msgElementName
+                    + "] returning  [null]");
+        }
+
+        return null;
+    }
+    
+    /**
+     * Find the Handler object that matches the criteria
+     * 
+     * @param existingHandlers The list of existing handlers and phases
+     * @param handlerClassName the class name string for the target object
+     *                   (could be a derived class)
+     * @return the Handler object that matches the criteria
+     */
+    public static Object findHandler(ArrayList existingHandlers, MetaDataEntry metaDataEntry) //String handlerClassName)
+    {
+
+        String title = "ObjectStateUtils:findHandler(): ";
+
+        String handlerClassName = metaDataEntry.getClassName();
+        String qNameAsString = metaDataEntry.getQNameAsString();
+
+        for (int i = 0; i < existingHandlers.size(); i++) {
+            if (existingHandlers.get(i) != null) {
+                String tmpClassName = existingHandlers.get(i).getClass().getName();
+                String tmpName = ((Handler) existingHandlers.get(i)).getName().toString();
+
+                if ((tmpClassName.equals(handlerClassName)) && (tmpName.equals(qNameAsString))) {
+                    // trace point
+                    if (log.isTraceEnabled()) {
+                        log.trace(title + " [" + handlerClassName + "]  name [" + qNameAsString
+                                + "]  returned");
+                    }
+
+                    return (Handler) (existingHandlers.get(i));
+                }
+            }
+        }
+
+        // trace point
+        if (log.isTraceEnabled()) {
+            log.trace(title + " [" + handlerClassName + "]  name [" + qNameAsString
+                    + "] was not found in the existingHandlers list");
+        }
+
+        return null;
+    }
+    
+    /**
+     * Find the TransportListener object that matches the criteria
+     * <p/>
+     * <B>Note<B> the saved meta information may not
+     * match up with any of the objects that
+     * are in the current AxisConfiguration object.
+     * 
+     * @param axisConfig The AxisConfiguration object
+     * @param listenerClassName the class name string for the target object
+     *                   (could be a derived class)
+     * @return the TransportListener object that matches the criteria
+     */
+    public static TransportListener findTransportListener(AxisConfiguration axisConfig,
+                                                          String listenerClassName) {
+        // TODO: investigate a better technique to match up with a TransportListener
+
+        HashMap transportsIn = axisConfig.getTransportsIn();
+
+        // get a collection of the values in the map
+        Collection values = transportsIn.values();
+
+        Iterator i = values.iterator();
+
+        while (i.hasNext()) {
+            TransportInDescription ti = (TransportInDescription) i.next();
+
+            TransportListener tl = ti.getReceiver();
+            String tlClassName = tl.getClass().getName();
+
+            if (tlClassName.equals(listenerClassName)) {
+                // trace point
+                if (log.isTraceEnabled()) {
+                    log.trace("ObjectStateUtils:findTransportListener():  [" + listenerClassName
+                            + "]  returned");
+                }
+
+                return tl;
+            }
+        }
+
+        // trace point
+        if (log.isTraceEnabled()) {
+            log.trace("ObjectStateUtils:findTransportListener(): returning  [null]");
+        }
+
+        return null;
+    }
+
+    /**
+     * Compares the two collections to see if they are equivalent.
+     * 
+     * @param a1  The first collection
+     * @param a2  The second collection
+     * @param strict  Indicates whether strict checking is required.  Strict
+     *                checking means that the two collections must have the
+     *                same elements in the same order.  Non-strict checking
+     *                means that the two collections must have the same 
+     *                elements, but the order is not significant.
+     * @return TRUE if the two collections are equivalent
+     *         FALSE, otherwise
+     */
+    public static boolean isEquivalent(ArrayList a1, ArrayList a2, boolean strict) {
+        if ((a1 != null) && (a2 != null)) {
+            // check number of elements in lists
+            int size1 = a1.size();
+            int size2 = a2.size();
+
+            if (size1 != size2) {
+                // trace point
+                if (log.isTraceEnabled()) {
+                    log.trace("ObjectStateUtils:isEquivalent(ArrayList,ArrayList): FALSE - size mismatch ["
+                            + size1 + "] != [" + size2 + "]");
+                }
+                return false;
+            }
+
+            if (strict) {
+                // Strict checking
+                // The lists must contain the same elements in the same order.
+                return (a1.equals(a2));
+            } else {
+                // Non-strict checking
+                // The lists must contain the same elements but the order is not required.
+                Iterator i1 = a1.iterator();
+
+                while (i1.hasNext()) {
+                    Object obj1 = i1.next();
+
+                    if (!a2.contains(obj1)) {
+                        // trace point
+                        if (log.isTraceEnabled()) {
+                            log.trace("ObjectStateUtils:isEquivalent(ArrayList,ArrayList): FALSE - mismatch with element ["
+                                    + obj1.getClass().getName() + "] ");
+                        }
+                        return false;
+                    }
+                }
+
+                return true;
+            }
+
+        } else if ((a1 == null) && (a2 == null)) {
+            return true;
+        } else if ((a1 != null) && (a2 == null)) {
+            if (a1.size() == 0) {
+                return true;
+            }
+            return false;
+        } else if ((a1 == null) && (a2 != null)) {
+            if (a2.size() == 0) {
+                return true;
+            }
+            return false;
+        } else {
+            // mismatch
+
+            // trace point
+            if (log.isTraceEnabled()) {
+                log.trace("ObjectStateUtils:isEquivalent(ArrayList,ArrayList): FALSE - mismatch in lists");
+            }
+            return false;
+        }
+    }
+
+    /**
+     * Compares the two collections to see if they are equivalent.
+     * 
+     * @param m1  The first collection
+     * @param m2  The second collection
+     * @param strict  Indicates whether strict checking is required.  Strict
+     *                checking means that the two collections must have the
+     *                same mappings.  Non-strict checking means that the 
+     *                two collections must have the same keys.  In both
+     *                cases, the order is not significant.
+     * @return TRUE if the two collections are equivalent
+     *         FALSE, otherwise
+     */
+    public static boolean isEquivalent(Map m1, Map m2, boolean strict) {
+        if ((m1 != null) && (m2 != null)) {
+            if (strict) {
+                // This is a strict test.
+                // Returns true if the given object is also a map and the two Maps 
+                // represent the same mappings. 
+                return (m1.equals(m2));
+            } else {
+                int size1 = m1.size();
+                int size2 = m2.size();
+
+                if (size1 != size2) {
+                    return false;
+                }
+
+                // check the keys, ordering is not important between the two maps
+                Iterator it1 = m1.keySet().iterator();
+
+                while (it1.hasNext()) {
+                    Object key1 = it1.next();
+
+                    if (m2.containsKey(key1) == false) {
+                        return false;
+                    }
+                }
+
+                return true;
+            }
+        } else if ((m1 == null) && (m2 == null)) {
+            return true;
+        } else {
+            // mismatch
+            return false;
+        }
+    }
+
+
+    /**
+     * Compares the two collections to see if they are equivalent.
+     * 
+     * @param l1  The first collection
+     * @param l2  The second collection
+     * @return TRUE if the two collections are equivalent
+     *         FALSE, otherwise
+     */
+    public static boolean isEquivalent(LinkedList l1, LinkedList l2) {
+        if ((l1 != null) && (l2 != null)) {
+            // This is a strict test.
+            // Returns true if the specified object is also a list, 
+            // both lists have the same size, and all corresponding pairs 
+            // of elements in the two lists are equal where
+            // they contain the same elements in the same order.
+            return (l1.equals(l2));
+        } else if ((l1 == null) && (l2 == null)) {
+            return true;
+        } else {
+            // mismatch
+            return false;
+        }
+    }
+    
+    /**
+     * Check the first set of names for a match against
+     * the second set of names.  These names are 
+     * associated with AxisMessage objects. Message names
+     * are expected to be non-null.  Element names could
+     * be either null or non-null.
+     * 
+     * @param name1  The name for the first message
+     * @param elementName1 The element name for the first message
+     * @param name2  The name for the second message
+     * @param elementName2 The element name for the second message
+     * @return TRUE if there's a match,
+     *         FALSE otherwise
+     */
+    private static boolean matchMessageNames(String name1, String elementName1, String name2,
+                                             String elementName2) {
+        // the name for the message must exist
+        if ((name1 != null) && (name2 != null) && (name1.equals(name2))) {
+            // there's a match on the name associated with the message object
+
+            // element names need to match, including being null
+            if ((elementName1 == null) && (elementName2 == null)) {
+                // there's a match for the nulls
+                return true;
+            } else if ((elementName1 != null) && (elementName2 != null)
+                    && (elementName1.equals(elementName2))) {
+                // there's a match for the element names
+                return true;
+            } else {
+                // there's some mismatch
+                return false;
+            }
+        } else {
+            // either a message name is null or the names don't match
+            return false;
+        }
+    }
+
+}
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/SafeObjectInputStream.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/SafeObjectInputStream.java	(revision 0)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/SafeObjectInputStream.java	(revision 0)
@@ -0,0 +1,383 @@
+/*
+ * Copyright 2004,2007 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.context.externalize;
+
+import org.apache.axis2.AxisFault;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.ObjectInput;
+import java.io.ObjectInputStream;
+import java.io.ObjectStreamConstants;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A SafeObjectInputStream reads data that was written by SafeObjectOutputStream
+ * 
+ * @see SafeObjectInput
+ */
+public class SafeObjectInputStream implements ObjectInput, ObjectStreamConstants {
+
+    private static final Log log = LogFactory.getLog(SafeObjectInputStream.class);
+    private static final boolean isDebug = log.isDebugEnabled();
+    
+    // All data is read from the delegated ObjectInput
+    ObjectInput in = null;
+    final ObjectInput original;
+    
+    // A buffer is used when Object is persisted as bytes
+    private byte[] buffer = null;
+    private final int BUFFER_MIN_SIZE = 4096;
+    
+    /**
+     * Add the SafeObjectInputStream if necessary
+     * @param in
+     * @return
+     */
+    public static SafeObjectInputStream install(ObjectInput in) {
+        if (in instanceof SafeObjectInputStream) {
+            return (SafeObjectInputStream) in;
+        }
+        return new SafeObjectInputStream(in);
+    }
+    
+    
+    /**
+     * Intentionally private.  Callers should use the install method to add the SafeObjectInputStream
+     * into the stream.
+     * @param in
+     */
+    private SafeObjectInputStream(ObjectInput in) {
+        original = in;
+        if (log.isDebugEnabled()) {
+            this.in = new DebugObjectInput(original);
+        } else {
+            this.in = original;
+        }
+    }
+    
+    //  Delegated Methods
+    public int available() throws IOException {
+        return in.available();
+    }
+    public void close() throws IOException {
+        in.close();
+    }
+    public int read() throws IOException {
+        return in.read();
+    }
+    public int read(byte[] b, int off, int len) throws IOException {
+        return in.read(b, off, len);
+    }
+    public int read(byte[] b) throws IOException {
+        return in.read(b);
+    }
+    public boolean readBoolean() throws IOException {
+        return in.readBoolean();
+    }
+    public byte readByte() throws IOException {
+        return in.readByte();
+    }
+    public char readChar() throws IOException {
+        return in.readChar();
+    }
+    public double readDouble() throws IOException {
+        return in.readDouble();
+    }
+    public float readFloat() throws IOException {
+        return in.readFloat();
+    }
+    public void readFully(byte[] b, int off, int len) throws IOException {
+        in.readFully(b, off, len);
+    }
+    public void readFully(byte[] b) throws IOException {
+        in.readFully(b);
+    }
+    public int readInt() throws IOException {
+        return in.readInt();
+    }
+    public String readLine() throws IOException {
+        return in.readLine();
+    }
+    public long readLong() throws IOException {
+        return in.readLong();
+    }
+    public Object readObject() throws ClassNotFoundException, IOException {
+        return readObjectOverride();
+    }
+    public short readShort() throws IOException {
+        return in.readShort();
+    }
+    public int readUnsignedByte() throws IOException {
+        return in.readUnsignedByte();
+    }
+    public int readUnsignedShort() throws IOException {
+        return in.readUnsignedShort();
+    }
+    public String readUTF() throws IOException {
+        return in.readUTF();
+    }
+    public long skip(long n) throws IOException {
+        return in.skip(n);
+    }
+    public int skipBytes(int n) throws IOException {
+        return in.skipBytes(n);
+    }
+    
+    // Value Add Methods
+    
+    /**
+     * Read the input stream and place the key/value pairs in a hashmap
+     * @return HashMap or null
+     * @throws IOException
+     * @see SafeObjectOutputStream.writeMap()
+     */
+    public HashMap readHashMap() throws IOException  {
+        HashMap hashMap = new HashMap();
+        return (HashMap) readMap(hashMap);
+    }
+    
+    /**
+     * Read the input stream and place the key/value pairs in the
+     * indicated Map
+     * @param map input map
+     * @return map or null
+     * @throws IOException
+     * @see SafeObjectOutputStream.writeMap()
+     */
+    public Map readMap(Map map) throws IOException {
+        boolean isActive = in.readBoolean();
+        if (!isActive) {
+            return null;
+        }
+        
+        while (in.readBoolean()) {
+            Object key = null;
+            Object value = null;
+
+            boolean isObjectForm = in.readBoolean();
+            try {
+                if (isObjectForm) {
+                    if (isDebug) {
+                        log.debug(" reading using object form");
+                    }
+                    // Read the key and value directly
+                    key = in.readObject();
+                    value = in.readObject();
+                } else {
+                    if (isDebug) {
+                        log.debug(" reading using byte form");
+                    }
+                    // Get the byte stream
+                    ByteArrayInputStream bais = getByteStream(in);
+
+                    // Now get the real key and value
+                    ObjectInputStream tempOIS = createObjectInputStream(bais);
+                    key = tempOIS.readObject();
+                    value = tempOIS.readObject();
+                    tempOIS.close();
+                    bais.close();
+                }
+                // Put the key and value in the map
+                if (isDebug) {
+                    log.debug("Read key=" + key + " value="+value);
+                }
+                map.put(key, value);
+            } catch (ClassNotFoundException e) {
+                // Swallow the error and try to continue
+                log.error(e);
+            } catch (IOException e) {
+                throw e;
+            } catch (Exception e) {
+                throw AxisFault.makeFault(e);
+            }
+        }
+        return map;
+    }
+    
+    /**
+     * Read the input stream and place objects in an ArrayList
+     * @return ArrayList or null
+     * @throws IOException
+     * @see SafeObjectInputStream.writeList()
+     */
+    public ArrayList readArrayList() throws IOException {
+        List ll = new ArrayList();
+        return (ArrayList) readList(ll);
+    }
+    
+    /**
+     * Read the input stream and place objects in a LinkedList
+     * @return LinkedList or null
+     * @throws IOException
+     * @see SafeObjectInputStream.writeList()
+     */
+    public LinkedList readLinkedList() throws IOException {
+       List ll = new LinkedList();
+       return (LinkedList) readList(ll);
+    }
+    
+    /**
+     * Read hte input stream and place objects in the specified List
+     * @param list List
+     * @return List or null
+     * @throws IOException
+     * @see SafeObjectInputStream.writeList()
+     */
+    public List readList(List list) throws IOException {
+        boolean isActive = in.readBoolean();
+        if (!isActive) {
+            return null;
+        }
+        
+        while (in.readBoolean()) {
+            Object value;
+            boolean isObjectForm = in.readBoolean();
+            try {
+                if (isObjectForm) {
+                    if (isDebug) {
+                        log.debug(" reading using object form");
+                    }
+                    // Read the value directly
+                    value = in.readObject();
+                } else {
+                    if (isDebug) {
+                        log.debug(" reading using byte form");
+                    }
+                    // Get the byte stream
+                    ByteArrayInputStream bais = getByteStream(in);
+
+                    // Now get the real key and value
+                    ObjectInputStream tempOIS = createObjectInputStream(bais);
+                    value = tempOIS.readObject();
+                    tempOIS.close();
+                    bais.close();
+                }
+                // Put the key and value in the map
+                if (isDebug) {
+                    log.debug("Read value="+value);
+                }
+                list.add(value);
+            } catch (IOException e) {
+                throw e;
+            } catch (Exception e) {
+                throw AxisFault.makeFault(e);
+            }
+        }
+        return list;
+    }
+    
+    /**
+     * Reads the object using the same format that was written.
+     * 
+     * EXPECTED FORMATS
+     *   boolean=false
+     *   return null Object
+     *   
+     *   
+     *   boolean=true
+     *   boolean=true
+     *   return Object read from inputStream
+     *   
+     *   
+     *   boolean=true
+     *   boolean=false
+     *   int=nuber of bytes
+     *   bytes
+     *   return Object read from bytes
+     *   
+     * @return Object or null
+     * @throws IOException
+     * @throws ClassNotFoundException
+     */
+    private Object readObjectOverride() throws IOException, ClassNotFoundException {
+        boolean isActive = in.readBoolean();
+        if (!isActive) {
+            if (isDebug) {
+                log.debug("Read object=null");
+            }
+            return null;
+        }
+        Object obj = null;
+        boolean isObjectForm = in.readBoolean();
+        if (isObjectForm) {
+            // Read the object directly
+            if (isDebug) {
+                log.debug(" reading using object form");
+            }
+            obj = in.readObject();
+        } else {
+            if (isDebug) {
+                log.debug(" reading using byte form");
+            }
+            // Get the byte stream
+            ByteArrayInputStream bais = getByteStream(in);
+
+            // Now get the real object
+            ObjectInputStream tempOIS = createObjectInputStream(bais);
+            obj = tempOIS.readObject();
+            tempOIS.close();
+            bais.close();
+        }
+        
+        if (isDebug) {
+            log.debug("Read object=" + obj);
+        }
+        return obj;   
+        
+    }
+    
+    /**
+     * Get the byte stream for an object that is written using the 
+     * byte format.  
+     * EXPECTED format
+     *     int (number of bytes)
+     *     bytes 
+     *     
+     * @param in
+     * @return
+     * @throws IOException
+     * @throws ClassNotFoundException
+     */
+    private ByteArrayInputStream getByteStream(ObjectInput in) throws IOException, ClassNotFoundException {
+        
+        // Read the length
+        int size = in.readInt();
+        
+        // Fill our temporary buffer
+        if (buffer == null || buffer.length < size) {
+            int allocSize = (size > BUFFER_MIN_SIZE) ? size : BUFFER_MIN_SIZE;
+            buffer = new byte[allocSize];
+        }
+        in.readFully(buffer, 0, size);
+        
+        // Return a stream backed by the buffer
+        return new ByteArrayInputStream(buffer, 0, size);
+    }
+    
+    private ObjectInputStream createObjectInputStream(InputStream is) throws IOException {
+        // The created ObjectInputStream must use the same class/object resolution 
+        // code that is used by the original ObjectInput
+        return new ObjectInputStreamWithCL(is);
+    }
+}
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/SafeObjectOutputStream.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/SafeObjectOutputStream.java	(revision 0)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/SafeObjectOutputStream.java	(revision 0)
@@ -0,0 +1,757 @@
+/*
+ * Copyright 2004,2007 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.context.externalize;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
+import java.io.Flushable;
+import java.io.IOException;
+import java.io.NotSerializableException;
+import java.io.ObjectOutput;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamConstants;
+import java.io.Serializable;
+import java.io.ObjectOutputStream.PutField;
+import java.util.Hashtable;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A SafeObjectOutputStream provides extra mechanisms to ensure that 
+ * objects can be safely serialized to the ObjectOutput.
+ * 
+ * If an Object is written to a normal ObjectOutput, the ObjectOutput is left in 
+ * an unknown state if a NotSerializableException occurs.
+ * 
+ * The SafeObjectOutputStream does some additonal checking to ensure that the Object can
+ * be safely written.  If the Object is suspicious, it is first written to a buffer to ensure
+ * that the underlying ObjectOutput is not corrupted.
+ * 
+ * In addition, SafeObjectOutputStream provides extra methods to write containers of Objects.
+ * For example the writeMap object will write the key and value pairs that are can be serialized.
+ * 
+ * @see SafeObjectInputStream
+ *
+ */
+public class SafeObjectOutputStream implements Closeable, Flushable, ObjectOutput,
+        ObjectStreamConstants, ExternalizeConstants {
+    
+    private static final Log log = LogFactory.getLog(SafeObjectOutputStream.class);
+    private static final boolean isDebug = log.isDebugEnabled();
+    
+    // Actual Stream 
+    private ObjectOutput out = null;
+    
+    // There are two ways to write out an object, a series of bytes or an Object.  
+    // These flags are embedded in the stream so that the reader knows which form was used.
+    private static final boolean FORM_BYTE = false;
+    private static final boolean FORM_OBJECT = true;
+    
+    // Temporary ObjectOutputStream for
+    MyOOS tempOOS = null;
+    
+    // As a way to improve performance and reduce trace logging with
+    // extra exceptions, keep a table of classes that are not serializable
+    // and only log the first time it that the class is encountered in
+    // an NotSerializableException
+    // note that the Hashtable is synchronized by Java so we shouldn't need to 
+    // do extra control over access to the table
+    public static Hashtable notSerializableList = new Hashtable();
+    
+    /**
+     * Add the SafeOutputStream if necessary.
+     * @param out Current ObjectOutput
+     * @return
+     * @throws IOException
+     */
+    public static SafeObjectOutputStream install(ObjectOutput out) throws IOException {
+        if (out instanceof SafeObjectOutputStream) {
+            return (SafeObjectOutputStream) out;
+        }
+        return new SafeObjectOutputStream(out);
+    }
+    
+    /**
+     * Intentionally private.  
+     * Callers should use the install method to add the SafeObjectOutputStream
+     * into the stream.
+     * @param oo
+     * @throws IOException
+     */
+    private SafeObjectOutputStream(ObjectOutput oo) throws IOException {
+        if (log.isDebugEnabled()) {
+            this.out = new DebugObjectOutputStream(oo);
+        } else {
+            this.out = oo;
+        }
+    }
+
+    // START DELEGATE METHODS
+    public void close() throws IOException {
+        if (tempOOS != null) {
+            tempOOS.close();
+            tempOOS = null;
+        }
+        out.close();
+    }
+
+    public void defaultWriteObject() throws IOException {
+        if (out instanceof ObjectOutputStream) {
+            ((ObjectOutputStream)out).defaultWriteObject();
+        }
+    }
+
+    public boolean equals(Object o) {
+        return out.equals(o);
+    }
+
+    public void flush() throws IOException {
+        out.flush();
+    }
+
+    public int hashCode() {
+        return out.hashCode();
+    }
+
+    public PutField putFields() throws IOException {
+        if (out instanceof ObjectOutputStream) {
+            return ((ObjectOutputStream)out).putFields();
+        } else {
+            throw new IOException("This method is not supported.");
+        }
+            
+    }
+
+    public void reset() throws IOException {
+        if (out instanceof ObjectOutputStream) {
+            ((ObjectOutputStream)out).reset();
+        }
+    }
+
+    public String toString() {
+        return out.toString();
+    }
+
+    public void useProtocolVersion(int version) throws IOException {
+        if (out instanceof ObjectOutputStream) {
+            ((ObjectOutputStream)out).useProtocolVersion(version);
+        }
+    }
+
+    public void write(byte[] buf, int off, int len) throws IOException {
+        out.write(buf, off, len);
+    }
+
+    public void write(byte[] buf) throws IOException {
+        out.write(buf);
+    }
+
+    public void write(int val) throws IOException {
+        out.write(val);
+    }
+
+    public void writeBoolean(boolean val) throws IOException {
+        out.writeBoolean(val);
+    }
+
+    public void writeByte(int val) throws IOException {
+        out.writeByte(val);
+    }
+
+    public void writeBytes(String str) throws IOException {
+        out.writeBytes(str);
+    }
+
+    public void writeChar(int val) throws IOException {
+        out.writeChar(val);
+    }
+
+    public void writeChars(String str) throws IOException {
+        out.writeChars(str);
+    }
+
+    public void writeDouble(double val) throws IOException {
+        out.writeDouble(val);
+    }
+
+    public void writeFields() throws IOException {
+        if (out instanceof ObjectOutputStream) {
+            ((ObjectOutputStream)out).writeFields();
+        }
+    }
+
+    public void writeFloat(float val) throws IOException {
+        out.writeFloat(val);
+    }
+
+    public void writeInt(int val) throws IOException {
+        out.writeInt(val);
+    }
+
+    public void writeLong(long val) throws IOException {
+        out.writeLong(val);
+    }
+
+    public void writeObject(Object obj) throws IOException {
+        writeObject(obj, false);  // Assume object is not safe
+    }
+
+    public void writeShort(int val) throws IOException {
+        out.writeShort(val);
+    }
+
+    public void writeUTF(String str) throws IOException {
+        out.writeUTF(str);
+    }
+
+    // END DELEGATE METHODS
+    
+    /**
+     * Write a map
+     * 
+     * FORMAT for null map
+     *     EMPTY_OBJECT
+     *     
+     * FORMAT for non-empty map
+     *     ACTIVE_OBJECT
+     *     for each contained key value pair
+     *        writePair
+     *     EMPTY_OBJECT (indicates end of the list
+     * 
+     * @param ll
+     * @return
+     * @throws IOException
+     */
+    public boolean writeMap(Map map) throws IOException {
+        
+        if (map == null) {
+            out.writeBoolean(EMPTY_OBJECT);
+            return false;
+        } else {
+            out.writeBoolean(ACTIVE_OBJECT);
+            // TODO Change to entry set to avoid second lookup
+            Iterator it = map.keySet().iterator();
+
+            while (it.hasNext()) {
+                Object key = it.next();
+                Object value = map.get(key);
+                writePair(key, false, value, false);
+            }
+            // Empty object indicates end of list
+            out.writeBoolean(EMPTY_OBJECT);
+        }
+        return true;
+    }
+    
+    /**
+     * Write a list.
+     * 
+     * FORMAT for null list
+     *     EMPTY_OBJECT
+     *     
+     * FORMAT for non-empty list
+     *     ACTIVE_OBJECT
+     *     for each contained object
+     *        ACTOVE_OBJECT
+     *        writeObject
+     *     EMPTY_OBJECT (indicates end of the list
+     * 
+     * @param ll
+     * @return
+     * @throws IOException
+     */
+    public boolean writeList(List al) throws IOException {
+        if (al == null) {
+            out.writeBoolean(EMPTY_OBJECT);
+            return false;
+        } else {
+            out.writeBoolean(ACTIVE_OBJECT);
+            Iterator it = al.iterator();
+
+            while (it.hasNext()) {
+                Object value = it.next();
+                writeItem(value, false);
+            }
+            // Empty object indicates end of list
+            out.writeBoolean(EMPTY_OBJECT);
+        }
+        return true;
+    }
+    
+    /**
+     * Writes an object to the stream.
+     * If the object is known (apriori) to be completely serializable it
+     * is "safe".  Safe objects are written directly to the stream.
+     * Objects that are not known are to be safe are tested for safety and 
+     * only written if they are deemed safe.  Unsafe objects are not written.
+     * Note: The java.io.ObjectOutputStream is left in an unrecoverable state
+     * if any object written to it causes a serialization error.  So please
+     * use the isSafe parameter wisely
+     * 
+     * FORMAT for NULL Object
+     *    EMPTY_OBJECT
+     *   
+     * FORMAT for non-serializable Object
+     *    EMPTY_OBJECT
+     *    
+     * FORMAT for safe serializable Object
+     *    ACTIVE_OBJECT
+     *    FORM_OBJECT
+     *    Object
+     *    
+     * FORMAT for other serializable Object
+     *    ACTIVE_OBJECT
+     *    FORM_BYTE
+     *    length of bytes
+     *    bytes representing the object
+     *   
+     * @param obj
+     * @param isSafe true if you know that object can be safely serialized. false if the 
+     * object needs to be tested for serialization.
+     * @returns true if written
+     * @throws IOException
+     */
+    private boolean writeObject(Object obj, 
+                       boolean isSafe) throws IOException {
+        
+        if (isDebug) {
+            log.debug("Writing object:" + obj);
+        }
+        
+        // Shortcut for null objects
+        if (obj == null) {
+            out.writeBoolean(EMPTY_OBJECT);
+            return false;
+        }
+        // Shortcut for non-serializable objects
+        if (!isSafe) {
+            if (!isSerializable(obj)) {
+                out.writeBoolean(EMPTY_OBJECT);
+                return false;
+            }
+        }
+        
+        // If not safe, see if there are characteristics of the Object
+        // that guarantee that it can be safely serialized 
+        // (for example Strings are always serializable)
+        if (!isSafe) {
+            isSafe = isSafeSerializable(obj);
+        }
+        if (isSafe) {
+            // Use object form
+            if (isDebug) {
+                log.debug("  write using object form");
+            }
+            out.writeBoolean(ACTIVE_OBJECT);  
+            out.writeBoolean(FORM_OBJECT);
+            out.writeObject(obj);
+        } else {
+
+            // Fall-back to byte form
+            if (isDebug) {
+                log.debug("  write using byte form");
+            }
+            MyOOS tempOOS;
+            try {
+                tempOOS = writeTempOOS(obj);
+            } catch (IOException e) {
+                // Put a EMPTY object in the file
+                out.writeBoolean(EMPTY_OBJECT);
+                throw e;
+            }
+            if (tempOOS == null) {
+                out.writeBoolean(EMPTY_OBJECT);
+                return false;
+            } 
+
+            out.writeBoolean(ACTIVE_OBJECT);   
+            out.writeBoolean(FORM_BYTE);
+            tempOOS.write(out);
+            resetOnSuccess();
+        }
+        return true;
+    }
+    
+    
+    /**
+     * Writes pair of objects to the stream.
+     * 
+     * If the objects are known (apriori) to be completely serializable they 
+     * are "safe".  Safe objects are written directly to the stream.
+     * Objects that are not known are to be safe are tested for safety and 
+     * only written if they are deemed safe.  Unsafe objects are not written.
+     * Note: The java.io.ObjectOutputStream is left in an unrecoverable state
+     * if any object written to it causes a serialization error.  So please
+     * use the isSafe parameter wisely
+     * 
+     *   
+     * FORMAT for non-serializable key/value pair
+     *    nothing is written
+     *    
+     * FORMAT for safe serializable key/value pair
+     *    ACTIVE_OBJECT
+     *    FORM_OBJECT
+     *    Object
+     *    
+     * FORMAT for other serializable key/value pair
+     *    ACTIVE_OBJECT
+     *    FORM_BYTE
+     *    length of bytes
+     *    bytes representing the object
+     *    
+     * @param obj1
+     * @param isSafe1 true if you know that object can be safely serialized. false if the 
+     * object needs to be tested for serialization.
+     * @param obj2
+     * @param isSafe2 true if you know that object can be safely serialized. false if the 
+     * object needs to be tested for serialization.
+     * @returns true if both are written to the stream
+     * @throws IOException
+     */
+    public boolean writePair(Object obj1, 
+                       boolean isSafe1, 
+                       Object obj2,
+                       boolean isSafe2) throws IOException {
+        
+        if (isDebug) {
+            log.debug("Writing key=" + obj1 + " value="+obj2);
+        }
+        // Shortcut for non-serializable objects
+        if ((!isSafe1 && !isSerializable(obj1)) ||
+             (!isSafe2 && !isSerializable(obj2))) {
+            return false;
+        }
+
+        boolean isSafe = (isSafe1 || isSafeSerializable(obj1)) && 
+            (isSafe2 || isSafeSerializable(obj2));
+
+        if (isSafe) {
+            if (isDebug) {
+                log.debug("  write using object form");
+            }
+            out.writeBoolean(ACTIVE_OBJECT);
+            out.writeBoolean(FORM_OBJECT);
+            out.writeObject(obj1);
+            out.writeObject(obj2);
+        } else {
+            if (isDebug) {
+                log.debug("  write using byte form");
+            }
+            MyOOS tempOOS = writeTempOOS(obj1, obj2);
+            if (tempOOS == null) {
+                return false;
+            } 
+            out.writeBoolean(ACTIVE_OBJECT);
+            out.writeBoolean(FORM_BYTE);
+            tempOOS.write(out);
+            resetOnSuccess();
+        }
+        return true;
+    }
+    
+    /**
+     * Writes pair of objects to the stream.
+     * 
+     * If the objects are known (apriori) to be completely serializable they 
+     * are "safe".  Safe objects are written directly to the stream.
+     * Objects that are not known are to be safe are tested for safety and 
+     * only written if they are deemed safe.  Unsafe objects are not written.
+     * Note: The java.io.ObjectOutputStream is left in an unrecoverable state
+     * if any object written to it causes a serialization error.  So please
+     * use the isSafe parameter wisely
+     * 
+     *   
+     * FORMAT for non-serializable key/value pair
+     *    nothing is written
+     *    
+     * FORMAT for safe serializable key/value pair
+     *    ACTIVE_OBJECT
+     *    FORM_OBJECT
+     *    Object
+     *    
+     * FORMAT for other serializable key/value pair
+     *    ACTIVE_OBJECT
+     *    FORM_BYTE
+     *    length of bytes
+     *    bytes representing the object
+     *    
+     * @param obj1
+     * @param isSafe1 true if you know that object can be safely serialized. false if the 
+     * object needs to be tested for serialization.
+     * @param obj2
+     * @param isSafe2 true if you know that object can be safely serialized. false if the 
+     * object needs to be tested for serialization.
+     * @returns true if both are written to the stream
+     * @throws IOException
+     */
+    public boolean writeItem(Object obj, 
+                       boolean isSafe) throws IOException {
+        
+        if (isDebug) {
+            log.debug("Writing obj=" + obj);
+        }
+        // Shortcut for non-serializable objects
+        if (!isSafe && !isSerializable(obj)) {
+            return false;
+        }
+
+        isSafe = (isSafe || isSafeSerializable(obj));
+
+        if (isSafe) {
+            if (isDebug) {
+                log.debug("  write using object form");
+            }
+            out.writeBoolean(ACTIVE_OBJECT);
+            out.writeBoolean(FORM_OBJECT);
+            out.writeObject(obj);
+        } else {
+            if (isDebug) {
+                log.debug("  write using byte form");
+            }
+            MyOOS tempOOS;
+            try {
+                tempOOS = writeTempOOS(obj);
+            } catch (RuntimeException e) {
+                return false;
+            }
+            if (tempOOS == null) {
+                return false;
+            } 
+            out.writeBoolean(ACTIVE_OBJECT);
+            out.writeBoolean(FORM_BYTE);
+            tempOOS.write(out);
+            resetOnSuccess();
+        }
+        return true;
+    }
+    
+    /**
+     * Does a quick check of the implemented interfaces to ensure that this 
+     * object is serializable
+     * @return true if the object is marked as Serializable 
+     */
+    private static boolean isSerializable(Object obj) {
+        boolean isSerializable = (obj == null) || obj instanceof Serializable;
+        if (!isSerializable) {
+            markNotSerializable(obj);
+        }
+        return isSerializable;
+    }
+    
+    /**
+     * Does a quick check of the implemented class is safe to serialize without 
+     * buffering.
+     * @return true if the object is marked as safe.
+     */
+    private static boolean isSafeSerializable(Object obj) {
+        
+        boolean isSafeSerializable = (obj == null) || 
+            obj instanceof SafeSerializable ||
+            obj instanceof String ||
+            obj instanceof Integer ||
+            obj instanceof Boolean ||
+            obj instanceof Long;
+        return isSafeSerializable;
+    }
+    
+    
+    /**
+     * Write the object to a temporary ObjectOutput
+     * @param obj
+     * @return ObjectOutput if successful
+     */
+    private MyOOS writeTempOOS(Object obj) throws IOException {
+        MyOOS oos = null;
+        
+        try {
+            oos = getTempOOS();
+            oos.writeObject(obj);
+            oos.flush();
+        } catch (NotSerializableException nse2) {
+            markNotSerializable(obj);
+            if (oos != null) {
+                resetOnFailure();
+                oos = null;
+            }
+            throw nse2;
+        } catch (IOException e) {
+            if (oos != null) {
+                resetOnFailure();
+                oos = null;
+            }
+            throw e;
+        } catch (RuntimeException e) {
+            if (oos != null) {
+                resetOnFailure();
+                oos = null;
+            }
+            throw e;
+        }
+        return oos;
+    }
+    
+    /**
+     * Write the objects to a temporary ObjectOutput
+     * @param obj1
+     * @param obj2
+     * @return ObjectOutput if successful
+     */
+    private MyOOS writeTempOOS(Object obj1, Object obj2) throws IOException {
+        MyOOS oos = null;
+        boolean first = true;
+        try {
+            oos = getTempOOS();
+            oos.writeObject(obj1);
+            first = false;
+            oos.writeObject(obj2);
+            oos.flush();
+        } catch (NotSerializableException nse2) {
+            // This is okay and expected in some cases.
+            // Log the error and continue
+            markNotSerializable((first) ? obj1 :obj2);
+            if (oos != null) {
+                resetOnFailure();
+                oos = null;
+            }
+        } catch (IOException e) {
+            if (oos != null) {
+                resetOnFailure();
+                oos = null;
+            }
+            throw e;
+        } catch (RuntimeException e) {
+            if (oos != null) {
+                resetOnFailure();
+                oos = null;
+            }
+            throw e;
+        }
+        return oos;
+    }
+    
+    /**
+     * Get or create a temporary ObjectOutputStream
+     * @return MyOOS
+     * @throws IOException
+     */
+    private MyOOS getTempOOS() throws IOException {
+        if (tempOOS == null) {
+            tempOOS = new MyOOS(new MyBAOS());
+        }
+        return tempOOS;
+    }
+    
+    /**
+     * If a failure occurs, reset the temporary ObjectOutputStream
+     */
+    private void resetOnFailure() throws IOException {
+        if (tempOOS != null) {
+            tempOOS.close();
+            tempOOS = null;  // The ObjectOutput is in an unknown state and thus discarded
+        }
+    }
+    
+    /**
+     * Reset the temporary ObjectOutputStream
+     * @throws IOException
+     */
+    private void resetOnSuccess() throws IOException {
+        tempOOS.reset();
+    }
+    
+    private static void markNotSerializable(Object obj) {
+        if (!isDebug) {
+            return;
+        }
+        if (obj != null) {
+            String name = obj.getClass().getCanonicalName();
+            Object value = notSerializableList.get(name);
+            if (value == null) {
+                notSerializableList.put(name, name);
+                if (log.isTraceEnabled()) {
+                    log.trace("***NotSerializableException*** [" + name + "]");
+                }
+            }
+        }
+    }
+    
+    /**
+     * MyBAOS is a ByteArrayOutputStream with a few additions.
+     *
+     */
+    class MyBAOS extends ByteArrayOutputStream {
+        /**
+         * Return direct access to the buffer without creating a copy of the byte[]
+         * @return buf
+         */
+        public byte[] getBytes() {
+            return buf;
+        }
+        /**
+         * Reset to a specific index in the buffer
+         * @param count
+         */
+        public void reset(int count) {
+            this.count = count;
+        }
+    }
+    
+    
+    /**
+     * MyOOS is an ObjectOutputStream with a few performant additions.
+     *
+     */
+    class MyOOS extends ObjectOutputStream {
+        MyBAOS baos;
+        int dataOffset;
+        MyOOS(MyBAOS baos) throws IOException {
+            super(baos);
+            flush();
+            this.baos = baos;
+            
+            // Capture the data offset 
+            // (the location where data starts..which is after header information)
+            dataOffset = baos.size();
+        }
+        
+        /**
+         * Override the reset so that we can reset to the data offset.
+         */
+        public void reset() throws IOException {
+            super.reset();
+            // Reset the byte stream to the position past the headers
+            baos.reset(dataOffset);
+        }
+        
+        /**
+         * Write the contents of MyOOS to the indicated ObjectOutput.
+         * Note that this direct write avoids any byte[] buffer creation
+         * @param out
+         * @throws IOException
+         */
+        public void write(ObjectOutput out) throws IOException {
+            out.flush();
+            // out.writeObject(out.toByteArray());
+            out.writeInt(baos.size());
+            out.write(baos.getBytes(),0,baos.size());
+        }
+    }
+
+}
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/SafeSerializable.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/SafeSerializable.java	(revision 0)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/SafeSerializable.java	(revision 0)
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2004,2007 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.context.externalize;
+
+import java.io.Serializable;
+
+/**
+ * This is a marker interface that indicates that the Object
+ * and all contents of the Object can be serialized safely without
+ * buffering. 
+ * 
+ * @See SafeObjectOutputStream
+ *
+ */
+public interface SafeSerializable extends Serializable {
+
+}
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/ExternalizeConstants.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/ExternalizeConstants.java	(revision 0)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/ExternalizeConstants.java	(revision 0)
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2004,2007 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.context.externalize;
+
+/**
+ * Common Externalize Constants
+ */
+public interface ExternalizeConstants {
+    
+    // Objects are preceeded by a bit indicating if the object is empty or active
+    public static final boolean EMPTY_OBJECT = false;  // null object or empty object
+    public static final boolean ACTIVE_OBJECT = true;  // otherwise it is an active object
+    
+    // used to indicate the end of a list
+    public static String LAST_ENTRY = "LAST_OBJ";
+
+    // used to indicate an "empty" object
+    public static String EMPTY_MARKER = "EMPTY_OBJ";
+    
+    //  message/trace/logging strings
+    public static final String UNSUPPORTED_SUID = "Serialization version ID is not supported.";
+    public static final String UNSUPPORTED_REVID = "Revision ID is not supported.";
+
+    public static final String OBJ_SAVE_PROBLEM =
+            "The object could not be saved to the output stream.  The object may or may not be important for processing the message when it is restored. Look at how the object is to be used during message processing.";
+    public static final String OBJ_RESTORE_PROBLEM =
+            "The object could not be restored from the input stream.  The object may or may not be important for processing the message when it is restored. Look at how the object is to be used during message processing.";
+
+}
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/DebugObjectOutputStream.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/DebugObjectOutputStream.java	(revision 0)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/DebugObjectOutputStream.java	(revision 0)
@@ -0,0 +1,156 @@
+/*
+ * Copyright 2004,2007 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.context.externalize;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.Closeable;
+import java.io.Flushable;
+import java.io.IOException;
+import java.io.ObjectOutput;
+import java.io.ObjectStreamConstants;
+
+/**
+ * DebugObjectOutputStream delegates to an ObjectOutput object.
+ * Each method logs in/out trace information
+ */
+public class DebugObjectOutputStream implements ObjectStreamConstants, ObjectOutput, Closeable,
+        Flushable {
+    private static final Log log = LogFactory.getLog(DebugObjectOutputStream.class);
+    private static final boolean isDebug = log.isDebugEnabled();
+    ObjectOutput out;
+    
+    DebugObjectOutputStream(ObjectOutput out) throws IOException {
+        super();
+        trace("--START DebugOutputStream--");
+        this.out = out;
+    }
+
+    public void close() throws IOException {
+        trace("--CLOSE DebugOutputStream--");
+        out.close();
+    }
+
+    public void flush() throws IOException {
+        trace ("start flush()");
+        out.flush();
+        trace ("end flush()");
+    }
+
+    public void write(byte[] b, int off, int len) throws IOException {
+        trace ("start write(b, off, len) off=" + off + " len=" + len);
+        if (len > 4) {
+            trace (" first four bytes = '" + 
+                   b[off] + "' '" + 
+                   b[off+1] + "' '" +
+                   b[off+2] + "' '" +
+                   b[off+3] + "'");
+        }
+        out.write(b, off, len);
+        trace ("end write(b, off, len)");
+    }
+
+    public void write(byte[] b) throws IOException {
+        trace ("start write(byte) byte=" + b);
+        out.write(b);
+        trace ("end write(b)");
+    }
+
+    public void write(int b) throws IOException {
+        trace ("start write(int) int=" + b);
+        out.write(b);
+        trace ("end write(int)");
+    }
+
+    public void writeBoolean(boolean v) throws IOException {
+        trace ("start writeBoolean(v) v=" + v);
+        out.writeBoolean(v);
+        trace ("end writeBoolean(v)");
+    }
+
+    public void writeByte(int v) throws IOException {
+        trace ("start writeByte(v) v=" + v);
+        out.writeByte(v);
+        trace ("end writeByte(v)");
+    }
+
+    public void writeBytes(String s) throws IOException {
+        trace ("start writeBytes(s) s=" + s);
+        out.writeBytes(s);
+        trace ("end writeBytes(s)");
+    }
+
+    public void writeChar(int v) throws IOException {
+        trace ("start writeChar(v) v=" + v);
+        out.writeChar(v);
+        trace ("end writeChar(v)");
+    }
+
+    public void writeChars(String s) throws IOException {
+        trace ("start writeChars(s) s=" + s);
+        out.writeChars(s);
+        trace ("end writeChars(s)");
+    }
+
+    public void writeDouble(double v) throws IOException {
+        trace ("start writeDouble(v) v=" + v);
+        out.writeDouble(v);
+        trace ("end writeDouble(v)");
+    }
+
+    public void writeFloat(float v) throws IOException {
+        trace ("start writeFloat(v) v=" + v);
+        out.writeFloat(v); 
+        trace ("end writeFloat(v)");
+    }
+
+    public void writeInt(int v) throws IOException {
+        trace ("start writeInt(v) v=" + v);
+        out.writeInt(v);
+        trace ("end writeInt(v)");
+    }
+
+    public void writeLong(long v) throws IOException {
+        trace ("start writeLong(v) v=" + v);
+        out.writeLong(v);
+        trace ("end writeLong(v)");
+    }
+
+    public void writeObject(Object obj) throws IOException {
+        trace ("start writeObject(v) v=" + obj);
+        out.writeObject(obj);
+        trace ("end writeObject(v)");
+    }
+
+    public void writeShort(int v) throws IOException {
+        trace ("start writeShort(v) v=" + v);
+        out.writeShort(v);
+        trace ("end writeShort(v)");
+    }
+
+    public void writeUTF(String str) throws IOException {
+        trace ("start writeUTF(v) v=" + str);
+        out.writeUTF(str);
+        trace ("end writeUTF(v)");
+    }
+    
+    public void trace(String str) {
+        if (isDebug) {
+            log.debug(str);
+        }
+    }
+}
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/DebugObjectInput.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/DebugObjectInput.java	(revision 0)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/DebugObjectInput.java	(revision 0)
@@ -0,0 +1,198 @@
+/*
+ * Copyright 2004,2007 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.context.externalize;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectStreamConstants;
+
+/**
+ * DebugObjectInput delegates to an ObjectInput object.
+ * Each method logs in/out trace information.
+ */
+public class DebugObjectInput implements ObjectInput, ObjectStreamConstants {
+    
+    private static final Log log = LogFactory.getLog(DebugObjectInput.class);
+    private static final boolean isDebug = log.isDebugEnabled();
+    ObjectInput oi; // delegate
+
+    public DebugObjectInput(ObjectInput oi) {
+        super();
+        this.oi = oi;
+    }
+
+    public int available() throws IOException {
+        trace("start available()");
+        int value = oi.available();
+        trace("end available() =" + value);
+        return value;
+    }
+
+    public void close() throws IOException {
+        trace("start close()");
+        oi.close();
+        trace("end close()");
+    }
+
+    public int read() throws IOException {
+        trace("start read()");
+        int value = oi.read();
+        trace("end read()=" + value);
+        return value;
+    }
+
+    public int read(byte[] b, int off, int len) throws IOException {
+        trace("start read(b, off, len) off=" + off + " len="+len);
+        int value = oi.read(b, off, len);
+        trace("end read(b,off,len)=" + value);
+        return value;
+    }
+
+    public int read(byte[] b) throws IOException {
+        trace("start read(b) b.length=" + b.length);
+        int value = oi.read(b);
+        trace("end read(b)=" + value);
+        return value;
+    }
+
+    public boolean readBoolean() throws IOException {
+        trace("start readBoolean()");
+        boolean value = oi.readBoolean();
+        trace("end readBoolean()=" + value);
+        return value;
+    }
+
+    public byte readByte() throws IOException {
+        trace("start readByte");
+        byte value = oi.readByte();
+        trace("end readByte()=" + value);
+        return value;
+    }
+
+    public char readChar() throws IOException {
+        trace("start readChar");
+        char value = oi.readChar();
+        trace("end readChar()=" + value);
+        return value;
+    }
+
+    public double readDouble() throws IOException {
+        trace("start readDouble");
+        double value = oi.readDouble();
+        trace("end readDouble()=" + value);
+        return value;
+    }
+
+    public float readFloat() throws IOException {
+        trace("start readFloat");
+        float value = oi.readFloat();
+        trace("end readFloat()=" + value);
+        return value;
+    }
+
+    public void readFully(byte[] b, int off, int len) throws IOException {
+        trace("start readFully(b,off,len) off=" + off + " len="+len);
+        oi.readFully(b, off, len);
+        trace("end readFully(b,off,len)");
+    }
+
+    public void readFully(byte[] b) throws IOException {
+        trace("start readFully(b) b.length="+ b.length);
+        oi.readFully(b);
+        trace("end readFully(b)");
+    }
+
+    public int readInt() throws IOException {
+        trace("start readInt()");
+        int value = oi.readInt();
+        trace("end readInt()="+ value);
+        return value;
+    }
+
+    public String readLine() throws IOException {
+        trace("start readLine()");
+        String value = oi.readLine();
+        trace("end readLine()="+ value);
+        return value;
+    }
+
+    public long readLong() throws IOException {
+        trace("start readLong()");
+        long value = oi.readLong();
+        trace("end readLong()="+ value);
+        return value;
+    }
+
+    public Object readObject() throws ClassNotFoundException, IOException {
+        trace("start readObject()");
+        Object value = oi.readObject();
+        
+        trace("end readObject()="+ value);
+        return value;
+    }
+
+    public short readShort() throws IOException {
+        trace("start readShort()");
+        short value = oi.readShort();
+        trace("end readShort()="+ value);
+        return value;
+    }
+
+    public int readUnsignedByte() throws IOException {
+        trace("start readLong()");
+        int value = oi.readUnsignedByte();
+        trace("end readUnsignedByte()="+ value);
+        return value;
+    }
+
+    public int readUnsignedShort() throws IOException {
+        trace("start readShort()");
+        int value = oi.readUnsignedShort();
+        trace("end readShort()="+ value);
+        return value;
+    }
+
+    public String readUTF() throws IOException {
+        trace("start readUTF()");
+        String value = oi.readUTF();
+        trace("end readUTF()="+ value);
+        return value;
+    }
+
+    public long skip(long n) throws IOException {
+        trace("start skip(n) n="+n);
+        long value = oi.skip(n);
+        trace("end skip(n)="+ value);
+        return value;
+    }
+
+    public int skipBytes(int n) throws IOException {
+        trace("start skipBytes(n) n="+n);
+        int value = oi.skipBytes(n);
+        trace("end skipBytes(n)="+ value);
+        return value;
+    }
+    
+    public void trace(String str) {
+        if (isDebug) {
+            log.debug(str);
+        }
+    }
+    
+}
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/ObjectInputStreamWithCL.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/ObjectInputStreamWithCL.java	(revision 0)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/context/externalize/ObjectInputStreamWithCL.java	(revision 0)
@@ -0,0 +1,261 @@
+/*
+ * Copyright 2004,2007 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.context.externalize;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.ObjectStreamClass;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.Proxy;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.HashMap;
+
+/**
+ * An ObjectInputStream that is constructed with a ClassLoader or ClassResolver.
+ * The default behavior is to use the ContextClassLoader
+ */
+public class ObjectInputStreamWithCL extends java.io.ObjectInputStream
+{
+
+    /**
+     * <p>
+     * This interface is used to resolve OSGi declared serializable classes.
+     * </p>
+     */
+    public interface ClassResolver
+    {
+        /**
+         * Attempt to load the specified class.
+         * 
+         * @param className
+         *            The classname.
+         * @return The class, or null if not found.
+         */
+        public Class resolveClass(String className);
+    }
+
+    private static final HashMap primClasses = new HashMap(8, 1.0F);
+
+    /** The class resolver */
+
+    protected static ClassResolver resolver;
+    static
+    {
+        primClasses.put("boolean", boolean.class);
+        primClasses.put("byte", byte.class);
+        primClasses.put("char", char.class);
+        primClasses.put("short", short.class);
+        primClasses.put("int", int.class);
+        primClasses.put("long", long.class);
+        primClasses.put("float", float.class);
+        primClasses.put("double", double.class);
+        primClasses.put("void", void.class);
+
+    }
+
+    protected ClassLoader classloader;
+
+    protected String name;
+
+    /**
+     * Construct using ContextClassLoader
+     * @param is
+     * @throws IOException
+     */
+    public ObjectInputStreamWithCL(InputStream is) throws IOException
+    {
+        super(is);
+        
+        classloader = (ClassLoader) AccessController.doPrivileged(new PrivilegedAction()
+        {
+            public Object run()
+            {
+                return Thread.currentThread().getContextClassLoader();                
+            }          
+        });                
+    }
+
+    /**
+     * Constructor that accepts a ClassLoader
+     * @param is
+     * @param cl
+     * @throws IOException
+     */
+    public ObjectInputStreamWithCL(InputStream is, ClassLoader cl) throws IOException
+    {
+        super(is);
+        classloader = cl;
+    }
+    
+    /**
+     * Constructor that accepts a ClassResolver
+     * @param is
+     * @param r ClassResolver
+     * @throws IOException
+     */
+    public ObjectInputStreamWithCL(InputStream is, ClassResolver r) throws IOException
+    {
+        super(is);
+        resolver = r;
+    }
+
+    /**
+     * Override resolveClass so that we can use our own ClassLoader
+     */
+    protected Class resolveClass(ObjectStreamClass objStrmClass) throws ClassNotFoundException
+    {
+        return resolveClass(objStrmClass.getName());
+    }
+
+    private Class resolveClass(String name) throws ClassNotFoundException
+    {
+        try
+        {
+            this.name = name;
+            return (Class) AccessController.doPrivileged(loadAction);
+        }
+        catch (java.security.PrivilegedActionException pae)
+        {
+            Exception wrapped = pae.getException();
+            if (wrapped instanceof ClassNotFoundException) throw (ClassNotFoundException) wrapped;
+            throw new ClassNotFoundException(name);
+        }
+    }
+
+    java.security.PrivilegedExceptionAction loadAction = 
+        new java.security.PrivilegedExceptionAction()
+    {
+        public java.lang.Object run() throws Exception
+        {
+            try
+            {
+                Class clazz = null;
+                // If the resolver is set
+                if (resolver != null)
+                {
+                    // use the resolver to load the class.
+                    clazz = resolver.resolveClass(name);
+                }
+
+                // if the class is not loadable
+                if (clazz == null)
+                {
+                    clazz = loadClass(name, classloader); // d296416
+                }
+
+                return clazz;
+            }
+            catch (ClassNotFoundException cnf)
+            {
+                Class c = (Class) primClasses.get(name);
+                if (c != null)
+                {
+                    return c;
+                }
+               
+                throw cnf;
+                
+            } 
+        }
+    };
+
+    // d296416: Use runtime bundle classloader (current) to resolve a class when
+    // the class could not be resolved using the specified classloader.
+    // A serializable class in a bundle should specify via
+    // <com.ibm.ws.runtime.serializable> bundle extension point
+    // that it is deserializable outside the current bundle.
+    // NOTE: Looking up current classloader is only a tactical solution,
+    // and could be deprecated in future.
+    // 
+    private java.lang.Class loadClass(String name, ClassLoader loader) throws ClassNotFoundException
+    {
+        try
+        {
+            return Class.forName(name, true, loader);
+        }
+        catch (ClassNotFoundException cnf)
+        {
+            return Class.forName(name);
+        }
+    }
+
+    
+    /**
+     * Override to provide our own resolution
+     */
+    protected Class resolveProxyClass(String[] interfaces) throws ClassNotFoundException
+    {
+        if (interfaces.length == 0)
+        {
+            throw new ClassNotFoundException("zero-length interfaces array");
+        }
+
+        Class nonPublicClass = null;
+
+        Class[] classes = new Class[interfaces.length];
+        for (int i = 0; i < interfaces.length; i++)
+        {
+            classes[i] = resolveClass(interfaces[i]);
+
+            if ((classes[i].getModifiers() & Modifier.PUBLIC) == 0)
+            {
+                // "if more than one non-public interface class loader is
+                // encountered, an IllegalAccessError is thrown"
+                if (nonPublicClass != null)
+                {
+                    throw new IllegalAccessError(nonPublicClass + " and " + classes[i] + " both declared non-public");
+                }
+
+                nonPublicClass = classes[i];
+            }
+        }
+
+        // The javadocs for this method say:
+        //
+        // "Unless any of the resolved interfaces are non-public, this same
+        // value of loader is also the class loader passed to
+        // Proxy.getProxyClass; if non-public interfaces are present, their
+        // class loader is passed instead"
+        //
+        // Unfortunately, we don't have a single classloader that we can use.
+        // Call getClassLoader() on either the non-public class (if any) or the
+        // first class.
+        proxyClass = nonPublicClass != null ? nonPublicClass : classes[0];
+        ClassLoader loader = (ClassLoader) AccessController.doPrivileged(proxyClassLoaderAction);
+
+        // "If Proxy.getProxyClass throws an IllegalArgumentException,
+        // resolveProxyClass will throw a ClassNotFoundException containing the
+        // IllegalArgumentException."
+        try
+        {
+            return Proxy.getProxyClass(loader, classes);
+        }
+        catch (IllegalArgumentException ex)
+        {
+            throw new ClassNotFoundException(ex.getMessage(), ex);
+        }
+    }
+
+    private Class proxyClass;
+    PrivilegedAction proxyClassLoaderAction = new PrivilegedAction()
+    {
+        public Object run()
+        {
+            return proxyClass.getClassLoader();
+        }
+    };
+}
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/util/MetaDataEntry.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/util/MetaDataEntry.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/util/MetaDataEntry.java	(working copy)
@@ -19,6 +19,10 @@
 
 package org.apache.axis2.util;
 
+import org.apache.axis2.context.externalize.SafeObjectInputStream;
+import org.apache.axis2.context.externalize.SafeObjectOutputStream;
+import org.apache.axis2.context.externalize.SafeSerializable;
+
 import javax.xml.namespace.QName;
 import java.io.Externalizable;
 import java.io.IOException;
@@ -31,14 +35,14 @@
  * An internal class for holding a set of information
  * about an object.
  */
-public class MetaDataEntry implements Externalizable {
+public class MetaDataEntry implements Externalizable, SafeSerializable {
     // serialization identifier
     private static final long serialVersionUID = 8978361069526299875L;
 
     // supported revision levels, add a new level to manage compatible changes
-    private static final int REVISION_1 = 1;
+    private static final int REVISION_2 = 2;
     // current revision level of this object
-    private static final int revisionID = REVISION_1;
+    private static final int revisionID = REVISION_2;
 
     // data to keep on an object
 
@@ -252,7 +256,8 @@
      * @param out The stream to write the object contents to
      * @throws IOException
      */
-    public void writeExternal(ObjectOutput out) throws IOException {
+    public void writeExternal(ObjectOutput o) throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
         // write out contents of this object
 
         //---------------------------------------------------------
@@ -269,10 +274,10 @@
         //---------------------------------------------------------
         // various simple fields
         //---------------------------------------------------------
-        ObjectStateUtils.writeString(out, className, "MetaDataEntry.className");
-        ObjectStateUtils.writeString(out, qnameAsString, "MetaDataEntry.qnameAsString");
-        ObjectStateUtils.writeString(out, extraName, "MetaDataEntry.extraName");
-        ObjectStateUtils.writeArrayList(out, children, "MetaDataEntry.list");
+        out.writeObject(className);
+        out.writeObject(qnameAsString);
+        out.writeObject(extraName);
+        out.writeList(children);
 
     }
 
@@ -288,7 +293,8 @@
      * @throws IOException
      * @throws ClassNotFoundException
      */
-    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+    public void readExternal(ObjectInput inObject) throws IOException, ClassNotFoundException {
+        SafeObjectInputStream in = SafeObjectInputStream.install(inObject);
 
         // serialization version ID
         long suid = in.readLong();
@@ -302,7 +308,7 @@
         }
 
         // make sure the object data is in a revision level we can handle
-        if (revID != REVISION_1) {
+        if (revID != REVISION_2) {
             throw new ClassNotFoundException(UNSUPPORTED_REVID);
         }
 
@@ -310,10 +316,10 @@
         // various simple fields
         //---------------------------------------------------------
 
-        className = ObjectStateUtils.readString(in, "MetaDataEntry.className");
-        qnameAsString = ObjectStateUtils.readString(in, "MetaDataEntry.qnameAsString");
-        extraName = ObjectStateUtils.readString(in, "MetaDataEntry.extraName");
-        children = ObjectStateUtils.readArrayList(in, "MetaDataEntry.list");
+        className = (String) in.readObject();
+        qnameAsString = (String) in.readObject();
+        extraName = (String) in.readObject();
+        children = in.readArrayList();
 
     }
 
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/util/MessageExternalizeUtils.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/util/MessageExternalizeUtils.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/util/MessageExternalizeUtils.java	(working copy)
@@ -1,430 +0,0 @@
-/*
- * Copyright 2004,2007 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.util;
-
-import org.apache.axiom.om.OMOutputFormat;
-import org.apache.axiom.om.impl.builder.StAXBuilder;
-import org.apache.axiom.om.util.StAXUtils;
-import org.apache.axiom.soap.SOAPEnvelope;
-import org.apache.axiom.soap.impl.builder.StAXSOAPModelBuilder;
-import org.apache.axis2.AxisFault;
-import org.apache.axis2.builder.BuilderUtil;
-import org.apache.axis2.context.MessageContext;
-import org.apache.axis2.transport.MessageFormatter;
-import org.apache.axis2.transport.TransportUtils;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-import javax.xml.stream.XMLStreamReader;
-
-import java.io.BufferedOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.ObjectInput;
-import java.io.ObjectOutput;
-import java.io.OutputStream;
-
-/**
- * Utility to read/write the Message of a MessageContext
- * Message Object Format.
- * 
- * <tt>
- * Format := Prolog {DataBlocks} EndBlocks
- * 
- * Prolog :=
- *   NAME      (UTF) 
- *   VERSION   (INT)
- *   ACTIVE    (BOOL)
- *     [OPTIMIZED (BOOL)]  
- *        [OPTIMIZED_CONTENT_TYPE (UTF)]    <--- If OPTIMIZED=TRUE
- *     [CHARSET   (UTF)] 
- *     [NAMESPACE (UTF)]
- *   
- * DataBlock :=
- *   SIZE (INT >0)
- *   DATA (BYTES)
- *   
- * EndBlocks
- *   SIZE (INT)   {0 indicates end -1 indicates failure}
- *     
- *   
- * </tt>
- */
-public class MessageExternalizeUtils {
-    static final Log log = LogFactory.getLog(MessageExternalizeUtils.class);
-    
-    // Change the version if the syntax of the externalized message is changed.
-    // Or if major changes are made to the underlying Axiom code.
-    static final int VERSION = 1;
-    
-    /**
-     * Private Constructor.
-     * This class only supports static methods
-     */
-    private MessageExternalizeUtils() {}
-    
-    /**
-     * Write out the Message
-     * @param out
-     * @param mc
-     * @param correlationIDString
-     * @param outputFormat
-     * @throws IOException
-     */
-    public static void writeExternal(ObjectOutput out, 
-                                     MessageContext mc,
-                                     String correlationIDString,
-                                     OMOutputFormat outputFormat) throws IOException {
-
-        SOAPEnvelope envelope = mc.getEnvelope();
-        if (envelope == null) {
-            // Case: No envelope
-            out.writeUTF("NULL_ENVELOPE");
-            out.writeInt(VERSION);
-            out.writeBoolean(ObjectStateUtils.EMPTY_OBJECT); // Not Active
-            out.writeInt(0);  // EndBlocks
-            if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-                log.trace(correlationIDString + ":writeExternal(): msg  is Empty");
-            }
-            return;
-        }
-        
-        // Write Prolog
-        String msgClass = envelope.getClass().getName();
-        out.writeUTF(msgClass);
-        out.writeInt(VERSION);
-        out.writeBoolean(ObjectStateUtils.ACTIVE_OBJECT);
-        if (outputFormat.isOptimized()) {
-            out.writeBoolean(true);
-            // Write out the contentType.
-            out.writeUTF(outputFormat.getContentType());
-        } else {
-            out.writeBoolean(false);
-        }
-        out.writeUTF(outputFormat.getCharSetEncoding());
-        out.writeUTF(envelope.getNamespace().getNamespaceURI());
-        if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-            log.trace(correlationIDString + ":writeExternal(): " + 
-                      "optimized=[" + outputFormat.isOptimized() + "]  " +
-                      "optimizedContentType " + outputFormat.getContentType() + "]  " +
-                      "charSetEnc=[" + outputFormat.getCharSetEncoding() + "]  " +
-                      "namespaceURI=[" + envelope.getNamespace().getNamespaceURI() + "]");
-        }
-        
-        // Write DataBlocks
-        // MessageOutputStream writes out the DataBlocks in chunks
-        // BufferedOutputStream buffers the data to prevent numerous, small blocks
-        MessageOutputStream mos = new MessageOutputStream(out);  
-        BufferedOutputStream bos = new BufferedOutputStream(mos);   
-        boolean errorOccurred = false;
-        try { 
-            // Write out the message using the same logic as the 
-            // transport layer.
-            MessageFormatter msgFormatter = TransportUtils.getMessageFormatter(mc);
-            msgFormatter.writeTo(mc, outputFormat, bos, 
-                                 true); // Preserve the original message
-            
-        } catch (IOException e) {
-            throw e;
-        } finally {
-            bos.flush();
-            bos.close();
-        }
-        
-        // Write End of Data Blocks
-        if (errorOccurred) {
-            out.writeInt(-1);
-        } else {
-            out.writeInt(0);
-        }
-    }
-    
-    /**
-     * Read the Message
-     * @param in
-     * @param mc
-     * @param correlationIDString
-     * @return
-     * @throws IOException
-     */
-    public static SOAPEnvelope readExternal(ObjectInput in,
-                                            MessageContext mc,
-                                            String correlationIDString) throws IOException {
-        SOAPEnvelope envelope = null;
-        
-        // Read Prolog
-        // Read the class name and object state
-        String name = in.readUTF();
-        int version = in.readInt();
-        
-        if (version != VERSION) {
-            throw new AxisFault("The version of the persisted message " + version + 
-                                " does not match the expected version " + VERSION +
-                                " Processing cannot continue.");
-        }
-        if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-            log.trace(correlationIDString + ":readExternal(): name= " + name  +
-                      " version= " + VERSION);
-        }
-        
-        
-        boolean gotMsg = in.readBoolean();
-        if (gotMsg != ObjectStateUtils.ACTIVE_OBJECT) {
-            if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-                log.trace(correlationIDString + ":readExternal(): " +
-                                "no message present");
-            }
-            in.readInt(); // Read end of data blocks
-            return envelope;
-        }
-        
-        // Read optimized, optimized content-type, charset encoding and namespace uri
-        boolean optimized= in.readBoolean();
-        String optimizedContentType = null;
-        if (optimized) {
-            optimizedContentType = in.readUTF();
-        }
-        String charSetEnc = in.readUTF();
-        String namespaceURI = in.readUTF();
-        if (LoggingControl.debugLoggingAllowed && log.isTraceEnabled()) {
-            log.trace(correlationIDString + ":readExternal(): " +
-                      "optimized=[" + optimized + "]  " +
-                      "optimizedContentType=[" + optimizedContentType + "]  " +
-                      "charSetEnc=[" + charSetEnc + "]  " +
-                      "namespaceURI=[" + namespaceURI + "]");
-        }
-        
-        MessageInputStream mis = new MessageInputStream(in);
-        StAXBuilder  builder = null;
-        try {
-            if (optimized) {
-                boolean isSOAP = true;
-                builder =
-                    BuilderUtil.getAttachmentsBuilder(mc,
-                                                      mis,
-                                                      optimizedContentType,
-                                                      isSOAP);
-                envelope = (SOAPEnvelope) builder.getDocumentElement();
-                // TODO Why do we need to free the inputStream ?
-                // build the OM in order to free the input stream
-                envelope.buildWithAttachments();
-            } else {
-                XMLStreamReader xmlreader = StAXUtils.createXMLStreamReader(mis, charSetEnc);
-                builder = new StAXSOAPModelBuilder(xmlreader, namespaceURI);
-                envelope = (SOAPEnvelope) builder.getDocumentElement();
-                // TODO Why do we need to free the inputStream ?
-                // build the OM in order to free the input stream
-                envelope.build();
-            }
-        } catch (Exception ex) {
-            // TODO: what to do if can't get the XML stream reader
-            // For now, log the event
-            log.error(correlationIDString
-                      + ":readExternal(): Error when deserializing persisted envelope: ["
-                      + ex.getClass().getName() + " : " + ex.getLocalizedMessage() + "]", ex);
-            envelope = null;
-        } finally {
-            if (builder != null) {
-                builder.close();
-            }
-            // Close the message input stream.  This will ensure that the
-            // underlying stream is advanced past the message.
-            mis.close();
-        }
-        return envelope;
-    }
-    
-    /**
-     * MessageOutputStream writes DataBlock chunks to the ObjectOutput.
-     */
-    private static class MessageOutputStream extends OutputStream {
-        ObjectOutput out;
-        boolean isTrace;
-        MessageOutputStream(ObjectOutput out) {
-            this.out = out;
-            isTrace = log.isTraceEnabled();
-        }
-        
-         
-        public void close() throws IOException {
-            // NOOP: ObjectOutput will be closed externally
-        }
-        
-        public void flush() throws IOException {
-            out.flush();
-        }
-
-        /** 
-         * Writes a chunk of data to the ObjectOutput
-         */
-        public void write(byte[] b, int off, int len) throws IOException {
-            if (len > 0) {
-                if (isTrace) {
-                    log.trace("Write data chunk with len=" + len);
-                    log.trace("Chunk = " + new String(b, off, len));
-                    System.out.println("Chunk = " + new String(b, off, len));
-                }
-                // Write out the length and the data chunk
-                out.writeInt(len);
-                out.write(b, off, len);
-            }
-        }
-
-         
-        /** 
-         * Writes a chunk of data to the ObjectOutput
-         */
-        public void write(byte[] b) throws IOException {
-            if (b != null &&  b.length > 0) {
-                if (isTrace) {
-                    log.trace("Write data chunk with size=" + b.length);
-                    log.trace("Chunk = " + new String(b));
-                    System.out.println("Chunk = " + new String(b));
-                }
-                // Write out the length and the data chunk
-                out.writeInt(b.length);
-                out.write(b);
-            }
-        }
-
-         
-        /** 
-         * Writes a single byte chunk of data to the ObjectOutput
-         */
-        public void write(int b) throws IOException {
-            if (isTrace) {
-                log.trace("Write one byte data chunk");
-            }
-            // Write out the length and the data chunk
-            out.writeInt(1);
-            out.write(b);
-        }
-    }
-       
-    /**
-     * Provides a InputStream interface over ObjectInput.
-     * MessageInputStream controls the reading of the DataBlock chunks
-     *
-     */
-    private static class MessageInputStream extends InputStream {
-        
-        ObjectInput in;
-        boolean isTrace;
-        int chunkAvail = 0;
-        boolean isEOD = false;
-        
-        /**
-         * Constructor
-         * @param in
-         */
-        MessageInputStream(ObjectInput in) {
-            this.in = in;
-            isTrace = true; // TODO log.isTraceEnabled();
-        }
-
-         
-        /**
-         * Read a single logical byte
-         */
-        public int read() throws IOException {
-            if (isTrace) {
-                log.trace("invoking read()");
-            }
-            // Determine how many bytes are left in the current data chunk
-            updateChunkAvail();
-            if (isEOD) {
-                return -1;
-            } else {
-                chunkAvail--;
-                return in.readByte();
-            }
-        }
-
-         
-        /**
-         * Read an array of logical bytes
-         */
-        public int read(byte[] b, int off, int len) throws IOException {
-            if (isTrace) {
-                log.trace("invoking read with off=" + off + " and len=" + len);
-            }
-            int bytesRead = 0;
-            while ((len >0 && !isEOD)) {
-                // Determine how many bytes are left in the current data chunk
-                updateChunkAvail();
-                if (!isEOD) {
-                    // Read the amount of bytes requested or the number of bytes available in the current chunk
-                    int readLength = len < chunkAvail ? len : chunkAvail;
-                    int br = in.read(b, off, readLength);
-                    if (br < 0) {
-                        throw new IOException("End of File encountered");
-                    }
-                    // Update state with the number of bytes read
-                    off += br;
-                    len -= br;
-                    chunkAvail -= br;
-                    bytesRead += br;
-                }
-            }
-            return bytesRead;
-        }
-
-         
-        public int read(byte[] b) throws IOException {
-            return read(b, 0, b.length);
-        }
-        
-        public void close() throws IOException {
-            if (isTrace) {
-                log.trace("start close");
-            }
-            // Keep reading chunks until EOD
-            if (!isEOD) {
-                byte[] tempBuffer = new byte[4 * 1024];
-                while (!isEOD) {
-                    read(tempBuffer);
-                }
-            }
-            if (isTrace) {
-                log.trace("end close");
-            }
-        }
-        
-        /**
-         * updateChunkAvail updates the chunkAvail field with the
-         * amount of data in the chunk.
-         * @throws IOException
-         */
-        private void updateChunkAvail() throws IOException {
-            
-            // If there are no more bytes in the current chunk,
-            // read the size of the next datablock
-            if (chunkAvail == 0 && !isEOD) {
-                chunkAvail = in.readInt();
-                if (isTrace) {
-                    log.trace("Read chunk of size=" + chunkAvail);
-                }
-                if (chunkAvail <= 0) {
-                    if (isTrace) {
-                        log.trace("End of data");
-                    }
-                    isEOD = true;
-                    chunkAvail = 0;
-                }
-            }
-        }
-    }
-}
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/util/ObjectStateUtils.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/util/ObjectStateUtils.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/util/ObjectStateUtils.java	(working copy)
@@ -10,1634 +10,366 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
+ * software distributed under the License is distributed on a
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied. See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
-
 package org.apache.axis2.util;
 
+import org.apache.axis2.context.externalize.ActivateUtils;
+import org.apache.axis2.context.externalize.ExternalizeConstants;
+import org.apache.axis2.context.externalize.SafeObjectInputStream;
+import org.apache.axis2.context.externalize.SafeObjectOutputStream;
 import org.apache.axis2.description.AxisMessage;
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.AxisServiceGroup;
-import org.apache.axis2.description.TransportInDescription;
 import org.apache.axis2.engine.AxisConfiguration;
-import org.apache.axis2.engine.Handler;
 import org.apache.axis2.transport.TransportListener;
-import org.apache.axis2.wsdl.WSDLConstants;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import javax.xml.namespace.QName;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
+
 import java.io.IOException;
-import java.io.NotSerializableException;
 import java.io.ObjectInput;
 import java.io.ObjectOutput;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.HashMap;
-import java.util.Hashtable;
-import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.Map;
-import java.util.Set;
 
 /**
- * Provides functions for saving and restoring an object's state.
+ * Utility to write, read and activate externalized Objects
  */
-public class ObjectStateUtils {
-	/*
-	 * setup for logging
-	 */
-	private static final Log log = LogFactory.getLog(ObjectStateUtils.class);
+public class ObjectStateUtils implements ExternalizeConstants {
+    /*
+     * setup for logging
+     */
+    private static final Log log = LogFactory.getLog(ObjectStateUtils.class);
 
-	// used as part of the metadata written out
-	// indicating a null or empty object
-	public static boolean EMPTY_OBJECT = false;
+    // used to indicate an valid "null" object,
+    // typically used in key-value pairs where a non-null key refers to a null
+    // value
+    public static String NULL_OBJECT = "NULL_OBJ";
 
-	// used as part of the metadata written out
-	// indicating a non-null or live object
-	public static boolean ACTIVE_OBJECT = true;
+    // message/trace/logging strings
+    public static final String UNSUPPORTED_SUID = "Serialization version ID is not supported.";
 
-	// used to indicate the end of a list
-	public static String LAST_ENTRY = "LAST_OBJ";
+    public static final String UNSUPPORTED_REVID = "Revision ID is not supported.";
 
-	// used to indicate an "empty" object
-	public static String EMPTY_MARKER = "EMPTY_OBJ";
+    // --------------------------------------------------------------------
+    // Save/Restore methods
+    // --------------------------------------------------------------------
 
-	// used to indicate an valid "null" object,
-	// typically used in key-value pairs where a non-null key refers to a null
-	// value
-	public static String NULL_OBJECT = "NULL_OBJ";
+    /**
+     * Write a string to the specified output stream.
+     * 
+     * @param o The output stream
+     * @param str The string to write
+     * @param desc A text description to use for logging
+     * @throws IOException Exception
+     */
+    public static void writeString(ObjectOutput o, String str, String desc) throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
+        out.writeUTF(desc);
+        out.writeObject(str);
+    }
 
-	// message/trace/logging strings
-	public static final String UNSUPPORTED_SUID = "Serialization version ID is not supported.";
+    /**
+     * Read a string from the specified input stream. Returns null if no string is available.
+     * 
+     * @param i The input stream
+     * @param desc A text description to use for logging
+     * @return The string or null, if not available
+     * @throws IOException
+     * @throws ClassNotFoundException
+     */
+    public static String readString(ObjectInput i, String desc) throws IOException,
+                                                               ClassNotFoundException {
+        SafeObjectInputStream in = SafeObjectInputStream.install(i);
 
-	public static final String UNSUPPORTED_REVID = "Revision ID is not supported.";
+        // Get the marker
+        in.readUTF();
 
-	public static final String OBJ_SAVE_PROBLEM = "The object could not be saved to the output stream.  The object may or may not be important for processing the message when it is restored. Look at how the object is to be used during message processing.";
+        // Get the object
+        return (String) in.readObject();
+    }
 
-	public static final String OBJ_RESTORE_PROBLEM = "The object could not be restored from the input stream.  The object may or may not be important for processing the message when it is restored. Look at how the object is to be used during message processing.";
+    /**
+     * Write an object to the specified output stream.
+     * 
+     * @param o The output stream
+     * @param obj The object to write
+     * @param desc A text description to use for logging
+     * @throws IOException Exception
+     */
+    public static void writeObject(ObjectOutput o, Object obj, String desc) throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
+        out.writeUTF(desc);
+        out.writeObject(obj);
+    }
 
-	// as a way to improve performance and reduce trace logging with
-	// extra exceptions, keep a table of classes that are not serializable
-	// and only log the first time it that the class is encountered in
-	// an NotSerializableException
-	// note that the Hashtable is synchronized by Java so we shouldn't need to
-	// do extra control over access to the table
-	public static Hashtable NotSerializableList = new Hashtable();
+    /**
+     * Read an object from the specified input stream. Returns null if no object is available.
+     * 
+     * @param i The input stream
+     * @param desc A text description to use for logging
+     * @return The object or null, if not available
+     * @throws IOException
+     * @throws ClassNotFoundException
+     */
+    public static Object readObject(ObjectInput i, String desc) throws IOException,
+                                                               ClassNotFoundException {
+        SafeObjectInputStream in = SafeObjectInputStream.install(i);
+        in.readUTF(); // Read Marker
+        return in.readObject();
+    }
 
-	// --------------------------------------------------------------------
-	// Save/Restore methods
-	// --------------------------------------------------------------------
+    /**
+     * Write an array of objects to the specified output stream. NOTE: each object in the array
+     * should implement either java.io.Serializable or java.io.Externalizable in order to be saved
+     * 
+     * @param o The output stream
+     * @param al The ArrayList to write
+     * @param desc A text description to use for logging
+     * @throws IOException Exception
+     */
+    public static void writeArrayList(ObjectOutput o, ArrayList al, String desc) 
+      throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
+        out.writeUTF(desc);
+        out.writeList(al);
+    }
 
-	/**
-	 * Write a string to the specified output stream. <p/> The format of the
-	 * information written to the output stream is: <BOLD>Non-Null String</BOLD>
-	 * <LI> UTF - class name string
-	 * <LI> boolean - active flag
-	 * <LI> Object - string data <p/> <BOLD>Null String</BOLD>
-	 * <LI> UTF - description
-	 * <LI> boolean - empty flag <p/>
-	 * 
-	 * @param out
-	 *            The output stream
-	 * @param str
-	 *            The string to write
-	 * @param desc
-	 *            A text description to use for logging
-	 * @throws IOException
-	 *             Exception
-	 */
-	public static void writeString(ObjectOutput out, String str, String desc)
-			throws IOException {
-		// The total number of bytes needed to represent all
-		// the characters of a string is calculated when the string
-		// is serialized. If this number is larger than 65535 (ie, 64 KB)
-		// then a java.io.UTFDataFormatException is thrown
+    /**
+     * Reads an array of objects from the specified input stream. Returns null if no array is
+     * available. NOTE: each object in the array should implement either java.io.Serializable or
+     * java.io.Externalizable in order to be saved
+     * 
+     * @param i The input stream
+     * @param desc A text description to use for logging
+     * @return The ArrayList or null, if not available
+     * @throws IOException
+     * @throws ClassNotFoundException
+     */
+    public static ArrayList readArrayList(ObjectInput i, String desc) throws IOException {
+        SafeObjectInputStream in = SafeObjectInputStream.install(i);
+        in.readUTF();
+        return in.readArrayList();
+    }
 
-		if (str != null) {
-			String str_desc = str.getClass().getName();
-			// this string is expected to fit the writeUTF limitations
-			out.writeUTF(str_desc);
+    /**
+     * Write a hashmap of objects to the specified output stream. NOTE: each object in the map
+     * should implement either java.io.Serializable or java.io.Externalizable in order to be saved
+     * 
+     * @param o The output stream
+     * @param map The HashMap to write
+     * @param desc A text description to use for logging
+     * @throws IOException Exception
+     */
+    public static void writeHashMap(ObjectOutput o, HashMap map, String desc) throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
+        out.writeUTF(desc);
+        out.writeMap(map);
+    }
 
-			out.writeBoolean(ACTIVE_OBJECT);
-			out.writeObject(str);
-			// trace point
-			if (log.isTraceEnabled()) {
-				log
-						.trace("ObjectStateUtils:writeString(): ACTIVE string: str_desc ["
-								+ str_desc
-								+ "]    string ["
-								+ str
-								+ "]   desc [" + desc + "]");
-			}
+    /**
+     * Read a hashmap of objects from the specified input stream. Returns null if no hashmap is
+     * available.
+     * 
+     * @param in The input stream
+     * @param desc A text description to use for logging
+     * @return The HashMap or null, if not available
+     * @throws IOException
+     * @throws ClassNotFoundException
+     */
+    public static HashMap readHashMap(ObjectInput i, String desc) throws IOException {
+        SafeObjectInputStream in = SafeObjectInputStream.install(i);
+        in.readUTF();
+        return in.readHashMap();
+    }
 
-		} else {
-			// this string is expected to fit the writeUTF limitations
-			out.writeUTF(desc);
+    /**
+     * Write a linked list of objects to the specified output stream. <NOTE: each object in the
+     * array should implement either java.io.Serializable or java.io.Externalizable in order to be
+     * saved
+     * 
+     * @param o The output stream
+     * @param list The LinkedList to write
+     * @param desc A text description to use for logging
+     * @throws IOException Exception
+     */
+    public static void writeLinkedList(ObjectOutput o, LinkedList objlist, String desc)
+      throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
+        out.writeUTF(desc);
+        out.writeList(objlist);
 
-			out.writeBoolean(EMPTY_OBJECT);
+    }
 
-			// for now, don't trace the EMPTY lines
-			// // trace point
-			// if (log.isTraceEnabled())
-			// {
-			// log.trace("ObjectStateUtils:writeString(): EMPTY String desc
-			// ["+desc+"] ");
-			// }
-		}
+    /**
+     * Reads a linked list of objects from the specified input stream. Returns null if no array is
+     * available.
+     * 
+     * @param in The input stream
+     * @param desc A text description to use for logging
+     * @return The linked list or null, if not available
+     * @throws IOException
+     * @throws ClassNotFoundException
+     */
+    public static LinkedList readLinkedList(ObjectInput i, String desc) throws IOException {
+        SafeObjectInputStream in = SafeObjectInputStream.install(i);
+        in.readUTF();
+        return in.readLinkedList();
+    }
 
-	}
+    // --------------------------------------------------------------------
+    // Finder methods
+    // --------------------------------------------------------------------
 
-	/**
-	 * Read a string from the specified input stream. Returns null if no string
-	 * is available. <p/> The format of the information to be read from the
-	 * input stream should be <BOLD>Non-Null String</BOLD>
-	 * <LI> UTF - class name string
-	 * <LI> boolean - active flag
-	 * <LI> Object - string data <p/> <BOLD>Null String</BOLD>
-	 * <LI> UTF - description
-	 * <LI> boolean - empty flag <p/>
-	 * 
-	 * @param in
-	 *            The input stream
-	 * @param desc
-	 *            A text description to use for logging
-	 * @return The string or null, if not available
-	 * @throws IOException
-	 * @throws ClassNotFoundException
-	 */
-	public static String readString(ObjectInput in, String desc)
-			throws IOException, ClassNotFoundException {
-		String str = null;
+    /**
+     * Find the AxisOperation object that matches the criteria
+     * 
+     * @param axisConfig The AxisConfiguration object
+     * @param opClassName the class name string for the target object (could be a derived class)
+     * @param opQName the name associated with the operation
+     * @return the AxisOperation object that matches the given criteria
+     */
+    public static AxisOperation findOperation(AxisConfiguration axisConfig, String opClassName,
+                                              QName opQName) {
+        return ActivateUtils.findOperation(axisConfig, opClassName, opQName);
+    }
 
-		// get the marker
-		String str_desc = in.readUTF();
+    /**
+     * Find the AxisOperation object that matches the criteria
+     * 
+     * @param service The AxisService object
+     * @param opClassName The class name string for the target object (could be a derived class)
+     * @param opQName the name associated with the operation
+     * @return the AxisOperation object that matches the given criteria
+     */
+    public static AxisOperation findOperation(AxisService service, 
+                                              String opClassName, 
+                                              QName opQName) {
+        return ActivateUtils.findOperation(service, opClassName, opQName);
+    }
 
-		// get the flag
-		boolean isActive = in.readBoolean();
+    /**
+     * Find the AxisService object that matches the criteria
+     * 
+     * @param axisConfig The AxisConfiguration object
+     * @param serviceClassName the class name string for the target object (could be a derived
+     * class)
+     * @param serviceName the name associated with the service
+     * @return the AxisService object that matches the criteria
+     */
+    public static AxisService findService(AxisConfiguration axisConfig, String serviceClassName,
+                                          String serviceName) {
+        return ActivateUtils.findService(axisConfig, serviceClassName, serviceName);
+    }
 
-		if (isActive == ACTIVE_OBJECT) {
-			str = (String) in.readObject();
-		}
+    /**
+     * Find the AxisServiceGroup object that matches the criteria <p/> <B>Note<B> the saved 
+     * service group meta information may not match up with any of the serviceGroups that 
+     * are in the current AxisConfiguration object.
+     * 
+     * @param axisConfig The AxisConfiguration object
+     * @param serviceGrpClassName the class name string for the target object (could be a derived
+     * class)
+     * @param serviceGrpName the name associated with the service group
+     * @return the AxisServiceGroup object that matches the criteria
+     */
+    public static AxisServiceGroup findServiceGroup(AxisConfiguration axisConfig,
+                                                    String serviceGrpClassName,
+                                                    String serviceGrpName) {
+        return ActivateUtils.findServiceGroup(axisConfig, serviceGrpClassName, serviceGrpName);
+    }
 
-		if (log.isTraceEnabled()) {
-			log.trace("ObjectStateUtils:readString(): [" + desc
-					+ "]  returning  [" + str + "]  for  saved [" + str_desc
-					+ "]");
-		}
+    /**
+     * Find the AxisMessage object that matches the criteria
+     * 
+     * @param op The AxisOperation object
+     * @param msgName The name associated with the message
+     * @param msgElementName The name associated with the message element
+     * @return the AxisMessage object that matches the given criteria
+     */
+    public static AxisMessage findMessage(AxisOperation op, 
+                                          String msgName, 
+                                          String msgElementName) {
+        return ActivateUtils.findMessage(op, msgName, msgElementName);
+    }
 
-		return str;
-	}
+    /**
+     * Find the Handler object that matches the criteria
+     * 
+     * @param existingHandlers The list of existing handlers and phases
+     * @param handlerClassName the class name string for the target object (could be a derived
+     * class)
+     * @return the Handler object that matches the criteria
+     */
+    public static Object findHandler(ArrayList existingHandlers, 
+                                     MetaDataEntry metaDataEntry) 
+    {
+        return ActivateUtils.findHandler(existingHandlers, metaDataEntry);
+    }
 
-	/**
-	 * Write an object to the specified output stream. <p/> The format of the
-	 * information written to the output stream is <p/> <BOLD>Non-Null Object</BOLD>
-	 * <LI> UTF - class name string
-	 * <LI> boolean - active flag
-	 * <LI> object - object if no error in the form of int byte array
-	 * 
-	 * <LI> LAST_ENTRY marker in the form of int object <p/> <BOLD>Null Object</BOLD>
-	 * <LI> UTF - description
-	 * <LI> boolean - empty flag <p/>
-	 * 
-	 * @param out
-	 *            The output stream
-	 * @param obj
-	 *            The object to write
-	 * @param desc
-	 *            A text description to use for logging
-	 * @throws IOException
-	 *             Exception
-	 */
-	public static void writeObject(ObjectOutput out, Object obj, String desc)
-			throws IOException {
-		IOException returned_exception = null;
+    /**
+     * Find the TransportListener object that matches the criteria <p/> <B>Note<B> the saved meta
+     * information may not match up with any of the objects that are in the current
+     * AxisConfiguration object.
+     * 
+     * @param axisConfig The AxisConfiguration object
+     * @param listenerClassName the class name string for the target object (could be a derived
+     * class)
+     * @return the TransportListener object that matches the criteria
+     */
+    public static TransportListener findTransportListener(AxisConfiguration axisConfig,
+                                                          String listenerClassName) {
+        return ActivateUtils.findTransportListener(axisConfig, listenerClassName);
+    }
 
-		if (obj != null) {
-			String objClassName = obj.getClass().getName();
-			String fullDesc = desc + ":" + objClassName;
-			// this string is expected to fit the writeUTF limitations
-			out.writeUTF(fullDesc);
+    /**
+     * Compares the two collections to see if they are equivalent.
+     * 
+     * @param a1 The first collection
+     * @param a2 The second collection
+     * @param strict Indicates whether strict checking is required. Strict checking means that the
+     * two collections must have the same elements in the same order. 
+     * Non-strict checking means that the two collections must have the same elements, 
+     * but the order is not significant.
+     * @return TRUE if the two collections are equivalent FALSE, otherwise
+     */
+    public static boolean isEquivalent(ArrayList a1, ArrayList a2, boolean strict) {
+        return ActivateUtils.isEquivalent(a1, a2, strict);
+    }
 
-			try {
-				// put the object into a test output buffer to see if it can be
-				// saved
-				// this technique preserves the integrity of the real output
-				// stream in the
-				// event of a serialization error
-				ByteArrayOutputStream test_outBuffer = new ByteArrayOutputStream();
-				ObjectOutputStream test_objOut = new ObjectOutputStream(
-						test_outBuffer);
+    /**
+     * Compares the two collections to see if they are equivalent.
+     * 
+     * @param m1 The first collection
+     * @param m2 The second collection
+     * @param strict Indicates whether strict checking is required. Strict checking means that the
+     * two collections must have the same mappings. Non-strict checking means that the two
+     * collections must have the same keys. In both cases, the order is not significant.
+     * @return TRUE if the two collections are equivalent FALSE, otherwise
+     */
+    public static boolean isEquivalent(Map m1, Map m2, boolean strict) {
+        return ActivateUtils.isEquivalent(m1, m2, strict);
+    }
 
-				// write the object to the test buffer
-				test_objOut.writeObject(obj);
-				test_objOut.close();
-
-				// put the contents of the test buffer into the
-				// real output stream
-				test_outBuffer.close();
-				byte[] data = test_outBuffer.toByteArray();
-				out.writeBoolean(ACTIVE_OBJECT);
-				out.writeObject(data);
-			} catch (NotSerializableException nse2) {
-				returned_exception = nse2;
-				// process this exception
-				traceNotSerializable(obj, nse2, desc,
-						"ObjectStateUtils.writeObject()", OBJ_SAVE_PROBLEM);
-			} catch (IOException exc2) {
-				// use this as a generic point for exceptions for the test
-				// output stream
-				returned_exception = exc2;
-
-				// trace point
-				if (log.isTraceEnabled()) {
-					log.trace("ObjectStateUtils:writeObject(): object["
-							+ obj.getClass().getName()
-							+ "]  ***Exception***  ["
-							+ exc2.getClass().getName() + " : "
-							+ exc2.getMessage() + "]  " + OBJ_SAVE_PROBLEM,
-							exc2);
-					// exc2.printStackTrace();
-				}
-			}
-
-			if (returned_exception != null) {
-				// Write a null object into the stream instead of the data that
-				// failed
-				out.writeBoolean(EMPTY_OBJECT);
-
-				// let the caller know that there was a problem
-				// note the integrity of the real output stream has been
-				// preserved
-				throw returned_exception;
-			}
-		} else {
-			// this string is expected to fit the writeUTF limitations
-			out.writeUTF(desc);
-
-			out.writeBoolean(EMPTY_OBJECT);
-
-			// trace point
-			if (log.isTraceEnabled()) {
-				log.trace("ObjectStateUtils:writeObject(): EMPTY Object ["
-						+ desc + "]  ");
-			}
-		}
-	}
-
-	/**
-	 * Read an object from the specified input stream. Returns null if no object
-	 * is available. <p/> The format of the information to be read from the
-	 * input stream should be <BOLD>Non-Null Object</BOLD>
-	 * <LI> UTF - class name string
-	 * <LI> boolean - active flag
-	 * <LI> object - object if no error
-	 * <LI> LAST_ENTRY marker <p/> <BOLD>Null Object</BOLD>
-	 * <LI> UTF - description
-	 * <LI> boolean - empty flag <p/>
-	 * 
-	 * @param in
-	 *            The input stream
-	 * @param desc
-	 *            A text description to use for logging
-	 * @return The object or null, if not available
-	 * @throws IOException
-	 * @throws ClassNotFoundException
-	 */
-	public static Object readObject(ObjectInput in, String desc)
-			throws IOException, ClassNotFoundException {
-		Object obj = null;
-		byte[] data = null;
-
-		String str_desc = in.readUTF();
-
-		boolean isActive = in.readBoolean();
-
-		if (isActive == ACTIVE_OBJECT) {
-
-			// Read the byte array that contains our object
-			data = (byte[]) in.readObject();
-
-			// convert the byte[] back into the real object
-			ByteArrayInputStream test_inBuffer = new ByteArrayInputStream(data);
-			ObjectInputStream test_objIn = new ObjectInputStream(test_inBuffer);
-			obj = test_objIn.readObject();
-			test_objIn.close();
-			test_inBuffer.close();
-
-		}
-
-		String value = "null";
-
-		if (obj != null) {
-			value = obj.getClass().getName();
-		}
-
-		// trace point
-		if (log.isTraceEnabled()) {
-			log.trace("ObjectStateUtils:readObject(): [" + desc
-					+ "]  returning  [" + value + "]   for saved [" + str_desc
-					+ "]");
-		}
-
-		return obj;
-	}
-
-	/**
-	 * Write an array of objects to the specified output stream. <p/> The format
-	 * of the information written to the output stream is
-	 * <LI> class name of the array
-	 * <LI> active or empty
-	 * <LI> data <p/> NOTE: each object in the array should implement either
-	 * java.io.Serializable or java.io.Externalizable in order to be saved <p/>
-	 * 
-	 * @param out
-	 *            The output stream
-	 * @param al
-	 *            The ArrayList to write
-	 * @param desc
-	 *            A text description to use for logging
-	 * @throws IOException
-	 *             Exception
-	 */
-	public static void writeArrayList(ObjectOutput out, ArrayList al,
-			String desc) throws IOException {
-		// The format of the data is
-		//
-		// Non-null list:
-		// UTF - description string
-		// boolean - active flag
-		// objects - objects from list
-		// - ACTIVE_OBJECT
-		// - data
-		// EMPTY_OBJEXT - end of array marker
-		//    
-		// Null list:
-		// UTF - description string
-		// boolean - empty flag
-		//
-		int savedListSize = 0;
-
-		out.writeUTF(desc);
-		out.writeBoolean(al == null ? EMPTY_OBJECT : ACTIVE_OBJECT);
-
-		if (al != null) {
-			// setup an iterator for the list
-			Iterator i = al.iterator();
-			while (i.hasNext()) {
-
-				Object obj = i.next();
-				try {
-					// put each list entry into a test output buffer to see if
-					// it can be saved
-					// this technique preserves the integrity of the real output
-					// stream in the
-					// event of a serialization error
-					ByteArrayOutputStream test_outBuffer = new ByteArrayOutputStream();
-					ObjectOutputStream test_objOut = new ObjectOutputStream(
-							test_outBuffer);
-
-					// write the object to the test buffer
-					test_objOut.writeObject(obj);
-					test_objOut.flush();
-
-					byte[] data = test_outBuffer.toByteArray();
-					out.writeBoolean(ACTIVE_OBJECT);
-					out.writeObject(data);
-
-					test_objOut.close();
-					test_outBuffer.close();
-					savedListSize++;
-				} catch (NotSerializableException nse2) {
-					// process this exception
-					traceNotSerializable(obj, nse2, desc,
-							"ObjectStateUtils.writeArrayList()",
-							OBJ_SAVE_PROBLEM);
-				} catch (Exception exc) {
-					// use this as a generic point for exceptions
-
-					// trace point
-					if (log.isTraceEnabled()) {
-						log.trace("ObjectStateUtils:writeArrayList(): object["
-								+ obj.getClass().getName()
-								+ "]  ***Exception***  ["
-								+ exc.getClass().getName() + " : "
-								+ exc.getMessage() + "]  " + OBJ_SAVE_PROBLEM,
-								exc);
-						// exc.printStackTrace();
-					}
-				}
-			}
-
-			// put the end-of-marker in the stream
-			out.writeBoolean(EMPTY_OBJECT);
-		}
-		// trace point
-		if (log.isTraceEnabled()) {
-			log.trace("ObjectStateUtils:writeArrayList(): List [" + desc
-					+ "]   members saved [" + savedListSize + "]");
-		}
-	}
-
-	/**
-	 * Reads an array of objects from the specified input stream. Returns null
-	 * if no array is available. <p/> The format of the information to be read
-	 * from the input stream should be
-	 * <LI> class name
-	 * <LI> active or empty
-	 * <LI> data <p/> NOTE: each object in the array should implement either
-	 * java.io.Serializable or java.io.Externalizable in order to be saved <p/>
-	 * 
-	 * @param in
-	 *            The input stream
-	 * @param desc
-	 *            A text description to use for logging
-	 * @return The ArrayList or null, if not available
-	 * @throws IOException
-	 * @throws ClassNotFoundException
-	 */
-	public static ArrayList readArrayList(ObjectInput in, String desc)
-			throws IOException {
-		// The format of the data is
-		//
-		// Non-null list:
-		// UTF - description string
-		// boolean - active flag
-		// objects - objects from list
-		// - ACTIVE_OBJECT
-		// - data
-		// EMPTY_OBJEXT - end of array marker
-		//    
-		// Null list:
-		// UTF - description string
-		// boolean - empty flag
-		//
-
-		ArrayList list = null;
-
-		String str_desc = in.readUTF();
-
-		boolean isActive = in.readBoolean();
-
-		if (isActive == ACTIVE_OBJECT) {
-			list = new ArrayList();
-
-			// stop when we get to the end-of-list marker
-			while (in.readBoolean()) {
-
-				// get the object
-				try {
-					byte[] data = (byte[]) in.readObject();
-
-					// convert the byte[] back into the real object
-					ByteArrayInputStream test_inBuffer = new ByteArrayInputStream(
-							data);
-					ObjectInputStream test_objIn = new ObjectInputStream(
-							test_inBuffer);
-					Object obj = test_objIn.readObject();
-					test_objIn.close();
-					test_inBuffer.close();
-
-					// add the entry to the list
-					list.add(obj);
-
-					// trace point
-					if (log.isTraceEnabled()) {
-						log.trace("ObjectStateUtils:readArrayList(): [" + desc
-								+ "]  index [" + list.size() + "]  for saved ["
-								+ str_desc + "]");
-					}
-				} catch (Exception ex) {
-					// use this as a generic point for all exceptions
-
-					// trace point
-					if (log.isTraceEnabled()) {
-						log.trace(
-								"ObjectStateUtils:readArrayList(): [" + desc
-										+ "]  object index [" + list.size()
-										+ "]   for saved [" + str_desc
-										+ "]  ***Exception***  ["
-										+ ex.getClass().getName() + " : "
-										+ ex.getMessage() + "]  "
-										+ OBJ_RESTORE_PROBLEM, ex);
-						// ex.printStackTrace();
-					}
-				}
-
-			} // end while keep going
-		}
-
-		// trace point
-		if (log.isTraceEnabled()) {
-			int size = (list == null) ? -1 : list.size();
-			log.trace("ObjectStateUtils:readArrayList(): [" + desc
-					+ "]  returning  [listsize=" + size + "]  for saved ["
-					+ str_desc + "]");
-		}
-		return list;
-	}
-
-	/**
-	 * Write a hashmap of objects to the specified output stream. <p/> The
-	 * format of the information written to the output stream is
-	 * <LI> class name of the array
-	 * <LI> active or empty
-	 * <LI> data <p/> NOTE: each object in the map should implement either
-	 * java.io.Serializable or java.io.Externalizable in order to be saved <p/>
-	 * 
-	 * @param out
-	 *            The output stream
-	 * @param map
-	 *            The HashMap to write
-	 * @param desc
-	 *            A text description to use for logging
-	 * @throws IOException
-	 *             Exception
-	 */
-	public static void writeHashMap(ObjectOutput out, HashMap map, String desc)
-			throws IOException {
-		// The format of the data is
-		//
-		// Non-null map:
-		// UTF - description string
-		// boolean - active flag
-		// objects - object,object pairs from list
-		// - active flag
-		// - key
-		// - value
-		// EMPTY OBJECT - end marker
-		//    
-		// Empty list:
-		// UTF - description string
-		// boolean - empty flag
-		//
-		int savedMapSize = 0;
-
-		out.writeUTF(desc);
-		out.writeBoolean(map == null ? EMPTY_OBJECT : ACTIVE_OBJECT);
-
-		if (map != null) {
-			Set keyset = map.keySet();
-			Iterator i = keyset.iterator();
-
-			while (i.hasNext()) {
-				// handle errors when can't access the value for the key
-
-				Object key = i.next();
-				Object value = map.get(key);
-
-				try {
-					// put each pair into a buffer to see if they can be saved
-					ByteArrayOutputStream pair_outBuffer = new ByteArrayOutputStream();
-					ObjectOutputStream pair_objOut = new ObjectOutputStream(
-							pair_outBuffer);
-
-					// write the objects in pairs
-					pair_objOut.writeObject(key);
-					pair_objOut.writeObject(value);
-					pair_objOut.flush();
-
-					byte[] data = pair_outBuffer.toByteArray();
-					out.writeBoolean(ACTIVE_OBJECT);
-					out.writeObject(data);
-
-					pair_objOut.close();
-					pair_outBuffer.close();
-					savedMapSize++;
-				} catch (NotSerializableException nse2) {
-					// only trace the first time a particular class causes this
-					// exception
-					traceNotSerializable(key, nse2, desc,
-							"ObjectStateUtils.writeHashMap() map key",
-							OBJ_SAVE_PROBLEM);
-				} catch (Exception exc) {
-					// use this as a generic point for exceptions
-
-					// trace point
-					if (log.isTraceEnabled()) {
-						log.trace("ObjectStateUtils:writeHashMap(): map key ["
-								+ key.getClass().getName()
-								+ "]  ***Exception***  ["
-								+ exc.getClass().getName() + " : "
-								+ exc.getMessage() + "]  " + OBJ_SAVE_PROBLEM,
-								exc);
-						// exc.printStackTrace();
-					}
-				}
-			}
-
-			// write out a marker for the end of list
-			out.writeBoolean(EMPTY_OBJECT);
-
-		}
-
-		// trace point
-		if (log.isTraceEnabled()) {
-			log.trace("ObjectStateUtils:writeHashMap(): map [" + desc
-					+ "]   members saved [" + savedMapSize + "]");
-		}
-	}
-
-	/**
-	 * Read a hashmap of objects from the specified input stream. Returns null
-	 * if no hashmap is available. <p/> The format of the information to be read
-	 * from the input stream should be
-	 * <LI> class name
-	 * <LI> active or empty
-	 * <LI> data <p/> NOTE: each object in the array should implement either
-	 * java.io.Serializable or java.io.Externalizable in order to be saved <p/>
-	 * 
-	 * @param in
-	 *            The input stream
-	 * @param desc
-	 *            A text description to use for logging
-	 * @return The HashMap or null, if not available
-	 * @throws IOException
-	 * @throws ClassNotFoundException
-	 */
-	public static HashMap readHashMap(ObjectInput in, String desc)
-			throws IOException {
-		// The format of the data is
-		//
-		// Non-null map:
-		// UTF - description string
-		// boolean - active flag
-		// objects - object,object pairs from list
-		// - active flag
-		// - key
-		// - value
-		// EMPTY OBJECT - end marker
-		//    
-		// Empty list:
-		// UTF - description string
-		// boolean - empty flag
-		//
-		int obtainedMapSize = 0;
-
-		HashMap map = null;
-		String str_desc = in.readUTF();
-		boolean isActive = in.readBoolean();
-
-		if (isActive == ACTIVE_OBJECT) {
-			map = new HashMap();
-
-			while (in.readBoolean()) {
-				Object key = null;
-				Object value = null;
-
-				try {
-					byte[] data = (byte[]) in.readObject();
-
-					// convert the byte[] back into the real objects
-					ByteArrayInputStream test_inBuffer = new ByteArrayInputStream(
-							data);
-					ObjectInputStream test_objIn = new ObjectInputStream(
-							test_inBuffer);
-					key = test_objIn.readObject();
-					value = test_objIn.readObject();
-					test_objIn.close();
-					test_inBuffer.close();
-
-					// add the entry to the map
-					map.put(key, value);
-					obtainedMapSize++;
-
-					// trace point
-					if (log.isTraceEnabled()) {
-						log.trace("ObjectStateUtils:readHashMap(): [" + desc
-								+ "]  object pair index [" + obtainedMapSize
-								+ "]   for saved [" + str_desc + "]");
-					}
-				} catch (Exception ex) {
-					// use this as a generic point for all exceptions
-
-					// trace point
-					if (log.isTraceEnabled()) {
-						log.trace(
-								"ObjectStateUtils:readHashMap(): [" + desc
-										+ "]  object pair index ["
-										+ obtainedMapSize + "]   for saved ["
-										+ str_desc + "] ***Exception***  ["
-										+ ex.getClass().getName() + " : "
-										+ ex.getMessage() + "]  "
-										+ OBJ_RESTORE_PROBLEM, ex);
-						// ex.printStackTrace();
-					}
-				}
-			}
-		}
-
-		int size = (map == null) ? -1 : map.size();
-		if (log.isTraceEnabled()) {
-			log.trace("ObjectStateUtils:readHashMap(): [" + desc
-					+ "]  returning  [mapsize=" + size + "]    for saved ["
-					+ str_desc + "]");
-		}
-
-		return map;
-	}
-
-	/**
-	 * Write a linked list of objects to the specified output stream. <p/> The
-	 * format of the information written to the output stream is
-	 * <LI> class name of the array
-	 * <LI> active or empty
-	 * <LI> data <p/> NOTE: each object in the array should implement either
-	 * java.io.Serializable or java.io.Externalizable in order to be saved <p/>
-	 * 
-	 * @param out
-	 *            The output stream
-	 * @param list
-	 *            The LinkedList to write
-	 * @param desc
-	 *            A text description to use for logging
-	 * @throws IOException
-	 *             Exception
-	 */
-	public static void writeLinkedList(ObjectOutput out, LinkedList objlist,
-			String desc) throws IOException {
-		// The format of the data is
-		//
-		// Non-null list:
-		// UTF - description string
-		// boolean - active flag
-		// objects - objects from list
-		// - ACTIVE_OBJECT
-		// - data
-		// EMPTY_OBJEXT - end of array marker
-		//    
-		// Null list:
-		// UTF - description string
-		// boolean - empty flag
-		//
-		int savedListSize = 0;
-
-		out.writeUTF(desc);
-		out.writeBoolean(objlist == null ? EMPTY_OBJECT : ACTIVE_OBJECT);
-
-		if (objlist != null) {
-			// setup an iterator for the list
-			Iterator i = objlist.iterator();
-
-			while (i.hasNext()) {
-				Object obj = i.next();
-
-				try {
-					// put each list entry into a test output buffer to see if
-					// it can be saved
-					// this technique preserves the integrity of the real output
-					// stream in the
-					// event of a serialization error
-					ByteArrayOutputStream test_outBuffer = new ByteArrayOutputStream();
-					ObjectOutputStream test_objOut = new ObjectOutputStream(
-							test_outBuffer);
-
-					// write the object to the test buffer
-					test_objOut.writeObject(obj);
-					test_objOut.flush();
-
-					byte[] data = test_outBuffer.toByteArray();
-					out.writeBoolean(ACTIVE_OBJECT);
-					out.writeObject(data);
-
-					test_objOut.close();
-					test_outBuffer.close();
-					savedListSize++;
-				} catch (NotSerializableException nse2) {
-					// process this exception
-					traceNotSerializable(obj, nse2, desc,
-							"ObjectStateUtils.writeLinkedList()",
-							OBJ_SAVE_PROBLEM);
-				} catch (Exception exc) {
-					// use this as a generic point for exceptions
-
-					// trace point
-					if (log.isTraceEnabled()) {
-						log.trace("ObjectStateUtils:writeLinkedList(): object["
-								+ obj.getClass().getName()
-								+ "]  ***Exception***  ["
-								+ exc.getClass().getName() + " : "
-								+ exc.getMessage() + "]  " + OBJ_SAVE_PROBLEM,
-								exc);
-						// exc.printStackTrace();
-					}
-				}
-			}
-
-			// put the end-of-marker in the stream
-			out.writeBoolean(EMPTY_OBJECT);
-		}
-		// trace point
-		if (log.isTraceEnabled()) {
-			log.trace("ObjectStateUtils:writeLinkedList(): List [" + desc
-					+ "]   members saved [" + savedListSize + "]");
-		}
-	}
-
-	/**
-	 * Reads a linked list of objects from the specified input stream. Returns
-	 * null if no array is available. <p/> The format of the information to be
-	 * read from the input stream should be
-	 * <LI> class name
-	 * <LI> active or empty
-	 * <LI> data <p/> NOTE: each object in the list should implement either
-	 * java.io.Serializable or java.io.Externalizable in order to be saved <p/>
-	 * 
-	 * @param in
-	 *            The input stream
-	 * @param desc
-	 *            A text description to use for logging
-	 * @return The linked list or null, if not available
-	 * @throws IOException
-	 * @throws ClassNotFoundException
-	 */
-	public static LinkedList readLinkedList(ObjectInput in, String desc)
-			throws IOException {
-		// The format of the data is
-		//
-		// Non-null list:
-		// UTF - description string
-		// boolean - active flag
-		// objects - objects from list
-		// - ACTIVE_OBJECT
-		// - data
-		// EMPTY_OBJEXT - end of array marker
-		//    
-		// Null list:
-		// UTF - description string
-		// boolean - empty flag
-		//
-
-		LinkedList list = null;
-
-		String str_desc = in.readUTF();
-
-		boolean isActive = in.readBoolean();
-
-		if (isActive == ACTIVE_OBJECT) {
-			list = new LinkedList();
-
-			// stop when we get to the end-of-list marker
-			while (in.readBoolean()) {
-
-				// get the object
-				try {
-					byte[] data = (byte[]) in.readObject();
-
-					// convert the byte[] back into the real object
-					ByteArrayInputStream test_inBuffer = new ByteArrayInputStream(
-							data);
-					ObjectInputStream test_objIn = new ObjectInputStream(
-							test_inBuffer);
-					Object obj = test_objIn.readObject();
-					test_objIn.close();
-					test_inBuffer.close();
-
-					// add the entry to the list
-					list.add(obj);
-
-					// trace point
-					if (log.isTraceEnabled()) {
-						log.trace("ObjectStateUtils:readArrayList(): [" + desc
-								+ "]  index [" + list.size() + "]  for saved ["
-								+ str_desc + "]");
-					}
-				} catch (Exception ex) {
-					// use this as a generic point for all exceptions
-
-					// trace point
-					if (log.isTraceEnabled()) {
-						log.trace(
-								"ObjectStateUtils:readArrayList(): [" + desc
-										+ "]  object index [" + list.size()
-										+ "]   for saved [" + str_desc
-										+ "]  ***Exception***  ["
-										+ ex.getClass().getName() + " : "
-										+ ex.getMessage() + "]  "
-										+ OBJ_RESTORE_PROBLEM, ex);
-						// ex.printStackTrace();
-					}
-				}
-
-			} // end while keep going
-		}
-
-		// trace point
-		if (log.isTraceEnabled()) {
-			int size = (list == null) ? -1 : list.size();
-			log.trace("ObjectStateUtils:readArrayList(): [" + desc
-					+ "]  returning  [listsize=" + size + "]  for saved ["
-					+ str_desc + "]");
-		}
-		return list;
-	}
-
-	// --------------------------------------------------------------------
-	// Finder methods
-	// --------------------------------------------------------------------
-
-	/**
-	 * Find the AxisOperation object that matches the criteria
-	 * 
-	 * @param axisConfig
-	 *            The AxisConfiguration object
-	 * @param opClassName
-	 *            the class name string for the target object (could be a
-	 *            derived class)
-	 * @param opQName
-	 *            the name associated with the operation
-	 * @return the AxisOperation object that matches the given criteria
-	 */
-	public static AxisOperation findOperation(AxisConfiguration axisConfig,
-			String opClassName, QName opQName) {
-		HashMap services = axisConfig.getServices();
-
-		Iterator its = services.values().iterator();
-
-		while (its.hasNext()) {
-			AxisService service = (AxisService) its.next();
-
-			Iterator ito = service.getOperations();
-
-			while (ito.hasNext()) {
-				AxisOperation operation = (AxisOperation) ito.next();
-
-				String tmpOpName = operation.getClass().getName();
-				QName tmpOpQName = operation.getName();
-
-				if ((tmpOpName.equals(opClassName))
-						&& (tmpOpQName.equals(opQName))) {
-					// trace point
-					if (log.isTraceEnabled()) {
-						log
-								.trace("ObjectStateUtils:findOperation(axisCfg): returning  ["
-										+ opClassName
-										+ "]   ["
-										+ opQName.toString() + "]");
-					}
-
-					return operation;
-				}
-			}
-		}
-
-		// trace point
-		if (log.isTraceEnabled()) {
-			log.trace("ObjectStateUtils:findOperation(axisCfg): ["
-					+ opClassName + "]   [" + opQName.toString()
-					+ "]  returning  [null]");
-		}
-
-		return null;
-	}
-
-	/**
-	 * Find the AxisOperation object that matches the criteria
-	 * 
-	 * @param service
-	 *            The AxisService object
-	 * @param opClassName
-	 *            The class name string for the target object (could be a
-	 *            derived class)
-	 * @param opQName
-	 *            the name associated with the operation
-	 * @return the AxisOperation object that matches the given criteria
-	 */
-	public static AxisOperation findOperation(AxisService service,
-			String opClassName, QName opQName) {
-		if (service == null) {
-			return null;
-		}
-
-		Iterator ito = service.getOperations();
-
-		while (ito.hasNext()) {
-			AxisOperation operation = (AxisOperation) ito.next();
-
-			String tmpOpName = operation.getClass().getName();
-			QName tmpOpQName = operation.getName();
-
-			if ((tmpOpName.equals(opClassName)) && (tmpOpQName.equals(opQName))) {
-				// trace point
-				if (log.isTraceEnabled()) {
-					log
-							.trace("ObjectStateUtils:findOperation(service): returning  ["
-									+ opClassName
-									+ "]   ["
-									+ opQName.toString() + "]");
-				}
-
-				return operation;
-			}
-		}
-
-		// trace point
-		if (log.isTraceEnabled()) {
-			log.trace("ObjectStateUtils:findOperation(service): ["
-					+ opClassName + "]   [" + opQName.toString()
-					+ "]  returning  [null]");
-		}
-
-		return null;
-	}
-
-	/**
-	 * Find the AxisService object that matches the criteria
-	 * 
-	 * @param axisConfig
-	 *            The AxisConfiguration object
-	 * @param serviceClassName
-	 *            the class name string for the target object (could be a
-	 *            derived class)
-	 * @param serviceName
-	 *            the name associated with the service
-	 * @return the AxisService object that matches the criteria
-	 */
-	public static AxisService findService(AxisConfiguration axisConfig,
-			String serviceClassName, String serviceName) {
-		HashMap services = axisConfig.getServices();
-
-		Iterator its = services.values().iterator();
-
-		while (its.hasNext()) {
-			AxisService service = (AxisService) its.next();
-
-			String tmpServClassName = service.getClass().getName();
-			String tmpServName = service.getName();
-
-			if ((tmpServClassName.equals(serviceClassName))
-					&& (tmpServName.equals(serviceName))) {
-				// trace point
-				if (log.isTraceEnabled()) {
-					log.trace("ObjectStateUtils:findService(): returning  ["
-							+ serviceClassName + "]   [" + serviceName + "]");
-				}
-
-				return service;
-			}
-		}
-
-		// trace point
-		if (log.isTraceEnabled()) {
-			log.trace("ObjectStateUtils:findService(): [" + serviceClassName
-					+ "]   [" + serviceName + "]  returning  [null]");
-		}
-
-		return null;
-	}
-
-	/**
-	 * Find the AxisServiceGroup object that matches the criteria <p/> <B>Note<B>
-	 * the saved service group meta information may not match up with any of the
-	 * serviceGroups that are in the current AxisConfiguration object.
-	 * 
-	 * @param axisConfig
-	 *            The AxisConfiguration object
-	 * @param serviceGrpClassName
-	 *            the class name string for the target object (could be a
-	 *            derived class)
-	 * @param serviceGrpName
-	 *            the name associated with the service group
-	 * @return the AxisServiceGroup object that matches the criteria
-	 */
-	public static AxisServiceGroup findServiceGroup(
-			AxisConfiguration axisConfig, String serviceGrpClassName,
-			String serviceGrpName) {
-		Iterator its = axisConfig.getServiceGroups();
-
-		while (its.hasNext()) {
-			AxisServiceGroup serviceGroup = (AxisServiceGroup) its.next();
-
-			String tmpSGClassName = serviceGroup.getClass().getName();
-			String tmpSGName = serviceGroup.getServiceGroupName();
-
-			if (tmpSGClassName.equals(serviceGrpClassName)) {
-				boolean found = false;
-
-				// the serviceGroupName can be null, so either both the
-				// service group names are null or they match
-				if ((tmpSGName == null) && (serviceGrpName == null)) {
-					found = true;
-				} else if ((tmpSGName != null)
-						&& (tmpSGName.equals(serviceGrpName))) {
-					found = true;
-				}
-
-				if (found) {
-					// trace point
-					if (log.isTraceEnabled()) {
-						log
-								.trace("ObjectStateUtils:findServiceGroup(): returning  ["
-										+ serviceGrpClassName
-										+ "]   ["
-										+ serviceGrpName + "]");
-					}
-
-					return serviceGroup;
-				}
-			}
-		}
-
-		// trace point
-		if (log.isTraceEnabled()) {
-			log.trace("ObjectStateUtils:findServiceGroup(): ["
-					+ serviceGrpClassName + "]   [" + serviceGrpName
-					+ "]  returning  [null]");
-		}
-
-		return null;
-	}
-
-	/**
-	 * Find the AxisMessage object that matches the criteria
-	 * 
-	 * @param op
-	 *            The AxisOperation object
-	 * @param msgName
-	 *            The name associated with the message
-	 * @param msgElementName
-	 *            The name associated with the message element
-	 * @return the AxisMessage object that matches the given criteria
-	 */
-	public static AxisMessage findMessage(AxisOperation op, String msgName,
-			String msgElementName) {
-		// Several kinds of AxisMessages can be associated with a particular
-		// AxisOperation. The kinds of AxisMessages that are typically
-		// accessible are associated with "in" and "out".
-		// There are also different kinds of AxisOperations, and each
-		// type of AxisOperation can have its own mix of AxisMessages
-		// depending on the style of message exchange pattern (mep)
-
-		if (op == null) {
-			// trace point
-			if (log.isTraceEnabled()) {
-				log.trace("ObjectStateUtils:findMessage(): [" + msgName
-						+ "]  [" + msgElementName
-						+ "] returning  [null] - no AxisOperation");
-			}
-
-			return null;
-		}
-
-		if (msgName == null) {
-			// nothing to match with, expect to match against a name
-			// trace point
-			if (log.isTraceEnabled()) {
-				log.trace("ObjectStateUtils:findMessage(): [" + msgName
-						+ "]  [" + msgElementName
-						+ "] returning  [null] - message name is not set");
-			}
-
-			return null;
-		}
-
-		String tmpName = null;
-		String tmpElementName = null;
-
-		// -------------------------------------
-		// first try the "out" message
-		// -------------------------------------
-		AxisMessage out = null;
-		try {
-			out = op.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
-		} catch (Exception ex) {
-			// just absorb the exception
-		}
-
-		if (out != null) {
-			tmpName = out.getName();
-
-			QName tmpQout = out.getElementQName();
-			if (tmpQout != null) {
-				tmpElementName = tmpQout.toString();
-			}
-		}
-
-		// check the criteria for a match
-
-		boolean matching = matchMessageNames(tmpName, tmpElementName, msgName,
-				msgElementName);
-
-		if (matching) {
-			// trace point
-			if (log.isTraceEnabled()) {
-				log
-						.trace("ObjectStateUtils:findMessage(): returning OUT message  ["
-								+ msgName + "]  [" + msgElementName + "] ");
-			}
-
-			return out;
-		}
-
-		// -------------------------------------
-		// next, try the "in" message
-		// -------------------------------------
-		AxisMessage in = null;
-		try {
-			in = op.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE);
-		} catch (Exception ex) {
-			// just absorb the exception
-		}
-
-		if (in != null) {
-			tmpName = in.getName();
-
-			QName tmpQin = in.getElementQName();
-			if (tmpQin != null) {
-				tmpElementName = tmpQin.toString();
-			}
-		} else {
-			tmpName = null;
-			tmpElementName = null;
-		}
-
-		// check the criteria for a match
-
-		matching = matchMessageNames(tmpName, tmpElementName, msgName,
-				msgElementName);
-
-		if (matching) {
-			// trace point
-			if (log.isTraceEnabled()) {
-				log
-						.trace("ObjectStateUtils:findMessage(): returning IN message ["
-								+ msgName + "]  [" + msgElementName + "] ");
-			}
-
-			return in;
-		}
-
-		// if we got here, then no match was found
-
-		// trace point
-		if (log.isTraceEnabled()) {
-			log.trace("ObjectStateUtils:findMessage(): [" + msgName + "]  ["
-					+ msgElementName + "] returning  [null]");
-		}
-
-		return null;
-	}
-
-	/**
-	 * Check the first set of names for a match against the second set of names.
-	 * These names are associated with AxisMessage objects. Message names are
-	 * expected to be non-null. Element names could be either null or non-null.
-	 * 
-	 * @param name1
-	 *            The name for the first message
-	 * @param elementName1
-	 *            The element name for the first message
-	 * @param name2
-	 *            The name for the second message
-	 * @param elementName2
-	 *            The element name for the second message
-	 * @return TRUE if there's a match, FALSE otherwise
-	 */
-	private static boolean matchMessageNames(String name1, String elementName1,
-			String name2, String elementName2) {
-		// the name for the message must exist
-		if ((name1 != null) && (name2 != null) && (name1.equals(name2))) {
-			// there's a match on the name associated with the message object
-
-			// element names need to match, including being null
-			if ((elementName1 == null) && (elementName2 == null)) {
-				// there's a match for the nulls
-				return true;
-			} else if ((elementName1 != null) && (elementName2 != null)
-					&& (elementName1.equals(elementName2))) {
-				// there's a match for the element names
-				return true;
-			} else {
-				// there's some mismatch
-				return false;
-			}
-		} else {
-			// either a message name is null or the names don't match
-			return false;
-		}
-	}
-
-	/**
-	 * Find the Handler object that matches the criteria
-	 * 
-	 * @param existingHandlers
-	 *            The list of existing handlers and phases
-	 * @param handlerClassName
-	 *            the class name string for the target object (could be a
-	 *            derived class)
-	 * @return the Handler object that matches the criteria
-	 */
-	public static Object findHandler(ArrayList existingHandlers,
-			MetaDataEntry metaDataEntry) // String handlerClassName)
-	{
-
-		String title = "ObjectStateUtils:findHandler(): ";
-
-		String handlerClassName = metaDataEntry.getClassName();
-		String qNameAsString = metaDataEntry.getQNameAsString();
-
-		for (int i = 0; i < existingHandlers.size(); i++) {
-			if (existingHandlers.get(i) != null) {
-				String tmpClassName = existingHandlers.get(i).getClass()
-						.getName();
-				String tmpName = ((Handler) existingHandlers.get(i)).getName()
-						.toString();
-
-				if ((tmpClassName.equals(handlerClassName))
-						&& (tmpName.equals(qNameAsString))) {
-					// trace point
-					if (log.isTraceEnabled()) {
-						log.trace(title + " [" + handlerClassName + "]  name ["
-								+ qNameAsString + "]  returned");
-					}
-
-					return (Handler) (existingHandlers.get(i));
-				}
-			}
-		}
-
-		// trace point
-		if (log.isTraceEnabled()) {
-			log.trace(title + " [" + handlerClassName + "]  name ["
-					+ qNameAsString
-					+ "] was not found in the existingHandlers list");
-		}
-
-		return null;
-	}
-
-	/**
-	 * Find the TransportListener object that matches the criteria <p/> <B>Note<B>
-	 * the saved meta information may not match up with any of the objects that
-	 * are in the current AxisConfiguration object.
-	 * 
-	 * @param axisConfig
-	 *            The AxisConfiguration object
-	 * @param listenerClassName
-	 *            the class name string for the target object (could be a
-	 *            derived class)
-	 * @return the TransportListener object that matches the criteria
-	 */
-	public static TransportListener findTransportListener(
-			AxisConfiguration axisConfig, String listenerClassName) {
-		// TODO: investigate a better technique to match up with a
-		// TransportListener
-
-		HashMap transportsIn = axisConfig.getTransportsIn();
-
-		// get a collection of the values in the map
-		Collection values = transportsIn.values();
-
-		Iterator i = values.iterator();
-
-		while (i.hasNext()) {
-			TransportInDescription ti = (TransportInDescription) i.next();
-
-			TransportListener tl = ti.getReceiver();
-			String tlClassName = tl.getClass().getName();
-
-			if (tlClassName.equals(listenerClassName)) {
-				// trace point
-				if (log.isTraceEnabled()) {
-					log.trace("ObjectStateUtils:findTransportListener():  ["
-							+ listenerClassName + "]  returned");
-				}
-
-				return tl;
-			}
-		}
-
-		// trace point
-		if (log.isTraceEnabled()) {
-			log
-					.trace("ObjectStateUtils:findTransportListener(): returning  [null]");
-		}
-
-		return null;
-	}
-
-	/**
-	 * Compares the two collections to see if they are equivalent.
-	 * 
-	 * @param a1
-	 *            The first collection
-	 * @param a2
-	 *            The second collection
-	 * @param strict
-	 *            Indicates whether strict checking is required. Strict checking
-	 *            means that the two collections must have the same elements in
-	 *            the same order. Non-strict checking means that the two
-	 *            collections must have the same elements, but the order is not
-	 *            significant.
-	 * @return TRUE if the two collections are equivalent FALSE, otherwise
-	 */
-	public static boolean isEquivalent(ArrayList a1, ArrayList a2,
-			boolean strict) {
-		if ((a1 != null) && (a2 != null)) {
-			// check number of elements in lists
-			int size1 = a1.size();
-			int size2 = a2.size();
-
-			if (size1 != size2) {
-				// trace point
-				if (log.isTraceEnabled()) {
-					log
-							.trace("ObjectStateUtils:isEquivalent(ArrayList,ArrayList): FALSE - size mismatch ["
-									+ size1 + "] != [" + size2 + "]");
-				}
-				return false;
-			}
-
-			if (strict) {
-				// Strict checking
-				// The lists must contain the same elements in the same order.
-				return (a1.equals(a2));
-			} else {
-				// Non-strict checking
-				// The lists must contain the same elements but the order is not
-				// required.
-				Iterator i1 = a1.iterator();
-
-				while (i1.hasNext()) {
-					Object obj1 = i1.next();
-
-					if (!a2.contains(obj1)) {
-						// trace point
-						if (log.isTraceEnabled()) {
-							log
-									.trace("ObjectStateUtils:isEquivalent(ArrayList,ArrayList): FALSE - mismatch with element ["
-											+ obj1.getClass().getName() + "] ");
-						}
-						return false;
-					}
-				}
-
-				return true;
-			}
-
-		} else if ((a1 == null) && (a2 == null)) {
-			return true;
-		} else if ((a1 != null) && (a2 == null)) {
-			if (a1.size() == 0) {
-				return true;
-			}
-			return false;
-		} else if ((a1 == null) && (a2 != null)) {
-			if (a2.size() == 0) {
-				return true;
-			}
-			return false;
-		} else {
-			// mismatch
-
-			// trace point
-			if (log.isTraceEnabled()) {
-				log
-						.trace("ObjectStateUtils:isEquivalent(ArrayList,ArrayList): FALSE - mismatch in lists");
-			}
-			return false;
-		}
-	}
-
-	/**
-	 * Compares the two collections to see if they are equivalent.
-	 * 
-	 * @param m1
-	 *            The first collection
-	 * @param m2
-	 *            The second collection
-	 * @param strict
-	 *            Indicates whether strict checking is required. Strict checking
-	 *            means that the two collections must have the same mappings.
-	 *            Non-strict checking means that the two collections must have
-	 *            the same keys. In both cases, the order is not significant.
-	 * @return TRUE if the two collections are equivalent FALSE, otherwise
-	 */
-	public static boolean isEquivalent(Map m1, Map m2, boolean strict) {
-		if ((m1 != null) && (m2 != null)) {
-			if (strict) {
-				// This is a strict test.
-				// Returns true if the given object is also a map and the two
-				// Maps
-				// represent the same mappings.
-				return (m1.equals(m2));
-			} else {
-				int size1 = m1.size();
-				int size2 = m2.size();
-
-				if (size1 != size2) {
-					return false;
-				}
-
-				// check the keys, ordering is not important between the two
-				// maps
-				Iterator it1 = m1.keySet().iterator();
-
-				while (it1.hasNext()) {
-					Object key1 = it1.next();
-
-					if (m2.containsKey(key1) == false) {
-						return false;
-					}
-				}
-
-				return true;
-			}
-		} else if ((m1 == null) && (m2 == null)) {
-			return true;
-		} else {
-			// mismatch
-			return false;
-		}
-	}
-
-	/**
-	 * Compares the two collections to see if they are equivalent.
-	 * 
-	 * @param l1
-	 *            The first collection
-	 * @param l2
-	 *            The second collection
-	 * @return TRUE if the two collections are equivalent FALSE, otherwise
-	 */
-	public static boolean isEquivalent(LinkedList l1, LinkedList l2) {
-		if ((l1 != null) && (l2 != null)) {
-			// This is a strict test.
-			// Returns true if the specified object is also a list,
-			// both lists have the same size, and all corresponding pairs
-			// of elements in the two lists are equal where
-			// they contain the same elements in the same order.
-			return (l1.equals(l2));
-		} else if ((l1 == null) && (l2 == null)) {
-			return true;
-		} else {
-			// mismatch
-			return false;
-		}
-	}
-
-	/**
-	 * Trace the NotSerializable exception for the specified object if this is
-	 * the first time that the specified object has caused the exception.
-	 * 
-	 * @param obj
-	 *            The object being saved or restored
-	 * @param nse
-	 *            The exception object with the details of the error
-	 * @param objDesc
-	 *            The description of the object, eg, like the field name where
-	 *            it is being used
-	 * @param methodName
-	 *            The method name which encountered the exception
-	 * @param desc
-	 *            Text to be used for tracing
-	 */
-	public static void traceNotSerializable(Object obj,
-			NotSerializableException nse, String objDesc, String methodName,
-			String desc) {
-		if (log.isTraceEnabled() == false) {
-			// if no tracing is being done, there's nothing to do
-			// exit quickly
-			return;
-		}
-
-		if (obj != null) {
-			String objName = obj.getClass().getName();
-
-			if (NotSerializableList.get(objName) == null) {
-				// set up some information about the exception
-				// for now, just use an initial counter, which we aren't doing
-				// much with
-				// but takes less space than the original object that caused the
-				// exception
-				// future: consider using a trace information object that would
-				// contain a count of the times that a particular class
-				// caused the exception, the class name of that class,
-				// and the stack trace for the first time - this information
-				// could then be accessed from a utility
-				Integer counter = new Integer(1);
-
-				// add to table
-				NotSerializableList.put(objName, counter);
-
-				// trace point
-				log.trace("ObjectStateUtils: ***NotSerializableException*** ["
-						+ nse.getMessage() + "] in method [" + methodName
-						+ "] for object [" + objName + "]  associated with ["
-						+ objDesc + "].  " + desc);
-			}
-
-		}
-
-	}
-
+    /**
+     * Compares the two collections to see if they are equivalent.
+     * 
+     * @param l1
+     *            The first collection
+     * @param l2
+     *            The second collection
+     * @return TRUE if the two collections are equivalent FALSE, otherwise
+     */
+    public static boolean isEquivalent(LinkedList l1, LinkedList l2) {
+        return ActivateUtils.isEquivalent(l1, l2);
+    }
 }
Index: C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/client/Options.java
===================================================================
--- C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/client/Options.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/kernel/src/org/apache/axis2/client/Options.java	(working copy)
@@ -27,17 +27,21 @@
 import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.addressing.RelatesTo;
 import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.externalize.ExternalizeConstants;
+import org.apache.axis2.context.externalize.SafeObjectInputStream;
+import org.apache.axis2.context.externalize.SafeObjectOutputStream;
+import org.apache.axis2.context.externalize.SafeSerializable;
 import org.apache.axis2.description.TransportInDescription;
 import org.apache.axis2.description.TransportOutDescription;
 import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.transport.TransportListener;
 import org.apache.axis2.util.MetaDataEntry;
-import org.apache.axis2.util.ObjectStateUtils;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import javax.xml.namespace.QName;
+
 import java.io.Externalizable;
 import java.io.IOException;
 import java.io.ObjectInput;
@@ -59,7 +63,7 @@
  * property inheritance, so that if a property is not set in one instance it
  * will check its parent for a setting.
  */
-public class Options implements Externalizable {
+public class Options implements Externalizable, SafeSerializable {
 
     /*
      * setup for logging
@@ -93,9 +97,9 @@
      * Refer to the writeExternal() and readExternal() methods.
      */
     // supported revision levels, add a new level to manage compatible changes
-    private static final int REVISION_1 = 1;
+    private static final int REVISION_2 = 2;
     // current revision level of this object
-    private static final int revisionID = REVISION_1;
+    private static final int revisionID = REVISION_2;
 
 
     /**
@@ -1025,7 +1029,8 @@
      * @param out The stream to write the object contents to
      * @throws IOException
      */
-    public void writeExternal(ObjectOutput out) throws IOException {
+    public void writeExternal(ObjectOutput o) throws IOException {
+        SafeObjectOutputStream out = SafeObjectOutputStream.install(o);
         String logCorrelationIDString = getLogCorrelationIDString();
 
         // write out contents of this object
@@ -1056,147 +1061,83 @@
         out.writeBoolean(manageSession);
 
         // the following objects could be null
-        ObjectStateUtils.writeObject(out, isExceptionToBeThrownOnSOAPFault,
-                                     logCorrelationIDString + ".isExceptionToBeThrownOnSOAPFault");
-        ObjectStateUtils.writeObject(out, useSeparateListener,
-                                     logCorrelationIDString + ".useSeparateListener");
+        out.writeObject(isExceptionToBeThrownOnSOAPFault);
+        out.writeObject(useSeparateListener);
 
         //---------------------------------------------------------
         // various strings
         //---------------------------------------------------------
 
         // String soapVersionURI
-        ObjectStateUtils
-                .writeString(out, soapVersionURI, logCorrelationIDString + ".soapVersionURI");
+        out.writeObject(soapVersionURI);
 
         // String action
-        ObjectStateUtils.writeString(out, action, logCorrelationIDString + ".action");
+        out.writeObject(action);
 
         // String transportInProtocol
-        ObjectStateUtils.writeString(out, transportInProtocol,
-                                     logCorrelationIDString + ".transportInProtocol");
+        out.writeObject(transportInProtocol);
 
         // String messageId
-        ObjectStateUtils.writeString(out, messageId, logCorrelationIDString + ".messageId");
+        out.writeObject(messageId);
 
         // String object id
-        ObjectStateUtils.writeString(out, logCorrelationIDString,
-                                     logCorrelationIDString + ".logCorrelationIDString");
+        out.writeObject(logCorrelationIDString);
 
         //---------------------------------------------------------
         // various objects
         //---------------------------------------------------------
+        
+        // Write out the EndpointReference values
+        out.writeObject(faultTo);
+        out.writeObject(from);
+        out.writeObject(replyTo);
+        out.writeObject(to);
+        
 
-        // put some try..catch blocks around the following objects
-        // so that the writing to the output stream continues
-        // even if one of the objects can't be serialized
-
-        try {
-            // EndpointReference faultTo
-            ObjectStateUtils.writeObject(out, faultTo, logCorrelationIDString + ".faultTo");
-        }
-        catch (Exception e1) {
-            // note that the utility class will provide the trace for the
-            // exception so we won't have to
-            // so just consume the exception for now
-        }
-
-        try {
-            // EndpointReference from
-            ObjectStateUtils.writeObject(out, from, logCorrelationIDString + ".from");
-        }
-        catch (Exception e2) {
-            // note that the utility class will provide the trace for the
-            // exception so we won't have to
-            // so just consume the exception for now
-        }
-
-        try {
-            // EndpointReference replyTo
-            ObjectStateUtils.writeObject(out, replyTo, logCorrelationIDString + ".replyTo");
-        }
-        catch (Exception e3) {
-            // note that the utility class will provide the trace for the
-            // exception so we won't have to
-            // so just consume the exception for now
-        }
-
-        try {
-            // EndpointReference to
-            ObjectStateUtils.writeObject(out, to, logCorrelationIDString + ".to");
-        }
-        catch (Exception e4) {
-            // note that the utility class will provide the trace for the
-            // exception so we won't have to
-            // so just consume the exception for now
-        }
-
         // TransportListener listener
+        metaListener = null;
         if (listener != null) {
             metaListener = new MetaDataEntry(listener.getClass().getName(), null);
-        } else {
-            metaListener = null;
         }
-        ObjectStateUtils.writeObject(out, metaListener, logCorrelationIDString + ".listener");
+        out.writeObject(metaListener);
 
         // TransportInDescription transportIn
+        metaTransportIn = null;
         if (transportIn != null) {
             metaTransportIn = new MetaDataEntry(null, transportIn.getName().toString());
-        } else {
-            metaTransportIn = null;
-        }
-        ObjectStateUtils.writeObject(out, metaTransportIn, logCorrelationIDString + ".transportIn");
+        } 
+        out.writeObject(metaTransportIn);
 
         // TransportOutDescription transportOut
+        metaTransportOut = null;
         if (transportOut != null) {
             metaTransportOut = new MetaDataEntry(null, transportOut.getName().toString());
-        } else {
-            metaTransportOut = null;
         }
-        ObjectStateUtils
-                .writeObject(out, metaTransportOut, logCorrelationIDString + ".transportOut");
+        out.writeObject(metaTransportOut);
 
         //---------------------------------------------------------
         // collections and lists
         //---------------------------------------------------------
-
+        
         // List relationships, which is an array of RelatesTo objects
-        ArrayList tmp = null;
+        out.writeList(relationships);
+       
 
-        if (relationships != null) {
-            // make sure this is an array list
-            tmp = new ArrayList(relationships);
-        }
-
-        ObjectStateUtils.writeArrayList(out, tmp, logCorrelationIDString + ".relationships");
-
         // ArrayList referenceParameters
-        ObjectStateUtils.writeArrayList(out, referenceParameters,
-                                        logCorrelationIDString + ".referenceParameters");
+        out.writeList(referenceParameters);
 
         //---------------------------------------------------------
         // properties
         //---------------------------------------------------------
 
         // HashMap properties
-        HashMap tmpHM = new HashMap(getProperties());
+        out.writeMap(properties);
 
-        ObjectStateUtils.writeHashMap(out, tmpHM, logCorrelationIDString + ".properties");
-
         //---------------------------------------------------------
         // "nested"
         //---------------------------------------------------------
-
-        try {
-            // Options parent
-            ObjectStateUtils.writeObject(out, parent, logCorrelationIDString + ".parent");
-        }
-        catch (Exception e5) {
-            // note that the utility class will provide the trace for the
-            // exception so we won't have to
-            // so just consume the exception for now
-        }
-
+        out.writeUTF("parent");
+        out.writeObject(parent);
     }
 
 
@@ -1212,7 +1153,8 @@
      * @throws IOException
      * @throws ClassNotFoundException
      */
-    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+    public void readExternal(ObjectInput inObject) throws IOException, ClassNotFoundException {
+        SafeObjectInputStream in = SafeObjectInputStream.install(inObject);
         // serialization version ID
         long suid = in.readLong();
 
@@ -1221,12 +1163,12 @@
 
         // make sure the object data is in a version we can handle
         if (suid != serialVersionUID) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_SUID);
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_SUID);
         }
 
         // make sure the object data is in a revision level we can handle
-        if (revID != REVISION_1) {
-            throw new ClassNotFoundException(ObjectStateUtils.UNSUPPORTED_REVID);
+        if (revID != REVISION_2) {
+            throw new ClassNotFoundException(ExternalizeConstants.UNSUPPORTED_REVID);
         }
 
         //---------------------------------------------------------
@@ -1236,120 +1178,89 @@
 
         manageSession = in.readBoolean();
 
-        // the following objects could be null
-        Object tmp1 = ObjectStateUtils.readObject(in, "Options.isExceptionToBeThrownOnSOAPFault");
-        if (tmp1 != null) {
-            isExceptionToBeThrownOnSOAPFault = (Boolean) tmp1;
-        }
+        isExceptionToBeThrownOnSOAPFault = (Boolean) in.readObject();
+        useSeparateListener = (Boolean) in.readObject();
 
-        Object tmp2 = ObjectStateUtils.readObject(in, "Options.useSeparateListener");
-        if (tmp2 != null) {
-            useSeparateListener = (Boolean) tmp2;
-        }
-
         //---------------------------------------------------------
         // various strings
         //---------------------------------------------------------
 
         // String soapVersionURI
-        soapVersionURI = ObjectStateUtils.readString(in, "Options.soapVersionURI");
+        soapVersionURI = (String) in.readObject();
 
         // String action
-        action = ObjectStateUtils.readString(in, "Options.action");
+        action = (String) in.readObject();
 
         // String transportInProtocol
-        transportInProtocol = ObjectStateUtils.readString(in, "Options.transportInProtocol");
+        transportInProtocol = (String) in.readObject();
 
         // String messageId
-        messageId = ObjectStateUtils.readString(in, "Options.messageId");
+        messageId = (String) in.readObject();
 
         // String object id
-        logCorrelationIDString = ObjectStateUtils.readString(in, "Options.logCorrelationIDString");
+        logCorrelationIDString = (String) in.readObject();
 
         // trace point
-        log.trace(myClassName + ":readExternal():  reading the input stream for  [" +
-                logCorrelationIDString + "]");
+        if (log.isTraceEnabled()) {
+            log.trace(myClassName + ":readExternal():  reading the input stream for  [" +
+                      logCorrelationIDString + "]");
+        }
 
         //---------------------------------------------------------
         // various objects
         //---------------------------------------------------------
 
         // EndpointReference faultTo
-        faultTo = (EndpointReference) ObjectStateUtils.readObject(in, "Options.faultTo");
+        faultTo = (EndpointReference) in.readObject();
 
         // EndpointReference from
-        from = (EndpointReference) ObjectStateUtils.readObject(in, "Options.from");
+        from = (EndpointReference) in.readObject();
 
         // EndpointReference replyTo
-        replyTo = (EndpointReference) ObjectStateUtils.readObject(in, "Options.replyTo");
+        replyTo = (EndpointReference) in.readObject();
 
         // EndpointReference to
-        to = (EndpointReference) ObjectStateUtils.readObject(in, "Options.to");
+        to = (EndpointReference) in.readObject();
 
         // TransportListener listener
         // is not usable until the meta data has been reconciled
         listener = null;
-        metaListener = (MetaDataEntry) ObjectStateUtils.readObject(in, "Options.metaListener");
+        metaListener = (MetaDataEntry) in.readObject();
 
         // TransportInDescription transportIn
         // is not usable until the meta data has been reconciled
         transportIn = null;
-        metaTransportIn =
-                (MetaDataEntry) ObjectStateUtils.readObject(in, "Options.metaTransportIn");
+        metaTransportIn = (MetaDataEntry) in.readObject();
 
         // TransportOutDescription transportOut
         // is not usable until the meta data has been reconciled
         transportOut = null;
-        metaTransportOut =
-                (MetaDataEntry) ObjectStateUtils.readObject(in, "Options.metaTransportOut");
+        metaTransportOut = (MetaDataEntry) in.readObject();
 
         //---------------------------------------------------------
         // collections and lists
         //---------------------------------------------------------
 
         // List relationships, which is an array of RelatesTo objects
-        ArrayList tmpAL1 = ObjectStateUtils.readArrayList(in, "Options.relationships");
-        if (tmpAL1 != null) {
-            relationships = new ArrayList(tmpAL1);
-        } else {
-            relationships = null;
-        }
+        relationships = in.readArrayList();
 
         // ArrayList referenceParameters
-        ArrayList tmpAL2 = ObjectStateUtils.readArrayList(in, "Options.referenceParameters");
-        if (tmpAL2 != null) {
-            referenceParameters = new ArrayList(tmpAL2);
-        } else {
-            referenceParameters = null;
-        }
+        referenceParameters = in.readArrayList();
 
         //---------------------------------------------------------
         // properties
         //---------------------------------------------------------
 
         // HashMap properties
-        HashMap tmpHM = ObjectStateUtils.readHashMap(in, "Options.properties");
+        properties = in.readHashMap();
 
-        if (tmpHM != null) {
-            properties = new HashMap(tmpHM);
-        } else {
-            properties = new HashMap();
-        }
-
         //---------------------------------------------------------
         // "nested"
         //---------------------------------------------------------
 
         // Options parent
-        Object tmpParent = ObjectStateUtils.readObject(in, "Options.parent");
-
-        if (tmpParent != null) {
-            parent = (Options) tmpParent;
-        } else {
-            parent = null;
-        }
-
-
+        in.readUTF(); // read marker
+        parent = (Options) in.readObject();
     }
 
     /**
Index: C:/workspace/live/os_axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/util/MessageUtils.java
===================================================================
--- C:/workspace/live/os_axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/util/MessageUtils.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/util/MessageUtils.java	(working copy)
@@ -34,7 +34,9 @@
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.Constants.Configuration;
+import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.OperationContext;
 import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.handler.AttachmentsAdapter;
 import org.apache.axis2.jaxws.handler.TransportHeadersAdapter;
@@ -51,13 +53,17 @@
 import javax.activation.DataHandler;
 import javax.xml.namespace.QName;
 import javax.xml.soap.AttachmentPart;
-import javax.xml.soap.MimeHeader;
-import javax.xml.soap.MimeHeaders;
 import javax.xml.soap.SOAPMessage;
 import javax.xml.ws.WebServiceException;
 
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 
@@ -313,4 +319,76 @@
             }
         } 
     }
+    
+    /**
+     * This is for debug purposes only
+     * @param mc
+     */
+    private static void persistMessageContext(MessageContext mc) {
+        try {
+            ConfigurationContext cc = mc.getConfigurationContext();
+            OperationContext op = mc.getOperationContext();
+            if (cc == null && op != null) {
+                cc = op.getConfigurationContext();
+            }
+            
+            File theFile = null;
+            theFile = File.createTempFile("DebugPersist", null);
+            
+            // Setup an output stream to a physical file
+            FileOutputStream outStream = new FileOutputStream(theFile);
+
+            // Attach a stream capable of writing objects to the 
+            // stream connected to the file
+            ObjectOutputStream outObjStream = new ObjectOutputStream(outStream);
+
+            // Try to save the message context
+            outObjStream.writeObject(mc);
+            outObjStream.flush();
+            outObjStream.close();
+            outStream.flush();
+            outStream.close();
+            
+            // Now read in the persisted message
+            // Setup an input stream to the file
+            FileInputStream inStream = new FileInputStream(theFile);
+            
+            // attach a stream capable of reading objects from the 
+            // stream connected to the file
+            ObjectInputStream inObjStream = new ObjectInputStream(inStream);
+
+            org.apache.axis2.context.MessageContext restoredMC = 
+                (org.apache.axis2.context.MessageContext) inObjStream.readObject();
+            inObjStream.close();
+            inStream.close();
+            if (cc == null && op == null) {
+                return;
+            }
+            
+            if (cc != null) {
+                restoredMC.activate(cc);
+            } else {
+                restoredMC.activateWithOperationContext(op);
+            }
+            if (restoredMC.getServiceContext() == null) {
+                throw ExceptionFactory.makeWebServiceException("No Service Group!");
+            }
+            if (cc != null) {
+                mc.activate(cc);
+            } else {
+                mc.activateWithOperationContext(op);
+            }
+            if (mc.getOperationContext() == null) {
+                throw new RuntimeException("No Operation Context");
+            }
+            if (mc.getOperationContext().getServiceContext() == null) {
+                throw new RuntimeException("No Service Context");
+            }
+            return;
+        } catch (FileNotFoundException e) {
+        } catch (IOException e) {
+        } catch (ClassNotFoundException e) {
+        }
+        return;
+    }
 }
Index: C:/workspace/live/os_axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/PropertyMigrator.java
===================================================================
--- C:/workspace/live/os_axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/PropertyMigrator.java	(revision 576971)
+++ C:/workspace/live/os_axis2/modules/jaxws/src/org/apache/axis2/jaxws/client/PropertyMigrator.java	(working copy)
@@ -25,14 +25,15 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
+import java.io.Serializable;
 import java.util.Map;
 
 /**
  * The PropertyMigrator implements the ApplicationContextMigrator in order to perform the necessary
  * manipulations of properties during a request or response flow.
  */
-public class PropertyMigrator implements ApplicationContextMigrator {
-	private static final Log log = LogFactory.getLog(PropertyMigrator.class);
+public class PropertyMigrator implements ApplicationContextMigrator, Serializable {
+    private static final Log log = LogFactory.getLog(PropertyMigrator.class);
     public void migratePropertiesFromMessageContext(Map<String, Object> userContext,
                                                     MessageContext messageContext) {
 
