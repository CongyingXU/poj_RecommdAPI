Index: userguide3.html
===================================================================
--- userguide3.html	(revision 371896)
+++ userguide3.html	(working copy)
@@ -14,11 +14,9 @@
 <i>User Feedback: <a
 href="mailto:axis-user@ws.apache.org">axis-user@ws.apache.org</a></i>
 
-<p align="right">Pages: <a href="userguide.html"
->Content</a>, <a href="userguide1.html">1</a>,
-<a href="userguide2.html">2</a>, <b>3</b>, <a
-href="userguide4.html">4</a>, <a href="userguide5.html"
->5</a></p>
+<p align="right">Pages: <a href="userguide.html">Content</a>, <a
+href="userguide1.html">1</a>, <a href="userguide2.html">2</a>, <b>3</b>, <a
+href="userguide4.html">4</a>, <a href="userguide5.html">5</a></p>
 
 <p><b><font size="4">Note (on samples):</font></b> In this page of the user's
 guide we will look at how to write Web Service Clients using Axis2. All the
@@ -26,7 +24,8 @@
 color="#000000">"samples/userguide/src"</font></b> directory of the binary
 distribution. So... let's explore the samples.</p>
 
-<h2><a name="Web_Service_Clients_Using_Axis2">Web Service Clients Using Axis2</a></h2>
+<h2><a name="Web_Service_Clients_Using_Axis2">Web Service Clients Using
+Axis2</a></h2>
 
 <p>Now let's see how we can write a Web Service Client to use this Web
 Service.</p>
@@ -138,10 +137,12 @@
 <p>Below we describe how to write Web Services Clients using Axis2. This can
 be done in two methods:</p>
 <ol>
-  <li><a href="#Writing_Web_Service_Clients_using_Axis2's_Primary_APIs">Using the Axis2's primary APIs</a></li>
-  <li><p><a href="#Writing_Web_Service_Clients_using_Code_Generation_with_Data_Binding_Support">Using stubs generated with data binding
-    support</a>, making the life easy for developers writing Web Service
-    client applications</p>
+  <li><a href="#Writing_Web_Service_Clients_using_Axis2's_Primary_APIs">Using
+    the Axis2's primary APIs</a></li>
+  <li><p><a
+    href="#Writing_Web_Service_Clients_using_Code_Generation_with_Data_Binding_Support">Using
+    stubs generated with data binding support</a>, making the life easy for
+    developers writing Web Service client applications</p>
   </li>
 </ol>
 
@@ -155,18 +156,20 @@
 channel invocations. Let's first see how we can write a client to invoke
 "echo" operation of "MyService" using the simplest blocking invocation. The
 client code you need to write is as follows.</p>
+<source>
 <pre>  try {
             OMElement payload = ClientUtil.getEchoOMElement();
-<font color="#33cc00">            Options options = new Options();
+            <span style="color: #24C113">            
+            Options options = new Options();
             options.setTo(targetEPR);
             options.setListenerTransportProtocol(Constants.TRANSPORT_HTTP);
             options.setUseSeparateListener(false);
 
             ServiceClient serviceClient = new ServiceClient();
-            serviceClient.setOptions(options);</font>
+            serviceClient.setOptions(options);
 
-<font color="#33cc00">            OMElement result = sender.sendReceive(payload);</font>
-
+            OMElement result = sender.sendReceive(payload);
+            </span>
             StringWriter writer = new StringWriter();
             result.serializeWithCache(new OMOutput(XMLOutputFactory.newInstance().createXMLStreamWriter(writer)));
             writer.flush();
@@ -179,6 +182,7 @@
             e.printStackTrace();
         }
 }</pre>
+</source>
 
 <p>The green lines shows the set of operations that you need to perform
 inorder to invoke a web service. The rest is used to create the OMElement
@@ -191,9 +195,9 @@
 <h4><a name="PingClient">PingClient</a></h4>
 
 <p>In the Web Service "MyService" we had a IN-ONLY operation with the name
-"ping" (see <a href="userguide2.html#Web_Services_Using_Axis2" tareget="_blank">Web Services Using
-Axis2</a>). Let's write a client to invoke this operation. The client code is
-as follows:</p>
+"ping" (see <a href="userguide2.html#Web_Services_Using_Axis2">Web Services
+Using Axis2</a>). Let's write a client to invoke this operation. The client
+code is as follows:</p>
 <pre> try {
        OMElement payload = ClientUtil.getPingOMElement();
        Options options = new Options();
@@ -321,7 +325,7 @@
             while (!callback.isComplete()) {
                 Thread.sleep(1000);
             }
-          <font color="#33cc00">serviceClinet.finalizeInvoke();</font>
+            serviceClinet.finalizeInvoke();
 
         } catch (AxisFault axisFault) {
             axisFault.printStackTrace();
@@ -496,10 +500,12 @@
     e.printStackTrace();
 }</pre>
 
-<p align="right"><a href="userguide2.html"><img
-src="images/arrow_left.gif"> Previous</a> | <a href="userguide4.html">Next <img src="images/arrow_right.gif"></a></p>
+<p align="right"><a href="userguide2.html"><img src="images/arrow_left.gif">
+Previous</a> | <a href="userguide4.html">Next <img
+src="images/arrow_right.gif"></a></p>
 
 <p>Pages: <a href="userguide.html">Content</a>, <a
-href="userguide1.html">1</a>, <a href="userguide2.html">2</a>, <b>3</b>, <a href="userguide4.html">4</a>, <a href="userguide5.html">5</a></p>
+href="userguide1.html">1</a>, <a href="userguide2.html">2</a>, <b>3</b>, <a
+href="userguide4.html">4</a>, <a href="userguide5.html">5</a></p>
 </body>
 </html>
Index: CodegenTools-EclipsePlugin.html
===================================================================
--- CodegenTools-EclipsePlugin.html	(revision 371896)
+++ CodegenTools-EclipsePlugin.html	(working copy)
@@ -41,9 +41,9 @@
 or copy the necessary folders to the eclipse plug-in directory and restart
 Eclipse.</p>
 
-<p><i>Note - This plug-in works on Eclipse version 3.1 and upwards. The
-provided screen shots may slightly differ with what the user would actually
-see but the fuctuonality has not been changed.</i></p>
+<p><strong>Note</strong> - This plug-in works on Eclipse version 3.1 and
+upwards. The provided screen shots may slightly differ with what the user
+would actually see but the fuctuonality has not been changed.</p>
 
 <h2>Operation</h2>
 
@@ -57,7 +57,7 @@
 generator wizard. Following is the first wizard page.</p>
 
 <p><img alt="" src="images/tools/wsdl/toolSelectionpage.jpg" width="557"
-height="501"/></p>
+height="501" /></p>
 
 <p>Selecting the generate code from WSDL option leads to the next page. Note
 that the Java-to-WSDL tool is disabled.</p>
@@ -75,9 +75,9 @@
 these options since the most common options are defaulted, But advanced users
 will find it very easy to "turn the knobs" using these options.</p>
 
-<p><em>Note - The databinding option "xmlbeans" would not work for Eclipse
-version 3.0. This has been a known problem and users are recommended to use
-Eclipse version 3.1 or upwards</em></p>
+<p><strong>Note</strong> - The databinding option "xmlbeans" would not work
+for Eclipse version 3.0. This has been a known problem and users are
+recommended to use Eclipse version 3.1 or upwards</p>
 
 <p><img src="images/tools/wsdl/OptionsPage.jpg" width="518" height="500"
 alt="" /></p>
Index: mail-configuration.html
===================================================================
--- mail-configuration.html	(revision 371896)
+++ mail-configuration.html	(working copy)
@@ -1,110 +1,110 @@
-<!-- saved from url=(0022)http://internet.e-mail -->
-<html>
-<head>
-<title>Mail transport</title>
-
-</head>
-
-<body><h1>Mail transport</h1>
-<p>The inner workings of the mail transport has two parts, the transport sender and the transport listener. The transport listener is a basic email client which will be on a loop checking for new messages for a particular email address. When an email comes in it will be tunneled into the Axis engine.</p>
-<p>Mail transport can be used against a generic mail server or it can be used like a mailet. The simple mailet provided with Axis2 will direct any message that is coming to a particular address into the Axis engine. The engine will process the message and will use the Transport sender to send the reply.</p>
-<p></p>
-<p>To get started on the mail transport you need the following additional jar dependencies on the classpath.</p>
-  <ol>
-  <li>javamail</li>
-  <li>activation</li>
-  </ol>
-<p>We use the Geronimo version of these jars to compile but you will need the sun version to run the code. Specificaly we are using geronimo-spec-javamail-[version].jar and geronimo-spec-activation-[version].jar. These will be downloaded by maven when you run the maven build.</p>
-
-<h2>Transport Sender</h2>
-<p>You need to have a mail account to activate the mail functionality. This can either be a generic mail server or you can start up a james mail server. The Mail transport sender can be activated by adding following entry to the axis2.xml file.</p>
-  <source>
-  <pre>
-   &lt;transportSender name="mail" class="org.apache.axis2.transport.mail.MailTransportSender"&gt;
-        &lt;parameter name="transport.mail.smtp.host" locked="xsd:false"&gt;smtp server host&lt;/parameter&gt;
-        &lt;parameter name="transport.mail.smtp.user" locked="xsd:false"&gt;user name&lt;/parameter&gt;
-        &lt;parameter name="transport.mail.smtp.password" locked="xsd:false"&gt;password&lt;/parameter&gt;
-        &lt;parameter name="transport.mail.smtp.port" locked="xsd:false"&gt;Port on the server for pop&lt;/parameter&gt;
-   &lt;/transportSender&gt;
-  </pre>
-  </source>
-
-  <h2>Transport Receiver</h2>
-
-  <p>The mail Listener can be activated by adding the following entry to the axis2.xml file.</p>
-
-  <source><pre>
-   &lt;transportReceiver name="mail" class="org.apache.axis2.transport.mail.SimpleMailListener"&gt;
-        &lt;parameter name="transport.mail.pop3.host" locked="xsd:false"&gt;pop server host&lt;/parameter&gt;
-        &lt;parameter name="transport.mail.pop3.user" locked="xsd:false"&gt;user name&lt;/parameter&gt;
-        &lt;parameter name="transport.mail.pop3.password" locked="xsd:false"&gt;password&lt;/parameter&gt;
-        &lt;parameter name="transport.mail.pop3.port" locked="xsd:false"&gt;Port on the server for smtp&lt;/parameter&gt;
-        &lt;parameter name="transport.mail.replyToAddress" locked="xsd:false"&gt;email address&lt;/parameter&gt;
-  &lt;/transportReceiver&gt;
-  </pre></source>
-
-  <p>At the Client side if the Mail Listener is needed it is automatically started by Axis2.</p>
-
-  <h2>Using Mail transport in the Server Side</h2>
-  <p> If the Mail Listener is need to be started as the server it can be done with following command with the all the axis2 jars and the mail dependency jars in the classpath.</p>
-  <source><pre>java org.apache.axis2.transport.mail.SimpleMailListener repository-directory</pre></source>
-
-  <h2>Using Mail transport in the Client Side</h2>
-  <p>Following code segment shows how to send a oneway SOAP message using the mail transport, this need the Transport Sender configured.</p>
-<source>
-<pre>
-OMElement payload = ....
-
-MessageSender sender = new MessageSender(serviceContext);
-sender.setTo(targetEPR);
-sender.setSenderTransport(Constants.TRANSPORT_MAIL);
-
-sender.send(operationName.getLocalPart(), payload);
-</pre>
-</source>
-  
-  <h2>Configure James as SMTP and POP server</h2>
-  <p>Download the <a href="http://james.apache.org/">Apache James</a> and start James, connect to the James via telnet for administrator James with the following code
-</p>
-
-<source>
-<pre>
-$telnet 127.0.0.1 4555
-Trying 127.0.0.1...
-Connected to localhost.localdomain (127.0.0.1).
-Escape character is '^]'.
-JAMES Remote Administration Tool 2.2.0
-Please enter your login and password
-Login id:
-root
-Password:
-root
-Welcome root. HELP for a list of commands
-</pre>
-</source>
-
-<p>Add users to James</p>
-<source>
-<pre>
-adduser axis2-server axis2
-User axis2-server added
-adduser axis2-client axis2
-User axis2-client added
-Connection closed by foreign host.
-</pre>
-</source>
-
-  <p>Now James is up and running with the accounts</p>
-
-  <h2>Using the included mail server</h2>
-
-  <p>The inbuilt mail server can be started from the command line using the following piece of code when all the needed jars are in the class path.</p>
-<p><code>java org.apache.axis2.transport.mail.server.MailServer</code></p>
-  <p>The server itself does not need any configuration or tinkering to work. A ConfigurationContext and the ports to operate on are the only details needed. The server will store the mails in memory against the recipient till the recipient pops it from the server. To facilitate the use in *nix environments as a non root user the pop and smtp ports used by default config/test cases are (1024 + 25) and (1024 + 110).</p>
-
-  <hr/>
-
-  <p>&nbsp;</p>
-
-</body>
-</html>
+<!-- saved from url=(0022)http://internet.e-mail -->
+<html>
+<head>
+<title>Mail transport</title>
+
+</head>
+
+<body><h1>Mail transport</h1>
+<p>The inner workings of the mail transport has two parts, the transport sender and the transport listener. The transport listener is a basic email client which will be on a loop checking for new messages for a particular email address. When an email comes in it will be tunneled into the Axis engine.</p>
+<p>Mail transport can be used against a generic mail server or it can be used like a mailet. The simple mailet provided with Axis2 will direct any message that is coming to a particular address into the Axis engine. The engine will process the message and will use the Transport sender to send the reply.</p>
+<p></p>
+<p>To get started on the mail transport you need the following additional jar dependencies on the classpath.</p>
+  <ol>
+  <li>javamail</li>
+  <li>activation</li>
+  </ol>
+<p>We use the Geronimo version of these jars to compile but you will need the sun version to run the code. Specificaly we are using geronimo-spec-javamail-[version].jar and geronimo-spec-activation-[version].jar. These will be downloaded by maven when you run the maven build.</p>
+
+<h2>Transport Sender</h2>
+<p>You need to have a mail account to activate the mail functionality. This can either be a generic mail server or you can start up a james mail server. The Mail transport sender can be activated by adding following entry to the axis2.xml file.</p>
+  <source>
+  <pre>
+   &lt;transportSender name="mail" class="org.apache.axis2.transport.mail.MailTransportSender"&gt;
+        &lt;parameter name="transport.mail.smtp.host" locked="xsd:false"&gt;smtp server host&lt;/parameter&gt;
+        &lt;parameter name="transport.mail.smtp.user" locked="xsd:false"&gt;user name&lt;/parameter&gt;
+        &lt;parameter name="transport.mail.smtp.password" locked="xsd:false"&gt;password&lt;/parameter&gt;
+        &lt;parameter name="transport.mail.smtp.port" locked="xsd:false"&gt;Port on the server for pop&lt;/parameter&gt;
+   &lt;/transportSender&gt;
+  </pre>
+  </source>
+
+  <h2>Transport Receiver</h2>
+
+  <p>The mail Listener can be activated by adding the following entry to the axis2.xml file.</p>
+
+  <source><pre>
+   &lt;transportReceiver name="mail" class="org.apache.axis2.transport.mail.SimpleMailListener"&gt;
+        &lt;parameter name="transport.mail.pop3.host" locked="xsd:false"&gt;pop server host&lt;/parameter&gt;
+        &lt;parameter name="transport.mail.pop3.user" locked="xsd:false"&gt;user name&lt;/parameter&gt;
+        &lt;parameter name="transport.mail.pop3.password" locked="xsd:false"&gt;password&lt;/parameter&gt;
+        &lt;parameter name="transport.mail.pop3.port" locked="xsd:false"&gt;Port on the server for smtp&lt;/parameter&gt;
+        &lt;parameter name="transport.mail.replyToAddress" locked="xsd:false"&gt;email address&lt;/parameter&gt;
+  &lt;/transportReceiver&gt;
+  </pre></source>
+
+  <p>At the Client side if the Mail Listener is needed it is automatically started by Axis2.</p>
+
+  <h2>Using Mail transport in the Server Side</h2>
+  <p> If the Mail Listener is need to be started as the server it can be done with following command with the all the axis2 jars and the mail dependency jars in the classpath.</p>
+  <source><pre>java org.apache.axis2.transport.mail.SimpleMailListener repository-directory</pre></source>
+
+  <h2>Using Mail transport in the Client Side</h2>
+  <p>Following code segment shows how to send a oneway SOAP message using the mail transport, this need the Transport Sender configured.</p>
+<source>
+<pre>
+OMElement payload = ....
+
+MessageSender sender = new MessageSender(serviceContext);
+sender.setTo(targetEPR);
+sender.setSenderTransport(Constants.TRANSPORT_MAIL);
+
+sender.send(operationName.getLocalPart(), payload);
+</pre>
+</source>
+  
+  <h2>Configure James as SMTP and POP server</h2>
+  <p>Download the <a href="http://james.apache.org/">Apache James</a> and start James, connect to the James via telnet for administrator James with the following code
+</p>
+
+<source>
+<pre>
+$telnet 127.0.0.1 4555
+Trying 127.0.0.1...
+Connected to localhost.localdomain (127.0.0.1).
+Escape character is '^]'.
+JAMES Remote Administration Tool 2.2.0
+Please enter your login and password
+Login id:
+root
+Password:
+root
+Welcome root. HELP for a list of commands
+</pre>
+</source>
+
+<p>Add users to James</p>
+<source>
+<pre>
+adduser axis2-server axis2
+User axis2-server added
+adduser axis2-client axis2
+User axis2-client added
+Connection closed by foreign host.
+</pre>
+</source>
+
+  <p>Now James is up and running with the accounts</p>
+
+  <h2>Using the included mail server</h2>
+
+  <p>The inbuilt mail server can be started from the command line using the following piece of code when all the needed jars are in the class path.</p>
+<source><pre>java org.apache.axis2.transport.mail.server.MailServer</pre></source>
+  <p>The server itself does not need any configuration or tinkering to work. A ConfigurationContext and the ports to operate on are the only details needed. The server will store the mails in memory against the recipient till the recipient pops it from the server. To facilitate the use in *nix environments as a non root user the pop and smtp ports used by default config/test cases are (1024 + 25) and (1024 + 110).</p>
+
+  <hr/>
+
+  <p>&nbsp;</p>
+
+</body>
+</html>
Index: Axis2ArchitectureGuide.html
===================================================================
--- Axis2ArchitectureGuide.html	(revision 371896)
+++ Axis2ArchitectureGuide.html	(working copy)
@@ -74,6 +74,7 @@
     </ul>
   </li>
 </ul>
+
 <h2><a name="bmBP">The Big Picture</a></h2>
 
 <p>Any architecture is a result of what that architecture should yield. The
@@ -127,6 +128,7 @@
 speed is a major consideration for Axis2. Axis2 Core Architecture is built on
 three specifications- WSDL, SOAP and WS-Addressing. Other specifications like
 JAX-RP, SAAJ &amp; WS-Policy are layered on top of the Core Architecture.</p>
+
 <h2><a name="thearchi">Axis2, The Architecture</a></h2>
 Axis2 architecture lays out some principals to preserve the uniformity. They
 are as follows:
@@ -201,6 +203,7 @@
 
 <p><img src="images/archi-guide/all.png" name="Graphic2" width="426" alt=""
 height="189" border="0" align="bottom" usemap="#Graphic2Map"></p>
+
 <h2><a name="bmInfoMod">Information Model</a></h2>
 
 <p>Information Model has two main hierarchies-Contexts and Descriptions. This
@@ -306,6 +309,7 @@
 <h2>XML Processing Model</h2>
 
 <p>Please refer to the <a href="OMTutorial.html">OM Tutorial</a></p>
+
 <h2><a name="bmSOAPPM">SOAP Processing Model</a></h2>
 
 <p><img src="images/archi-guide/soap-processing.gif" name="Graphic4" alt=""
@@ -356,6 +360,7 @@
 
 <p><img src="images/archi-guide/phases.png" name="Graphic5" align="bottom"
 alt="" width="525" height="226" border="0"></p>
+
 <h3><a name="default">Axis2 Default Processing Model</a></h3>
 
 <p>Axis2 has some inbuilt handlers that run in inbuilt phases and they create
@@ -368,14 +373,15 @@
     the Dispatch phase. The in-built dispatchers dispatch to a particular
     operation depending on various conditions like WS-Addressing information,
     URI information, SOAP action information, etc.,</li>
-  <ul>
-    <li><a name="mr">Message Receiver - Consume the SOAP Message and run on
-      the Message Processing phase in the inflow</a></li>
-    <li><p>Transport Sender - Send the SOAP message to the SOAP endpoint the
-      message is destined to. Always runs on the</p>
-    </li>
-  </ul>
 </ol>
+<ul>
+  <li><a name="mr">Message Receiver - Consume the SOAP Message and run on the
+    Message Processing phase in the inflow</a></li>
+  <li><p>Transport Sender - Send the SOAP message to the SOAP endpoint the
+    message is destined to. Always runs on the</p>
+  </li>
+</ul>
+
 <h3><a name="incomingsoap">Processing an Incoming SOAP Message</a></h3>
 
 <p>Incoming SOAP Message is always received by a Transport Receiver waiting
@@ -405,15 +411,15 @@
   <li>Message Validation Phase - Once the user level execution has taken
     place this phase validates whether SOAP Message Processing has taken
     place correctly.</li>
-  <li><p>Message Processing Phase - The Business logic of the SOAP message is
+  <li>Message Processing Phase - The Business logic of the SOAP message is
     executed here. A <a href="#mr">Message Receiver</a> is registered with
     each Operation. This Message receiver (associated to the particular
-    operation) will executed as the last Handler of this phase.</p>
-  </li>
+    operation) will executed as the last Handler of this phase.</li>
 </ol>
 
 <p>There may be other handlers in any of these phases. Users may use custom
 handlers to override the mechanics in each of these phases.</p>
+
 <h3><a name="outgoing">Processing of the Outgoing Message</a></h3>
 
 <p><em>Out Pipe</em> is simpler because the service and operation to dispatch
@@ -425,11 +431,11 @@
   <li>Message Initialize Phase - Fist phase of the <em>Out Pipe</em>. Serves
     as the placeholder for the custom handlers</li>
   <li>User Phases - This executes handlers in user defined phases</li>
-  <li><p>Transports Phase - Execute any transport handlers taken from the
+  <li>Transports Phase - Execute any transport handlers taken from the
     associated transport configuration. The last handler would be a transport
-    Sender which would send the SOAP message to the target end point.</p>
-  </li>
+    Sender which would send the SOAP message to the target end point.</li>
 </ol>
+
 <h3><a name="extending">Extending SOAP Processing Model</a></h3>
 
 <p>Above we discussed the default processing model of Axis2. Now lets discuss
@@ -454,6 +460,7 @@
   <li>or before a given handler</li>
   <li>or after a given handler</li>
 </ol>
+
 <h4><a name="extendingwithmodules">Extending the SOAP Processing Model with
 Modules</a></h4>
 
@@ -489,6 +496,7 @@
 
 <p>The Deployment Model provides a concrete mechanism to configure Axis2.
 This model has three entities that provide the configuration.</p>
+
 <h3><a name="xmlfile">The <em>axis2.xml</em> file</a></h3>
 
 <p>This file holds the global configuration for the client and server, and
@@ -498,8 +506,7 @@
   <li>Registered transports in and transport outs</li>
   <li>User defined phase names</li>
   <li>Modules that are engaged globally (to all services)</li>
-  <li><p>Globally defined <a href="#mr">Message Receivers</a></p>
-  </li>
+  <li>Globally defined <a href="#mr">Message Receivers</a></li>
 </ol>
 <a name="servicearchive"></a>
 
@@ -511,24 +518,23 @@
 <ol>
   <li>Service level parameters</li>
   <li>Modules that are engaged Service level</li>
-  <li><p>Service Specific <a href="#mr">Message Receivers</a></p>
-  </li>
-  <li><p>Operations inside the Service</p>
-  </li>
+  <li>Service Specific <a href="#mr">Message Receivers</a></li>
+  <li>Operations inside the Service</li>
 </ol>
+
 <h3><a name="modulearchive">Module Archive</a></h3>
 
-<p>Module archive must have a <em>META-INF/module.xml</em> file and dependent
-classes. The <em>module.xml</em> file has Module parameters and the
-Operations defined in the module.</p>
+<p>Module archive must have a META-INF/module.xml file and dependent classes.
+The <em>module.xml</em> file has Module parameters and the Operations defined
+in the module.</p>
 
 <p>When the system is starting up Axis2 ask the deployment model to create a
-Axis Configuration. Deployment Model first finds the <em>axis2.xml</em> file
-and build the global configuration. Then it checks for the module archives
-and then for the service archives. After which the corresponding services and
-modules are added to the Axis Configuration. System will build Contexts on
-top of the Axis Configurations and then Axis2 is ready to send or receive the
-SOAP Message. Hot deployment is only allowed for the service, in which case a
+Axis Configuration. Deployment Model first finds the axis2.xml file and build
+the global configuration. Then it checks for the module archives and then for
+the service archives. After which the corresponding services and modules are
+added to the Axis Configuration. System will build Contexts on top of the
+Axis Configurations and then Axis2 is ready to send or receive the SOAP
+Message. Hot deployment is only allowed for the service, in which case a
 thread will check the repository repeatedly, and then add the service
 corresponding to the new found service archives to the repository.</p>
 <a name="bmClientAPI"></a>
@@ -552,6 +558,7 @@
 the Client API. The implementation is based on a class called
 <code>ServiceClient</code> and there are extensions for each MEP that Axis2
 Client API supports.</p>
+
 <h3><a name="oneway">One Way Messaging Support</a></h3>
 
 <p>The One-Way support is provided by the <code>fireAndForget</code> which
@@ -572,14 +579,15 @@
     methods</li>
   <li>Sender transport - transport used to send the SOAP Message</li>
   <li>Listener transport - transport the Response is received</li>
-  <li><p>Use Separate Channel - determines whether the response is send over
+  <li>Use Separate Channel - determines whether the response is send over
     a separate transport connection or not. This can be false only when
-    sender and listener transport is same and is a Two-Way transport.</p>
+    sender and listener transport is same and is a Two-Way transport.
   </li>
 </ol>
 
 <p>Depending on the values of the above four parameter, Axis2 behave
 differently.</p>
+
 <h2><a name="bmTransports">Transports</a></h2>
 
 <p>Axis2 has two basic constructs for transports, transport In Configuration
@@ -601,7 +609,7 @@
   <li>Transport Sender for Out Configuration</li>
   <li>Transport Listener for In Configuration</li>
   <li>Parameters of the transport</li>
-  <li><p>Transport handlers</p>
+  <li>Transport handlers
   </li>
 </ol>
 
@@ -645,6 +653,7 @@
 to the emitter which emits an XML. The XML is then parsed with the relevant
 XSL to generate the code. No matter what the language, the process is the
 same except for the template that is being used</p>
+
 <h2><a name="bmDB" id="bmDB">Data Binding</a></h2>
 <a name="integration"></a>
 
@@ -662,6 +671,7 @@
 
 <p><img src="images/codegen.gif" name="Graphic7" align="bottom" width="406"
 alt="" height="467" border="0"></p>
+
 <h3><a name="serial">Serialization and De-Serialization</a></h3>
 
 <p>AXIOM is based on a StAX (Streaming API for XML) API. Xml-beans supports
Index: http-transport.html
===================================================================
--- http-transport.html	(revision 371896)
+++ http-transport.html	(working copy)
@@ -1,137 +1,137 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
-<html>
-<head>
-  <meta http-equiv="content-type" content="">
-  <title>HTTP transports</title>
-</head>
-
-<body lang="en">
-<a name="configTransport"/>
-<h1>HTTP transports</h1>
-
-<h3>CommonsHTTPTransportSender</h3>
-
-<p>This is the default transport sender that is used in Server API as well as
-Client API. As the name implies it is based on commons-httpclient-3.0-rc3. In
-order to acquire the maximum flexibility, this sender has implemented POST
-interface and GET interface. GET interface is provided to help axis2 support
-REST.</p>
-
-<p>Chunking support and KeepAlive support is also integrated via the
-facilities provided by commons-httpclient along with HTTP 1.1 support.</p>
-
-<p>&lt;transportSender/&gt; element is used to define transport senders in
-the axis2.xml as follows:</p>
-<pre><code>&lt;transportSender name="http" class="org.apache.axis2.transport.http.CommonsHTTPTransportSender"&gt;<br/>        &lt;parameter name="PROTOCOL" locked="false"&gt;HTTP/1.1&lt;/parameter&gt;<br/>        &lt;parameter name="Transfer-Encoding"&gt;chunked&lt;/parameter&gt;<br/>&lt;/transportSender&gt;<br/></code></pre>
-
-<p>Above code snippet shows the complete configuration of the transport
-sender. &lt;parameter/&gt; element introduces the additional parameters that
-should be compliant with the sender. HTTP PROTOCOL version sets as HTTP/1.0
-or HTTP/1.1. Default version is HTTP/1.1. It should be noted that chunking
-support is available only for HTTP/1.1. Thus, the user should be careful in
-setting the "chunked" property and use it only with version 1.1. KeepAlive
-property is default in version 1.1.</p>
-
-<p>These are the only parameters that are available from deployment. Other
-parameters such as character encoding style (UTF-8, UTF-16 etc) etc, are
-provided via MessageContext.</p>
-
-<h4>HTTPS support</h4>
-It should be noted that CommonsHTTPTransportSender can be used to communicate
-over https. <code></code>
-<pre>&lt;transportSender name="<b>https</b>" class="org.apache.axis2.transport.http.CommonsHTTPTransportSender"&gt;<br/>        &lt;parameter name="PROTOCOL" locked="false"&gt;HTTP/1.1&lt;/parameter&gt;<br/>        &lt;parameter name="Transfer-Encoding"&gt;chunked&lt;/parameter&gt;<br/>&lt;/transportSender&gt;<br/></pre>
-Please note that https works only when the server does not expect to
-authenticate the clients and where the server has the clients' public keys in
-its trust store.
-
-<h2>Timeout Configuraiton</h2>
-
-<p>There are two timeout exists in transport level. They are called, Socket
-timeout and Connection timeout. This can be configured in deployment time or
-in run time. In deployment time, user has to add the following lines in
-axis2.xml.</p>
-
-<p>For Socket timeout:</p>
-<pre>&lt;parameter name="SO_TIMEOUT" locked="false"&gt;some_int_value&lt;/parameter&gt;</pre>
-
-<p>For Connection timeout:</p>
-<pre> &lt;parameter name="CONNECTION_TIMEOUT" locked="false"&gt;some_int_value&lt;/parameter&gt;</pre>
-<br/>
-In runtime it's set as follows in the Stub. <source>
-<pre>...
-Options options = new Options();
-options.setProperty(HTTPConstants.SO_TIMEOUT,new Integer(some_int_value));
-options.setProperty(HTTPConstants.CONNECTION_TIMEOUT,new Integer(some_int_value));
-...</pre>
-</source>
-<p></p>
-
-<h2>Proxy and NTLM Authentication</h2>
-
-<p>HttpClient support "Basic, Digest and NTLM" authentication schemes. These
-are used to authenticate with http servers and proxies.</p>
-
-<p>Axis2 uses deployment time and runtime mechanisms to authenticate proxies.
-In deployment time, user has to change the Axis2.xml as follows. This
-authentication will be available in http and https.</p>
-<pre>&lt;transportSender name="<b>http</b>" class="org.apache.axis2.transport.http.CommonsHTTPTransportSender"&gt;
-        &lt;parameter name="PROTOCOL" locked="false"&gt;HTTP/1.1&lt;/parameter&gt;
-        &lt;parameter name="PROXY" proxy_host="proxy_host_name" proxy_port="proxy_host_port" locked="true&gt;userName:domain:passWord&lt;/parameter&gt;
-&lt;/transportSender&gt;<br/></pre>
-
-<p>For a particular proxy, if authentication is not available fill
-"userName:domain:passWord"as "anonymous:anonymous:anonymous".</p>
-
-<p>At runtime user can override the PROXY settings with an Object of
-HttpTransportProperties.ProxyProperties. On the stub initiate an object of
-prior and set it to the MessageContext's property bag via
-HttpConstants.PROXY. On the stub, it depicts as follows,</p>
-<pre>...
-Options options = new Options();
-....
-
-HttpTransportProperties.ProxyProperties proxyProperties = new HttpTransportProperties.new ProxyProperties();
-proxyProperties.setProxyHostName(....);
-proxyProperties.setProxyPort(...);
-...
-options.setProperty(HttpConstants.PROXY, proxyProperties);
-....</pre>
-
-<p>The above code would eventually override the deployment proxy
-configuration settings.</p>
-
-<p>NTLM is the most complex of the authentication protocols supported by
-HttpClient. It requires an instance of NTCredentials be available for the
-domain name of the server or the default credentials. Note that since NTLM
-does not use the notion of realms HttpClient uses the domain name of the
-server as the name of the realm. Also note that the username provided to the
-NTCredentials should not be prefixed with the domain - ie: "axis2" is correct
-whereas "DOMAIN\axis2" is not correct.</p>
-
-<p>There are some significant differences in the way that NTLM works compared
-with basic and digest authentication. These differences are generally handled
-by HttpClient, however having an understanding of these differences can help
-avoid problems when using NTLM authentication.</p>
-<ol>
-  <li>NTLM authentication works almost exactly the same as any other form of
-    authentication in terms of the HttpClient API.  The only difference is
-    that you need to supply 'NTCredentials' instead of
-    'UsernamePasswordCredentials' (NTCredentials actually extends
-    UsernamePasswordCredentials so you can use NTCredentials right throughout
-    your application if need be).</li>
-  <li>The realm for NTLM authentication is the domain name of the computer
-    being connected to, this can be troublesome as servers often have
-    multiple domain names that refer to them.  Only the domain name that
-    HttpClient connects to (as specified by the HostConfiguration) is used to
-    look up the credentials. It is generally advised that while initially
-    testing NTLM authentication, you pass the realm in as null which is used
-    as the default.</li>
-  <li>NTLM authenticates a connection and not a request, so you need to
-    authenticate every time a new connection is made and keeping the
-    connection open during authentication is vital.  Due to this, NTLM cannot
-    be used to authenticate with both a proxy and the server, nor can NTLM be
-    used with HTTP 1.0 connections or servers that do not support HTTP
-    keep-alives.</li>
-</ol>
-</body>
-</html>
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+<head>
+  <meta http-equiv="content-type" content="">
+  <title>HTTP transports</title>
+</head>
+
+<body lang="en">
+<a name="configTransport"/>
+<h1>HTTP transports</h1>
+
+<h3>CommonsHTTPTransportSender</h3>
+
+<p>This is the default transport sender that is used in Server API as well as
+Client API. As the name implies it is based on commons-httpclient-3.0-rc3. In
+order to acquire the maximum flexibility, this sender has implemented POST
+interface and GET interface. GET interface is provided to help axis2 support
+REST.</p>
+
+<p>Chunking support and KeepAlive support is also integrated via the
+facilities provided by commons-httpclient along with HTTP 1.1 support.</p>
+
+<p>&lt;transportSender/&gt; element is used to define transport senders in
+the axis2.xml as follows:</p>
+<pre>&lt;transportSender name="http" class="org.apache.axis2.transport.http.CommonsHTTPTransportSender"&gt;<br/>        &lt;parameter name="PROTOCOL" locked="false"&gt;HTTP/1.1&lt;/parameter&gt;<br/>        &lt;parameter name="Transfer-Encoding"&gt;chunked&lt;/parameter&gt;<br/>&lt;/transportSender&gt;<br/></pre>
+
+<p>Above code snippet shows the complete configuration of the transport
+sender. &lt;parameter/&gt; element introduces the additional parameters that
+should be compliant with the sender. HTTP PROTOCOL version sets as HTTP/1.0
+or HTTP/1.1. Default version is HTTP/1.1. It should be noted that chunking
+support is available only for HTTP/1.1. Thus, the user should be careful in
+setting the "chunked" property and use it only with version 1.1. KeepAlive
+property is default in version 1.1.</p>
+
+<p>These are the only parameters that are available from deployment. Other
+parameters such as character encoding style (UTF-8, UTF-16 etc) etc, are
+provided via MessageContext.</p>
+
+<h4>HTTPS support</h4>
+It should be noted that CommonsHTTPTransportSender can be used to communicate
+over https. <code></code>
+<pre>&lt;transportSender name="<b>https</b>" class="org.apache.axis2.transport.http.CommonsHTTPTransportSender"&gt;<br/>        &lt;parameter name="PROTOCOL" locked="false"&gt;HTTP/1.1&lt;/parameter&gt;<br/>        &lt;parameter name="Transfer-Encoding"&gt;chunked&lt;/parameter&gt;<br/>&lt;/transportSender&gt;<br/></pre>
+Please note that https works only when the server does not expect to
+authenticate the clients and where the server has the clients' public keys in
+its trust store.
+
+<h2>Timeout Configuraiton</h2>
+
+<p>There are two timeout exists in transport level. They are called, Socket
+timeout and Connection timeout. This can be configured in deployment time or
+in run time. In deployment time, user has to add the following lines in
+axis2.xml.</p>
+
+<p>For Socket timeout:</p>
+<pre>&lt;parameter name="SO_TIMEOUT" locked="false"&gt;some_int_value&lt;/parameter&gt;</pre>
+
+<p>For Connection timeout:</p>
+<pre> &lt;parameter name="CONNECTION_TIMEOUT" locked="false"&gt;some_int_value&lt;/parameter&gt;</pre>
+<br/>
+In runtime it's set as follows in the Stub. <source>
+<pre>...
+Options options = new Options();
+options.setProperty(HTTPConstants.SO_TIMEOUT,new Integer(some_int_value));
+options.setProperty(HTTPConstants.CONNECTION_TIMEOUT,new Integer(some_int_value));
+...</pre>
+</source>
+<p></p>
+
+<h2>Proxy and NTLM Authentication</h2>
+
+<p>HttpClient support "Basic, Digest and NTLM" authentication schemes. These
+are used to authenticate with http servers and proxies.</p>
+
+<p>Axis2 uses deployment time and runtime mechanisms to authenticate proxies.
+In deployment time, user has to change the Axis2.xml as follows. This
+authentication will be available in http and https.</p>
+<pre>&lt;transportSender name="<b>http</b>" class="org.apache.axis2.transport.http.CommonsHTTPTransportSender"&gt;
+        &lt;parameter name="PROTOCOL" locked="false"&gt;HTTP/1.1&lt;/parameter&gt;
+        &lt;parameter name="PROXY" proxy_host="proxy_host_name" proxy_port="proxy_host_port" locked="true&gt;userName:domain:passWord&lt;/parameter&gt;
+&lt;/transportSender&gt;<br/></pre>
+
+<p>For a particular proxy, if authentication is not available fill
+"userName:domain:passWord"as "anonymous:anonymous:anonymous".</p>
+
+<p>At runtime user can override the PROXY settings with an Object of
+HttpTransportProperties.ProxyProperties. On the stub initiate an object of
+prior and set it to the MessageContext's property bag via
+HttpConstants.PROXY. On the stub, it depicts as follows,</p>
+<pre>...
+Options options = new Options();
+....
+
+HttpTransportProperties.ProxyProperties proxyProperties = new HttpTransportProperties.new ProxyProperties();
+proxyProperties.setProxyHostName(....);
+proxyProperties.setProxyPort(...);
+...
+options.setProperty(HttpConstants.PROXY, proxyProperties);
+....</pre>
+
+<p>The above code would eventually override the deployment proxy
+configuration settings.</p>
+
+<p>NTLM is the most complex of the authentication protocols supported by
+HttpClient. It requires an instance of NTCredentials be available for the
+domain name of the server or the default credentials. Note that since NTLM
+does not use the notion of realms HttpClient uses the domain name of the
+server as the name of the realm. Also note that the username provided to the
+NTCredentials should not be prefixed with the domain - ie: "axis2" is correct
+whereas "DOMAIN\axis2" is not correct.</p>
+
+<p>There are some significant differences in the way that NTLM works compared
+with basic and digest authentication. These differences are generally handled
+by HttpClient, however having an understanding of these differences can help
+avoid problems when using NTLM authentication.</p>
+<ol>
+  <li>NTLM authentication works almost exactly the same as any other form of
+    authentication in terms of the HttpClient API.  The only difference is
+    that you need to supply 'NTCredentials' instead of
+    'UsernamePasswordCredentials' (NTCredentials actually extends
+    UsernamePasswordCredentials so you can use NTCredentials right throughout
+    your application if need be).</li>
+  <li>The realm for NTLM authentication is the domain name of the computer
+    being connected to, this can be troublesome as servers often have
+    multiple domain names that refer to them.  Only the domain name that
+    HttpClient connects to (as specified by the HostConfiguration) is used to
+    look up the credentials. It is generally advised that while initially
+    testing NTLM authentication, you pass the realm in as null which is used
+    as the default.</li>
+  <li>NTLM authenticates a connection and not a request, so you need to
+    authenticate every time a new connection is made and keeping the
+    connection open during authentication is vital.  Due to this, NTLM cannot
+    be used to authenticate with both a proxy and the server, nor can NTLM be
+    used with HTTP 1.0 connections or servers that do not support HTTP
+    keep-alives.</li>
+</ol>
+</body>
+</html>
