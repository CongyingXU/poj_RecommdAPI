Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointDescription.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointDescription.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/EndpointDescription.java	(working copy)
@@ -44,6 +44,8 @@
 import org.apache.axis2.description.WSDL11ToAllAxisServicesBuilder;
 import org.apache.axis2.description.WSDL11ToAxisServiceBuilder;
 import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.description.builder.DescriptionBuilderComposite;
+import org.apache.axis2.jaxws.description.builder.MDQConstants;
 import org.apache.axis2.jaxws.i18n.Messages;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -92,8 +94,12 @@
     private AxisService axisService;
 
     private QName portQName;
+
     // Corresponds to a port that was added dynamically via addPort and is not declared (either in WSDL or annotations)
     private boolean isDynamicPort;
+    
+    private String serviceImplName;	//class name of the service impl or SEI
+    
     // Note that an EndpointInterfaceDescription will ONLY be set for an Endpoint-based implementation;
     // it will NOT be set for a Provider-based implementation
     private EndpointInterfaceDescription endpointInterfaceDescription;
@@ -107,6 +113,9 @@
     //On Client side, there should be One ServiceClient instance per AxisSerivce
     private ServiceClient serviceClient = null;
     
+    //This is the base WebService or WebServiceProvider that we are processing
+    DescriptionBuilderComposite composite = null;
+    
     public static final String AXIS_SERVICE_PARAMETER = "org.apache.axis2.jaxws.description.EndpointDescription";
     private static final Log log = LogFactory.getLog(EndpointDescription.class);
 
@@ -119,11 +128,14 @@
     // Only one of these two annotations will be set; they are mutually exclusive
     private WebService          webServiceAnnotation;
     private WebServiceProvider  webServiceProviderAnnotation;
+
     // Information common to both WebService and WebServiceProvider annotations
     private String              annotation_WsdlLocation;
     private String              annotation_ServiceName;
     private String              annotation_PortName;
     private String              annotation_TargetNamespace;
+ 
+    // Information only set on WebService annotation
     // ANNOTATION: @WebService
     private String              webService_EndpointInterface;
     private String              webService_Name;
@@ -196,6 +208,75 @@
     }
     
     /**
+     * Create an EndpointDescription based on the DescriptionBuilderComposite.  
+     * Note that per the JAX-WS Spec (Final Release, 4/19/2006
+     * Section 4.2.3 Proxies, page 55)the "namespace component of the port is the target namespace of the WSDL 
+     * definition document".
+     * 
+     * @param theClass The SEI or Impl class.  This will be NULL for Dispatch clients
+     *                 since they don't use an SEI
+     */
+    public EndpointDescription(ServiceDescription parent, String serviceImplName) {
+//TODO: This constructor is similar to the first one, other than it is getting its annotation
+//from the MDQInput List rather than the annotated class.
+    	
+    	// TODO: This and the other constructor will (eventually) take the same args, so the logic needs to be combined
+        // TODO: If there is WSDL, could compare the namespace of the defn against the portQName.namespace
+        this.parentServiceDescription = parent;
+        this.serviceImplName = serviceImplName;
+        this.implOrSEIClass = null;
+
+ 		composite = getServiceDescription().getDescriptionBuilderComposite();
+		if (composite == null){
+            throw ExceptionFactory.makeWebServiceException("EndpointDescription.EndpointDescription: parents DBC is null");
+		}
+
+        //Set the base level of annotation that we are processing...currently
+        // a 'WebService' or a 'WebServiceProvider'
+        if (composite.getWebServiceAnnot() != null)
+        	webServiceAnnotation = composite.getWebServiceAnnot();
+        else
+        	webServiceProviderAnnotation = composite.getWebServiceProviderAnnot();
+        
+        //Call the getter to insure the qualified port name is set. 
+        getPortQName();
+		
+        // TODO: Refactor this with the consideration of no WSDL/Generic Service/Annotated SEI
+        setupAxisServiceFromDBL();
+        addToAxisService();	//Add a reference to this EndpointDescription to the AxisService
+
+        buildDescriptionHierachy();
+        
+        //Currently, we need to set the anonymous operations only for the client
+        //side
+        //TODO: Determine if we need to do this for server side?
+        //	addAnonymousAxisOperations();
+        
+        // This will set the serviceClient field after adding the AxisService 
+        // to the AxisConfig
+        getServiceClient();
+        
+        // Give the configuration builder a chance to finalize configuration for this service
+        try {
+            getServiceDescription().getClientConfigurationFactory().completeAxis2Configuration(axisService);
+        } catch (DeploymentException e) {
+            // TODO RAS
+            // TODO NLS
+            // TODO: Remove this println
+            System.out.println("Caught exception in ServiceDescription.ServiceDescription: " + e);
+            e.printStackTrace();
+//            throw ExceptionFactory.makeWebServiceException("ServiceDescription caught " + e);
+        } catch (Exception e) {
+            // TODO RAS
+            // TODO NLS
+            // TODO: Remove this println
+            System.out.println("Caught exception in ServiceDescription.ServiceDescription: " + e);
+            e.printStackTrace();
+//            throw ExceptionFactory.makeWebServiceException("ServiceDescription caught " + e);
+        }
+    }
+    
+    /**
      * Create from an annotated implementation or SEI class.
      * Note this is currently used only on the server-side (this probably won't change).
      *
@@ -255,7 +336,9 @@
 
         // Verify that one (and only one) of the required annotations is present.
         // TODO: Add tests to verify this error checking
-        webServiceAnnotation = (WebService) implOrSEIClass.getAnnotation(WebService.class);
+        webServiceAnnotation = getServiceDescription().isDBCMap()? 
+        				(WebService) implOrSEIClass.getAnnotation(WebService.class)
+        				: (WebService)composite.getWebServiceAnnot();
         webServiceProviderAnnotation = (WebServiceProvider) implOrSEIClass.getAnnotation(WebServiceProvider.class);
         
         if (webServiceAnnotation == null && webServiceProviderAnnotation == null)
@@ -391,23 +474,96 @@
         }
     }
 
-    private void buildAxisServiceFromWSDL() {
-        // TODO: Change this to use WSDLToAxisServiceBuilder superclass
-        // Note that the axis service builder takes only the localpart of the port qname.
-        // TODO:: This should check that the namespace of the definition matches the namespace of the portQName per JAXRPC spec
-        WSDL11ToAxisServiceBuilder serviceBuilder = new WSDL11ToAxisServiceBuilder(getServiceDescription().getWSDLWrapper().getDefinition(), 
-                getServiceDescription().getServiceQName(), portQName.getLocalPart());
-        // TODO: Currently this only builds the client-side AxisService; it needs to do client and server somehow.
-        // Patterned after AxisService.createClientSideAxisService
-        serviceBuilder.setServerSide(false);
+    /*
+     * This setups and builds the AxisService using only the DescriptionBuilderCompositeList
+     * 
+     */
+    private void setupAxisServiceFromDBL() {
+        // TODO: Need to use MetaDataQuery validator to merge WSDL (if any) and annotations (if any)
+        // Build up the AxisService.  Note that if this is a dispatch client, then we don't use the
+        // WSDL to build up the AxisService since the port added to the Service by the client is not
+        // one that will be present in the WSDL.  A null class passed in as the SEI indicates this 
+        // is a dispatch client.
+    	
+     	if (getServiceDescription().getWSDLWrapper() != null) {
+            buildAxisServiceFromWSDL();
+        }
+        else {
+            buildAxisServiceFromNoWSDL();
+        }
+        
+        if (axisService == null) {
+            // TODO: RAS & NLS
+            throw ExceptionFactory.makeWebServiceException("Unable to create AxisService for "
+                    + createAxisServiceName());
+        }
+
+        // Save the Service QName as a parameter.
+        Parameter serviceNameParameter = new Parameter();
+        serviceNameParameter.setName(MDQConstants.WSDL_SERVICE_QNAME);
+        serviceNameParameter.setValue(getServiceDescription().getServiceQName());
+        
+        // Save the Port name.  Note: Axis does not expect a QName since the namespace
+        //   for the port is the ns from the WSDL definition 
+        Parameter portParameter = new Parameter();
+        portParameter.setName(MDQConstants.WSDL_PORT);
+        portParameter.setValue(getPortQName().getLocalPart());
+
+        //Save the WSDL Definition
+        Parameter wsdlDefParameter = new Parameter();
+        wsdlDefParameter.setName(MDQConstants.WSDL_DEFINITION);
+        wsdlDefParameter.setValue(getServiceDescription().getWSDLWrapper().getDefinition());
+        
+        //Save the WSDL Location
+        Parameter wsdlLocationParameter = new Parameter();
+        wsdlDefParameter.setName(MDQConstants.WSDL_LOCATION);
+        wsdlDefParameter.setValue(getWebServiceWSDLLocation());
+        
+        //Save the fully qualified class name for the serviceImpl
+        Parameter serviceClassNameParameter = new Parameter();
+        serviceClassNameParameter.setName(MDQConstants.SERVICE_CLASS);
+        serviceClassNameParameter.setValue(javifyClassName(composite.getClassName()));
+           
         try {
-            axisService = serviceBuilder.populateService();
-            axisService.setName(createAxisServiceName());
-        } catch (AxisFault e) {
-            // TODO We should not swallow a fault here.
-            log.warn(Messages.getMessage("warnAxisFault", e.toString()));
+            axisService.addParameter(serviceNameParameter);
+            axisService.addParameter(portParameter);                        
+            axisService.addParameter(wsdlDefParameter);
+            axisService.addParameter(wsdlLocationParameter);                        
+            axisService.addParameter(serviceClassNameParameter);
+        } 
+        catch (AxisFault e) {
+            // TODO RAS
+            e.printStackTrace();
         }
     }
+
+    private void buildAxisServiceFromWSDL() {
+    	
+    	try {
+    		
+    		// TODO: Change this to use WSDLToAxisServiceBuilder superclass
+    		// Note that the axis service builder takes only the localpart of the port qname.
+    		// TODO:: This should check that the namespace of the definition matches the namespace of the portQName per JAXRPC spec
+    		WSDL11ToAxisServiceBuilder serviceBuilder = 
+    			new WSDL11ToAxisServiceBuilder( getServiceDescription().getWSDLWrapper().getDefinition(), 
+    					getServiceDescription().getServiceQName(), 
+    					getPortQName().getLocalPart());
+    		
+    		// TODO: Currently this only builds the client-side AxisService; 
+    		// it needs to do client and server somehow.
+    		// Patterned after AxisService.createClientSideAxisService        
+    		if (getServiceDescription().isServerSide())
+    			serviceBuilder.setServerSide(true);
+    		else 
+    			serviceBuilder.setServerSide(false);
+    		
+    		axisService = serviceBuilder.populateService();
+    		axisService.setName(createAxisServiceName());
+    	} catch (AxisFault e) {
+    		// TODO We should not swallow a fault here.
+    		log.warn(Messages.getMessage("warnAxisFault", e.toString()));
+    	}
+    }
     
     private void buildAxisServiceFromNoWSDL() {
         // TODO: Refactor this to create from annotations.
@@ -427,16 +583,29 @@
         // Build up the Description Hierachy.  Note that if this is a dynamic port, then we don't use the
         // WSDL to build up the hierachy since the port added to the Service by the client is not
         // one that will be present in the WSDL.
-        if (!isDynamicPort && getServiceDescription().getWSDLWrapper() != null) {
-            buildEndpointDescriptionFromWSDL();
-        }
-        else if (implOrSEIClass != null){
-            // Create the rest of the description hierachy from annotations on the class.
-            // If there is no SEI class, then this is a Distpach case, and we currently 
-            // don't create the rest of the description hierachy (since it is not an SEI and thus
-            // not operation-based client.
-            buildEndpointDescriptionFromNoWSDL();
-        }
+    	
+    	//First, check to see if we can build this with the DBC List
+    	//TODO: When MDQ input is the only possible input, then we can remove the check for
+    	//      the DBC list, until that time the code in here may appear somewhat redundant
+    	if (getServiceDescription().isDBCMap()) {
+    		if (!isDynamicPort && getServiceDescription().getWSDLWrapper() != null)
+    			buildEndpointDescriptionFromWSDL();
+    		else
+    			buildEndpointDescriptionFromNoWSDL();
+    	} else {
+    		//Still processing annotations from the class
+    		
+    		if (!isDynamicPort && getServiceDescription().getWSDLWrapper() != null) {
+    			buildEndpointDescriptionFromWSDL();
+    		}
+    		else if (implOrSEIClass != null){
+    			// Create the rest of the description hierachy from annotations on the class.
+    			// If there is no SEI class, then this is a Distpach case, and we currently 
+    			// don't create the rest of the description hierachy (since it is not an SEI and thus
+    			// not operation-based client.
+    			buildEndpointDescriptionFromNoWSDL();
+    		}
+    	}
     }
     
     private void buildEndpointDescriptionFromWSDL() {
@@ -450,12 +619,15 @@
         boolean wsdlPortFound = false;
         if (wsdlPorts != null && wsdlPorts.size() > 0) {
             Iterator wsdlPortIterator = wsdlPorts.values().iterator();
+  
             while (wsdlPortIterator.hasNext() && !wsdlPortFound) {
                 Port wsdlPort = (Port) wsdlPortIterator.next();
                 // Note the namespace is not included on the WSDL Port.
                 if (wsdlPort.getName().equals(portQName.getLocalPart())) {
-                    // Create the Endpoint Interface Description based on the WSDL.
+                    
+                	// Create the Endpoint Interface Description based on the WSDL.
                     endpointInterfaceDescription = new EndpointInterfaceDescription(this);
+ 
                     // Update the EndpointInterfaceDescription created with WSDL with information from the
                     // annotations in the SEI
                     endpointInterfaceDescription.updateWithSEI(implOrSEIClass);
@@ -503,6 +675,7 @@
         return serviceClient;
     }
  
+    //This should eventually be deprecated in favor 'createAxisServiceNameFromDBL
     private String createAxisServiceName() {
         String portName = null;
         if (portQName != null) {
@@ -515,6 +688,13 @@
         return getServiceDescription().getServiceQName().getLocalPart() + "." + portName;
     }
 
+    private String javifyClassName(String className) {
+    	if(className.indexOf("/") != -1) {
+    		return className.replaceAll("/", ".");
+    	}
+    	return className;
+    }
+
     public boolean isProviderBased() {
         return webServiceProviderAnnotation != null;
     }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ServiceDescription.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ServiceDescription.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/ServiceDescription.java	(working copy)
@@ -19,9 +19,11 @@
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Enumeration;
+import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.List;
 
 import javax.xml.namespace.QName;
 import javax.xml.ws.WebServiceException;
@@ -30,6 +32,7 @@
 import javax.wsdl.Port;
 import javax.wsdl.Service;
 import javax.wsdl.WSDLException;
+import javax.xml.namespace.QName;
 
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.client.ServiceClient;
@@ -45,6 +48,9 @@
 import org.apache.axis2.engine.AbstractDispatcher;
 import org.apache.axis2.jaxws.ClientConfigurationFactory;
 import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.description.builder.DescriptionBuilderComposite;
+import org.apache.axis2.jaxws.description.builder.MethodDescriptionComposite;
+import org.apache.axis2.jaxws.description.builder.WebMethodAnnot;
 import org.apache.axis2.jaxws.i18n.Messages;
 import org.apache.axis2.jaxws.util.WSDL4JWrapper;
 import org.apache.axis2.jaxws.util.WSDLWrapper;
@@ -115,6 +121,11 @@
     
     private static final Log log = LogFactory.getLog(ServiceDescription.class);
 
+    private HashMap<String, DescriptionBuilderComposite> dbcMap = null;
+    
+    private DescriptionBuilderComposite	composite = null;
+    private boolean isServerSide = false;
+    
     /**
      * This is (currently) the client-side-only constructor
      * Construct a service description hierachy based on WSDL (may be null), the Service class, and 
@@ -163,7 +174,54 @@
         // TODO: The ServiceQName instance variable should be set based on annotation or default
     }
 
+    /**
+     * This is (currently) the service-provider-side-only constructor.
+     * Create a service Description based on a service implementation class
+     * 
+     * @param serviceImplClass
+     */
+    ServiceDescription(	
+    		HashMap<String, DescriptionBuilderComposite> dbcMap,
+    		DescriptionBuilderComposite composite ) {
+    	
+    	this.composite = composite;
+    	
+    	String serviceImplName = this.composite.getClassName();
+    	
+    	this.dbcMap = dbcMap;
+//TODO: How to we get this when called from server side, create here for now
+    	this.isServerSide = true;
+	
+    	//capture the WSDL, if there is any...to be used for later processing
+    	setupWsdlDefinition();
+    	
+		// Do a first pass validation for this DescriptionBuilderComposite.
+    	// This is not intended to be a full integrity check, but rather a fail-fast mechanism
+    	validateDBCLIntegrity();
+    	
+        // The ServiceQName instance variable is set based on annotation or default
+        //TODO: When we get this, need to consider verifying service name between WSDL
+        //      and annotations, so
+    	String targetNamespace;
+    	String serviceName;
+    	if(this.composite.getWebServiceAnnot() != null) {
+    		targetNamespace = this.composite.getWebServiceAnnot().targetNamespace();
+    		serviceName = this.composite.getWebServiceAnnot().serviceName();
+    	}
+    	else {
+    		targetNamespace = this.composite.getWebServiceProviderAnnot().targetNamespace();
+    		serviceName = this.composite.getWebServiceProviderAnnot().serviceName();
+    	}
+		this.serviceQName = new QName(targetNamespace, serviceName);
 
+        
+    	
+        // Create the EndpointDescription hierachy from the service impl annotations; Since the PortQName is null, 
+        // it will be set to the annotation value.
+        //EndpointDescription endpointDescription = new EndpointDescription(null, this, serviceImplName);
+        EndpointDescription endpointDescription = new EndpointDescription(this, serviceImplName);
+        addEndpointDescription(endpointDescription);       
+    }
     
     /*=======================================================================*/
     /*=======================================================================*/
@@ -326,9 +384,15 @@
     public EndpointDescription[] getEndpointDescriptions() {
         return endpointDescriptions.values().toArray(new EndpointDescription[0]);
     }
+    
     public EndpointDescription getEndpointDescription(QName portQName) {
         return endpointDescriptions.get(portQName);
     }
+    
+    public DescriptionBuilderComposite getDescriptionBuilderComposite() {
+    	return composite;
+    }
+
     /**
      * Return the EndpointDescriptions corresponding to the SEI class.  Note that
      * Dispatch endpoints will never be returned because they do not have an associated SEI.
@@ -355,6 +419,17 @@
         }
         return returnEndpointDesc;
     }
+    
+    /*
+     * @return True - if we are processing with the DBC List instead of reflection
+     */
+    public boolean isDBCMap() {
+    	if (dbcMap == null)
+    		return false;
+    	else
+    		return true;
+    }
+    
     // END of public accessor methods
     /*=======================================================================*/
     /*=======================================================================*/
@@ -365,9 +440,24 @@
     private void setupWsdlDefinition() {
         // Note that there may be no WSDL provided, for example when called from 
         // Service.create(QName serviceName).
-        if (wsdlURL != null) {
+    	
+    	if (isDBCMap()) {
+
+    		if (composite.getWsdlDefinition() != null) {
+    			this.wsdlURL = composite.getWsdlURL();
+                
+    			try {
+                    this.wsdlWrapper = new WSDL4JWrapper(this.wsdlURL, 
+                    				composite.getWsdlDefinition());
+
+                } catch (WSDLException e) {
+                    throw ExceptionFactory.makeWebServiceException(Messages.getMessage("wsdlException", e.getMessage()), e);
+                }
+    		}
+        //Deprecate this code block when MDQ is fully integrated
+    	} else if (wsdlURL != null) {
             try {
-                wsdlWrapper = new WSDL4JWrapper(this.wsdlURL);
+                this.wsdlWrapper = new WSDL4JWrapper(this.wsdlURL);
             } catch (WSDLException e) {
                 throw ExceptionFactory.makeWebServiceException(Messages.getMessage("wsdlException", e.getMessage()), e);
             }
@@ -381,7 +471,7 @@
     public URL getWSDLLocation() {
         return wsdlURL;
     }
-    
+
     public ConfigurationContext getAxisConfigContext() {
         if (configContext == null) {
             configContext = getClientConfigurationFactory().getClientConfigurationContext();
@@ -406,4 +496,175 @@
     public QName getServiceQName() {
         return serviceQName;
     }
+
+
+    public boolean isServerSide() {
+ 		return isServerSide;
 }
+
+	private AxisService processImplBean(){
+		//Process
+		AxisService axisService = null;
+		return axisService;
+	}
+	
+	private void validateDBCLIntegrity(){
+		
+		//First, check the integrity of this input composite
+		//and retrieve
+		//the composite that represents this impl
+		
+//TODO: Currently, we are calling this method on the DBC. However, the DBC
+//will eventually need access to to the whole DBC map to do proper validation.
+//We don't want to pass the map of DBC's back into a single DBC.
+//So, for starters, this method and all the privates that it calls should be 
+// moved to here. At some point, we should consider using a new class that we
+//can implement scenarios of, like validateServiceImpl implements validator
+		
+		try {
+			validateIntegrity();
+		}
+		catch (Exception ex) {
+			//com.ibm.ws.ffdc.FFDCFilter.processException(ex, "org.apache.axis2.jaxws.description.ServiceDescription", "329", this);				
+			//Tr.error(_tc, msg, inserts);
+		}
+	}
+
+	public void validateIntegrity() {
+	//TODO: Consider moving this to a utils area, do we really want a public
+	//      method that checks integrity...possibly
+	
+	//TODO: This method will validate the integrity of this object. Basically, if 
+	//consumer set this up improperly, then we should fail fast, should consider placing
+	//this method in a utils class within the 'description' package
+	
+	if (composite.getWebServiceAnnot() != null && composite.getWebServiceProviderAnnot() != null) {
+		throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: WebService annotation and WebServiceProvider annotation cannot coexist");
+	}
+	//	TODO EDIT CHECK: valid only if is a provider class, what are these?
+	//	TODO From WASServiceGenerator: use logic for checks against SEI and service impl
+	
+//	Make sure that we're only validating against WSDL, if there is WSDL...duh
+	
+	if (composite.getWebServiceAnnot() != null) {
+		if (!composite.isInterface()) {
+			// TODO: Validate on the class that this.classModifiers Array does not contain the strings
+			//        FINAL or ABSTRACT, but does contain PUBLIC
+			// TODO: Validate on the class that a public constructor exists
+			// TODO: Validate on the class that a finalize() method does not exist
+			if (!composite.getWebServiceAnnot().wsdlLocation().equals("")) {
+				if (composite.getWsdlDefinition() == null || composite.getWsdlURL() ==  null) {
+					throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: cannot find WSDL Definition pertaining to this WebService annotation");
+				}
+			}
+			
+			//		setWebServiceAnnotDefaults(true=impl); Must happen before we start checking annot
+			//		if 'endpointInterface' is not null then
+			//			Perform more validation with SEI
+			//			Verify that we can find the SEI composite in the sorted list
+			//			Verify that there are no WebMethod annotations (Basically, make sure that
+			//            the only annotations are HandlerChain, SOAPMessageHandlers
+			//			Validate w/something similar to validateImplementation, which basically
+			//				validates that the implementation class methods and intf methods lines up
+			//		else 'endpoint interface' is null so process as implicit SEI
+			//			Validate hmmm something
+			//			WSDL Check: ?
+			//		Call ValidateWebMethodAnnots()
+			//			- this method will check that all methods are public - ???
+			//
+		} else { //this is an interface
+			//TODO:	Validate that the interface is public 
+			
+			if (!composite.getWebServiceAnnot().endpointInterface().equals("")) {
+				throw ExceptionFactory.makeWebServiceException("DescriptionBuilderComposite: WebService annotation contains a non-empty field for the SEI");
+			}
+			//		Validate (Spec. JAXWS 2.0 Sec.3.4) all WebMethod annots have exclude to 'false' or null 
+			//		Call ValidateWebMethodAnnots()
+			//	
+		}
+		
+		CheckMethodsAgainstWSDL();
+		
+	}
+	//We made it through this round of validation, now set appropriate defaults
+	//within each annotation, Realize that we'll have to do this for the inherited classes
+	//as well.
+	
+	//!!!  TODO: Set Default field values for each annot, as well as, inherited classes
+	//TODO: We shouldn't try to set defaults for all annots...we need to be selective
+	//      based on what is being represented here (i.e. provider vs. impl. vs. SEI)
+	//      So, we may consider doing this at end of individual validation blocks above
+	//setWebServiceAnnotDefaults(true=impl);
+	//setWebMethodAnnotDefaults();
+	//setWebServiceProviderAnnotDefaults();
+	
+	// For each annot that is set within this composite
+	// If it is set, then check that its default values are appropriate, based
+	// on the spec.
+	}
+	
+	private void CheckMethodsAgainstWSDL() {		
+
+		if (WebMethodAnnotationsExist()) {
+			if (WebMethodAnnotationsWithFalseExclusions())
+				VerifyFalseExclusionsWithWSDL();
+			else
+				VerifyPublicMethodsWithWSDL();
+		} else {
+			VerifyPublicMethodsWithWSDL();
+		}
+	}
+	
+	/**
+	 * @return Returns TRUE if we find just one WebMethod Annotation 
+	 */
+	private boolean WebMethodAnnotationsExist() {
+		
+		
+		MethodDescriptionComposite mdc = null;
+		Iterator<MethodDescriptionComposite> iter = composite.getMethodDescriptionsList().iterator();
+		
+		while (iter.hasNext()) {
+			mdc = iter.next();
+
+			if (mdc.getWebMethodAnnot() != null)
+				return true;
+		}
+		
+		return false;
+	}
+	
+	private void VerifyFalseExclusionsWithWSDL() {
+		//TODO: Place logic here to verify that each exclude==false WebMethod annot we find
+		//      is contained in the WSDL
+	}
+	
+	private void VerifyPublicMethodsWithWSDL() {
+		//TODO: Place logic here to verify that each publicMethod with no WebMethod annot
+		//      is contained in the WSDL
+
+	}
+
+	
+	/**
+	 * @return Returns TRUE if we find just one WebMethod Annotation with exclude flag
+	 * set to false
+	 */
+	private boolean WebMethodAnnotationsWithFalseExclusions() {
+		
+		MethodDescriptionComposite mdc = null;
+		Iterator<MethodDescriptionComposite> iter = composite.getMethodDescriptionsList().iterator();
+		
+		while (iter.hasNext()) {
+			mdc = iter.next();
+
+			WebMethodAnnot wma = mdc.getWebMethodAnnot();
+			if (wma != null) {
+				if (wma.exclude() == false)
+					return true;
+			}
+		}
+		
+		return false;
+	}
+}
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/ResponseWrapperAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/ResponseWrapperAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/ResponseWrapperAnnot.java	(working copy)
@@ -104,6 +104,23 @@
 	public Class<Annotation> annotationType(){
 		return Annotation.class;
 	}
+	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@ResponseWrapper.localName= " + localName);
+		sb.append(newLine);
+		sb.append("@ResponseWrapper.className= " + className);
+		sb.append(newLine);
+		sb.append("@ResponseWrapper.targetNamespace= " + targetNamespace);
+		sb.append(newLine);
+		return sb.toString();
+	}
 
 
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/ServiceModeAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/ServiceModeAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/ServiceModeAnnot.java	(working copy)
@@ -60,4 +60,17 @@
 		this.value = value;
 	}
 	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@ServiceMode.value= " + value.toString());
+		sb.append(newLine);
+		return null;
+	}
+	
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/MethodDescriptionComposite.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/MethodDescriptionComposite.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/MethodDescriptionComposite.java	(working copy)
@@ -3,6 +3,8 @@
  */
 package org.apache.axis2.jaxws.description.builder;
 
+import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 
 public class MethodDescriptionComposite {
@@ -13,22 +15,22 @@
 	private String[]	exceptions;
 
 	boolean	oneWayAnnotated;	
-	private WebMethodAnnot	webMethodAnnot;	
-	private WebResultAnnot 	webResultAnnot;
+	private WebMethodAnnot			webMethodAnnot;	
+	private WebResultAnnot 			webResultAnnot;
 	private WebServiceContextAnnot 	webServiceContextAnnot;	
-	private HandlerChainAnnot	handlerChainAnnot;	
-	private SoapBindingAnnot 	soapBindingAnnot;
-	private WebServiceRefAnnot 	webServiceRefAnnot;	
-	private WebEndpointAnnot 	webEndpointAnnot;
-	private RequestWrapperAnnot requestWrapperAnnot; //TODO EDIT CHECK: only on methods of SEI
-	private ResponseWrapperAnnot responseWrapperAnnot;//TODO EDIT CHECK: only on methods of SEI
+	private HandlerChainAnnot		handlerChainAnnot;	
+	private SoapBindingAnnot 		soapBindingAnnot;
+	private WebServiceRefAnnot 		webServiceRefAnnot;	
+	private WebEndpointAnnot 		webEndpointAnnot;
+	private RequestWrapperAnnot 	requestWrapperAnnot; //TODO EDIT CHECK: only on methods of SEI
+	private ResponseWrapperAnnot 	responseWrapperAnnot;//TODO EDIT CHECK: only on methods of SEI
 	private List<ParameterDescriptionComposite> parameterDescriptions;//TODO EDIT CHECK: only on methods of SEI
 
 	/*
 	 * Default Constructor
 	 */
 	public MethodDescriptionComposite () {
-		
+		parameterDescriptions = new ArrayList<ParameterDescriptionComposite>();
 	}
 	
 	public MethodDescriptionComposite (	
@@ -250,9 +252,10 @@
 	 *  @param index The index at which to place this parameterDescription
 	 */
 	public void addParameterDescriptionComposite(ParameterDescriptionComposite parameterDescription, int index) {
+		parameterDescription.setListOrder(index);
 		parameterDescriptions.add(index, parameterDescription);
 	}
-	
+
 	/**
 	 *  @param parameterDescription The parameterDescription to add to the set.
 	 */
@@ -273,4 +276,91 @@
 	public void setExceptions(String[] exceptions) {
 		this.exceptions = exceptions;
 	}
+	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append("***** BEGIN MethodDescriptionComposite *****");
+		sb.append(newLine);
+		sb.append("MDC.name= " + methodName);
+		sb.append(newLine);
+		sb.append("MDC.returnType= " + returnType);
+		if(exceptions != null) {
+			for(int i=0; i < exceptions.length; i++) {
+				sb.append("MDC.exception= " + exceptions[i]);
+				sb.append(newLine);
+			}
+		}
+		sb.append(newLine);
+		sb.append("\t ** @OneWay **");
+		sb.append(newLine);
+		sb.append("\t isOneWay= ");
+		if(oneWayAnnotated) {
+			sb.append("true");
+		}
+		else {
+			sb.append("false");
+		}
+		sb.append(newLine);
+		if(webMethodAnnot != null) {
+			sb.append("\t ** @WebMethod **");
+			sb.append(newLine);
+			sb.append("\t" + webMethodAnnot.toString());
+		}
+		sb.append(newLine);
+		if(requestWrapperAnnot != null) {
+			sb.append("\t ** @RequestWrapper **");
+			sb.append(newLine);
+			sb.append("\t" + requestWrapperAnnot.toString());
+		}
+		sb.append(newLine);
+		if(responseWrapperAnnot != null) {
+			sb.append("\t ** @ResponsetWrapper **");
+			sb.append(newLine);
+			sb.append("\t" + responseWrapperAnnot.toString());
+		}
+		sb.append(newLine);
+		if(soapBindingAnnot != null) {
+			sb.append("\t ** @SOAPBinding **");
+			sb.append(newLine);
+			sb.append("\t" + soapBindingAnnot.toString());
+		}
+		sb.append(newLine);
+		if(webEndpointAnnot != null) {
+			sb.append("\t ** @WebEndpoint **");
+			sb.append(newLine);
+			sb.append("\t" + webEndpointAnnot.toString());
+		}
+		sb.append(newLine);
+		if(webResultAnnot != null) {
+			sb.append("\t ** @WebResult **");
+			sb.append(newLine);
+			sb.append("\t" + webResultAnnot.toString());
+		}
+		sb.append(newLine);
+		if(webServiceRefAnnot != null) {
+			sb.append("\t ** @WebServiceRef **");
+			sb.append(newLine);
+			sb.append("\t" + webServiceRefAnnot.toString());
+		}
+		sb.append(newLine);
+		if(handlerChainAnnot != null) {
+			sb.append("\t ** @HandlerChain **");
+			sb.append(newLine);
+			sb.append("\t" + handlerChainAnnot.toString());
+		}
+		sb.append(newLine);
+		Iterator<ParameterDescriptionComposite> pdcIter = parameterDescriptions.iterator();
+		while(pdcIter.hasNext()) {
+			ParameterDescriptionComposite pdc = pdcIter.next();
+			sb.append("\t\t" + pdc.toString());
+			sb.append(newLine);
+		}
+		sb.append("***** END MethodDescriptionComposite *****");
+		return sb.toString();
+	}
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/ParameterDescriptionComposite.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/ParameterDescriptionComposite.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/ParameterDescriptionComposite.java	(working copy)
@@ -9,6 +9,7 @@
 	private WebParamAnnot			webParamAnnot;
 	private WebServiceRefAnnot 		webServiceRefAnnot;
 	private WebServiceContextAnnot	webServiceContextAnnot;
+	private int listOrder; //represents this composites order in the list
 
 	public ParameterDescriptionComposite () {
 		
@@ -30,21 +31,21 @@
 	/**
 	 * @return Returns the parameterType.
 	 */
-	private String getParameterType() {
+	public String getParameterType() {
 		return parameterType;
 	}
 
 	/**
 	 * @return Returns the webParamAnnot.
 	 */
-	private WebParamAnnot getWebParamAnnot() {
+	public WebParamAnnot getWebParamAnnot() {
 		return webParamAnnot;
 	}
 
 	/**
 	 * @return Returns the webServiceRefAnnot.
 	 */
-	private WebServiceRefAnnot getWebServiceRefAnnot() {
+	public WebServiceRefAnnot getWebServiceRefAnnot() {
 		return webServiceRefAnnot;
 	}
 
@@ -56,31 +57,70 @@
 	}
 
 	/**
+	 * @return Returns the webServiceContextAnnot.
+	 */
+	public int getListOrder() {
+		return listOrder;
+	}
+
+	/**
 	 * @param parameterType The parameterType to set.
 	 */
-	private void setParameterType(String parameterType) {
+	public void setParameterType(String parameterType) {
 		this.parameterType = parameterType;
 	}
 
 	/**
 	 * @param webParamAnnot The webParamAnnot to set.
 	 */
-	private void setWebParamAnnot(WebParamAnnot webParamAnnot) {
+	public void setWebParamAnnot(WebParamAnnot webParamAnnot) {
 		this.webParamAnnot = webParamAnnot;
 	}
 
 	/**
 	 * @param webServiceRefAnnot The webServiceRefAnnot to set.
 	 */
-	private void setWebServiceRefAnnot(WebServiceRefAnnot webServiceRefAnnot) {
+	public void setWebServiceRefAnnot(WebServiceRefAnnot webServiceRefAnnot) {
 		this.webServiceRefAnnot = webServiceRefAnnot;
 	}
 
 	/**
 	 * @param webServiceContextAnnot The webServiceContextAnnot to set.
 	 */
-	private void setWebServiceContextAnnot(WebServiceContextAnnot webServiceContextAnnot) {
+	public void setWebServiceContextAnnot(WebServiceContextAnnot webServiceContextAnnot) {
 		this.webServiceContextAnnot = webServiceContextAnnot;
 	}
 
+	/**
+	 * @param webServiceContextAnnot The webServiceContextAnnot to set.
+	 */
+	public void setListOrder(int listOrder) {
+		this.listOrder = listOrder;
+	}
+
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append("***** BEGIN ParameterDescriptionComposite *****");
+		sb.append("PDC.parameterType= " + parameterType);
+		sb.append(newLine);
+		if(webParamAnnot != null) {
+			sb.append("\t @WebParam");
+			sb.append(newLine);
+			sb.append("\t" + webParamAnnot.toString());
+		}
+		sb.append(newLine);
+		if(webServiceRefAnnot != null) {
+			sb.append("\t @WebServiceRef");
+			sb.append(newLine);
+			sb.append("\t" + webServiceRefAnnot.toString());
+		}
+		sb.append(newLine);
+		sb.append("***** END ParameterDescriptionComposite *****");
+		return sb.toString();
+	}
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebServiceProviderAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebServiceProviderAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebServiceProviderAnnot.java	(working copy)
@@ -123,4 +123,23 @@
 	public Class<Annotation> annotationType(){
 		return Annotation.class;
 	}
+	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@WebServiceProvider.serviceName= " + serviceName);
+		sb.append(newLine);
+		sb.append("@WebServiceProvider.targetNamespace= " + targetNamespace);
+		sb.append(newLine);
+		sb.append("@WebServiceProvider.wsdlLocation= " + wsdlLocation);
+		sb.append(newLine);
+		sb.append("@WebServiceProvider.portName= " + portName);
+		sb.append(newLine);
+		return sb.toString();
+	}
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebFaultAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebFaultAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebFaultAnnot.java	(working copy)
@@ -75,5 +75,22 @@
 	public Class<Annotation> annotationType(){
 		return Annotation.class;
 	}
+	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@WebFault.name= " + name);
+		sb.append(newLine);
+		sb.append("@WebFault.faultBean= " + faultBean);
+		sb.append(newLine);
+		sb.append("@WebFault.targetNamespace= " + targetNamespace);
+		sb.append(newLine);
+		return sb.toString();
+	}
 
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/FieldDescriptionComposite.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/FieldDescriptionComposite.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/FieldDescriptionComposite.java	(working copy)
@@ -87,5 +87,30 @@
 	public void setWebServiceRefAnnot(WebServiceRefAnnot webServiceRefAnnot) {
 		this.webServiceRefAnnot = webServiceRefAnnot;
 	}
+	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append("***** BEGIN FieldDescriptionComposite *****");
+		sb.append("FDC.fieldName=" + fieldName);
+		sb.append(newLine);
+		if(handlerChainAnnot != null) {
+			sb.append("\t @HandlerChain");
+			sb.append(newLine);
+			sb.append("\t" + handlerChainAnnot.toString());
+		}
+		sb.append(newLine);
+		if(webServiceRefAnnot != null) {
+			sb.append("\t @WebServiceRef");
+			sb.append(newLine);
+			sb.append("\t" + webServiceRefAnnot.toString());
+		}
+		sb.append("***** END FieldDescriptionComposite");
+		return sb.toString();
+	}
 }
 	
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/BindingTypeAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/BindingTypeAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/BindingTypeAnnot.java	(working copy)
@@ -62,6 +62,19 @@
 	public Class<Annotation> annotationType(){
 		return Annotation.class;
 	}
+	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@BindingType.value= " + value);
+		sb.append(newLine);
+		return sb.toString();
+	}
 
 
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebResultAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebResultAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebResultAnnot.java	(working copy)
@@ -98,5 +98,30 @@
 	public Class<Annotation> annotationType(){
 		return Annotation.class;
 	}
+	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@WebResult.name= " + name);
+		sb.append(newLine);
+		sb.append("@WebResult.partName= " + partName);
+		sb.append(newLine);
+		sb.append("@WebResult.targetNamespace= " + targetNamespace);
+		sb.append(newLine);
+		sb.append("@WebResult.header= ");
+		if(header) {
+			sb.append("true");
+		}
+		else {
+			sb.append("false");
+		}
+		sb.append(newLine);
+		return sb.toString();
+	}
 
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/DescriptionBuilderComposite.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/DescriptionBuilderComposite.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/DescriptionBuilderComposite.java	(working copy)
@@ -3,11 +3,16 @@
  */
 package org.apache.axis2.jaxws.description.builder;
 
+import java.net.URL;
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
 import javax.wsdl.Definition;
 
+import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.util.WSDL4JWrapper;
+
 public class DescriptionBuilderComposite {
 	/*
 	 * This structure contains the full reflected class, as well as, the
@@ -18,18 +23,24 @@
 
 	public DescriptionBuilderComposite () {
 		
+		methodDescriptions = new ArrayList<MethodDescriptionComposite>();
+		fieldDescriptions = new ArrayList<FieldDescriptionComposite>();
+		webServiceRefAnnotList = new ArrayList<WebServiceRefAnnot>();	
+		interfacesList = new ArrayList<String>();
 	}
 
 	//Class type within the module
-	private enum ModuleClassType { SERVICEIMPL, SEI, SERVICE, SUPER, PROVIDER, FAULT }
+	public static enum ModuleClassType { SERVICEIMPL, SEI, SERVICE, SUPER, PROVIDER, FAULT}
+	private ModuleClassType moduleClassType = null;
 	
 	//Note: a WSDL is not necessary
-	private Definition	wsdlDefinition;
+	private Definition 	wsdlDefinition = null;
+	private URL			wsdlURL = null;
 
 	// Class-level annotations
 	private WebServiceAnnot 			webServiceAnnot;	
-	private WebServiceProviderAnnot 	webServiceProviderAnnot; //	TODO EDIT CHECK: WebService and WebServiceProvider are mutually exclusive
-	private ServiceModeAnnot 			serviceModeAnnot;	//	TODO EDIT CHECK: valid only if is a provider class	
+	private WebServiceProviderAnnot 	webServiceProviderAnnot;
+	private ServiceModeAnnot 			serviceModeAnnot;	
 	private WebServiceClientAnnot 		webServiceClientAnnot;
 	private WebFaultAnnot 				webFaultAnnot;
 	private HandlerChainAnnot 			handlerChainAnnot;
@@ -43,7 +54,8 @@
 	private String[] 		classModifiers; //public, abstract, final, strictfp...
 	private String			extendsClass;	//Set to the name of the super class
 	private List<String>	interfacesList; //Set this for all implemented interfaces
-
+	private boolean			isInterface = false;
+	
 	private List<MethodDescriptionComposite> methodDescriptions;		
 	private List<FieldDescriptionComposite> fieldDescriptions;		
 
@@ -154,13 +166,20 @@
 	}
 
 	/**
-	 * @return Returns the wsdlDefinition.
+	 * @return Returns the wsdlDefinition
 	 */
 	public Definition getWsdlDefinition() {
 		return wsdlDefinition;
 	}
 	
 	/**
+	 * @return Returns the wsdlURL
+	 */
+	public URL getWsdlURL() {
+		return this.wsdlURL;
+	}
+	
+	/**
 	 * Returns the nth occurence of this MethodComposite. Since
 	 * method names are not unique, we have to account for multiple occurrences
 	 *
@@ -187,6 +206,10 @@
 		return composite;
 	}
 	
+	public List<MethodDescriptionComposite> getMethodDescriptionsList() {
+		return methodDescriptions;
+	}
+	
 	/**
 	 *
 	 * @return Returns the methodDescriptionComposite..null if not found
@@ -205,6 +228,15 @@
 		return composite;
 	}
 	
+	/**
+	 *
+	 * @return Returns true if this is an interface
+	 */
+	public boolean isInterface(){
+
+		return isInterface;
+	}
+	
 	//++++++++
 	//Setters
 	//++++++++
@@ -236,7 +268,7 @@
 	/**
 	 * @param interfacesList  The interfacesList to set.
 	 */
-	public void getInterfacesList(List<String> interfacesList) {
+	public void setInterfacesList(List<String> interfacesList) {
 		this.interfacesList = interfacesList;
 	}
 	
@@ -300,6 +332,13 @@
 	}
 
 	/**
+	 * @param wsdlURL The wsdlURL to set.
+	 */
+	public void setwsdlURL(URL wsdlURL) {
+		this.wsdlURL = wsdlURL;
+	}
+
+	/**
 	 * @param BindingTypeAnnot The BindingTypeAnnot to set.
 	 */
 	public void setBindingTypeAnnot(
@@ -316,6 +355,13 @@
 	}
 
 	/**
+	 * @param isInterface Sets whether this composite represents a class or interface
+	 */
+	public void setIsInterface(boolean isInterface){
+		this.isInterface = isInterface;
+	}
+
+	/**
 	 *  @param methodDescription The methodDescription to add to the set.
 	 */
 	public void addMethodDescriptionComposite(MethodDescriptionComposite methodDescription) {
@@ -328,5 +374,112 @@
 	public void addFieldDescriptionComposite(FieldDescriptionComposite fieldDescription) {
 		fieldDescriptions.add(fieldDescription);
 	}
+		
+	/**
+	 * @return Returns the ModuleClassType.
+	 */
+	public ModuleClassType getClassType() {
+		
+		if (moduleClassType == null) {
+			//TODO: Determine the class type
+		}
+		return moduleClassType;
+	}
 	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append("***** BEGIN DescriptionBuilderComposite *****");
+		sb.append(newLine);
+		sb.append("DBC.className= " + className);
+		sb.append(newLine);
+		sb.append("DBC.superClass=" + extendsClass);
+		sb.append(newLine);
+		if(classModifiers != null) {
+			for(int i=0; i < classModifiers.length; i++) {
+				sb.append("DBC.classModifier=" + classModifiers[i]);
+				sb.append(newLine);
+			}
+		}
+		sb.append(newLine);
+		Iterator<String> intIter = interfacesList.iterator();
+		while(intIter.hasNext()) {
+			String inter = intIter.next();
+			sb.append("DBC.interface= " + inter);
+			sb.append(newLine);
+		}
+		sb.append(newLine);
+		if(webServiceAnnot != null) {
+			sb.append("\t ** @WebService **");
+			sb.append(newLine);
+			sb.append("\t" + webServiceAnnot.toString());
+		}
+		sb.append(newLine);
+		if(webServiceProviderAnnot != null) {
+			sb.append("\t ** @WebServiceProvider **");
+			sb.append(newLine);
+			sb.append("\t" + webServiceProviderAnnot.toString());
+		}
+		sb.append(newLine);
+		if(webServiceClientAnnot != null) {
+			sb.append("\t ** @WebServiceClient **");
+			sb.append(newLine);
+			sb.append("\t" + webServiceClientAnnot.toString());
+		}
+		sb.append(newLine);
+		if(webFaultAnnot != null) {
+			sb.append("\t ** @WebFault **");
+			sb.append(newLine);
+			sb.append("\t" + webFaultAnnot.toString());
+		}
+		sb.append(newLine);
+		if(serviceModeAnnot != null) {
+			sb.append("\t ** @ServiceMode **");
+			sb.append(newLine);
+			sb.append("\t" + serviceModeAnnot.toString());
+		}
+		sb.append(newLine);
+		if(soapBindingAnnot != null) {
+			sb.append("\t ** @SOAPBinding **");
+			sb.append(newLine);
+			sb.append("\t" + soapBindingAnnot.toString());
+		}
+		sb.append(newLine);
+		if(handlerChainAnnot != null) {
+			sb.append("\t ** @HandlerChain **");
+			sb.append(newLine);
+			sb.append("\t" + handlerChainAnnot.toString());
+		}
+		sb.append(newLine);
+		Iterator<WebServiceRefAnnot> wsrIter = webServiceRefAnnotList.iterator();
+		while(wsrIter.hasNext()) {
+			WebServiceRefAnnot wsr = wsrIter.next();
+			sb.append("\t ** @WebServiceRef **");
+			sb.append(newLine);
+			sb.append("\t" + wsr.toString());
+			sb.append(newLine);
+		}
+		sb.append(newLine);
+		Iterator<MethodDescriptionComposite> mdcIter =  methodDescriptions.iterator();
+		sb.append(newLine);
+		while(mdcIter.hasNext()) {
+			MethodDescriptionComposite mdc = mdcIter.next();
+			sb.append("\t\t" + mdc.toString());
+			sb.append(newLine);
+		}
+		sb.append(newLine);
+		Iterator<FieldDescriptionComposite> fdcIter = fieldDescriptions.iterator();
+		sb.append(newLine);
+		while(fdcIter.hasNext()) {
+			FieldDescriptionComposite fdc = fdcIter.next();
+			sb.append("\t\t" + fdc.toString());
+			sb.append(newLine);
+		}
+		sb.append("***** END DescriptionBuilderComposite *****");
+		return sb.toString();
+	}
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebEndpointAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebEndpointAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebEndpointAnnot.java	(working copy)
@@ -62,4 +62,17 @@
 	public Class<Annotation> annotationType(){
 		return Annotation.class;
 	}
+	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@WebEndpoint.name= " + name);
+		sb.append(newLine);
+		return sb.toString();
+	}
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebMethodAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebMethodAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebMethodAnnot.java	(working copy)
@@ -70,5 +70,28 @@
 	public Class<Annotation> annotationType(){
 		return Annotation.class;
 	}
+	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@WebMethod.operationName= " + operationName);
+		sb.append(newLine);
+		sb.append("@WebMethod.action= " + action);
+		sb.append(newLine);
+		sb.append("@WebMethod.exclude = ");
+		if(exclude) {
+			sb.append("true");
+		}
+		else {
+			sb.append("false");
+		}
+		sb.append(newLine);
+		return sb.toString();
+	}
 
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/MDQConstants.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/MDQConstants.java	(revision 0)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/MDQConstants.java	(revision 0)
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.axis2.jaxws.description.builder;
+
+import javax.xml.namespace.QName;
+
+import org.apache.axis2.wsdl.WSDLConstants;
+
+
+public class MDQConstants {
+
+	public static final String WSDL_SERVICE_QNAME = "WSDL_SERVICE_QNAME";
+    public static final String WSDL_PORT = "WSDL_PORT";
+    public static final String WSDL_DEFINITION = WSDLConstants.WSDL_4_J_DEFINITION;
+    public static final String WSDL_LOCATION = "WSDL_LOCATION";
+    public static final String SERVICE_CLASS = "SERVICE_CLASS";
+}
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/HandlerChainAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/HandlerChainAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/HandlerChainAnnot.java	(working copy)
@@ -70,4 +70,19 @@
 	public Class<Annotation> annotationType(){
 		return Annotation.class;
 	}
+	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@HandlerChain.file= " + file);
+		sb.append(newLine);
+		sb.append("@HandlerChain.name= " + name);
+		sb.append(newLine);
+		return sb.toString();
+	}
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/RequestWrapperAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/RequestWrapperAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/RequestWrapperAnnot.java	(working copy)
@@ -104,6 +104,23 @@
 	public Class<Annotation> annotationType(){
 		return Annotation.class;
 	}
+	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@RequestWrapper.localName= " + localName);
+		sb.append(newLine);
+		sb.append("@RequestWrapper.className= " + className);
+		sb.append(newLine);
+		sb.append("@RequestWrapper.targetNamespace= " + targetNamespace);
+		sb.append(newLine);
+		return sb.toString();
+	}
 
 
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebServiceRefAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebServiceRefAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebServiceRefAnnot.java	(working copy)
@@ -187,4 +187,25 @@
 	public Class<Annotation> annotationType(){
 		return Annotation.class;
 	}
+	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@WebServiceRef.name= " + name);
+		sb.append(newLine);
+		sb.append("@WebServiceRef.wsdlLocation= " + wsdlLocation);
+		sb.append(newLine);
+		sb.append("@WebServiceRef.mappedName= " + mappedName);
+		sb.append(newLine);
+		sb.append("@WebServiceRef.type= " + typeString);
+		sb.append(newLine);
+		sb.append("@WebServiceRef.value= " + valueString);
+		sb.append(newLine);
+		return sb.toString();
+	}
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/SoapBindingAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/SoapBindingAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/SoapBindingAnnot.java	(working copy)
@@ -77,4 +77,18 @@
 		return Annotation.class;
 	}
 
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@SOAPBinding.style= " + style.toString());
+		sb.append("@SOAPBinding.parameterStyle= " + parameterStyle.toString());
+		sb.append("@SOAPBinding.use= " + use.toString());
+		sb.append(newLine);
+		return sb.toString();
+	}
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebServiceClientAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebServiceClientAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebServiceClientAnnot.java	(working copy)
@@ -105,5 +105,21 @@
 		return Annotation.class;
 	}
 
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@WebServiceClient.name= " + name);
+		sb.append(newLine);
+		sb.append("@WebServiceClient.targetNamespace= " + targetNamespace);
+		sb.append(newLine);
+		sb.append("@WebServiceClient.wsdlLocation= " + wsdlLocation);
+		sb.append(newLine);
+		return sb.toString();
+	}
 
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebServiceAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebServiceAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebServiceAnnot.java	(working copy)
@@ -145,4 +145,26 @@
 	}
 	
 	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@WebService.name= " + name);
+		sb.append(newLine);
+		sb.append("@WebService.serviceName= " + serviceName);
+		sb.append(newLine);
+		sb.append("@WebService.endpointInterface= " + endpointInterface);
+		sb.append(newLine);
+		sb.append("@WebService.targetNamespace= " + targetNamespace);
+		sb.append(newLine);
+		sb.append("@WebService.wsdlLocation= " + wsdlLocation);
+		sb.append(newLine);
+		sb.append("@WebService.portName= " + portName);
+		sb.append(newLine);
+		return sb.toString();
+	}
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebParamAnnot.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebParamAnnot.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/builder/WebParamAnnot.java	(working copy)
@@ -101,5 +101,32 @@
 	public Class<Annotation> annotationType(){
 		return Annotation.class;
 	}
+	
+	/**
+	 * Convenience method for unit testing. We will print all of the 
+	 * data members here.
+	 */
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		String newLine = "\n";
+		sb.append(newLine);
+		sb.append("@WebParam.name= " + name);
+		sb.append(newLine);
+		sb.append("@WebParam.partName= " + partName);
+		sb.append(newLine);
+		sb.append("@WebParam.mode = " + mode.toString());
+		sb.append(newLine);
+		sb.append("@WebParam.targetNamespace= " + targetNamespace);
+		sb.append(newLine);
+		sb.append("@WebParam.header= ");
+		if(header) {
+			sb.append("true");
+		}
+		else {
+			sb.append("false");
+		}
+		sb.append(newLine);
+		return sb.toString();
+	}
 
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/DescriptionFactory.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/DescriptionFactory.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/description/DescriptionFactory.java	(working copy)
@@ -21,12 +21,17 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.net.URL;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
 
 import javax.jws.WebService;
 import javax.xml.namespace.QName;
 
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.description.builder.DescriptionBuilderComposite;
 
 /**
  * Creates the JAX-WS metadata descritpion hierachy from some combinations of
@@ -47,7 +52,53 @@
     public static ServiceDescription createServiceDescriptionFromServiceImpl(Class serviceImplClass, AxisService axisService) {
         return new ServiceDescription(serviceImplClass, axisService);
     }
+    
+    //TODO: Determine whether this method is necessary...we may want to always build a 
+    //ServiceDescription based on a particular impl class
+    public static List<ServiceDescription> createServiceDescriptionFromDBCMap (
+    		HashMap<String, DescriptionBuilderComposite> dbcMap) {
 
+    	List<ServiceDescription> serviceDescriptionList = new ArrayList<ServiceDescription>();
+
+		
+    	for (Iterator<DescriptionBuilderComposite> nameIter = dbcMap.values().iterator(); 
+    		nameIter.hasNext();) {
+    		DescriptionBuilderComposite serviceImplComposite = nameIter.next();
+    		if(isImpl(serviceImplComposite)) {
+				// process this impl class
+        		String serviceImplName = serviceImplComposite.getClassName();
+                if (serviceImplComposite == null)
+                	throw ExceptionFactory.makeWebServiceException("ServiceDescription.constructor: Can not find DBC represents associated serviceImplName:  " + serviceImplName);
+        		
+        		ServiceDescription serviceDescription = new ServiceDescription(dbcMap, 
+        				serviceImplComposite);
+        	   	serviceDescriptionList.add(serviceDescription);
+    		}
+    	}
+    	
+    	//For each impl class and each SEI, build a ServiceDescription
+    	//TODO: Probably not the best way to process SEI's ...need to look at this
+    	/*
+    	HashMap<String, DescriptionBuilderComposite> seiMap = 
+    		sortedDBCList.getMap(DBCInputListSorter.seiMapKey);
+
+    	for (int i=1; i < sortedDBCList.getImplClassesList().size(); i++ ) {
+    		//process this sei class
+    		
+    		String seiName = sortedDBCList.getSeiClassesList().get(i);
+    		DescriptionBuilderComposite seiComposite = seiMap.get(seiName);
+            
+    		if (seiComposite == null)
+            	throw ExceptionFactory.makeWebServiceException("ServiceDescription.constructor: Can not find DBC represents associated serviceImplName:  " + serviceImplName);
+    		
+    		ServiceDescription serviceDescription = new ServiceDescription( sortedDBCList, seiComposite);
+    	   	serviceDescriptionList.add(serviceDescription);
+    	}
+    	*/  	
+    	
+    	return serviceDescriptionList;
+    }
+
     /**
      * Update an existing ServiceDescription with an annotated SEI
      * @param serviceDescription
@@ -59,4 +110,40 @@
         serviceDescription.updateEndpointDescription(sei, portQName, updateType);
         return serviceDescription;
     }
+    
+    /**
+     * Builds a list of DescriptionBuilderComposite which is relevant to the particular
+     * class
+     * @param List<> A list of DescriptionBuilderComposite objects
+     * @param serviceImplName 
+     * @return List<>
+     */ 
+	private static List<DescriptionBuilderComposite> BuildRelevantCompositeList(
+				List<DescriptionBuilderComposite> compositeList,
+				String serviceImplName) {
+		
+		List<DescriptionBuilderComposite> relevantList = compositeList;
+		
+		//TODO: Find the composite which represents this serviceImplName
+		
+		//TODO: Go through input list to find composites relevant to this one and add
+		//      to 'relevant list'
+		
+		return relevantList;
+	}
+	
+	/**
+	 * This method will be used to determine if a given DBC represents a
+	 * Web service implementation.
+	 * @param dbc - <code>DescriptionBuilderComposite</code>
+	 * @return - <code>boolean</code>
+	 */
+	private static boolean isImpl(DescriptionBuilderComposite dbc) {
+		if(!dbc.isInterface() && (dbc.getWebServiceAnnot() != null || 
+				dbc.getWebServiceProviderAnnot() != null)) {
+			return true;
+		}
+		return false;
+	}
+
 }
Index: C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/util/WSDL4JWrapper.java
===================================================================
--- C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/util/WSDL4JWrapper.java	(revision 463048)
+++ C:/wasx/axis2/modules/jaxws/src/org/apache/axis2/jaxws/util/WSDL4JWrapper.java	(working copy)
@@ -52,6 +52,13 @@
 		wsdlDefinition = reader.readWSDL(wsdlURL.toString());
 		
 	}
+
+    public WSDL4JWrapper(URL wsdlURL, Definition wsdlDefinition) throws WSDLException{
+		super();
+		this.wsdlURL = wsdlURL;
+		this.wsdlDefinition = wsdlDefinition;
+		
+	}
 	//TODO: Perform validations for each method to check for null parameters on QName.
 	
 	public Definition getDefinition(){
