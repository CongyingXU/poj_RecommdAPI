Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/nonwrap/META-INF/services.xml
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/nonwrap/META-INF/services.xml	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/nonwrap/META-INF/services.xml	(working copy)
@@ -4,9 +4,6 @@
    <messageReceiver mep="http://www.w3.org/2004/08/wsdl/in-out" class="org.apache.axis2.jaxws.server.JAXWSMessageReceiver"/>
   </messageReceivers>
   <parameter locked="false" name="ServiceClass">org.apache.axis2.jaxws.sample.nonwrap.DocLitNonWrapPortTypeImpl</parameter>
-  <operation name="invoke" mep="http://www.w3.org/2004/08/wsdl/in-out">
-    <actionMapping/>
-  </operation>
  </service>
 </serviceGroup>
 
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/AddNumbersTests.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/AddNumbersTests.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/AddNumbersTests.java	(working copy)
@@ -27,6 +27,7 @@
 			System.out.println("----------------------------------");
 		}catch(Exception e){
 			e.printStackTrace();
+			fail();
 		}
 	}
 }
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/NonWrapTests.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/NonWrapTests.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/NonWrapTests.java	(working copy)
@@ -5,11 +5,13 @@
 
 import java.util.concurrent.Future;
 
+import javax.xml.ws.Holder;
 import org.apache.axis2.jaxws.sample.nonwrap.sei.DocLitNonWrapPortType;
 import org.apache.axis2.jaxws.sample.nonwrap.sei.DocLitNonWrapService;
 import org.test.sample.nonwrap.ObjectFactory;
 import org.test.sample.nonwrap.ReturnType;
 import org.test.sample.nonwrap.TwoWay;
+import org.test.sample.nonwrap.TwoWayHolder;
 
 import junit.framework.TestCase;
 
@@ -42,6 +44,7 @@
 			System.out.println("------------------------------");
 		}catch(Exception e){
 			e.printStackTrace();
+			fail();
 		}
 	}
 	public void testTwoWayASyncCallback(){
@@ -58,6 +61,30 @@
 			System.out.println("------------------------------");
 		}catch(Exception e){
 			e.printStackTrace();
+			fail();
 		}
 	}
+	public void testTwoWayHolder(){
+		System.out.println("------------------------------");
+		System.out.println("Test : "+getName());
+		try{
+			TwoWayHolder twh = new TwoWayHolder();
+			twh.setTwoWayHolderInt(new Integer(0));
+			twh.setTwoWayHolderStr(new String("Request Holder String"));
+			Holder<TwoWayHolder> holder = new Holder<TwoWayHolder>(twh);
+			TwoWay twoWay = new ObjectFactory().createTwoWay();
+			twoWay.setTwowayStr("testing sync call for java bean non wrap endpoint");
+			DocLitNonWrapService service = new DocLitNonWrapService();
+			DocLitNonWrapPortType proxy = service.getDocLitNonWrapPort();
+			proxy.twoWayHolder(holder);
+			twh = holder.value;
+			System.out.println("Holder string ="+twh.getTwoWayHolderStr());
+			System.out.println("Holder int ="+twh.getTwoWayHolderInt());
+			
+			System.out.println("------------------------------");
+		}catch(Exception e){
+			e.printStackTrace();
+			fail();
+		}
+	}
 }
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/BareTests.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/BareTests.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/BareTests.java	(working copy)
@@ -30,6 +30,7 @@
 			System.out.println("------------------------------");
 		}catch(Exception e){
 			e.printStackTrace();
+			fail();
 		}
 	}
 }
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/WrapTests.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/WrapTests.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/WrapTests.java	(working copy)
@@ -3,6 +3,7 @@
  */
 package org.apache.axis2.jaxws.sample;
 
+import javax.xml.ws.Holder;
 import org.apache.axis2.jaxws.sample.wrap.sei.DocLitWrap;
 import org.apache.axis2.jaxws.sample.wrap.sei.DocLitWrapService;
 
@@ -42,6 +43,7 @@
 			System.out.println("------------------------------");
 		}catch(Exception e){
 			e.printStackTrace();
+			fail();
 		}
 	}
 	
@@ -57,7 +59,28 @@
 			System.out.println("------------------------------");
 		}catch(Exception e){
 			e.printStackTrace();
+			fail();
 		}
 	}
+	
+	public void testTwoWayHolder(){
+		System.out.println("------------------------------");
+		System.out.println("Test : "+getName());
+		try{
+			String holderString = new String("Test twoWay Sync");
+			Integer holderInteger = new Integer(0);
+			Holder<String> strHolder = new Holder<String>(holderString);
+			Holder<Integer> intHolder = new Holder<Integer>(holderInteger);
+			DocLitWrapService service = new DocLitWrapService();
+			DocLitWrap proxy = service.getDocLitWrapPort();
+			proxy.twoWayHolder(strHolder, intHolder);
+			System.out.println("Holder Response String =" + strHolder.value);;
+			System.out.println("Holder Response Integer ="+ intHolder.value);
+			System.out.println("------------------------------");
+		}catch(Exception e){
+			e.printStackTrace();
+			fail();
+		}
+	}
 
 }
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/description/AnnotationServiceImplDescriptionTests.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/description/AnnotationServiceImplDescriptionTests.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/description/AnnotationServiceImplDescriptionTests.java	(working copy)
@@ -133,8 +133,10 @@
         // Check the Java parameters, WebParam names, and WebResult (actually lack thereof) for each of these operations
         
         // Note regarding WebParam names:
-        // Unlike the Java paramaters, the WebParam names will remove the JAX-WS AsyncHandler
-        // parameter.  That is because it is NOT part of the contract, and thus it is NOT part of
+        //In the client Async Call the the WebParam name will not remove JAX-WS AsyncHandler.
+        //Proxy invoking the the Async Call will check the input method object and if
+        //its of type JAX-WS AsyncHandler then that WebParam will be skipped.
+        //This is done because AsyncHandler is NOT part of the contract, and thus it is NOT part of
         // the JAXB object constructed for the method invocation.  The AsyncHandler is part of the 
         // JAX-WS programming model to support an asynchronous callback to receive the response.
         
@@ -173,7 +175,7 @@
                     assertEquals(checkParams[0], "java.lang.String" );
                     assertEquals(checkParams[1], "javax.xml.ws.AsyncHandler");
                     // Check the WebParam Names (see note above) 
-                    assertEquals(1, webParamNames.length);
+                    assertEquals(2, webParamNames.length);
                     assertEquals("invoke_str", webParamNames[0]);
                     // Check the lack of a WebResult annotation
                     assertEquals(false, operation.isWebResultAnnotationSpecified());
@@ -210,7 +212,7 @@
                     assertEquals(checkParams[1], "int");
                     assertEquals(checkParams[2], "javax.xml.ws.AsyncHandler");
                     // Check the WebParam Names (see note above) 
-                    assertEquals(2, webParamNames.length);
+                    assertEquals(3, webParamNames.length);
                     assertEquals("twoWayHolder_str", webParamNames[0]);
                     assertEquals("twoWayHolder_int", webParamNames[1]);
                     // Check the lack of a WebResult annotation
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java	(working copy)
@@ -94,7 +94,6 @@
         suite.addTestSuite(NonWrapTests.class);
         suite.addTestSuite(WrapTests.class);
         suite.addTestSuite(AddNumbersTests.class);
-        suite.addTestSuite(BareTests.class);
         
         // Start (and stop) the server only once for all the tests
         TestSetup testSetup = new TestSetup(suite) {
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/i18n/resource.properties
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/i18n/resource.properties	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/i18n/resource.properties	(working copy)
@@ -60,6 +60,7 @@
 ICCreateOpClientErr1=Cannot create OperationClient.  ServiceClient is null.
 ICCreateOpClientErr2=Cannot create OperationClient.  Operation qname is null.
 proxyErr1=An attempt was made to invoke method {0}, but this method is not available on the javax.xml.ws.BindingProvider or {1} class.
+proxyErr2=@SOAPBinding annotation Style on SEI and @SOAPBinding annotation Style on Method should be same.
 JAXWSMessageReceiverNoServiceClass=No service class was found for this AxisService.
 EndpointControllerErr2=No Service class is configured for this endpoint.  Processing cannot continue.
 EndpointControllerErr4=Error loading the provider implementation class {0}.  Processing cannot continue.
@@ -91,6 +92,7 @@
 JAXBWrapperErr4=Internal Assertion Error. Number of child objects does not match the number of child names in wrap() method.
 JAXBWrapperErr5=Internal Assertion Error. Number of child names does not match the number of bean properties in JAXB class {0}.
 JAXBWrapperErr6=Internal Assertion Error. JAXB object {0} does not have a bean property named {1}.
+JAXBWrapperErr7=Internal Assertion Error. Method Parameters that holds child objects to create JAXBObject is null.
 JAXBSourceNamespaceErr=The DOMSource must be Namespace Aware.
 AttachmentsNotSupported=SAAJ Attachments are not supported yet.
 protoNotFound00=An associated Protocol was not found for the binding {0}.
@@ -100,4 +102,9 @@
 AsyncListenerErr1=AxisCallback Object cannot be null, Internal error.
 DocLitProxyHandlerErr1=As per WS-I compliance, Multi part WSDL not allowed for Doc/Lit NON Wrapped request, Method invoked has multiple input parameter.
 DocLitProxyHandlerErr2 = Method Input parameter for NON Wrapped Request cannot be null.
-SOAP12WithSAAJ12Err=A SOAP 1.2 Message cannot be rendered in an SAAJ 1.2 Object Model.
\ No newline at end of file
+DocLitProxyHandlerErr3=Method parameter type javax.xml.ws.AsyncHandler should only be used with Async Callback operations, method is Async if it returns a Future<?> and endswith letters 'Async'.
+DocLitProxyHandlerErr4=WebParam annotation's Mode cannot be IN for input parameter of type Holder.
+DocLitProxyHandlerErr5=Object Not a Holder type.
+JavaBeanDispatcherErr1=No Java method was found for the operation, if WSDL Operation Name is different from java Method name, make sure you have @WebMethod annotation name present.DocLitProxyHandlerErr2 = Method Input parameter for NON Wrapped Request cannot be null.
+SOAP12WithSAAJ12Err=A SOAP 1.2 Message cannot be rendered in an SAAJ 1.2 Object Model.
+SOAP12WithSAAJ12Err=A SOAP 1.2 Message cannot be rendered in an SAAJ 1.2 Object Model.
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperToolImpl.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperToolImpl.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/impl/JAXBWrapperToolImpl.java	(working copy)
@@ -37,6 +37,7 @@
 import javax.xml.namespace.QName;
 
 import org.apache.axis2.jaxws.i18n.Messages;
+import org.apache.axis2.jaxws.marshaller.MethodParameter;
 import org.apache.axis2.jaxws.wrapper.JAXBWrapperTool;
 
 
@@ -115,6 +116,22 @@
 		}
 	}
 	
+	public Object wrap(Class jaxbClass, String jaxbClassName, ArrayList<MethodParameter> mps) throws JAXBWrapperException{
+		if(mps == null){
+			throw new JAXBWrapperException(Messages.getMessage("JAXBWrapperErr7"));
+		}
+		ArrayList<String> nameList = new ArrayList<String>();
+		Map<String, Object> objectList = new WeakHashMap<String, Object>();
+		for(MethodParameter mp:mps){
+			String name = mp.getName();
+			Object object = mp.getValue();
+			
+			nameList.add(name);
+			objectList.put(name, object);
+		}
+		return wrap(jaxbClass, jaxbClassName, nameList, objectList);
+	}
+	
 	public JAXBElement wrapAsJAXBElement(Class jaxbClass, String jaxbClassName,
 			ArrayList<String> childNames, Map<String, Object> childObjects) throws JAXBWrapperException{
 		
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/JAXBWrapperTool.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/JAXBWrapperTool.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/wrapper/JAXBWrapperTool.java	(working copy)
@@ -23,6 +23,7 @@
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBElement;
 
+import org.apache.axis2.jaxws.marshaller.MethodParameter;
 import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
 
 
@@ -48,8 +49,17 @@
      * @return list of Objects in the same order as the element names.
      */ 
     public Object wrap(Class jaxbClass, String jaxbClassName, ArrayList<String> childNames, Map<String, Object> childObjects) throws JAXBWrapperException;
-    
     /**
+     * wrap
+     * Creates a jaxb object that is initialized with the child objects
+     * @param jaxbClass
+     * @param jaxbClassName
+     * @param methodParameters
+     * @return
+     * @throws JAXBWrapperException
+     */
+    public Object wrap(Class jaxbClass, String jaxbClassName, ArrayList<MethodParameter> methodParameters) throws JAXBWrapperException;
+    /**
      * wrapAsJAXBElement
      * Creates a JAXBElement that is initialized with the child objects and can be serialsed to xml later.
      * @param javabClass Class of the JAXB object to return
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/description/OperationDescription.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/description/OperationDescription.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/description/OperationDescription.java	(working copy)
@@ -26,6 +26,7 @@
 import javax.jws.WebMethod;
 import javax.jws.WebParam;
 import javax.jws.WebResult;
+import javax.jws.WebParam.Mode;
 import javax.jws.soap.SOAPBinding;
 import javax.xml.namespace.QName;
 import javax.xml.ws.RequestWrapper;
@@ -138,6 +139,7 @@
     // TODO: Should WebParam annotation be moved to the ParameterDescription?
     private WebParam[]          webParamAnnotations;
     private String[]            webParamNames;
+    private Mode[]				webParamMode;
     private String[]            webParamTNS;
 
     
@@ -439,14 +441,7 @@
             ArrayList<String> buildNames = new ArrayList<String>();
             WebParam[] webParams = getWebParam();
             for (WebParam currentParam:webParams) {
-                // TODO: Is skipping param names of "asyncHandler" correct?  This came from original ProxyDescription class and ProxyTest fails without this code
-                //       Due to code in DocLitProxyHandler.getParamValues() which does not add values for AsyncHandler objects.
-                //       It probably DOES need to be skipped, albeit more robustly (check that the type of the param is javax.xml.ws.AsyncHandler also)
-                //       The reason is that the handler is part of the JAX-WS async callback programming model; it is NOT part of the formal params
-                //       to the actual method and therefore is NOT part of the JAXB request wrapper
-                if(!currentParam.name().equals("asyncHandler")){
                     buildNames.add(currentParam.name());
-                }
             }
             webParamNames = buildNames.toArray(new String[0]);
         }
@@ -459,20 +454,24 @@
             ArrayList<String> buildNames = new ArrayList<String>();
             WebParam[] webParams = getWebParam();
             for (WebParam currentParam:webParams) {
-                // TODO: Is skipping param names of "asyncHandler" correct?  This came from original ProxyDescription class and ProxyTest fails without this code
-                //       Due to code in DocLitProxyHandler.getParamValues() which does not add values for AsyncHandler objects.
-                //       It probably DOES need to be skipped, albeit more robustly (check that the type of the param is javax.xml.ws.AsyncHandler also)
-                //       The reason is that the handler is part of the JAX-WS async callback programming model; it is NOT part of the formal params
-                //       to the actual method and therefore is NOT part of the JAXB request wrapper
-                if(!currentParam.name().equals("asyncHandler")){
-                    buildNames.add(currentParam.targetNamespace());
-                }
+            	buildNames.add(currentParam.targetNamespace());
             }
             webParamTNS = buildNames.toArray(new String[0]);
         }
         return webParamTNS;
     }
              
+    public Mode[] getWebParamModes(){
+    	if(webParamMode == null){
+    		ArrayList<Mode> buildModes = new ArrayList<Mode>();
+    		WebParam[] webParams = getWebParam();
+    		for (WebParam currentParam:webParams){
+                buildModes.add(currentParam.mode());
+    		}
+    		 webParamMode = buildModes.toArray(new Mode[0]);
+    	}
+    	return webParamMode;
+    }
     public String getWebParamTNS(String name){
        WebParam[] webParams = getWebParam();
        for (WebParam currentParam:webParams){
@@ -584,4 +583,13 @@
         }
         return onewayIsOneway.booleanValue();   
     }
+    
+    public boolean isWebMethodExcluded(){
+		WebMethod webMethod = getWebMethod();
+		if(webMethod == null){
+			return false;
+		}
+		
+		return webMethod.exclude();
+	}
 }
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/MethodParameter.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/MethodParameter.java	(revision 0)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/MethodParameter.java	(revision 0)
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.marshaller;
+
+import javax.jws.WebParam.Mode;
+
+
+/**
+ * Stores Method Parameter as Name and Value. Method Parameter can be an input Method Parameter or output Method parameter.
+ * input Method Parameter is a input to a java Method.
+ * output Method Parameter is a return parameter from a java Method.
+ */
+public class MethodParameter {
+	
+	private String name = null;
+	private Object value = null;
+	private Mode mode = null;
+	private Class type = null;
+	private Class actualType = null; //If parameter is a GenericType, this property stores the actual Type
+	private boolean isHolder = false;
+	
+	public MethodParameter(String name, Object value, Mode mode) {
+		super();
+		this.name = name;
+		this.value = value;
+		this.mode = mode;
+	}
+	public MethodParameter(String name, Object value, Mode mode, Class type, Class actualType, boolean isHolder) {
+		this(name,value,mode);
+		this.type = type;
+		this.isHolder = isHolder;
+		this.actualType = actualType;
+	}
+	public String getName() {
+		return name;
+	}
+	public Object getValue() {
+		return value;
+	}
+	public Mode getMode() {
+		return mode;
+	}
+	public Class getType() {
+		return type;
+	}
+	public void setType(Class type) {
+		this.type = type;
+	}
+	public Class getActualType() {
+		return this.actualType;
+	}
+	public void setActualType(Class actualType) {
+		this.actualType = actualType;
+	}
+	public boolean isHolder() {
+		return isHolder;
+	}
+	public void setHolder(boolean isHolder) {
+		this.isHolder = isHolder;
+	}
+}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/DocLitBareMethodMarshaller.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/DocLitBareMethodMarshaller.java	(revision 0)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/DocLitBareMethodMarshaller.java	(revision 0)
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.marshaller;
+
+public interface DocLitBareMethodMarshaller extends MethodMarshaller {
+
+}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/MethodMarshaller.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/MethodMarshaller.java	(revision 0)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/MethodMarshaller.java	(revision 0)
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.marshaller;
+
+import javax.xml.bind.JAXBException;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.MessageException;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
+/*
+ * This is a helper class that converts org.apache.axis2.jaxws.message.Message to java Objects
+ * or JAXBObject. It also converts java objects or JAXBObject to org.apache.axis2.jaxws.message.Message.
+ */
+
+public interface MethodMarshaller {
+	
+	/**
+	 * This method converts java Objects in to a Message. Used on Client side to convert input method object to Message that is sent on wire.
+	 * 
+	 * NONWRAP CASE:
+	 * creates a request message. The input object to a non wrapped wsdl will be a object (mainly a JAXB Object) that will
+	 * have all the payload data or method parameter data already setup. So the message will be created by converting input object in to a JAXBBlock and
+	 * attaching the Block Message to soap body.
+	 * 
+	 * WRAP CASE:
+	 * 
+	 * create request message. It reads RequestWrapper annotation from OperationDescription and reads the class name, then reads
+	 * all the webParam annotation on the method and uses JAXBWrapTool to wrap the request as jaxbObject. Create JAXBblock from the jaxbObject
+	 * reads Biniding provider properties and set them on request message and return request message.
+	 * @param object
+	 * @return
+	 */
+	public Message marshalRequest(Object[] object) throws IllegalAccessException, InstantiationException, ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, javax.xml.stream.XMLStreamException;
+	
+	/**
+	 * This method creates Message from a returnObject and input parameters of holder type. This is a case where we have method with return
+	 * type and input parameters as holders. Used on Server side to convert service methods return type to Message that is then sent on wire.
+	 * @param jaxbObject
+	 * @return
+	 */
+	public Message marshalResponse(Object returnObject, Object[] holderObjects)throws ClassNotFoundException, JAXBException, MessageException, JAXBWrapperException, XMLStreamException, InstantiationException, IllegalAccessException;
+	
+	/**
+	 * This method creates Fault Message from a Throbale input parameter. 
+	 * Used on Server side to convert Exceptions to Fault Message that is then sent on wire.
+	 * @param jaxbObject
+	 * @return
+	 */
+	public Message marshalFaultResponse(Throwable throwable);
+	/**
+	 * This method converts Message to java objects. Used on Server Side to this extract method input parameters from message and invokes method on service
+	 * with found input parameters on ServiceEndpoint.
+	 * @param message
+	 * @return
+	 */
+	public Object[] demarshalRequest(Message message)throws ClassNotFoundException, JAXBException, MessageException, JAXBWrapperException, XMLStreamException, InstantiationException, IllegalAccessException;
+	
+	/**
+	 * This method converts Message to Object. Used on Client side when converting response message from Server to ResponseWrapper/return type of method that
+	 * Client uses to map.
+	 * 
+	 * NONWRAP CASE:
+	 * creates return result that client expects from the method call. This method reads the method return type
+	 * or uses webResult annotation and creates JAXBBlock from the response context and returns the business object associated with the JAXBBlock.
+	 * 
+	 * WRAP CASE:
+	 * creates return result that client expects from the method call. It reads response wrapper annotation then reads OM from the
+	 * response message context and creates JAXBBlock from the OMElement on messageContext. It then reads the webresult annotation to gather the return parameter
+	 * name and creates the result object for it by reading the property object from JAXBBlock's business object using PropertyDescriptor. 
+	 * 
+	 * @param message
+	 * @return
+	 */
+	public Object demarshalResponse(Message message, Object[] inputArgs) throws IllegalAccessException, InstantiationException, ClassNotFoundException, JAXBWrapperException, JAXBException, XMLStreamException, MessageException;
+	/**
+	 * This method converts Fault Message to fault java objects. Used on Client Side to extract Fault Object expected by client from message.
+	 * @param message
+	 * @return
+	 */
+	public Object demarshalFaultResponse(Message message);
+	
+	/**
+	 * Indicates if message contains fault.
+	 * @param message
+	 * @return
+	 */
+	public boolean isFault(Message message);
+	
+	
+}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/DocLitWrappedMethodMarshaller.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/DocLitWrappedMethodMarshaller.java	(revision 0)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/DocLitWrappedMethodMarshaller.java	(revision 0)
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.marshaller;
+
+public interface DocLitWrappedMethodMarshaller extends MethodMarshaller {
+
+}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/spi/ServiceDelegate.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/spi/ServiceDelegate.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/spi/ServiceDelegate.java	(working copy)
@@ -41,10 +41,7 @@
 import org.apache.axis2.jaxws.JAXWSClientContext;
 import org.apache.axis2.jaxws.client.JAXBDispatch;
 import org.apache.axis2.jaxws.client.XMLDispatch;
-import org.apache.axis2.jaxws.client.factory.DescriptorFactory;
-import org.apache.axis2.jaxws.client.factory.ProxyHandlerFactory;
-import org.apache.axis2.jaxws.client.proxy.BaseProxyHandler;
-import org.apache.axis2.jaxws.client.proxy.ProxyDescriptor;
+import org.apache.axis2.jaxws.client.proxy.JAXWSProxyHandler;
 import org.apache.axis2.jaxws.description.DescriptionFactory;
 import org.apache.axis2.jaxws.description.ServiceDescription;
 import org.apache.axis2.jaxws.handler.PortData;
@@ -259,15 +256,10 @@
                 addPortData(portName, null, address);
     		}
     	}
-    	DescriptorFactory df = (DescriptorFactory)FactoryRegistry.getFactory(DescriptorFactory.class);
-    	ProxyDescriptor pd = df.create(sei, serviceDescription);
-    	pd.setPort(ports.get(portName));
-    	ProxyHandlerFactory phf =(ProxyHandlerFactory) FactoryRegistry.getFactory(ProxyHandlerFactory.class);
-    	BaseProxyHandler proxyHandler = phf.create(pd, this);
+    	JAXWSProxyHandler proxyHandler = new JAXWSProxyHandler(this, sei, ports.get(portName));
     	
     	Class[] seiClazz = new Class[]{sei, BindingProvider.class};
     	Object proxyClass = Proxy.newProxyInstance(sei.getClassLoader(), seiClazz, proxyHandler);
-    	
     	return sei.cast(proxyClass);
     }
     
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/server/dispatcher/Mapper.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/server/dispatcher/Mapper.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/server/dispatcher/Mapper.java	(working copy)
@@ -1,85 +0,0 @@
-/*
- * Copyright 2006 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws.server.dispatcher;
-
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Map;
-
-import javax.xml.bind.JAXBException;
-import javax.xml.stream.XMLStreamException;
-
-import org.apache.axis2.jaxws.core.MessageContext;
-import org.apache.axis2.jaxws.message.Block;
-import org.apache.axis2.jaxws.message.MessageException;
-import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
-/*
- * This class is used to map xml/annotation data with java. We use mapper to retrive various java art effects by looking in Service and SEI annotations.
- * If no annotation are specified we derive defaults.
- */
-
-public interface Mapper {
-	
-	/**
-	 * Looks at the SOAPBinding annotation figures out if the request is BARE or Wrapped and accordingly returns Parameter objects for the java method.
-	 * @param mc
-	 * @param javaMethod
-	 * @return
-	 */
-	public Object[] getInputParameterData(MessageContext mc, Method javaMethod) throws JAXBException, MessageException, XMLStreamException, JAXBWrapperException;
-	
-	/**
-	 * Creates output message block that can be serialized as response from server.
-	 * @param mc
-	 * @param response
-	 * @return
-	 */
-	public Block getOutputParameterBlock(MessageContext mc, Object response, Method method)throws JAXBException, ClassNotFoundException, JAXBWrapperException, MessageException;
-	
-	/**
-	 * Reads java method from Message context operationName. 
-     * Find the Java method that corresponds to the WSDL operation that was 
-     * targeted by the Axis2 Dispatchers.
-     * @param mc
-	 * @return
-	 */
-	public Method getJavaMethod(MessageContext mc, Class serviceImplClass);
-	
-	/**
-	 * @param javaMethod
-	 * @param args
-	 * @return
-	 * creates a message context given a java method and input arguments.
-	 */
-	public MessageContext getMessageContext(Method javaMethod, Object[] args);
-	
-	/**
-	 * Reads input parameter names for java method.
-	 * @param method
-	 * @param objects
-	 * @return
-	 */
-	public ArrayList<String> getParamNames(Method method, Object[] objects);
-	
-	/**
-	 * creates name value pair for input parameters, skips AsyncHandler object from input parameter. 
-	 * @param objects
-	 * @param names
-	 * @return
-	 */
-	public Map<String, Object> getParamValues(Object[] objects, ArrayList<String> names);
-}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/server/dispatcher/MapperImpl.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/server/dispatcher/MapperImpl.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/server/dispatcher/MapperImpl.java	(working copy)
@@ -1,377 +0,0 @@
-/*
- * Copyright 2006 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws.server.dispatcher;
-
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayInputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.Reader;
-import java.lang.reflect.Method;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.Future;
-
-import javax.jws.soap.SOAPBinding;
-import javax.xml.bind.JAXBContext;
-import javax.xml.bind.JAXBElement;
-import javax.xml.bind.JAXBException;
-import javax.xml.bind.JAXBIntrospector;
-import javax.xml.bind.Unmarshaller;
-import javax.xml.bind.JAXBElement.GlobalScope;
-import javax.xml.bind.annotation.XmlRootElement;
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.ws.AsyncHandler;
-import javax.xml.ws.Response;
-
-import org.apache.axiom.om.OMElement;
-import org.apache.axis2.jaxws.ExceptionFactory;
-import org.apache.axis2.jaxws.core.MessageContext;
-import org.apache.axis2.jaxws.description.EndpointDescription;
-import org.apache.axis2.jaxws.description.EndpointInterfaceDescription;
-import org.apache.axis2.jaxws.description.OperationDescription;
-import org.apache.axis2.jaxws.description.ServiceDescription;
-import org.apache.axis2.jaxws.message.Block;
-import org.apache.axis2.jaxws.message.Message;
-import org.apache.axis2.jaxws.message.MessageException;
-import org.apache.axis2.jaxws.message.factory.BlockFactory;
-import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
-import org.apache.axis2.jaxws.registry.FactoryRegistry;
-import org.apache.axis2.jaxws.wrapper.JAXBWrapperTool;
-import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
-import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperToolImpl;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-public class MapperImpl implements Mapper {
-	private static int SIZE = 1;
-	private static String DEFAULT_NAME="arg";
-	private static final Log log = LogFactory.getLog(MapperImpl.class);
-	public MapperImpl() {
-		super();
-		// TODO Auto-generated constructor stub
-	}
-
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.jaxws.server.dispatcher.Mapper#getParameterData(org.apache.axis2.jaxws.core.MessageContext, java.lang.reflect.Method)
-	 */
-	public Object[] getInputParameterData(MessageContext mc, Method javaMethod) throws JAXBException, MessageException, XMLStreamException, JAXBWrapperException {
-		
-		Message msg = mc.getMessage();
-		EndpointDescription ed = getEndpointDescription(mc);
-		Class[] paramTypes = javaMethod.getParameterTypes();
-		OperationDescription opDesc = mc.getOperationDescription();
-		String paramName[] = opDesc.getWebParamNames();
-		if(paramTypes == null){
-			//Method has no input parameters.
-			return null;
-		}
-		if(paramTypes.length == 0){
-			return null;
-		}
-		if(isSEIDocLitBare(ed)){
-			//Create the jaxbcontext for input parameter, for non wrap case there should be only one input param which is the Request Wrapper
-			if(paramTypes !=null && paramTypes.length >SIZE){
-				if (log.isDebugEnabled()) {
-		            log.debug("As per WS-I compliance, Multi part WSDL not allowed for Doc/Lit NON Wrapped request, Method invoked has multiple input parameter");
-		        }
-				throw ExceptionFactory.makeWebServiceException("As per WS-I compliance, Multi part WSDL not allowed for Doc/Lit NON Wrapped request, Method invoked has multiple input parameter");
-			}
-			if(paramTypes !=null){
-				Class paramType = paramTypes[0];
-				
-				JAXBContext ctx = JAXBContext.newInstance(new Class[]{paramType});
-				
-				BlockFactory factory = (BlockFactory) FactoryRegistry.getFactory(JAXBBlockFactory.class);
-				try{
-				
-					Block block = msg.getBodyBlock(0, ctx,factory);
-					return new Object[]{block.getBusinessObject(true)};
-					
-				}catch(Exception e){
-					//FIXME: this is the bare case where child of body is not a method but a primitive data type. Reader from Block is throwing exception.
-					Block block = msg.getBodyBlock(0, ctx,factory);
-					OMElement om = block.getOMElement();
-					
-					XMLInputFactory xmlFactory = XMLInputFactory.newInstance();
-					
-					Unmarshaller u = ctx.createUnmarshaller();
-					Reader inputReader = new InputStreamReader(new ByteArrayInputStream(om.toString().getBytes()));
-					XMLStreamReader sr = xmlFactory.createXMLStreamReader(inputReader);
-					JAXBElement o =u.unmarshal(sr, paramTypes[0]);
-					return new Object[]{o.getValue()};
-				}
-				
-				
-				//Object obj = block.getBusinessObject(true);
-				//return new Object[]{obj};
-			}
-		}
-		
-		if(isSEIDocLitWrapped(ed)){
-			
-            String requestWrapperClassName = opDesc.getRequestWrapperClassName();
-            JAXBContext jbc = createJAXBContext(requestWrapperClassName);
-            BlockFactory factory = (BlockFactory) FactoryRegistry.getFactory(JAXBBlockFactory.class);
-        
-            Block wrapper = msg.getBodyBlock(0, jbc, factory);
-            
-            JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
-            
-            String[] webParamNames = opDesc.getWebParamNames();
-            ArrayList<String> elements = new ArrayList<String>(Arrays.asList(webParamNames));
-
-            Object param = wrapper.getBusinessObject(true);
-            Object[] contents = wrapperTool.unWrap(param, elements);
-            return contents;
-		}
-		return null;
-	}
-	
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.jaxws.server.dispatcher.Mapper#getOutputParameterBlock(org.apache.axis2.jaxws.core.MessageContext, java.lang.Object)
-	 */
-	public Block getOutputParameterBlock(MessageContext mc, Object response, Method method) throws JAXBException, ClassNotFoundException, JAXBWrapperException, MessageException{
-		EndpointDescription ed = getEndpointDescription(mc);
-		OperationDescription opDesc = getOperationDescription(mc);
-		Class returnType = getReturnType(method);
-		if(isSEIDocLitBare(ed)){
-			if(returnType.isAssignableFrom(response.getClass())){
-				
-				BlockFactory bfactory = (BlockFactory) FactoryRegistry.getFactory(
-						JAXBBlockFactory.class);
-				JAXBContext ctx = JAXBContext.newInstance(new Class[]{returnType});
-				if(!isXmlRootElementDefined(returnType)){
-					String returnTypeName = opDesc.getWebResultName();
-					return createJAXBBlock(returnTypeName,response,ctx);
-				}
-				else{
-					return createJAXBBlock(response, ctx);
-					
-				}
-			}
-			else{
-				String webResult = opDesc.getWebResultName();
-				JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
-				ArrayList<String> elements = new ArrayList<String>(Arrays.asList(webResult));
-				
-	            Object[] contents = wrapperTool.unWrap(response, elements);
-	            for(Object obj:contents){
-	            	if(returnType.getClass().isAssignableFrom(obj.getClass())){
-	            		BlockFactory bfactory = (BlockFactory) FactoryRegistry.getFactory(
-	    						JAXBBlockFactory.class);
-	    				JAXBContext ctx = JAXBContext.newInstance(new Class[]{returnType});
-	    				Block block = bfactory.createFrom(response, ctx, null);
-	    				return block;
-	            	}
-	            }
-			}
-			
-			
-		}
-		if(isSEIDocLitWrapped(ed)){
-			
-	            //We'll need a JAXBContext to marshall the response object(s).
-				String responseWrapperClazzName = opDesc.getResponseWrapperClassName();
-	            JAXBContext jbc = createJAXBContext(responseWrapperClazzName);
-	            BlockFactory bfactory = (BlockFactory) FactoryRegistry.getFactory(
-	                    JAXBBlockFactory.class);
-	            
-	            String responseWrapper = opDesc.getResponseWrapperClassName();
-	            Class responseWrapperClass = null;
-	           
-	            responseWrapperClass = Class.forName(responseWrapper, false, Thread.currentThread().getContextClassLoader());
-	            
-	            JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
-
-	            String webResult = opDesc.getWebResultName();
-	            ArrayList<String> responseParams = new ArrayList<String>();
-	            responseParams.add(webResult);
-	 
-	            ArrayList<String> elements = new ArrayList<String>();
-	            elements.add(webResult);
-	            
-	            Map<String, Object> responseParamValues = new HashMap<String, Object>();
-	            responseParamValues.put(webResult, response);
-	            
-	            Object wrapper = wrapperTool.wrap(responseWrapperClass, 
-	                    responseWrapper, responseParams, responseParamValues);
-	            
-	            Block block = bfactory.createFrom(wrapper ,jbc, null);
-	            return block;
-	        
-		}
-		
-		return null;
-	}
-
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.jaxws.server.dispatcher.Mapper#getJavaMethod(org.apache.axis2.jaxws.core.MessageContext)
-	 */
-	public Method getJavaMethod(MessageContext mc, Class serviceImplClass) {
-		 QName opName = mc.getOperationName();
-		 
-	        if (opName == null)
-	            // TODO: NLS
-	            throw ExceptionFactory.makeWebServiceException("Operation name was not set");
-	        
-	        String localPart = opName.getLocalPart();
-	        Method[] methods = serviceImplClass.getMethods();
-	        for (int i = 0; i < methods.length; ++i) {
-	            if (localPart.equals(methods[i].getName()))
-	                return methods[i];
-	        }
-	        
-	        if (log.isDebugEnabled()) {
-	            log.debug("No Java method found for the operation");
-	        }
-	        // TODO: NLS
-	        throw ExceptionFactory.makeWebServiceException("No Java method was found for the operation");
-	}
-
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.jaxws.server.dispatcher.Mapper#getMessageContext(java.lang.reflect.Method, java.lang.Object[])
-	 */
-	public MessageContext getMessageContext(Method javaMethod, Object[] args) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.jaxws.server.dispatcher.Mapper#getParamNames(java.lang.reflect.Method, java.lang.Object[])
-	 */
-	public ArrayList<String> getParamNames(Method method, Object[] objects){
-		return null;
-	}
-	
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.jaxws.server.dispatcher.Mapper#getParamValues(java.lang.Object[], java.util.ArrayList)
-	 */
-	public Map<String, Object> getParamValues(Object[] objects, ArrayList<String> names){
-		return null;
-	}
-	
-	private EndpointDescription getEndpointDescription(MessageContext mc){
-  	  ServiceDescription sd = mc.getServiceDescription();
-        EndpointDescription[] eds = sd.getEndpointDescriptions();
-        return eds[0];
-  }
-  
-  private boolean isSEIDocLitBare(EndpointDescription ed){
-		SOAPBinding.ParameterStyle style = ed.getEndpointInterfaceDescription().getSoapBindingParameterStyle();
-		return style == SOAPBinding.ParameterStyle.BARE;
-	}
-	
-	private  boolean isSEIDocLitWrapped(EndpointDescription ed){
-		SOAPBinding.ParameterStyle style = ed.getEndpointInterfaceDescription().getSoapBindingParameterStyle();
-		return style == SOAPBinding.ParameterStyle.WRAPPED;
-	} 
-	
-	private JAXBContext createJAXBContext(String wrapperClassName) {
-        // This will only support Doc/Lit Wrapped params for now.
-        try {
-            
-            if (wrapperClassName != null) {
-            	Class WrapperClazz = Class.forName(wrapperClassName, true, Thread.currentThread().getContextClassLoader());
-                JAXBContext jbc = JAXBContext.newInstance(new Class[]{WrapperClazz});
-                return jbc;
-            }
-            else {
-                throw ExceptionFactory.makeWebServiceException("");
-            }
-        } catch (JAXBException e) {
-            throw ExceptionFactory.makeWebServiceException(e);
-        }catch(ClassNotFoundException e){
-        	throw ExceptionFactory.makeWebServiceException(e);
-        }
-    }
-	
-	private OperationDescription getOperationDescription(MessageContext mc) {
-        ServiceDescription sd = mc.getServiceDescription();
-        EndpointDescription[] eds = sd.getEndpointDescriptions();
-        EndpointDescription ed = eds[0];
-        EndpointInterfaceDescription eid = ed.getEndpointInterfaceDescription();
-        
-        OperationDescription[] ops = eid.getOperation(mc.getOperationName());
-        OperationDescription op = ops[0];
-        
-        if (log.isDebugEnabled()) {
-            log.debug("wsdl operation: " + op.getName());
-            log.debug("   java method: " + op.getJavaMethodName());
-        }
-        
-        return op;        
-    }
-	
-	private Class getReturnType(Method seiMethod){
-		Class returnType = seiMethod.getReturnType();
-		//pooling implementation
-		if(Response.class.isAssignableFrom(returnType)){
-			Type type = seiMethod.getGenericReturnType();
-			ParameterizedType pType = (ParameterizedType) type;
-			return (Class)pType.getActualTypeArguments()[0];	
-		}
-		//Callback Implementation
-		if(Future.class.isAssignableFrom(returnType)){
-			Type[] type = seiMethod.getGenericParameterTypes();
-			Class parameters[]= seiMethod.getParameterTypes();
-			int i=0;
-			for(Class param:parameters){
-				if(AsyncHandler.class.isAssignableFrom(param)){
-					ParameterizedType pType = (ParameterizedType)type[i];
-					return (Class)pType.getActualTypeArguments()[0];
-				}
-				i++;
-			}
-		}
-			
-		
-		
-		return returnType;	
-	}
-	private Block createJAXBBlock(String name, Object jaxbObject, JAXBContext context) throws MessageException{
-		
-		JAXBIntrospector introspector = context.createJAXBIntrospector();
-		if(introspector.isElement(jaxbObject)){
-			return createJAXBBlock(jaxbObject, context);
-		}
-		else{
-			//Create JAXBElement then use that to create JAXBBlock.
-			Class clazz = jaxbObject.getClass();
-			JAXBElement<Object> element = new JAXBElement<Object>(new QName(name), clazz, jaxbObject);
-			JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
-			return factory.createFrom(element,context ,null);
-		}
-		
-	}
-	
-	protected Block createJAXBBlock(Object jaxbObject, JAXBContext context) throws MessageException{
-		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
-		return factory.createFrom(jaxbObject,context,null);
-		
-	}
-	private boolean isXmlRootElementDefined(Class jaxbClass){
-		XmlRootElement root = (XmlRootElement) jaxbClass.getAnnotation(XmlRootElement.class);
-		return root !=null;
-	}
-}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/server/dispatcher/JavaBeanDispatcher.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/server/dispatcher/JavaBeanDispatcher.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/server/dispatcher/JavaBeanDispatcher.java	(working copy)
@@ -18,18 +18,23 @@
 
 import java.lang.reflect.Method;
 
+import javax.jws.soap.SOAPBinding.ParameterStyle;
+import javax.xml.namespace.QName;
 import javax.xml.ws.Holder;
 import javax.xml.ws.soap.SOAPBinding;
 
+import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.core.MessageContext;
 import org.apache.axis2.jaxws.core.util.MessageContextUtils;
 import org.apache.axis2.jaxws.description.EndpointDescription;
 import org.apache.axis2.jaxws.description.EndpointInterfaceDescription;
 import org.apache.axis2.jaxws.description.OperationDescription;
 import org.apache.axis2.jaxws.description.ServiceDescription;
-import org.apache.axis2.jaxws.message.Block;
+import org.apache.axis2.jaxws.i18n.Messages;
+import org.apache.axis2.jaxws.marshaller.MethodMarshaller;
+import org.apache.axis2.jaxws.marshaller.factory.MethodMarshallerFactory;
 import org.apache.axis2.jaxws.message.Message;
-import org.apache.axis2.jaxws.message.factory.MessageFactory;
+import org.apache.axis2.jaxws.message.Protocol;
 import org.apache.axis2.jaxws.registry.FactoryRegistry;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -42,7 +47,10 @@
 public class JavaBeanDispatcher extends JavaDispatcher {
 
     private static final Log log = LogFactory.getLog(JavaBeanDispatcher.class);
-    
+    private ServiceDescription serviceDesc = null;
+    private EndpointDescription endpointDesc = null;
+    private OperationDescription operationDesc = null;
+    private MethodMarshaller methodMarshaller = null;
     private Object serviceInstance;
     
     public JavaBeanDispatcher(Class implClass) {
@@ -58,50 +66,36 @@
             log.debug("Preparing to invoke service endpoint implementation " +
                     "class: " + serviceImplClass.getName());
         }
+        
+        initialize(mc);
+        methodMarshaller = createMethodMarshaller(mc.getMessage().getProtocol());
+        Object[] methodInputParams = methodMarshaller.demarshalRequest(mc.getMessage());
+        Method target = getJavaMethod(mc, serviceImplClass);
 
-        mc.setOperationName(mc.getAxisMessageContext().getAxisOperation().getName());
-        OperationDescription opDesc = getOperationDescription(mc);
-        mc.setOperationDescription(opDesc);
-        
-        Mapper mapper = new MapperImpl();
-        Method target = mapper.getJavaMethod(mc, serviceImplClass);
-        Object[] params = mapper.getInputParameterData(mc, target);
-        if(params!=null){
-        	for(Object param:params){
-        		if(param!=null && param instanceof Holder){
-        			throw new UnsupportedOperationException("Holders not supported yet");
-        		}
-        	}
-        }
         //At this point, we have the method that is going to be invoked and
         //the parameter data to invoke it with, so create an instance and 
         //do the invoke.
         serviceInstance = createServiceInstance();
-        Object response = target.invoke(serviceInstance, params);
+        //Passing method input params to grab holder values, if any.
+        Object response = target.invoke(serviceInstance, methodInputParams);
         
-        if(opDesc.isOneWay()){
-        	//Dont return response message context if its a one way operation.
-        	return null;
+        Message message = null;
+        //No need to create Response Messagecontext if its a one way call.
+        if(operationDesc.isOneWay()){
+        	message = null;
         }
-        
-        //TODO:Support Holders 
-        if(!opDesc.isOneWay() && target.getReturnType().getName().equals("void")){
-        	//process everything that does not have holders two way with void is empty responsewrapper in soap body
-        	
+        else if(target.getReturnType().getName().equals("void")){
+        	message = methodMarshaller.marshalResponse(null, methodInputParams);
         }
-        Block responseBlock = mapper.getOutputParameterBlock(mc, response, target);
-       
-        //Create the Message for the response
-        MessageFactory factory = (MessageFactory) FactoryRegistry.getFactory(
-                MessageFactory.class);
-        Message message = factory.create(mc.getMessage().getProtocol());
-        message.setBodyBlock(0, responseBlock);
+        else{
+        	message = methodMarshaller.marshalResponse(response, methodInputParams);
+        }
         
         MessageContext responseMsgCtx = MessageContextUtils.createMessageMessageContext(mc);
         responseMsgCtx.setMessage(message);
         
         //Enable MTOM if necessary
-        EndpointInterfaceDescription epInterfaceDesc = opDesc.getEndpointInterfaceDescription();
+        EndpointInterfaceDescription epInterfaceDesc = operationDesc.getEndpointInterfaceDescription();
         EndpointDescription epDesc = epInterfaceDesc.getEndpointDescription();
         
         String bindingType = epDesc.getBindingTypeValue();
@@ -115,6 +109,14 @@
         return responseMsgCtx;
     }
     
+    private void initialize(MessageContext mc){
+    	mc.setOperationName(mc.getAxisMessageContext().getAxisOperation().getName());
+    	serviceDesc = getServiceDescription(mc);
+        endpointDesc = getEndpointDescription(mc);
+        operationDesc = getOperationDescription(mc);
+        mc.setOperationDescription(operationDesc);
+        methodMarshaller = null;
+    }
     /*
      * Gets the OperationDescription associated with the request that is currently
      * being processed.
@@ -124,12 +126,25 @@
      */
 
     private OperationDescription getOperationDescription(MessageContext mc) {
+    	
         ServiceDescription sd = mc.getServiceDescription();
         EndpointDescription[] eds = sd.getEndpointDescriptions();
         EndpointDescription ed = eds[0];
         EndpointInterfaceDescription eid = ed.getEndpointInterfaceDescription();
         
         OperationDescription[] ops = eid.getOperation(mc.getOperationName());
+        String methodName = mc.getOperationName().getLocalPart();
+        for(OperationDescription op:ops){
+        	Method method = op.getSEIMethod();
+        	if(method.getName().equals(methodName)){
+        		if (log.isDebugEnabled()) {
+                    log.debug("wsdl operation: " + op.getName());
+                    log.debug("   java method: " + op.getJavaMethodName());
+                }
+        		return op;
+        	}
+        			
+        }
         OperationDescription op = ops[0];
         
         if (log.isDebugEnabled()) {
@@ -138,7 +153,105 @@
         }
         
         return op;        
+        
     }
     
+    private ServiceDescription getServiceDescription(MessageContext mc){
+    	return mc.getServiceDescription();
+    }
     
+    private EndpointDescription getEndpointDescription(MessageContext mc){
+    	ServiceDescription sd = mc.getServiceDescription();
+    	EndpointDescription[] eds = sd.getEndpointDescriptions();
+        EndpointDescription ed = eds[0];
+        return ed;
+    }
+    
+    private MethodMarshaller createMethodMarshaller(Protocol protocol){
+    	javax.jws.soap.SOAPBinding.Style styleOnSEI = endpointDesc.getEndpointInterfaceDescription().getSoapBindingStyle();
+		javax.jws.soap.SOAPBinding.Style styleOnMethod = operationDesc.getSoapBindingStyle();
+		if(styleOnMethod!=null && styleOnSEI!=styleOnMethod){
+			throw ExceptionFactory.makeWebServiceException(Messages.getMessage("proxyErr2"));
+		}
+		if(styleOnSEI == javax.jws.soap.SOAPBinding.Style.RPC){
+			throw new UnsupportedOperationException("RPC/LIT not supported.");
+		}
+		
+		MethodMarshallerFactory cf = (MethodMarshallerFactory) FactoryRegistry.getFactory(MethodMarshallerFactory.class);
+		
+		if(styleOnSEI == javax.jws.soap.SOAPBinding.Style.DOCUMENT){
+			return createDocLitMessageConvertor(cf, protocol);
+		}
+		if(styleOnSEI == javax.jws.soap.SOAPBinding.Style.RPC){
+			return createRPCLitMessageConvertor(cf, protocol);
+			
+		}
+		return null;
+    }
+    
+    private MethodMarshaller createDocLitMessageConvertor(MethodMarshallerFactory cf, Protocol protocol){
+		ParameterStyle parameterStyle = null;
+		if(isDocLitBare(endpointDesc, operationDesc)){
+			parameterStyle = javax.jws.soap.SOAPBinding.ParameterStyle.BARE;
+		}
+		if(isDocLitWrapped(endpointDesc, operationDesc)){
+			parameterStyle = javax.jws.soap.SOAPBinding.ParameterStyle.WRAPPED;
+		}
+		return cf.createDocLitMethodMarshaller(parameterStyle, serviceDesc, endpointDesc, operationDesc, protocol);
+	}
+	
+	private MethodMarshaller createRPCLitMessageConvertor(MethodMarshallerFactory cf, Protocol protocol){
+		return cf.createDocLitMethodMarshaller(null, serviceDesc, endpointDesc, operationDesc, protocol);
+	}
+	
+    
+    public Method getJavaMethod(MessageContext mc, Class serviceImplClass) {
+		 QName opName = mc.getOperationName();
+		 
+	        if (opName == null)
+	            // TODO: NLS
+	            throw ExceptionFactory.makeWebServiceException("Operation name was not set");
+	        
+	        String localPart = opName.getLocalPart();
+	        Method[] methods = serviceImplClass.getMethods();
+	        for (int i = 0; i < methods.length; ++i) {
+	        	String webMethodName = operationDesc.getWebMethodOperationName();
+	            if (localPart.equals(methods[i].getName())){
+	                return methods[i];
+	            }
+	            if(webMethodName.equals(methods[i].getName())){
+	            	return methods[i];
+	            }
+	            
+	        }
+	        
+	        if (log.isDebugEnabled()) {
+	            log.debug("No Java method found for the operation");
+	        }
+	        // TODO: NLS
+	        throw ExceptionFactory.makeWebServiceException(Messages.getMessage("JavaBeanDispatcherErr1"));
+	}
+    
+    protected boolean isDocLitBare(EndpointDescription endpointDesc, OperationDescription operationDesc){
+		javax.jws.soap.SOAPBinding.ParameterStyle methodParamStyle = operationDesc.getSoapBindingParameterStyle();
+		if(methodParamStyle!=null){
+			return methodParamStyle == javax.jws.soap.SOAPBinding.ParameterStyle.BARE;
+		}
+		else{
+			javax.jws.soap.SOAPBinding.ParameterStyle SEIParamStyle = endpointDesc.getEndpointInterfaceDescription().getSoapBindingParameterStyle();
+			return SEIParamStyle == javax.jws.soap.SOAPBinding.ParameterStyle.BARE;
+		}
+	}
+	
+	protected boolean isDocLitWrapped(EndpointDescription endpointDesc, OperationDescription operationDesc){
+		javax.jws.soap.SOAPBinding.ParameterStyle methodParamStyle = operationDesc.getSoapBindingParameterStyle();
+		if(methodParamStyle!=null){
+			return methodParamStyle == javax.jws.soap.SOAPBinding.ParameterStyle.WRAPPED;
+		}
+		else{
+		javax.jws.soap.SOAPBinding.ParameterStyle SEIParamStyle = endpointDesc.getEndpointInterfaceDescription().getSoapBindingParameterStyle();
+		return SEIParamStyle == javax.jws.soap.SOAPBinding.ParameterStyle.WRAPPED;
+		}
+	}
+    
 }
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/registry/FactoryRegistry.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/registry/FactoryRegistry.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/registry/FactoryRegistry.java	(working copy)
@@ -20,8 +20,7 @@
 import java.util.Hashtable;
 import java.util.Map;
 
-import org.apache.axis2.jaxws.client.factory.DescriptorFactory;
-import org.apache.axis2.jaxws.client.factory.ProxyHandlerFactory;
+import org.apache.axis2.jaxws.marshaller.factory.MethodMarshallerFactory;
 import org.apache.axis2.jaxws.message.databinding.impl.JAXBBlockFactoryImpl;
 import org.apache.axis2.jaxws.message.databinding.impl.OMBlockFactoryImpl;
 import org.apache.axis2.jaxws.message.databinding.impl.SOAPEnvelopeBlockFactoryImpl;
@@ -56,8 +55,7 @@
 		table.put(MessageFactory.class, new MessageFactoryImpl());
 		table.put(XMLPartFactory.class, new XMLPartFactoryImpl());
 		table.put(SAAJConverterFactory.class, new SAAJConverterFactoryImpl());
-		table.put(ProxyHandlerFactory.class, new ProxyHandlerFactory());
-		table.put(DescriptorFactory.class, new DescriptorFactory());
+		table.put(MethodMarshallerFactory.class, new MethodMarshallerFactory());
 	}
 	/**
 	 * FactoryRegistry is currently a static singleton
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyDescriptor.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyDescriptor.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyDescriptor.java	(working copy)
@@ -1,202 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws.client.proxy;
-
-import java.lang.reflect.Method;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Hashtable;
-import java.util.Map;
-
-import javax.jws.WebParam;
-import javax.jws.WebResult;
-import javax.jws.soap.SOAPBinding;
-import javax.jws.soap.SOAPBinding.Style;
-import javax.xml.ws.AsyncHandler;
-import javax.xml.ws.RequestWrapper;
-import javax.xml.ws.Response;
-import javax.xml.ws.ResponseWrapper;
-
-import org.apache.axis2.jaxws.ExceptionFactory;
-import org.apache.axis2.jaxws.description.EndpointDescription;
-import org.apache.axis2.jaxws.description.OperationDescription;
-import org.apache.axis2.jaxws.description.ServiceDescription;
-import org.apache.axis2.jaxws.handler.PortData;
-import org.apache.axis2.jaxws.i18n.Messages;
-
-/**
- * ProxyDescriptor is instantiated from ProxyHandler using the Method argument. 
- * ProxyDescriptor will provide all the annotation details like RequestWrapper class
- * ResponseWrapper Class, WebParam name etc...
- *
- */
-public class ProxyDescriptor {
-	
-	private Class seiClazz = null;
-	private Method seiMethod = null;
-	private PortData port = null;
-    private ServiceDescription serviceDescription= null;
-	private OperationDescription operationDescription= null;
-	private EndpointDescription endpointDescription = null;
-   
-    
-	public ServiceDescription getServiceDescription() {
-     return serviceDescription;   
-    }
-    public OperationDescription getOperationDescription() {
-        return operationDescription;
-    }
-    public EndpointDescription getEndpointDescription() {
-        return endpointDescription;
-    }
-
-	//TODO Need to put validation to check if seiMethod is null;
-	public ProxyDescriptor(Class seiClazz, ServiceDescription serviceDescription){
-		this.seiClazz = seiClazz;
-        this.serviceDescription = serviceDescription;
-        // FIXME: This probably needs to be more robust; can there be > 1 endpoints; if so, how choose which one?
-        this.endpointDescription = serviceDescription.getEndpointDescription(seiClazz)[0];
-	}
-	
-	public Class getRequestWrapperClass(boolean isAsync) throws ClassNotFoundException{
-		String className = operationDescription.getRequestWrapperClassName();
-		return Class.forName(className, true, Thread.currentThread().getContextClassLoader());
-	}
-	
-	public String getRequestWrapperClassName(){
-		return operationDescription.getRequestWrapperClassName();
-	}
-	
-	public String getRequestWrapperLocalName(){
-		return operationDescription.getRequestWrapperLocalName();
-	}
-
-	public Class getResponseWrapperClass(boolean isAsync) throws ClassNotFoundException{
-		//TODO: Move this logic to OperationDescription. This is a hack right now.
-		if(isAsync){
-			return getReturnType(isAsync);
-		}
-		
-		String className = operationDescription.getResponseWrapperClassName();
-		return Class.forName(className, true, Thread.currentThread().getContextClassLoader());
-	}
-
-	public String getResponseWrapperLocalName(){
-		return operationDescription.getResponseWrapperLocalName();
-	}
-    public String getWebResultName(boolean isAsync){
-        return operationDescription.getWebResultName();
-	}
-    // TODO: Move to OperationDescription?
-	public ArrayList<String> getParamNames(){ 
-        return new ArrayList<String>(Arrays.asList(operationDescription.getWebParamNames()));
-	}
-	public ArrayList<String> getParamtns(){ 
-        return new ArrayList<String>(Arrays.asList(operationDescription.getWebParamTNS()));
-	}
-	public String getParamtns(String name){ 
-        return operationDescription.getWebParamTNS(name);
-	}
-	public PortData getPort() {
-		return port;
-	}
-	public void setPort(PortData port) {
-		this.port = port;
-	}
-	public Method getSeiMethod() {
-		return seiMethod;
-	}
-	public void setSeiMethod(Method seiMethod) {
-		this.seiMethod = seiMethod;
-        operationDescription = endpointDescription.getEndpointInterfaceDescription().getOperation(seiMethod);
-	}
-	
-	/*
-	 * This method looks at @SOAPBindingAnnotation on clazz to look for Parameter Style
-	 */
-	public boolean isClazzDocLitBare(){
-		SOAPBinding.ParameterStyle style = endpointDescription.getEndpointInterfaceDescription().getSoapBindingParameterStyle();
-		return style == SOAPBinding.ParameterStyle.BARE;
-	}
-	
-	public boolean isClazzDocLitWrapped(){
-		SOAPBinding.ParameterStyle style = endpointDescription.getEndpointInterfaceDescription().getSoapBindingParameterStyle();
-		return style == SOAPBinding.ParameterStyle.WRAPPED;
-	}
-	
-	//TODO read soap binding on method too, make sure if Binding style is different from binding style in Clazz throw Exception.
-	public Style getBindingStyle(){
-        return endpointDescription.getEndpointInterfaceDescription().getSoapBindingStyle(); 
-	}
-	public Class getSeiClazz() {
-		return seiClazz;
-	}
-	public void setSeiClazz(Class seiClazz) {
-		this.seiClazz = seiClazz;
-	}
-    public boolean isOneWay(){
-        return operationDescription.isOneWay();
-    }
-
-    public String filterAsync(String method){
-		if(method.endsWith("Async")){
-			int index =method.lastIndexOf("Async");
-			return method.substring(0,index);
-		}
-		else{
-			return method;
-		}
-	}
-	
-	/**
-	 * In this method I am trying get the return type of the method.
-	 * if SEI method is Async pooling implmentation then return type is actual type in Generic Response, example Response<ClassName>.
-	 * if SEI method is Async Callback implementation then return type is actual type of method parameter type AsyncHandler, example AsyncHandler<ClassName>
-	 * I use java reflection to get the return type.
-	 * @param isAsync
-	 * @return
-	 */
-	public Class getReturnType(boolean isAsync){
-		Class returnType = seiMethod.getReturnType();
-		if(isAsync){
-			//pooling implementation
-			if(Response.class.isAssignableFrom(returnType)){
-				Type type = seiMethod.getGenericReturnType();
-				ParameterizedType pType = (ParameterizedType) type;
-				return (Class)pType.getActualTypeArguments()[0];	
-			}
-			//Callback Implementation
-			else{
-				Type[] type = seiMethod.getGenericParameterTypes();
-				Class parameters[]= seiMethod.getParameterTypes();
-				int i=0;
-				for(Class param:parameters){
-					if(AsyncHandler.class.isAssignableFrom(param)){
-						ParameterizedType pType = (ParameterizedType)type[i];
-						return (Class)pType.getActualTypeArguments()[0];
-					}
-					i++;
-				}
-			}
-			
-		}
-		
-		return returnType;	
-	}
-}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyAsyncListener.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyAsyncListener.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyAsyncListener.java	(working copy)
@@ -16,13 +16,6 @@
  */
 package org.apache.axis2.jaxws.client.proxy;
 
-import java.util.concurrent.ExecutionException;
-
-import org.apache.axiom.om.OMElement;
-import org.apache.axiom.soap.SOAPBody;
-import javax.xml.ws.WebServiceException;
-
-import org.apache.axiom.soap.SOAPEnvelope;
 import org.apache.axis2.jaxws.AxisCallback;
 import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.core.MessageContext;
@@ -37,18 +30,23 @@
  */
 public class ProxyAsyncListener extends AsyncListener {
 
-	BaseProxyHandler handler = null;
+	JAXWSProxyHandler handler = null;
+	Object[] inputArgs = null;
 	public ProxyAsyncListener() {
 		super();
 	}
-
-	public BaseProxyHandler getHandler() {
+	
+	public JAXWSProxyHandler getHandler() {
 		return handler;
 	}
 
-	public void setHandler(BaseProxyHandler handler) {
+	public void setHandler(JAXWSProxyHandler handler) {
 		this.handler = handler;
 	}
+	
+	public void setInputArgs(Object[] inputArgs){
+		this.inputArgs = inputArgs;
+	}
 
 	/**
 	 * @param cb
@@ -62,8 +60,8 @@
 		 
 		 try{
 			 //I will delegate the request to create respose to proxyHandler since it has all the logic written to create response for Sync and oneWay.
-			  return handler.createResponse(null, mc);
-		 }catch(Exception e){
+			  return handler.createResponse(null,inputArgs, mc);
+		 }catch(Throwable e){
 			throw ExceptionFactory.makeWebServiceException(e);
 		 }
 	 }
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/BaseProxyHandler.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/BaseProxyHandler.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/BaseProxyHandler.java	(working copy)
@@ -1,266 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws.client.proxy;
-
-import java.beans.IntrospectionException;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.concurrent.Future;
-
-import javax.xml.bind.JAXBException;
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.ws.AsyncHandler;
-import javax.xml.ws.Response;
-import javax.xml.ws.WebServiceException;
-
-import org.apache.axis2.AxisFault;
-import org.apache.axis2.jaxws.AxisController;
-import org.apache.axis2.jaxws.BindingProvider;
-import org.apache.axis2.jaxws.ExceptionFactory;
-import org.apache.axis2.jaxws.core.InvocationContext;
-import org.apache.axis2.jaxws.core.InvocationContextFactory;
-import org.apache.axis2.jaxws.core.MessageContext;
-import org.apache.axis2.jaxws.core.controller.AxisInvocationController;
-import org.apache.axis2.jaxws.core.controller.InvocationController;
-import org.apache.axis2.jaxws.i18n.Messages;
-import org.apache.axis2.jaxws.impl.AsyncListener;
-import org.apache.axis2.jaxws.message.MessageException;
-import org.apache.axis2.jaxws.spi.ServiceDelegate;
-import org.apache.axis2.jaxws.util.WSDLWrapper;
-import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-// import com.sun.xml.bind.v2.runtime.reflect.Lister;
-
-/**
- * ProxyHandler is the java.lang.reflect.InvocationHandler implementation.
- * When jaxws client calls the method on proxy object that it gets using the getPort
- * ServiceDelegate api, the Inovke method on ProxyHandler is Invoked.
- * ProxyHandler uses EndpointInterfaceDescriptor and finds out if 
- * 1) The client call is Document Literal or Rpc Literal
- * 2) The WSDL is wrapped or unWrapped. 
- * 
- * ProxyHandler then reads OperationDescription using Method name called by Client
- * From OperationDescription it does the following 
- * 1) if the wsdl isWrapped() reads RequestWrapper Class and responseWrapperClass
- * 2) then reads the webParams for the Operation.
- * 
- * isWrapped() = true  and DocLiteral then
- * ProxyHandler then uses WrapperTool to create Request that is a Wrapped JAXBObject.
- * Creates JAXBBlock using JAXBBlockFactory
- * Creates MessageContext->Message and sets JAXBBlock to xmlPart as RequestMsgCtx in InvocationContext.
- * Makes call to InvocationController.
- * Reads ResponseMsgCtx ->MessageCtx->Message->XMLPart.
- * Converts that to JAXBlock using JAXBBlockFactory and returns the BO from this JAXBBlock.
- * 
- * isWrapped() != true and DocLiteral then
- * ProxyHandler creates the JAXBBlock for the input request creates a 
- * MessageContext that is then used by IbvocationController to invoke.
- * Response is read and return object is derived using @Webresult annotation.
- * A JAXBBlock is created from the Response and the BO from JAXBBlock is
- * returned.  
- * 
- * RPCLiteral 
- * TBD
- * 
- */
-
-public abstract class BaseProxyHandler extends BindingProvider implements
-		InvocationHandler {
-	private static Log log = LogFactory.getLog(BaseProxyHandler.class);
-//	TODO remove axisController once InvocationController code is build.
-	private AxisController axisController = null;
-	//Reference to ServiceDelegate instance that was used to create the Proxy
-	private ServiceDelegate delegate = null;
-	protected ProxyDescriptor proxyDescriptor = null;
-	
-	public BaseProxyHandler(ProxyDescriptor pd, ServiceDelegate delegate) {
-		super();
-		this.proxyDescriptor = pd;
-		this.delegate = delegate;
-		initRequestContext();
-	}
-	
-	/* (non-Javadoc)
-	 * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
-	 * 
-	 * Invoke method checks to see if BindingProvider method was invoked by client if yes, it uses reflection and invokes the BindingProvider method.
-	 * If SEI method was called then it delegates to InvokeSEIMethod().
-	 */
-	public Object invoke(Object proxy, Method method, Object[] args)
-			throws Throwable {
-		if (log.isDebugEnabled()) {
-            log.debug("Attemping to invoke Method: " +method.getName());
-        }
-		if(!isValidMethodCall(method)){
-			throw ExceptionFactory.makeWebServiceException(Messages.getMessage("proxyErr1",method.getName(), axisController.getClientContext().getClazz().getName()));
-		}
-		
-		if(isBindingProviderInvoked(method)){
-			if (log.isDebugEnabled()) {
-	            log.debug("Invoking method on Binding Provider");
-	        }
-			return method.invoke(this, args);
-			
-		}
-		else{
-			proxyDescriptor.setSeiMethod(method);
-			return InvokeSEIMethod(method, args);
-		}
-	}
-	
-	/**
-	 * InvokeSEIMethod invokes Axis engine using methods on InvocationController. Create request Invocation context, instantiates AxisInvocationController and 
-	 * runs invoke.
-	 * 
-	 */
-	private Object InvokeSEIMethod(Method method, Object[] args)throws ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, XMLStreamException, IllegalAccessException,IntrospectionException, NoSuchFieldException, InvocationTargetException{
-		if (log.isDebugEnabled()) {
-            log.debug("Attempting to Invoke SEI Method "+ method.getName());
-        }
-		
-		//TODO make sure the method is a public method and it is declared in SEI.
-		
-		InvocationContext requestIC = InvocationContextFactory.createInvocationContext(null);
-		MessageContext requestContext = createRequest(method, args);
-        requestContext.setOperationDescription(proxyDescriptor.getOperationDescription());
-		requestIC.setRequestMessageContext(requestContext);
-		InvocationController controller = new AxisInvocationController();
-		//FIXME: Fix based on how InvocationContext changes to get ServiceClient.
-		requestIC.setServiceClient(proxyDescriptor.getEndpointDescription().getServiceClient());
-		
-		//check if the call is OneWay, Async or Sync
-		if(proxyDescriptor.isOneWay() || method.getReturnType().getName().equals("void")){
-			if(log.isDebugEnabled()){
-				log.debug("OneWay Call");
-			}
-			controller.invokeOneWay(requestIC);
-		}
-		
-		if(method.getReturnType().isAssignableFrom(Future.class)){
-			if(log.isDebugEnabled()){
-				log.debug("Async Callback");
-			}
-			//Get AsyncHandler from Objects and sent that to InvokeAsync
-			AsyncHandler asyncHandler = null;
-			for(Object obj:args){
-				if(obj !=null && AsyncHandler.class.isAssignableFrom(obj.getClass())){
-					asyncHandler = (AsyncHandler)obj;
-					break;
-				}
-			}
-			if(asyncHandler == null){
-				throw ExceptionFactory.makeWebServiceException("AynchHandler null for Async callback, Invalid AsyncHandler callback Object");
-			}
-			AsyncListener listener = createProxyListener();
-			requestIC.setAsyncListener(listener);
-			requestIC.setExecutor(delegate.getExecutor());
-			return controller.invokeAsync(requestIC, asyncHandler);
-		}
-		
-		if(method.getReturnType().isAssignableFrom(Response.class)){
-			if(log.isDebugEnabled()){
-				log.debug("Async Polling");
-			}
-			AsyncListener listener = createProxyListener();
-			requestIC.setAsyncListener(listener);
-			requestIC.setExecutor(delegate.getExecutor());
-			return controller.invokeAsync(requestIC);
-		}
-		
-		if(!proxyDescriptor.isOneWay()){
-			InvocationContext responseIC = controller.invoke(requestIC);
-		
-			MessageContext responseContext = responseIC.getResponseMessageContext();
-			Object responseObj = createResponse(method, responseContext);
-			return responseObj;
-		}
-		return null;
-	}
-	
-	private AsyncListener createProxyListener(){
-		ProxyAsyncListener listener = new ProxyAsyncListener();
-		listener.setHandler(this);
-		return listener;
-	}
-	
-	protected boolean isAsync(){
-		String methodName = proxyDescriptor.getSeiMethod().getName();
-		Class returnType = proxyDescriptor.getSeiMethod().getReturnType();
-		return methodName.endsWith("Async") && (returnType.isAssignableFrom(Response.class) || returnType.isAssignableFrom(Future.class));
-	}
-	/**
-	 * Create request context for the method call. This request context will be used by InvocationController to route the method call to axis engine.
-	 * @param method
-	 * @param args
-	 * @return
-	 */
-	protected abstract MessageContext createRequest(Method method, Object[] args) throws ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, javax.xml.stream.XMLStreamException;
-	
-	/**
-	 * Creates response context for the method call. This response context will be used to create response result to the client call.
-	 * @param method
-	 * @param responseContext
-	 * @return
-	 */
-	protected abstract Object createResponse(Method method, MessageContext responseContext)throws IllegalAccessException, ClassNotFoundException, JAXBWrapperException, JAXBException, javax.xml.stream.XMLStreamException, MessageException, IntrospectionException, NoSuchFieldException, InvocationTargetException;
-	
-	private boolean isBindingProviderInvoked(Method method){
-		Class SEIClass = proxyDescriptor.getSeiClazz();
-		Class methodsClass = method.getDeclaringClass();
-		return (SEIClass == methodsClass)?false:true;
-	}
-	
-	private boolean isValidMethodCall(Method method){
-		Class SEIClass = proxyDescriptor.getSeiClazz();
-		Class clazz = method.getDeclaringClass();
-		if(clazz == javax.xml.ws.BindingProvider.class || clazz == SEIClass){
-			return true;
-		}
-		return false;
-	}
-	//TODO: remove reference to AxisController.
-	protected void setAxisController(AxisController ac) {
-		this.axisController = ac;
-	}
-	
-	public void setDelegate(ServiceDelegate delegate) {
-		this.delegate = delegate;
-	}
-	
-	protected void initRequestContext() {
-		String soapAddress = null;
-		String soapAction = null;
-		String endPointAddress = proxyDescriptor.getPort().getEndpointAddress();
-		WSDLWrapper wsdl = delegate.getServiceDescription().getWSDLWrapper();
-		QName serviceName = delegate.getServiceName();
-		QName portName = proxyDescriptor.getPort().getPortName();
-		if (wsdl != null) {
-			soapAddress = wsdl.getSOAPAddress(serviceName, portName);
-			soapAction = wsdl.getSOAPAction(serviceName, portName);
-		}
-		super.initRequestContext(endPointAddress, soapAddress, soapAction);
-	}
-
-	protected ServiceDelegate getDelegate() {
-		return delegate;
-	}
-
-}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/JAXWSProxyHandler.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/JAXWSProxyHandler.java	(revision 0)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/JAXWSProxyHandler.java	(revision 0)
@@ -0,0 +1,412 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.client.proxy;
+
+import java.beans.IntrospectionException;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.concurrent.Future;
+
+import javax.jws.soap.SOAPBinding;
+import javax.jws.soap.SOAPBinding.ParameterStyle;
+import javax.xml.bind.JAXBException;
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.ws.AsyncHandler;
+import javax.xml.ws.Binding;
+import javax.xml.ws.Response;
+import javax.xml.ws.WebServiceException;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.jaxws.AxisController;
+import org.apache.axis2.jaxws.BindingProvider;
+import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.core.InvocationContext;
+import org.apache.axis2.jaxws.core.InvocationContextFactory;
+import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.core.controller.AxisInvocationController;
+import org.apache.axis2.jaxws.core.controller.InvocationController;
+import org.apache.axis2.jaxws.description.EndpointDescription;
+import org.apache.axis2.jaxws.description.OperationDescription;
+import org.apache.axis2.jaxws.description.ServiceDescription;
+import org.apache.axis2.jaxws.handler.PortData;
+import org.apache.axis2.jaxws.i18n.Messages;
+import org.apache.axis2.jaxws.impl.AsyncListener;
+import org.apache.axis2.jaxws.marshaller.MethodMarshaller;
+import org.apache.axis2.jaxws.marshaller.factory.MethodMarshallerFactory;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.MessageException;
+import org.apache.axis2.jaxws.message.Protocol;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
+import org.apache.axis2.jaxws.spi.ServiceDelegate;
+import org.apache.axis2.jaxws.util.WSDLWrapper;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+// import com.sun.xml.bind.v2.runtime.reflect.Lister;
+
+/**
+ * ProxyHandler is the java.lang.reflect.InvocationHandler implementation.
+ * When jaxws client calls the method on proxy object that it gets using the getPort
+ * ServiceDelegate api, the Inovke method on ProxyHandler is Invoked.
+ * ProxyHandler uses EndpointInterfaceDescriptor and finds out if 
+ * 1) The client call is Document Literal or Rpc Literal
+ * 2) The WSDL is wrapped or unWrapped. 
+ * 
+ * ProxyHandler then reads OperationDescription using Method name called by Client
+ * From OperationDescription it does the following 
+ * 1) if the wsdl isWrapped() reads RequestWrapper Class and responseWrapperClass
+ * 2) then reads the webParams for the Operation.
+ * 
+ * isWrapped() = true  and DocLiteral then
+ * ProxyHandler then uses WrapperTool to create Request that is a Wrapped JAXBObject.
+ * Creates JAXBBlock using JAXBBlockFactory
+ * Creates MessageContext->Message and sets JAXBBlock to xmlPart as RequestMsgCtx in InvocationContext.
+ * Makes call to InvocationController.
+ * Reads ResponseMsgCtx ->MessageCtx->Message->XMLPart.
+ * Converts that to JAXBlock using JAXBBlockFactory and returns the BO from this JAXBBlock.
+ * 
+ * isWrapped() != true and DocLiteral then
+ * ProxyHandler creates the JAXBBlock for the input request creates a 
+ * MessageContext that is then used by IbvocationController to invoke.
+ * Response is read and return object is derived using @Webresult annotation.
+ * A JAXBBlock is created from the Response and the BO from JAXBBlock is
+ * returned.  
+ * 
+ * RPCLiteral 
+ * TBD
+ * 
+ */
+
+public class JAXWSProxyHandler extends BindingProvider implements
+		InvocationHandler {
+	private static Log log = LogFactory.getLog(JAXWSProxyHandler.class);
+
+	//Reference to ServiceDelegate instance that was used to create the Proxy
+	private ServiceDelegate delegate = null;
+	protected ServiceDescription serviceDesc = null;
+	protected EndpointDescription endpointDesc = null;
+	protected OperationDescription operationDesc = null;
+	protected MethodMarshaller methodMarshaller = null;
+	private PortData port = null;
+	private Class seiClazz = null;
+	private Method method = null;
+	
+	public JAXWSProxyHandler(ServiceDelegate delegate, Class seiClazz, PortData port) {
+		super();
+		this.delegate = delegate;
+		this.seiClazz = seiClazz;
+		this.port = port;
+		this.serviceDesc=delegate.getServiceDescription();
+//		FIXME: This probably needs to be more robust; can there be > 1 endpoints; if so, how choose which one?
+		this.endpointDesc = serviceDesc.getEndpointDescription(seiClazz)[0];
+		initRequestContext();
+	}
+	
+	/* (non-Javadoc)
+	 * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
+	 * 
+	 * Invoke method checks to see if BindingProvider method was invoked by client if yes, it uses reflection and invokes the BindingProvider method.
+	 * If SEI method was called then it delegates to InvokeSEIMethod().
+	 */
+	public Object invoke(Object proxy, Method method, Object[] args)
+			throws Throwable {
+		if (log.isDebugEnabled()) {
+            log.debug("Attemping to invoke Method: " +method.getName());
+        }
+        
+		this.method = method;
+		
+		if(!isValidMethodCall(method)){
+			throw ExceptionFactory.makeWebServiceException(Messages.getMessage("proxyErr1",method.getName(), seiClazz.getName()));
+		}
+		
+		if(!isPublic(method)){
+			throw ExceptionFactory.makeWebServiceException("Invalid Method Call, Method "+method.getName() + " not a public method"); 
+		}
+		
+		if(isBindingProviderInvoked(method)){
+			if (log.isDebugEnabled()) {
+	            log.debug("Invoking method on Binding Provider");
+	        }
+			try{
+				return method.invoke(this, args);
+			}catch(Throwable e){
+				throw ExceptionFactory.makeMessageException(e);
+			}
+			
+		}
+		else{
+			operationDesc = endpointDesc.getEndpointInterfaceDescription().getOperation(method);
+			if(isMethodExcluded()){
+				throw ExceptionFactory.makeWebServiceException("Invalid Method Call, Method "+method.getName() + " has been excluded using @webMethod annotation");
+			}
+			try{
+				return InvokeSEIMethod(method, args);
+			}catch(Throwable e){
+				throw ExceptionFactory.makeWebServiceException(e);
+			}
+		}
+	}
+	
+	/**
+	 * InvokeSEIMethod invokes Axis engine using methods on InvocationController. Create request Invocation context, instantiates AxisInvocationController and 
+	 * runs invoke.
+	 * 
+	 */
+	private Object InvokeSEIMethod(Method method, Object[] args)throws Throwable{
+		if (log.isDebugEnabled()) {
+            log.debug("Attempting to Invoke SEI Method "+ method.getName());
+        }
+		initialize();
+		InvocationContext requestIC = InvocationContextFactory.createInvocationContext(null);
+		MessageContext requestContext = createRequest(method, args);
+		//Enable MTOM on the Message if the property was
+        //set on the SOAPBinding.
+        Binding bnd = getBinding();
+        if (bnd != null && bnd instanceof SOAPBinding) {
+            javax.xml.ws.soap.SOAPBinding soapBnd = (javax.xml.ws.soap.SOAPBinding) bnd;
+            if (soapBnd.isMTOMEnabled()) {
+                Message requestMsg = requestContext.getMessage();
+                requestMsg.setMTOMEnabled(true);
+            }
+        }
+        requestContext.setOperationDescription(operationDesc);
+		requestIC.setRequestMessageContext(requestContext);
+		InvocationController controller = new AxisInvocationController();
+		requestIC.setServiceClient(delegate.getServiceClient(port.getPortName()));
+		
+		//check if the call is OneWay, Async or Sync
+		//if(operationDesc.isOneWay() || method.getReturnType().getName().equals("void")){
+		if(operationDesc.isOneWay()){
+			if(log.isDebugEnabled()){
+				log.debug("OneWay Call");
+			}
+			controller.invokeOneWay(requestIC);
+		}
+		
+		if(method.getReturnType().isAssignableFrom(Future.class)){
+			if(log.isDebugEnabled()){
+				log.debug("Async Callback");
+			}
+			//Get AsyncHandler from Objects and sent that to InvokeAsync
+			AsyncHandler asyncHandler = null;
+			for(Object obj:args){
+				if(obj !=null && AsyncHandler.class.isAssignableFrom(obj.getClass())){
+					asyncHandler = (AsyncHandler)obj;
+					break;
+				}
+			}
+			if(asyncHandler == null){
+				throw ExceptionFactory.makeWebServiceException("AynchHandler null for Async callback, Invalid AsyncHandler callback Object");
+			}
+			AsyncListener listener = createProxyListener(args);
+			requestIC.setAsyncListener(listener);
+			requestIC.setExecutor(delegate.getExecutor());
+			return controller.invokeAsync(requestIC, asyncHandler);
+		}
+		
+		if(method.getReturnType().isAssignableFrom(Response.class)){
+			if(log.isDebugEnabled()){
+				log.debug("Async Polling");
+			}
+			AsyncListener listener = createProxyListener(args);
+			requestIC.setAsyncListener(listener);
+			requestIC.setExecutor(delegate.getExecutor());
+			return controller.invokeAsync(requestIC);
+		}
+		
+		if(!operationDesc.isOneWay()){
+			InvocationContext responseIC = controller.invoke(requestIC);
+		
+			MessageContext responseContext = responseIC.getResponseMessageContext();
+			Object responseObj = createResponse(method, args, responseContext);
+			return responseObj;
+		}
+		return null;
+	}
+	
+	private AsyncListener createProxyListener(Object[] args){
+		ProxyAsyncListener listener = new ProxyAsyncListener();
+		listener.setHandler(this);
+		listener.setInputArgs(args);
+		return listener;
+	}
+	
+	protected boolean isAsync(){
+		String methodName = method.getName();
+		Class returnType = method.getReturnType();
+		return methodName.endsWith("Async") && (returnType.isAssignableFrom(Response.class) || returnType.isAssignableFrom(Future.class));
+	}
+	/**
+	 * Create request context for the method call. This request context will be used by InvocationController to route the method call to axis engine.
+	 * @param method
+	 * @param args
+	 * @return
+	 */
+	protected MessageContext createRequest(Method method, Object[] args) throws Throwable{
+		if (log.isDebugEnabled()) {
+            log.debug("Converting objects to Message");
+        }
+		Message message = methodMarshaller.marshalRequest(args);
+		
+		if (log.isDebugEnabled()) {
+            log.debug("Objects converted to Message");
+        }
+		MessageContext request = new MessageContext();
+		request.setMessage(message);
+		request.getProperties().putAll(getRequestContext());
+		if (log.isDebugEnabled()) {
+            log.debug("Request Created");
+        }
+		return request;	
+	}
+	
+	/**
+	 * Creates response context for the method call. This response context will be used to create response result to the client call.
+	 * @param method
+	 * @param responseContext
+	 * @return
+	 */
+	protected Object createResponse(Method method, Object[] args, MessageContext responseContext)throws Throwable{
+		Message responseMsg = responseContext.getMessage();
+		if (log.isDebugEnabled()) {
+            log.debug("Converting Message to Response Object");
+        }
+		Object object = methodMarshaller.demarshalResponse(responseMsg, args);
+		if (log.isDebugEnabled()) {
+            log.debug("Message Converted to response Object");
+        }
+		return object;
+	}
+	
+	private boolean isBindingProviderInvoked(Method method){
+		Class methodsClass = method.getDeclaringClass();
+		return (seiClazz == methodsClass)?false:true;
+	}
+	
+	private boolean isValidMethodCall(Method method){
+		Class clazz = method.getDeclaringClass();
+		if(clazz == javax.xml.ws.BindingProvider.class || clazz == seiClazz){
+			return true;
+		}
+		return false;
+	}
+	
+	public void setDelegate(ServiceDelegate delegate) {
+		this.delegate = delegate;
+	}
+	
+	protected void initRequestContext() {
+		String soapAddress = null;
+		String soapAction = null;
+		String endPointAddress = port.getEndpointAddress();
+		WSDLWrapper wsdl = delegate.getServiceDescription().getWSDLWrapper();
+		QName serviceName = delegate.getServiceName();
+		QName portName = port.getPortName();
+		if (wsdl != null) {
+			soapAddress = wsdl.getSOAPAddress(serviceName, portName);
+			soapAction = wsdl.getSOAPAction(serviceName, portName);
+		}
+		super.initRequestContext(endPointAddress, soapAddress, soapAction);
+	}
+
+	protected ServiceDelegate getDelegate() {
+		return delegate;
+	}
+	
+	private boolean isPublic(Method method){
+		return Modifier.isPublic(method.getModifiers());
+	}
+	
+	private boolean isMethodExcluded(){
+		return operationDesc.isWebMethodExcluded();
+	}
+
+	public PortData getPort() {
+		return port;
+	}
+
+	public void setPort(PortData port) {
+		this.port = port;
+	}
+
+	public Class getSeiClazz() {
+		return seiClazz;
+	}
+
+	public void setSeiClazz(Class seiClazz) {
+		this.seiClazz = seiClazz;
+	}
+	private void initialize(){
+		SOAPBinding.Style styleOnSEI = endpointDesc.getEndpointInterfaceDescription().getSoapBindingStyle();
+		SOAPBinding.Style styleOnMethod = operationDesc.getSoapBindingStyle();
+		if(styleOnMethod!=null && styleOnSEI!=styleOnMethod){
+			throw ExceptionFactory.makeWebServiceException(Messages.getMessage("proxyErr2"));
+		}
+		
+		MethodMarshallerFactory cf = (MethodMarshallerFactory) FactoryRegistry.getFactory(MethodMarshallerFactory.class);
+		if(styleOnSEI == SOAPBinding.Style.DOCUMENT){
+			methodMarshaller = createDocLitMethodMarshaller(cf);
+		}
+		if(styleOnSEI == SOAPBinding.Style.RPC){
+			methodMarshaller = createRPCLitMethodMarshaller(cf);
+			
+		}
+	
+	}
+	private MethodMarshaller createDocLitMethodMarshaller(MethodMarshallerFactory cf){
+		ParameterStyle parameterStyle = null;
+		if(isDocLitBare()){
+			parameterStyle = SOAPBinding.ParameterStyle.BARE;
+		}
+		if(isDocLitWrapped()){
+			parameterStyle = SOAPBinding.ParameterStyle.WRAPPED;
+		}
+		//FIXME: The protocol should actually come from the binding information included in
+	    // either the WSDL or an annotation.
+		return cf.createDocLitMethodMarshaller(parameterStyle, serviceDesc, endpointDesc, operationDesc, Protocol.soap11);
+	}
+	
+	private MethodMarshaller createRPCLitMethodMarshaller(MethodMarshallerFactory cf){
+		return cf.createDocLitMethodMarshaller(null, serviceDesc, endpointDesc, operationDesc, Protocol.soap11);
+	}
+	protected boolean isDocLitBare(){
+		SOAPBinding.ParameterStyle methodParamStyle = operationDesc.getSoapBindingParameterStyle();
+		if(methodParamStyle!=null){
+			return methodParamStyle == SOAPBinding.ParameterStyle.BARE;
+		}
+		else{
+			SOAPBinding.ParameterStyle SEIParamStyle = endpointDesc.getEndpointInterfaceDescription().getSoapBindingParameterStyle();
+			return SEIParamStyle == SOAPBinding.ParameterStyle.BARE;
+		}
+	}
+	
+	protected boolean isDocLitWrapped(){
+		SOAPBinding.ParameterStyle methodParamStyle = operationDesc.getSoapBindingParameterStyle();
+		if(methodParamStyle!=null){
+			return methodParamStyle == SOAPBinding.ParameterStyle.WRAPPED;
+		}
+		else{
+		SOAPBinding.ParameterStyle SEIParamStyle = endpointDesc.getEndpointInterfaceDescription().getSoapBindingParameterStyle();
+		return SEIParamStyle == SOAPBinding.ParameterStyle.WRAPPED;
+		}
+	}
+}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/RPCLitProxyHandler.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/RPCLitProxyHandler.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/RPCLitProxyHandler.java	(working copy)
@@ -1,59 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws.client.proxy;
-
-import java.lang.reflect.Method;
-
-import org.apache.axis2.jaxws.core.MessageContext;
-import org.apache.axis2.jaxws.core.controller.AxisInvocationController;
-import org.apache.axis2.jaxws.spi.ServiceDelegate;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-
-public class RPCLitProxyHandler extends BaseProxyHandler {
-	private static Log log = LogFactory.getLog(RPCLitProxyHandler.class);
-
-	/**
-	 * @param pd
-	 * @param delegate
-	 */
-	public RPCLitProxyHandler(ProxyDescriptor pd, ServiceDelegate delegate) {
-		super(pd, delegate);
-		// TODO Auto-generated constructor stub
-	}
-
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.jaxws.client.proxy.BaseProxyHandler#createRequest(java.lang.reflect.Method, java.lang.Object)
-	 */
-	@Override
-	protected MessageContext createRequest(Method method, Object[] args) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	/* (non-Javadoc)
-	 * @see org.apache.axis2.jaxws.client.proxy.BaseProxyHandler#createResponse(java.lang.reflect.Method, org.apache.axis2.jaxws.core.MessageContext)
-	 */
-	@Override
-	protected Object createResponse(Method method,
-			MessageContext responseContext) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/DocLitProxyHandler.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/DocLitProxyHandler.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/DocLitProxyHandler.java	(working copy)
@@ -1,475 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws.client.proxy;
-
-import java.beans.IntrospectionException;
-import java.io.ByteArrayInputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Map;
-
-import javax.xml.bind.JAXBContext;
-import javax.xml.bind.JAXBElement;
-import javax.xml.bind.JAXBException;
-import javax.xml.bind.JAXBIntrospector;
-import javax.xml.bind.Unmarshaller;
-import javax.xml.bind.annotation.XmlRootElement;
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.ws.AsyncHandler;
-
-import org.apache.axiom.om.OMElement;
-import org.apache.axis2.jaxws.ExceptionFactory;
-import org.apache.axis2.jaxws.core.MessageContext;
-import org.apache.axis2.jaxws.i18n.Messages;
-import org.apache.axis2.jaxws.message.Block;
-import org.apache.axis2.jaxws.message.Message;
-import org.apache.axis2.jaxws.message.MessageException;
-import org.apache.axis2.jaxws.message.Protocol;
-import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
-import org.apache.axis2.jaxws.message.factory.MessageFactory;
-import org.apache.axis2.jaxws.message.factory.XMLStringBlockFactory;
-import org.apache.axis2.jaxws.registry.FactoryRegistry;
-import org.apache.axis2.jaxws.spi.ServiceDelegate;
-import org.apache.axis2.jaxws.wrapper.JAXBWrapperTool;
-import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
-import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperToolImpl;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-
-public class DocLitProxyHandler extends BaseProxyHandler {
-	private static Log log = LogFactory.getLog(DocLitProxyHandler.class);
-	private static int SIZE = 1;
-	private static String DEFAULT_ARG="arg";
-	private static QName SOAPENV_QNAME= new QName("http://schemas.xmlsoap.org/soap/envelop/", "Envelope");
-	private ArrayList<Object> argList = null;
-	/**
-	 * @param pd
-	 * @param delegate
-	 */
-	public DocLitProxyHandler(ProxyDescriptor pd, ServiceDelegate delegate) {
-		super(pd, delegate);
-	}
-
-	@Override
-	protected MessageContext createRequest(Method method, Object[] args) throws ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, javax.xml.stream.XMLStreamException {
-		MessageContext requestCtx = null;
-		if(isDocLitWrapped()){
-			if (log.isDebugEnabled()) {
-	            log.debug("Creating Doc Lit Wrapped Request for method : " +method.getName());
-	        }
-			return createDocLitWrappedRequest(method, args);
-		}
-		if(isDocLitBare()){
-			if (log.isDebugEnabled()) {
-	            log.debug("Creating Doc Lit Bare Request for method : " +method.getName());
-	        }
-			return createDocLitNONWrappedRequest(method, args);
-		}
-		return requestCtx;
-	}
-
-	@Override
-	protected Object createResponse(Method method, MessageContext responseContext) throws IllegalAccessException, ClassNotFoundException, JAXBWrapperException, JAXBException, javax.xml.stream.XMLStreamException, MessageException, IntrospectionException, NoSuchFieldException, InvocationTargetException{
-		Object result = null;
-		if(isDocLitWrapped()){
-			if (log.isDebugEnabled()) {
-	            log.debug("Creating Doc Lit Wrapped Response ");
-	        }
-			return createDocLitWrappedResponse(method, responseContext);
-		}
-		if(isDocLitBare()){
-			if (log.isDebugEnabled()) {
-	            log.debug("Creating Doc Lit Bare Request ");
-	        }
-			return createDocLitNONWrappedResponse(method, responseContext);
-		}
-		return result;
-	}
-
-	/**
-	 * createDocLitWrappedRequest create request message context. It reads RequestWrapper annotation from OperationDescription and reads the calss name, then reads
-	 * all the webParam annotation on the method and uses JAXBWrapTool to wrap the request as jaxbObject. Create JAXBblock from the jaxbObject and sets OMElement on 
-	 * Request MessageContext, reads Biniding provider properties and set them on request message context and return request message context.
-	 * @param method
-	 * @param objects
-	 * @return
-	 * @throws ClassNotFoundException
-	 * @throws JAXBWrapperException
-	 * @throws JAXBException
-	 * @throws MessageException
-	 * @throws javax.xml.stream.XMLStreamException
-	 */
-	private MessageContext createDocLitWrappedRequest(Method method, Object[] objects)throws ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, javax.xml.stream.XMLStreamException{
-		
-		Class wrapperClazz = proxyDescriptor.getRequestWrapperClass(isAsync());
-		ArrayList<String> names = getParamNames(objects);
-		String localName = proxyDescriptor.getRequestWrapperLocalName();
-		Map<String, Object> values = getParamValues(objects, names);
-		JAXBWrapperTool wrapTool = new JAXBWrapperToolImpl();
-		if (log.isDebugEnabled()) {
-            log.debug("JAXBWrapperTool attempting to wrap propertes in WrapperClass :" + wrapperClazz);
-        }
-		//TODO:if(@XmlRootElement) annotation found or defined
-		Object jaxbObject = wrapTool.wrap(wrapperClazz, localName,names, values);
-		if (log.isDebugEnabled()) {
-            log.debug("JAXBWrapperTool wrapped following propertes :");
-        }
-		//TODO: if (!@XmlRootElement) annotation not found or not defined then can I use JAXBElement?
-		//JAXBElement jaxbObject = wrapTool.wrapAsJAXBElement(wrapperClazz, requestWrapper.localName(),names, values);
-		JAXBContext ctx = JAXBContext.newInstance(new Class[]{wrapperClazz});
-		if (log.isDebugEnabled()) {
-            log.debug("Attempting to create Block");
-        }
-		XmlRootElement root = null;
-		Block reqBlock = null;
-		root =(XmlRootElement) wrapperClazz.getAnnotation(XmlRootElement.class);
-		if(root != null){
-		 reqBlock = createJAXBBlock(jaxbObject, ctx);
-		 if (log.isDebugEnabled()) {
-	            log.debug("JAXBBlock Created");
-	        }
-		}
-		else{
-			reqBlock = createJAXBBlock(localName, jaxbObject, ctx);
-			if (log.isDebugEnabled()) {
-	            log.debug("JAXBBlock Created");
-	        }
-		}
-		
-		MessageContext requestCtx = initializeRequest(reqBlock);
-		return requestCtx;
-		
-	}
-	
-	
-	/**
-	 * CreateDocLitNONWrappedRequest creates a request message context. The input object to a non wrapped wsdl will be a object (mainly a JAXB Object) that will
-	 * have all the payload data or method parameter data already setup. So the message context will be created by converting input object in to a JAXBBlock and
-	 * attaching the Block Message to soap body.
-	 * @param method
-	 * @param objects
-	 * @return
-	 */
-	private MessageContext createDocLitNONWrappedRequest(Method method, Object[] objects) throws JAXBException, MessageException, XMLStreamException{
-		MessageContext requestCtx = null;
-		
-		ArrayList<String> names = getParamNames(objects);
-		ArrayList<String> tns = proxyDescriptor.getParamtns();
-		Map<String, Object> values = getParamValues(objects, names);
-		if(names.size()> SIZE || values.size() > SIZE){
-			if (log.isDebugEnabled()) {
-	            log.debug("As per WS-I compliance, Multi part WSDL not allowed for Doc/Lit NON Wrapped request, Method invoked has multiple input parameter");
-	        }
-			throw ExceptionFactory.makeWebServiceException(Messages.getMessage("DocLitProxyHandlerErr1"));
-		}
-		if(names.size() !=0){
-			JAXBContext ctx = null;
-			Object requestObject = null;
-			String requestObjectName = null;
-			for(String name:names){
-				requestObject = values.get(name);
-				requestObjectName = name;
-				if(requestObject == null){
-					if (log.isDebugEnabled()) {
-			            log.debug("Method Input parameter for NON Wrapped Request cannot be null");
-			        }
-					throw ExceptionFactory.makeWebServiceException(Messages.getMessage("DocLitProxyHandlerErr2"));
-				}
-			}
-				
-			ctx = JAXBContext.newInstance(new Class[]{requestObject.getClass()});
-			if (log.isDebugEnabled()) {
-	            log.debug("Attempting to create Block");
-	        }
-			Block reqBlock = createJAXBBlock(requestObjectName, requestObject, ctx);
-			if (log.isDebugEnabled()) {
-	            log.debug("Block Created");
-	        }
-			requestCtx = initializeRequest(reqBlock);
-		}
-		if(names.size() == 0){
-			Block emptyBodyBlock = createEmptyBodyBlock();
-			requestCtx = initializeRequest(emptyBodyBlock);
-		}
-		return requestCtx;
-	}
-	
-	/**
-	 * CreateDocLitWrappedResponse creates return result that client expects from the method call. It reads response wrapper annotation then reads OM from the
-	 * response message context and creates JAXBBlock from the OMElement on messageContext. It then reads the webresult annotation to gather the return parameter
-	 * name and creates the result object for it by reading the property object from JAXBBlock's business object using PropertyDescriptor. 
-	 * @param method
-	 * @param response
-	 * @return
-	 * @throws IllegalAccessException
-	 * @throws ClassNotFoundException
-	 * @throws JAXBWrapperException
-	 * @throws JAXBException
-	 * @throws javax.xml.stream.XMLStreamException
-	 * @throws MessageException
-	 * @throws IntrospectionException
-	 * @throws NoSuchFieldException
-	 * @throws InvocationTargetException
-	 */
-
-	private Object createDocLitWrappedResponse(Method method, MessageContext response)throws ClassNotFoundException, JAXBWrapperException, JAXBException, javax.xml.stream.XMLStreamException, MessageException{
-		Class wrapperClazz = proxyDescriptor.getResponseWrapperClass(isAsync());
-		String resultName = proxyDescriptor.getWebResultName(isAsync());
-		JAXBContext ctx = JAXBContext.newInstance(new Class[]{wrapperClazz});
-		
-		// Get a JAXBBlockFactory instance.  We'll need this to get the JAXBBlock
-        // out of the Message
-        JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
-        
-        Message responseMsg = response.getMessage();
-        Block resBlock = responseMsg.getBodyBlock(0, ctx, factory);
-		Object bo = resBlock.getBusinessObject(true);
-		
-		//if ReturnType/WrapperClass is assignable from bo then return bo;
-		if(resultName==null && wrapperClazz.isAssignableFrom(bo.getClass())){
-			return bo;
-		}
-		
-		//if ReturnType is not of same type as JAXBBlock business Object then I will look for resultName in Business Object and return that.
-		return getWebResultObject(wrapperClazz, bo, resultName);
-			
-	}
-	
-	/**
-	 * CreateDocLitNONWrappedResponse creates return result that client expects from the method call. This method reads the method return type
-	 * or uses webResult annotation and creates JAXBBlock from the response context and returns the business object associated with the JAXBBlock.
-	 * @param method
-	 * @param response
-	 * @return
-	 */
-	private Object createDocLitNONWrappedResponse(Method method, MessageContext response) throws JAXBWrapperException, JAXBException, MessageException, XMLStreamException{
-		
-		Message responseMsg = response.getMessage();
-		Class returnType = proxyDescriptor.getReturnType(isAsync());
-		JAXBContext ctx = JAXBContext.newInstance(returnType);
-		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
-		Block resBlock = responseMsg.getBodyBlock(0, ctx, factory);
-		Object bo = null;
-		try{
-			 bo = resBlock.getBusinessObject(true);
-		}catch(Exception e){
-			//FIXME: this is the bare case where child of body is not a method but a primitive data type. Reader from Block is throwing exception.
-			OMElement om = resBlock.getOMElement();
-			
-			XMLInputFactory xmlFactory = XMLInputFactory.newInstance();
-			
-			Unmarshaller u = ctx.createUnmarshaller();
-			Reader inputReader = new InputStreamReader(new ByteArrayInputStream(om.toString().getBytes()));
-			XMLStreamReader sr = xmlFactory.createXMLStreamReader(inputReader);
-			JAXBElement o =u.unmarshal(sr, returnType);
-			bo = o.getValue();
-		}
-		if(returnType.isAssignableFrom(bo.getClass())){
-			return bo;
-		}
-		//If returnType is different than JAXBBlock Business Object, I will look for resultName in BusinessObject and return that.
-		String resultName = proxyDescriptor.getWebResultName(isAsync());
-		return getWebResultObject(returnType, bo, resultName);
-	}
-	
-	private Block createJAXBBlock(Object jaxbObject, JAXBContext context) throws MessageException{
-		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
-		return factory.createFrom(jaxbObject,context,null);
-		
-	}
-	
-	private Block createJAXBBlock(String name, Object jaxbObject, JAXBContext context) throws MessageException{
-		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
-		JAXBIntrospector introspector = context.createJAXBIntrospector();
-		if(introspector.isElement(jaxbObject)){
-			return factory.createFrom(jaxbObject, context, null);
-		}
-		else{
-			Class clazz = jaxbObject.getClass();
-			String tns = proxyDescriptor.getParamtns(name);
-			JAXBElement<Object> element = new JAXBElement<Object>(new QName(tns, name), clazz, jaxbObject);
-			return factory.createFrom(element,context,null);
-		}
-		
-	}
-	
-	private Block createEmptyBodyBlock() throws MessageException{
-		String emptyBody = "";
-		XMLStringBlockFactory stringFactory = (XMLStringBlockFactory) FactoryRegistry.getFactory(XMLStringBlockFactory.class);
-		return stringFactory.createFrom(emptyBody, null, SOAPENV_QNAME);
-	}
-	
-	private Block createJAXBBlock(OMElement om, JAXBContext context)throws javax.xml.stream.XMLStreamException{
-		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
-		return factory.createFrom(om,context,null);
-		
-	}
-
-	
-	
-	/** 
-	 * reads PropertyDescritpr and invokes  get method on result property and returns the object.
-	 * @param wrapperClazz
-	 * @param businessObject
-	 * @param propertyName
-	 * @return
-	 * @throws NoSuchFieldException
-	 * @throws IntrospectionException
-	 * @throws InvocationTargetException
-	 * @throws IllegalAccessException
-	 */
-	private Object getWebResultObject(Class wrapperClazz, Object businessObject, String propertyName) throws JAXBWrapperException{
-		
-		JAXBWrapperTool wrapTool = new JAXBWrapperToolImpl();
-		if (log.isDebugEnabled()) {
-            log.debug("Attempting to unwrap object from WrapperClazz: "+wrapperClazz);
-        }
-		Object[] webResult = wrapTool.unWrap(businessObject,new ArrayList<String>(Arrays.asList(new String[]{propertyName})));
-		if (log.isDebugEnabled()) {
-            log.debug("Object unwrapped");
-        }
-		return webResult[0];
-		
-	}
-	
-	private MessageContext initializeRequest(Block messageBlock) throws XMLStreamException, MessageException{
-		MessageContext request = new MessageContext();
-		MessageFactory mf = (MessageFactory)FactoryRegistry.getFactory(MessageFactory.class);
-		//FIXME: The protocol should actually come from the binding information included in
-        // either the WSDL or an annotation.
-		Message m = mf.create(Protocol.soap11);
-		m.setBodyBlock(0,messageBlock);
-		request.setMessage(m);
-		request.getProperties().putAll(getRequestContext());
-	
-		return request;
-		
-	}
-	
-	private boolean isDocLitBare(){
-		/* TODO: if(EndPoinInterfaceDescriptor.clientCall == Doc/literal) && OperationDescriptor.isWrapped() == false){ 
-		 * return true; 
-		 * else
-		 * return false;
-		 */
-		return proxyDescriptor.isClazzDocLitBare();
-	}
-	
-	private boolean isDocLitWrapped(){
-		/* TODO: if(EndPoinInterfaceDescriptor.clientCall == Doc/literal) && OperationDescriptor.isWrapped() == true){ 
-		 * return true; 
-		 * else
-		 * return false;
-		 */
-		return proxyDescriptor.isClazzDocLitWrapped();
-	}
-	
-	public ArrayList<String> getParamNames(Object[] objects){ 
-        ArrayList<String> names = proxyDescriptor.getParamNames();
-        //TODO Should this logic be moved to Operation Description.
-        argList = null;
-		ArrayList<Object> paramValues = createArgList(names, objects);
-		if(names.size() == paramValues.size()){
-			return names;
-		}
-		if(names.size() > 0 && names.size() != paramValues.size()){
-			throw ExceptionFactory.makeWebServiceException(Messages.getMessage("InvalidWebParams"));
-		}
-		//if no webparams found but there method has input parameter I will create default input param names. Java reflection does not allow reading
-		//formal parameter names, hence I will create defautl argument names to be arg0, arg1 ....
-		int i=0;
-		if(names.size() ==0){
-			for(Object paramValue:paramValues){
-				names.add(DEFAULT_ARG + i++);
-			}
-		}
-		return names;
-	}
-	//TODO: Should we move this to OperationDescription.
-	public Map<String, Object> getParamValues(Object[] objects, ArrayList<String> names){
-		Map<String, Object> values = new HashMap<String, Object>();
-		
-		if(objects == null){
-			return values;
-		}
-		//if object array not null check if there is only AsyncHandler object param, if yes then its Async call 
-		//with no parameter. Lets filter AsyncHandler and check for return objects, if they are 0 return value;
-		ArrayList<Object> paramValues = createArgList(names, objects);
-		
-		//@webparams and paramValues identified in method should match. 
-		if(names.size() > 0 && names.size() != paramValues.size()){
-			throw ExceptionFactory.makeWebServiceException(Messages.getMessage("InvalidWebParams"));
-		}
-		
-		if(paramValues.size() == 0){
-			//No method parameters
-			return values;
-		}
-		//If no webParam annotation defined read default names of the object and let's use those.
-		boolean readDefault = false;
-		if(names.size() ==0){
-			readDefault = true;
-		}
-		int i =0;
-		for(Object paramValue: paramValues){
-			if(readDefault){
-				//Java Reflection does not allow you to read names of forma parameter, so I will default the method argument names to arg0, arg1 ....
-				values.put(DEFAULT_ARG + i++, paramValue);
-			}else{
-				values.put(names.get(i++), paramValue);
-			}
-		}
-		return values;
-	}
-	//TODO Implement createNameValuePair method so we can remove getParamName and getParamObject and only call this method once. 
-	private ArrayList<Object> createArgList(ArrayList<String> names, Object[] objects){
-		if(argList !=null){
-			return argList;
-		}
-		argList = new ArrayList<Object>();
-		
-		if(objects == null){
-			return argList;
-		}
-		int i =0;
-		for(Object obj:objects){
-			//skip AsycHandler Object
-			if(obj instanceof AsyncHandler){
-				if(isAsync() && proxyDescriptor.isClazzDocLitBare()){
-					//doeble check and remove the name of AsyncHandler from names list, work around for how wsImport generates doc/lit bare art-effects.
-					names.remove(i);
-				}
-				i++;
-				continue;
-			}
-			
-			argList.add(obj);
-			i++;
-		}
-		return argList;
-	}
-	
-}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/factory/DescriptorFactory.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/factory/DescriptorFactory.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/factory/DescriptorFactory.java	(working copy)
@@ -1,30 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws.client.factory;
-
-import org.apache.axis2.jaxws.client.proxy.ProxyDescriptor;
-import org.apache.axis2.jaxws.description.ServiceDescription;
-
-
-public class DescriptorFactory{
-
-	public ProxyDescriptor create(Class seiClass, ServiceDescription serviceDescription) {
-		// TODO Auto-generated method stub
-		return new ProxyDescriptor(seiClass, serviceDescription);
-	}
-
-}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/factory/ProxyHandlerFactory.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/factory/ProxyHandlerFactory.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/client/factory/ProxyHandlerFactory.java	(working copy)
@@ -1,43 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws.client.factory;
-
-import javax.jws.soap.SOAPBinding.Style;
-
-
-import org.apache.axis2.jaxws.client.proxy.BaseProxyHandler;
-import org.apache.axis2.jaxws.client.proxy.DocLitProxyHandler;
-import org.apache.axis2.jaxws.client.proxy.ProxyDescriptor;
-import org.apache.axis2.jaxws.client.proxy.RPCLitProxyHandler;
-import org.apache.axis2.jaxws.spi.ServiceDelegate;
-
-
-/**
- * ProxyHandler Factory looks at proxy descriptor object and create a doc/lit or rpc/lit proxy handler. 
- */
-public class ProxyHandlerFactory {
-
-	public BaseProxyHandler create(ProxyDescriptor descriptor, ServiceDelegate sd){
-		if(descriptor.getBindingStyle() == Style.DOCUMENT){
-			return new DocLitProxyHandler(descriptor, sd);
-		}
-		if(descriptor.getBindingStyle()== Style.RPC){
-			return new RPCLitProxyHandler(descriptor, sd);
-		}
-		return null;
-	}
-}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/factory/MethodMarshallerFactory.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/factory/MethodMarshallerFactory.java	(revision 0)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/factory/MethodMarshallerFactory.java	(revision 0)
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.marshaller.factory;
+
+import javax.jws.soap.SOAPBinding;
+
+import org.apache.axis2.jaxws.description.EndpointDescription;
+import org.apache.axis2.jaxws.description.OperationDescription;
+import org.apache.axis2.jaxws.description.ServiceDescription;
+import org.apache.axis2.jaxws.marshaller.MethodMarshaller;
+import org.apache.axis2.jaxws.marshaller.impl.DocLitBareMethodMarshallerImpl;
+import org.apache.axis2.jaxws.marshaller.impl.DocLitWrappedMethodMarshallerImpl;
+import org.apache.axis2.jaxws.message.Protocol;
+
+
+public class MethodMarshallerFactory {
+
+	public MethodMarshallerFactory() {
+		super();
+		
+	}
+	
+	public MethodMarshaller createDocLitMethodMarshaller(SOAPBinding.ParameterStyle style, ServiceDescription serviceDesc, EndpointDescription endpointDesc, OperationDescription operationDesc, Protocol protocol){
+		if(style == SOAPBinding.ParameterStyle.WRAPPED){
+			return new DocLitWrappedMethodMarshallerImpl(serviceDesc, endpointDesc, operationDesc, protocol);
+		}
+		if(style == SOAPBinding.ParameterStyle.BARE){
+			return new DocLitBareMethodMarshallerImpl(serviceDesc, endpointDesc, operationDesc, protocol);
+		}
+		return null;
+	}
+	
+	public MethodMarshaller createRPCLitMethodMarshaller(SOAPBinding.ParameterStyle style, ServiceDescription serviceDesc, EndpointDescription endpointDesc, OperationDescription operationDesc, Protocol protocol){
+		throw new UnsupportedOperationException("RPC/LIT not supported");
+	}
+}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/DocLitWrappedMethodMarshallerImpl.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/DocLitWrappedMethodMarshallerImpl.java	(revision 0)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/DocLitWrappedMethodMarshallerImpl.java	(revision 0)
@@ -0,0 +1,204 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.marshaller.impl;
+
+import java.util.ArrayList;
+
+import javax.naming.OperationNotSupportedException;
+import javax.xml.bind.JAXBException;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.axis2.jaxws.description.EndpointDescription;
+import org.apache.axis2.jaxws.description.OperationDescription;
+import org.apache.axis2.jaxws.description.ServiceDescription;
+import org.apache.axis2.jaxws.marshaller.DocLitWrappedMethodMarshaller;
+import org.apache.axis2.jaxws.marshaller.MethodParameter;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.MessageException;
+import org.apache.axis2.jaxws.message.Protocol;
+import org.apache.axis2.jaxws.wrapper.JAXBWrapperTool;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperToolImpl;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+public class DocLitWrappedMethodMarshallerImpl extends MethodMarshallerImpl
+		implements DocLitWrappedMethodMarshaller {
+	private static Log log = LogFactory.getLog(DocLitWrappedMethodMarshallerImpl.class);
+
+	/**
+	 * @param serviceDesc
+	 * @param endpointDesc
+	 * @param operationDesc
+	 */
+	public DocLitWrappedMethodMarshallerImpl(ServiceDescription serviceDesc,
+			EndpointDescription endpointDesc, OperationDescription operationDesc, Protocol protocol) {
+		super(serviceDesc, endpointDesc, operationDesc, protocol);
+		// TODO Auto-generated constructor stub
+	}
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.convertor.impl.MessageConvertorImpl#toJAXBObject(org.apache.axis2.jaxws.message.Message)
+	 */
+	@Override
+	public Object demarshalResponse(Message message, Object[] inputArgs) throws IllegalAccessException, InstantiationException, ClassNotFoundException, JAXBWrapperException, JAXBException, javax.xml.stream.XMLStreamException, MessageException{
+		Class wrapperClazz = null;
+		String className = operationDesc.getResponseWrapperClassName();
+		//TODO Move this to Operation Description.
+		if(className == null || (className!=null && className.length()==0)){
+			wrapperClazz = getReturnType();
+		}
+		else{		
+			wrapperClazz = loadClass(className);
+		}
+		String resultName = operationDesc.getWebResultName();
+		Object bo = createBusinessObject(wrapperClazz, message);
+		createResponseHolders(bo, inputArgs, false);
+		//if result name is null and that means there is no webResult meaning its a void return.
+		if(resultName !=null){
+		//if ReturnType is not of same type as JAXBBlock business Object then I will look for resultName in Business Object and return that.
+			Object resultObject = findProperty(resultName, bo);
+			return resultObject;
+		}
+		return null;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.convertor.impl.MessageConvertorImpl#toObjects(org.apache.axis2.jaxws.message.Message)
+	 */
+	@Override
+	public Object[] demarshalRequest(Message message)throws ClassNotFoundException, JAXBException, MessageException, JAXBWrapperException, XMLStreamException, InstantiationException, IllegalAccessException {
+        String className = operationDesc.getRequestWrapperClassName();
+        Class requestWrapperClazz = loadClass(className);
+        Object jaxbObject = createBusinessObject(requestWrapperClazz, message);
+        
+        if (log.isDebugEnabled()) {
+            log.debug("reading input method parameters");
+        }
+        ArrayList<MethodParameter> mps = toInputMethodParameter(jaxbObject);
+        if (log.isDebugEnabled()) {
+            log.debug("done reading input method parameters");
+        }
+        
+        Object[] contents = new Object[mps.size()];
+        int i =0;
+        for (MethodParameter mp:mps){
+        	contents[i++] =mp.getValue();
+        }
+        
+        if (log.isDebugEnabled()) {
+            log.debug("Object unwrapped");
+        }
+        
+        return contents;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.convertor.impl.MessageConvertorImpl#fromJAXBObject(java.lang.Object)
+	 */
+	@Override
+	public Message marshalResponse(Object returnObject, Object[] holderObjects)throws ClassNotFoundException, JAXBException, MessageException, JAXBWrapperException, XMLStreamException, InstantiationException, IllegalAccessException {
+		Class wrapperClazz = null;
+		String wrapperClazzName = operationDesc.getResponseWrapperClassName();
+		String webResult = operationDesc.getWebResultName();
+		//TODO Move this to Operation Description.
+		if(wrapperClazzName == null || (wrapperClazzName!=null && wrapperClazzName.length()==0)){
+			wrapperClazz = getReturnType();
+			wrapperClazzName = wrapperClazz.getName();
+			if(log.isDebugEnabled()){
+				log.debug("No ResponseWrapper annotation found, using return type of method as response object");
+			}
+		}
+		else{		
+			wrapperClazz = loadClass(wrapperClazzName);
+		}
+		//create all holders list
+		ArrayList<Object> objectList = new ArrayList<Object>();
+		if(holderObjects!=null){
+			objectList = toArrayList(holderObjects);
+			for(Object obj:holderObjects){
+				if(!(isHolder(obj))){
+					objectList.remove(obj);
+				}
+			}
+		}
+		//No Holders found 
+		ArrayList<MethodParameter> mps = new ArrayList<MethodParameter>();
+		if(objectList.size() == 0 && wrapperClazz.getName().equals("void")){
+			//No holders and return type void example --> public void someMethod() I will return empty ResponseWrapper in message body for this case.
+			//doNothing as there is nothing to wrap
+		}
+		if(objectList.size() == 0 && !wrapperClazz.getName().equals("void")){
+			//No holders but a return type example --> public ReturnType someMethod()
+			mps = toOutputMethodParameter(returnObject);
+		}
+		else{
+			//Holders found and return type or no return type. example --> public ReturnType someMethod(Holder<String>) or public void someMethod(Holder<String>)
+			mps = toOutputMethodParameter(returnObject, objectList.toArray());
+		}
+		
+        JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
+        Object wrapper = wrapperTool.wrap(wrapperClazz, 
+        		wrapperClazzName, mps);
+        
+		Message message = createMessage(wrapper, wrapperClazz, wrapperClazzName);
+		return message;
+		
+	}
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.convertor.impl.MessageConvertorImpl#fromObjects(java.lang.Object[])
+	 */
+	@Override
+	public Message marshalRequest(Object[] objects) throws IllegalAccessException, InstantiationException, ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, javax.xml.stream.XMLStreamException {
+		
+		String className = operationDesc.getRequestWrapperClassName();
+		Class wrapperClazz = loadClass(className);
+		String localName = operationDesc.getRequestWrapperLocalName();
+		
+		//Get Name Value pair for input parameter Objects, skip AsyncHandler and identify Holders.
+		ArrayList<MethodParameter> methodParameters = toInputMethodParameters(objects);
+		JAXBWrapperTool wrapTool = new JAXBWrapperToolImpl();
+		if (log.isDebugEnabled()) {
+            log.debug("JAXBWrapperTool attempting to wrap propertes in WrapperClass :" + wrapperClazz);
+        }
+	
+		Object jaxbObject = wrapTool.wrap(wrapperClazz, localName, methodParameters);
+		if (log.isDebugEnabled()) {
+            log.debug("JAXBWrapperTool wrapped following propertes :");
+        }
+		
+		Message message = createMessage(jaxbObject, wrapperClazz, localName);
+		return message;
+	}
+
+	@Override
+	public Object demarshalFaultResponse(Message message) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean isFault(Message message) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public Message marshalFaultResponse(Throwable throwable) {
+		throw new UnsupportedOperationException();
+	}
+	
+}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/DocLitBareMethodMarshallerImpl.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/DocLitBareMethodMarshallerImpl.java	(revision 0)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/DocLitBareMethodMarshallerImpl.java	(revision 0)
@@ -0,0 +1,234 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.marshaller.impl;
+
+import java.util.ArrayList;
+
+import javax.naming.OperationNotSupportedException;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.ws.Holder;
+
+import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.description.EndpointDescription;
+import org.apache.axis2.jaxws.description.OperationDescription;
+import org.apache.axis2.jaxws.description.ServiceDescription;
+import org.apache.axis2.jaxws.i18n.Messages;
+import org.apache.axis2.jaxws.marshaller.DocLitBareMethodMarshaller;
+import org.apache.axis2.jaxws.marshaller.MethodParameter;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.MessageException;
+import org.apache.axis2.jaxws.message.Protocol;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+public class DocLitBareMethodMarshallerImpl extends MethodMarshallerImpl
+		implements DocLitBareMethodMarshaller {
+	private static int SIZE = 1;
+	private static Log log = LogFactory.getLog(DocLitBareMethodMarshallerImpl.class);
+	/**
+	 * @param serviceDesc
+	 * @param endpointDesc
+	 * @param operationDesc
+	 */
+	public DocLitBareMethodMarshallerImpl(ServiceDescription serviceDesc,
+			EndpointDescription endpointDesc, OperationDescription operationDesc, Protocol protocol) {
+		super(serviceDesc, endpointDesc, operationDesc, protocol);
+		// TODO Auto-generated constructor stub
+	}
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.convertor.impl.MessageConvertorImpl#toJAXBObject(org.apache.axis2.jaxws.message.Message)
+	 */
+	@Override
+	public Object demarshalResponse(Message message, Object[] inputArgs) throws IllegalAccessException, InstantiationException, ClassNotFoundException, JAXBWrapperException, JAXBException, XMLStreamException, MessageException{
+		
+		Class returnType = getReturnType();
+		String resultName = operationDesc.getWebResultName();
+		Object bo = null;
+		if(returnType.getName().equals("void")){
+			ArrayList<MethodParameter> mps = toInputMethodParameters(inputArgs);
+			for(MethodParameter mp:mps){
+				if(mp.isHolder()){
+					returnType = mp.getActualType();
+				}
+			}
+			
+		}
+		bo = createBusinessObject(returnType, message);
+		//In a bare case there should not be a situation where there is a return type and a holder.
+		createResponseHolders(bo, inputArgs, true);
+		
+		return bo;
+		
+	}
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.convertor.impl.MessageConvertorImpl#toObjects(org.apache.axis2.jaxws.message.Message)
+	 */
+	@Override
+	public Object[] demarshalRequest(Message message)throws ClassNotFoundException, JAXBException, MessageException, JAXBWrapperException, XMLStreamException, InstantiationException, IllegalAccessException{
+		
+		ArrayList<Class> inputParams = getInputTypes();
+		//Method has no input parameters
+		if(inputParams.size() == 0){
+			return null;
+		}
+		if(inputParams.size() > SIZE){
+			if (log.isDebugEnabled()) {
+	            log.debug("As per WS-I compliance, Multi part WSDL not allowed for Doc/Lit NON Wrapped request, Method invoked has multiple input parameter");
+	        }
+			throw ExceptionFactory.makeWebServiceException(Messages.getMessage("DocLitProxyHandlerErr1"));
+		}
+		
+		Class jaxbClass = inputParams.get(0);
+		
+		Object jaxbObject = createBusinessObject(jaxbClass, message);
+        
+        if (log.isDebugEnabled()) {
+            log.debug("reading input method parameters");
+        }
+        Class rawType = operationDesc.getSEIMethod().getParameterTypes()[0];
+       
+        if(isHolder(rawType)){
+        	
+        	return new Object[]{createHolder(rawType, jaxbObject)};
+        }
+        else{
+        	return new Object[]{jaxbObject};
+        }
+       
+		
+	}
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.convertor.impl.MessageConvertorImpl#fromJAXBObject(java.lang.Object)
+	 */
+	@Override
+	public Message marshalResponse(Object returnObject, Object[] holderObjects) throws ClassNotFoundException, JAXBException, MessageException, JAXBWrapperException, XMLStreamException, InstantiationException, IllegalAccessException{
+		// Response wrapper is basically the return type. so the return object is a jaxbObject. If there is a holder objects then that is the responsewrapper.
+		Class wrapperClazz = getReturnType();
+		String wrapperClazzName = wrapperClazz.getName();
+		String webResult = operationDesc.getWebResultName();
+		
+		//create all holders list
+		ArrayList<Object> objectList = new ArrayList<Object>();
+		if(holderObjects!=null){
+			objectList = toArrayList(holderObjects);
+			for(Object obj:holderObjects){
+				if(!(isHolder(obj))){
+					objectList.remove(obj);
+				}
+			}
+		}
+		if(objectList.size()> SIZE){
+			//More than one holder input parameter found, this is a WS-I violation.
+			if (log.isDebugEnabled()) {
+	            log.debug("As per WS-I compliance, Multi part WSDL not allowed for Doc/Lit NON Wrapped request, Method invoked has multiple input parameter");
+	        }
+			throw ExceptionFactory.makeWebServiceException(Messages.getMessage("DocLitProxyHandlerErr1"));
+		}
+		Message message = null;
+		ArrayList<MethodParameter> mps = new ArrayList<MethodParameter>();
+		if(objectList.size() == 0 && wrapperClazz.getName().equals("void")){
+			//No holders and return type void example --> public void someMethod() I will return empty ResponseWrapper in message body for this case.
+			//doNothing as there is nothing to wrap
+		
+		}
+		if(objectList.size() == 0 && !wrapperClazz.getName().equals("void")){
+			//No holders but a return type example --> public ReturnType someMethod()
+			
+			message = createMessage(returnObject, wrapperClazz, wrapperClazzName);
+		}
+		else{
+			//Holders found and return type or no return type. example --> public ReturnType someMethod(Holder<AHolder>) or public void someMethod(Holder<AHolder>)
+			//Note that SEI implementation will wrap return type in a holder if method has a return type and input param as holder.
+			//WSGen and WsImport Generate Holders with return type as one of the Holder JAXBObject property, if wsdl schema forces a holder and a return type.
+			ArrayList<Class> holderType = getInputTypes();
+			Holder holder = (Holder)objectList.get(0);
+			Object value = holder.value;
+			message = createMessage(value, holderType.get(0), holderType.get(0).getName());
+		}
+		
+		return message;
+		
+	}
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.convertor.impl.MessageConvertorImpl#fromObjects(java.lang.Object[])
+	 */
+	@Override
+	public Message marshalRequest(Object[] objects) throws IllegalAccessException, InstantiationException, ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, javax.xml.stream.XMLStreamException{
+		
+		
+		ArrayList<MethodParameter> mps = toInputMethodParameters(objects);
+		
+		//WSDL wrapped and running wsImport with non-wrap binding or wsdl un-Wrapped and running wsImport with no binding, EITHER WAYS 
+		//there can be only 0 or 1 Body parts as per WS-I. 
+		if(mps.size()> SIZE){
+			if (log.isDebugEnabled()) {
+	            log.debug("As per WS-I compliance, Multi part WSDL not allowed for Doc/Lit NON Wrapped request, Method invoked has multiple input parameter");
+	        }
+			throw ExceptionFactory.makeWebServiceException(Messages.getMessage("DocLitProxyHandlerErr1"));
+		}
+		
+		//Lets handle case where there is one message part or one input parameter
+		Message message = null;
+		if(mps.size() !=0){
+			Object requestObject = null;
+			String requestObjectName = null;
+			Class requestObjectType = null;
+			JAXBContext ctx = null;
+			for(MethodParameter mp : mps){
+				requestObject = mp.getValue();
+				requestObjectName = mp.getName();
+				requestObjectType = mp.getActualType();
+				if(requestObject == null){
+					if (log.isDebugEnabled()) {
+			            log.debug("Method Input parameter for NON Wrapped Request cannot be null");
+			        }
+					throw ExceptionFactory.makeWebServiceException(Messages.getMessage("DocLitProxyHandlerErr2"));
+				}
+			}
+				
+			message = createMessage(requestObject, requestObjectType, requestObjectName);
+		}
+		//no message part case or no input parameter
+		if(mps.size() == 0){
+			message = createEmptyMessage();
+		}
+		
+		return message;
+	}
+
+	@Override
+	public Object demarshalFaultResponse(Message message) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean isFault(Message message) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public Message marshalFaultResponse(Throwable throwable) {
+		throw new UnsupportedOperationException();
+	}
+}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/MethodMarshallerImpl.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/MethodMarshallerImpl.java	(revision 0)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/MethodMarshallerImpl.java	(revision 0)
@@ -0,0 +1,588 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.marshaller.impl;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.concurrent.Future;
+
+import javax.jws.WebParam.Mode;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBElement;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.JAXBIntrospector;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.annotation.XmlRootElement;
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+import javax.xml.ws.AsyncHandler;
+import javax.xml.ws.Holder;
+import javax.xml.ws.Response;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.description.EndpointDescription;
+import org.apache.axis2.jaxws.description.OperationDescription;
+import org.apache.axis2.jaxws.description.ServiceDescription;
+import org.apache.axis2.jaxws.i18n.Messages;
+import org.apache.axis2.jaxws.marshaller.MethodMarshaller;
+import org.apache.axis2.jaxws.marshaller.MethodParameter;
+import org.apache.axis2.jaxws.message.Block;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.MessageException;
+import org.apache.axis2.jaxws.message.Protocol;
+import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
+import org.apache.axis2.jaxws.message.factory.MessageFactory;
+import org.apache.axis2.jaxws.message.factory.XMLStringBlockFactory;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
+import org.apache.axis2.jaxws.wrapper.JAXBWrapperTool;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperToolImpl;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+public abstract class MethodMarshallerImpl implements MethodMarshaller {
+
+	private static String DEFAULT_ARG="arg";
+	private static QName SOAPENV_QNAME = new QName("http://schemas.xmlsoap.org/soap/envelope/", "Envelope");
+	private static Log log = LogFactory.getLog(MethodMarshallerImpl.class);
+	protected ServiceDescription serviceDesc = null;
+	protected EndpointDescription endpointDesc = null;
+	protected OperationDescription operationDesc = null;
+	protected Protocol protocol = Protocol.soap11;
+	
+	public MethodMarshallerImpl(ServiceDescription serviceDesc, EndpointDescription endpointDesc, OperationDescription operationDesc, Protocol protocol){
+		this.serviceDesc = serviceDesc;
+		this.endpointDesc = endpointDesc;
+		this.operationDesc = operationDesc;
+		this.protocol = protocol;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.helper.XMLMessageConvertor#toJAXBObject(org.apache.axis2.jaxws.message.Message)
+	 */
+	public abstract Object demarshalResponse(Message message, Object[] inputArgs) throws IllegalAccessException, InstantiationException, ClassNotFoundException, JAXBWrapperException, JAXBException, XMLStreamException, MessageException; 
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.helper.XMLMessageConvertor#toObjects(org.apache.axis2.jaxws.message.Message)
+	 */
+	public abstract Object[] demarshalRequest(Message message) throws ClassNotFoundException, JAXBException, MessageException, JAXBWrapperException, XMLStreamException, InstantiationException, IllegalAccessException;
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.helper.XMLMessageConvertor#fromJAXBObject(java.lang.Object)
+	 */
+	public abstract Message marshalResponse(Object returnObject, Object[] holderObjects)throws ClassNotFoundException, JAXBException, MessageException, JAXBWrapperException, XMLStreamException, InstantiationException, IllegalAccessException; 
+	
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.helper.XMLMessageConvertor#fromObjects(java.lang.Object[])
+	 */
+	public abstract Message marshalRequest(Object[] object)throws IllegalAccessException, InstantiationException, ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, XMLStreamException; 
+	
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.marshaller.MethodMarshaller#demarshalFaultResponse(org.apache.axis2.jaxws.message.Message)
+	 */
+	public abstract Object demarshalFaultResponse(Message message); 
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.marshaller.MethodMarshaller#isFault(org.apache.axis2.jaxws.message.Message)
+	 */
+	public abstract boolean isFault(Message message); 
+		
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.marshaller.MethodMarshaller#marshalFaultResponse(java.lang.Throwable)
+	 */
+	public abstract Message marshalFaultResponse(Throwable throwable); 
+		
+	/*
+	 * Creates method output parameter/return parameter. reads webResult annotation and then matches them with the response/result value of Invoked method
+	 * and creates a name value pair.
+	 * Also hadnles situation where ResponseWrapper is a holder.
+	 */
+	
+	protected ArrayList<MethodParameter> toOutputMethodParameter(Object webResultValue){
+		ArrayList<MethodParameter> mps = new ArrayList<MethodParameter>();
+		String webResult = operationDesc.getWebResultName();
+		MethodParameter mp = new MethodParameter(webResult, webResultValue, null);
+		mps.add(mp);
+		return mps;
+	}
+	
+	protected ArrayList<MethodParameter> toOutputMethodParameter(Object webResultObject, Object[] holderObjects)throws IllegalAccessException, InstantiationException, ClassNotFoundException{
+		//Get all names of input parameters
+		ArrayList<String> paramNames = new ArrayList<String>();
+		paramNames =toArrayList(operationDesc.getWebParamNames());
+		
+		//Get all modes for params
+		ArrayList<Mode> paramMode = new ArrayList<Mode>();
+		paramMode = toArrayList(operationDesc.getWebParamModes());
+		
+		Method seiMethod = operationDesc.getSEIMethod();
+	    Class[] types = seiMethod.getParameterTypes();
+	    ArrayList<Class> paramTypes = toArrayList(types);
+	    ArrayList<Class> actualTypes = getInputTypes();
+	    
+		for(int i =0;i<types.length; i++){
+			if(!(types[i].isAssignableFrom(Holder.class))){
+				paramNames.remove(i);
+				paramMode.remove(i);
+				paramTypes.remove(i);
+			}
+		}
+		
+		ArrayList<Object> paramValues = toArrayList(holderObjects);
+		if(webResultObject!=null){
+			paramValues.add(webResultObject);
+			paramNames.add(operationDesc.getWebResultName());
+			//dummy mode for return object
+			paramMode.add(Mode.IN);
+		}
+		//lets create name value pair.
+		return createMethodParameters(paramNames, paramValues, paramMode, paramTypes, actualTypes);
+		
+	}
+	
+	protected ArrayList<MethodParameter> toInputMethodParameter(Object jaxbObject) throws JAXBWrapperException, IllegalAccessException, InstantiationException, ClassNotFoundException{
+		ArrayList<MethodParameter> mps = new ArrayList<MethodParameter>();
+		if(jaxbObject == null){
+			return mps;
+		}
+        ArrayList<String> webParam = toArrayList(operationDesc.getWebParamNames());
+        ArrayList<Mode> modes = toArrayList(operationDesc.getWebParamModes());
+        
+        if (log.isDebugEnabled()) {
+            log.debug("Attempting to unwrap object from WrapperClazz");
+        }
+        JAXBWrapperTool wrapperTool = new JAXBWrapperToolImpl();
+        Object[] objects = wrapperTool.unWrap(jaxbObject, webParam);
+        if (log.isDebugEnabled()) {
+            log.debug("Object unwrapped");
+        }
+        return toInputMethodParameters(objects);
+	}
+	/*
+	 * Creates method input parameters, reads webparam annotation and then matches them to the input parameters that the the invoked method was supplied 
+	 * and creates a name value pair.
+	 */
+	protected ArrayList<MethodParameter> toInputMethodParameters(Object[] objects)throws IllegalAccessException, InstantiationException, ClassNotFoundException{
+		ArrayList<MethodParameter> mps = new ArrayList<MethodParameter>();
+		//Hand no input parameters
+		if(objects == null){
+			return mps;
+		}
+		if(objects!=null && objects.length==0){
+			return mps;
+		}
+		
+		//Get all names of input parameters
+		ArrayList<String> paramNames = new ArrayList<String>();
+		paramNames =toArrayList(operationDesc.getWebParamNames());
+		//Get all the objects of input parameters
+		ArrayList<Object> paramValues = new ArrayList<Object>(); 
+		paramValues = toArrayList(objects);
+		//Get all modes for params
+		ArrayList<Mode> paramMode = new ArrayList<Mode>();
+		paramMode = toArrayList(operationDesc.getWebParamModes());
+		
+		Method seiMethod = operationDesc.getSEIMethod();
+		
+		Class[] clazz = seiMethod.getParameterTypes();
+		ArrayList<Class> paramTypes = toArrayList(clazz);
+     
+		ArrayList<Class> actualTypes = getInputTypes();
+		int i =0;
+		
+		//if no webParam defined then lets get default names.
+		if(paramNames.size() == 0 && paramValues.size()>0){
+			while(i< paramValues.size()){
+				paramNames.add(DEFAULT_ARG + i++);
+			}
+		}
+		if(paramNames.size() != paramValues.size()){
+			throw ExceptionFactory.makeWebServiceException(Messages.getMessage("InvalidWebParams"));
+		}
+		//lets create name value pair.
+		mps = createMethodParameters(paramNames, paramValues, paramMode, paramTypes, actualTypes);
+		
+		return mps;
+	}
+	
+	protected ArrayList<Class> getInputTypes(){
+		Method seiMethod = operationDesc.getSEIMethod();
+		ArrayList<Class> paramTypes = new ArrayList<Class>();
+		Type[] types = seiMethod.getGenericParameterTypes();
+		for(Type type:types){
+			if(ParameterizedType.class.isAssignableFrom(type.getClass())){
+				ParameterizedType pType = (ParameterizedType) type;
+				Class rawClazz = (Class)pType.getRawType();
+				Class actualClazz = (Class)pType.getActualTypeArguments()[0];
+				paramTypes.add(actualClazz);
+				/*
+				if(rawClazz.isAssignableFrom(Holder.class)){
+					Class actualClazz = (Class)pType.getActualTypeArguments()[0];
+					paramTypes.add(actualClazz);
+				}
+				*/
+			}
+			else{
+				Class formalClazz= (Class)type;
+				paramTypes.add(formalClazz);
+			}
+		}
+		return paramTypes;
+	}
+	
+	protected boolean isAsync(){
+		Method method = operationDesc.getSEIMethod();
+		if(method == null){
+			return false;
+		}
+		String methodName = method.getName();
+		Class returnType = method.getReturnType();
+		return methodName.endsWith("Async") && (returnType.isAssignableFrom(Response.class) || returnType.isAssignableFrom(Future.class));
+	}
+	
+	protected boolean isXmlRootElementDefined(Class jaxbClass){
+		XmlRootElement root = (XmlRootElement) jaxbClass.getAnnotation(XmlRootElement.class);
+		return root !=null;
+	}
+	
+	protected <T> ArrayList<T> toArrayList(T[] objects){
+		return (objects!=null)? new ArrayList<T>(Arrays.asList(objects)):new ArrayList<T>();
+	}
+	
+	protected Block createJAXBBlock(Object jaxbObject, JAXBContext context) throws MessageException{
+		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
+		return factory.createFrom(jaxbObject,context,null);
+		
+	}
+	
+	protected Block createJAXBBlock(String name, Object jaxbObject, JAXBContext context) throws MessageException{
+		
+		JAXBIntrospector introspector = context.createJAXBIntrospector();
+		if(introspector.isElement(jaxbObject)){
+			return createJAXBBlock(jaxbObject, context);
+		}
+		else{
+			//Create JAXBElement then use that to create JAXBBlock.
+			Class clazz = jaxbObject.getClass();
+			JAXBElement<Object> element = new JAXBElement<Object>(new QName(name), clazz, jaxbObject);
+			JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
+			return factory.createFrom(element,context ,null);
+		}
+		
+	}
+	protected Block createJAXBBlock(OMElement om, JAXBContext context)throws javax.xml.stream.XMLStreamException{
+		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
+		return factory.createFrom(om,context,null);
+		
+	}
+
+	protected Block createEmptyBodyBlock()throws MessageException{
+		String emptyBody = "";
+		XMLStringBlockFactory stringFactory = (XMLStringBlockFactory) FactoryRegistry.getFactory(XMLStringBlockFactory.class);
+		return stringFactory.createFrom(emptyBody, null, SOAPENV_QNAME);
+	}
+	
+	protected JAXBContext createJAXBContext(String wrapperClazzName) throws ClassNotFoundException, JAXBException {
+		Class wrapperClazz = loadClass(wrapperClazzName);
+		return createJAXBContext(wrapperClazz);
+        
+    }
+	
+	protected JAXBContext createJAXBContext(Class wrapperClazz) throws JAXBException{
+		return JAXBContext.newInstance(new Class[]{wrapperClazz});
+	}
+	
+	protected Class loadClass(String className)throws ClassNotFoundException{
+		return Class.forName(className, true, Thread.currentThread().getContextClassLoader());
+	}
+	/**
+	 * In this method I am trying get the return type of the method.
+	 * if SEI method is Async pooling implmentation then return type is actual type in Generic Response, example Response<ClassName>.
+	 * if SEI method is Async Callback implementation then return type is actual type of method parameter type AsyncHandler, example AsyncHandler<ClassName>
+	 * I use java reflection to get the return type.
+	 * @param isAsync
+	 * @return
+	 */
+	protected Class getReturnType(){
+		Method seiMethod = operationDesc.getSEIMethod();
+		Class returnType = seiMethod.getReturnType();
+		if(isAsync()){
+			//pooling implementation
+			if(Response.class.isAssignableFrom(returnType)){
+				Type type = seiMethod.getGenericReturnType();
+				ParameterizedType pType = (ParameterizedType) type;
+				return (Class)pType.getActualTypeArguments()[0];	
+			}
+			//Callback Implementation
+			else{
+				Type[] type = seiMethod.getGenericParameterTypes();
+				Class parameters[]= seiMethod.getParameterTypes();
+				int i=0;
+				for(Class param:parameters){
+					if(AsyncHandler.class.isAssignableFrom(param)){
+						ParameterizedType pType = (ParameterizedType)type[i];
+						return (Class)pType.getActualTypeArguments()[0];
+					}
+					i++;
+				}
+			}
+			
+		}
+		
+		return returnType;	
+	}
+	
+	protected ArrayList<MethodParameter> createMethodParameters(ArrayList<String> paramNames, ArrayList<Object>paramValues, ArrayList<Mode> paramModes, ArrayList<Class> paramTypes, ArrayList<Class> actualTypes) throws IllegalAccessException, InstantiationException, ClassNotFoundException{
+		ArrayList<MethodParameter> mps = new ArrayList<MethodParameter>();
+		int i=0;
+		for(String paramName:paramNames){
+			Object paramValue = paramValues.get(i);
+			
+			//initialize to default value.
+			Mode paramMode = Mode.IN;
+			if(paramModes !=null && paramModes.size() >0){
+				paramMode =paramModes.get(i);
+			}
+			Class paramType = null;
+			Class actualType = null;
+			if(paramTypes !=null){
+				paramType = paramTypes.get(i);
+			}
+			if(actualTypes!=null){
+				actualType = actualTypes.get(i);
+			}
+			MethodParameter mp = null;
+			//If call is Async call then lets filter AsyncHandler object name and value;
+			if(!isParamAsyncHandler(paramName, paramValue)){
+				
+				if(paramType !=null){
+					//Identify Holders and get Holder Values, this if condition will mostly execute during client side call
+					if(isHolder(paramValue) && isHolder(paramType)){
+						Object holderValue = getHolderValue(paramMode, paramValue);
+						mp = new MethodParameter(paramName, holderValue, paramMode, paramType, actualType, true);
+						
+					}
+					//Identify that param value is not Holders however if the method parameter is holder type and create Holder, this will mostly be called during server side call 
+					else if(!isHolder(paramValue) && isHolder(paramType)){
+						Holder<Object> holder = createHolder(paramType, paramValue);
+						mp=new MethodParameter(paramName, holder, paramMode, paramType, actualType, true);
+					}
+					else{
+						mp = new MethodParameter(paramName, paramValue, paramMode, paramType, actualType, false);
+					}
+				}
+				if(paramType == null){
+					if(isHolder(paramValue)){
+						Object holderValue = getHolderValue(paramMode, paramValue);
+						mp = new MethodParameter(paramName, holderValue, paramMode);	
+					}
+					else{
+						mp = new MethodParameter(paramName, paramValues, paramMode);
+					}
+				}
+				mps.add(mp);
+			}
+			
+			i++;
+		}
+		return mps;
+	}
+	
+	private boolean isParamAsyncHandler(String name, Object value){
+		//TODO I would like to check the name of the parameter to "asyncHandler" As per the JAX-WS specification
+		//However the RI tooling has a bug where it generates partName="asyncHandler" for doc/lit bare case instead of name="asyncHandler".
+		//Once fixed we can also check for name but for now this will work
+		if(value!=null && value instanceof AsyncHandler){
+			if(log.isDebugEnabled()){
+				log.debug("Parameter is AsycnHandler Object");
+			}
+			if(!isAsync()){
+				if (log.isDebugEnabled()) {
+		            log.debug("Method parameter type javax.xml.ws.AsyncHandler should only be used with Async Callback operations, method is Async if it returns a Future<?> and endswith letters 'Async'");
+		        }
+				throw ExceptionFactory.makeWebServiceException(Messages.getMessage("DocLitProxyHandlerErr3"));
+			}
+			return true;
+		}
+		return false;
+		
+	}
+	
+	protected boolean isHolder(Object value){
+		return value!=null && Holder.class.isAssignableFrom(value.getClass());
+	}
+	
+	protected boolean isHolder(Class type){
+		return type!=null && Holder.class.isAssignableFrom(type);
+	}
+	protected Object getHolderValue(Mode mode, Object value){
+		if(!Holder.class.isAssignableFrom(value.getClass())){
+			if(log.isDebugEnabled()){
+				log.debug("Object Not a Holder type");
+			}
+			ExceptionFactory.makeWebServiceException(Messages.getMessage("DocLitProxyHandlerErr5"));
+		}
+		if(mode !=null && mode.equals(Mode.IN)){
+			if(log.isDebugEnabled()){
+				log.debug("WebParam annotation's Mode cannot be IN for input parameter of type Holder");
+			}
+			throw ExceptionFactory.makeWebServiceException(Messages.getMessage("DocLitProxyHandlerErr4"));
+		}
+		Holder holder = (Holder)value;
+		return holder.value;
+		
+	}
+	
+	protected <T> Holder<T> createHolder(Class paramType, T value) throws IllegalAccessException, InstantiationException, ClassNotFoundException{
+		if(Holder.class.isAssignableFrom(paramType)){
+    		Class holderClazz = loadClass(paramType.getName());
+    		Holder<T> holder = (Holder<T>) holderClazz.newInstance();
+    		holder.value = value;
+    		return holder;
+    	}
+		return null;
+	}
+	
+	protected Message createMessage(Object jaxbObject, Class jaxbClazz, String jaxbClassName)throws JAXBException, MessageException, XMLStreamException{
+		Block bodyBlock = null;
+		JAXBContext ctx = createJAXBContext(jaxbClazz);
+		if (log.isDebugEnabled()) {
+            log.debug("Attempting to create Block");
+        }
+		if(isXmlRootElementDefined(jaxbClazz)){
+			bodyBlock = createJAXBBlock(jaxbObject, ctx);
+		}
+		else{
+			bodyBlock =  createJAXBBlock(jaxbClassName, jaxbObject, ctx);
+		}
+		if (log.isDebugEnabled()) {
+            log.debug("JAXBBlock Created");
+        }
+		
+		MessageFactory mf = (MessageFactory)FactoryRegistry.getFactory(MessageFactory.class);
+		
+		Message m = mf.create(protocol);
+		m.setBodyBlock(0,bodyBlock);
+		return m;
+	}
+	protected Message createEmptyMessage()throws JAXBException, MessageException, XMLStreamException{
+		Block emptyBodyBlock = createEmptyBodyBlock();
+		MessageFactory mf = (MessageFactory)FactoryRegistry.getFactory(MessageFactory.class);
+		Message m = mf.create(protocol);
+		m.setBodyBlock(0,emptyBodyBlock);
+		return m;
+	}
+	
+	protected Object createBusinessObject(Class jaxbClazz, Message message) throws JAXBException, MessageException, XMLStreamException{
+		JAXBContext ctx = createJAXBContext(jaxbClazz);
+		
+		// Get a JAXBBlockFactory instance.  We'll need this to get the JAXBBlock
+        // out of the Message
+        JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
+        
+        Block block = message.getBodyBlock(0, ctx, factory);
+        try{
+        	return block.getBusinessObject(true);
+        }catch(Exception e){
+        //FIXME: this is the bare case where child of body is not a method but a primitive data type. Reader from Block is throwing exception.
+        	block = message.getBodyBlock(0, ctx,factory);
+        	OMElement om = block.getOMElement();
+        	
+        	XMLInputFactory xmlFactory = XMLInputFactory.newInstance();
+		
+        	Unmarshaller u = ctx.createUnmarshaller();
+        	Reader inputReader = new InputStreamReader(new ByteArrayInputStream(om.toString().getBytes()));
+        	XMLStreamReader sr = xmlFactory.createXMLStreamReader(inputReader);
+        	JAXBElement o =u.unmarshal(sr, jaxbClazz);
+        	return o.getValue();
+        
+        }       
+	}
+	
+	protected void createResponseHolders(Object bo, Object[] inputArgs, boolean isBare)throws JAXBWrapperException, InstantiationException, ClassNotFoundException, IllegalAccessException{
+		if(inputArgs == null){
+			return;
+		}
+		ArrayList<Object> objList = toArrayList(inputArgs);
+		for(Object arg:inputArgs){
+			if(arg == null){
+				objList.remove(arg);
+			}
+			else if(arg!=null && !Holder.class.isAssignableFrom(arg.getClass())){
+				objList.remove(arg);
+			}
+			
+		}
+		if(objList.size()<=0){
+			return;
+		}
+		ArrayList<MethodParameter> mps = null;
+		if(isBare){
+			mps = toInputMethodParameters(new Object[]{bo});
+			
+		}
+		else{
+			mps = toInputMethodParameter(bo);
+		}
+			
+		MethodParameter[] mpArray = mps.toArray(new MethodParameter[0]);
+		for(MethodParameter mp:mpArray){
+			if(!mp.isHolder()){
+				mps.remove(mp);
+			}
+		}
+		if(mps.size() <=0){
+			return;
+		}
+		mpArray = null;
+		int index=0;
+		for(Object inputArg: objList){
+			Holder inputHolder = (Holder)inputArg;
+			MethodParameter mp = mps.get(index);
+			Holder responseHolder = (Holder)mp.getValue();
+			inputHolder.value = responseHolder.value;
+			index++;
+		}
+		
+	}
+	
+	protected Object findProperty(String propertyName, Object jaxbObject)throws JAXBWrapperException{
+		JAXBWrapperTool wrapTool = new JAXBWrapperToolImpl();
+		if (log.isDebugEnabled()) {
+            log.debug("Attempting to unwrap objects");
+        }
+		Object[] webResult = wrapTool.unWrap(jaxbObject,new ArrayList<String>(Arrays.asList(new String[]{propertyName})));
+		if (log.isDebugEnabled()) {
+            log.debug("Object unwrapped");
+        }
+		//this is a parameter in JAXBObject
+		return webResult[0];
+	}
+
+	
+	
+}
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/nonwrap/META-INF/services.xml
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/nonwrap/META-INF/services.xml	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/nonwrap/META-INF/services.xml	(working copy)
@@ -4,9 +4,6 @@
    <messageReceiver mep="http://www.w3.org/2004/08/wsdl/in-out" class="org.apache.axis2.jaxws.server.JAXWSMessageReceiver"/>
   </messageReceivers>
   <parameter locked="false" name="ServiceClass">org.apache.axis2.jaxws.sample.nonwrap.DocLitNonWrapPortTypeImpl</parameter>
-  <operation name="invoke" mep="http://www.w3.org/2004/08/wsdl/in-out">
-    <actionMapping/>
-  </operation>
  </service>
 </serviceGroup>
 
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/nonwrap/DocLitNonWrapPortTypeImpl.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/nonwrap/DocLitNonWrapPortTypeImpl.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/nonwrap/DocLitNonWrapPortTypeImpl.java	(working copy)
@@ -66,7 +66,10 @@
 	 * @see org.apache.axis2.jaxws.sample.nonwrap.sei.DocLitNonWrapPortType#twoWayHolder(javax.xml.ws.Holder)
 	 */
 	public void twoWayHolder(Holder<TwoWayHolder> allByMyself) {
-		// TODO Auto-generated method stub
+		//TODO Auto-generated method stub
+		TwoWayHolder twh = allByMyself.value;
+		twh.setTwoWayHolderInt(10);
+		twh.setTwoWayHolderStr("Response String");
 
 	}
 
Index: C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/wrap/DocLitWrapImpl.java
===================================================================
--- C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/wrap/DocLitWrapImpl.java	(revision 453624)
+++ C:/WebServices/Eclipse/workspace/axis2_100406/modules/jaxws/test/org/apache/axis2/jaxws/sample/wrap/DocLitWrapImpl.java	(working copy)
@@ -48,8 +48,10 @@
 	 */
 	public void twoWayHolder(Holder<String> twoWayHolderStr,
 			Holder<Integer> twoWayHolderInt) {
-		// TODO Auto-generated method stub
 
+		twoWayHolderInt.value = 10;
+		twoWayHolderStr.value = "Response String";
+
 	}
 
 	/* (non-Javadoc)
