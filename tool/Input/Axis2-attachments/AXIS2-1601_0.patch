Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/BlockTests.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/BlockTests.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/message/BlockTests.java	(working copy)
@@ -23,6 +23,7 @@
 
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBIntrospector;
+import javax.xml.bind.Marshaller;
 import javax.xml.bind.Unmarshaller;
 import javax.xml.bind.util.JAXBSource;
 import javax.xml.namespace.QName;
@@ -45,6 +46,7 @@
 import org.apache.axiom.om.OMOutputFormat;
 import org.apache.axiom.om.impl.builder.StAXOMBuilder;
 import org.apache.axis2.jaxws.message.databinding.JAXBBlockContext;
+import org.apache.axis2.jaxws.message.databinding.JAXBUtils;
 import org.apache.axis2.jaxws.message.factory.BlockFactory;
 import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
 import org.apache.axis2.jaxws.message.factory.MessageFactory;
@@ -327,7 +329,7 @@
         jaxb.setInput("Hello World");
         JAXBBlockContext context = new JAXBBlockContext(EchoString.class, false);
        
-        JAXBIntrospector jbi = context.getIntrospector();
+        JAXBIntrospector jbi = JAXBUtils.getJAXBIntrospector(context.getJAXBContext());
         QName expectedQName = jbi.getElementName(jaxb);
         
 		// Create a Block using the sample string as the content.  This simulates
@@ -376,7 +378,7 @@
         jaxb.setInput("Hello World");
         JAXBBlockContext context = new JAXBBlockContext(EchoString.class, false);
         
-        JAXBIntrospector jbi = context.getIntrospector();
+        JAXBIntrospector jbi = JAXBUtils.getJAXBIntrospector(context.getJAXBContext());
         QName expectedQName = jbi.getElementName(jaxb);
         
 		// Create a Block using the sample string as the content.  This simulates
@@ -429,7 +431,9 @@
 		// which represents the message.  We will simulate this with inflow.
         StringWriter sw = new StringWriter();
         XMLStreamWriter writer = outputFactory.createXMLStreamWriter(sw);
-        context.getMarshaller().marshal(jaxb, writer);
+        Marshaller marshaller = JAXBUtils.getJAXBMarshaller(context.getJAXBContext());
+        marshaller.marshal(jaxb, writer);
+        JAXBUtils.releaseJAXBMarshaller(context.getJAXBContext(), marshaller);
         writer.flush();
         sw.flush();
 		StringReader sr = new StringReader(sw.toString());
@@ -470,14 +474,16 @@
         jaxb.setInput("Hello World");
         JAXBBlockContext context = new JAXBBlockContext(EchoString.class, false);
 
-        JAXBIntrospector jbi = context.getIntrospector();
+        JAXBIntrospector jbi = JAXBUtils.getJAXBIntrospector(context.getJAXBContext());
         QName expectedQName = jbi.getElementName(jaxb);
 		
 		// On inbound, there will already be a XMLStreamReader (probably from OM)
 		// which represents the message.  We will simulate this with inflow.
         StringWriter sw = new StringWriter();
         XMLStreamWriter writer = outputFactory.createXMLStreamWriter(sw);
-        context.getMarshaller().marshal(jaxb, writer);
+        Marshaller marshaller = JAXBUtils.getJAXBMarshaller(context.getJAXBContext());
+        marshaller.marshal(jaxb, writer);
+        JAXBUtils.releaseJAXBMarshaller(context.getJAXBContext(), marshaller);
         writer.flush();
         sw.flush();
 		StringReader sr = new StringReader(sw.toString());
@@ -524,14 +530,16 @@
         jaxb.setInput("Hello World");
         JAXBBlockContext context = new JAXBBlockContext(EchoString.class, false);
         
-        JAXBIntrospector jbi = context.getIntrospector();
+        JAXBIntrospector jbi = JAXBUtils.getJAXBIntrospector(context.getJAXBContext());
         QName expectedQName = jbi.getElementName(jaxb);
 		
 		// On inbound, there will already be a XMLStreamReader (probably from OM)
 		// which represents the message.  We will simulate this with inflow.
         StringWriter sw = new StringWriter();
         XMLStreamWriter writer = outputFactory.createXMLStreamWriter(sw);
-        context.getMarshaller().marshal(jaxb, writer);
+        Marshaller marshaller = JAXBUtils.getJAXBMarshaller(context.getJAXBContext());
+        marshaller.marshal(jaxb, writer);
+        JAXBUtils.releaseJAXBMarshaller(context.getJAXBContext(), marshaller);
         writer.flush();
         sw.flush();
 		StringReader sr = new StringReader(sw.toString());
Index: C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java	(working copy)
@@ -66,7 +66,7 @@
     
     static {
         // Enable debug
-        //BasicConfigurator.configure();
+        // BasicConfigurator.configure();
     }
     
     /**
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/i18n/resource.properties
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/i18n/resource.properties	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/i18n/resource.properties	(working copy)
@@ -66,8 +66,8 @@
 EndpointControllerErr4=The {0} provider implementation class cannot be loaded due to an error. Processing cannot continue.
 EndpointControllerErr5=A service implementation class cannot be found.
 EndpointControllerErr6=The service is unable to load the {0} service implementation class.
-BlockImplErr1=An internal error occurred. The block for {0} is already consumed. Processing cannot continue.
-XMLPartImplErr1=An internal error occurred. The XML part is already consumed.  Processing cannot continue.
+BlockImplErr1=An internal error occurred. The block for {0} is already consumed. Processing cannot continue.  Run with the debug option to determine where the block was first consumed.
+XMLPartImplErr1=An internal error occurred. The XML part is already consumed.  Processing cannot continue. Run with the debug option to determine where the block was first consumed.
 XMLPartImplErr2=An internal error occurred. The content of the XML part cannot be determined.
 RESTIsNotSupported=The REST protocol is not supported in this version of the system.
 ProtocolIsNotKnown=The protocol has not been set. This error might indicate an internal error in the JAX-WS layer.
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/impl/XMLPartBase.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/impl/XMLPartBase.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/impl/XMLPartBase.java	(working copy)
@@ -36,6 +36,9 @@
 import org.apache.axis2.jaxws.message.XMLPart;
 import org.apache.axis2.jaxws.message.factory.BlockFactory;
 import org.apache.axis2.jaxws.message.factory.SOAPEnvelopeBlockFactory;
+import org.apache.axis2.jaxws.message.util.MessageUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 
 /**
  * XMLPartBase class for an XMLPart
@@ -75,6 +78,8 @@
  */
 public abstract class XMLPartBase implements XMLPart {
 
+	private static Log log = LogFactory.getLog(XMLPartBase.class);
+	
 	Protocol protocol = Protocol.unknown;  // Protocol defaults to unknown
 	
 	// The actual xml representation is always one of the following
@@ -288,7 +293,7 @@
 				reader = omElement.getXMLStreamReader();
 			}
 		}
-		consumed = consume;
+		setConsumed(consume);
 		return reader;
 	}
 
@@ -372,7 +377,7 @@
 				omElement.serialize(writer);
 			}
 		}
-		consumed = consume;
+		setConsumed(consume);
 		return;
 		
 	}
@@ -516,5 +521,17 @@
 		return new XMLSpineImpl(protocol);
 	}
 	
+	private void setConsumed(boolean consume) { 
+		if (consume) {
+			this.consumed = true;
+			if (log.isDebugEnabled()) {
+				log.debug("The follow stack trace indicates where the Block is consumed");
+				log.debug(MessageUtils.stackToString(new RuntimeException()));
+			}
+		} else {
+			consumed = false;
+		}
+	}
 	
+	
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/impl/MessageImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/impl/MessageImpl.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/impl/MessageImpl.java	(working copy)
@@ -220,19 +220,39 @@
      * @see org.apache.axis2.jaxws.message.Message#getAttachment(java.lang.String)
      */
     public Attachment getAttachment(String cid) {
-        if (attachments != null) {
+       if (attachments != null) {
            Iterator<Attachment> itr = attachments.iterator();
            while (itr.hasNext()) {
                Attachment a = itr.next();
-               if (a.getContentID().equals(cid))
+               if (a.getContentID().equals(cid)) {
                    return a;
+               }
            }
        }
         
        return null;
     }
 
+    
 	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.message.Message#removeAttachment(java.lang.String)
+	 */
+    public Attachment removeAttachment(String cid) {
+        if (attachments != null) {
+            Iterator<Attachment> itr = attachments.iterator();
+            while (itr.hasNext()) {
+                Attachment a = itr.next();
+                if (a.getContentID().equals(cid)) {
+                   itr.remove();
+                   return a;
+                }
+            }
+        }
+        
+        return null;
+    }
+
+    /* (non-Javadoc)
 	 * @see org.apache.axis2.jaxws.message.XMLPart#getProtocol()
 	 */
 	public Protocol getProtocol() {
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/impl/XMLPartImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/impl/XMLPartImpl.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/impl/XMLPartImpl.java	(working copy)
@@ -84,32 +84,6 @@
 	protected OMElement _convertSpine2OM(XMLSpine spine) throws MessageException {
 		
 		OMElement omEnvelope = spine.getAsOMElement();
-        // If we have MTOM attachments, we need to replace the <xop:include>
-        // elements with OMText binary nodes.
-        Message msg = getParent();
-        if (msg.isMTOMEnabled()) {
-            // First find all of the <xop:include> elements
-            ArrayList<OMElement> xops = AttachmentUtils.findXopElements(omEnvelope);
-            
-            if (xops != null) {
-                QName href = new QName("","href");
-                Iterator<OMElement> itr = xops.iterator();
-                while (itr.hasNext()) {
-                    OMElement xop = itr.next();
-                    String cid = xop.getAttributeValue(href);
-                    
-                    // Then find their corresponding Attachment object
-                    Attachment a = msg.getAttachment(cid);
-                    
-                    // Convert the <xop:include> OMElement into an OMText
-                    // binary node and replace it in the tree.                    
-                    OMText binaryNode = AttachmentUtils.makeBinaryOMNode(xop, a);
-                    xop.insertSiblingAfter(binaryNode);
-                    xop.detach();
-                }
-            }
-        }
-        
 		return omEnvelope;
 	}
 
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/impl/BlockImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/impl/BlockImpl.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/impl/BlockImpl.java	(working copy)
@@ -31,11 +31,15 @@
 import org.apache.axiom.om.util.StAXUtils;
 import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.i18n.Messages;
+import org.apache.axis2.jaxws.marshaller.impl.MethodMarshallerImpl;
 import org.apache.axis2.jaxws.message.Block;
 import org.apache.axis2.jaxws.message.MessageException;
 import org.apache.axis2.jaxws.message.XMLPart;
 import org.apache.axis2.jaxws.message.factory.BlockFactory;
+import org.apache.axis2.jaxws.message.util.MessageUtils;
 import org.apache.axis2.jaxws.message.util.Reader2Writer;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 
 /**
  * BlockImpl
@@ -56,6 +60,8 @@
  */
 public abstract class BlockImpl implements Block {
 
+	private static Log log = LogFactory.getLog(BlockImpl.class);
+
 	private Object busObject;
 	private Object busContext;
 	
@@ -279,11 +285,11 @@
 			busObject = null;
 			busContext = null;
 			omElement = null;
-			// Create an exception so that we can print a stack trace.
-			//Exception e = new RuntimeException();
-			//System.out.println("consumed block " + this.getClass() + " at ");
-			//e.printStackTrace(System.out);
-			
+			if (log.isDebugEnabled()) {
+				// The following stack trace consumes indicates where the message is consumed
+				log.debug("The follow stack trace indicates where the Block is consumed");
+				log.debug(MessageUtils.stackToString(new RuntimeException()));
+			}
 		} else {
 			consumed = false;
 		}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/Message.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/Message.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/Message.java	(working copy)
@@ -77,8 +77,21 @@
      */
     public Attachment getAttachment(String cid);
     
+    /** 
+     * Get the attachment and remove it from the Message
+     * @param cid
+     * @return
+     */
+    public Attachment removeAttachment(String cid);
+    
+    /**
+     * @return if this is an MTOM message
+     */
     public boolean isMTOMEnabled();
     
+    /** Indicate whether this is an MTOM message
+     * @param b
+     */
     public void setMTOMEnabled(boolean b);
     
     /**
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/JAXBBlockImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/JAXBBlockImpl.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/JAXBBlockImpl.java	(working copy)
@@ -32,6 +32,7 @@
 import javax.xml.stream.XMLStreamWriter;
 
 import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.util.StAXUtils;
 import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.message.Message;
 import org.apache.axis2.jaxws.message.MessageException;
@@ -40,6 +41,7 @@
 import org.apache.axis2.jaxws.message.attachments.JAXBAttachmentUnmarshaller;
 import org.apache.axis2.jaxws.message.databinding.JAXBBlock;
 import org.apache.axis2.jaxws.message.databinding.JAXBBlockContext;
+import org.apache.axis2.jaxws.message.databinding.JAXBUtils;
 import org.apache.axis2.jaxws.message.factory.BlockFactory;
 import org.apache.axis2.jaxws.message.impl.BlockImpl;
 import org.apache.commons.logging.Log;
@@ -54,8 +56,6 @@
 
     private static final Log log = LogFactory.getLog(JAXBBlockImpl.class);
     
-	protected static XMLInputFactory inputFactory = XMLInputFactory.newInstance();
-	protected static XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
 	/**
 	 * Called by JAXBBlockFactory
 	 * @param busObject
@@ -83,12 +83,11 @@
 
 	@Override
 	protected Object _getBOFromReader(XMLStreamReader reader, Object busContext) throws XMLStreamException, MessageException {
-		try {
-			// Get the JAXBBlockContext.  All of the necessry information is recorded on it
-			JAXBBlockContext ctx = (JAXBBlockContext) busContext;
-			
+	    // Get the JAXBBlockContext.  All of the necessry information is recorded on it
+        JAXBBlockContext ctx = (JAXBBlockContext) busContext;
+        try {
             // TODO Re-evaluate Unmarshall construction w/ MTOM
-			Unmarshaller u = ctx.getUnmarshaller();
+			Unmarshaller u = JAXBUtils.getJAXBUnmarshaller(ctx.getJAXBContext());
             
             // If MTOM is enabled, add in the AttachmentUnmarshaller
             if (isMTOMEnabled()) {
@@ -98,22 +97,33 @@
                 XMLPart xp = getParent();
                 Message msg = xp.getParent();
                 
+                // TODO Pool ?
                 JAXBAttachmentUnmarshaller aum = new JAXBAttachmentUnmarshaller();
                 aum.setMessage(msg);
                 u.setAttachmentUnmarshaller(aum);
             }
+            Object jaxb = null;
             if (!ctx.isUseJAXBElement()){
             	// Normal Unmarshalling
-            	Object jaxb = u.unmarshal(reader);
+            	jaxb = u.unmarshal(reader);
 				setQName(getQName(jaxb, ctx));
-				return jaxb;
 			}else{
 				// Unmarshal as a JAXBElement and then get the value
 				JAXBElement jaxbElement = u.unmarshal(reader, ctx.getType());
-				Object jaxb = jaxbElement.getValue();
-				return jaxb;
+				jaxb = jaxbElement.getValue();
 			}
+            
+            // Successfully unmarshalled the object
+            // TODO remove attachment unmarshaller ?
+            JAXBUtils.releaseJAXBUnmarshaller(ctx.getJAXBContext(), u);
+            return jaxb;
 		} catch(JAXBException je) {
+            if (log.isDebugEnabled()) {
+                try {
+                    log.debug("JAXBContext for unmarshal failure:" + ctx.getJAXBContext());
+                } catch (Exception e) {
+                }
+            }
 			throw ExceptionFactory.makeMessageException(je);
 		}
 	}
@@ -126,7 +136,7 @@
 		// The solution is to write out the object and use a reader to read it back in.
 		// First create an XMLStreamWriter backed by a writer
 		StringWriter sw = new StringWriter();
-		XMLStreamWriter writer = outputFactory.createXMLStreamWriter(sw);
+		XMLStreamWriter writer = StAXUtils.createXMLStreamWriter(sw);
 		
 		// Write the business object to the writer
 		_outputFromBO(busObj, busContext, writer);
@@ -135,19 +145,20 @@
 		writer.flush();
 		sw.flush();
 		String str = sw.toString();
+        writer.close();
 		
 		// Return a reader backed by the string
 		StringReader sr = new StringReader(str);
-		return inputFactory.createXMLStreamReader(sr);
+		return StAXUtils.createXMLStreamReader(sr);
 	}
 
 	@Override
 	protected void _outputFromBO(Object busObject, Object busContext, XMLStreamWriter writer) throws XMLStreamException, MessageException {
-		try {
+        JAXBBlockContext ctx = (JAXBBlockContext) busContext;
+        try {
 			// Very easy, use the Context to get the Marshaller.
 			// Use the marshaller to write the object.  
-			JAXBBlockContext ctx = (JAXBBlockContext) busContext;
-			Marshaller m = ctx.getMarshaller();
+			Marshaller m = JAXBUtils.getJAXBMarshaller(ctx.getJAXBContext());
 			
 			// TODO Should MTOM be inside getMarshaller ?
 			// If MTOM is enabled, add in the AttachmentMarshaller.
@@ -158,12 +169,23 @@
                 XMLPart xp = getParent();
                 Message msg = xp.getParent();
                 
+                // Pool
                 JAXBAttachmentMarshaller am = new JAXBAttachmentMarshaller();
                 am.setMessage(msg);
                 m.setAttachmentMarshaller(am);
             }   
             m.marshal(busObject, writer);
+            
+            // Successfully marshalled the data
+            // TODO remove attachment marshaller ?
+            JAXBUtils.releaseJAXBMarshaller(ctx.getJAXBContext(), m);
 		} catch(JAXBException je) {
+            if (log.isDebugEnabled()) {
+                try {
+                    log.debug("JAXBContext for marshal failure:" + ctx.getJAXBContext());
+                } catch (Exception e) {
+                }
+            }
 			throw ExceptionFactory.makeMessageException(je);
 		}
 	}
@@ -175,8 +197,10 @@
 	 * @throws MessageException
 	 */
 	private static QName getQName(Object jaxb, JAXBBlockContext ctx) throws JAXBException {
-		JAXBIntrospector jbi = ctx.getIntrospector();
-		return jbi.getElementName(jaxb);
+		JAXBIntrospector jbi = JAXBUtils.getJAXBIntrospector(ctx.getJAXBContext());
+		QName qName = jbi.getElementName(jaxb);
+		JAXBUtils.releaseJAXBIntrospector(ctx.getJAXBContext(), jbi);
+		return qName;
 	}
     
     private boolean isMTOMEnabled() {
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/XMLStringBlockImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/XMLStringBlockImpl.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/XMLStringBlockImpl.java	(working copy)
@@ -26,6 +26,7 @@
 import javax.xml.stream.XMLStreamWriter;
 
 import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.util.StAXUtils;
 import org.apache.axis2.jaxws.message.databinding.XMLStringBlock;
 import org.apache.axis2.jaxws.message.factory.BlockFactory;
 import org.apache.axis2.jaxws.message.impl.BlockImpl;
@@ -37,9 +38,6 @@
  * Block containing a business object that is a String of xml text
  */
 public class XMLStringBlockImpl extends BlockImpl implements XMLStringBlock {
-
-	protected static XMLInputFactory inputFactory = XMLInputFactory.newInstance();
-	protected static XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
 	
 	/**
 	 * Constructor called from factory
@@ -74,7 +72,7 @@
 		// Create an XMLStreamReader from the inputFactory using the String as the sources
 		String str = (String) busObj;
 		StringReader sr = new StringReader(str);
-		return inputFactory.createXMLStreamReader(sr);
+		return StAXUtils.createXMLStreamReader(sr);
 	}
 
 	@Override
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/SourceBlockImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/SourceBlockImpl.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/SourceBlockImpl.java	(working copy)
@@ -17,6 +17,7 @@
 package org.apache.axis2.jaxws.message.databinding.impl;
 
 import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.util.StAXUtils;
 import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.i18n.Messages;
 import org.apache.axis2.jaxws.message.MessageException;
@@ -71,9 +72,6 @@
  * if a non-consumable request is made.
  */
 public class SourceBlockImpl extends BlockImpl implements SourceBlock {
-
-	private static XMLInputFactory inputFactory = XMLInputFactory.newInstance();
-	private static XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
 	
 	private static Class staxSource = null;
 	static {
@@ -161,7 +159,11 @@
 		} 
 		
 		if(busObj instanceof StreamSource){
-			return inputFactory.createXMLStreamReader((Source) busObj);
+			XMLInputFactory f = StAXUtils.getXMLInputFactory();
+			
+			XMLStreamReader reader = f.createXMLStreamReader((Source) busObj);
+			StAXUtils.releaseXMLInputFactory(f);
+			return reader;
 		}
 		//TODO: For GM we need to only use this approach when absolutely necessary.  
         // For example, we don't want to do this if this is a (1.6) StaxSource or if the installed parser provides 
@@ -181,7 +183,7 @@
            Transformer transformer = TransformerFactory.newInstance().newTransformer();
            transformer.transform(src, result); 
 	       ByteArrayInputStream bytes = new ByteArrayInputStream(out.toByteArray());
-	       return inputFactory.createXMLStreamReader(bytes);
+	       return StAXUtils.createXMLStreamReader(bytes);
 	   }catch(TransformerException e){
 		   throw new XMLStreamException(e);
 	   }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/JAXBBlockContext.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/JAXBBlockContext.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/JAXBBlockContext.java	(working copy)
@@ -18,9 +18,6 @@
 
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.JAXBIntrospector;
-import javax.xml.bind.Marshaller;
-import javax.xml.bind.Unmarshaller;
 
 /*
  * A JAXBBlockContext controls access to the JAXB Context/Marshal/Unmarshal code.
@@ -34,7 +31,6 @@
 	private Class type = null;
 	private JAXBContext jaxbContext = null;
 	private boolean useJAXBElement = false;
-	private JAXBIntrospector introspector = null;
 	
 	/**
 	 * Normal Constructor JAXBBlockContext
@@ -88,82 +84,11 @@
 	public JAXBContext getJAXBContext() throws JAXBException {
 		if (jaxbContext == null) {	
 			if (!useJAXBElement) {
-				// TODO Need J2W AccessController
-				// TODO Need to cache this
-				jaxbContext = JAXBContext.newInstance(new Class[]{type});
+				jaxbContext = JAXBUtils.getJAXBContext(type);
 			} else {
-				// TODO This may be overkill.
-				jaxbContext = JAXBContext.newInstance(new Class[]{type});
+				jaxbContext = JAXBUtils.getJAXBContext(type);
 			}
 		}
 		return jaxbContext;
 	}
-
-
-
-	/**
-	 * @return Unmarshaller
-	 * @throws JAXBException
-	 */
-	public Unmarshaller getUnmarshaller() throws JAXBException {
-		// TODO A New unmarahller is always created.  We should consider how to recognize if when a marshaller can be reused.
-		
-		Unmarshaller unmarshaller = null;
-		JAXBContext jc = getJAXBContext();
-		if (!useJAXBElement) {
-			// TODO Caching
-			unmarshaller = jc.createUnmarshaller();
-	     } else {
-			// TODO There may be a way to share JAXBElement unmarshallers ?
-			unmarshaller = jc.createUnmarshaller();
-		}
-		// TODO Additional options for unmarshaller ?
-			
-		// TODO Should we set up MTOM Attachment handler here ?
-		
-		return unmarshaller;
-	}
-	
-	/**
-	 * @return Marshaller
-	 * @throws JAXBException
-	 */
-	public Marshaller getMarshaller() throws JAXBException {
-		// TODO A New marahller is always created.  We should consider how to recognize if when a marshaller can be reused.
-		Marshaller marshaller = null;
-		JAXBContext jc = getJAXBContext();
-		if (!useJAXBElement) {
-			// TODO Caching
-			marshaller = jc.createMarshaller();
-		} else {
-			// TODO There may be a way to share these ?
-			marshaller = jc.createMarshaller();
-		}
-		// TODO Additional options for marshaller ?
-		marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE); // No PIs
-
-		// TODO Should we set up MTOM Attachment handler here ?
-		return marshaller;
-	}
-	
-	/**
-	 * @return Intospector
-	 * @throws JAXBException
-	 */
-	public JAXBIntrospector getIntrospector() throws JAXBException {
-		if (introspector == null) {
-			JAXBContext jc = getJAXBContext();
-			if (!useJAXBElement) {
-				// TODO Caching
-				introspector = jc.createJAXBIntrospector();
-			} else {
-				// TODO There may be a way to share these ?
-				introspector = jc.createJAXBIntrospector();
-			}
-			// TODO Additional options for unmarshaller ?
-			
-			// TODO Should we set up MTOM Attachment handler here ?
-		}
-		return introspector;
-	}
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/JAXBUtils.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/JAXBUtils.java	(revision 0)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/JAXBUtils.java	(revision 0)
@@ -0,0 +1,235 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.message.databinding;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.JAXBIntrospector;
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.Unmarshaller;
+
+import org.apache.axis2.jaxws.message.databinding.impl.JAXBBlockImpl;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * JAXB Utilites to pool JAXBContext and related objects.
+ * Currently the JAXBContext is pooled by Class name.  We may change this to 
+ * create and pool by package name.
+ */
+public class JAXBUtils {
+	
+    private static final Log log = LogFactory.getLog(JAXBUtils.class);
+    
+	// Create a synchronized weak hashmap key=class name, value= JAXBContext
+	private static Map<String, JAXBContext> map =
+			Collections.synchronizedMap(new WeakHashMap<String, JAXBContext>());
+	private static JAXBContext genericJAXBContext = null;
+	
+	private static Map<JAXBContext,Unmarshaller> umap = 
+        Collections.synchronizedMap(new WeakHashMap<JAXBContext, Unmarshaller>());
+    
+    private static Map<JAXBContext,Marshaller> mmap = 
+        Collections.synchronizedMap(new WeakHashMap<JAXBContext, Marshaller>());
+    
+    private static Map<JAXBContext,JAXBIntrospector> imap = 
+        Collections.synchronizedMap(new WeakHashMap<JAXBContext, JAXBIntrospector>());
+	
+    private static boolean ENABLE_ADV_POOLING = false;
+    
+    /**
+	 * Get a generic JAXBContext (that can be used for primitives)
+	 * @throws JAXBException
+	 */
+	public static JAXBContext getGenericJAXBContext() throws JAXBException {
+		
+		// JAXBContexts can be reused and are supposed to be thread-safe
+		if (genericJAXBContext == null) {
+            if (log.isDebugEnabled()) {
+                log.debug("Generic JAXBContext [created]");
+            }
+            genericJAXBContext = JAXBContext.newInstance(int.class);
+            return genericJAXBContext;
+		} else {
+            if (log.isDebugEnabled()) {
+                log.debug("Generic JAXBContext [from pool]");
+            }
+        }
+		return genericJAXBContext;
+	}
+	
+	/**
+	 * Get a JAXBContext for the class
+	 * @param cls Class
+	 * @return JAXBContext
+	 * @throws JAXBException
+	 */
+	public static JAXBContext getJAXBContext(Class cls) throws JAXBException {
+		// JAXBContexts for the same class can be reused and are supposed to be thread-safe
+		// TODO Can we cache by package name ?
+        if (cls.isPrimitive()) {
+            return getGenericJAXBContext();
+        }
+		JAXBContext context = map.get(cls.getName());
+		if (context == null) {
+            synchronized(map) {
+                if (log.isDebugEnabled()) {
+                    log.debug("JAXBContext [created] for" + cls.getName());
+                }
+                context = JAXBContext.newInstance(cls);
+                map.put(cls.getName(), context);
+            }
+		} else {
+            if (log.isDebugEnabled()) {
+                log.debug("JAXBContext [from pool] for" + cls.getName());
+            }
+        }
+		return context;
+	}
+	
+	/**
+	 * Get the unmarshaller.  You must call releaseUnmarshaller to put it back into the pool
+	 * @param context JAXBContext
+	 * @return Unmarshaller
+	 * @throws JAXBException
+	 */
+	public static Unmarshaller getJAXBUnmarshaller(JAXBContext context) throws JAXBException {
+		if (!ENABLE_ADV_POOLING) {
+            if (log.isDebugEnabled()) {
+                log.debug("Unmarshaller created [no pooling]");
+            }
+		    return context.createUnmarshaller();
+        } 
+        Unmarshaller u = umap.get(context);
+        if (u == null) {
+            if (log.isDebugEnabled()) {
+                log.debug("Unmarshaller created [not in pool]");
+            }
+            u = context.createUnmarshaller();
+        } else {
+            if (log.isDebugEnabled()) {
+                log.debug("Unmarshaller obtained [from  pool]");
+            }
+        }
+        return u;
+	}
+	
+	/**
+	 * Release Unmarshaller
+	 * Do not call this method if an exception occurred while using the Unmarshaller.
+	 * We object my be in an invalid state.
+	 * @param context JAXBContext
+	 * @param unmarshaller Unmarshaller
+	 */
+	public static void releaseJAXBUnmarshaller(JAXBContext context, Unmarshaller unmarshaller) {
+        if (log.isDebugEnabled()) {
+            log.debug("Unmarshaller placed back into pool");
+        }
+		umap.put(context, unmarshaller);
+	}
+	
+	/**
+	 * Get JAXBMarshaller
+	 * @param context JAXBContext
+	 * @return Marshaller
+	 * @throws JAXBException
+	 */
+	public static Marshaller getJAXBMarshaller(JAXBContext context) throws JAXBException {
+        Marshaller m = null;
+        if (!ENABLE_ADV_POOLING) {
+            if (log.isDebugEnabled()) {
+                log.debug("Marshaller created [no pooling]");
+            }
+            m = context.createMarshaller();
+        } else { 
+            m = mmap.get(context);
+            if (m == null) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Marshaller created [not in pool]");
+                }
+                m = context.createMarshaller();
+            } else {
+                if (log.isDebugEnabled()) {
+                    log.debug("Marshaller obtained [from  pool]");
+                }
+            }
+        }
+		m.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE); // No PIs
+		return m;
+	}
+	
+	/**
+	 * releaseJAXBMarshalller
+	 * Do not call this method if an exception occurred while using the Marshaller.
+	 * We object my be in an invalid state.
+	 * @param context JAXBContext
+	 * @param marshaller Marshaller
+	 */
+	public static void releaseJAXBMarshaller(JAXBContext context, Marshaller marshaller) {
+        if (log.isDebugEnabled()) {
+            log.debug("Marshaller placed back into pool");
+        }
+        mmap.put(context, marshaller);
+	}
+	
+	/**
+	 * get JAXB Introspector
+	 * @param context JAXBContext
+	 * @return JAXBIntrospector
+	 * @throws JAXBException
+	 */
+	public static JAXBIntrospector getJAXBIntrospector(JAXBContext context) throws JAXBException {
+        JAXBIntrospector i = null;
+        if (!ENABLE_ADV_POOLING) {
+            if (log.isDebugEnabled()) {
+                log.debug("JAXBIntrospector created [no pooling]");
+            }
+            i = context.createJAXBIntrospector();
+        } else { 
+            i = imap.get(context);
+            if (i == null) {
+                if (log.isDebugEnabled()) {
+                    log.debug("JAXBIntrospector created [not in pool]");
+                }
+                i = context.createJAXBIntrospector();
+            } else {
+                if (log.isDebugEnabled()) {
+                    log.debug("JAXBIntrospector obtained [from  pool]");
+                }
+            }
+        }
+        return i;
+	}
+	
+	/**
+	 * Release JAXBIntrospector
+	 * Do not call this method if an exception occurred while using the JAXBIntrospector.
+	 * We object my be in an invalid state.
+	 * @param context JAXBContext
+	 * @param introspector JAXBIntrospector
+	 */
+	public static void releaseJAXBIntrospector(JAXBContext context, JAXBIntrospector introspector) {
+        if (log.isDebugEnabled()) {
+            log.debug("JAXBIntrospector placed back into pool");
+        }
+        imap.put(context, introspector);
+	}
+}
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/attachments/AttachmentUtils.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/attachments/AttachmentUtils.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/attachments/AttachmentUtils.java	(working copy)
@@ -25,6 +25,7 @@
 import org.apache.axiom.om.OMFactory;
 import org.apache.axiom.om.OMNode;
 import org.apache.axiom.om.OMText;
+import org.apache.axiom.om.impl.llom.OMNavigator;
 import org.apache.axiom.soap.SOAPEnvelope;
 import org.apache.axis2.jaxws.message.Attachment;
 import org.apache.commons.logging.Log;
@@ -55,14 +56,48 @@
      * A recursive search for all of the <xop:include> elements in the tree.
      */
     private static void findXopElements(OMElement root, ArrayList<OMElement> xops) {
-        Iterator itr = root.getChildElements();
-        if (log.isDebugEnabled())
-            log.debug("[subtree] " + root.getLocalName());
         
+        // Navigator does a traversal that mimics the structure of an xml document. 
+        // Each non-element object is processed once.
+        // Each element object is visited prior to its children and after its children.
+        // 
+        // Suppose you have the following tree (caps are elements, lowers are text)
+        // 
+    	//     A
+    	//    / \
+    	//   B   C
+    	//  /\   /\
+    	//  D e F  g
+    	// 
+        // The traversal is
+    	// is A B D D' e B' C F F' g C' A'
+        // The ' indicates that this is the second time the node is visited (i.e. nav.visited() returns true)
+        
+    	OMNavigator nav = new OMNavigator(root);
+    	
+    	while (nav.isNavigable()) {
+    		OMNode curr = nav.next();
+            
+            // Inspect elements that have been visited. 
+            // It is probably safer to inspect the node when it is visited, because this guarantees that its
+            // children have been processed/expanded.
+    		if (nav.visited() && curr instanceof OMElement) {
+    			OMElement element = (OMElement) curr;
+    			if (element.getQName().equals(XOP_INCLUDE)) {
+    				if (log.isDebugEnabled()) {
+    					log.debug("[XOP_INCLUDE] " + element.getLocalName());
+                    }
+    				xops.add(element);
+    			}
+    		}
+    	}
+    	
+    	/* LEGACY SEARCH CODE
         // If it has no children, then it's a leaf and we need
         // to check if it's an <xop:include> element.  If not, then
         // we need to grab each of the children and continue traversing
         // down the tree.
+        Iterator itr = root.getChildren();
         if (itr == null || !itr.hasNext()) {
             if (log.isDebugEnabled())
                 log.debug("[leaf] " + root.getLocalName());
@@ -77,6 +112,7 @@
                 findXopElements(next, xops);
             }
         }
+       */ 
     }
     
     /**
@@ -95,9 +131,44 @@
      * A recursive search for all of the binary, optimized nodes in a tree.
      */
     private static void findBinaryElements(OMNode node, ArrayList<OMText> attachments) {
-        // If it's an OMText, then it's essentially a leaf and won't
-        // have any children.  If not, then check to see if it's an OMElement
-        // and continue traversing down.
+        
+    	
+        // Navigator does a traversal that mimics the structure of an xml document. 
+        // Each non-element object is processed once.
+        // Each element object is visited prior to its children and after its children.
+        // 
+        // Suppose you have the following tree (caps are elements, lowers are text)
+        // 
+        //     A
+        //    / \
+        //   B   C
+        //  /\   /\
+        //  D e F  g
+        // 
+        // The traversal is
+        // The traversal is
+        // is A B D D' e B' C F F' g C' A'
+        // The ' indicates that this is the second time the node is visited (i.e. nav.isVisited() returns true)
+    	OMNavigator nav = new OMNavigator(node);
+    	
+    	while (nav.isNavigable()) {
+    		OMNode curr = nav.next();
+    		if (curr instanceof OMText) {
+    			// If it's an OMText, see if its optimized and add it to the list
+                if (log.isDebugEnabled())
+                    log.debug("text node found");
+                
+                OMText textNode = (OMText) curr;
+                if (textNode.isOptimized()) {
+                    if (log.isDebugEnabled())
+                        log.debug("optimized text node found");
+                    
+                    attachments.add(textNode);
+                }
+            }
+    	}
+    	
+        /* LEGACY SEARCH CODE
         if (node instanceof OMText) {
             if (log.isDebugEnabled())
                 log.debug("text node found");
@@ -118,6 +189,7 @@
                 findBinaryElements(next, attachments);
             }
         }
+        */
     }
     
     /**
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/util/impl/SAAJConverterImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/util/impl/SAAJConverterImpl.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/util/impl/SAAJConverterImpl.java	(working copy)
@@ -302,7 +302,8 @@
 					break;
 				}
 				case XMLStreamReader.END_DOCUMENT: {
-					// Ignore
+					// Close reader and ignore
+                    reader.close();
 					break;
 				}
 				case XMLStreamReader.PROCESSING_INSTRUCTION: {
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/util/Reader2Writer.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/util/Reader2Writer.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/util/Reader2Writer.java	(working copy)
@@ -27,6 +27,7 @@
 import org.apache.axiom.om.OMDocument;
 import org.apache.axiom.om.OMNode;
 import org.apache.axiom.om.impl.builder.StAXOMBuilder;
+import org.apache.axiom.om.util.StAXUtils;
 
 /**
  * Reader2Writer
@@ -36,7 +37,6 @@
 public class Reader2Writer {
 
 	private XMLStreamReader reader;
-	private static XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
 	
 	/**
 	 * Construct from a Reader
@@ -68,7 +68,7 @@
 	 */
 	public String getAsString() throws XMLStreamException {
 		StringWriter sw = new StringWriter();
-		XMLStreamWriter writer = outputFactory.createXMLStreamWriter(sw);
+		XMLStreamWriter writer = StAXUtils.createXMLStreamWriter(sw);
 		
 		// Write the reader to the writer
 		outputTo(writer);
@@ -77,6 +77,7 @@
 		writer.flush();
 		sw.flush();
 		String str = sw.toString();
+        writer.close();
 		return str;
 	}
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/util/MessageUtils.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/util/MessageUtils.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/message/util/MessageUtils.java	(working copy)
@@ -21,6 +21,7 @@
 import java.util.List;
 
 import javax.activation.DataHandler;
+import javax.xml.namespace.QName;
 import javax.xml.soap.AttachmentPart;
 import javax.xml.soap.MimeHeader;
 import javax.xml.soap.MimeHeaders;
@@ -222,10 +223,34 @@
         // Enable MTOM Attachments 
         if (message.isMTOMEnabled()) {
             Options opts = msgContext.getOptions();
-            opts.setProperty(Configuration.ENABLE_MTOM, "true");                    
+            opts.setProperty(Configuration.ENABLE_MTOM, "true");
+            // If we have MTOM attachments, we need to replace the <xop:include>
+            // elements with OMText binary nodes.
+            
+            // First find all of the <xop:include> elements
+            ArrayList<OMElement> xops = AttachmentUtils.findXopElements(envelope);
+            
+            if (xops != null) {
+                QName href = new QName("","href");
+                Iterator<OMElement> itr = xops.iterator();
+                while (itr.hasNext()) {
+                    OMElement xop = itr.next();
+                    String cid = xop.getAttributeValue(href);
+                    
+                    // Then find their corresponding Attachment object
+                    Attachment a = message.getAttachment(cid);
+                    
+                    // Convert the <xop:include> OMElement into an OMText
+                    // binary node and replace it in the tree.                    
+                    OMText binaryNode = AttachmentUtils.makeBinaryOMNode(xop, a);
+                    xop.insertSiblingAfter(binaryNode);
+                    xop.detach();
+                }
+            }
+            
         }
         
-        // Add the attachments
+        // Add the remaining attachments
         List attachments = message.getAttachments();
         if (attachments != null && attachments.size() > 0) {
             for (int i=0; i<attachments.size(); i++) {
@@ -236,6 +261,19 @@
                 }
             }
         }
-       
     }
+    
+    /**
+     * Get a string containing the stack of the specified exception
+     * @param e Throwable
+     * @return String
+     */
+    public static String stackToString(Throwable e){
+        java.io.StringWriter sw= new java.io.StringWriter(); 
+        java.io.BufferedWriter bw = new java.io.BufferedWriter(sw);
+        java.io.PrintWriter pw= new java.io.PrintWriter(bw); 
+        e.printStackTrace(pw);
+        pw.close();
+        return sw.getBuffer().toString();
+      }
 }
Index: C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/MethodMarshallerImpl.java
===================================================================
--- C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/MethodMarshallerImpl.java	(revision 470989)
+++ C:/workspace/live/axis2/modules/jaxws/src/org/apache/axis2/jaxws/marshaller/impl/MethodMarshallerImpl.java	(working copy)
@@ -37,7 +37,6 @@
 import javax.xml.bind.annotation.XmlRootElement;
 import javax.xml.bind.annotation.XmlType;
 import javax.xml.namespace.QName;
-import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 import javax.xml.ws.AsyncHandler;
@@ -45,6 +44,7 @@
 import javax.xml.ws.Response;
 
 import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.util.StAXUtils;
 import org.apache.axis2.jaxws.ExceptionFactory;
 import org.apache.axis2.jaxws.description.EndpointDescription;
 import org.apache.axis2.jaxws.description.FaultDescription;
@@ -62,6 +62,7 @@
 import org.apache.axis2.jaxws.message.XMLFault;
 import org.apache.axis2.jaxws.message.XMLFaultReason;
 import org.apache.axis2.jaxws.message.databinding.JAXBBlockContext;
+import org.apache.axis2.jaxws.message.databinding.JAXBUtils;
 import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
 import org.apache.axis2.jaxws.message.factory.MessageFactory;
 import org.apache.axis2.jaxws.message.factory.XMLStringBlockFactory;
@@ -406,8 +407,10 @@
 			JAXBBlockContext context, 
 			String targetNamespace) throws MessageException, JAXBException {
 		
-		JAXBIntrospector introspector = context.getIntrospector();
-		if(introspector.isElement(jaxbObject)){
+		JAXBIntrospector i  = JAXBUtils.getJAXBIntrospector(context.getJAXBContext());
+		boolean isElement = i.isElement(jaxbObject);
+		JAXBUtils.releaseJAXBIntrospector(context.getJAXBContext(), i);
+		if(isElement){
 			return createJAXBBlock(jaxbObject, context);
 		}
 		else{
@@ -686,17 +689,11 @@
 			throws JAXBException, MessageException, XMLStreamException {
 		JAXBBlockContext blockContext = createJAXBBlockContext(jaxbClazz);
 		
-		OMElement om = block.getOMElement();
-
-		XMLInputFactory xmlFactory = XMLInputFactory.newInstance();
-
-		Unmarshaller u = blockContext.getUnmarshaller();
-		Reader inputReader = new InputStreamReader(new ByteArrayInputStream(om
-				.toString().getBytes()));
-		XMLStreamReader sr = xmlFactory.createXMLStreamReader(inputReader);
-		JAXBElement o = u.unmarshal(sr, jaxbClazz);
-		return o.getValue();
-
+		// Get a JAXBBlockFactory instance. 
+        JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
+        
+        Block jaxbBlock = factory.createFrom(block, blockContext);
+        return jaxbBlock.getBusinessObject(true); 
 	}
 	protected void createResponseHolders(ArrayList<MethodParameter> mps, ArrayList<Object> inputArgHolders, Message message)throws JAXBException, MessageException, XMLStreamException{
 		Object bo = null;
