Index: test/org/apache/axis2/transport/tcp/TCPEchoRawXMLTest.java
===================================================================
--- test/org/apache/axis2/transport/tcp/TCPEchoRawXMLTest.java	(revision 947631)
+++ test/org/apache/axis2/transport/tcp/TCPEchoRawXMLTest.java	(working copy)
@@ -42,6 +42,7 @@
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.description.AxisService;
 import org.apache.axis2.description.OutInAxisOperation;
+import org.apache.axis2.description.Parameter;
 import org.apache.axis2.util.Utils;
 import org.apache.axis2.wsdl.WSDLConstants;
 import org.apache.commons.logging.Log;
@@ -51,6 +52,7 @@
 import javax.xml.stream.XMLStreamException;
 
 public class TCPEchoRawXMLTest extends TestCase {
+
     private EndpointReference targetEPR =
             new EndpointReference("tcp://127.0.0.1:"
                     + (UtilsTCPServer.TESTING_PORT)
@@ -81,15 +83,26 @@
                 Utils.createSimpleService(serviceName,
                                           Echo.class.getName(),
                                           operationName);
+        service.addParameter(new Parameter(TCPEndpoint.PARAM_PORT, UtilsTCPServer.TESTING_PORT));
+        service.addParameter(new Parameter(TCPEndpoint.PARAM_CONTENT_TYPE, "text/xml"));
         UtilsTCPServer.deployService(service);
+
         clientService = Utils.createSimpleServiceforClient(serviceName,
                                                            Echo.class.getName(),
                                                            operationName);
+        clientService.addParameter(new Parameter(TCPEndpoint.PARAM_PORT,
+                UtilsTCPServer.TESTING_PORT + 1));
+        clientService.addParameter(new Parameter(TCPEndpoint.PARAM_CONTENT_TYPE, "text/xml"));
+        clientService.addParameter(new Parameter(TCPEndpoint.PARAM_HOST, "127.0.0.1"));
         configContext = UtilsTCPServer.createClientConfigurationContext();
     }
 
     protected void tearDown() throws Exception {
         UtilsTCPServer.stop();
+        if (configContext.getListenerManager() != null) {
+            configContext.getListenerManager().stop();
+        }
+        configContext.cleanupContexts();
     }
 
     private OMElement createPayload() {
@@ -174,7 +187,7 @@
 
         Options options = new Options();
         options.setTo(targetEPR);
-        options.setAction(Constants.AXIS2_NAMESPACE_URI+"/"+operationName.getLocalPart());
+        options.setAction(Constants.AXIS2_NAMESPACE_URI + "/" + operationName.getLocalPart());
         options.setTransportInProtocol(Constants.TRANSPORT_TCP);
         options.setUseSeparateListener(true);
 
Index: test/org/apache/axis2/transport/tcp/TCPTwoChannelEchoRawXMLTest.java
===================================================================
--- test/org/apache/axis2/transport/tcp/TCPTwoChannelEchoRawXMLTest.java	(revision 947631)
+++ test/org/apache/axis2/transport/tcp/TCPTwoChannelEchoRawXMLTest.java	(working copy)
@@ -35,6 +35,7 @@
 import org.apache.axis2.client.async.Callback;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.Parameter;
 import org.apache.axis2.util.Utils;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -72,6 +73,8 @@
                 Utils.createSimpleService(serviceName,
                                           Echo.class.getName(),
                                           operationName);
+        service.addParameter(new Parameter(TCPEndpoint.PARAM_PORT, UtilsTCPServer.TESTING_PORT));
+        service.addParameter(new Parameter(TCPEndpoint.PARAM_CONTENT_TYPE, "text/xml"));
         UtilsTCPServer.deployService(service);
 
         configContext = UtilsTCPServer.createClientConfigurationContext();
@@ -79,6 +82,10 @@
 
     protected void tearDown() throws Exception {
         UtilsTCPServer.stop();
+        if (configContext.getListenerManager() != null) {
+            configContext.getListenerManager().stop();
+        }
+        configContext.cleanupContexts();
     }
 
     public void testEchoXMLCompleteASync() throws Exception {
@@ -120,6 +127,10 @@
                     Utils.createSimpleServiceforClient(serviceName,
                                                        Echo.class.getName(),
                                                        operationName);
+            serviceClient.addParameter(new Parameter(TCPEndpoint.PARAM_PORT,
+                UtilsTCPServer.TESTING_PORT + 1));
+            serviceClient.addParameter(new Parameter(TCPEndpoint.PARAM_CONTENT_TYPE, "text/xml"));
+            serviceClient.addParameter(new Parameter(TCPEndpoint.PARAM_HOST, "127.0.0.1"));
 
             sender = new ServiceClient(configContext, serviceClient);
             sender.setOptions(options);
Index: test/org/apache/axis2/transport/tcp/UtilsTCPServer.java
===================================================================
--- test/org/apache/axis2/transport/tcp/UtilsTCPServer.java	(revision 947631)
+++ test/org/apache/axis2/transport/tcp/UtilsTCPServer.java	(working copy)
@@ -24,7 +24,6 @@
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.ConfigurationContextFactory;
 import org.apache.axis2.description.AxisService;
-import org.apache.axis2.transport.tcp.TCPServer;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -35,7 +34,7 @@
 public class UtilsTCPServer {
     private static int count = 0;
 
-    private static TCPServer receiver;
+    private static TCPTransportListener receiver;
 
     public static final int TESTING_PORT = 5555;
 
@@ -73,9 +72,9 @@
             } catch (InterruptedException e1) {
                 throw new AxisFault("Thread interuptted", e1);
             }
-            receiver = new TCPServer(TESTING_PORT, er);
+            receiver = new TCPTransportListener();
+            receiver.init(er, er.getAxisConfiguration().getTransportIn(Constants.TRANSPORT_TCP));
             receiver.start();
-
         }
         count++;
     }
@@ -84,6 +83,7 @@
         try {
             if (count == 1) {
                 receiver.stop();
+                receiver.destroy();
                 count = 0;
                 System.out.print("Server stopped .....");
             } else {
Index: conf/axis2.xml
===================================================================
--- conf/axis2.xml	(revision 947631)
+++ conf/axis2.xml	(working copy)
@@ -137,11 +137,13 @@
     <!--</targetResolvers>-->
 
     <transportReceiver name="tcp"
-                       class="org.apache.axis2.transport.tcp.TCPServer">
-        <parameter name="port">6060</parameter>
+                       class="org.apache.axis2.transport.tcp.TCPTransportListener">
+        <!--parameter name="transport.tcp.port">6060</parameter>
+        <parameter name="transport.tcp.contentType">text/xml</parameter-->
         <!--If you want to give your own host address for EPR generation-->
         <!--uncommet following paramter , and set as you required.-->
-        <!--<parameter name="hostname">tcp://myApp.com/ws</parameter>-->
+        <!--<parameter name="transport.tcp.hostname">tcp://myApp.com/ws</parameter>-->
+        <!--<parameter name="transport.tcp.backlog">50</parameter>-->
     </transportReceiver>
 
     <transportSender name="tcp"
Index: src/org/apache/axis2/transport/tcp/TCPWorker.java
===================================================================
--- src/org/apache/axis2/transport/tcp/TCPWorker.java	(revision 947631)
+++ src/org/apache/axis2/transport/tcp/TCPWorker.java	(working copy)
@@ -17,101 +17,81 @@
  * under the License.
  */
 
-
 package org.apache.axis2.transport.tcp;
 
-import org.apache.axiom.om.OMXMLParserWrapper;
 import org.apache.axiom.soap.SOAPEnvelope;
-import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
-import org.apache.axis2.builder.BuilderUtil;
-import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.transport.TransportUtils;
 import org.apache.axis2.context.MessageContext;
-import org.apache.axis2.description.TransportInDescription;
-import org.apache.axis2.description.TransportOutDescription;
-import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.axis2.engine.AxisEngine;
-import org.apache.axis2.i18n.Messages;
 import org.apache.axis2.util.MessageContextBuilder;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.Reader;
 import java.net.Socket;
 
 /**
  * This Class is the work hoarse of the TCP request, this process the incomming SOAP Message.
  */
 public class TCPWorker implements Runnable {
+
     private static final Log log = LogFactory.getLog(TCPWorker.class);
-    private ConfigurationContext configurationContext;
+
+    private TCPEndpoint endpoint;
     private Socket socket;
 
-    public TCPWorker(ConfigurationContext configurationContext, Socket socket) {
-        this.configurationContext = configurationContext;
+    public TCPWorker(TCPEndpoint endpoint, Socket socket) {
+        this.endpoint = endpoint;
         this.socket = socket;
     }
 
     public void run() {
+
         MessageContext msgContext = null;
 
         try {
-            AxisConfiguration axisConf = configurationContext.getAxisConfiguration();
-            TransportOutDescription transportOut =
-                    axisConf.getTransportOut(Constants.TRANSPORT_TCP);
-            TransportInDescription transportIn =
-                    axisConf.getTransportIn(Constants.TRANSPORT_TCP);
+            msgContext = endpoint.createMessageContext();
+            msgContext.setIncomingTransportName(Constants.TRANSPORT_TCP);
+            //msgContext.setTransportIn(endpoint.getListener().getTransportInDescription());
 
-            if ((transportOut != null) && (transportIn != null)) {
+            TCPOutTransportInfo outInfo = new TCPOutTransportInfo();
+            outInfo.setSocket(socket);
+            outInfo.setContentType(endpoint.getContentType());
+            msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, outInfo);
 
-                // create the Message Context and fill in the values
-                msgContext = configurationContext.createMessageContext();
-                msgContext.setIncomingTransportName(Constants.TRANSPORT_TCP);
-                msgContext.setTransportIn(transportIn);
-                msgContext.setTransportOut(transportOut);
-                msgContext.setServerSide(true);
+            // create the SOAP Envelope
+            SOAPEnvelope envelope = TransportUtils.createSOAPMessage(msgContext,
+                    socket.getInputStream(), endpoint.getContentType());
+            msgContext.setEnvelope(envelope);
 
-                OutputStream out = socket.getOutputStream();
+            AxisEngine.receive(msgContext);
 
-                msgContext.setProperty(MessageContext.TRANSPORT_OUT, out);
+        } catch (Exception e) {
+            sendFault(msgContext, e);
 
-                // create the SOAP Envelope
-                Reader in = new InputStreamReader(socket.getInputStream());
-                OMXMLParserWrapper builder = BuilderUtil.getBuilder(in);
-                SOAPEnvelope envelope = (SOAPEnvelope) builder.getDocumentElement();
-
-                msgContext.setEnvelope(envelope);
-                AxisEngine.receive(msgContext);
-            } else {
-                throw new AxisFault(Messages.getMessage("unknownTransport",
-                                                        Constants.TRANSPORT_TCP));
-            }
-        } catch (Throwable e) {
-            log.error(e.getMessage(), e);
+        } finally {
             try {
+                socket.close();
+            } catch (IOException e) {
+                log.error("Error while closing a TCP socket", e);
+            }
+        }
+    }
 
-                if (msgContext != null) {
-                    msgContext.setProperty(MessageContext.TRANSPORT_OUT, socket.getOutputStream());
+    private void sendFault(MessageContext msgContext, Exception fault) {
+        log.error("Error while processing TCP request through the Axis2 engine", fault);
+        try {
+            if (msgContext != null) {
+                msgContext.setProperty(MessageContext.TRANSPORT_OUT, socket.getOutputStream());
 
-                    MessageContext faultContext =
-                            MessageContextBuilder.createFaultMessageContext(msgContext, e);
+                MessageContext faultContext =
+                        MessageContextBuilder.createFaultMessageContext(msgContext, fault);
 
-                    AxisEngine.sendFault(faultContext);
-                }
-            } catch (Exception e1) {
-                log.error(e1.getMessage(), e1);
+                AxisEngine.sendFault(faultContext);
             }
-        } finally {
-            if (socket != null) {
-                try {
-                    this.socket.close();
-                } catch (IOException e1) {
-                    // Do nothing
-                }
-            }
+        } catch (Exception e) {
+            log.error("Error while sending the fault response", e);
         }
     }
 }
Index: src/org/apache/axis2/transport/tcp/TCPTransportSender.java
===================================================================
--- src/org/apache/axis2/transport/tcp/TCPTransportSender.java	(revision 947631)
+++ src/org/apache/axis2/transport/tcp/TCPTransportSender.java	(working copy)
@@ -21,113 +21,114 @@
 package org.apache.axis2.transport.tcp;
 
 import org.apache.axis2.AxisFault;
-import org.apache.axis2.addressing.EndpointReference;
-import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.description.OutInAxisOperation;
+import org.apache.axis2.engine.AxisEngine;
 import org.apache.axis2.context.MessageContext;
-import org.apache.axis2.description.TransportOutDescription;
-import org.apache.axis2.handlers.AbstractHandler;
-import org.apache.axis2.i18n.Messages;
-import org.apache.axis2.transport.TransportSender;
+import org.apache.axis2.transport.OutTransportInfo;
 import org.apache.axis2.transport.TransportUtils;
-import org.apache.axis2.util.URL;
+import org.apache.axis2.transport.base.AbstractTransportSender;
+import org.apache.axiom.soap.SOAPEnvelope;
 
 import java.io.IOException;
-import java.io.OutputStream;
-import java.io.Writer;
-import java.net.InetSocketAddress;
-import java.net.MalformedURLException;
-import java.net.Socket;
-import java.net.SocketAddress;
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.io.ByteArrayInputStream;
+import java.net.*;
 
-public class TCPTransportSender extends AbstractHandler implements TransportSender {
-    protected Writer out;
-    private Socket socket;
+public class TCPTransportSender extends AbstractTransportSender {
 
-    public void init(ConfigurationContext confContext, TransportOutDescription transportOut)
-            throws AxisFault {
-    }
+    public void sendMessage(MessageContext msgContext, String targetEPR,
+                            OutTransportInfo outTransportInfo) throws AxisFault {
 
-    public void stop() {
-    }
+        if (targetEPR != null) {
+            Socket socket = openTCPConnection(targetEPR);
+            try {
+                TransportUtils.writeMessage(msgContext, socket.getOutputStream());
+                if (!msgContext.getOptions().isUseSeparateListener() && !msgContext.isServerSide()){
+                    waitForReply(msgContext, socket, getContentType(targetEPR));
+                }
+            } catch (IOException e) {
+                handleException("Error while sending a TCP request", e);
+            } finally {
+                closeConnection(socket);
+            }
 
-    public void cleanup(MessageContext msgContext) throws AxisFault {
-        try {
-            if (socket != null) {
-                socket.close();
-                socket = null;
+        } else if (outTransportInfo != null && (outTransportInfo instanceof TCPOutTransportInfo)) {
+            TCPOutTransportInfo outInfo = (TCPOutTransportInfo) outTransportInfo;
+            try {
+                TransportUtils.writeMessage(msgContext, outInfo.getSocket().getOutputStream());
+            } catch (IOException e) {
+                handleException("Error while sending a TCP response", e);
+            } finally {
+                closeConnection(outInfo.getSocket());
             }
-        } catch (IOException e) {
-            // TODO: Log this?
         }
     }
 
-    /**
-     * Method invoke
-     *
-     * @param msgContext
-     * @throws AxisFault
-     */
-    public InvocationResponse invoke(MessageContext msgContext) throws AxisFault {
+    private void waitForReply(MessageContext msgContext, Socket socket,
+                              String contentType) throws AxisFault {
 
-        // Check for the REST behaviour, if you desire rest beahaviour
-        // put a <parameter name="doREST" value="true"/> at the axis2.xml
-        msgContext.setDoingMTOM(TransportUtils.doWriteMTOM(msgContext));
-        msgContext.setDoingSwA(TransportUtils.doWriteSwA(msgContext));
+        if (!(msgContext.getAxisOperation() instanceof OutInAxisOperation) &&
+                msgContext.getProperty(org.apache.axis2.Constants.PIGGYBACK_MESSAGE) == null) {
+            return;
+        }
 
-        OutputStream out;
-        EndpointReference epr = null;
+        try {
+            MessageContext responseMsgCtx = createResponseMessageContext(msgContext);
+            BufferedReader reader = new BufferedReader(new InputStreamReader(
+                    socket.getInputStream()));
 
-        if (msgContext.getTo() != null && !msgContext.getTo().hasAnonymousAddress()) {
-            epr = msgContext.getTo();
+            char[] cbuf = new char[1024];
+            int len;
+            StringBuffer buff = new StringBuffer();
+            while ((len = reader.read(cbuf)) != -1) {
+                buff.append(cbuf, 0, len);
+            }
+
+            ByteArrayInputStream bais = new ByteArrayInputStream(buff.toString().getBytes());
+            SOAPEnvelope envelope = TransportUtils.createSOAPMessage(msgContext,
+                        bais, contentType);
+            responseMsgCtx.setEnvelope(envelope);
+            AxisEngine.receive(responseMsgCtx);
+        } catch (Exception e) {
+            handleException("Error while processing response", e);
         }
+    }
 
-        if (epr != null) {
-            if (!epr.hasNoneAddress()) {
-                out = openTheConnection(epr, msgContext);
-                TransportUtils.writeMessage(msgContext, out);
-                try {
-                    socket.shutdownOutput();
-                    msgContext.setProperty(MessageContext.TRANSPORT_IN, socket.getInputStream());
-                } catch (IOException e) {
-                    throw AxisFault.makeFault(e);
-                }
+    private String getContentType(String url) {
+        try {
+            URL tcpUrl = new URL(url);
+            String query = tcpUrl.getQuery();
+            if (query.endsWith("contentType")) {
+                return query.substring(12);
             }
-        } else {
-            out = (OutputStream) msgContext.getProperty(MessageContext.TRANSPORT_OUT);
+        } catch (MalformedURLException ignored) {
 
-            if (out != null) {
-                TransportUtils.writeMessage(msgContext, out);
-            } else {
-                throw new AxisFault(
-                        "Both the TO and Property MessageContext.TRANSPORT_OUT is Null, No where to send");
-            }
         }
-
-        TransportUtils.setResponseWritten(msgContext, true);
-        
-        return InvocationResponse.CONTINUE;
+        return "text/xml";
     }
 
-    protected OutputStream openTheConnection(EndpointReference toURL, MessageContext msgContext)
-            throws AxisFault {
-        if (toURL != null) {
-            try {
-                URL url = new URL(toURL.getAddress());
-                SocketAddress add = new InetSocketAddress(url.getHost(), (url.getPort() == -1)
-                        ? 80
-                        : url.getPort());
-
-                socket = new Socket();
-                socket.connect(add);
-
-                return socket.getOutputStream();
-            } catch (MalformedURLException e) {
-                throw AxisFault.makeFault(e);
-            } catch (IOException e) {
-                throw AxisFault.makeFault(e);
+    private Socket openTCPConnection(String url) throws AxisFault {
+        try {
+            URI tcpUrl = new URI(url);
+            if (!tcpUrl.getScheme().equals("tcp")) {
+                throw new Exception("Invalid protocol prefix : " + tcpUrl.getScheme());
             }
-        } else {
-            throw new AxisFault(Messages.getMessage("canNotBeNull", "End point reference"));
+            SocketAddress address = new InetSocketAddress(tcpUrl.getHost(), tcpUrl.getPort());
+            Socket socket = new Socket();
+            socket.connect(address);
+            return socket;
+        } catch (Exception e) {
+            handleException("Error while opening TCP connection to : " + url, e);
         }
+        return null;
     }
+
+    private void closeConnection(Socket socket) {
+        try {
+            socket.close();
+        } catch (IOException e) {
+            log.error("Error while closing a TCP socket", e);
+        }
+    }
 }
Index: src/org/apache/axis2/transport/tcp/TCPEndpoint.java
===================================================================
--- src/org/apache/axis2/transport/tcp/TCPEndpoint.java	(revision 0)
+++ src/org/apache/axis2/transport/tcp/TCPEndpoint.java	(revision 0)
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package org.apache.axis2.transport.tcp;
+
+import org.apache.axis2.transport.base.ProtocolEndpoint;
+import org.apache.axis2.transport.base.ParamUtils;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.description.ParameterInclude;
+
+public class TCPEndpoint extends ProtocolEndpoint {
+
+    private String host = null;
+    private int port = -1;
+    private int backlog = 50;
+    private String contentType;
+
+    public static final String PARAM_PORT = "transport.tcp.port";
+    public static final String PARAM_HOST = "transport.tcp.hostname";
+    public static final String PARAM_BACKLOG = "transport.tcp.backlog";
+    public static final String PARAM_CONTENT_TYPE = "transport.tcp.contentType";
+
+    public TCPEndpoint() {
+
+    }
+
+    public TCPEndpoint(String host, int port, int backlog) {
+        this.host = host;
+        this.port = port;
+        this.backlog = backlog;
+    }
+
+    public int getPort() {
+        return port;
+    }
+
+    public String getHost() {
+        return host;
+    }
+
+    public int getBacklog() {
+        return backlog;
+    }
+
+    public String getContentType() {
+        return contentType;
+    }
+
+    public boolean loadConfiguration(ParameterInclude params) throws AxisFault {
+        port = ParamUtils.getOptionalParamInt(params, PARAM_PORT, -1);
+        if (port == -1) {
+            return false;
+        }
+
+        contentType = ParamUtils.getRequiredParam(params, PARAM_CONTENT_TYPE);
+
+        host = ParamUtils.getOptionalParam(params, PARAM_HOST);
+        backlog = ParamUtils.getOptionalParamInt(params, PARAM_BACKLOG, 50);
+        return true;
+    }
+
+    public EndpointReference[] getEndpointReferences(String ip) throws AxisFault {
+        String url = "tcp://" + (host != null ? host : ip) + ":" + port;
+        if (getService() != null) {
+            String context = getListener().getConfigurationContext().getServiceContextPath();
+            url +=  (context.startsWith("/") ? "" : "/") + context + "/" +
+                    getServiceName();
+        }
+        return new EndpointReference[] { new EndpointReference(url) };
+    }
+    
+}
Index: src/org/apache/axis2/transport/tcp/TCPOutTransportInfo.java
===================================================================
--- src/org/apache/axis2/transport/tcp/TCPOutTransportInfo.java	(revision 0)
+++ src/org/apache/axis2/transport/tcp/TCPOutTransportInfo.java	(revision 0)
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.transport.tcp;
+
+import org.apache.axis2.transport.OutTransportInfo;
+
+import java.io.OutputStream;
+import java.net.Socket;
+
+public class TCPOutTransportInfo implements OutTransportInfo {
+
+    private Socket socket;
+    private String contentType;
+
+    public Socket getSocket() {
+        return socket;
+    }
+
+    public void setSocket(Socket socket) {
+        this.socket = socket;
+    }
+
+    public void setContentType(String contentType) {
+        this.contentType = contentType;
+    }
+
+    public String getContentType() {
+        return contentType;
+    }
+}
Index: src/org/apache/axis2/transport/tcp/TCPTransportListener.java
===================================================================
--- src/org/apache/axis2/transport/tcp/TCPTransportListener.java	(revision 0)
+++ src/org/apache/axis2/transport/tcp/TCPTransportListener.java	(revision 0)
@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.transport.tcp;
+
+import org.apache.axis2.transport.base.AbstractTransportListenerEx;
+import org.apache.axis2.AxisFault;
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class TCPTransportListener extends AbstractTransportListenerEx<TCPEndpoint> {
+
+    private Map<TCPEndpoint, TCPServer> serverTable = new ConcurrentHashMap<TCPEndpoint, TCPServer>();
+
+    protected void doInit() throws AxisFault {
+
+    }
+
+    protected TCPEndpoint createEndpoint() {
+        return new TCPEndpoint();
+    }
+
+    protected void startEndpoint(TCPEndpoint endpoint) throws AxisFault {
+        try {
+            TCPServer server = new TCPServer(endpoint, workerPool);
+            server.startServer();
+            serverTable.put(endpoint, server);
+        } catch (IOException e) {
+            handleException("Error while starting the TCP endpoint", e);
+        }
+    }
+
+    protected void stopEndpoint(TCPEndpoint endpoint) {
+        try {
+            TCPServer server = serverTable.get(endpoint);
+            if (server != null) {
+                server.stopServer();
+            }
+        } catch (IOException e) {
+            log.error("Error while stopping the TCP endpoint", e);
+        } finally {
+            serverTable.remove(endpoint);
+        }
+    }
+}
Index: src/org/apache/axis2/transport/tcp/TCPServer.java
===================================================================
--- src/org/apache/axis2/transport/tcp/TCPServer.java	(revision 947631)
+++ src/org/apache/axis2/transport/tcp/TCPServer.java	(working copy)
@@ -20,212 +20,66 @@
 
 package org.apache.axis2.transport.tcp;
 
-import org.apache.axis2.AxisFault;
-import org.apache.axis2.Constants;
-import org.apache.axis2.util.Utils;
-import org.apache.axis2.addressing.EndpointReference;
-import org.apache.axis2.context.ConfigurationContext;
-import org.apache.axis2.context.ConfigurationContextFactory;
-import org.apache.axis2.context.MessageContext;
-import org.apache.axis2.context.SessionContext;
-import org.apache.axis2.description.Parameter;
-import org.apache.axis2.description.TransportInDescription;
-import org.apache.axis2.engine.ListenerManager;
-import org.apache.axis2.i18n.Messages;
-import org.apache.axis2.transport.TransportListener;
-import org.apache.commons.logging.Log;
+import org.apache.axis2.transport.base.threads.WorkerPool;
 import org.apache.commons.logging.LogFactory;
+import org.apache.commons.logging.Log;
 
-import java.io.File;
-import java.io.IOException;
 import java.net.ServerSocket;
 import java.net.Socket;
-import java.net.SocketException;
+import java.net.InetAddress;
+import java.io.IOException;
 
-/**
- * Class TCPServer
- */
-public class TCPServer implements Runnable, TransportListener {
-    private int port = 8000;
+public class TCPServer implements Runnable {
+    
+    private TCPEndpoint endpoint;
+    private ServerSocket serverSocket;
+    private WorkerPool workerPool;
     private boolean started = false;
+
     private static final Log log = LogFactory.getLog(TCPServer.class);
-    private ConfigurationContext configContext;
-    private ServerSocket serversocket;
-    private String hostAddress = null;
-    private String contextPath;
 
-    public TCPServer() {
+    public TCPServer(TCPEndpoint endpoint, WorkerPool workerPool) {
+        this.endpoint = endpoint;
+        this.workerPool = workerPool;
     }
 
-    public TCPServer(int port, ConfigurationContext configContext) throws AxisFault {
-        try {
-            this.configContext = configContext;
-            serversocket = new ServerSocket(port);
-
-            ListenerManager listenerManager = configContext.getListenerManager();
-            TransportInDescription trsIn = new TransportInDescription(Constants.TRANSPORT_TCP);
-            trsIn.setReceiver(this);
-            if (listenerManager == null) {
-                listenerManager = new ListenerManager();
-                listenerManager.init(configContext);
-            }
-            listenerManager.addListener(trsIn, true);
-            contextPath = configContext.getServiceContextPath();
-
-        } catch (IOException e1) {
-            throw AxisFault.makeFault(e1);
-        }
-    }
-
-    public TCPServer(int port, String dir) throws AxisFault {
-        this(port, ConfigurationContextFactory.createConfigurationContextFromFileSystem(dir, null));
-    }
-
-    public void init(ConfigurationContext axisConf, TransportInDescription transprtIn)
-            throws AxisFault {
-        this.configContext = axisConf;
-
-        Parameter param = transprtIn.getParameter(PARAM_PORT);
-
-        if (param != null) {
-            this.port = Integer.parseInt((String) param.getValue());
-        }
-        param = transprtIn.getParameter(HOST_ADDRESS);
-        if (param != null) {
-            hostAddress = ((String) param.getValue()).trim();
-        }
-        contextPath = configContext.getServiceContextPath();
-    }
-
-    public static void main(String[] args) throws AxisFault, NumberFormatException {
-        if (args.length != 2) {
-            System.out.println("TCPServer repositoryLocation port");
-        } else {
-            File repository = new File(args[0]);
-
-            if (!repository.exists()) {
-                System.out.print("Repository file does not exists .. initializing repository");
-            }
-
-            TCPServer tcpServer = new TCPServer(Integer.parseInt(args[1]),
-                                                repository.getAbsolutePath());
-
-            System.out.println("[Axis2] Using the Repository " + repository.getAbsolutePath());
-            System.out.println("[Axis2] Starting the TCP Server on port " + args[1]);
-            tcpServer.start();
-            Runtime.getRuntime().addShutdownHook(new Thread(tcpServer));
-        }
-    }
-
     public void run() {
         while (started) {
             Socket socket = null;
 
             try {
-                socket = serversocket.accept();
-            } catch (java.io.InterruptedIOException iie) {
-            }
-            catch (Exception e) {
-                log.debug(e);
+                socket = serverSocket.accept();
+            } catch (java.io.InterruptedIOException ignored) {
 
+            } catch (Exception e) {
+                log.debug(e);
                 break;
             }
 
             if (socket != null) {
-                configContext.getThreadPool().execute(new TCPWorker(configContext, socket));
+                workerPool.execute(new TCPWorker(endpoint, socket));
             }
         }
     }
 
-    public synchronized void start() throws AxisFault {
-        if (serversocket == null) {
-            serversocket = openSocket(port);
-        }
-        started = true;
-        this.configContext.getThreadPool().execute(this);
-    }
-
-
-    /**
-     * Controls the number of server sockets kept open.
-     */
-    public ServerSocket openSocket(int port) throws AxisFault {
-        for (int i = 0; i < 5; i++) {
-            try {
-                return new ServerSocket(port + i);
-            } catch (IOException e) {
-                // What I'm gonna do here. Try again.
-            }
-        }
-
-        throw new AxisFault(Messages.getMessage("failedToOpenSocket"));
-    }
-
-
-    /*
-    *  (non-Javadoc)
-    * @see org.apache.axis2.transport.TransportListener#stop()
-    */
-    public void stop() throws AxisFault {
-        try {
-            this.serversocket.close();
-            started = false;
-        } catch (IOException e) {
-            throw AxisFault.makeFault(e);
-        }
-    }
-
-    public ConfigurationContext getConfigurationContext() {
-        return this.configContext;
-    }
-
-    /**
-     * I fthe hostAddress parameter is present in axis2.xml then the EPR will be
-     * created by taking the hostAddres into account
-     * (non-Javadoc)
-     *
-     * @see org.apache.axis2.transport.TransportListener#getEPRForService(String, String)
-     */
-    public EndpointReference getEPRForService(String serviceName, String ip) throws AxisFault {
-        EndpointReference[] epRsForService = getEPRsForService(serviceName, ip);
-        return epRsForService != null ? epRsForService[0] : null;
-    }
-
-    public EndpointReference[] getEPRsForService(String serviceName, String ip) throws AxisFault {
-        //if host address is present
-        if (hostAddress != null) {
-            if (serversocket != null) {
-                // todo this has to fix
-                return new EndpointReference[]{
-                        new EndpointReference(hostAddress + "/" + contextPath + serviceName)};
+    public void startServer() throws IOException {
+        if (serverSocket == null) {
+            if (endpoint.getHost() != null) {
+                InetAddress address = InetAddress.getByName(endpoint.getHost());
+                serverSocket = new ServerSocket(endpoint.getPort(), endpoint.getBacklog(), address);
             } else {
-                log.debug("Unable to generate EPR for the transport tcp");
-                return null;
+                serverSocket = new ServerSocket(endpoint.getPort(), endpoint.getBacklog());
             }
         }
-        if (ip == null) {
-            try {
-                ip = Utils.getIpAddress(configContext.getAxisConfiguration());
-            } catch (SocketException e) {
-                throw AxisFault.makeFault(e);
-            }
-        }
-        if (serversocket != null) {
-            // todo this has to fix
-            return new EndpointReference[]{
-                    new EndpointReference("tcp://" + ip + ":" + (serversocket.getLocalPort())
-                                          + "/" + contextPath + "/" + serviceName)};
-        } else {
-            log.debug("Unable to generate EPR for the transport tcp");
-            return null;
-        }
+        started = true;
+        endpoint.getListener().getConfigurationContext().getThreadPool().execute(this);
+        log.info("TCP server started on port : " + endpoint.getPort());
     }
 
-    public SessionContext getSessionContext(MessageContext messageContext) {
-        return null;
+    public void stopServer() throws IOException {
+        started = false;
+        serverSocket.close();
+        serverSocket = null;
+        log.info("TCP server stopped on port : " + endpoint.getPort());
     }
-
-    public void destroy() {
-        this.configContext = null;
-    }
 }
