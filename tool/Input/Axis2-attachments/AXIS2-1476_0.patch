Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/proxy/ProxyNonWrappedTests.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/proxy/ProxyNonWrappedTests.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/proxy/ProxyNonWrappedTests.java	(working copy)
@@ -1,117 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.proxy;
-
-import java.io.File;
-import java.net.URL;
-import java.util.concurrent.Future;
-
-import javax.xml.namespace.QName;
-import javax.xml.ws.AsyncHandler;
-import javax.xml.ws.BindingProvider;
-import javax.xml.ws.Service;
-
-import org.apache.axis2.jaxws.proxy.doclitnonwrapped.sei.DocLitnonWrappedProxy;
-import org.apache.axis2.jaxws.proxy.doclitnonwrapped.sei.ProxyDocLitUnwrappedService;
-import org.test.proxy.doclitnonwrapped.Invoke;
-import org.test.proxy.doclitnonwrapped.ObjectFactory;
-import org.test.proxy.doclitnonwrapped.ReturnType;
-
-
-import junit.framework.TestCase;
-
-/**
- * This test cases will use proxy NON wrapped wsdl to invoke methods
- * on a deployed Server Endpoint.
- */
-public class ProxyNonWrappedTests extends TestCase {
-
-	QName serviceName = new QName("http://doclitnonwrapped.proxy.test.org", "ProxyDocLitUnwrappedService");
-	private String axisEndpoint = "http://localhost:8080/axis2/services/ProxyDocLitUnwrappedService";
-	private QName portName = new QName("http://org.apache.axis2.proxy.doclitwrapped", "ProxyDocLitWrappedPort");
-	private String wsdlLocation = "test-resources/wsdl/ProxyDocLitnonWrapped.wsdl";
-	public ProxyNonWrappedTests() {
-		super();
-		// TODO Auto-generated constructor stub
-	}
-
-	/**
-	 * @param arg0
-	 */
-	public ProxyNonWrappedTests(String arg0) {
-		super(arg0);
-		// TODO Auto-generated constructor stub
-	}
-	
-	public void testInvoke(){
-		System.out.println("-----------------------------------");
-		System.out.println("test: " + getName());
-		System.out.println(">>Testing Sync Inovoke on Proxy DocLit non-wrapped");
-		ObjectFactory factory = new ObjectFactory();
-		Invoke invokeObj = factory.createInvoke();
-		invokeObj.setInvokeStr("test request for twoWay Operation");
-		Service service = Service.create(null, serviceName);
-		assertNotNull(service);
-		DocLitnonWrappedProxy proxy = service.getPort(portName, DocLitnonWrappedProxy.class);
-		assertNotNull(proxy);
-		BindingProvider p =	(BindingProvider)proxy;
-		p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
-		ReturnType response = proxy.invoke(invokeObj);
-		assertNotNull(response);
-		System.out.println(">>Response =" +response.getReturnStr());
-		
-		System.out.println("-------------------------------------");
-	}
-	
-	public void testInvokeAsyncCallback(){
-		try{ 
-			System.out.println("---------------------------------------");
-			System.out.println("DocLitNonWrapped test case: " + getName());
-			//Create wsdl url
-			File wsdl= new File(wsdlLocation); 
-			URL wsdlUrl = wsdl.toURL(); 
-			ObjectFactory factory = new ObjectFactory();
-			//create input object to web service operation
-			Invoke invokeObj = factory.createInvoke();
-			invokeObj.setInvokeStr("test request for twoWay Async Operation");
-			//Create Service
-			ProxyDocLitUnwrappedService service = new ProxyDocLitUnwrappedService(wsdlUrl, serviceName);
-			//Create proxy
-			DocLitnonWrappedProxy proxy = service.getProxyDocLitnonWrappedPort(); 
-			System.out.println(">>Invoking Binding Provider property");
-			//Setup Endpoint url -- optional.
-			BindingProvider p =	(BindingProvider)proxy;
-				p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
-			System.out.println(">> Invoking Proxy Asynchronous Callback");
-			AsyncHandler<ReturnType> handler = new AsyncCallback();
-			//Invoke operation Asynchronously.
-			Future<?> monitor = proxy.invokeAsync(invokeObj, handler);
-			while(!monitor.isDone()){
-				Thread.sleep(1000);
-			}
-			System.out.println("---------------------------------------");
-		}catch(Exception e){ 
-			e.printStackTrace(); 
-            fail("Exception received" + e);
-		}
-	}
-	
-	public void testInvokeAsyncPolling(){
-		
-	}
-
-}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/proxy/ProxyTests.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/proxy/ProxyTests.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/proxy/ProxyTests.java	(working copy)
@@ -1,240 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.proxy;
-
-import java.io.File;
-import java.net.URL;
-import java.util.concurrent.Future;
-
-import javax.xml.namespace.QName;
-import javax.xml.ws.AsyncHandler;
-import javax.xml.ws.BindingProvider;
-import javax.xml.ws.Service;
-
-import junit.framework.TestCase;
-
-import org.apache.axis2.jaxws.proxy.doclitwrapped.sei.DocLitWrappedProxy;
-import org.apache.axis2.jaxws.proxy.doclitwrapped.sei.ProxyDocLitWrappedService;
-
-
-public class ProxyTests extends TestCase {
-	private QName serviceName = new QName(
-			"http://org.apache.axis2.proxy.doclitwrapped", "ProxyDocLitWrappedService");
-	private String wasEndpoint = "http://localhost:7777/axis2/services/ProxyDocLitWrappedService";
-	private String axisEndpoint = "http://localhost:8080/axis2/services/ProxyDocLitWrappedService";
-	private QName portName = new QName("http://org.apache.axis2.proxy.doclitwrapped",
-			"ProxyDocLitWrappedPort");
-	private String wsdlLocation = "test/org/apache/axis2/jaxws/proxy/doclitwrapped/META-INF/ProxyDocLitWrapped.wsdl";
-	private boolean runningOnAxis = true;
-	
-	public void testMultipleServiceCalls(){
-		try{
-			if(!runningOnAxis){
-				return;
-			}
-			System.out.println("---------------------------------------");
-			System.out.println("test:" +getName());
-			String request = new String("some string request");
-			System.out.println("Service Call #1");
-			ProxyDocLitWrappedService service1 = new ProxyDocLitWrappedService();
-			DocLitWrappedProxy proxy1 = service1.getProxyDocLitWrappedPort();
-			BindingProvider p1 =	(BindingProvider)proxy1;
-			p1.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
-			String response1 = proxy1.invoke(request);
-			System.out.println("Proxy Response =" + response1);
-			System.out.println("---------------------------------------");
-			
-			System.out.println("Service Call #2");
-			ProxyDocLitWrappedService service2 = new ProxyDocLitWrappedService();
-			DocLitWrappedProxy proxy2 = service2.getProxyDocLitWrappedPort();
-			BindingProvider p2 =	(BindingProvider)proxy2;
-			p2.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
-			String response2 = proxy2.invoke(request);
-			System.out.println("Proxy Response =" + response2);
-			System.out.println("---------------------------------------");
-			
-		}catch(Exception e){
-			//fail(getName() + " failed");
-			e.printStackTrace();
-		}
-	}
-    
-    public void testInvokeWithNullParam(){
-        try{ 
-            if(!runningOnAxis){
-                return;
-            }
-            System.out.println("---------------------------------------");
-            System.out.println("Test Name: "+getName());
-            File wsdl= new File(wsdlLocation); 
-            URL wsdlUrl = wsdl.toURL(); 
-            Service service = Service.create(null, serviceName); 
-            Object proxy =service.getPort(portName, DocLitWrappedProxy.class);
-            System.out.println(">>Invoking Binding Provider property");
-            BindingProvider p = (BindingProvider)proxy;
-            p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
-
-            DocLitWrappedProxy dwp = (DocLitWrappedProxy)proxy;
-            System.out.println(">> Invoking Proxy Synchronously");
-            String request = null;
-            String response = dwp.invoke(request);
-            System.out.println("Proxy Response =" + response);
-            System.out.println("---------------------------------------");
-        }catch(Exception e){ 
-            e.printStackTrace(); 
-            fail("Exception received" + e);
-        }
-    }
-	public void testInvoke(){
-		try{ 
-			if(!runningOnAxis){
-				return;
-			}
-			System.out.println("---------------------------------------");
-			
-			File wsdl= new File(wsdlLocation); 
-			URL wsdlUrl = wsdl.toURL(); 
-			Service service = Service.create(null, serviceName);
-			String request = new String("some string request"); 
-			Object proxy =service.getPort(portName, DocLitWrappedProxy.class);
-			System.out.println(">>Invoking Binding Provider property");
-			BindingProvider p =	(BindingProvider)proxy;
-				p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
-				
-			DocLitWrappedProxy dwp = (DocLitWrappedProxy)proxy;
-			System.out.println(">> Invoking Proxy Synchronously");
-			String response = dwp.invoke(request);
-			System.out.println("Proxy Response =" + response);
-			System.out.println("---------------------------------------");
-		}catch(Exception e){ 
-			e.printStackTrace(); 
-            fail("Exception received" + e);
-		}
-	}
-
-    public void testInvokeWithWSDL(){
-        try{ 
-            if(!runningOnAxis){
-                return;
-            }
-            System.out.println("---------------------------------------");
-            File wsdl= new File(wsdlLocation); 
-            URL wsdlUrl = wsdl.toURL(); 
-            Service service = Service.create(wsdlUrl, serviceName);
-            String request = new String("some string request"); 
-            Object proxy =service.getPort(portName, DocLitWrappedProxy.class);
-            System.out.println(">>Invoking Binding Provider property");
-            BindingProvider p = (BindingProvider)proxy;
-            p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
-                
-            DocLitWrappedProxy dwp = (DocLitWrappedProxy)proxy;
-            System.out.println(">> Invoking Proxy Synchronously");
-            String response = dwp.invoke(request);
-            System.out.println("Proxy Response =" + response);
-            System.out.println("---------------------------------------");
-        }catch(Exception e){ 
-            e.printStackTrace(); 
-            fail("Exception received" + e);
-        }
-    }
-	
-	public void testInvokeAsyncCallback(){
-		try{ 
-			if(!runningOnAxis){
-				return;
-			}
-			System.out.println("---------------------------------------");
-			
-			File wsdl= new File(wsdlLocation); 
-			URL wsdlUrl = wsdl.toURL(); 
-			Service service = Service.create(null, serviceName);
-			String request = new String("some string request"); 
-			Object proxy =service.getPort(portName, DocLitWrappedProxy.class);
-			System.out.println(">>Invoking Binding Provider property");
-			BindingProvider p =	(BindingProvider)proxy;
-				p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
-				
-			DocLitWrappedProxy dwp = (DocLitWrappedProxy)proxy;
-			System.out.println(">> Invoking Proxy Asynchronous Callback");
-			AsyncHandler handler = new AsyncCallback();
-			Future<?> response = dwp.invokeAsync(request, handler);
-			System.out.println("---------------------------------------");
-		}catch(Exception e){ 
-			e.printStackTrace(); 
-            fail("Exception received" + e);
-		}
-	}
-	public void testTwoWay(){
-		try{ 
-			if(runningOnAxis){
-				return;
-			}
-			File wsdl= new File(wsdlLocation); 
-			URL wsdlUrl = wsdl.toURL(); 
-			Service service = Service.create(null, serviceName);
-			String request = new String("some string request"); 
-			
-			Object proxy =service.getPort(portName, DocLitWrappedProxy.class); 
-			BindingProvider p =	(BindingProvider)proxy;
-				p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,wasEndpoint);
-				
-			DocLitWrappedProxy dwp = (DocLitWrappedProxy)proxy;  
-			String response = dwp.twoWay(request);
-			System.out.println("Response =" + response);
-		}catch(Exception e){ 
-			e.printStackTrace(); 
-            fail("Exception received" + e);
-		}
-	}
-	
-	public void testOneWay(){
-		
-	}
-	
-	public void testHolder(){
-		
-	}
-	
-	public void testTwoWayAsyncCallback(){
-		try{ 
-			if(runningOnAxis){
-				return;
-			}
-			File wsdl= new File(wsdlLocation); 
-			URL wsdlUrl = wsdl.toURL(); 
-			Service service = Service.create(null, serviceName);
-			
-			String request = new String("some string request"); 
-			
-			Object proxy =service.getPort(portName, DocLitWrappedProxy.class); 
-			BindingProvider p =	(BindingProvider)proxy;
-				p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,wasEndpoint);
-				
-			DocLitWrappedProxy dwp = (DocLitWrappedProxy)proxy;
-			AsyncHandler handler = new AsyncCallback();
-			Future<?> response = dwp.twoWayAsync(request, handler);
-			
-		}catch(Exception e){ 
-			e.printStackTrace(); 
-            fail("Exception received" + e);
-		}
-	}
-	
-	public void testAsyncPooling(){
-		
-	}
-}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/proxy/AsyncCallback.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/proxy/AsyncCallback.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/proxy/AsyncCallback.java	(working copy)
@@ -1,55 +0,0 @@
-/**
- * 
- */
-package org.apache.axis2.proxy;
-
-import java.util.concurrent.ExecutionException;
-
-import javax.xml.ws.AsyncHandler;
-import javax.xml.ws.Response;
-
-import org.test.proxy.doclitwrapped.ReturnType;
-
-
-
-/**
- * @author nvthaker
- *
- */
-public class AsyncCallback implements AsyncHandler {
-
-	/**
-	 * 
-	 */
-	public AsyncCallback() {
-		super();
-		// TODO Auto-generated constructor stub
-	}
-
-	/* (non-Javadoc)
-	 * @see javax.xml.ws.AsyncHandler#handleResponse(javax.xml.ws.Response)
-	 */
-	public void handleResponse(Response response) {
-		try{
-			Object obj = response.get();
-			if(obj instanceof ReturnType){
-				ReturnType type = (ReturnType)obj;
-				System.out.println(">>Return String = "+type.getReturnStr());
-				return;
-			}
-			if(obj instanceof org.test.proxy.doclitnonwrapped.ReturnType){
-				org.test.proxy.doclitnonwrapped.ReturnType returnType = (org.test.proxy.doclitnonwrapped.ReturnType)obj;
-				System.out.println(">>Return String = "+returnType.getReturnStr());
-				return;
-			}
-			System.out.println("Response.get should have been ReturnType" );
-			
-		}catch(ExecutionException e){
-			e.printStackTrace();
-		}catch(InterruptedException e){
-			e.printStackTrace();
-		}
-
-	}
-
-}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/JAXBCallbackHandler.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/JAXBCallbackHandler.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/JAXBCallbackHandler.java	(working copy)
@@ -1,34 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws;
-
-import javax.xml.ws.AsyncHandler;
-import javax.xml.ws.Response;
-
-import test.EchoStringResponse;
-
-public class JAXBCallbackHandler<T> implements AsyncHandler<T> {
-
-    public void handleResponse(Response response) {
-        try {
-            EchoStringResponse esr = (EchoStringResponse) response.get();
-            System.out.println(">> Async response received: " + esr.getEchoStringReturn());
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/proxy/ProxyNonWrappedTests.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/proxy/ProxyNonWrappedTests.java	(revision 0)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/proxy/ProxyNonWrappedTests.java	(revision 0)
@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.jaxws.proxy;
+
+import java.io.File;
+import java.net.URL;
+import java.util.concurrent.Future;
+
+import javax.xml.namespace.QName;
+import javax.xml.ws.AsyncHandler;
+import javax.xml.ws.BindingProvider;
+import javax.xml.ws.Service;
+
+import org.apache.axis2.jaxws.proxy.doclitnonwrapped.sei.DocLitnonWrappedProxy;
+import org.apache.axis2.jaxws.proxy.doclitnonwrapped.sei.ProxyDocLitUnwrappedService;
+import org.test.proxy.doclitnonwrapped.Invoke;
+import org.test.proxy.doclitnonwrapped.ObjectFactory;
+import org.test.proxy.doclitnonwrapped.ReturnType;
+
+
+import junit.framework.TestCase;
+
+/**
+ * This test cases will use proxy NON wrapped wsdl to invoke methods
+ * on a deployed Server Endpoint.
+ */
+public class ProxyNonWrappedTests extends TestCase {
+
+    QName serviceName = new QName("http://doclitnonwrapped.proxy.test.org", "ProxyDocLitUnwrappedService");
+    private String axisEndpoint = "http://localhost:8080/axis2/services/ProxyDocLitUnwrappedService";
+    private QName portName = new QName("http://org.apache.axis2.proxy.doclitwrapped", "ProxyDocLitWrappedPort");
+    private String wsdlLocation = "test-resources/wsdl/ProxyDocLitnonWrapped.wsdl";
+    public ProxyNonWrappedTests() {
+        super();
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @param arg0
+     */
+    public ProxyNonWrappedTests(String arg0) {
+        super(arg0);
+        // TODO Auto-generated constructor stub
+    }
+    
+    public void testInvoke(){
+        System.out.println("-----------------------------------");
+        System.out.println("test: " + getName());
+        System.out.println(">>Testing Sync Inovoke on Proxy DocLit non-wrapped");
+        ObjectFactory factory = new ObjectFactory();
+        Invoke invokeObj = factory.createInvoke();
+        invokeObj.setInvokeStr("test request for twoWay Operation");
+        Service service = Service.create(null, serviceName);
+        assertNotNull(service);
+        DocLitnonWrappedProxy proxy = service.getPort(portName, DocLitnonWrappedProxy.class);
+        assertNotNull(proxy);
+        BindingProvider p = (BindingProvider)proxy;
+        p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
+        ReturnType response = proxy.invoke(invokeObj);
+        assertNotNull(response);
+        System.out.println(">>Response =" +response.getReturnStr());
+        
+        System.out.println("-------------------------------------");
+    }
+    
+    public void testInvokeAsyncCallback(){
+        try{ 
+            System.out.println("---------------------------------------");
+            System.out.println("DocLitNonWrapped test case: " + getName());
+            //Create wsdl url
+            File wsdl= new File(wsdlLocation); 
+            URL wsdlUrl = wsdl.toURL(); 
+            ObjectFactory factory = new ObjectFactory();
+            //create input object to web service operation
+            Invoke invokeObj = factory.createInvoke();
+            invokeObj.setInvokeStr("test request for twoWay Async Operation");
+            //Create Service
+            ProxyDocLitUnwrappedService service = new ProxyDocLitUnwrappedService(wsdlUrl, serviceName);
+            //Create proxy
+            DocLitnonWrappedProxy proxy = service.getProxyDocLitnonWrappedPort(); 
+            System.out.println(">>Invoking Binding Provider property");
+            //Setup Endpoint url -- optional.
+            BindingProvider p = (BindingProvider)proxy;
+                p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
+            System.out.println(">> Invoking Proxy Asynchronous Callback");
+            AsyncHandler<ReturnType> handler = new AsyncCallback();
+            //Invoke operation Asynchronously.
+            Future<?> monitor = proxy.invokeAsync(invokeObj, handler);
+            while(!monitor.isDone()){
+                Thread.sleep(1000);
+            }
+            System.out.println("---------------------------------------");
+        }catch(Exception e){ 
+            e.printStackTrace(); 
+            fail("Exception received" + e);
+        }
+    }
+    
+    public void testInvokeAsyncPolling(){
+        
+    }
+
+}
+
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/proxy/ProxyTests.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/proxy/ProxyTests.java	(revision 0)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/proxy/ProxyTests.java	(revision 0)
@@ -0,0 +1,280 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.jaxws.proxy;
+
+import java.io.File;
+import java.net.URL;
+import java.util.concurrent.Future;
+
+import javax.xml.namespace.QName;
+import javax.xml.ws.AsyncHandler;
+import javax.xml.ws.BindingProvider;
+import javax.xml.ws.Response;
+import javax.xml.ws.Service;
+
+import junit.framework.TestCase;
+
+import org.apache.axis2.jaxws.proxy.doclitwrapped.sei.DocLitWrappedProxy;
+import org.apache.axis2.jaxws.proxy.doclitwrapped.sei.ProxyDocLitWrappedService;
+import org.test.proxy.doclitwrapped.ReturnType;
+
+public class ProxyTests extends TestCase {
+    private QName serviceName = new QName(
+            "http://org.apache.axis2.proxy.doclitwrapped", "ProxyDocLitWrappedService");
+    private String axisEndpoint = "http://localhost:8080/axis2/services/ProxyDocLitWrappedService";
+    private QName portName = new QName("http://org.apache.axis2.proxy.doclitwrapped",
+            "ProxyDocLitWrappedPort");
+    private String wsdlLocation = "test/org/apache/axis2/jaxws/proxy/doclitwrapped/META-INF/ProxyDocLitWrapped.wsdl";
+    private boolean runningOnAxis = true;
+    
+    public void testMultipleServiceCalls(){
+        try{
+            if(!runningOnAxis){
+                return;
+            }
+            System.out.println("---------------------------------------");
+            System.out.println("test:" +getName());
+            String request = new String("some string request");
+            System.out.println("Service Call #1");
+            ProxyDocLitWrappedService service1 = new ProxyDocLitWrappedService();
+            DocLitWrappedProxy proxy1 = service1.getProxyDocLitWrappedPort();
+            BindingProvider p1 =    (BindingProvider)proxy1;
+            p1.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
+            String response1 = proxy1.invoke(request);
+            System.out.println("Proxy Response =" + response1);
+            System.out.println("---------------------------------------");
+            
+            System.out.println("Service Call #2");
+            ProxyDocLitWrappedService service2 = new ProxyDocLitWrappedService();
+            DocLitWrappedProxy proxy2 = service2.getProxyDocLitWrappedPort();
+            BindingProvider p2 =    (BindingProvider)proxy2;
+            p2.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
+            String response2 = proxy2.invoke(request);
+            System.out.println("Proxy Response =" + response2);
+            System.out.println("---------------------------------------");
+            
+        }catch(Exception e){
+            //fail(getName() + " failed");
+            e.printStackTrace();
+        }
+    }
+    
+    public void testInvokeWithNullParam(){
+        try{ 
+            if(!runningOnAxis){
+                return;
+            }
+            System.out.println("---------------------------------------");
+            System.out.println("Test Name: "+getName());
+            File wsdl= new File(wsdlLocation); 
+            URL wsdlUrl = wsdl.toURL(); 
+            Service service = Service.create(null, serviceName); 
+            Object proxy =service.getPort(portName, DocLitWrappedProxy.class);
+            System.out.println(">>Invoking Binding Provider property");
+            BindingProvider p = (BindingProvider)proxy;
+            p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
+
+            DocLitWrappedProxy dwp = (DocLitWrappedProxy)proxy;
+            System.out.println(">> Invoking Proxy Synchronously");
+            String request = null;
+            String response = dwp.invoke(request);
+            System.out.println("Proxy Response =" + response);
+            System.out.println("---------------------------------------");
+        }catch(Exception e){ 
+            e.printStackTrace(); 
+            fail("Exception received" + e);
+        }
+    }
+    public void testInvoke(){
+        try{ 
+            if(!runningOnAxis){
+                return;
+            }
+            System.out.println("---------------------------------------");
+            
+            File wsdl= new File(wsdlLocation); 
+            URL wsdlUrl = wsdl.toURL(); 
+            Service service = Service.create(null, serviceName);
+            String request = new String("some string request"); 
+            Object proxy =service.getPort(portName, DocLitWrappedProxy.class);
+            System.out.println(">>Invoking Binding Provider property");
+            BindingProvider p = (BindingProvider)proxy;
+                p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
+                
+            DocLitWrappedProxy dwp = (DocLitWrappedProxy)proxy;
+            System.out.println(">> Invoking Proxy Synchronously");
+            String response = dwp.invoke(request);
+            System.out.println("Proxy Response =" + response);
+            System.out.println("---------------------------------------");
+        }catch(Exception e){ 
+            e.printStackTrace(); 
+            fail("Exception received" + e);
+        }
+    }
+
+    public void testInvokeWithWSDL(){
+        try{ 
+            if(!runningOnAxis){
+                return;
+            }
+            System.out.println("---------------------------------------");
+            File wsdl= new File(wsdlLocation); 
+            URL wsdlUrl = wsdl.toURL(); 
+            Service service = Service.create(wsdlUrl, serviceName);
+            String request = new String("some string request"); 
+            Object proxy =service.getPort(portName, DocLitWrappedProxy.class);
+            System.out.println(">>Invoking Binding Provider property");
+            BindingProvider p = (BindingProvider)proxy;
+            p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
+                
+            DocLitWrappedProxy dwp = (DocLitWrappedProxy)proxy;
+            System.out.println(">> Invoking Proxy Synchronously");
+            String response = dwp.invoke(request);
+            System.out.println("Proxy Response =" + response);
+            System.out.println("---------------------------------------");
+        }catch(Exception e){ 
+            e.printStackTrace(); 
+            fail("Exception received" + e);
+        }
+    }
+    
+    public void testInvokeAsyncCallback(){
+        try{ 
+            if(!runningOnAxis){
+                return;
+            }
+            System.out.println("---------------------------------------");
+            
+            File wsdl= new File(wsdlLocation); 
+            URL wsdlUrl = wsdl.toURL(); 
+            Service service = Service.create(null, serviceName);
+            String request = new String("some string request"); 
+            Object proxy =service.getPort(portName, DocLitWrappedProxy.class);
+            System.out.println(">>Invoking Binding Provider property");
+            BindingProvider p = (BindingProvider)proxy;
+                p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
+                
+            DocLitWrappedProxy dwp = (DocLitWrappedProxy)proxy;
+            System.out.println(">> Invoking Proxy Asynchronous Callback");
+            AsyncHandler handler = new AsyncCallback();
+            Future<?> response = dwp.invokeAsync(request, handler);
+            System.out.println("---------------------------------------");
+        }catch(Exception e){ 
+            e.printStackTrace(); 
+            fail("Exception received" + e);
+        }
+    }
+    
+    public void testInvokeAsyncPolling() {
+        try { 
+            System.out.println("---------------------------------------");
+            
+            File wsdl= new File(wsdlLocation); 
+            URL wsdlUrl = wsdl.toURL(); 
+            Service service = Service.create(null, serviceName);
+            DocLitWrappedProxy proxy =service.getPort(portName, DocLitWrappedProxy.class);
+            
+            String request = new String("some string request"); 
+            
+            System.out.println(">> Invoking Binding Provider property");
+            BindingProvider p = (BindingProvider) proxy;
+            p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, axisEndpoint);
+                
+            System.out.println(">> Invoking Proxy with async polling request");
+            Response<ReturnType> asyncResponse = proxy.invokeAsync(request);
+
+            while (!asyncResponse.isDone()) {
+                System.out.println(">> Async invocation still not complete");
+                Thread.sleep(1000);
+            }
+            
+            ReturnType response = asyncResponse.get();
+            assertNotNull(response);
+        }
+        catch(Exception e) { 
+            e.printStackTrace(); 
+            fail("Exception received" + e);
+        }
+    }
+    
+    public void testTwoWay(){
+        /*
+        try{ 
+            if(runningOnAxis){
+                return;
+            }
+            File wsdl= new File(wsdlLocation); 
+            URL wsdlUrl = wsdl.toURL(); 
+            Service service = Service.create(null, serviceName);
+            String request = new String("some string request"); 
+            
+            Object proxy =service.getPort(portName, DocLitWrappedProxy.class); 
+            BindingProvider p = (BindingProvider)proxy;
+            p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,wasEndpoint);
+                
+            DocLitWrappedProxy dwp = (DocLitWrappedProxy)proxy;  
+            String response = dwp.twoWay(request);
+            System.out.println("Response =" + response);
+        }catch(Exception e){ 
+            e.printStackTrace(); 
+            fail("Exception received" + e);
+        }
+        */
+    }
+    
+    public void testOneWay(){
+        
+    }
+    
+    public void testHolder(){
+        
+    }
+    
+    public void testTwoWayAsyncCallback(){
+        /*
+        try{ 
+            if(runningOnAxis){
+                return;
+            }
+            File wsdl= new File(wsdlLocation); 
+            URL wsdlUrl = wsdl.toURL(); 
+            Service service = Service.create(null, serviceName);
+            
+            String request = new String("some string request"); 
+            
+            Object proxy =service.getPort(portName, DocLitWrappedProxy.class); 
+            BindingProvider p = (BindingProvider)proxy;
+                p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,wasEndpoint);
+                
+            DocLitWrappedProxy dwp = (DocLitWrappedProxy)proxy;
+            AsyncHandler handler = new AsyncCallback();
+            Future<?> response = dwp.twoWayAsync(request, handler);
+            
+        }catch(Exception e){ 
+            e.printStackTrace(); 
+            fail("Exception received" + e);
+        }
+        */
+    }
+    
+    public void testAsyncPooling(){
+        
+    }
+}
+
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/proxy/AsyncCallback.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/proxy/AsyncCallback.java	(revision 0)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/proxy/AsyncCallback.java	(revision 0)
@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.jaxws.proxy;
+
+import java.util.concurrent.ExecutionException;
+
+import javax.xml.ws.AsyncHandler;
+import javax.xml.ws.Response;
+
+import org.test.proxy.doclitwrapped.ReturnType;
+
+/**
+ *
+ */
+public class AsyncCallback implements AsyncHandler {
+
+    public AsyncCallback() {
+        super();
+    }
+
+    /* (non-Javadoc)
+     * @see javax.xml.ws.AsyncHandler#handleResponse(javax.xml.ws.Response)
+     */
+    public void handleResponse(Response response) {
+        try{
+            Object obj = response.get();
+            if(obj instanceof ReturnType){
+                ReturnType type = (ReturnType)obj;
+                System.out.println(">>Return String = "+type.getReturnStr());
+                return;
+            }
+            if(obj instanceof org.test.proxy.doclitnonwrapped.ReturnType){
+                org.test.proxy.doclitnonwrapped.ReturnType returnType = (org.test.proxy.doclitnonwrapped.ReturnType)obj;
+                System.out.println(">>Return String = "+returnType.getReturnStr());
+                return;
+            }
+            System.out.println("Response.get should have been ReturnType" );
+            
+        }catch(ExecutionException e){
+            e.printStackTrace();
+        }catch(InterruptedException e){
+            e.printStackTrace();
+        }
+    }
+
+}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/JAXBDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/JAXBDispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/JAXBDispatch.java	(working copy)
@@ -1,108 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws;
-
-import java.util.concurrent.Future;
-
-import javax.xml.bind.JAXBContext;
-import javax.xml.ws.Dispatch;
-import javax.xml.ws.Service;
-import javax.xml.ws.WebServiceException;
-
-import junit.framework.TestCase;
-import test.EchoString;
-import test.EchoStringResponse;
-import test.ObjectFactory;
-
-public class JAXBDispatch extends TestCase {
-
-    private Dispatch<Object> dispatch;
-    
-    public JAXBDispatch(String name) {
-        super(name);
-    }
-    
-    public void setUp() throws Exception {
-        //Create the Service object
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        
-        //Create the JAX-B Dispatch object
-        JAXBContext jbc = null;
-        jbc = JAXBContext.newInstance("test");
-        dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                jbc, Service.Mode.PAYLOAD);
-    }
-    
-    public void testSync() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-
-        // Create the input param
-        ObjectFactory factory = new ObjectFactory();
-        EchoString request = factory.createEchoString();         
-        request.setInput("SYNC JAXB TEST");
-        
-        // Invoke the Dispatch<Object>
-        System.out.println(">> Invoking sync Dispatch with JAX-B Parameter");
-        EchoStringResponse response = (EchoStringResponse) dispatch.invoke(request);
-        
-        assertNotNull(response);
-        
-        System.out.println(">> Response content: " + response.getEchoStringReturn());
-        
-        assertTrue("[ERROR] - Response object was null", response != null);
-        assertTrue("[ERROR] - No content in response object", response.getEchoStringReturn() != null);
-        assertTrue("[ERROR] - Zero length content in response", response.getEchoStringReturn().length() > 0);
-    }
-    
-    public void testAysnc() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Create the input param
-        ObjectFactory factory = new ObjectFactory();
-        EchoString request = factory.createEchoString();         
-        request.setInput("ASYNC(CALLBACK) JAXB TEST");
-        
-        // Create the callback for async responses
-        JAXBCallbackHandler<Object> callback = new JAXBCallbackHandler<Object>();
-        
-        // Invoke the Dispatch<Object> asynchronously
-        System.out.println(">> Invoking async(callback) Dispatch with JAX-B Parameter");
-        Future<?> monitor = dispatch.invokeAsync(request, callback);
-        
-        while (!monitor.isDone()) {
-             System.out.println(">> Async invocation still not complete");
-             Thread.sleep(1000);
-        }
-    }
-    
-    public void testOneWay() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-
-        // Create the input param
-        ObjectFactory factory = new ObjectFactory();
-        EchoString request = factory.createEchoString();         
-        request.setInput("ONE-WAY JAXB TEST");
-        
-        // Invoke the Dispatch<Object> one-way
-        System.out.println(">> Invoking one-way Dispatch with JAX-B Parameter");
-        dispatch.invokeOneWay(request);
-    }
-}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/DispatchTestSuite.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/DispatchTestSuite.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/DispatchTestSuite.java	(working copy)
@@ -1,40 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws;
-
-import junit.framework.TestSuite;
-
-public class DispatchTestSuite {
-
-    public static TestSuite suite() {
-        TestSuite suite = new TestSuite();
-        suite = addTestSuites(suite);
-        return suite;
-    }
-	
-    public static TestSuite addTestSuites(TestSuite suite) {
-        suite.addTestSuite(StringDispatch.class);
-        suite.addTestSuite(StreamSourceDispatch.class);
-        suite.addTestSuite(DOMSourceDispatch.class);
-        suite.addTestSuite(SAXSourceDispatch.class);
-        suite.addTestSuite(SOAPMessageDispatch.class);
-        suite.addTestSuite(JAXBDispatch.class);
-        suite.addTestSuite(JAXBSourceDispatch.class);
-        return suite;
-    }
-
-}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/provider/source/SourceProvider.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/provider/source/SourceProvider.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/provider/source/SourceProvider.java	(working copy)
@@ -20,17 +20,15 @@
 import java.io.InputStream;
 import java.io.StringWriter;
 
-import javax.xml.ws.Provider;
-import javax.xml.ws.WebServiceProvider;
 import javax.xml.transform.Result;
 import javax.xml.transform.Source;
 import javax.xml.transform.Transformer;
 import javax.xml.transform.TransformerFactory;
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.transform.stream.StreamSource;
+import javax.xml.ws.Provider;
+import javax.xml.ws.WebServiceProvider;
 
-import org.apache.axis2.jaxws.DispatchTestConstants;
-
 @WebServiceProvider()
 public class SourceProvider implements Provider<Source> {
     String responseAsString = new String("<ns2:ReturnType xmlns:ns2=\"http://test\"><return_str>some response</return_str></ns2:ReturnType>");
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/provider/sourcemsg/SourceMessageProvider.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/provider/sourcemsg/SourceMessageProvider.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/provider/sourcemsg/SourceMessageProvider.java	(working copy)
@@ -20,19 +20,17 @@
 import java.io.InputStream;
 import java.io.StringWriter;
 
-import javax.xml.ws.Provider;
-import javax.xml.ws.Service;
-import javax.xml.ws.ServiceMode;
-import javax.xml.ws.WebServiceProvider;
 import javax.xml.transform.Result;
 import javax.xml.transform.Source;
 import javax.xml.transform.Transformer;
 import javax.xml.transform.TransformerFactory;
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.transform.stream.StreamSource;
+import javax.xml.ws.Provider;
+import javax.xml.ws.Service;
+import javax.xml.ws.ServiceMode;
+import javax.xml.ws.WebServiceProvider;
 
-import org.apache.axis2.jaxws.DispatchTestConstants;
-
 @WebServiceProvider()
 @ServiceMode(value=Service.Mode.MESSAGE)
 public class SourceMessageProvider implements Provider<Source> {
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java	(revision 471637)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java	(working copy)
@@ -21,7 +21,6 @@
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
 
-import org.apache.axis2.jaxws.DispatchTestSuite;
 import org.apache.axis2.jaxws.attachments.MTOMSerializationTests;
 import org.apache.axis2.jaxws.description.AnnotationDescriptionTests;
 import org.apache.axis2.jaxws.description.AnnotationProviderImplDescriptionTests;
@@ -33,6 +32,7 @@
 import org.apache.axis2.jaxws.description.builder.DescriptionBuilderTests;
 import org.apache.axis2.jaxws.description.impl.ServiceDescriptionTests;
 import org.apache.axis2.jaxws.dispatch.SOAP12Dispatch;
+import org.apache.axis2.jaxws.dispatch.DispatchTestSuite;
 import org.apache.axis2.jaxws.exception.ExceptionFactoryTests;
 import org.apache.axis2.jaxws.handler.HandlerChainProcessorTests;
 import org.apache.axis2.jaxws.i18n.JaxwsMessageBundleTests;
@@ -51,6 +51,8 @@
 import org.apache.axis2.jaxws.provider.SourceProviderTests;
 import org.apache.axis2.jaxws.provider.StringMessageProviderTests;
 import org.apache.axis2.jaxws.provider.StringProviderTests;
+import org.apache.axis2.jaxws.proxy.ProxyNonWrappedTests;
+import org.apache.axis2.jaxws.proxy.ProxyTests;
 import org.apache.axis2.jaxws.sample.AddNumbersTests;
 import org.apache.axis2.jaxws.sample.AddressBookTests;
 import org.apache.axis2.jaxws.sample.FaultyWebServiceTests;
@@ -58,8 +60,6 @@
 import org.apache.axis2.jaxws.sample.NonWrapTests;
 import org.apache.axis2.jaxws.sample.WrapTests;
 import org.apache.axis2.jaxws.security.BasicAuthSecurityTests;
-import org.apache.axis2.proxy.ProxyNonWrappedTests;
-import org.apache.axis2.proxy.ProxyTests;
 import org.apache.log4j.BasicConfigurator;
 
 public class JAXWSTest extends TestCase {
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/JAXBCallbackHandler.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/JAXBCallbackHandler.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/JAXBCallbackHandler.java	(working copy)
@@ -1,20 +1,22 @@
 /*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
  *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
-package org.apache.axis2.jaxws;
+package org.apache.axis2.jaxws.dispatch;
 
 import javax.xml.ws.AsyncHandler;
 import javax.xml.ws.Response;
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/JAXBDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/JAXBDispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/JAXBDispatch.java	(working copy)
@@ -1,20 +1,22 @@
 /*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
  *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
-package org.apache.axis2.jaxws;
+package org.apache.axis2.jaxws.dispatch;
 
 import java.util.concurrent.Future;
 
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/DispatchTestSuite.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/DispatchTestSuite.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/DispatchTestSuite.java	(working copy)
@@ -1,20 +1,22 @@
 /*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
  *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
-package org.apache.axis2.jaxws;
+package org.apache.axis2.jaxws.dispatch;
 
 import junit.framework.TestSuite;
 
@@ -36,5 +38,4 @@
         suite.addTestSuite(JAXBSourceDispatch.class);
         return suite;
     }
-
 }
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/DOMSourceDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/DOMSourceDispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/DOMSourceDispatch.java	(working copy)
@@ -1,20 +1,22 @@
 /*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
  *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
-package org.apache.axis2.jaxws;
+package org.apache.axis2.jaxws.dispatch;
 
 import java.io.ByteArrayInputStream;
 import java.util.concurrent.Future;
@@ -26,6 +28,7 @@
 import javax.xml.transform.Source;
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.ws.Dispatch;
+import javax.xml.ws.Response;
 import javax.xml.ws.Service;
 
 import junit.framework.TestCase;
@@ -112,7 +115,7 @@
         DOMSource request = createDOMSourceFromString(DispatchTestConstants.sampleBodyContent);
 
         // Setup the callback for async responses
-        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
+        AsyncCallback<Source> callbackHandler = new AsyncCallback<Source>();
         
         System.out.println(">> Invoking async (callback) Dispatch");
         Future<?> monitor = dispatch.invokeAsync(request, callbackHandler);
@@ -121,6 +124,19 @@
             System.out.println(">> Async invocation still not complete");
             Thread.sleep(1000);
         }
+        
+        Source response = callbackHandler.getValue();
+        assertNotNull(response);
+        
+        // Turn the Source into a String so we can check it
+        String responseText = createStringFromSource(response);        
+        System.out.println(responseText);
+        
+        // Check to make sure the content is correct
+        assertTrue(!responseText.contains("soap"));
+        assertTrue(!responseText.contains("Envelope"));
+        assertTrue(!responseText.contains("Body"));
+        assertTrue(responseText.contains("echoStringResponse"));
     }
     
     public void testAsyncCallbackMessageMode() throws Exception {
@@ -137,7 +153,7 @@
         DOMSource request = createDOMSourceFromString(DispatchTestConstants.sampleSoapMessage);
 
         // Setup the callback for async responses
-        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
+        AsyncCallback<Source> callbackHandler = new AsyncCallback<Source>();
         
         System.out.println(">> Invoking async (callback) Dispatch");
         Future<?> monitor = dispatch.invokeAsync(request, callbackHandler);
@@ -146,8 +162,91 @@
             System.out.println(">> Async invocation still not complete");
             Thread.sleep(1000);
         }
+        
+        Source response = callbackHandler.getValue();
+        assertNotNull(response);
+        
+        // Turn the Source into a String so we can check it
+        String responseText = createStringFromSource(response);        
+        System.out.println(responseText);
+        
+        // Check to make sure the content is correct
+        assertTrue(responseText.contains("soap"));
+        assertTrue(responseText.contains("Envelope"));
+        assertTrue(responseText.contains("Body"));
+        assertTrue(responseText.contains("echoStringResponse"));
 	}
     
+    public void testAsyncPollingPayloadMode() throws Exception {
+        System.out.println("---------------------------------------");
+        System.out.println("test: " + getName());
+        
+        // Initialize the JAX-WS client artifacts
+        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
+        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
+        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
+                Source.class, Service.Mode.PAYLOAD);
+        
+        // Create the DOMSource
+        DOMSource request = createDOMSourceFromString(DispatchTestConstants.sampleBodyContent);
+
+        System.out.println(">> Invoking async (polling) Dispatch");
+        Response<Source> asyncResponse = dispatch.invokeAsync(request);
+            
+        while (!asyncResponse.isDone()) {
+            System.out.println(">> Async invocation still not complete");
+            Thread.sleep(1000);
+        }
+        
+        Source response = asyncResponse.get();
+        assertNotNull(response);
+        
+        // Turn the Source into a String so we can check it
+        String responseText = createStringFromSource(response);        
+        System.out.println(responseText);
+        
+        // Check to make sure the content is correct
+        assertTrue(!responseText.contains("soap"));
+        assertTrue(!responseText.contains("Envelope"));
+        assertTrue(!responseText.contains("Body"));
+        assertTrue(responseText.contains("echoStringResponse"));
+    }
+    
+    public void testAsyncPollingMessageMode() throws Exception {
+        System.out.println("---------------------------------------");
+        System.out.println("test: " + getName());
+        
+        // Initialize the JAX-WS client artifacts
+        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
+        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
+        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
+                Source.class, Service.Mode.MESSAGE);
+        
+        // Create the DOMSource
+        DOMSource request = createDOMSourceFromString(DispatchTestConstants.sampleSoapMessage);
+
+        System.out.println(">> Invoking async (callback) Dispatch");
+        Response<Source> asyncResponse = dispatch.invokeAsync(request);
+            
+        while (!asyncResponse.isDone()) {
+            System.out.println(">> Async invocation still not complete");
+            Thread.sleep(1000);
+        }
+        
+        Source response = asyncResponse.get();
+        assertNotNull(response);
+        
+        // Turn the Source into a String so we can check it
+        String responseText = createStringFromSource(response);        
+        System.out.println(responseText);
+        
+        // Check to make sure the content is correct
+        assertTrue(responseText.contains("soap"));
+        assertTrue(responseText.contains("Envelope"));
+        assertTrue(responseText.contains("Body"));
+        assertTrue(responseText.contains("echoStringResponse"));
+    }
+    
     public void testOneWayPayloadMode() throws Exception {
         System.out.println("---------------------------------------");
         System.out.println("test: " + getName());
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/ParamTests.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/ParamTests.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/ParamTests.java	(working copy)
@@ -1,18 +1,20 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
  *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
 package org.apache.axis2.jaxws.dispatch;
 
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/SOAP12Dispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/SOAP12Dispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/SOAP12Dispatch.java	(working copy)
@@ -1,18 +1,20 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
  *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
 package org.apache.axis2.jaxws.dispatch;
 
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/JAXBSourceDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/JAXBSourceDispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/JAXBSourceDispatch.java	(working copy)
@@ -1,20 +1,22 @@
 /*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
  *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
-package org.apache.axis2.jaxws;
+package org.apache.axis2.jaxws.dispatch;
 
 import java.io.StringWriter;
 
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/StringDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/StringDispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/StringDispatch.java	(working copy)
@@ -1,24 +1,27 @@
 /*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
  *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
-package org.apache.axis2.jaxws;
+package org.apache.axis2.jaxws.dispatch;
 
 import java.util.concurrent.Future;
 
 import javax.xml.ws.Dispatch;
+import javax.xml.ws.Response;
 import javax.xml.ws.Service;
 
 import junit.framework.TestCase;
@@ -93,15 +96,25 @@
                 String.class, Service.Mode.PAYLOAD);
 
         // Create the callback for async responses
-        CallbackHandler<String> callbackHandler = new CallbackHandler<String>();
+        AsyncCallback<String> callback = new AsyncCallback<String>();
         
         System.out.println(">> Invoking async (callback) Dispatch");
-        Future<?> monitor = dispatch.invokeAsync(DispatchTestConstants.sampleBodyContent, callbackHandler);
+        Future<?> monitor = dispatch.invokeAsync(DispatchTestConstants.sampleBodyContent, callback);
 	        
         while (!monitor.isDone()) {
             System.out.println(">> Async invocation still not complete");
             Thread.sleep(1000);
         }
+        
+        String response = callback.getValue();
+        assertNotNull("dispatch invoke returned null", response);
+        System.out.println(response);
+        
+        // Check to make sure the content is correct
+        assertTrue(!response.contains("soap"));
+        assertTrue(!response.contains("Envelope"));
+        assertTrue(!response.contains("Body"));
+        assertTrue(response.contains("echoStringResponse"));
 	}
     
     /**
@@ -118,16 +131,90 @@
                 String.class, Service.Mode.MESSAGE);
 
         // Create the callback for async responses
-        CallbackHandler<String> callbackHandler = new CallbackHandler<String>();
+        AsyncCallback<String> callback = new AsyncCallback<String>();
         
         System.out.println(">> Invoking async (callback) Dispatch with Message Mode");
-        Future<?> monitor = dispatch.invokeAsync(DispatchTestConstants.sampleSoapMessage, callbackHandler);
+        Future<?> monitor = dispatch.invokeAsync(DispatchTestConstants.sampleSoapMessage, callback);
     
         while (!monitor.isDone()) {
             System.out.println(">> Async invocation still not complete");
             Thread.sleep(1000);
         }
+        
+        String response = callback.getValue();
+        assertNotNull("dispatch invoke returned null", response);
+        System.out.println(response);
+        
+        // Check to make sure the content is correct
+        assertTrue(response.contains("soap"));
+        assertTrue(response.contains("Envelope"));
+        assertTrue(response.contains("Body"));
+        assertTrue(response.contains("echoStringResponse"));
 	}
+    
+    /**
+     * Invoke a Dispatch<String> using the async polling API in PAYLOAD mode
+     */
+    public void testAsyncPollingPayloadMode() throws Exception {
+        System.out.println("---------------------------------------");
+        System.out.println("test: " + getName());
+        
+        // Initialize the JAX-WS client artifacts
+        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
+        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
+        Dispatch<String> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
+                String.class, Service.Mode.PAYLOAD);
+
+        System.out.println(">> Invoking async (polling) Dispatch");
+        Response<String> asyncResponse = dispatch.invokeAsync(DispatchTestConstants.sampleBodyContent);
+            
+        while (!asyncResponse.isDone()) {
+            System.out.println(">> Async invocation still not complete");
+            Thread.sleep(1000);
+        }
+        
+        String response = asyncResponse.get();
+        assertNotNull("dispatch invoke returned null", response);
+        System.out.println(response);
+        
+        // Check to make sure the content is correct
+        assertTrue(!response.contains("soap"));
+        assertTrue(!response.contains("Envelope"));
+        assertTrue(!response.contains("Body"));
+        assertTrue(response.contains("echoStringResponse"));
+    }
+    
+    /**
+     * Invoke a Dispatch<String> using the async polling API in MESSAGE mode
+     */
+    public void testAsyncPollingMessageMode() throws Exception {
+        System.out.println("---------------------------------------");
+        System.out.println("test: " + getName());
+        
+        // Initialize the JAX-WS client artifacts
+        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
+        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
+        Dispatch<String> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
+                String.class, Service.Mode.MESSAGE);
+
+        System.out.println(">> Invoking async (polling) Dispatch with Message Mode");
+        Response<String> asyncResponse = dispatch.invokeAsync(DispatchTestConstants.sampleSoapMessage);
+    
+        while (!asyncResponse.isDone()) {
+            System.out.println(">> Async invocation still not complete");
+            Thread.sleep(1000);
+        }
+        
+        String response = asyncResponse.get();
+        assertNotNull("dispatch invoke returned null", response);
+        System.out.println(response);
+        
+        // Check to make sure the content is correct
+        assertTrue(response.contains("soap"));
+        assertTrue(response.contains("Envelope"));
+        assertTrue(response.contains("Body"));
+        assertTrue(response.contains("echoStringResponse"));
+    }
 	
     /**
      * Invoke a Dispatch<String> one-way in PAYLOAD mode 
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/SOAPMessageDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/SOAPMessageDispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/SOAPMessageDispatch.java	(working copy)
@@ -1,20 +1,22 @@
 /*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
  *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
-package org.apache.axis2.jaxws;
+package org.apache.axis2.jaxws.dispatch;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -24,6 +26,7 @@
 import javax.xml.soap.MessageFactory;
 import javax.xml.soap.SOAPMessage;
 import javax.xml.ws.Dispatch;
+import javax.xml.ws.Response;
 import javax.xml.ws.Service;
 import junit.framework.TestCase;
 
@@ -60,10 +63,9 @@
 
 		assertNotNull("dispatch invoke returned null", response);
 		response.writeTo(System.out);
-		System.out.println("-----------------------------------------");
 	}
 	
-	public void testSOAPMessageASyncCallbackMessageMode() throws Exception {
+	public void testSOAPMessageAsyncCallbackMessageMode() throws Exception {
 		
         String basedir = new File(".").getAbsolutePath();
         String messageResource = new File(basedir, this.messageResource).getAbsolutePath();
@@ -80,16 +82,54 @@
 		FileInputStream inputStream = new FileInputStream(messageResource);
 		MessageFactory factory = MessageFactory.newInstance();
 		SOAPMessage msgObject = factory.createMessage(null, inputStream);
-		CallbackHandler<SOAPMessage> ch = new CallbackHandler<SOAPMessage>();
+		
+        AsyncCallback<SOAPMessage> ac = new AsyncCallback<SOAPMessage>();
 		//Invoke the Dispatch
 		System.out.println(">> Invoking sync Dispatch");
-		Future<?> monitor = dispatch.invokeAsync(msgObject, ch);
+		Future<?> monitor = dispatch.invokeAsync(msgObject, ac);
 
 		assertNotNull("dispatch invokeAsync returned null Future<?>", monitor);
 		while (!monitor.isDone()) {
             System.out.println(">> Async invocation still not complete");
             Thread.sleep(1000);
         }
+        
+        SOAPMessage response = ac.getValue();
+        assertNotNull("dispatch invoke returned null", response);
+        response.writeTo(System.out);
 	}
+    
+    public void testSOAPMessageAsyncPollingMessageMode() throws Exception {
+        
+        String basedir = new File(".").getAbsolutePath();
+        String messageResource = new File(basedir, this.messageResource).getAbsolutePath();
+        
+        System.out.println("---------------------------------------");
+        System.out.println("test: " + getName());
+        //Initialize the JAX-WS client artifacts
+        Service svc = Service.create(serviceName);
+        svc.addPort(portName, null, url);
+        Dispatch<SOAPMessage> dispatch = svc.createDispatch(portName,
+                SOAPMessage.class, Service.Mode.MESSAGE);
 
+        //Create SOAPMessage Object no attachments here.
+        FileInputStream inputStream = new FileInputStream(messageResource);
+        MessageFactory factory = MessageFactory.newInstance();
+        SOAPMessage msgObject = factory.createMessage(null, inputStream);
+
+        //Invoke the Dispatch
+        System.out.println(">> Invoking sync Dispatch");
+        Response<SOAPMessage> asyncResponse = dispatch.invokeAsync(msgObject);
+
+        assertNotNull("dispatch invokeAsync returned null Response", asyncResponse);
+        while (!asyncResponse.isDone()) {
+            System.out.println(">> Async invocation still not complete");
+            Thread.sleep(1000);
+        }
+        
+        SOAPMessage response = asyncResponse.get();
+        assertNotNull("dispatch invoke returned null", response);
+        response.writeTo(System.out);
+    }
+    
 }
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/CallbackHandler.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/CallbackHandler.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/CallbackHandler.java	(working copy)
@@ -1,34 +1,27 @@
 /*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
  *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
-package org.apache.axis2.jaxws;
+package org.apache.axis2.jaxws.dispatch;
 
-import java.io.StringWriter;
-
 import javax.xml.soap.SOAPMessage;
 import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLStreamReader;
-import javax.xml.transform.Result;
 import javax.xml.transform.Source;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.dom.DOMSource;
-import javax.xml.transform.sax.SAXSource;
-import javax.xml.transform.stream.StreamResult;
-import javax.xml.transform.stream.StreamSource;
 import javax.xml.ws.AsyncHandler;
 import javax.xml.ws.Response;
 
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/AsyncCallback.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/AsyncCallback.java	(revision 0)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/AsyncCallback.java	(revision 0)
@@ -0,0 +1,34 @@
+package org.apache.axis2.jaxws.dispatch;
+
+import java.util.concurrent.ExecutionException;
+
+import javax.xml.ws.AsyncHandler;
+import javax.xml.ws.Response;
+
+public class AsyncCallback<T> implements AsyncHandler<T> {
+
+    private T value;
+    private Throwable exception;
+    
+    public void handleResponse(Response<T> response) {
+        try {
+            value = response.get();
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        } catch (ExecutionException e) {
+            e.printStackTrace();
+        }
+    }
+    
+    public boolean hasError() {
+        return (exception != null);
+    }
+    
+    public Throwable getError() {
+        return exception;
+    }
+    
+    public T getValue() {
+        return value;
+    }
+}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/DispatchTestConstants.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/DispatchTestConstants.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/DispatchTestConstants.java	(working copy)
@@ -1,20 +1,22 @@
 /*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
  *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
-package org.apache.axis2.jaxws;
+package org.apache.axis2.jaxws.dispatch;
 
 import javax.xml.namespace.QName;
 
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/SAXSourceDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/SAXSourceDispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/SAXSourceDispatch.java	(working copy)
@@ -1,20 +1,22 @@
 /*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
  *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
-package org.apache.axis2.jaxws;
+package org.apache.axis2.jaxws.dispatch;
 
 import java.io.ByteArrayInputStream;
 import java.util.concurrent.Future;
@@ -24,6 +26,7 @@
 import javax.xml.transform.Source;
 import javax.xml.transform.sax.SAXSource;
 import javax.xml.ws.Dispatch;
+import javax.xml.ws.Response;
 import javax.xml.ws.Service;
 
 import junit.framework.TestCase;
@@ -111,7 +114,6 @@
         System.out.println("---------------------------------------");
         System.out.println("test: " + getName());
         
-        
         // Initialize the JAX-WS client artifacts
         Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
         svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
@@ -119,7 +121,7 @@
                 Source.class, Service.Mode.PAYLOAD);
         
         // Setup the callback for async responses
-        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
+        AsyncCallback<Source> callbackHandler = new AsyncCallback<Source>();
         
         // Create a SAXSource out of the string content
         byte[] bytes = DispatchTestConstants.sampleBodyContent.getBytes();
@@ -134,6 +136,21 @@
             System.out.println(">> Async invocation still not complete");
             Thread.sleep(1000);
         }
+        
+        Source response = callbackHandler.getValue();
+        assertNotNull("dispatch invoke returned null", response);
+        
+        // Prepare the response content for checking
+        XMLStreamReader reader = inputFactory.createXMLStreamReader(response);
+        Reader2Writer r2w = new Reader2Writer(reader);
+        String responseText = r2w.getAsString();
+        System.out.println(responseText);
+        
+        // Check to make sure the content is correct
+        assertTrue(!responseText.contains("soap"));
+        assertTrue(!responseText.contains("Envelope"));
+        assertTrue(!responseText.contains("Body"));
+        assertTrue(responseText.contains("echoStringResponse"));
     }
     
     public void testAsyncCallbackMessageMode() throws Exception {
@@ -147,7 +164,7 @@
                 Source.class, Service.Mode.MESSAGE);
 		
         // Setup the callback for async responses
-        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
+        AsyncCallback<Source> callbackHandler = new AsyncCallback<Source>();
         
         // Create a SAXSource out of the string content
         byte[] bytes = DispatchTestConstants.sampleSoapMessage.getBytes();
@@ -162,8 +179,103 @@
             System.out.println(">> Async invocation still not complete");
             Thread.sleep(1000);
         }
+        
+        Source response = callbackHandler.getValue();
+        assertNotNull("dispatch invoke returned null", response);
+        
+        // Prepare the response content for checking
+        XMLStreamReader reader = inputFactory.createXMLStreamReader(response);
+        Reader2Writer r2w = new Reader2Writer(reader);
+        String responseText = r2w.getAsString();
+        System.out.println(responseText);
+        
+        // Check to make sure the content is correct
+        assertTrue(responseText.contains("soap"));
+        assertTrue(responseText.contains("Envelope"));
+        assertTrue(responseText.contains("Body"));
+        assertTrue(responseText.contains("echoStringResponse"));
 	}
     
+    public void testAsyncPollingPayloadMode() throws Exception {
+        System.out.println("---------------------------------------");
+        System.out.println("test: " + getName());
+        
+        // Initialize the JAX-WS client artifacts
+        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
+        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
+        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
+                Source.class, Service.Mode.PAYLOAD);
+        
+        // Create a SAXSource out of the string content
+        byte[] bytes = DispatchTestConstants.sampleBodyContent.getBytes();
+        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
+        InputSource input = new InputSource(stream);
+        Source request = new SAXSource(input);
+        
+        System.out.println(">> Invoking async (polling) Dispatch");
+        Response<Source> asyncResponse = dispatch.invokeAsync(request);
+
+        while (!asyncResponse.isDone()) {
+            System.out.println(">> Async invocation still not complete");
+            Thread.sleep(1000);
+        }
+        
+        Source response = asyncResponse.get();
+        assertNotNull("dispatch invoke returned null", response);
+        
+        // Prepare the response content for checking
+        XMLStreamReader reader = inputFactory.createXMLStreamReader(response);
+        Reader2Writer r2w = new Reader2Writer(reader);
+        String responseText = r2w.getAsString();
+        System.out.println(responseText);
+        
+        // Check to make sure the content is correct
+        assertTrue(!responseText.contains("soap"));
+        assertTrue(!responseText.contains("Envelope"));
+        assertTrue(!responseText.contains("Body"));
+        assertTrue(responseText.contains("echoStringResponse"));
+    }
+    
+    public void testAsyncPollingMessageMode() throws Exception {
+        System.out.println("---------------------------------------");
+        System.out.println("test: " + getName());
+        
+        // Initialize the JAX-WS client artifacts
+        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
+        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
+        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
+                Source.class, Service.Mode.MESSAGE);
+        
+        // Create a SAXSource out of the string content
+        byte[] bytes = DispatchTestConstants.sampleSoapMessage.getBytes();
+        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
+        InputSource input = new InputSource(stream);
+        Source request = new SAXSource(input);
+        
+        System.out.println(">> Invoking async (callback) Dispatch");
+        Response<Source> asyncResponse = dispatch.invokeAsync(request);
+
+        while (!asyncResponse.isDone()) {
+            System.out.println(">> Async invocation still not complete");
+            Thread.sleep(1000);
+        }
+        
+        Source response = asyncResponse.get();
+        assertNotNull("dispatch invoke returned null", response);
+        
+        // Prepare the response content for checking
+        XMLStreamReader reader = inputFactory.createXMLStreamReader(response);
+        Reader2Writer r2w = new Reader2Writer(reader);
+        String responseText = r2w.getAsString();
+        System.out.println(responseText);
+        
+        // Check to make sure the content is correct
+        assertTrue(responseText.contains("soap"));
+        assertTrue(responseText.contains("Envelope"));
+        assertTrue(responseText.contains("Body"));
+        assertTrue(responseText.contains("echoStringResponse"));
+    }
+    
     public void testOneWayPayloadMode() throws Exception {
         System.out.println("---------------------------------------");
         System.out.println("test: " + getName());
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/StreamSourceDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/StreamSourceDispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/dispatch/StreamSourceDispatch.java	(working copy)
@@ -1,20 +1,22 @@
 /*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
  *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
-package org.apache.axis2.jaxws;
+package org.apache.axis2.jaxws.dispatch;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
@@ -25,6 +27,7 @@
 import javax.xml.transform.Source;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.ws.Dispatch;
+import javax.xml.ws.Response;
 import javax.xml.ws.Service;
 import javax.xml.ws.Service.Mode;
 
@@ -62,7 +65,8 @@
         // Invoke the Dispatch<Source>
 		System.out.println(">> Invoking sync Dispatch with PAYLOAD mode");
 		Source response = dispatch.invoke(srcStream);
-
+		assertNotNull(response);
+        
         // Prepare the response content for checking
         XMLStreamReader reader = inputFactory.createXMLStreamReader(response);
         Reader2Writer r2w = new Reader2Writer(reader);
@@ -96,6 +100,7 @@
         
         System.out.println(">> Invoking sync Dispatch with MESSAGE Mode");
 		StreamSource response = (StreamSource) dispatch.invoke(srcStream);
+        assertNotNull(response);
 
         // Prepare the response content for checking
         XMLStreamReader reader = inputFactory.createXMLStreamReader(response);
@@ -124,7 +129,7 @@
                 Service.Mode.PAYLOAD);
         
         // We'll need a callback instance to handle the async responses
-        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
+        AsyncCallback<Source> callbackHandler = new AsyncCallback<Source>();
         
         // Create a StreamSource with the desired content
         byte[] bytes = DispatchTestConstants.sampleBodyContent.getBytes();
@@ -139,6 +144,21 @@
             System.out.println(">> Async invocation still not complete");
             Thread.sleep(1000);
         }
+        
+        Source response = callbackHandler.getValue();
+        assertNotNull(response);
+        
+        // Prepare the response content for checking
+        XMLStreamReader reader = inputFactory.createXMLStreamReader(response);
+        Reader2Writer r2w = new Reader2Writer(reader);
+        String responseText = r2w.getAsString();
+        System.out.println(responseText);
+        
+        // Check to make sure the content is correct
+        assertTrue(!responseText.contains("soap"));
+        assertTrue(!responseText.contains("Envelope"));
+        assertTrue(!responseText.contains("Body"));
+        assertTrue(responseText.contains("echoStringResponse"));
     }
     
     /**
@@ -155,7 +175,7 @@
                 Mode.MESSAGE);
         
         // We'll need a callback instance to handle the async responses
-        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
+        AsyncCallback<Source> callbackHandler = new AsyncCallback<Source>();
 
         // Create a StreamSource with the desired content
         byte[] bytes = DispatchTestConstants.sampleSoapMessage.getBytes();
@@ -170,9 +190,109 @@
             System.out.println(">> Async invocation still not complete");
             Thread.sleep(1000);
         }
+        
+        Source response = callbackHandler.getValue();
+        assertNotNull(response);
+
+        // Prepare the response content for checking
+        XMLStreamReader reader = inputFactory.createXMLStreamReader(response);
+        Reader2Writer r2w = new Reader2Writer(reader);
+        String responseText = r2w.getAsString();
+        System.out.println(responseText);
+        
+        // Check to make sure the content is correct
+        assertTrue(responseText.contains("soap"));
+        assertTrue(responseText.contains("Envelope"));
+        assertTrue(responseText.contains("Body"));
+        assertTrue(responseText.contains("echoStringResponse"));
     }
 
     /**
+     * Invoke a Dispatch<Source> asynchronously with the content in PAYLOAD mode.
+     */
+    public void testAsyncPollingPayloadMode() throws Exception {
+        System.out.println("---------------------------------------");
+        System.out.println("test: " + getName());
+        
+        // Initialize the JAX-WS client artifacts
+        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
+        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
+        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, Source.class,
+                Service.Mode.PAYLOAD);
+        // Create a StreamSource with the desired content
+        byte[] bytes = DispatchTestConstants.sampleBodyContent.getBytes();
+        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
+        Source srcStream = new StreamSource((InputStream) stream);
+
+        System.out.println(">> Invoking async (callback) Dispatch with PAYLOAD mode");
+        Response<Source> asyncResponse = dispatch.invokeAsync(srcStream);
+
+        // Wait for the async response to be returned
+        while (!asyncResponse.isDone()) {
+            System.out.println(">> Async invocation still not complete");
+            Thread.sleep(1000);
+        }
+        
+        Source response = asyncResponse.get();
+        assertNotNull(response);
+        
+        // Prepare the response content for checking
+        XMLStreamReader reader = inputFactory.createXMLStreamReader(response);
+        Reader2Writer r2w = new Reader2Writer(reader);
+        String responseText = r2w.getAsString();
+        System.out.println(responseText);
+        
+        // Check to make sure the content is correct
+        assertTrue(!responseText.contains("soap"));
+        assertTrue(!responseText.contains("Envelope"));
+        assertTrue(!responseText.contains("Body"));
+        assertTrue(responseText.contains("echoStringResponse"));
+    }
+    
+    /**
+     * Invoke a Dispatch<Source> asynchronously with the content in MESSAGE mode.
+     */
+    public void testAsyncPollingMessageMode() throws Exception {
+        System.out.println("---------------------------------------");
+        System.out.println("test: " + getName());
+        
+        // Initialize the JAX-WS client artifacts 
+        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
+        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
+        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, Source.class,
+                Mode.MESSAGE);
+
+        // Create a StreamSource with the desired content
+        byte[] bytes = DispatchTestConstants.sampleSoapMessage.getBytes();
+        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
+        Source srcStream = new StreamSource((InputStream) stream);
+        
+        System.out.println(">> Invoking async (callback) Dispatch with MESSAGE mode");
+        Response<Source> asyncResponse = dispatch.invokeAsync(srcStream);
+
+        // Wait for the async response to be returned
+        while (!asyncResponse.isDone()) {
+            System.out.println(">> Async invocation still not complete");
+            Thread.sleep(1000);
+        }
+        
+        Source response = asyncResponse.get();
+        assertNotNull(response);
+
+        // Prepare the response content for checking
+        XMLStreamReader reader = inputFactory.createXMLStreamReader(response);
+        Reader2Writer r2w = new Reader2Writer(reader);
+        String responseText = r2w.getAsString();
+        System.out.println(responseText);
+        
+        // Check to make sure the content is correct
+        assertTrue(responseText.contains("soap"));
+        assertTrue(responseText.contains("Envelope"));
+        assertTrue(responseText.contains("Body"));
+        assertTrue(responseText.contains("echoStringResponse"));
+    }
+    
+    /**
      * Invoke a Dispatch<Source> one-way operation
      */
 	public void testOneWayPayloadMode() throws Exception {
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/DOMSourceDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/DOMSourceDispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/DOMSourceDispatch.java	(working copy)
@@ -1,215 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws;
-
-import java.io.ByteArrayInputStream;
-import java.util.concurrent.Future;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.transform.Source;
-import javax.xml.transform.dom.DOMSource;
-import javax.xml.ws.Dispatch;
-import javax.xml.ws.Service;
-
-import junit.framework.TestCase;
-
-import org.apache.axis2.jaxws.message.util.Reader2Writer;
-import org.w3c.dom.Document;
-import org.w3c.dom.Node;
-
-/**
- * This class tests the JAX-WS Dispatch with various forms of the 
- * javax.xml.transform.dom.DOMSource 
- */
-public class DOMSourceDispatch extends TestCase{
-
-    private static final XMLInputFactory inputFactory = XMLInputFactory.newInstance();
-    
-    public void testSyncPayloadMode() throws Exception {
-		System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                Source.class, Service.Mode.PAYLOAD);
-        
-        // Create the DOMSource
-        DOMSource request = createDOMSourceFromString(DispatchTestConstants.sampleBodyContent);
-        
-		System.out.println(">> Invoking sync Dispatch");
-		Source response = dispatch.invoke(request);
-		assertNotNull("dispatch invoke returned null",response);
-		
-        // Turn the Source into a String so we can check it
-        String responseText = createStringFromSource(response);        
-        System.out.println(responseText);
-        
-        // Check to make sure the content is correct
-        assertTrue(!responseText.contains("soap"));
-        assertTrue(!responseText.contains("Envelope"));
-        assertTrue(!responseText.contains("Body"));
-        assertTrue(responseText.contains("echoStringResponse"));
-	}
-
-	public void testSyncMessageMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                Source.class, Service.Mode.MESSAGE);
-        
-        // Create the DOMSource
-        DOMSource request = createDOMSourceFromString(DispatchTestConstants.sampleSoapMessage);
-        
-        System.out.println(">> Invoking sync Dispatch");
-        Source response = dispatch.invoke(request);
-        assertNotNull("dispatch invoke returned null",response);
-        
-        // Turn the Source into a String so we can check it
-        String responseText = createStringFromSource(response);        
-        System.out.println(responseText);
-        
-        // Check to make sure the content is correct
-        assertTrue(responseText.contains("soap"));
-        assertTrue(responseText.contains("Envelope"));
-        assertTrue(responseText.contains("Body"));
-        assertTrue(responseText.contains("echoStringResponse"));
-	}
-
-    public void testAsyncCallbackPayloadMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                Source.class, Service.Mode.PAYLOAD);
-        
-        // Create the DOMSource
-        DOMSource request = createDOMSourceFromString(DispatchTestConstants.sampleBodyContent);
-
-        // Setup the callback for async responses
-        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
-        
-        System.out.println(">> Invoking async (callback) Dispatch");
-        Future<?> monitor = dispatch.invokeAsync(request, callbackHandler);
-            
-        while (!monitor.isDone()) {
-            System.out.println(">> Async invocation still not complete");
-            Thread.sleep(1000);
-        }
-    }
-    
-    public void testAsyncCallbackMessageMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                Source.class, Service.Mode.MESSAGE);
-        
-        // Create the DOMSource
-        DOMSource request = createDOMSourceFromString(DispatchTestConstants.sampleSoapMessage);
-
-        // Setup the callback for async responses
-        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
-        
-        System.out.println(">> Invoking async (callback) Dispatch");
-        Future<?> monitor = dispatch.invokeAsync(request, callbackHandler);
-	        
-        while (!monitor.isDone()) {
-            System.out.println(">> Async invocation still not complete");
-            Thread.sleep(1000);
-        }
-	}
-    
-    public void testOneWayPayloadMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                Source.class, Service.Mode.PAYLOAD);
-
-        // Create the DOMSource
-        DOMSource request = createDOMSourceFromString(DispatchTestConstants.sampleBodyContent);
-
-        System.out.println(">> Invoking One Way Dispatch");
-        dispatch.invokeOneWay(request);
-    }
-    
-    public void testOneWayMessageMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                Source.class, Service.Mode.MESSAGE);
-
-        // Create the DOMSource
-        DOMSource request = createDOMSourceFromString(DispatchTestConstants.sampleSoapMessage);
-
-        System.out.println(">> Invoking One Way Dispatch");
-        dispatch.invokeOneWay(request);
-	}
-    
-	/**
-     * Create a DOMSource with the provided String as the content
-     * @param input
-     * @return
-	 */
-    private DOMSource createDOMSourceFromString(String input) throws Exception {
-        byte[] bytes = input.getBytes();
-        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
-        
-        DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
-        domFactory.setNamespaceAware(true);
-        DocumentBuilder domBuilder = domFactory.newDocumentBuilder();
-        Document domTree = domBuilder.parse(stream);
-        Node node = domTree.getDocumentElement();
-        
-        DOMSource domSource = new DOMSource(node);
-        return domSource;
-    }
-    
-    /**
-     * Create a String from the provided Source
-     * @param input
-     * @return
-     */
-    private String createStringFromSource(Source input) throws Exception {
-        XMLStreamReader reader = inputFactory.createXMLStreamReader(input);
-        Reader2Writer r2w = new Reader2Writer(reader);
-        String text = r2w.getAsString();
-        return text;
-    }
-}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/JAXBSourceDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/JAXBSourceDispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/JAXBSourceDispatch.java	(working copy)
@@ -1,91 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws;
-
-import java.io.StringWriter;
-
-import javax.xml.bind.JAXBContext;
-import javax.xml.bind.util.JAXBSource;
-import javax.xml.namespace.QName;
-import javax.xml.transform.Result;
-import javax.xml.transform.Source;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.stream.StreamResult;
-import javax.xml.ws.Dispatch;
-import javax.xml.ws.Service;
-
-import org.test.dispatch.jaxbsource.Invoke;
-import org.test.dispatch.jaxbsource.ObjectFactory;
-
-import junit.framework.TestCase;
-
-
-/*
- * This is a test case for Invoking Dispatch with a JAXBSource.
- * test uses JAXB Objects from org.test.dispatch.jaxbsource package, create a request of JAXBSource type
- * and invokes the service endpoint and reads the response of type Source. Assert failure if response not received.
- */
-
-
-public class JAXBSourceDispatch extends TestCase {
-	/**
-     * Invoke a sync Dispatch<JAXBSource> in PAYLOAD mode
-     */
-	
-	private String url = "http://localhost:8080/axis2/services/SourceProviderService";
-	private QName serviceName = new QName("http://ws.apache.org/axis2", "SourceProviderService");
-	private QName portName =new QName("http://ws.apache.org/axis2", "SimpleProviderServiceSOAP11port0");
-	
-    public void testJAXBSourceSyncPayloadMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        try{
-	        // Initialize the JAX-WS client artifacts
-	        Service svc = Service.create(serviceName);
-	        svc.addPort(portName, null, url);
-	        Dispatch<JAXBSource> dispatch = svc.createDispatch(portName, 
-	                JAXBSource.class, Service.Mode.PAYLOAD);
-	        
-	        //Create JAXBContext and JAXBSource here.
-	        ObjectFactory factory = new ObjectFactory();
-	        Invoke invokeObj = factory.createInvoke();
-	        invokeObj.setInvokeStr("Some Request");
-	        JAXBContext ctx = JAXBContext.newInstance("org.test.dispatch.jaxbsource");
-	       
-	        JAXBSource jbSrc = new JAXBSource(ctx.createMarshaller(), invokeObj);
-	        // Invoke the Dispatch
-	        System.out.println(">> Invoking sync Dispatch");
-	        //Invoke Server endpoint and read response
-	        Source response = dispatch.invoke(jbSrc);
-	       
-	        assertNotNull("dispatch invoke returned null", response);
-	        //Print the response as string.
-	        StringWriter writer = new StringWriter();
-	        Transformer t = TransformerFactory.newInstance().newTransformer();
-	        Result result = new StreamResult(writer);
-	        t.transform(response, result);
-	
-	        System.out.println("Response On Client: \n"+writer.getBuffer().toString());
-	        System.out.println("---------------------------------------");
-        }catch(Exception e){
-        	e.printStackTrace();
-        }
-        
-    }
-    
-}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/StringDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/StringDispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/StringDispatch.java	(working copy)
@@ -1,165 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws;
-
-import java.util.concurrent.Future;
-
-import javax.xml.ws.Dispatch;
-import javax.xml.ws.Service;
-
-import junit.framework.TestCase;
-
-public class StringDispatch extends TestCase {
-
-    /**
-     * Invoke a sync Dispatch<String> in PAYLOAD mode
-     */
-    public void testSyncPayloadMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<String> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                String.class, Service.Mode.PAYLOAD);
-        
-        // Invoke the Dispatch
-        System.out.println(">> Invoking sync Dispatch");
-        String response = dispatch.invoke(DispatchTestConstants.sampleBodyContent);
-
-        assertNotNull("dispatch invoke returned null", response);
-        System.out.println(response);
-        
-        // Check to make sure the content is correct
-        assertTrue(!response.contains("soap"));
-        assertTrue(!response.contains("Envelope"));
-        assertTrue(!response.contains("Body"));
-        assertTrue(response.contains("echoStringResponse"));
-	}
-    
-    /**
-     * Invoke a sync Dispatch<String> in MESSAGE mode
-     */
-    public void testSyncWithMessageMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<String> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                String.class, Service.Mode.MESSAGE);
-        
-        // Invoke the Dispatch
-        System.out.println(">> Invoking sync Dispatch");
-        String response = dispatch.invoke(DispatchTestConstants.sampleSoapMessage);
-
-        assertNotNull("dispatch invoke returned null", response);
-        System.out.println(response);
-        
-        // Check to make sure the content is correct
-        assertTrue(response.contains("soap"));
-        assertTrue(response.contains("Envelope"));
-        assertTrue(response.contains("Body"));
-        assertTrue(response.contains("echoStringResponse"));
-	}
-    
-	/**
-     * Invoke a Dispatch<String> using the async callback API in PAYLOAD mode
-	 */
-    public void testAsyncCallbackPayloadMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<String> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                String.class, Service.Mode.PAYLOAD);
-
-        // Create the callback for async responses
-        CallbackHandler<String> callbackHandler = new CallbackHandler<String>();
-        
-        System.out.println(">> Invoking async (callback) Dispatch");
-        Future<?> monitor = dispatch.invokeAsync(DispatchTestConstants.sampleBodyContent, callbackHandler);
-	        
-        while (!monitor.isDone()) {
-            System.out.println(">> Async invocation still not complete");
-            Thread.sleep(1000);
-        }
-	}
-    
-    /**
-     * Invoke a Dispatch<String> using the async callback API in MESSAGE mode
-     */
-    public void testAsyncCallbackMessageMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<String> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                String.class, Service.Mode.MESSAGE);
-
-        // Create the callback for async responses
-        CallbackHandler<String> callbackHandler = new CallbackHandler<String>();
-        
-        System.out.println(">> Invoking async (callback) Dispatch with Message Mode");
-        Future<?> monitor = dispatch.invokeAsync(DispatchTestConstants.sampleSoapMessage, callbackHandler);
-    
-        while (!monitor.isDone()) {
-            System.out.println(">> Async invocation still not complete");
-            Thread.sleep(1000);
-        }
-	}
-	
-    /**
-     * Invoke a Dispatch<String> one-way in PAYLOAD mode 
-     */
-    public void testOneWayPayloadMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<String> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                String.class, Service.Mode.PAYLOAD);
-
-        System.out.println(">> Invoking one-way Dispatch");
-        dispatch.invokeOneWay(DispatchTestConstants.sampleBodyContent);
-    }
-    
-    /**
-     * Invoke a Dispatch<String> one-way in MESSAGE mode 
-	 */
-    public void testOneWayMessageMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<String> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                String.class, Service.Mode.MESSAGE);
-
-        System.out.println(">> Invoking one-way Dispatch");
-        dispatch.invokeOneWay(DispatchTestConstants.sampleSoapMessage);
-	}
-}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/SOAPMessageDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/SOAPMessageDispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/SOAPMessageDispatch.java	(working copy)
@@ -1,95 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.util.concurrent.Future;
-
-import javax.xml.namespace.QName;
-import javax.xml.soap.MessageFactory;
-import javax.xml.soap.SOAPMessage;
-import javax.xml.ws.Dispatch;
-import javax.xml.ws.Service;
-import junit.framework.TestCase;
-
-public class SOAPMessageDispatch extends TestCase {
-	private String url = "http://localhost:8080/axis2/services/ProxyDocLitWrappedService";
-	private QName serviceName = new QName(
-			"http://org.apache.axis2.proxy.doclitwrapped", "ProxyDocLitWrappedService");
-	private QName portName = new QName("http://org.apache.axis2.proxy.doclitwrapped",
-	"ProxyDocLitWrappedPort");
-	
-	String messageResource = "test-resources" + File.separator  + "xml" + File.separator +"soapmessage.xml";
-	
-	public void testSOAPMessageSyncMessageMode() throws Exception {
-		
-        String basedir = new File(".").getAbsolutePath();
-        String messageResource = new File(basedir, this.messageResource).getAbsolutePath();
-        
-		System.out.println("---------------------------------------");
-		System.out.println("test: " + getName());
-		//Initialize the JAX-WS client artifacts
-		Service svc = Service.create(serviceName);
-		svc.addPort(portName, null, url);
-		Dispatch<SOAPMessage> dispatch = svc.createDispatch(portName,
-				SOAPMessage.class, Service.Mode.MESSAGE);
-
-		//Create SOAPMessage Object no attachments here.
-		FileInputStream inputStream = new FileInputStream(messageResource);
-		MessageFactory factory = MessageFactory.newInstance();
-		SOAPMessage msgObject = factory.createMessage(null, inputStream);
-
-		//Invoke the Dispatch
-		System.out.println(">> Invoking Async Dispatch");
-		SOAPMessage response = dispatch.invoke(msgObject);
-
-		assertNotNull("dispatch invoke returned null", response);
-		response.writeTo(System.out);
-		System.out.println("-----------------------------------------");
-	}
-	
-	public void testSOAPMessageASyncCallbackMessageMode() throws Exception {
-		
-        String basedir = new File(".").getAbsolutePath();
-        String messageResource = new File(basedir, this.messageResource).getAbsolutePath();
-        
-		System.out.println("---------------------------------------");
-		System.out.println("test: " + getName());
-		//Initialize the JAX-WS client artifacts
-		Service svc = Service.create(serviceName);
-		svc.addPort(portName, null, url);
-		Dispatch<SOAPMessage> dispatch = svc.createDispatch(portName,
-				SOAPMessage.class, Service.Mode.MESSAGE);
-
-		//Create SOAPMessage Object no attachments here.
-		FileInputStream inputStream = new FileInputStream(messageResource);
-		MessageFactory factory = MessageFactory.newInstance();
-		SOAPMessage msgObject = factory.createMessage(null, inputStream);
-		CallbackHandler<SOAPMessage> ch = new CallbackHandler<SOAPMessage>();
-		//Invoke the Dispatch
-		System.out.println(">> Invoking sync Dispatch");
-		Future<?> monitor = dispatch.invokeAsync(msgObject, ch);
-
-		assertNotNull("dispatch invokeAsync returned null Future<?>", monitor);
-		while (!monitor.isDone()) {
-            System.out.println(">> Async invocation still not complete");
-            Thread.sleep(1000);
-        }
-	}
-
-}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/CallbackHandler.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/CallbackHandler.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/CallbackHandler.java	(working copy)
@@ -1,68 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws;
-
-import java.io.StringWriter;
-
-import javax.xml.soap.SOAPMessage;
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.transform.Result;
-import javax.xml.transform.Source;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.dom.DOMSource;
-import javax.xml.transform.sax.SAXSource;
-import javax.xml.transform.stream.StreamResult;
-import javax.xml.transform.stream.StreamSource;
-import javax.xml.ws.AsyncHandler;
-import javax.xml.ws.Response;
-
-import org.apache.axis2.jaxws.message.util.Reader2Writer;
-
-public class CallbackHandler<T> implements AsyncHandler <T> {
-
-    public void handleResponse(Response response) {
-        System.out.println(">> Processing async reponse");
-        try{
-            T res = (T) response.get();
-            
-            if(res instanceof SOAPMessage){
-            	SOAPMessage message = (SOAPMessage) res;
-            	message.writeTo(System.out);
-            	
-            }
-            
-            if(res instanceof String){
-                System.out.println("Response [" + res + "]");
-            }
-            else if(Source.class.isAssignableFrom(res.getClass())){
-                Source source = (Source) res;
-                
-                XMLInputFactory inputFactory = XMLInputFactory.newInstance();
-                XMLStreamReader reader = inputFactory.createXMLStreamReader(source);
-                Reader2Writer r2w = new Reader2Writer(reader);
-                String responseText = r2w.getAsString();
-                
-                System.out.println(responseText);
-            }
-            System.out.println("---------------------------------------------");
-        }catch(Exception e){
-            e.printStackTrace();
-        }
-    }
-}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/StreamSourceDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/StreamSourceDispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/StreamSourceDispatch.java	(working copy)
@@ -1,196 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws;
-
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-import java.util.concurrent.Future;
-
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.transform.Source;
-import javax.xml.transform.stream.StreamSource;
-import javax.xml.ws.Dispatch;
-import javax.xml.ws.Service;
-import javax.xml.ws.Service.Mode;
-
-import junit.framework.TestCase;
-
-import org.apache.axis2.jaxws.message.util.Reader2Writer;
-
-/**
- * This class tests the JAX-WS Dispatch<Source> functionality with various
- * forms of a StreamSource object. 
- *
- */
-public class StreamSourceDispatch extends TestCase {
-
-    private static XMLInputFactory inputFactory = XMLInputFactory.newInstance();
-    
-	/**
-     * Invoke a Dispatch<Source> synchronously with the content in PAYLOAD mode.
-	 */
-    public void testSyncPayloadMode() throws Exception {
-		System.out.println("---------------------------------------");
-		System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-		svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-		Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, Source.class, 
-                Service.Mode.PAYLOAD);
-		
-        // Create a StreamSource with the desired content
-        byte[] bytes = DispatchTestConstants.sampleBodyContent.getBytes();
-        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
-        Source srcStream = new StreamSource((InputStream) stream);
-        
-        // Invoke the Dispatch<Source>
-		System.out.println(">> Invoking sync Dispatch with PAYLOAD mode");
-		Source response = dispatch.invoke(srcStream);
-
-        // Prepare the response content for checking
-        XMLStreamReader reader = inputFactory.createXMLStreamReader(response);
-        Reader2Writer r2w = new Reader2Writer(reader);
-        String responseText = r2w.getAsString();
-        System.out.println(responseText);
-        
-        // Check to make sure the content is correct
-        assertTrue(!responseText.contains("soap"));
-        assertTrue(!responseText.contains("Envelope"));
-        assertTrue(!responseText.contains("Body"));
-        assertTrue(responseText.contains("echoStringResponse"));            
-	}
-
-    /**
-     * Invoke a Dispatch<Source> synchronously with the content in MESSAGE mode.
-     */
-    public void testSyncMessageMode() throws Exception {
-		System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-		Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-		svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-		Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, Source.class,
-				Mode.MESSAGE);
-		
-		// Create a StreamSource with the desired content
-        byte[] bytes = DispatchTestConstants.sampleSoapMessage.getBytes();
-        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
-        Source srcStream = new StreamSource((InputStream) stream);
-        
-        System.out.println(">> Invoking sync Dispatch with MESSAGE Mode");
-		StreamSource response = (StreamSource) dispatch.invoke(srcStream);
-
-        // Prepare the response content for checking
-        XMLStreamReader reader = inputFactory.createXMLStreamReader(response);
-        Reader2Writer r2w = new Reader2Writer(reader);
-        String responseText = r2w.getAsString();
-        System.out.println(responseText);
-        
-        // Check to make sure the content is correct
-        assertTrue(responseText.contains("soap"));
-        assertTrue(responseText.contains("Envelope"));
-        assertTrue(responseText.contains("Body"));
-        assertTrue(responseText.contains("echoStringResponse"));            
-	}
-
-    /**
-     * Invoke a Dispatch<Source> asynchronously with the content in PAYLOAD mode.
-     */
-    public void testAsyncCallbackPayloadMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, Source.class,
-                Service.Mode.PAYLOAD);
-        
-        // We'll need a callback instance to handle the async responses
-        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
-        
-        // Create a StreamSource with the desired content
-        byte[] bytes = DispatchTestConstants.sampleBodyContent.getBytes();
-        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
-        Source srcStream = new StreamSource((InputStream) stream);
-
-        System.out.println(">> Invoking async (callback) Dispatch with PAYLOAD mode");
-        Future<?> monitor = dispatch.invokeAsync(srcStream, callbackHandler);
-
-        // Wait for the async response to be returned
-        while (!monitor.isDone()) {
-            System.out.println(">> Async invocation still not complete");
-            Thread.sleep(1000);
-        }
-    }
-    
-    /**
-     * Invoke a Dispatch<Source> asynchronously with the content in MESSAGE mode.
-     */
-	public void testAsyncCallbackMessageMode() throws Exception {
-		System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts 
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-		svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, Source.class,
-                Mode.MESSAGE);
-        
-        // We'll need a callback instance to handle the async responses
-        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
-
-        // Create a StreamSource with the desired content
-        byte[] bytes = DispatchTestConstants.sampleSoapMessage.getBytes();
-        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
-		Source srcStream = new StreamSource((InputStream) stream);
-		
-        System.out.println(">> Invoking async (callback) Dispatch with MESSAGE mode");
-        Future<?> monitor = dispatch.invokeAsync(srcStream, callbackHandler);
-
-        // Wait for the async response to be returned
-        while (!monitor.isDone()) {
-            System.out.println(">> Async invocation still not complete");
-            Thread.sleep(1000);
-        }
-    }
-
-    /**
-     * Invoke a Dispatch<Source> one-way operation
-     */
-	public void testOneWayPayloadMode() throws Exception {
-		System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-		Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-		svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-		Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, Source.class,
-				Service.Mode.PAYLOAD);
-        
-		// Create a StreamSource with the desired content
-        byte[] bytes = DispatchTestConstants.sampleBodyContent.getBytes();
-        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
-		Source srcStream = new StreamSource((InputStream) stream);
-		
-		System.out.println(">> Invoking One Way Dispatch");
-		dispatch.invokeOneWay(srcStream);
-	}
-}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/SAXSourceDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/SAXSourceDispatch.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/SAXSourceDispatch.java	(working copy)
@@ -1,206 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws;
-
-import java.io.ByteArrayInputStream;
-import java.util.concurrent.Future;
-
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.transform.Source;
-import javax.xml.transform.sax.SAXSource;
-import javax.xml.ws.Dispatch;
-import javax.xml.ws.Service;
-
-import junit.framework.TestCase;
-
-import org.apache.axis2.jaxws.message.util.Reader2Writer;
-import org.xml.sax.InputSource;
-
-/**
- * This class tests the JAX-WS Dispatch<Source> with content in various 
- * forms of a javax.xml.transform.sax.SAXSource.
- */
-public class SAXSourceDispatch extends TestCase{
-
-    private static final XMLInputFactory inputFactory = XMLInputFactory.newInstance();
-    
-	public void testSyncPayloadMode() throws Exception {
-		System.out.println("---------------------------------------");
-		System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-		svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-		Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                Source.class, Service.Mode.PAYLOAD);
-        
-        // Create a SAXSource out of the string content
-        byte[] bytes = DispatchTestConstants.sampleBodyContent.getBytes();
-		ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
-        InputSource input = new InputSource(stream);
-		Source request = new SAXSource(input);
-		
-        System.out.println(">> Invoking sync Dispatch");
-		Source response = dispatch.invoke(request);
-        
-		assertNotNull("dispatch invoke returned null", response);
-        
-        // Prepare the response content for checking
-        XMLStreamReader reader = inputFactory.createXMLStreamReader(response);
-        Reader2Writer r2w = new Reader2Writer(reader);
-        String responseText = r2w.getAsString();
-        System.out.println(responseText);
-        
-        // Check to make sure the content is correct
-        assertTrue(!responseText.contains("soap"));
-        assertTrue(!responseText.contains("Envelope"));
-        assertTrue(!responseText.contains("Body"));
-        assertTrue(responseText.contains("echoStringResponse"));
-	}
-
-	public void testSyncMessageMode() throws Exception {
-		System.out.println("---------------------------------------");
-		System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                Source.class, Service.Mode.MESSAGE);
-		
-        // Create a SAXSource out of the string content
-        byte[] bytes = DispatchTestConstants.sampleSoapMessage.getBytes();
-        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
-        InputSource input = new InputSource(stream);
-        Source request = new SAXSource(input);
-		
-		System.out.println(">> Invoking sync Dispatch with Message Mode");
-		Source response = dispatch.invoke(request);
-
-        assertNotNull("dispatch invoke returned null", response);
-        
-        // Prepare the response content for checking
-        XMLStreamReader reader = inputFactory.createXMLStreamReader(response);
-        Reader2Writer r2w = new Reader2Writer(reader);
-        String responseText = r2w.getAsString();
-        System.out.println(responseText);
-        
-        // Check to make sure the content is correct
-        assertTrue(responseText.contains("soap"));
-        assertTrue(responseText.contains("Envelope"));
-        assertTrue(responseText.contains("Body"));
-        assertTrue(responseText.contains("echoStringResponse"));
-	}
-
-    public void testAsyncCallbackPayloadMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                Source.class, Service.Mode.PAYLOAD);
-        
-        // Setup the callback for async responses
-        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
-        
-        // Create a SAXSource out of the string content
-        byte[] bytes = DispatchTestConstants.sampleBodyContent.getBytes();
-        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
-        InputSource input = new InputSource(stream);
-        Source request = new SAXSource(input);
-        
-        System.out.println(">> Invoking async (callback) Dispatch");
-        Future<?> monitor = dispatch.invokeAsync(request, callbackHandler);
-
-        while (!monitor.isDone()) {
-            System.out.println(">> Async invocation still not complete");
-            Thread.sleep(1000);
-        }
-    }
-    
-    public void testAsyncCallbackMessageMode() throws Exception {
-		System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                Source.class, Service.Mode.MESSAGE);
-		
-        // Setup the callback for async responses
-        CallbackHandler<Source> callbackHandler = new CallbackHandler<Source>();
-        
-        // Create a SAXSource out of the string content
-        byte[] bytes = DispatchTestConstants.sampleSoapMessage.getBytes();
-        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
-        InputSource input = new InputSource(stream);
-        Source request = new SAXSource(input);
-        
-        System.out.println(">> Invoking async (callback) Dispatch");
-        Future<?> monitor = dispatch.invokeAsync(request, callbackHandler);
-
-        while (!monitor.isDone()) {
-            System.out.println(">> Async invocation still not complete");
-            Thread.sleep(1000);
-        }
-	}
-    
-    public void testOneWayPayloadMode() throws Exception {
-        System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                Source.class, Service.Mode.PAYLOAD);
-        
-        // Create a SAXSource out of the string content
-        byte[] bytes = DispatchTestConstants.sampleBodyContent.getBytes();
-        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
-        InputSource input = new InputSource(stream);
-        Source request = new SAXSource(input);
-        
-        System.out.println(">> Invoking One Way Dispatch");
-        dispatch.invokeOneWay(request);
-    }
-    
-    public void testOneWayMessageMode() throws Exception {
-		System.out.println("---------------------------------------");
-        System.out.println("test: " + getName());
-        
-        // Initialize the JAX-WS client artifacts
-        Service svc = Service.create(DispatchTestConstants.QNAME_SERVICE);
-        svc.addPort(DispatchTestConstants.QNAME_PORT, null, DispatchTestConstants.URL);
-        Dispatch<Source> dispatch = svc.createDispatch(DispatchTestConstants.QNAME_PORT, 
-                Source.class, Service.Mode.MESSAGE);
-        
-        // Create a SAXSource out of the string content
-        byte[] bytes = DispatchTestConstants.sampleSoapMessage.getBytes();
-        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
-        InputSource input = new InputSource(stream);
-        Source request = new SAXSource(input);
-        
-		System.out.println(">> Invoking One Way Dispatch");
-		dispatch.invokeOneWay(request);
-	}
-}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/DispatchTestConstants.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/DispatchTestConstants.java	(revision 470019)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/test/org/apache/axis2/jaxws/DispatchTestConstants.java	(working copy)
@@ -1,44 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws;
-
-import javax.xml.namespace.QName;
-
-public class DispatchTestConstants {
-
-    public static final String URL = "http://localhost:8080/axis2/services/EchoService";
-    public static final QName QNAME_SERVICE = new QName("http://ws.apache.org/axis2", "EchoService");
-    public static final QName QNAME_PORT = new QName("http://ws.apache.org/axis2", "EchoServiceSOAP11port0");
-
-    private static final String sampleSoapEnvelopeHeader = 
-        "<soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">" + 
-        "<soap:Body>";
-    
-    private static final String sampleSoapEnvelopeFooter =
-        "</soap:Body>" + 
-        "</soap:Envelope>";
-    
-    public static final String sampleBodyContent = 
-        "<ns1:echoString xmlns:ns1=\"http://test\">" + 
-        "<ns1:input xmlns=\"http://test\">HELLO THERE!!!</ns1:input>" + 
-        "</ns1:echoString>";
-    
-    public static final String sampleSoapMessage = 
-        sampleSoapEnvelopeHeader +
-        sampleBodyContent + 
-        sampleSoapEnvelopeFooter;
-}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/core/InvocationContextImpl.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/core/InvocationContextImpl.java	(revision 470629)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/core/InvocationContextImpl.java	(working copy)
@@ -22,6 +22,7 @@
 import javax.xml.ws.handler.Handler;
 
 import org.apache.axis2.client.ServiceClient;
+import org.apache.axis2.jaxws.client.async.AsyncResponse;
 import org.apache.axis2.jaxws.impl.AsyncListener;
 
 /**
@@ -35,7 +36,7 @@
     private MessageContext requestMsgCtx;
     private MessageContext responseMsgCtx;
     private Executor executor;
-    private AsyncListener asyncListener;
+    private AsyncResponse asyncResponse;
     
     private ServiceClient serviceClient; //FIXME: This is temporary
     
@@ -101,12 +102,12 @@
         executor = e;
     }
     
-    public AsyncListener getAsyncListener() {
-        return asyncListener;
+    public AsyncResponse getAsyncResponseListener() {
+        return asyncResponse;
     }
     
-    public void setAsyncListener(AsyncListener al) {
-        asyncListener = al;
+    public void setAsyncResponseListener(AsyncResponse ar) {
+        asyncResponse = ar;
     }
     
     // FIXME: This is temporary
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/core/controller/AxisInvocationController.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/core/controller/AxisInvocationController.java	(revision 471639)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/core/controller/AxisInvocationController.java	(working copy)
@@ -22,8 +22,6 @@
 import java.net.URL;
 import java.util.Iterator;
 import java.util.Map;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 
 import javax.xml.namespace.QName;
@@ -43,15 +41,14 @@
 import org.apache.axis2.context.ServiceContext;
 import org.apache.axis2.description.AxisOperation;
 import org.apache.axis2.engine.MessageReceiver;
-import org.apache.axis2.jaxws.AxisCallback;
 import org.apache.axis2.jaxws.BindingProvider;
 import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.client.async.AsyncResponse;
+import org.apache.axis2.jaxws.client.async.CallbackFuture;
 import org.apache.axis2.jaxws.core.InvocationContext;
 import org.apache.axis2.jaxws.core.MessageContext;
 import org.apache.axis2.jaxws.description.OperationDescription;
 import org.apache.axis2.jaxws.i18n.Messages;
-import org.apache.axis2.jaxws.impl.AsyncListener;
-import org.apache.axis2.jaxws.impl.AsyncListenerWrapper;
 import org.apache.axis2.jaxws.marshaller.ClassUtils;
 import org.apache.axis2.jaxws.message.Message;
 import org.apache.axis2.jaxws.message.MessageException;
@@ -227,68 +224,34 @@
         OperationClient opClient = createOperationClient(svcClient, operationName);
         
         initOperationClient(opClient, request);
-        
-        org.apache.axis2.context.MessageContext axisRequestMsgCtx = request.getAxisMessageContext();
-        
+                
         // Setup the client so that it knows whether the underlying call to
         // Axis2 knows whether or not to start a listening port for an
         // asynchronous response.
         Boolean useAsyncMep = (Boolean) request.getProperties().get(Constants.USE_ASYNC_MEP);
         if((useAsyncMep != null && useAsyncMep.booleanValue()) 
                 || opClient.getOptions().isUseSeparateListener()) {
-            if (log.isDebugEnabled()) {
-                log.debug("Enabling asynchronous message exchange.  An asynchronous listener will be establish.");
-            }
-
-            opClient.getOptions().setUseSeparateListener(true);
-            opClient.getOptions().setTransportInProtocol("http");
-
-            //FIXME: This has to be here so the ThreadContextMigrator can pick it up.
-            //This should go away once AXIS2-978 is fixed.
-            axisRequestMsgCtx.getOptions().setUseSeparateListener(true);
-            
-            // Setup the response callback receiver to receive the async response
-            // This logic is based on org.apache.axis2.client.ServiceClient.sendReceiveNonBlocking(...)
-            AxisOperation op = opClient.getOperationContext().getAxisOperation();
-            MessageReceiver messageReceiver = op.getMessageReceiver();
-            if (messageReceiver == null || !(messageReceiver instanceof CallbackReceiver))
-                op.setMessageReceiver(new CallbackReceiver());
+            configureAsyncListener(opClient, request.getAxisMessageContext());
         }
-        else {
+		else {
             if (log.isDebugEnabled()) {
                 log.debug("Asynchronous message exchange not enabled.  The invocation will be synchronous.");
             }
         }
-
         
-        // There should be an AsyncListener that is configured and set on the
-        // InvocationContext.  We must get this and use it to wait for the 
-        // async response to come back.  The AxisCallback that is set on the 
-        // AsyncListener is the callback that Axis2 will call when the response
-        // has arrived.
-        AsyncListener listener = ic.getAsyncListener();
-        AxisCallback axisCallback = new AxisCallback();
-        listener.setAxisCallback(axisCallback);
-        listener.setInvocationContext(ic);
         
-        // Once the AsyncListener is configured, we must include that in an 
-        // AsyncListenerWrapper.  The wrapper is what will handle the lifecycle 
-        // of the listener and determine when it's started and stopped.
-        AsyncListenerWrapper<?> wrapper = new AsyncListenerWrapper<Object>(listener);
-
-        // Inside of the wrapper we must set the callback that the JAX-WS
-        // client programmer provided.  This is the user object that we 
-        // must call back on once we've done everything we need to do at
-        // the JAX-WS layer.
+        CallbackFuture cbf = null;
         if(callback != null){
-            wrapper.setAsyncHandler(callback);
+            cbf = new CallbackFuture(ic.getAsyncResponseListener(), 
+                    callback, ic.getExecutor());
         }
         else {
             throw ExceptionFactory.makeWebServiceException(Messages.getMessage("ICErr4"));
         }
 
-        opClient.setCallback(axisCallback);
+        opClient.setCallback(cbf);
         
+        org.apache.axis2.context.MessageContext axisRequestMsgCtx = request.getAxisMessageContext();
         try {
             execute(opClient, false, axisRequestMsgCtx);
         } catch(AxisFault af) {
@@ -300,42 +263,64 @@
         	af.printStackTrace(System.out);
         }
         
-        // Now that the request has been sent, start the listener thread so that it can
-        // catch the async response.
-        // TODO: Need to determine whether this should be done BEFORE or AFTER
-        // we send the request.  My guess is before though.
-        try {
-            // TODO:Need to figure out where we get the Executor from
-            // Can't be from the MessageContext, but should maybe be 
-            // set somewhere accessible.
-            // FIXME: This should NOT be an ExecutorService, but should just
-            // be a plain old Executor.
-            ExecutorService exec = (ExecutorService) ic.getExecutor();
-            Future<?> future = exec.submit(wrapper);
-            future.get();
-            //TODO temp fix to resolve async callback hang.
-            exec.shutdown();
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-            throw ExceptionFactory.makeWebServiceException(e);
-        } catch (ExecutionException e) {
-            e.printStackTrace();
-            throw ExceptionFactory.makeWebServiceException(e);
-        }
-        
-        return wrapper;
+        return cbf.getFutureTask();
     }
     
     /*
      *  (non-Javadoc)
      * @see org.apache.axis2.jaxws.core.controller.InvocationController#invokeAsync(org.apache.axis2.jaxws.core.InvocationContext)
      */
-    public Response invokeAsync(InvocationContext ic) {
-        if (log.isDebugEnabled()) {
-            log.debug("Invocation pattern: async (polling)");
+    public Response doInvokeAsync(MessageContext request) {
+        // We need the qname of the operation being invoked to know which 
+        // AxisOperation the OperationClient should be based on.
+        // Note that the OperationDesc is only set through use of the Proxy. Dispatch
+        // clients do not use operations, so the operationDesc will be null.  In this
+        // case an anonymous AxisService with anoymouns AxisOperations for the supported
+        // MEPs will be created; and it is that anonymous operation name which needs to
+        // be specified
+        // TODO: Fix this logic once AxisService is created via annoations and not just WSDL
+        //       If ServiceDesc.axisService is null, then we created an Annon Service and operations in 
+        //       ServiceDelegate.getServiceClient(), and that is what the service client points to.
+        //       Therefore, we need to use the annonymous operation name in that case, so the anonymous service client will find 
+        //       the anonymous AxisOperation on that service.  
+        //       This means the ServiceDesc was not build with WSDL, and so there are no Axis objects attached to them
+        //       i.e the OperationDesc.axisOperation == null
+        QName operationName = getOperationNameToUse(request, ServiceClient.ANON_OUT_IN_OP);
+
+        // TODO: Will the ServiceClient stick around on the InvocationContext
+        // or will we need some other mechanism of creating this?
+        // Try to create an OperationClient from the passed in ServiceClient
+        InvocationContext ic = request.getInvocationContext();
+        ServiceClient svcClient = ic.getServiceClient();
+        OperationClient opClient = createOperationClient(svcClient, operationName);
+        
+        initOperationClient(opClient, request);
+        
+        // Setup the client so that it knows whether the underlying call to
+        // Axis2 knows whether or not to start a listening port for an
+        // asynchronous response.
+        Boolean useAsyncMep = (Boolean) request.getProperties().get(Constants.USE_ASYNC_MEP);
+        if((useAsyncMep != null && useAsyncMep.booleanValue()) 
+                || opClient.getOptions().isUseSeparateListener()) {
+            configureAsyncListener(opClient, request.getAxisMessageContext());
         }
         
-        throw ExceptionFactory.makeWebServiceException(Messages.getMessage("AsyncPollingNotSupported"));
+        AsyncResponse resp = ic.getAsyncResponseListener(); 
+        opClient.setCallback(resp);
+        
+        org.apache.axis2.context.MessageContext axisRequestMsgCtx = request.getAxisMessageContext();
+        try {
+            execute(opClient, false, axisRequestMsgCtx);
+        } catch(AxisFault af) {
+            // TODO MIKE revisit?
+            // do nothing here.  The exception we get is from the endpoint,
+            // and will be sitting on the message context.  We need to save it
+            // to process it through jaxws
+            System.out.println("Swallowed Exception =" + af);
+            af.printStackTrace(System.out);
+        }
+        
+        return resp;
     }
     
     /*
@@ -477,6 +462,26 @@
         }
     }
     
+    private void configureAsyncListener(OperationClient client, org.apache.axis2.context.MessageContext mc) {
+    	if (log.isDebugEnabled()) {
+        	log.debug("Enabling asynchronous message exchange.  An asynchronous listener will be establish.");
+		}
+    
+        client.getOptions().setUseSeparateListener(true);
+        client.getOptions().setTransportInProtocol("http");
+
+        //FIXME: This has to be here so the ThreadContextMigrator can pick it up.
+        //This should go away once AXIS2-978 is fixed.
+        mc.getOptions().setUseSeparateListener(true);
+        
+        // Setup the response callback receiver to receive the async response
+        // This logic is based on org.apache.axis2.client.ServiceClient.sendReceiveNonBlocking(...)
+        AxisOperation op = client.getOperationContext().getAxisOperation();
+        MessageReceiver messageReceiver = op.getMessageReceiver();
+        if (messageReceiver == null || !(messageReceiver instanceof CallbackReceiver))
+            op.setMessageReceiver(new CallbackReceiver());
+    }
+    
     private Message createMessageFromOM(OMElement om) throws MessageException {
         try {
             MessageFactory mf = (MessageFactory) FactoryRegistry.getFactory(MessageFactory.class);
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/core/controller/InvocationController.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/core/controller/InvocationController.java	(revision 471641)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/core/controller/InvocationController.java	(working copy)
@@ -1,204 +1,226 @@
-/*
- * Copyright 2006 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.axis2.jaxws.core.controller;
-
-import java.util.concurrent.Future;
-
-import javax.xml.ws.AsyncHandler;
-import javax.xml.ws.Response;
-import javax.xml.ws.WebServiceException;
-
-import org.apache.axis2.jaxws.ExceptionFactory;
-import org.apache.axis2.jaxws.core.InvocationContext;
-import org.apache.axis2.jaxws.core.MessageContext;
-import org.apache.axis2.jaxws.i18n.Messages;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-/**
- * The <tt>InvocationController</tt> is an abstract implementation modeling
- * the invocation of a target web service.  All of the information that the 
- * InvocationController needs should exist within the InvocatonContext
- * that is passed in to the various invoke methods.  
- * 
- * The request information is passed in within the InvocationContext.  The
- * InvocationController assumes that there is a MessageContext within that
- * InvocationContext that is populated with all of the information that it
- * needs to invoke.  If not, an error will be returned.  Once the response 
- * comes back, the information for that response will be held inside of the
- * MessageContext representing the response, that exists in the 
- * InvocationContext.
- * 
- * The InvocationController supports four different invocation patterns:
- * 
- * 1) synchronous - This is represented by the {@link #invoke(InvocationContext)}
- * method.  This is a blocking, request/response call to the web service.
- * 
- * 2) one-way - This is represented by the {@link #invokeOneWay(InvocationContext)}
- * method.  This is a one-way invocation that only returns errors related
- * to sending the message.  If an error occurs while processing, the client
- * will not be notified.
- * 
- * 3) asynchronous (callback) - {@link #invokeAsync(InvocationContext, AsyncHandler)}
- * 
- * 4) asynchronous (polling) - {@link #invokeAsync(InvocationContext)}
- */
-public abstract class InvocationController {
-    
-    private static final Log log = LogFactory.getLog(InvocationController.class);
-    
-    /**
-     * Performs a synchronous (blocking) invocation of a target service.  The 
-     * InvocationContext passed in should contain a valid MessageContext 
-     * containing the properties and message to be sent for the request.  The
-     * response contents will be processed and placed in the InvocationContext
-     * as well.
-     * 
-     * @param ic
-     * @return
-     */
-    public InvocationContext invoke(InvocationContext ic) {
-        if (log.isDebugEnabled()) {
-            log.debug("Invocation pattern: synchronous");
-        }
-        
-        // Check to make sure we at least have a valid InvocationContext
-        // and request MessageContext
-        if (ic == null) {
-            throw ExceptionFactory.makeWebServiceException(Messages.getMessage("ICErr1"));
-        }
-        if (ic.getRequestMessageContext() == null) {
-            throw ExceptionFactory.makeWebServiceException(Messages.getMessage("ICErr2"));
-        }
-        
-        MessageContext request = ic.getRequestMessageContext();
-        MessageContext response = null;
-
-        // TODO: Place-holder for running the JAX-WS request handler chain
-        
-        prepareRequest(request);
-        
-        response = doInvoke(request);
-        prepareResponse(response);
-        ic.setResponseMessageContext(response);
-        
-        // TODO: Place-holder for running the JAX-WS response handler chain
-        
-        return ic;
-    }
-    
-    protected abstract MessageContext doInvoke(MessageContext request);
-    
-    /**
-     * Performs a one-way invocation of the client.  This is SHOULD NOT be a 
-     * robust invocation, so any fault that occurs during the processing of 
-     * the request will not be returned to the client.  Errors returned to the
-     * client are problems that occurred during the sending of the message to 
-     * the server.
-     * 
-     * @param ic
-     */
-    public void invokeOneWay(InvocationContext ic) {
-        if (log.isDebugEnabled()) {
-            log.debug("Invocation pattern: one-way");
-        }
-        
-        // Check to make sure we at least have a valid InvocationContext
-        // and request MessageContext
-        if (ic == null) {
-            throw ExceptionFactory.makeWebServiceException("ICErr1");
-        }
-        if (ic.getRequestMessageContext() == null) {
-            throw ExceptionFactory.makeWebServiceException("ICErr2");
-        }
-        
-        MessageContext request = ic.getRequestMessageContext();
-        
-        // TODO: Place-holder to run the JAX-WS request handler chain
-        
-        prepareRequest(request);
-        doInvokeOneWay(request);
-        return;
-    }
-    
-    protected abstract void doInvokeOneWay(MessageContext mc) throws WebServiceException;
-    
-    /**
-     * Performs an asynchronous (non-blocking) invocation of the client based 
-     * on a callback model.  The AsyncHandler that is passed in is the callback
-     * that the client programmer supplied when they invoked their JAX-WS
-     * Dispatch or their SEI-based dynamic proxy.  
-     * 
-     * @param ic
-     * @param callback
-     * @return
-     */
-    public abstract Response invokeAsync(InvocationContext ic);
-    
-    /**
-     * Performs an asynchronous (non-blocking) invocation of the client based 
-     * on a polling model.  The Response object that is returned allows the 
-     * client programmer to poll against it to see if a response has been sent
-     * back by the server.
-     * 
-     * @param ic
-     * @return
-     */
-    public Future<?> invokeAsync(InvocationContext ic, AsyncHandler asyncHandler) {
-        if (log.isDebugEnabled()) {
-            log.debug("Invocation pattern: asynchronous(callback)");
-        }
-        
-        // Check to make sure we at least have a valid InvocationContext
-        // and request MessageContext
-        if (ic == null) {
-            throw ExceptionFactory.makeWebServiceException(Messages.getMessage("ICErr1"));
-        }
-        if (ic.getRequestMessageContext() == null) {
-            throw ExceptionFactory.makeWebServiceException(Messages.getMessage("ICErr2"));
-        }
-        
-        MessageContext request = ic.getRequestMessageContext();
-
-        // TODO: Place-holder for running the JAX-WS request handler chain
-        
-        prepareRequest(request);
-        Future<?> future = doInvokeAsync(request, asyncHandler);
-        return future;        
-    }
-    
-    public abstract Future<?> doInvokeAsync(MessageContext mc, AsyncHandler asyncHandler);
-    
-    /**
-     * Abstract method that must be implemented by whoever is providing
-     * the specific client binding.  Once this is called, everything that
-     * is needed to invoke the operation must be available in the 
-     * MessageContext.
-     * @param mc
-     */
-    protected abstract void prepareRequest(MessageContext mc);
-    
-    /**
-     * Abstract method that must be implemented by whoever is providing
-     * the specific client binding.  This is called after the response has 
-     * come back and allows the client binding to put whatever info it has
-     * in the response MessageContext.
-     * @param mc
-     */
-    protected abstract void prepareResponse(MessageContext mc);
-    
-}
+/*
+ * Copyright 2006 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.core.controller;
+
+import java.util.concurrent.Future;
+
+import javax.xml.ws.AsyncHandler;
+import javax.xml.ws.Response;
+
+import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.core.InvocationContext;
+import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.i18n.Messages;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * The <tt>InvocationController</tt> is an abstract implementation modeling
+ * the invocation of a target web service.  All of the information that the 
+ * InvocationController needs should exist within the InvocatonContext
+ * that is passed in to the various invoke methods.  
+ * 
+ * The request information is passed in within the InvocationContext.  The
+ * InvocationController assumes that there is a MessageContext within that
+ * InvocationContext that is populated with all of the information that it
+ * needs to invoke.  If not, an error will be returned.  Once the response 
+ * comes back, the information for that response will be held inside of the
+ * MessageContext representing the response, that exists in the 
+ * InvocationContext.
+ * 
+ * The InvocationController supports four different invocation patterns:
+ * 
+ * 1) synchronous - This is represented by the {@link #invoke(InvocationContext)}
+ * method.  This is a blocking, request/response call to the web service.
+ * 
+ * 2) one-way - This is represented by the {@link #invokeOneWay(InvocationContext)}
+ * method.  This is a one-way invocation that only returns errors related
+ * to sending the message.  If an error occurs while processing, the client
+ * will not be notified.
+ * 
+ * 3) asynchronous (callback) - {@link #invokeAsync(InvocationContext, AsyncHandler)}
+ * 
+ * 4) asynchronous (polling) - {@link #invokeAsync(InvocationContext)}
+ */
+public abstract class InvocationController {
+    
+    private static final Log log = LogFactory.getLog(InvocationController.class);
+    
+    /**
+     * Performs a synchronous (blocking) invocation of a target service.  The 
+     * InvocationContext passed in should contain a valid MessageContext 
+     * containing the properties and message to be sent for the request.  The
+     * response contents will be processed and placed in the InvocationContext
+     * as well.
+     * 
+     * @param ic
+     * @return
+     */
+    public InvocationContext invoke(InvocationContext ic) {
+        if (log.isDebugEnabled()) {
+            log.debug("Invocation pattern: synchronous");
+        }
+        
+        // Check to make sure we at least have a valid InvocationContext
+        // and request MessageContext
+        if (ic == null) {
+            throw ExceptionFactory.makeWebServiceException(Messages.getMessage("ICErr1"));
+        }
+        if (ic.getRequestMessageContext() == null) {
+            throw ExceptionFactory.makeWebServiceException(Messages.getMessage("ICErr2"));
+        }
+        
+        MessageContext request = ic.getRequestMessageContext();
+        MessageContext response = null;
+
+        // TODO: Place-holder for running the JAX-WS request handler chain
+        
+        prepareRequest(request);
+        
+        response = doInvoke(request);
+        prepareResponse(response);
+        ic.setResponseMessageContext(response);
+        
+        // TODO: Place-holder for running the JAX-WS response handler chain
+        
+        return ic;
+    }
+    
+    protected abstract MessageContext doInvoke(MessageContext request);
+    
+    /**
+     * Performs a one-way invocation of the client.  This is SHOULD NOT be a 
+     * robust invocation, so any fault that occurs during the processing of 
+     * the request will not be returned to the client.  Errors returned to the
+     * client are problems that occurred during the sending of the message to 
+     * the server.
+     * 
+     * @param ic
+     */
+    public void invokeOneWay(InvocationContext ic) {
+        if (log.isDebugEnabled()) {
+            log.debug("Invocation pattern: one-way");
+        }
+        
+        // Check to make sure we at least have a valid InvocationContext
+        // and request MessageContext
+        if (ic == null) {
+            throw ExceptionFactory.makeWebServiceException("ICErr1");
+        }
+        if (ic.getRequestMessageContext() == null) {
+            throw ExceptionFactory.makeWebServiceException("ICErr2");
+        }
+        
+        MessageContext request = ic.getRequestMessageContext();
+        
+        // TODO: Place-holder to run the JAX-WS request handler chain
+        
+        prepareRequest(request);
+        doInvokeOneWay(request);
+        return;
+    }
+    
+    protected abstract void doInvokeOneWay(MessageContext mc);
+    
+    /**
+     * Performs an asynchronous (non-blocking) invocation of the client based 
+     * on a callback model.  The AsyncHandler that is passed in is the callback
+     * that the client programmer supplied when they invoked their JAX-WS
+     * Dispatch or their SEI-based dynamic proxy.  
+     * 
+     * @param ic
+     * @param callback
+     * @return
+     */
+    public Response invokeAsync(InvocationContext ic) {
+        if (log.isDebugEnabled()) {
+            log.debug("Invocation pattern: asynchronous(callback)");
+        }
+        
+        // Check to make sure we at least have a valid InvocationContext
+        // and request MessageContext
+        if (ic == null) {
+            throw ExceptionFactory.makeWebServiceException(Messages.getMessage("ICErr1"));
+        }
+        if (ic.getRequestMessageContext() == null) {
+            throw ExceptionFactory.makeWebServiceException(Messages.getMessage("ICErr2"));
+        }
+        
+        MessageContext request = ic.getRequestMessageContext();
+
+        // TODO: Place-holder for running the JAX-WS request handler chain
+        
+        prepareRequest(request);
+        Response resp = doInvokeAsync(request);
+        return resp;
+    }
+    
+    public abstract Response doInvokeAsync(MessageContext mc);
+    
+    /**
+     * Performs an asynchronous (non-blocking) invocation of the client based 
+     * on a polling model.  The Response object that is returned allows the 
+     * client programmer to poll against it to see if a response has been sent
+     * back by the server.
+     * 
+     * @param ic
+     * @return
+     */
+    public Future<?> invokeAsync(InvocationContext ic, AsyncHandler asyncHandler) {
+        if (log.isDebugEnabled()) {
+            log.debug("Invocation pattern: asynchronous(callback)");
+        }
+        
+        // Check to make sure we at least have a valid InvocationContext
+        // and request MessageContext
+        if (ic == null) {
+            throw ExceptionFactory.makeWebServiceException(Messages.getMessage("ICErr1"));
+        }
+        if (ic.getRequestMessageContext() == null) {
+            throw ExceptionFactory.makeWebServiceException(Messages.getMessage("ICErr2"));
+        }
+        
+        MessageContext request = ic.getRequestMessageContext();
+
+        // TODO: Place-holder for running the JAX-WS request handler chain
+        
+        prepareRequest(request);
+        Future<?> future = doInvokeAsync(request, asyncHandler);
+        return future;        
+    }
+    
+    public abstract Future<?> doInvokeAsync(MessageContext mc, AsyncHandler asyncHandler);
+    
+    /**
+     * Abstract method that must be implemented by whoever is providing
+     * the specific client binding.  Once this is called, everything that
+     * is needed to invoke the operation must be available in the 
+     * MessageContext.
+     * @param mc
+     */
+    protected abstract void prepareRequest(MessageContext mc);
+    
+    /**
+     * Abstract method that must be implemented by whoever is providing
+     * the specific client binding.  This is called after the response has 
+     * come back and allows the client binding to put whatever info it has
+     * in the response MessageContext.
+     * @param mc
+     */
+    protected abstract void prepareResponse(MessageContext mc);
+    
+}
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/core/InvocationContext.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/core/InvocationContext.java	(revision 470629)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/core/InvocationContext.java	(working copy)
@@ -22,7 +22,7 @@
 import javax.xml.ws.handler.Handler;
 
 import org.apache.axis2.client.ServiceClient;
-import org.apache.axis2.jaxws.impl.AsyncListener;
+import org.apache.axis2.jaxws.client.async.AsyncResponse;
 
 /**
  * The <code>InvocationContext</code> encapsulates all of the information 
@@ -47,9 +47,9 @@
     
     public void setExecutor(Executor e);
     
-    public AsyncListener getAsyncListener();
+    public AsyncResponse getAsyncResponseListener();
     
-    public void setAsyncListener(AsyncListener al);
+    public void setAsyncResponseListener(AsyncResponse al);
     
     //FIXME: This is temporary.
     public void setServiceClient(ServiceClient client);
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/XMLDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/XMLDispatch.java	(revision 470629)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/XMLDispatch.java	(working copy)
@@ -24,8 +24,8 @@
 
 import org.apache.axiom.om.OMElement;
 import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.client.async.AsyncResponse;
 import org.apache.axis2.jaxws.handler.PortData;
-import org.apache.axis2.jaxws.impl.AsyncListener;
 import org.apache.axis2.jaxws.message.Block;
 import org.apache.axis2.jaxws.message.Message;
 import org.apache.axis2.jaxws.message.Protocol;
@@ -56,7 +56,7 @@
         type = c;
     }
     
-    public AsyncListener createAsyncListener() {
+    public AsyncResponse createAsyncResponseListener() {
         if (log.isDebugEnabled()) {
             log.debug("Creating new AsyncListener for XMLDispatch");
         }
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyAsyncListener.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyAsyncListener.java	(revision 470629)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyAsyncListener.java	(working copy)
@@ -16,10 +16,9 @@
  */
 package org.apache.axis2.jaxws.client.proxy;
 
-import org.apache.axis2.jaxws.AxisCallback;
 import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.client.async.AsyncResponse;
 import org.apache.axis2.jaxws.core.MessageContext;
-import org.apache.axis2.jaxws.impl.AsyncListener;
 
 
 /**
@@ -28,7 +27,7 @@
  * The Class will return the data type associated with Response<T> Generic Class.
  * Example Response<Float> will return a Float object to client on Response.get() call.
  */
-public class ProxyAsyncListener extends AsyncListener {
+public class ProxyAsyncListener extends AsyncResponse {
 
 	JAXWSProxyHandler handler = null;
 	Object[] inputArgs = null;
@@ -48,23 +47,15 @@
 		this.inputArgs = inputArgs;
 	}
 
-	/**
-	 * @param cb
-	 */
-	public ProxyAsyncListener(AxisCallback cb) {
-		super(cb);
-		
+	public Object getResponseValueObject(MessageContext mc) {
+	    try{
+	        //I will delegate the request to create respose to proxyHandler 
+            //since it has all the logic written to create response for Sync 
+            //and oneWay.
+	        return handler.createResponse(null,inputArgs, mc);
+	    }
+	    catch (Throwable e) {
+	        throw ExceptionFactory.makeWebServiceException(e);
+	    }
 	}
-	
-	 public Object getResponseValueObject(MessageContext mc){
-		 
-		 try{
-			 //I will delegate the request to create respose to proxyHandler since it has all the logic written to create response for Sync and oneWay.
-			  return handler.createResponse(null,inputArgs, mc);
-		 }catch(Throwable e){
-			throw ExceptionFactory.makeWebServiceException(e);
-		 }
-	 }
-
-	 
 }
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/JAXWSProxyHandler.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/JAXWSProxyHandler.java	(revision 470629)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/JAXWSProxyHandler.java	(working copy)
@@ -21,7 +21,6 @@
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.util.Map;
 import java.util.concurrent.Future;
 
 import javax.jws.soap.SOAPBinding;
@@ -33,6 +32,7 @@
 
 import org.apache.axis2.jaxws.BindingProvider;
 import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.client.async.AsyncResponse;
 import org.apache.axis2.jaxws.core.InvocationContext;
 import org.apache.axis2.jaxws.core.InvocationContextFactory;
 import org.apache.axis2.jaxws.core.MessageContext;
@@ -44,7 +44,6 @@
 import org.apache.axis2.jaxws.description.ServiceDescriptionWSDL;
 import org.apache.axis2.jaxws.handler.PortData;
 import org.apache.axis2.jaxws.i18n.Messages;
-import org.apache.axis2.jaxws.impl.AsyncListener;
 import org.apache.axis2.jaxws.marshaller.MethodMarshaller;
 import org.apache.axis2.jaxws.marshaller.factory.MethodMarshallerFactory;
 import org.apache.axis2.jaxws.message.Message;
@@ -52,7 +51,6 @@
 import org.apache.axis2.jaxws.registry.FactoryRegistry;
 import org.apache.axis2.jaxws.spi.ServiceDelegate;
 import org.apache.axis2.jaxws.util.WSDLWrapper;
-import org.apache.axis2.transport.http.HTTPConstants;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -214,8 +212,8 @@
 			if(asyncHandler == null){
 				throw ExceptionFactory.makeWebServiceException("AynchHandler null for Async callback, Invalid AsyncHandler callback Object");
 			}
-			AsyncListener listener = createProxyListener(args);
-			requestIC.setAsyncListener(listener);
+			AsyncResponse listener = createProxyListener(args);
+			requestIC.setAsyncResponseListener(listener);
 			requestIC.setExecutor(delegate.getExecutor());
 				        
 	        Future<?> future = controller.invokeAsync(requestIC, asyncHandler);
@@ -233,8 +231,8 @@
 			if(log.isDebugEnabled()){
 				log.debug("Async Polling");
 			}
-			AsyncListener listener = createProxyListener(args);
-			requestIC.setAsyncListener(listener);
+			AsyncResponse listener = createProxyListener(args);
+			requestIC.setAsyncResponseListener(listener);
 			requestIC.setExecutor(delegate.getExecutor());
 	        
 			Response response = controller.invokeAsync(requestIC);
@@ -264,7 +262,7 @@
 		return null;
 	}
 	
-	private AsyncListener createProxyListener(Object[] args){
+	private AsyncResponse createProxyListener(Object[] args){
 		ProxyAsyncListener listener = new ProxyAsyncListener();
 		listener.setHandler(this);
 		listener.setInputArgs(args);
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatch.java	(revision 470629)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatch.java	(working copy)
@@ -19,6 +19,7 @@
 import javax.xml.bind.JAXBContext;
 
 import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.client.async.AsyncResponse;
 import org.apache.axis2.jaxws.handler.PortData;
 import org.apache.axis2.jaxws.impl.AsyncListener;
 import org.apache.axis2.jaxws.marshaller.ClassUtils;
@@ -46,7 +47,7 @@
         jaxbContext = jbc;
     }
     
-    public AsyncListener createAsyncListener() {
+    public AsyncResponse createAsyncResponseListener() {
         JAXBDispatchAsyncListener listener = new JAXBDispatchAsyncListener();
         listener.setJAXBContext(jaxbContext);
         listener.setMode(mode);
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/XMLDispatchAsyncListener.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/XMLDispatchAsyncListener.java	(revision 470629)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/XMLDispatchAsyncListener.java	(working copy)
@@ -5,8 +5,8 @@
 import javax.xml.ws.Service.Mode;
 
 import org.apache.axiom.om.OMElement;
+import org.apache.axis2.jaxws.client.async.AsyncResponse;
 import org.apache.axis2.jaxws.core.MessageContext;
-import org.apache.axis2.jaxws.impl.AsyncListener;
 import org.apache.axis2.jaxws.message.Block;
 import org.apache.axis2.jaxws.message.Message;
 import org.apache.axis2.jaxws.message.MessageException;
@@ -20,7 +20,7 @@
  * {@link org.apache.axis2.jaxws.impl.AsyncListener} class to provide 
  * proper deserialization into the target format (XML String or Source).
  */
-public class XMLDispatchAsyncListener extends AsyncListener {
+public class XMLDispatchAsyncListener extends AsyncResponse {
 
     private Mode mode;
     private Class type;
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatchAsyncListener.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatchAsyncListener.java	(revision 470629)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/JAXBDispatchAsyncListener.java	(working copy)
@@ -20,8 +20,8 @@
 import javax.xml.ws.Service.Mode;
 
 import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.client.async.AsyncResponse;
 import org.apache.axis2.jaxws.core.MessageContext;
-import org.apache.axis2.jaxws.impl.AsyncListener;
 import org.apache.axis2.jaxws.message.Block;
 import org.apache.axis2.jaxws.message.Message;
 import org.apache.axis2.jaxws.message.databinding.JAXBBlockContext;
@@ -33,7 +33,7 @@
  * {@link org.apache.axis2.jaxws.impl.AsyncListener} class to provide JAX-B
  * specific function when processing an async response.
  */
-public class JAXBDispatchAsyncListener extends AsyncListener {
+public class JAXBDispatchAsyncListener extends AsyncResponse {
     
     private Mode mode;
     private JAXBContext jaxbContext;
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/BaseDispatch.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/BaseDispatch.java	(revision 470629)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/BaseDispatch.java	(working copy)
@@ -30,6 +30,7 @@
 import org.apache.axis2.client.ServiceClient;
 import org.apache.axis2.jaxws.BindingProvider;
 import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.client.async.AsyncResponse;
 import org.apache.axis2.jaxws.core.InvocationContext;
 import org.apache.axis2.jaxws.core.InvocationContextFactory;
 import org.apache.axis2.jaxws.core.MessageContext;
@@ -89,7 +90,7 @@
      * 
      * @return a configured AsyncListener instance
      */
-    protected abstract AsyncListener createAsyncListener();
+    protected abstract AsyncResponse createAsyncResponseListener();
     
     public Object invoke(Object obj) throws WebServiceException {
         if (log.isDebugEnabled()) { 
@@ -234,8 +235,8 @@
         invocationContext.setExecutor(e);
         
         // Create the AsyncListener that is to be used by the InvocationController.
-        AsyncListener listener = createAsyncListener();
-        invocationContext.setAsyncListener(listener);
+        AsyncResponse listener = createAsyncResponseListener();
+        invocationContext.setAsyncResponseListener(listener);
         
         // Send the request using the InvocationController
         Future<?> asyncResponse = ic.invokeAsync(invocationContext, asynchandler);
@@ -254,7 +255,58 @@
     }
   
     public Response invokeAsync(Object obj)throws WebServiceException{
-        throw new UnsupportedOperationException("Async (polling) invocations are not yet supported.");
+        if (log.isDebugEnabled()) { 
+            log.debug("Entered asynchronous (polling) invocation: BaseDispatch.invokeAsync()");
+        }
+        
+        // Create the InvocationContext instance for this request/response flow.
+        InvocationContext invocationContext = InvocationContextFactory.createInvocationContext(null);
+        invocationContext.setServiceClient(serviceClient);
+        
+        // Create the MessageContext to hold the actual request message and its
+        // associated properties
+        MessageContext requestMsgCtx = new MessageContext();
+        invocationContext.setRequestMessageContext(requestMsgCtx);
+        
+        Message requestMsg = null;
+        if (isValidInvocationParam(obj)) {
+            requestMsg = createMessageFromValue(obj);
+        }
+        else {
+            throw ExceptionFactory.makeWebServiceException("dispatchInvalidParam");
+        }
+        
+        setupMessageProperties(requestMsg);
+        requestMsgCtx.setMessage(requestMsg);
+        
+        // Copy the properties from the request context into the MessageContext
+        requestMsgCtx.getProperties().putAll(requestContext);
+
+        // Setup the Executor that will be used to drive async responses back to 
+        // the client.
+        // FIXME: We shouldn't be getting this from the ServiceDelegate, rather each 
+        // Dispatch object should have it's own.
+        Executor e = serviceDelegate.getExecutor();
+        invocationContext.setExecutor(e);
+        
+        // Create the AsyncListener that is to be used by the InvocationController.
+        AsyncResponse listener = createAsyncResponseListener();
+        invocationContext.setAsyncResponseListener(listener);
+        
+        // Send the request using the InvocationController
+        Response asyncResponse = ic.invokeAsync(invocationContext);
+        
+        //Check to see if we need to maintain session state
+        if (requestMsgCtx.isMaintainSession()) {
+            //TODO: Need to figure out a cleaner way to make this call. 
+            setupSessionContext(invocationContext.getServiceClient().getServiceContext().getProperties());
+        }
+        
+        if (log.isDebugEnabled()) {
+            log.debug("Asynchronous (polling) invocation sent: BaseDispatch.invokeAsync()");
+        }
+        
+        return asyncResponse;
     }
     
     //FIXME: This needs to be moved up to the BindingProvider and should actually
@@ -323,7 +375,7 @@
      * a violation.
      */
     private boolean isValidInvocationParam(Object object){
-    	String bindingId = port.getBindingID();
+        String bindingId = port.getBindingID();
         
         // If no bindingId was found, use the default.
         if (bindingId == null) {
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/async/CallbackFuture.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/async/CallbackFuture.java	(revision 0)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/async/CallbackFuture.java	(revision 0)
@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *      
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.jaxws.client.async;
+
+import java.util.concurrent.Callable;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Future;
+import java.util.concurrent.FutureTask;
+
+import javax.xml.ws.AsyncHandler;
+
+import org.apache.axis2.client.async.AsyncResult;
+import org.apache.axis2.client.async.Callback;
+
+public class CallbackFuture extends Callback {
+    
+    private CallbackFutureTask cft;
+    private Executor executor;
+    private FutureTask task;
+   
+    public CallbackFuture(AsyncResponse response, AsyncHandler handler, Executor exec) {
+        cft = new CallbackFutureTask(response, handler);
+        task = new FutureTask(cft);
+        executor = exec;
+    }
+    
+    public Future<?> getFutureTask() {
+        return (Future<?>) task;
+    }
+    
+    @Override
+    public void onComplete(AsyncResult result) {
+        cft.setResult(result);
+        execute();
+    }
+
+    @Override
+    public void onError(Exception e) {
+         cft.setError(e);
+         execute();
+    }
+    
+    private void execute() {
+        if (executor != null) {
+            executor.execute(task);
+        }
+    }    
+}
+
+class CallbackFutureTask implements Callable {
+    
+    AsyncResponse response;
+    AsyncResult result;
+    AsyncHandler handler;
+    Exception error;
+    
+    CallbackFutureTask(AsyncResponse r, AsyncHandler h) {
+        response = r;
+        handler = h;
+    }
+    
+    void setResult(AsyncResult r) {
+        result = r;
+    }
+    
+    void setError(Exception e) {
+        error = e;
+    }
+    
+    public Object call() throws Exception {
+        if (result != null) {
+            response.onComplete(result);    
+        }
+        else if (error != null) {
+            response.onError(error);
+        }
+        
+        handler.handleResponse(response);        
+        return null;
+    }
+}
\ No newline at end of file
Index: C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/async/AsyncResponse.java
===================================================================
--- C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/async/AsyncResponse.java	(revision 0)
+++ C:/work/apps/eclipse/workspace/axis2-current/modules/jaxws/src/org/apache/axis2/jaxws/client/async/AsyncResponse.java	(revision 0)
@@ -0,0 +1,135 @@
+package org.apache.axis2.jaxws.client.async;
+
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+import javax.xml.ws.Response;
+import javax.xml.ws.WebServiceException;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axis2.client.async.AsyncResult;
+import org.apache.axis2.client.async.Callback;
+import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.message.Message;
+import org.apache.axis2.jaxws.message.MessageException;
+import org.apache.axis2.jaxws.util.Constants;
+import org.apache.axis2.util.ThreadContextMigratorUtil;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+public class AsyncResponse extends Callback implements Response {
+
+    private static final Log log = LogFactory.getLog(AsyncResponse.class);
+    
+    private boolean done;
+    private boolean cancelled;
+    private Object responseObj;
+    private MessageContext response;
+    private Map<String, Object> responseContext;
+    private Throwable fault;
+    
+    //-------------------------------------
+    // org.apache.axis2.client.async.Callback APIs
+    //-------------------------------------
+    @Override
+    public void onComplete(AsyncResult result) {
+        try {
+            org.apache.axis2.context.MessageContext axisResponse = result.getResponseMessageContext();
+            response = new MessageContext(axisResponse);
+            
+            //REVIEW: Are we on the final thread of execution here or does this get handed off to the executor?
+            // TODO: Remove workaround for WS-Addressing running in thin client (non-server) environment
+            try {
+                ThreadContextMigratorUtil.performMigrationToThread(Constants.THREAD_CONTEXT_MIGRATOR_LIST_ID, axisResponse);
+            }
+            catch (Throwable t) {
+                fault = t;
+                
+                if (log.isDebugEnabled()) {
+                    log.debug("JAX-WS AxisCallback caught throwable from ThreadContextMigratorUtil " + t);
+                    log.debug("...caused by " + t.getCause());
+                }
+                t.printStackTrace();
+            }
+        } catch (MessageException e) {
+            fault = e;
+            e.printStackTrace();
+        }
+        
+        done = true;
+    }
+
+    @Override
+    public void onError(Exception e) {
+        fault = e;
+    }
+    
+    //-------------------------------------
+    // javax.xml.ws.Response APIs
+    //-------------------------------------
+    
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        return false;
+    }
+
+    public Object get() throws InterruptedException, ExecutionException {
+        if (hasFault()) {
+            throw new ExecutionException(fault);
+        }
+        if (response == null) {
+            WebServiceException wse = new WebServiceException("null response");
+            throw new ExecutionException(wse);
+        }
+        
+        // TODO: Check the type of the object to make sure it corresponds with
+        // the parameterized generic type.
+        if (responseObj == null) {
+            responseObj = getResponseValueObject(response);
+        }
+        
+        return responseObj;
+    }
+
+    public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+        return null;
+    }
+
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    public boolean isDone() {
+        return done;
+    }
+
+    public Map getContext() {
+        return responseContext;
+    }
+    
+    public boolean hasFault() {
+        if (fault != null)
+            return true;
+        else
+            return false;
+    }
+    
+    /**
+     * A default implementation of this method that returns the contents
+     * of the message in the form of an XML String.  Subclasses should override
+     * this to convert the response message into whatever format they require.
+     * @param msg
+     */
+    protected Object getResponseValueObject(MessageContext mc) {
+        try {
+            Message msg = mc.getMessage();
+            OMElement om = msg.getAsOMElement();
+            return om.toString();
+        } catch (MessageException e) {
+            throw ExceptionFactory.makeWebServiceException(e);
+        }
+    }
+
+}
