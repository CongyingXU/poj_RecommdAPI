Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/proxy/ProxyTests.java
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/proxy/ProxyTests.java	(revision 0)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/proxy/ProxyTests.java	(revision 0)
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.proxy;
+
+import java.io.File;
+import java.io.StringWriter;
+import java.net.URL;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLOutputFactory;
+import javax.xml.stream.XMLStreamWriter;
+import javax.xml.ws.BindingProvider;
+import javax.xml.ws.Service;
+
+import junit.framework.TestCase;
+
+import org.apache.axis2.jaxws.proxy.doclitwrapped.sei.DocLitWrappedProxy;
+import org.test.proxy.doclitwrapped.ReturnType;
+
+
+public class ProxyTests extends TestCase {
+	private QName serviceName = new QName(
+			"http://org.apache.axis2.proxy.doclitwrapped", "ProxyDocLitWrappedService");
+	private String wasEndpoint = "http://localhost:9081/axis2/services/ProxyDocLitWrappedService";
+	private String axisEndpoint = "http://localhost:8080/axis2/services/ProxyDocLitWrappedService";
+	private QName portName = new QName("http://org.apache.axis2.proxy.doclitwrapped",
+			"ProxyDocLitWrappedPort");
+	private String wsdlLocation = "modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/META-INF/ProxyDocLitWrapped.wsdl";
+	private boolean runningOnAxis = true;
+	
+	public void testInvoke(){
+		try{ 
+			if(!runningOnAxis){
+				return;
+			}
+			System.out.println("---------------------------------------");
+			
+			File wsdl= new File(wsdlLocation); 
+			URL wsdlUrl = wsdl.toURL(); 
+			Service service = Service.create(null, serviceName);
+			//StockSymbol ss = new StockSymbol(); 
+			String request = new String("some string request"); 
+			//ss.setSymbol("IBM"); 
+			Object proxy =service.getPort(portName, DocLitWrappedProxy.class);
+			System.out.println(">>Invoking Binding Provider property");
+			BindingProvider p =	(BindingProvider)proxy;
+				p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,axisEndpoint);
+				
+			DocLitWrappedProxy dwp = (DocLitWrappedProxy)proxy;
+			System.out.println(">> Invoking Proxy");
+			String response = dwp.invoke(request);
+			System.out.println("Proxy Response =" + response);
+			System.out.println("---------------------------------------");
+		}catch(Exception e){ 
+			e.printStackTrace(); 
+		}
+	}
+	
+	public void testTwoWay(){
+		try{ 
+			if(runningOnAxis){
+				return;
+			}
+			File wsdl= new File(wsdlLocation); 
+			URL wsdlUrl = wsdl.toURL(); 
+			Service service = Service.create(null, serviceName);
+			//StockSymbol ss = new StockSymbol(); 
+			String request = new String("some string request"); 
+			//ss.setSymbol("IBM"); 
+			Object proxy =service.getPort(portName, DocLitWrappedProxy.class); 
+			BindingProvider p =	(BindingProvider)proxy;
+				p.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,wasEndpoint);
+				
+			DocLitWrappedProxy dwp = (DocLitWrappedProxy)proxy;  
+			String response = dwp.twoWay(request);
+			System.out.println("Response =" + response);
+		}catch(Exception e){ 
+			e.printStackTrace(); 
+		}
+	}
+	
+	public void testOneWay(){
+		
+	}
+	
+	public void testHolder(){
+		
+	}
+	
+	public void testAsyncCallback(){
+		
+	}
+}
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/META-INF/services.xml
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/META-INF/services.xml	(revision 0)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/META-INF/services.xml	(revision 0)
@@ -0,0 +1,12 @@
+<serviceGroup>
+ <service name="ProxyDocLitWrappedService">
+  <messageReceivers>
+   <messageReceiver mep="http://www.w3.org/2004/08/wsdl/in-out" class="org.apache.axis2.jaxws.server.JAXWSMessageReceiver"/>
+  </messageReceivers>
+  <parameter locked="false" name="ServiceClass">org.apache.axis2.jaxws.proxy.doclitwrapped.DocLitWrappedProxyImpl</parameter>
+  <operation name="invoke" mep="http://www.w3.org/2004/08/wsdl/in-out">
+    <actionMapping/>
+  </operation>
+ </service>
+</serviceGroup>
+
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/META-INF/MANIFEST.MF
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/META-INF/MANIFEST.MF	(revision 0)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/META-INF/MANIFEST.MF	(revision 0)
@@ -0,0 +1 @@
+Manifest-Version: 1.0
\ No newline at end of file
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/META-INF/ProxyDocLitWrapped.wsdl
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/META-INF/ProxyDocLitWrapped.wsdl	(revision 0)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/META-INF/ProxyDocLitWrapped.wsdl	(revision 0)
@@ -0,0 +1,282 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
+	xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
+	xmlns:tns="http://org.apache.axis2.proxy.doclitwrapped"
+	xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="proxy"
+	targetNamespace="http://org.apache.axis2.proxy.doclitwrapped">
+
+	<wsdl:types>
+		<xsd:schema
+			targetNamespace="http://org.apache.axis2.proxy.doclitwrapped"
+			xmlns:tns="http://org.apache.axis2.proxy.doclitwrapped"
+			xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+
+			<xsd:element name="MyFault" type="xsd:string" />
+
+			<xsd:element name="oneWayVoid">
+				<xsd:complexType>
+					<xsd:sequence />
+				</xsd:complexType>
+			</xsd:element>
+
+			<xsd:element name="oneWay">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="oneway_str"
+							type="xsd:string" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+
+			<xsd:element name="twoWayHolder">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="twoWayHolder_str"
+							type="xsd:string" />
+						<xsd:element name="twoWayHolder_int"
+							type="xsd:int" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+
+			<xsd:element name="twoWay">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="twoway_str"
+							type="xsd:string" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+			
+			<xsd:element name="ReturnType">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="return_str"
+							type="xsd:string" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+
+			<xsd:element name="invoke">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="invoke_str"
+							type="xsd:string" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+
+			<xsd:element name="invokeReturnType">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="return_str"
+							type="xsd:string" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+
+
+			
+
+			<!-- fin op definition -->
+
+			<xsd:element name="finOp">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="op"
+							type="tns:FinancialOperation" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+
+			<xsd:element name="finOpResponse">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="response"
+							type="tns:FinancialOperation" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+
+			<xsd:complexType name="FinancialOperation">
+				<xsd:sequence>
+					<xsd:element name="amount" type="xsd:float" />
+				</xsd:sequence>
+			</xsd:complexType>
+
+			<xsd:complexType name="Withdraw">
+				<xsd:complexContent>
+					<xsd:extension base="tns:FinancialOperation">
+						<xsd:sequence>
+							<xsd:element name="memo" type="xsd:string" />
+						</xsd:sequence>
+					</xsd:extension>
+				</xsd:complexContent>
+			</xsd:complexType>
+
+			<xsd:complexType name="Deposit">
+				<xsd:complexContent>
+					<xsd:extension base="tns:FinancialOperation">
+						<xsd:sequence>
+							<xsd:element name="status"
+								type="xsd:string" />
+						</xsd:sequence>
+					</xsd:extension>
+				</xsd:complexContent>
+			</xsd:complexType>
+
+		</xsd:schema>
+	</wsdl:types>
+
+	<wsdl:message name="oneWayVoidRequest">
+		<wsdl:part name="allByMyself" element="tns:oneWayVoid" />
+	</wsdl:message>
+
+	<wsdl:message name="oneWayRequest">
+		<wsdl:part name="allByMyself" element="tns:oneWay" />
+	</wsdl:message>
+
+	<wsdl:message name="twoWayHolderRequest">
+		<wsdl:part name="allByMyself" element="tns:twoWayHolder" />
+	</wsdl:message>
+
+	<wsdl:message name="twoWayHolderResponse">
+		<wsdl:part name="allByMyself" element="tns:twoWayHolder" />
+	</wsdl:message>
+
+	<wsdl:message name="twoWayRequest">
+		<wsdl:part name="allByMyself" element="tns:twoWay" />
+	</wsdl:message>
+
+	<wsdl:message name="twoWayResponse">
+		<wsdl:part name="allByMyself" element="tns:ReturnType" />
+	</wsdl:message>
+
+	<wsdl:message name="invokeRequest">
+		<wsdl:part name="allByMyself" element="tns:invoke" />
+	</wsdl:message>
+
+	<wsdl:message name="invokeResponse">
+		<wsdl:part name="allByMyself" element="tns:ReturnType" />
+	</wsdl:message>
+
+	<wsdl:message name="finOpRequest">
+		<wsdl:part name="op" element="tns:finOp" />
+	</wsdl:message>
+
+	<wsdl:message name="finOpResponse">
+		<wsdl:part name="op" element="tns:finOpResponse" />
+	</wsdl:message>
+
+	<wsdl:portType name="DocLitWrappedProxy">
+
+		<wsdl:operation name="oneWayVoid">
+			<wsdl:input message="tns:oneWayVoidRequest" />
+		</wsdl:operation>
+
+		<wsdl:operation name="oneWay">
+			<wsdl:input message="tns:oneWayRequest" />
+		</wsdl:operation>
+
+		<wsdl:operation name="twoWayHolder">
+			<wsdl:input message="tns:twoWayHolderRequest" />
+			<wsdl:output message="tns:twoWayHolderResponse" />
+		</wsdl:operation>
+
+		<wsdl:operation name="twoWay">
+			<wsdl:input message="tns:twoWayRequest" />
+			<wsdl:output message="tns:twoWayResponse" />
+		</wsdl:operation>
+		
+		<wsdl:operation name="invoke">
+			<wsdl:input message="tns:invokeRequest" />
+			<wsdl:output message="tns:invokeResponse" />
+		</wsdl:operation>
+		
+		<wsdl:operation name="finOp">
+			<wsdl:input message="tns:finOpRequest" />
+			<wsdl:output message="tns:finOpResponse" />
+		</wsdl:operation>
+
+	</wsdl:portType>
+
+	<wsdl:binding name="ProxyDocLitWrapped"
+		type="tns:DocLitWrappedProxy">
+		<soap:binding style="document"
+			transport="http://schemas.xmlsoap.org/soap/http" />
+
+		<wsdl:operation name="oneWayVoid">
+			<soap:operation
+				soapAction="http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn" />
+			<wsdl:input>
+				<soap:body use="literal" />
+			</wsdl:input>
+		</wsdl:operation>
+
+		<wsdl:operation name="oneWay">
+			<soap:operation
+				soapAction="http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn" />
+			<wsdl:input>
+				<soap:body use="literal" />
+			</wsdl:input>
+		</wsdl:operation>
+
+		<wsdl:operation name="twoWayHolder">
+			<soap:operation
+				soapAction="http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn" />
+			<wsdl:input>
+				<soap:body use="literal" />
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal" />
+			</wsdl:output>
+
+		</wsdl:operation>
+
+		<wsdl:operation name="twoWay">
+			<soap:operation
+				soapAction="http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn" />
+			<wsdl:input>
+				<soap:body use="literal" />
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal" />
+			</wsdl:output>
+
+		</wsdl:operation>
+		
+		<wsdl:operation name="invoke">
+			<soap:operation
+				soapAction="http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn" />
+			<wsdl:input>
+				<soap:body use="literal" />
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal" />
+			</wsdl:output>
+
+		</wsdl:operation>
+		
+		<wsdl:operation name="finOp">
+			<soap:operation
+				soapAction="http://org.apache.axis2.proxy.doclitwrapped/finOp" />
+			<wsdl:input>
+				<soap:body use="literal" />
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal" />
+			</wsdl:output>
+
+		</wsdl:operation>
+
+	</wsdl:binding>
+
+	<wsdl:service name="ProxyDocLitWrappedService">
+		<wsdl:port binding="tns:ProxyDocLitWrapped"
+			name="ProxyDocLitWrappedPort">
+			<soap:address
+				location="http://localhost:9080/axis2/services/ProxyDocLitWrappedService/invoke" />
+		</wsdl:port>
+	</wsdl:service>
+
+</wsdl:definitions>
\ No newline at end of file
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/sei/DocLitWrappedProxy.java
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/sei/DocLitWrappedProxy.java	(revision 0)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/sei/DocLitWrappedProxy.java	(revision 0)
@@ -0,0 +1,102 @@
+
+package org.apache.axis2.jaxws.proxy.doclitwrapped.sei;
+
+import javax.jws.Oneway;
+import javax.jws.WebMethod;
+import javax.jws.WebParam;
+import javax.jws.WebParam.Mode;
+import javax.jws.WebResult;
+import javax.jws.WebService;
+import javax.xml.ws.Holder;
+import javax.xml.ws.RequestWrapper;
+import javax.xml.ws.ResponseWrapper;
+
+import org.test.proxy.doclitwrapped.FinancialOperation;
+
+
+/**
+ * This class was generated by the JAXWS SI.
+ * JAX-WS RI 2.0_01-b15-fcs
+ * Generated source version: 2.0
+ * 
+ */
+@WebService(name = "DocLitWrappedProxy", targetNamespace = "http://org.apache.axis2.proxy.doclitwrapped")
+public interface DocLitWrappedProxy {
+
+
+    /**
+     * 
+     */
+    @WebMethod(action = "http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn")
+    @Oneway
+    @RequestWrapper(localName = "oneWayVoid", targetNamespace = "http://org.apache.axis2.proxy.doclitwrapped", className = "org.test.proxy.doclitwrapped.OneWayVoid")
+    public void oneWayVoid();
+
+    /**
+     * 
+     * @param onewayStr
+     */
+    @WebMethod(action = "http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn")
+    @Oneway
+    @RequestWrapper(localName = "oneWay", targetNamespace = "http://org.apache.axis2.proxy.doclitwrapped", className = "org.test.proxy.doclitwrapped.OneWay")
+    public void oneWay(
+        @WebParam(name = "oneway_str", targetNamespace = "")
+        String onewayStr);
+
+    /**
+     * 
+     * @param twoWayHolderInt
+     * @param twoWayHolderStr
+     */
+    @WebMethod(action = "http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn")
+    @RequestWrapper(localName = "twoWayHolder", targetNamespace = "http://org.apache.axis2.proxy.doclitwrapped", className = "org.test.proxy.doclitwrapped.TwoWayHolder")
+    @ResponseWrapper(localName = "twoWayHolder", targetNamespace = "http://org.apache.axis2.proxy.doclitwrapped", className = "org.test.proxy.doclitwrapped.TwoWayHolder")
+    public void twoWayHolder(
+        @WebParam(name = "twoWayHolder_str", targetNamespace = "", mode = Mode.INOUT)
+        Holder<String> twoWayHolderStr,
+        @WebParam(name = "twoWayHolder_int", targetNamespace = "", mode = Mode.INOUT)
+        Holder<Integer> twoWayHolderInt);
+
+    /**
+     * 
+     * @param twowayStr
+     * @return
+     *     returns java.lang.String
+     */
+    @WebMethod(action = "http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn")
+    @WebResult(name = "return_str", targetNamespace = "")
+    @RequestWrapper(localName = "twoWay", targetNamespace = "http://org.apache.axis2.proxy.doclitwrapped", className = "org.test.proxy.doclitwrapped.TwoWay")
+    @ResponseWrapper(localName = "ReturnType", targetNamespace = "http://org.apache.axis2.proxy.doclitwrapped", className = "org.test.proxy.doclitwrapped.ReturnType")
+    public String twoWay(
+        @WebParam(name = "twoway_str", targetNamespace = "")
+        String twowayStr);
+
+    /**
+     * 
+     * @param invokeStr
+     * @return
+     *     returns java.lang.String
+     */
+    @WebMethod(action = "http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn")
+    @WebResult(name = "return_str", targetNamespace = "")
+    @RequestWrapper(localName = "invoke", targetNamespace = "http://org.apache.axis2.proxy.doclitwrapped", className = "org.test.proxy.doclitwrapped.Invoke")
+    @ResponseWrapper(localName = "ReturnType", targetNamespace = "http://org.apache.axis2.proxy.doclitwrapped", className = "org.test.proxy.doclitwrapped.ReturnType")
+    public String invoke(
+        @WebParam(name = "invoke_str", targetNamespace = "")
+        String invokeStr);
+
+    /**
+     * 
+     * @param op
+     * @return
+     *     returns org.test.proxy.doclitwrapped.FinancialOperation
+     */
+    @WebMethod(action = "http://org.apache.axis2.proxy.doclitwrapped/finOp")
+    @WebResult(name = "response", targetNamespace = "")
+    @RequestWrapper(localName = "finOp", targetNamespace = "http://org.apache.axis2.proxy.doclitwrapped", className = "org.test.proxy.doclitwrapped.FinOp")
+    @ResponseWrapper(localName = "finOpResponse", targetNamespace = "http://org.apache.axis2.proxy.doclitwrapped", className = "org.test.proxy.doclitwrapped.FinOpResponse")
+    public FinancialOperation finOp(
+        @WebParam(name = "op", targetNamespace = "")
+        FinancialOperation op);
+
+}
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/sei/ProxyDocLitWrappedService.java
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/sei/ProxyDocLitWrappedService.java	(revision 0)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/sei/ProxyDocLitWrappedService.java	(revision 0)
@@ -0,0 +1,54 @@
+
+package org.apache.axis2.jaxws.proxy.doclitwrapped.sei;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import javax.xml.namespace.QName;
+import javax.xml.ws.Service;
+import javax.xml.ws.WebEndpoint;
+import javax.xml.ws.WebServiceClient;
+
+
+
+/**
+ * This class was generated by the JAXWS SI.
+ * JAX-WS RI 2.0_01-b15-fcs
+ * Generated source version: 2.0
+ * 
+ */
+@WebServiceClient(name = "ProxyDocLitWrappedService", targetNamespace = "http://org.apache.axis2.proxy.doclitwrapped", wsdlLocation = "c:\\temp\\ProxyDocLitWrapped.wsdl")
+public class ProxyDocLitWrappedService
+    extends Service
+{
+
+    private final static URL PROXYDOCLITWRAPPEDSERVICE_WSDL_LOCATION;
+
+    static {
+        URL url = null;
+        try {
+            url = new URL("file:/C:/temp/ProxyDocLitWrapped.wsdl");
+        } catch (MalformedURLException e) {
+            e.printStackTrace();
+        }
+        PROXYDOCLITWRAPPEDSERVICE_WSDL_LOCATION = url;
+    }
+
+    public ProxyDocLitWrappedService(URL wsdlLocation, QName serviceName) {
+        super(wsdlLocation, serviceName);
+    }
+
+    public ProxyDocLitWrappedService() {
+        super(PROXYDOCLITWRAPPEDSERVICE_WSDL_LOCATION, new QName("http://org.apache.axis2.proxy.doclitwrapped", "ProxyDocLitWrappedService"));
+    }
+
+    /**
+     * 
+     * @return
+     *     returns DocLitWrappedProxy
+     */
+    @WebEndpoint(name = "ProxyDocLitWrappedPort")
+    public DocLitWrappedProxy getProxyDocLitWrappedPort() {
+        return (DocLitWrappedProxy)super.getPort(new QName("http://org.apache.axis2.proxy.doclitwrapped", "ProxyDocLitWrappedPort"), DocLitWrappedProxy.class);
+    }
+
+}
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/DocLitWrappedProxyImpl.java
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/DocLitWrappedProxyImpl.java	(revision 0)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/proxy/doclitwrapped/DocLitWrappedProxyImpl.java	(revision 0)
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.proxy.doclitwrapped;
+
+import javax.xml.ws.Provider;
+
+
+public class DocLitWrappedProxyImpl implements Provider<String> {
+
+	public String invoke(String invoke_str) {
+		// TODO Auto-generated method stub
+		System.out.println("End point called with String value =" + invoke_str);
+		return new String("<ns2:ReturnType xmlns:ns2=\"http://org.apache.axis2.proxy.doclitwrapped\"><return_str>some response</return_str></ns2:ReturnType>");
+	}
+}
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java	(revision 423526)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test/org/apache/axis2/jaxws/framework/JAXWSTest.java	(working copy)
@@ -31,6 +31,7 @@
 import org.apache.axis2.jaxws.message.SAAJConverterTests;
 import org.apache.axis2.jaxws.message.XMLStreamReaderSplitterTests;
 import org.apache.axis2.jaxws.provider.*;
+import org.apache.axis2.proxy.ProxyTests;
 
 public class JAXWSTest extends TestCase {
     /**
@@ -57,6 +58,7 @@
         
         suite.addTestSuite(StringProviderTests.class);
         suite.addTestSuite(SourceProviderTests.class);
+        suite.addTestSuite(ProxyTests.class);
 
         // Start (and stop) the server only once for all the tests
         TestSetup testSetup = new TestSetup(suite) {
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/maven.xml
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/maven.xml	(revision 423526)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/maven.xml	(working copy)
@@ -25,6 +25,7 @@
         <j:set var="compiled.classes.dir" value="target/test-classes"/>
         <!-- Theres got to be a better way to do this -->
         <j:set var="schema.source.dir" value="test-resources/xsd"/>
+    	<j:set var="wsdl.source.dir" value="test-resources/wsdl"/>
         <j:set var="schema.output.base.dir" value="target/schema"/>
         <j:set var="schema.generated.src.dir" value="${schema.output.base.dir}/src"/>
         <j:set var="schema.generated.classes.dir" value="${schema.output.base.dir}/classes"/>
@@ -56,9 +57,14 @@
         	<classpath location="${compiled.classes.dir}"/>
             <arg line="-d ${schema.generated.src.dir} -quiet ${schema.source.dir}/stock2.xsd"/>
         </java>
+    	<ant:echo>Generating java from ProxyDocLitWrapped.wsdl</ant:echo>
+    	<java classname="com.sun.tools.xjc.Driver" fork="true"> 
+    		<jvmarg line="${maven.junit.jvmargs}"/>
+    	    <classpath refid="maven.dependency.classpath"/>
+    	    <classpath location="${compiled.classes.dir}"/>
+    	    <arg line="-d ${schema.generated.src.dir} -p org.test.proxy.doclitwrapped -quiet -wsdl ${wsdl.source.dir}/ProxyDocLitWrapped.wsdl"/>
+    	</java>
     	
-
-    	
        <!-- Compile the generated classes -->
     	<ant:echo>Compiling generated schema</ant:echo>
         <javac destdir="${schema.generated.classes.dir}" srcdir="${schema.generated.src.dir}">
@@ -105,6 +111,20 @@
                 <ant:include name="org/apache/axis2/jaxws/server/**"/>
 			</ant:fileset>
 		</ant:copy>
+        <!-- ================================================================ -->
+        <!--- Proxy endpoint Service Samples -->
+        <!-- ================================================================ -->
+		<ant:copy toDir="target/test-classes/services/ProxyDocLitWrapped/">
+			<ant:fileset dir="target/test-classes">
+				<ant:include name="org/apache/axis2/jaxws/proxy/doclitwrapped/**"/>
+			</ant:fileset>
+			<ant:fileset dir="test/org/apache/axis2/jaxws/proxy/doclitwrapped">
+                <ant:include name="META-INF/**"/>
+			</ant:fileset>
+			<ant:fileset dir="target/classes">
+                <ant:include name="org/apache/axis2/jaxws/server/**"/>
+			</ant:fileset>
+		</ant:copy>
 	</preGoal>
 
     <!-- Create the API and Impl jars --> 
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/ClientMediator.java
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/ClientMediator.java	(revision 423526)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/ClientMediator.java	(working copy)
@@ -32,7 +32,6 @@
 import org.apache.axis2.description.AxisServiceGroup;
 import org.apache.axis2.jaxws.client.JAXBDispatch;
 import org.apache.axis2.jaxws.client.XMLDispatch;
-import org.apache.axis2.jaxws.client.proxy.ProxyHandler;
 import org.apache.axis2.jaxws.handler.PortData;
 import org.apache.axis2.jaxws.spi.ServiceDelegate;
 import org.apache.axis2.jaxws.util.WSDLWrapper;
@@ -98,26 +97,9 @@
 
 	// Add required parameter to this method.
     public <T> T createProxy(JAXWSClientContext<T> clientContext, ServiceDelegate delegate) {
-		//TODO: Have to rewrite this
-		this.clientContext = clientContext;
-		Class<T> sei = clientContext.getClazz();
-		//read port information from JAXWSClientContext and set that.
-		QName portName = null;
+		//proxy is now create from ServiceDelegate.getport
+		return null;
 		
-		try{
-			
-			AxisController axisController = buildAxisController();
-			axisController.setClientContext(clientContext);
-	    	ProxyHandler proxyHandler = new ProxyHandler(axisController, delegate);
-	    	
-	    	Class[] seiClazz = new Class[]{sei, BindingProvider.class};
-	    	Object proxyClass = Proxy.newProxyInstance(sei.getClassLoader(), seiClazz, proxyHandler);
-	    	
-	    	return sei.cast(proxyClass);
-		}catch(AxisFault e){
-    		throw new WebServiceException(e.getMessage());
-    	}
-		
 	}
 
 	private ConfigurationContext getAxisConfigContext() {
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/spi/ServiceDelegate.java
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/spi/ServiceDelegate.java	(revision 423526)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/spi/ServiceDelegate.java	(working copy)
@@ -17,6 +17,7 @@
 
 package org.apache.axis2.jaxws.spi;
 
+import java.lang.reflect.Proxy;
 import java.net.URL;
 import java.util.Hashtable;
 import java.util.Iterator;
@@ -24,9 +25,9 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 
-import javax.wsdl.WSDLException;
 import javax.xml.bind.JAXBContext;
 import javax.xml.namespace.QName;
+import javax.xml.ws.BindingProvider;
 import javax.xml.ws.Dispatch;
 import javax.xml.ws.WebServiceException;
 import javax.xml.ws.Service.Mode;
@@ -34,16 +35,23 @@
 import javax.xml.ws.http.HTTPBinding;
 import javax.xml.ws.soap.SOAPBinding;
 
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.client.ServiceClient;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.jaxws.ClientConfigurationFactory;
 import org.apache.axis2.jaxws.ClientMediator;
 import org.apache.axis2.jaxws.JAXWSClientContext;
 import org.apache.axis2.jaxws.client.JAXBDispatch;
 import org.apache.axis2.jaxws.client.XMLDispatch;
+import org.apache.axis2.jaxws.client.factory.DescriptorFactory;
+import org.apache.axis2.jaxws.client.factory.ProxyHandlerFactory;
+import org.apache.axis2.jaxws.client.proxy.BaseProxyHandler;
+import org.apache.axis2.jaxws.client.proxy.ProxyDescriptor;
 import org.apache.axis2.jaxws.description.ServiceDescription;
 import org.apache.axis2.jaxws.handler.PortData;
 import org.apache.axis2.jaxws.handler.PortInfoImpl;
-import org.apache.axis2.jaxws.util.WSDL4JWrapper;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
 import org.apache.axis2.jaxws.util.WSDLWrapper;
-import org.apache.commons.logging.LogFactory;
 
 public class ServiceDelegate extends javax.xml.ws.spi.ServiceDelegate {
 	private Executor executor;
@@ -52,7 +60,7 @@
     private ServiceDescription serviceDescription;
     private QName serviceQname;
     private ClientMediator mediator = null;
-
+    private ServiceClient serviceClient = null;
     // If no binding ID is available, use this one
     private static String DEFAULT_BINDING_ID = SOAPBinding.SOAP11HTTP_BINDING;
     
@@ -183,7 +191,7 @@
     }
      
     @Override
-    public <T> T getPort(QName qname, Class<T> sei) throws WebServiceException {
+    public <T> T getPort(QName portName, Class<T> sei) throws WebServiceException {
     	/* TODO Check to see if WSDL Location is provided.
          * if not check WebService annotation's WSDLLocation
          * if both are not provided then throw exception.
@@ -199,20 +207,25 @@
     	/*TODO: if portQname is null then fetch it from annotation. 
     	 * if portQname is provided then add that to the ports table.
     	 */
-    	if(qname!=null){
+    	if(portName!=null){
     		String address = "";
     		if(isValidWSDLLocation()){
-    			address = getWSDLWrapper().getSOAPAddress(serviceQname, qname);
+    			address = getWSDLWrapper().getSOAPAddress(serviceQname, portName);
     		}
-    		if(ports.get(qname)==null){
-    			addPort(qname, null, address);
+    		if(ports.get(portName)==null){
+    			addPort(portName, null, address);
     		}
     	}
-   	
-    	JAXWSClientContext<T> clientContext = createClientContext(ports.get(qname), sei, null);
-    	//Set all the required properties for JAXWSClientContext.
-    	return mediator.createProxy(clientContext, this);
-      
+    	DescriptorFactory df = (DescriptorFactory)FactoryRegistry.getFactory(DescriptorFactory.class);
+    	ProxyDescriptor pd = df.create(sei);
+    	pd.setPort(ports.get(portName));
+    	ProxyHandlerFactory phf =(ProxyHandlerFactory) FactoryRegistry.getFactory(ProxyHandlerFactory.class);
+    	BaseProxyHandler proxyHandler = phf.create(pd, this);
+    	
+    	Class[] seiClazz = new Class[]{sei, BindingProvider.class};
+    	Object proxyClass = Proxy.newProxyInstance(sei.getClassLoader(), seiClazz, proxyHandler);
+    	
+    	return sei.cast(proxyClass);
     }
     
     @Override
@@ -298,4 +311,23 @@
 	        }
         }
     }
+    //TODO We should hang AxisConfiguration from ServiceDescription or something parent to ServiceDescription
+    private ConfigurationContext getAxisConfigContext() {
+    	ClientConfigurationFactory factory = ClientConfigurationFactory.newInstance(); 
+    	ConfigurationContext configCtx = factory.getClientConfigurationContext();
+    	return configCtx;
+    	
+    }
+    //TODO Change when ServiceDescription has was to return ServiceClient or OperationClient
+    public ServiceClient getServiceClient() throws AxisFault {
+    	if(serviceClient == null){
+    		serviceClient = new ServiceClient(getAxisConfigContext(), 
+    				serviceDescription.getAxisService());
+    	}
+    	return serviceClient;
+    	
+    }
+		
+	
+
 }
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/BindingProvider.java
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/BindingProvider.java	(revision 423526)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/BindingProvider.java	(working copy)
@@ -51,4 +51,18 @@
     public Map<String, Object> getResponseContext() {
         return responseContext;
     }
+    
+    protected void initRequestContext(String endPointAddress, String soapAddress, String soapAction){
+    	if (endPointAddress != null && !"".equals(endPointAddress)) {
+			requestContext.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,
+					endPointAddress);
+		} else if (soapAddress != null && !"".equals(soapAddress)) {
+			requestContext.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,
+					soapAddress);
+		}
+		if (soapAction != null && !"".equals(soapAction)) {
+			getRequestContext().put(BindingProvider.SOAPACTION_URI_PROPERTY,
+					soapAction);
+		}
+    }
 }
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/registry/FactoryRegistry.java
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/registry/FactoryRegistry.java	(revision 423526)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/registry/FactoryRegistry.java	(working copy)
@@ -20,6 +20,8 @@
 import java.util.Hashtable;
 import java.util.Map;
 
+import org.apache.axis2.jaxws.client.factory.DescriptorFactory;
+import org.apache.axis2.jaxws.client.factory.ProxyHandlerFactory;
 import org.apache.axis2.jaxws.message.databinding.impl.JAXBBlockFactoryImpl;
 import org.apache.axis2.jaxws.message.databinding.impl.OMBlockFactoryImpl;
 import org.apache.axis2.jaxws.message.databinding.impl.SourceBlockFactoryImpl;
@@ -51,6 +53,8 @@
 		table.put(MessageFactory.class, new MessageFactoryImpl());
 		table.put(XMLPartFactory.class, new XMLPartFactoryImpl());
 		table.put(SAAJConverterFactory.class, new SAAJConverterFactoryImpl());
+		table.put(ProxyHandlerFactory.class, new ProxyHandlerFactory());
+		table.put(DescriptorFactory.class, new DescriptorFactory());
 	}
 	/**
 	 * FactoryRegistry is currently a static singleton
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyHandler.java
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyHandler.java	(revision 423526)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyHandler.java	(working copy)
@@ -1,427 +0,0 @@
-/*
- * Copyright 2004,2005 The Apache Software Foundation.
- * Copyright 2006 International Business Machines Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.axis2.jaxws.client.proxy;
-
-import java.beans.IntrospectionException;
-import java.beans.Introspector;
-import java.beans.PropertyDescriptor;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Hashtable;
-import java.util.Map;
-
-import javax.xml.bind.JAXBContext;
-import javax.xml.bind.JAXBException;
-import javax.xml.bind.annotation.XmlElement;
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.ws.WebServiceException;
-
-import org.apache.axiom.om.OMElement;
-import org.apache.axis2.jaxws.AxisController;
-import org.apache.axis2.jaxws.BindingProvider;
-import org.apache.axis2.jaxws.core.InvocationContext;
-import org.apache.axis2.jaxws.core.InvocationContextFactory;
-import org.apache.axis2.jaxws.core.MessageContext;
-import org.apache.axis2.jaxws.core.controller.AxisInvocationController;
-import org.apache.axis2.jaxws.core.controller.InvocationController;
-import org.apache.axis2.jaxws.message.Block;
-import org.apache.axis2.jaxws.message.MessageException;
-import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
-import org.apache.axis2.jaxws.registry.FactoryRegistry;
-import org.apache.axis2.jaxws.spi.ServiceDelegate;
-import org.apache.axis2.jaxws.util.WSDLWrapper;
-import org.apache.axis2.jaxws.wrapper.JAXBWrapperTool;
-import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
-import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperToolImpl;
-
-
-/**
- * ProxyHandler is the java.lang.reflect.InvocationHandler implementation.
- * When jaxws client calls the method on proxy object that it gets using the getPort
- * ServiceDelegate api, the Invoke method on ProxyHandler is invoked.
- * ProxyHandler uses EndpointInterfaceDescriptor and finds out if 
- * 1) The client call is Document Literal or Rpc Literal
- * 2) The WSDL is wrapped or unWrapped. 
- * 
- * ProxyHandler then reads OperationDescription using Method name called by Client
- * From OperationDescription it does the following 
- * 1) if the wsdl isWrapped() reads RequestWrapper Class and responseWrapperClass
- * 2) then reads the webParams for the Operation.
- * 
- * isWrapped() = true  and DocLiteral then
- * ProxyHandler then uses WrapperTool to create Request that is a Wrapped JAXBObject.
- * Creates JAXBBlock using JAXBBlockFactory
- * Creates MessageContext->Message and sets JAXBBlock to xmlPart as RequestMsgCtx in InvocationContext.
- * Makes call to InvocationController.
- * Reads ResponseMsgCtx ->MessageCtx->Message->XMLPart.
- * Converts that to JAXBlock using JAXBBlockFactory and returns the BO from this JAXBBlock.
- * 
- * isWrapped() != true and DocLiteral;
- * TBD
- * 
- * RPCLiteral 
- * TBD
- * 
- */
-
-public class ProxyHandler extends BindingProvider implements InvocationHandler {
-
-	//TODO remove axisController once InvocationController code is build.
-	private AxisController axisController = null;
-	//Reference to ServiceDelegate instance that was used to create the Proxy
-	private ServiceDelegate delegate = null;
-	private ProxyDescriptor proxyDescriptor = null;
-	public ProxyHandler(AxisController ac, ServiceDelegate delegate) {
-		super();
-		this.axisController = ac;
-		this.delegate = delegate;
-		setRequestContext();
-	}
-	
-	/* (non-Javadoc)
-	 * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
-	 * 
-	 * Invoke method checks to see if BindingProvider method was invoked by client if yes, it uses reflection and invokes the BindingProvider method.
-	 * If SEI method was called then it delegates to InvokeSEIMethod().
-	 */
-	public Object invoke(Object proxy, Method method, Object[] args)
-			throws Throwable {
-		if(!isValidMethodCall(method)){
-			throw new WebServiceException("Invalid Method-"+method.getName()+ " Method not found in javax.xml.ws.BindingProvider or "+axisController.getClientContext().getClazz() );
-		}
-		
-		if(isBindingProviderInvoked(method)){
-			return method.invoke(this, args);
-		}
-		else{
-			return InvokeSEIMethod(method, args);
-		}
-		
-	}
-	
-	/**
-	 * InvokeSEIMethod reads EndpointInterfaceDescription and finds out if the request is document literal or RPC Literal and check to see if the WSDL is 
-	 * wrapped or unWrapped. It then reads OperationDescription using Method and in case of doc/lit wrapped Request:
-	 * 1) creates request message context for doc/lit wrapped Request.
-	 * 2) creates response message context by calling InvocationController with request message context as input.
-	 * 3) create wrapped response and returns it to the client method call.
-	 * 
-	 * In case of doc/lit unWrapped Request:
-	 * TBD
-	 * 
-	 * In case of RPC/Lit wrapped Request:
-	 * TBD
-	 * 
-	 * In case of RPC/Lit unWrapped Request:
-	 * TBD
-	 * 
-	 * @param method - Method called by Client
-	 * @param args - Argument object to the method call
-	 * @return - returns the returnType of the method call.
-	 * @throws ClassNotFoundException
-	 * @throws JAXBWrapperException
-	 * @throws JAXBException
-	 * @throws MessageException
-	 * @throws XMLStreamException
-	 * @throws IllegalAccessException
-	 * @throws IntrospectionException
-	 * @throws NoSuchFieldException
-	 * @throws InvocationTargetException
-	 * 
-	 * 
-	 */
-	private Object InvokeSEIMethod(Method method, Object[] args)throws ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, XMLStreamException, IllegalAccessException,IntrospectionException, NoSuchFieldException, InvocationTargetException{
-		
-		/*TODO:ProxyHandler uses EndpointInterfaceDescriptor and finds out if 
-		 * 1) The client call is Document Literal or Rpc Literal
-		 * 2) The WSDL is wrapped or unWrapped. 
-		 * 
-		 * ProxyHandler then reads OperationDescription using Method name called by Client
-		 * From OperationDescription it does the following 
-		 * 1) if the wsdl isWrapped() reads RequestWrapper Class and responseWrapperClass
-		 * 2) then reads the webParams for the Operation.
-		 */
-		
-		proxyDescriptor = new ProxyDescriptor(method);
-		if(isDocLitWrapped()){
-			MessageContext requestCtx = createDocLitWrappedRequest(method, args);
-			MessageContext responseContext = execute(requestCtx);
-			Object wrappedResponse = createDocLitWrappedResponse(method, responseContext);
-			return wrappedResponse;
-			
-		}
-		return null;
-	}
-	
-	/**
-	 * createDocLitWrappedRequest create request message context. It reads RequestWrapper annotation from OperationDescription and reads the calss name, then reads
-	 * all the webParam annotation on the method and uses JAXBWrapTool to wrap the request as jaxbObject. Create JAXBblock from the jaxbObject and sets OMElement on 
-	 * Request MessageContext, reads Biniding provider properties and set them on request message context and return request message context.
-	 * @param method
-	 * @param objects
-	 * @return
-	 * @throws ClassNotFoundException
-	 * @throws JAXBWrapperException
-	 * @throws JAXBException
-	 * @throws MessageException
-	 * @throws javax.xml.stream.XMLStreamException
-	 */
-	//TODO Refactor this once OperationDescription is implemented.
-	private MessageContext createDocLitWrappedRequest(Method method, Object[] objects)throws ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, javax.xml.stream.XMLStreamException{
-		/*TODO : getOperationDesc from method name
-		 * and call 
-		 * createDocLitWrapperRequest(od, values);
-		 */
-		Class wrapperClazz = proxyDescriptor.getRequestWrapperClass();
-		ArrayList<String> names = proxyDescriptor.getParamNames();
-		String localName = proxyDescriptor.getResponseWrapperLocalName();
-		Map<String, Object> values = getParamValues(names, objects);
-		JAXBWrapperTool wrapTool = new JAXBWrapperToolImpl();
-		
-		//TODO:if(@XmlRootElement) annotation found or defined
-		Object jaxbObject = wrapTool.wrap(wrapperClazz, localName,names, values);
-		//TODO: if (!@XmlRootElement) annotation not found or not defined then can I use JAXBElement?
-		//JAXBElement jaxbObject = wrapTool.wrapAsJAXBElement(wrapperClazz, requestWrapper.localName(),names, values);
-		JAXBContext ctx = JAXBContext.newInstance(new Class[]{wrapperClazz});
-		Block reqBlock = createJAXBBlock(jaxbObject, ctx);
-		MessageContext requestCtx = initializeRequest(reqBlock);
-		return requestCtx;
-		
-	}
-	
-	
-	/**
-	 * invokes Axis engine using methods on InvocationController. Create request Invocation context, instantiates AxisInvocationController and runs invoke.
-	 * @param request
-	 * @return
-	 */
-	private MessageContext execute(MessageContext request){
-		//TODO: How do I get binding information.
-		
-		InvocationContext requestIC = InvocationContextFactory.createInvocationContext(null);
-		requestIC.setRequestMessageContext(request);
-		InvocationController controller = new AxisInvocationController();
-		//FIXME: Fix based on how InvocationContext changes to get ServiceClient.
-		requestIC.setServiceClient(axisController.getServiceClient());
-		
-		//TODO: check if the call is OneWay, Async or Sync
-		InvocationContext responseIC = controller.invoke(requestIC);
-		return responseIC.getResponseMessageContext();
-	}
-
-	
-	/**
-	 * CreateDocLitWrappedResponse creates return result that client expects from the method call. It reads response wrapper annotation then reads OM from the
-	 * response message context and creates JAXBBlock from the OMElement on messageContext. It then reads the webresult annotation to gather the return parameter
-	 * name and creates the result object for it by reading the property object from JAXBBlock's business object using PropertyDescriptor. 
-	 * @param method
-	 * @param response
-	 * @return
-	 * @throws IllegalAccessException
-	 * @throws ClassNotFoundException
-	 * @throws JAXBWrapperException
-	 * @throws JAXBException
-	 * @throws javax.xml.stream.XMLStreamException
-	 * @throws MessageException
-	 * @throws IntrospectionException
-	 * @throws NoSuchFieldException
-	 * @throws InvocationTargetException
-	 */
-//	TODO Refactor this once OperationDescription is implemented.
-	private Object createDocLitWrappedResponse(Method method, MessageContext response)throws IllegalAccessException, ClassNotFoundException, JAXBWrapperException, JAXBException, javax.xml.stream.XMLStreamException, MessageException, IntrospectionException, NoSuchFieldException, InvocationTargetException{
-		Class wrapperClazz = proxyDescriptor.getResponseWrapperClass();
-		String resultName = proxyDescriptor.getWebResultName();
-		JAXBContext ctx = JAXBContext.newInstance(new Class[]{wrapperClazz});
-		//TODO: I should go away from using messageAsOM and see if I can fetch Block from messageContext!!
-		OMElement om = response.getMessageAsOM();
-		Block resBlock = createJAXBBlock(om, ctx);
-		Object bo = resBlock.getBusinessObject(true);
-		return getWebResultObject(wrapperClazz, bo, resultName);
-	}
-	
-	private Block createJAXBBlock(Object jaxbObject, JAXBContext context) throws MessageException{
-		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
-		return factory.createFrom(jaxbObject,context,null);
-		
-	}
-	
-	private Block createJAXBBlock(OMElement om, JAXBContext context)throws javax.xml.stream.XMLStreamException{
-		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
-		return factory.createFrom(om,context,null);
-		
-	}
-
-	//TODO: should I unwrap the bo or use property descriptor?
-	private PropertyDescriptor gerPropertyDescriptor(Class returnClazz, String propertyName)throws IntrospectionException, NoSuchFieldException{
-		PropertyDescriptor[] allPds = Introspector.getBeanInfo(returnClazz).getPropertyDescriptors();
-		Field[] fields = returnClazz.getDeclaredFields();
-		for(PropertyDescriptor pd:allPds){
-			for(Field field:fields){
-				String javaFieldName = field.getName();
-				String pdName = pd.getDisplayName();
-				if(javaFieldName.equals(pdName)){
-					if(javaFieldName.equals(propertyName)){
-						return pd;
-						
-					}else{
-						XmlElement xmlElement =field.getAnnotation(XmlElement.class);
-						if(xmlElement == null){
-							//TODO:What happens if xmlElement not defined.
-							
-						}
-						String xmlName =xmlElement.name();
-						if(xmlName.equals(propertyName)){
-							return pd;
-						}
-						if(xmlName.toLowerCase().equals(propertyName.toLowerCase())){
-							return pd;
-						}
-					}
-				}
-			}
-		}
-		return null;
-	}
-	//TODO: refactor this once PropertyDescriptor is implemented.
-	private Map<String, Object> getParamValues(ArrayList<String> names, Object[] objects){
-		Map<String, Object> values = new Hashtable<String, Object>();
-		int i=0;
-		for(Object obj:objects){
-			values.put(names.get(i++), obj);
-		}
-		return values;
-	}
-	//TODO remove this once OperationDescription is implemented
-	
-	/** 
-	 * reads PropertyDescritpr and invokes  get method on result property and returns the object.
-	 * @param wrapperClazz
-	 * @param businessObject
-	 * @param propertyName
-	 * @return
-	 * @throws NoSuchFieldException
-	 * @throws IntrospectionException
-	 * @throws InvocationTargetException
-	 * @throws IllegalAccessException
-	 */
-	private Object getWebResultObject(Class wrapperClazz, Object businessObject, String propertyName) throws NoSuchFieldException, IntrospectionException,InvocationTargetException, IllegalAccessException{
-		PropertyDescriptor pd = gerPropertyDescriptor(wrapperClazz, propertyName);
-		if(pd == null){
-			//TODO: what happens if pd not found.
-		}
-		Method readMethod = pd.getReadMethod();
-		Object webResult = readMethod.invoke(wrapperClazz.cast(businessObject), null);
-		return webResult;
-	}
-	
-	private MessageContext initializeRequest(Block messageBlock) throws XMLStreamException, MessageException{
-		MessageContext request = new MessageContext();
-		request.setMessageAsOM(messageBlock.getOMElement());
-		request.getProperties().putAll(getRequestContext());
-	
-		return request;
-		
-	}
-
-	private boolean isBindingProviderInvoked(Method method){
-		Class SEIClass = axisController.getClientContext().getClazz();
-		Class methodsClass = method.getDeclaringClass();
-		return (SEIClass == methodsClass)?false:true;
-	}
-	
-	private boolean isDocLitRaw(){
-		/* TODO: if(EndPoinInterfaceDescriptor.clientCall == Doc/literal) && OperationDescriptor.isWrapped() == false){ 
-		 * return true; 
-		 * else
-		 * return false;
-		 */
-		return false;
-	}
-	
-	private boolean isDocLitWrapped(){
-		/* TODO: if(EndPoinInterfaceDescriptor.clientCall == Doc/literal) && OperationDescriptor.isWrapped() == true){ 
-		 * return true; 
-		 * else
-		 * return false;
-		 */
-		return true;
-	}
-	
-	private boolean isRPCLitRaw(){
-		/* TODO: if(EndPoinInterfaceDescriptor.clientCall == RPC/literal) && OperationDescriptor.isWrapped() == false){ 
-		 * return true; 
-		 * else
-		 * return false;
-		 */
-		return false;
-	}
-	
-	private boolean isRPCLitWrapped(){
-		/* TODO: if(EndPoinInterfaceDescriptor.clientCall == RPC/literal) && OperationDescriptor.isWrapped() == true){ 
-		 * return true; 
-		 * else
-		 * return false;
-		 */
-		return false;
-	}
-	private boolean isValidMethodCall(Method method){
-		//TODO: remove reference to axisController
-		Class SEIClass = axisController.getClientContext().getClazz();
-		Class clazz = method.getDeclaringClass();
-		if(clazz == javax.xml.ws.BindingProvider.class || clazz == SEIClass){
-			return true;
-		}
-		return false;
-	}
-	//TODO: remove reference to AxisController.
-	protected void setAxisController(AxisController ac) {
-		this.axisController = ac;
-	}
-	
-	public void setDelegate(ServiceDelegate delegate) {
-		this.delegate = delegate;
-	}
-	
-	protected void setRequestContext() {
-		String endPointAddress = axisController.getEndpointAddress();
-		WSDLWrapper wsdl = delegate.getServiceDescription().getWSDLWrapper();
-		QName serviceName = delegate.getServiceName();
-		QName portName = axisController.getPortName();
-		if (endPointAddress != null && !"".equals(endPointAddress)) {
-			getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,
-					endPointAddress);
-		} else if (wsdl != null) {
-			String soapAddress = wsdl.getSOAPAddress(serviceName, portName);
-			getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,
-					soapAddress);
-		}
-
-		if (wsdl != null) {
-			String soapAction = wsdl.getSOAPAction(serviceName, portName);
-			getRequestContext().put(BindingProvider.SOAPACTION_URI_PROPERTY,
-					soapAction);
-		}
-	}
-	
-	
-
-}
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyDescriptor.java
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyDescriptor.java	(revision 423526)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/ProxyDescriptor.java	(working copy)
@@ -20,11 +20,18 @@
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 
+import javax.jws.SOAPBinding;
 import javax.jws.WebParam;
 import javax.jws.WebResult;
+import javax.jws.SOAPBinding.Style;
 import javax.xml.ws.RequestWrapper;
 import javax.xml.ws.ResponseWrapper;
 
+import org.apache.axis2.jaxws.description.EndpointDescription;
+import org.apache.axis2.jaxws.description.OperationDescription;
+import org.apache.axis2.jaxws.description.ServiceDescription;
+import org.apache.axis2.jaxws.handler.PortData;
+
 /**
  * ProxyDescriptor is instantiated from ProxyHandler using the Method argument. 
  * ProxyDescriptor will provide all the annotation details like RequestWrapper class
@@ -32,20 +39,30 @@
  *
  */
 public class ProxyDescriptor {
-	private Method proxyMethod = null;
+	
+	private Class seiClazz = null;
+	private Method seiMethod = null;
+	private SOAPBinding soapBinding = null;
 	private RequestWrapper requestWrapper= null;
 	private ResponseWrapper responseWrapper= null;
 	private WebParam[] webParam = null;
 	private WebResult webResult = null;
-	
-	public ProxyDescriptor(Method method){
-		this.proxyMethod = method;
+	private PortData port = null;
+	//TODO replace annotation work once serviceDescription is ready
+	private ServiceDescription serviceDescription= null;
+	//TODO replace annotation work once operationDescription is ready
+	private OperationDescription operationDescription= null;
+	//TODO replace annotation work once endpointDescription is ready
+	private EndpointDescription endpointDescription = null;
+
+	public ProxyDescriptor(Class seiClazz){
+		this.seiClazz = seiClazz;
 	}
 	
 	//TODO remove this once OperationDescription is implemented
 	public RequestWrapper getRequestWrapper() {
 		if(requestWrapper == null){
-			requestWrapper = proxyMethod.getAnnotation(RequestWrapper.class);
+			requestWrapper = seiMethod.getAnnotation(RequestWrapper.class);
 		}
 		return requestWrapper;
 	}
@@ -53,7 +70,7 @@
 	//TODO remove this once OperationDescription is implemented
 	public ResponseWrapper getResponseWrapper() {
 		if(responseWrapper == null){
-			responseWrapper = proxyMethod.getAnnotation(ResponseWrapper.class);
+			responseWrapper = seiMethod.getAnnotation(ResponseWrapper.class);
 		}
 		return responseWrapper;
 	}
@@ -61,7 +78,7 @@
 	//TODO remove this once OperationDescription is implemented
 	public WebParam[] getWebParam() {
 		if(webParam == null){
-			Annotation[][] paramAnnotation = proxyMethod.getParameterAnnotations();
+			Annotation[][] paramAnnotation = seiMethod.getParameterAnnotations();
 			ArrayList<WebParam> webParamList = new ArrayList<WebParam>();
 			for(Annotation[] pa:paramAnnotation){
 				for(Annotation webParam:pa){
@@ -80,34 +97,55 @@
 	//TODO remove this once OperationDescription is implemented
 	public WebResult getWebResult(){
 		if(webResult == null){
-			webResult = proxyMethod.getAnnotation(WebResult.class);
+			webResult = seiMethod.getAnnotation(WebResult.class);
 		}
 		return webResult;
 	}
 	
 	//TODO: refactor this once PropertyDescriptor is implemented.
 	public Class getRequestWrapperClass() throws ClassNotFoundException{
+		if(getRequestWrapper() == null){
+			return null;
+		}
 		return Class.forName(getRequestWrapper().className(), true, ClassLoader.getSystemClassLoader());
 	}
 	
 	public String getRequestWrapperClassName(){
+		if(getRequestWrapper()== null){
+			return null;
+		}
 		return getRequestWrapper().className();
 	}
 	public String getRequestWrapperLocalName(){
+		if(getRequestWrapper() == null){
+			return null;
+		}
 		return getRequestWrapper().localName();
 	}
 	//TODO remove this once OperationDescription is implemented
 	public Class getResponseWrapperClass() throws ClassNotFoundException{
+		if(getResponseWrapper() == null){
+			return null;
+		}
 		return Class.forName(getResponseWrapper().className(), true, ClassLoader.getSystemClassLoader());
 	}
 	public String getResponseWrapperClassName(){
+		if(getResponseWrapper()==null){
+			return null;
+		}
 		return getResponseWrapper().className();
 	}
 	public String getResponseWrapperLocalName(){
+		if(getResponseWrapper()==null){
+			return null;
+		}
 		return getResponseWrapper().localName();
 	}
 	//TODO remove this once OperationDescription is implemented
 	public String getWebResultName(){
+		if(getWebResult()==null){
+			return null;
+		}
 		return getWebResult().name();
 	}
 	
@@ -120,4 +158,36 @@
 		}
 		return names;
 	}
+	public PortData getPort() {
+		return port;
+	}
+	public void setPort(PortData port) {
+		this.port = port;
+	}
+	public Method getSeiMethod() {
+		return seiMethod;
+	}
+	public void setSeiMethod(Method seiMethod) {
+		this.seiMethod = seiMethod;
+	}
+	public SOAPBinding getSoapBinding(){
+		if(soapBinding == null){
+			soapBinding = (SOAPBinding)seiClazz.getAnnotation(SOAPBinding.class);
+		}
+		return soapBinding;
+	}
+	public Style getBindingStyle(){
+		if(getSoapBinding()== null){
+			return SOAPBinding.Style.DOCUMENT;
+		}
+		return getSoapBinding().style(); 
+	}
+
+	public Class getSeiClazz() {
+		return seiClazz;
+	}
+
+	public void setSeiClazz(Class seiClazz) {
+		this.seiClazz = seiClazz;
+	}
 }
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/BaseProxyHandler.java
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/BaseProxyHandler.java	(revision 0)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/BaseProxyHandler.java	(revision 0)
@@ -0,0 +1,197 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.client.proxy;
+
+import java.beans.IntrospectionException;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import javax.xml.bind.JAXBException;
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.ws.WebServiceException;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.jaxws.AxisController;
+import org.apache.axis2.jaxws.BindingProvider;
+import org.apache.axis2.jaxws.core.InvocationContext;
+import org.apache.axis2.jaxws.core.InvocationContextFactory;
+import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.core.controller.AxisInvocationController;
+import org.apache.axis2.jaxws.core.controller.InvocationController;
+import org.apache.axis2.jaxws.message.MessageException;
+import org.apache.axis2.jaxws.spi.ServiceDelegate;
+import org.apache.axis2.jaxws.util.WSDLWrapper;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * ProxyHandler is the java.lang.reflect.InvocationHandler implementation.
+ * When jaxws client calls the method on proxy object that it gets using the getPort
+ * ServiceDelegate api, the Inovke method on ProxyHandler is Invoked.
+ * ProxyHandler uses EndpointInterfaceDescriptor and finds out if 
+ * 1) The client call is Document Literal or Rpc Literal
+ * 2) The WSDL is wrapped or unWrapped. 
+ * 
+ * ProxyHandler then reads OperationDescription using Method name called by Client
+ * From OperationDescription it does the following 
+ * 1) if the wsdl isWrapped() reads RequestWrapper Class and responseWrapperClass
+ * 2) then reads the webParams for the Operation.
+ * 
+ * isWrapped() = true  and DocLiteral then
+ * ProxyHandler then uses WrapperTool to create Request that is a Wrapped JAXBObject.
+ * Creates JAXBBlock using JAXBBlockFactory
+ * Creates MessageContext->Message and sets JAXBBlock to xmlPart as RequestMsgCtx in InvocationContext.
+ * Makes call to InvocationController.
+ * Reads ResponseMsgCtx ->MessageCtx->Message->XMLPart.
+ * Converts that to JAXBlock using JAXBBlockFactory and returns the BO from this JAXBBlock.
+ * 
+ * isWrapped() != true and DocLiteral;
+ * TBD
+ * 
+ * RPCLiteral 
+ * TBD
+ * 
+ */
+
+public abstract class BaseProxyHandler extends BindingProvider implements
+		InvocationHandler {
+	private static Log log = LogFactory.getLog(BaseProxyHandler.class);
+//	TODO remove axisController once InvocationController code is build.
+	private AxisController axisController = null;
+	//Reference to ServiceDelegate instance that was used to create the Proxy
+	private ServiceDelegate delegate = null;
+	protected ProxyDescriptor proxyDescriptor = null;
+	
+	public BaseProxyHandler(ProxyDescriptor pd, ServiceDelegate delegate) {
+		super();
+		this.proxyDescriptor = pd;
+		this.delegate = delegate;
+		initRequestContext();
+	}
+	
+	/* (non-Javadoc)
+	 * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
+	 * 
+	 * Invoke method checks to see if BindingProvider method was invoked by client if yes, it uses reflection and invokes the BindingProvider method.
+	 * If SEI method was called then it delegates to InvokeSEIMethod().
+	 */
+	public Object invoke(Object proxy, Method method, Object[] args)
+			throws Throwable {
+		if (log.isDebugEnabled()) {
+            log.debug("Attemping to invoke Method: " +method.getName());
+        }
+		if(!isValidMethodCall(method)){
+			throw new WebServiceException("Invalid Method-"+method.getName()+ " Method not found in javax.xml.ws.BindingProvider or "+axisController.getClientContext().getClazz() );
+		}
+		
+		if(isBindingProviderInvoked(method)){
+			if (log.isDebugEnabled()) {
+	            log.debug("Invoking method on Binding Provider");
+	        }
+			return method.invoke(this, args);
+			
+		}
+		else{
+			proxyDescriptor.setSeiMethod(method);
+			return InvokeSEIMethod(method, args);
+		}
+	}
+	
+	/**
+	 * InvokeSEIMethod invokes Axis engine using methods on InvocationController. Create request Invocation context, instantiates AxisInvocationController and 
+	 * runs invoke.
+	 * 
+	 */
+	private Object InvokeSEIMethod(Method method, Object[] args)throws ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, XMLStreamException, IllegalAccessException,IntrospectionException, NoSuchFieldException, InvocationTargetException{
+		if (log.isDebugEnabled()) {
+            log.debug("Attempting to Invoke SEI Method "+ method.getName());
+        }
+		InvocationContext requestIC = InvocationContextFactory.createInvocationContext(null);
+		MessageContext requestContext = createRequest(method, args);
+		requestIC.setRequestMessageContext(requestContext);
+		InvocationController controller = new AxisInvocationController();
+		//FIXME: Fix based on how InvocationContext changes to get ServiceClient.
+		try{
+			requestIC.setServiceClient(delegate.getServiceClient());
+		}catch(AxisFault e){
+			throw new WebServiceException(e);
+		}
+		//TODO: check if the call is OneWay, Async or Sync
+		InvocationContext responseIC = controller.invoke(requestIC);
+		MessageContext responseContext = responseIC.getResponseMessageContext();
+		Object responseObj = createResponse(method, responseContext);
+		
+		return responseObj;
+	}
+	
+	/**
+	 * Create request context for the method call. This request context will be used by InvocationController to route the method call to axis engine.
+	 * @param method
+	 * @param args
+	 * @return
+	 */
+	protected abstract MessageContext createRequest(Method method, Object[] args) throws ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, javax.xml.stream.XMLStreamException;
+	
+	/**
+	 * Creates response context for the method call. This response context will be used to create response result to the client call.
+	 * @param method
+	 * @param responseContext
+	 * @return
+	 */
+	protected abstract Object createResponse(Method method, MessageContext responseContext)throws IllegalAccessException, ClassNotFoundException, JAXBWrapperException, JAXBException, javax.xml.stream.XMLStreamException, MessageException, IntrospectionException, NoSuchFieldException, InvocationTargetException;
+	
+	private boolean isBindingProviderInvoked(Method method){
+		Class SEIClass = proxyDescriptor.getSeiClazz();
+		Class methodsClass = method.getDeclaringClass();
+		return (SEIClass == methodsClass)?false:true;
+	}
+	
+	private boolean isValidMethodCall(Method method){
+		Class SEIClass = proxyDescriptor.getSeiClazz();
+		Class clazz = method.getDeclaringClass();
+		if(clazz == javax.xml.ws.BindingProvider.class || clazz == SEIClass){
+			return true;
+		}
+		return false;
+	}
+	//TODO: remove reference to AxisController.
+	protected void setAxisController(AxisController ac) {
+		this.axisController = ac;
+	}
+	
+	public void setDelegate(ServiceDelegate delegate) {
+		this.delegate = delegate;
+	}
+	
+	protected void initRequestContext() {
+		String soapAddress = null;
+		String soapAction = null;
+		String endPointAddress = proxyDescriptor.getPort().getEndpointAddress();
+		WSDLWrapper wsdl = delegate.getServiceDescription().getWSDLWrapper();
+		QName serviceName = delegate.getServiceName();
+		QName portName = proxyDescriptor.getPort().getPortName();
+		if (wsdl != null) {
+			soapAddress = wsdl.getSOAPAddress(serviceName, portName);
+			soapAction = wsdl.getSOAPAction(serviceName, portName);
+		}
+		super.initRequestContext(endPointAddress, soapAddress, soapAction);
+	}
+
+}
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/RPCLitProxyHandler.java
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/RPCLitProxyHandler.java	(revision 0)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/RPCLitProxyHandler.java	(revision 0)
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.client.proxy;
+
+import java.lang.reflect.Method;
+
+import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.core.controller.AxisInvocationController;
+import org.apache.axis2.jaxws.spi.ServiceDelegate;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+
+public class RPCLitProxyHandler extends BaseProxyHandler {
+	private static Log log = LogFactory.getLog(RPCLitProxyHandler.class);
+
+	/**
+	 * @param pd
+	 * @param delegate
+	 */
+	public RPCLitProxyHandler(ProxyDescriptor pd, ServiceDelegate delegate) {
+		super(pd, delegate);
+		// TODO Auto-generated constructor stub
+	}
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.client.proxy.BaseProxyHandler#createRequest(java.lang.reflect.Method, java.lang.Object)
+	 */
+	@Override
+	protected MessageContext createRequest(Method method, Object[] args) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.apache.axis2.jaxws.client.proxy.BaseProxyHandler#createResponse(java.lang.reflect.Method, org.apache.axis2.jaxws.core.MessageContext)
+	 */
+	@Override
+	protected Object createResponse(Method method,
+			MessageContext responseContext) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+}
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/DocLitProxyHandler.java
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/DocLitProxyHandler.java	(revision 0)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/src/org/apache/axis2/jaxws/client/proxy/DocLitProxyHandler.java	(revision 0)
@@ -0,0 +1,242 @@
+/*
+ * Copyright 2004,2005 The Apache Software Foundation.
+ * Copyright 2006 International Business Machines Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.axis2.jaxws.client.proxy;
+
+import java.beans.IntrospectionException;
+import java.beans.Introspector;
+import java.beans.PropertyDescriptor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Hashtable;
+import java.util.Map;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.core.controller.AxisInvocationController;
+import org.apache.axis2.jaxws.message.Block;
+import org.apache.axis2.jaxws.message.MessageException;
+import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
+import org.apache.axis2.jaxws.spi.ServiceDelegate;
+import org.apache.axis2.jaxws.wrapper.JAXBWrapperTool;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperException;
+import org.apache.axis2.jaxws.wrapper.impl.JAXBWrapperToolImpl;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+
+public class DocLitProxyHandler extends BaseProxyHandler {
+	private static Log log = LogFactory.getLog(DocLitProxyHandler.class);
+	/**
+	 * @param pd
+	 * @param delegate
+	 */
+	public DocLitProxyHandler(ProxyDescriptor pd, ServiceDelegate delegate) {
+		super(pd, delegate);
+	}
+
+	@Override
+	protected MessageContext createRequest(Method method, Object[] args) throws ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, javax.xml.stream.XMLStreamException {
+		MessageContext requestCtx = null;
+		if(isDocLitWrapped()){
+			requestCtx = createDocLitWrappedRequest(method, args);
+		}
+		return requestCtx;
+	}
+
+	@Override
+	protected Object createResponse(Method method, MessageContext responseContext) throws IllegalAccessException, ClassNotFoundException, JAXBWrapperException, JAXBException, javax.xml.stream.XMLStreamException, MessageException, IntrospectionException, NoSuchFieldException, InvocationTargetException{
+		Object result = null;
+		if(isDocLitWrapped()){
+			 result = createDocLitWrappedResponse(method, responseContext);
+		}
+		return result;
+	}
+
+	/**
+	 * createDocLitWrappedRequest create request message context. It reads RequestWrapper annotation from OperationDescription and reads the calss name, then reads
+	 * all the webParam annotation on the method and uses JAXBWrapTool to wrap the request as jaxbObject. Create JAXBblock from the jaxbObject and sets OMElement on 
+	 * Request MessageContext, reads Biniding provider properties and set them on request message context and return request message context.
+	 * @param method
+	 * @param objects
+	 * @return
+	 * @throws ClassNotFoundException
+	 * @throws JAXBWrapperException
+	 * @throws JAXBException
+	 * @throws MessageException
+	 * @throws javax.xml.stream.XMLStreamException
+	 */
+	//TODO Refactor this once OperationDescription is implemented.
+	private MessageContext createDocLitWrappedRequest(Method method, Object[] objects)throws ClassNotFoundException, JAXBWrapperException, JAXBException, MessageException, javax.xml.stream.XMLStreamException{
+		/*TODO : getOperationDesc from method name
+		 * and call 
+		 * createDocLitWrapperRequest(od, values);
+		 */
+		Class wrapperClazz = proxyDescriptor.getRequestWrapperClass();
+		ArrayList<String> names = proxyDescriptor.getParamNames();
+		String localName = proxyDescriptor.getResponseWrapperLocalName();
+		Map<String, Object> values = getParamValues(names, objects);
+		JAXBWrapperTool wrapTool = new JAXBWrapperToolImpl();
+		
+		//TODO:if(@XmlRootElement) annotation found or defined
+		Object jaxbObject = wrapTool.wrap(wrapperClazz, localName,names, values);
+		//TODO: if (!@XmlRootElement) annotation not found or not defined then can I use JAXBElement?
+		//JAXBElement jaxbObject = wrapTool.wrapAsJAXBElement(wrapperClazz, requestWrapper.localName(),names, values);
+		JAXBContext ctx = JAXBContext.newInstance(new Class[]{wrapperClazz});
+		Block reqBlock = createJAXBBlock(jaxbObject, ctx);
+		MessageContext requestCtx = initializeRequest(reqBlock);
+		return requestCtx;
+		
+	}
+	/**
+	 * CreateDocLitWrappedResponse creates return result that client expects from the method call. It reads response wrapper annotation then reads OM from the
+	 * response message context and creates JAXBBlock from the OMElement on messageContext. It then reads the webresult annotation to gather the return parameter
+	 * name and creates the result object for it by reading the property object from JAXBBlock's business object using PropertyDescriptor. 
+	 * @param method
+	 * @param response
+	 * @return
+	 * @throws IllegalAccessException
+	 * @throws ClassNotFoundException
+	 * @throws JAXBWrapperException
+	 * @throws JAXBException
+	 * @throws javax.xml.stream.XMLStreamException
+	 * @throws MessageException
+	 * @throws IntrospectionException
+	 * @throws NoSuchFieldException
+	 * @throws InvocationTargetException
+	 */
+//	TODO Refactor this once OperationDescription is implemented.
+	private Object createDocLitWrappedResponse(Method method, MessageContext response)throws IllegalAccessException, ClassNotFoundException, JAXBWrapperException, JAXBException, javax.xml.stream.XMLStreamException, MessageException, IntrospectionException, NoSuchFieldException, InvocationTargetException{
+		Class wrapperClazz = proxyDescriptor.getResponseWrapperClass();
+		String resultName = proxyDescriptor.getWebResultName();
+		JAXBContext ctx = JAXBContext.newInstance(new Class[]{wrapperClazz});
+		//TODO: I should go away from using messageAsOM and see if I can fetch Block from messageContext!!
+		OMElement om = response.getMessageAsOM();
+		Block resBlock = createJAXBBlock(om, ctx);
+		Object bo = resBlock.getBusinessObject(true);
+		return getWebResultObject(wrapperClazz, bo, resultName);
+	}
+	
+	private Block createJAXBBlock(Object jaxbObject, JAXBContext context) throws MessageException{
+		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
+		return factory.createFrom(jaxbObject,context,null);
+		
+	}
+	
+	private Block createJAXBBlock(OMElement om, JAXBContext context)throws javax.xml.stream.XMLStreamException{
+		JAXBBlockFactory factory = (JAXBBlockFactory)FactoryRegistry.getFactory(JAXBBlockFactory.class);
+		return factory.createFrom(om,context,null);
+		
+	}
+
+	//TODO: should I unwrap the bo or use property descriptor?
+	private PropertyDescriptor gerPropertyDescriptor(Class returnClazz, String propertyName)throws IntrospectionException, NoSuchFieldException{
+		PropertyDescriptor[] allPds = Introspector.getBeanInfo(returnClazz).getPropertyDescriptors();
+		Field[] fields = returnClazz.getDeclaredFields();
+		for(PropertyDescriptor pd:allPds){
+			for(Field field:fields){
+				String javaFieldName = field.getName();
+				String pdName = pd.getDisplayName();
+				if(javaFieldName.equals(pdName)){
+					if(javaFieldName.equals(propertyName)){
+						return pd;
+						
+					}else{
+						XmlElement xmlElement =field.getAnnotation(XmlElement.class);
+						if(xmlElement == null){
+							//TODO:What happens if xmlElement not defined.
+							
+						}
+						String xmlName =xmlElement.name();
+						if(xmlName.equals(propertyName)){
+							return pd;
+						}
+						if(xmlName.toLowerCase().equals(propertyName.toLowerCase())){
+							return pd;
+						}
+					}
+				}
+			}
+		}
+		return null;
+	}
+	//TODO: refactor this once PropertyDescriptor is implemented.
+	private Map<String, Object> getParamValues(ArrayList<String> names, Object[] objects){
+		Map<String, Object> values = new Hashtable<String, Object>();
+		int i=0;
+		for(Object obj:objects){
+			values.put(names.get(i++), obj);
+		}
+		return values;
+	}
+	//TODO remove this once OperationDescription is implemented
+	
+	/** 
+	 * reads PropertyDescritpr and invokes  get method on result property and returns the object.
+	 * @param wrapperClazz
+	 * @param businessObject
+	 * @param propertyName
+	 * @return
+	 * @throws NoSuchFieldException
+	 * @throws IntrospectionException
+	 * @throws InvocationTargetException
+	 * @throws IllegalAccessException
+	 */
+	private Object getWebResultObject(Class wrapperClazz, Object businessObject, String propertyName) throws NoSuchFieldException, IntrospectionException,InvocationTargetException, IllegalAccessException{
+		PropertyDescriptor pd = gerPropertyDescriptor(wrapperClazz, propertyName);
+		if(pd == null){
+			//TODO: what happens if pd not found.
+		}
+		Method readMethod = pd.getReadMethod();
+		Object webResult = readMethod.invoke(wrapperClazz.cast(businessObject), null);
+		return webResult;
+	}
+	
+	private MessageContext initializeRequest(Block messageBlock) throws XMLStreamException, MessageException{
+		MessageContext request = new MessageContext();
+		request.setMessageAsOM(messageBlock.getOMElement());
+		request.getProperties().putAll(getRequestContext());
+	
+		return request;
+		
+	}
+	
+	private boolean isDocLitRaw(){
+		/* TODO: if(EndPoinInterfaceDescriptor.clientCall == Doc/literal) && OperationDescriptor.isWrapped() == false){ 
+		 * return true; 
+		 * else
+		 * return false;
+		 */
+		return false;
+	}
+	
+	private boolean isDocLitWrapped(){
+		/* TODO: if(EndPoinInterfaceDescriptor.clientCall == Doc/literal) && OperationDescriptor.isWrapped() == true){ 
+		 * return true; 
+		 * else
+		 * return false;
+		 */
+		return true;
+	}
+}
Index: C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test-resources/wsdl/ProxyDocLitWrapped.wsdl
===================================================================
--- C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test-resources/wsdl/ProxyDocLitWrapped.wsdl	(revision 0)
+++ C:/eclipse_312/cs/workspace/axis2_live/modules/jaxws/test-resources/wsdl/ProxyDocLitWrapped.wsdl	(revision 0)
@@ -0,0 +1,282 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
+	xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
+	xmlns:tns="http://org.apache.axis2.proxy.doclitwrapped"
+	xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="proxy"
+	targetNamespace="http://org.apache.axis2.proxy.doclitwrapped">
+
+	<wsdl:types>
+		<xsd:schema
+			targetNamespace="http://org.apache.axis2.proxy.doclitwrapped"
+			xmlns:tns="http://org.apache.axis2.proxy.doclitwrapped"
+			xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+
+			<xsd:element name="MyFault" type="xsd:string" />
+
+			<xsd:element name="oneWayVoid">
+				<xsd:complexType>
+					<xsd:sequence />
+				</xsd:complexType>
+			</xsd:element>
+
+			<xsd:element name="oneWay">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="oneway_str"
+							type="xsd:string" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+
+			<xsd:element name="twoWayHolder">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="twoWayHolder_str"
+							type="xsd:string" />
+						<xsd:element name="twoWayHolder_int"
+							type="xsd:int" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+
+			<xsd:element name="twoWay">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="twoway_str"
+							type="xsd:string" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+			
+			<xsd:element name="ReturnType">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="return_str"
+							type="xsd:string" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+
+			<xsd:element name="invoke">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="invoke_str"
+							type="xsd:string" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+
+			<xsd:element name="invokeReturnType">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="return_str"
+							type="xsd:string" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+
+
+			
+
+			<!-- fin op definition -->
+
+			<xsd:element name="finOp">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="op"
+							type="tns:FinancialOperation" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+
+			<xsd:element name="finOpResponse">
+				<xsd:complexType>
+					<xsd:sequence>
+						<xsd:element name="response"
+							type="tns:FinancialOperation" />
+					</xsd:sequence>
+				</xsd:complexType>
+			</xsd:element>
+
+			<xsd:complexType name="FinancialOperation">
+				<xsd:sequence>
+					<xsd:element name="amount" type="xsd:float" />
+				</xsd:sequence>
+			</xsd:complexType>
+
+			<xsd:complexType name="Withdraw">
+				<xsd:complexContent>
+					<xsd:extension base="tns:FinancialOperation">
+						<xsd:sequence>
+							<xsd:element name="memo" type="xsd:string" />
+						</xsd:sequence>
+					</xsd:extension>
+				</xsd:complexContent>
+			</xsd:complexType>
+
+			<xsd:complexType name="Deposit">
+				<xsd:complexContent>
+					<xsd:extension base="tns:FinancialOperation">
+						<xsd:sequence>
+							<xsd:element name="status"
+								type="xsd:string" />
+						</xsd:sequence>
+					</xsd:extension>
+				</xsd:complexContent>
+			</xsd:complexType>
+
+		</xsd:schema>
+	</wsdl:types>
+
+	<wsdl:message name="oneWayVoidRequest">
+		<wsdl:part name="allByMyself" element="tns:oneWayVoid" />
+	</wsdl:message>
+
+	<wsdl:message name="oneWayRequest">
+		<wsdl:part name="allByMyself" element="tns:oneWay" />
+	</wsdl:message>
+
+	<wsdl:message name="twoWayHolderRequest">
+		<wsdl:part name="allByMyself" element="tns:twoWayHolder" />
+	</wsdl:message>
+
+	<wsdl:message name="twoWayHolderResponse">
+		<wsdl:part name="allByMyself" element="tns:twoWayHolder" />
+	</wsdl:message>
+
+	<wsdl:message name="twoWayRequest">
+		<wsdl:part name="allByMyself" element="tns:twoWay" />
+	</wsdl:message>
+
+	<wsdl:message name="twoWayResponse">
+		<wsdl:part name="allByMyself" element="tns:ReturnType" />
+	</wsdl:message>
+
+	<wsdl:message name="invokeRequest">
+		<wsdl:part name="allByMyself" element="tns:invoke" />
+	</wsdl:message>
+
+	<wsdl:message name="invokeResponse">
+		<wsdl:part name="allByMyself" element="tns:ReturnType" />
+	</wsdl:message>
+
+	<wsdl:message name="finOpRequest">
+		<wsdl:part name="op" element="tns:finOp" />
+	</wsdl:message>
+
+	<wsdl:message name="finOpResponse">
+		<wsdl:part name="op" element="tns:finOpResponse" />
+	</wsdl:message>
+
+	<wsdl:portType name="DocLitWrappedProxy">
+
+		<wsdl:operation name="oneWayVoid">
+			<wsdl:input message="tns:oneWayVoidRequest" />
+		</wsdl:operation>
+
+		<wsdl:operation name="oneWay">
+			<wsdl:input message="tns:oneWayRequest" />
+		</wsdl:operation>
+
+		<wsdl:operation name="twoWayHolder">
+			<wsdl:input message="tns:twoWayHolderRequest" />
+			<wsdl:output message="tns:twoWayHolderResponse" />
+		</wsdl:operation>
+
+		<wsdl:operation name="twoWay">
+			<wsdl:input message="tns:twoWayRequest" />
+			<wsdl:output message="tns:twoWayResponse" />
+		</wsdl:operation>
+		
+		<wsdl:operation name="invoke">
+			<wsdl:input message="tns:invokeRequest" />
+			<wsdl:output message="tns:invokeResponse" />
+		</wsdl:operation>
+		
+		<wsdl:operation name="finOp">
+			<wsdl:input message="tns:finOpRequest" />
+			<wsdl:output message="tns:finOpResponse" />
+		</wsdl:operation>
+
+	</wsdl:portType>
+
+	<wsdl:binding name="ProxyDocLitWrapped"
+		type="tns:DocLitWrappedProxy">
+		<soap:binding style="document"
+			transport="http://schemas.xmlsoap.org/soap/http" />
+
+		<wsdl:operation name="oneWayVoid">
+			<soap:operation
+				soapAction="http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn" />
+			<wsdl:input>
+				<soap:body use="literal" />
+			</wsdl:input>
+		</wsdl:operation>
+
+		<wsdl:operation name="oneWay">
+			<soap:operation
+				soapAction="http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn" />
+			<wsdl:input>
+				<soap:body use="literal" />
+			</wsdl:input>
+		</wsdl:operation>
+
+		<wsdl:operation name="twoWayHolder">
+			<soap:operation
+				soapAction="http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn" />
+			<wsdl:input>
+				<soap:body use="literal" />
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal" />
+			</wsdl:output>
+
+		</wsdl:operation>
+
+		<wsdl:operation name="twoWay">
+			<soap:operation
+				soapAction="http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn" />
+			<wsdl:input>
+				<soap:body use="literal" />
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal" />
+			</wsdl:output>
+
+		</wsdl:operation>
+		
+		<wsdl:operation name="invoke">
+			<soap:operation
+				soapAction="http://org.apache.axis2.proxy.doclitwrapped/twoWayReturn" />
+			<wsdl:input>
+				<soap:body use="literal" />
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal" />
+			</wsdl:output>
+
+		</wsdl:operation>
+		
+		<wsdl:operation name="finOp">
+			<soap:operation
+				soapAction="http://org.apache.axis2.proxy.doclitwrapped/finOp" />
+			<wsdl:input>
+				<soap:body use="literal" />
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal" />
+			</wsdl:output>
+
+		</wsdl:operation>
+
+	</wsdl:binding>
+
+	<wsdl:service name="ProxyDocLitWrappedService">
+		<wsdl:port binding="tns:ProxyDocLitWrapped"
+			name="ProxyDocLitWrappedPort">
+			<soap:address
+				location="http://localhost:9080/axis2/services/ProxyDocLitWrappedService/invoke" />
+		</wsdl:port>
+	</wsdl:service>
+
+</wsdl:definitions>
\ No newline at end of file
