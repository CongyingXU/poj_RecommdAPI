Index: modules/adb-codegen/src/org/apache/axis2/schema/BeanWriterMetaInfoHolder.java
===================================================================
--- modules/adb-codegen/src/org/apache/axis2/schema/BeanWriterMetaInfoHolder.java	(revision 413981)
+++ modules/adb-codegen/src/org/apache/axis2/schema/BeanWriterMetaInfoHolder.java	(working copy)
@@ -39,7 +39,9 @@
     protected boolean choice = false;
 
     protected boolean extension = false;
+    protected boolean restriction = false;
     private String extensionClassName = "";
+    private String restrictionClassName = "";
     protected Map elementToSchemaQNameMap = new LinkedHashMap();
     protected Map elementToJavaClassMap = new LinkedHashMap();
     protected Map specialTypeFlagMap = new LinkedHashMap();
@@ -119,8 +121,6 @@
         return extension;
     }
 
-
-
     /**
      * Sets the extension status.
      *
@@ -129,6 +129,44 @@
     public void setExtension(boolean extension) {
         this.extension = extension;
     }
+    
+    /**
+     * Sets the restriction base class name. Valid only when the isRestriction
+     * returns true.
+     *
+     * @return Returns String.
+     */
+    public String getRestrictionClassName() {
+        return restrictionClassName;
+    }
+    
+    /**
+     * Sets the restriction base class name. Valid only when the isRestriction
+     * returns true.
+     *
+     * @param restrictionClassName
+     */
+    public void setRestrictionClassName(String restrictionClassName) {
+        this.restrictionClassName = restrictionClassName;
+    }
+    
+    /**
+     * Gets the restriction status.
+     *
+     * @return Returns boolean.
+     */
+    public boolean isRestriction() {
+        return restriction;
+    }
+    
+    /**
+     * Sets the restriction status.
+     *
+     * @param restriction
+     */
+    public void setRestriction(boolean restriction) {
+        this.restriction = restriction;
+    }
 
     /**
      * Gets the ordered status.
@@ -386,7 +424,8 @@
 
         return (QName[])returnQNames.toArray(new QName[returnQNames.size()]);
     }
-
+    
+    
     /**
      *  Finds the starting count for the addition of new items to the order
      * @return the starting number for the sequence
Index: modules/adb-codegen/src/org/apache/axis2/schema/SchemaCompiler.java
===================================================================
--- modules/adb-codegen/src/org/apache/axis2/schema/SchemaCompiler.java	(revision 413981)
+++ modules/adb-codegen/src/org/apache/axis2/schema/SchemaCompiler.java	(working copy)
@@ -781,9 +781,49 @@
             //Note  - this is no array! so the array boolean is false
 
         }else if (content instanceof XmlSchemaComplexContentRestriction){
-            //todo handle complex restriction here
-            throw new SchemaCompilationException(
-                    SchemaCompilerMessages.getMessage("schema.unsupportedcontenterror","Complex Content"));
+            
+        	// to handle extension we need to attach the extended items to the base type
+            // and create a new type
+            XmlSchemaComplexContentRestriction restriction = (XmlSchemaComplexContentRestriction)
+                    content;
+
+            //process the base type if it has not been processed yet
+            if (!isAlreadyProcessed(restriction.getBaseTypeName())){
+                //pick the relevant basetype from the schema and process it
+                XmlSchemaType type=  parentSchema.getTypeByName(restriction.getBaseTypeName());
+                if (type instanceof XmlSchemaComplexType) {
+                    XmlSchemaComplexType complexType = (XmlSchemaComplexType) type;
+                    if (complexType.getName() != null) {
+                        processNamedComplexSchemaType(complexType,parentSchema);
+                    } else {
+                        //this is not possible. The restriction should always
+                        //have a name
+                        throw new SchemaCompilationException("Unnamed complex type used in restriction");//Internationlize this
+                    }
+                } else if (type instanceof XmlSchemaSimpleType) {
+                    
+                	throw new SchemaCompilationException("Not a valid restriction, complex content restriction base type cannot be a simple type.");
+                }
+            }
+
+            // before actually processing this node, we need to recurse through the base types and add their
+            // children (sometimes even preserving the order) to the metainfo holder of this type
+            // the reason is that for restriction, the prefered way is to have the sequences of the base class
+            //* before * the sequence of the child element.
+            copyMetaInfoHierarchy(metaInfHolder,restriction.getBaseTypeName(),parentSchema);
+
+            //process the particle of this node
+            processParticle(restriction.getParticle(),metaInfHolder,parentSchema);
+
+            //the particle has been processed, However since this is an restriction we need to
+            //add the basetype as an extension to the complex type class.
+            // The basetype has been processed already
+            metaInfHolder.setExtension(true);
+            metaInfHolder.setExtensionClassName(findClassName(restriction.getBaseTypeName(),false));
+            
+            metaInfHolder.setRestriction(true);
+            metaInfHolder.setRestrictionClassName(findClassName(restriction.getBaseTypeName(),false));
+            //Note  - this is no array! so the array boolean is false
         }
     }
 
Index: modules/adb-codegen/src/org/apache/axis2/schema/writer/JavaBeanWriter.java
===================================================================
--- modules/adb-codegen/src/org/apache/axis2/schema/writer/JavaBeanWriter.java	(revision 413981)
+++ modules/adb-codegen/src/org/apache/axis2/schema/writer/JavaBeanWriter.java	(working copy)
@@ -18,6 +18,9 @@
 import org.apache.ws.commons.schema.XmlSchemaSimpleType;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+import org.w3c.dom.Attr;
+import org.w3c.dom.Node;
 
 import javax.xml.namespace.QName;
 import javax.xml.parsers.ParserConfigurationException;
@@ -386,6 +389,9 @@
             XSLTUtils.addAttribute(model, "extension", metainf.getExtensionClassName(), rootElt);
         }
 
+        if (metainf.isRestriction()) {
+            XSLTUtils.addAttribute(model, "restriction", metainf.getRestrictionClassName(), rootElt);
+        }
 
         if (metainf.isChoice()) {
             XSLTUtils.addAttribute(model, "choice", "yes", rootElt);
@@ -440,18 +446,32 @@
                                     Map typeMap,
                                     boolean isInherited) throws SchemaCompilationException {
         // go in the loop and add the part elements
-        QName[] qNames;
+        QName[] qName;
+        ArrayList missingQNames = new ArrayList();
+        ArrayList qNames = new ArrayList();
+        
+        BeanWriterMetaInfoHolder parentMetaInf = metainf.getParent();
+        
         if (metainf.isOrdered()) {
-            qNames = metainf.getOrderedQNameArray();
+            qName = metainf.getOrderedQNameArray();
         } else {
-            qNames = metainf.getQNameArray();
+            qName= metainf.getQNameArray();
         }
-
+        
+        for (int i = 0; i < qName.length; i++) {
+        	qNames.add(qName[i]);
+        }
+        //adding missing QNames to the end, including elements & attributes.
+        if (metainf.isRestriction()) {
+        	addMissingQNames(metainf, qNames);
+        }
         QName name;
-        for (int i = 0; i < qNames.length; i++) {
-            Element property = XSLTUtils.addChildElement(model, "property", rootElt);
-            name = qNames[i];
-            String xmlName = name.getLocalPart();
+        for (int i = 0; i < qNames.size(); i++) {
+        	name = (QName) qNames.get(i);
+        	
+        	Element property = XSLTUtils.addChildElement(model, "property", rootElt);
+        	
+        	String xmlName = name.getLocalPart();
             XSLTUtils.addAttribute(model, "name", xmlName, property);
             XSLTUtils.addAttribute(model, "nsuri", name.getNamespaceURI(), property);
             String javaName = makeUniqueJavaClassName(propertyNames, xmlName);
@@ -463,14 +483,19 @@
             if (javaClassNameForElement == null) {
                 throw new SchemaCompilationException(SchemaCompilerMessages.getMessage("schema.typeMissing"));
             }
-
+            
+            if (metainf.isRestriction() && typeChanged(name, metainf)) {
+            	XSLTUtils.addAttribute(model, "typeChanged", "yes", property);
+            	XSLTUtils.addAttribute(model, "rewrite", "yes", property);
+            }
+            
             XSLTUtils.addAttribute(model, "type", javaClassNameForElement, property);
 
-            if (PrimitiveTypeFinder.isPrimitive(javaClassNameForElement)){
+            if (PrimitiveTypeFinder.isPrimitive(javaClassNameForElement)) {
                 XSLTUtils.addAttribute(model, "primitive", "yes", property);
             }
             //add an attribute that says the type is default
-            if (isDefault(javaClassNameForElement)){
+            if (isDefault(javaClassNameForElement)) {
                 XSLTUtils.addAttribute(model, "default", "yes", property);
             }
 
@@ -482,7 +507,7 @@
                 XSLTUtils.addAttribute(model, "attribute", "yes", property);
             }
 
-            if (metainf.isNillable(name)){
+            if (metainf.isNillable(name)) {
                 XSLTUtils.addAttribute(model, "nillable", "yes", property);
             }
 
@@ -499,6 +524,10 @@
             }
             XSLTUtils.addAttribute(model, "shorttypename", shortTypeName, property);
 
+            if (missingQNames.contains(name) && metainf.isRestriction()) {
+            	XSLTUtils.addAttribute(model, "restricted", "yes", property);
+            }
+            
             if (isInherited){
                 XSLTUtils.addAttribute(model, "inherited", "yes", property);
             }
@@ -514,7 +543,16 @@
             long minOccurs = metainf.getMinOccurs(name);
             XSLTUtils.addAttribute(model, "minOccurs", minOccurs + "", property);
 
-
+            //in the case the original element is an array but the derived one is not.
+            if ((parentMetaInf.getArrayStatusForQName(name) && !metainf.getArrayStatusForQName(name)) && metainf.isRestriction()) {
+            	XSLTUtils.addAttribute(model, "rewrite", "yes", property);
+            	XSLTUtils.addAttribute(model, "occuranceChanged", "yes", property);
+            }
+            else if ((minOccursChanged(name, metainf) || maxOccursChanged(name, metainf)) && metainf.isRestriction()) {
+            	XSLTUtils.addAttribute(model, "restricted", "yes", property);
+            	XSLTUtils.addAttribute(model, "occuranceChanged", "yes", property);
+            }
+            
             if (metainf.getArrayStatusForQName(name)) {
 
                 XSLTUtils.addAttribute(model, "array", "yes", property);
@@ -531,9 +569,199 @@
                     XSLTUtils.addAttribute(model, "maxOccurs", maxOccurs + "", property);
                 }
             }
+            
         }
+        
+        /*if (metainf.isRestriction()) {
+        	
+        	QName[] pQNames;
+            BeanWriterMetaInfoHolder parentMetainf = metainf.getParent(); 
+            	
+            if (parentMetainf.isOrdered()) {
+            	pQNames = parentMetainf.getOrderedQNameArray();
+            } else {
+            	pQNames = parentMetainf.getQNameArray();
+            }
+            
+            
+        	Element root = model.getDocumentElement();
+        	if (root == null)
+        		System.out.println("HI:1");	
+        	NodeList propList = root.getElementsByTagName("property");
+        	
+        	HashMap properties = new HashMap();
+        	for (int i = 0; i < propList.getLength(); i++) {
+        		Element curElt = (Element)propList.item(i);
+        		Attr nameAtr = curElt.getAttributeNode("name");
+        		properties.put(nameAtr.getValue(),propList.item(i));
+        	}
+        	
+        
+        	if (qNames.length > pQNames.length) {
+        		for (int i = 0; i < qNames.length; i++) { 
+        			boolean found = false;
+        			for (int j = 0; j < pQNames.length; j++) {
+        				if (qNames[i] == pQNames[j]) {
+        					found = true;
+        				}
+        			}
+        			if (!found)
+        			{
+        				Element restrictElt = (Element)properties.get(qNames[i].getLocalPart());
+        				Attr nameAtr = restrictElt.getAttributeNode("name");
+        				System.out.println(nameAtr.getValue());
+        				//Node p = restrictElt.getParentNode();
+        				//String s = p.getNodeName();
+        				
+        				Attr restrictAttr = model.createAttribute("isRestricted");
+        				restrictAttr.setValue("yes");
+        		        restrictElt.setAttributeNode(restrictAttr);
+        			}
+        		}
+        	}
+        }*/
+        	
+        
+        
     }
-
+    private void addMissingQNames(BeanWriterMetaInfoHolder metainf, ArrayList qName) {
+    	
+    	QName[] qNames;
+        QName[] pQNames;
+        ArrayList missingQNames = new ArrayList();
+        
+    	BeanWriterMetaInfoHolder parentMetaInf = metainf.getParent();
+        
+        if (metainf.isOrdered()) {
+            qNames = metainf.getOrderedQNameArray();
+        } else {
+            qNames = metainf.getQNameArray();
+        }
+        
+        if (parentMetaInf.isOrdered()) {
+            pQNames = parentMetaInf.getOrderedQNameArray();
+        } else {
+            pQNames = parentMetaInf.getQNameArray();
+        }
+        
+        
+        for (int i=0; i < pQNames.length; i++) {
+       		if (qNameNotFound(pQNames[i], metainf)) {
+       			missingQNames.add(pQNames[i]);
+       		}
+       		if (i < qNames.length) {
+        		//keeping the order of restricted type.
+       			qName.add(qNames[i]); 
+       		}
+        }
+       	//adding missing QNames to the end of list.
+        if (!missingQNames.isEmpty()) {
+       		for (int i=0; i < missingQNames.size(); i++) {
+       			qName.add(missingQNames.get(i));
+       		}
+       	}
+        
+    }
+    
+    private boolean qNameNotFound(QName qname, BeanWriterMetaInfoHolder metainf) {
+    	
+    	boolean found = false;
+    	QName[] qNames;
+    	
+    	if (metainf.isOrdered()) {
+        	qNames = metainf.getOrderedQNameArray();
+        } else {
+        	qNames = metainf.getQNameArray();
+        }
+        
+        for (int j = 0; j < qNames.length; j++) {
+        	if (qname.getLocalPart().equals(qNames[j].getLocalPart())) {
+        			found = true;
+        	}
+        }
+        return !found;
+    }
+    
+    private boolean typeChanged(QName qname, BeanWriterMetaInfoHolder metainf) {
+    	
+    	boolean typeChanged = false;
+    	QName[] pQNames;
+    	
+    	BeanWriterMetaInfoHolder parentMetainf = metainf.getParent(); 
+        	
+        if (parentMetainf.isOrdered()) {
+        	pQNames = parentMetainf.getOrderedQNameArray();
+        } else {
+        	pQNames = parentMetainf.getQNameArray();
+        }
+        
+        for (int j = 0; j < pQNames.length; j++) {
+        	if (qname.getLocalPart().equals(pQNames[j].getLocalPart())) {
+        			
+             	String javaClassForParentElement = parentMetainf.getClassNameForQName(pQNames[j]);
+        		String javaClassForElement = metainf.getClassNameForQName(qname);
+        		
+        		if (!javaClassForParentElement.equals(javaClassForElement)) {
+        			typeChanged = true;
+        		}
+        	}
+        }
+        return typeChanged;
+    }
+    
+    private boolean minOccursChanged(QName qname, BeanWriterMetaInfoHolder metainf) throws SchemaCompilationException {
+    	
+    	boolean minChanged = false;
+    	QName[] pQNames;
+    	
+    	BeanWriterMetaInfoHolder parentMetainf = metainf.getParent(); 
+        	
+        if (parentMetainf.isOrdered()) {
+        	pQNames = parentMetainf.getOrderedQNameArray();
+        } else {
+        	pQNames = parentMetainf.getQNameArray();
+        }
+        
+        for (int j = 0; j < pQNames.length; j++) {
+        	if (qname.getLocalPart().equals(pQNames[j].getLocalPart())) {
+        			
+        		if (metainf.getMinOccurs(qname) > parentMetainf.getMinOccurs(pQNames[j])) {
+        			minChanged = true;
+       			}
+        		else if(metainf.getMinOccurs(qname) < parentMetainf.getMinOccurs(pQNames[j])) {
+        			throw new SchemaCompilationException(SchemaCompilerMessages.getMessage("minOccurs Wrong!")); 
+        		}
+        	}
+        }
+        return minChanged;
+    }
+    
+    private boolean maxOccursChanged(QName qname, BeanWriterMetaInfoHolder metainf) throws SchemaCompilationException {
+    	
+    	boolean maxChanged = false;
+    	QName[] pQNames;
+    	
+    	BeanWriterMetaInfoHolder parentMetainf = metainf.getParent(); 
+        	
+        if (parentMetainf.isOrdered()) {
+        	pQNames = parentMetainf.getOrderedQNameArray();
+        } else {
+        	pQNames = parentMetainf.getQNameArray();
+        }
+        
+        for (int j = 0; j < pQNames.length; j++) {
+        	if (qname.getLocalPart().equals(pQNames[j].getLocalPart())) {
+        			
+        		if (metainf.getMaxOccurs(qname) > parentMetainf.getMaxOccurs(pQNames[j])) {
+        			maxChanged = true;
+       			}
+        		else if(metainf.getMaxOccurs(qname) < parentMetainf.getMaxOccurs(pQNames[j])) {
+        			throw new SchemaCompilationException(SchemaCompilerMessages.getMessage("maxOccurs Wrong!")); 
+        		}
+        	}
+        }
+        return maxChanged;
+    }
     /**
      * Test whether the given class name matches the default
      * @param javaClassNameForElement
