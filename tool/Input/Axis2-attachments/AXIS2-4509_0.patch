Index: modules/jaxws/src/org/apache/axis2/jaxws/context/listener/CompositeInputStream.java
===================================================================
--- modules/jaxws/src/org/apache/axis2/jaxws/context/listener/CompositeInputStream.java	(revision 0)
+++ modules/jaxws/src/org/apache/axis2/jaxws/context/listener/CompositeInputStream.java	(revision 0)
@@ -0,0 +1,155 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.context.listener;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.LinkedList;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+/**
+ * CompositeInputStream has ability to store multiple inputStreams in a LinkList
+ * and perform various input stream operaitons on these inputStream in a serialized 
+ * manner or first in first read model.
+ */
+public class CompositeInputStream extends InputStream {
+    private static final Log log = 
+        LogFactory.getLog(CompositeInputStream.class);
+    private LinkedList<InputStream> compositeIS = new LinkedList<InputStream>();
+    //pointer to current node on Link list
+    private InputStream curr = null;
+   
+    public CompositeInputStream() {
+        //do nothing
+    }
+
+    public CompositeInputStream(InputStream is){
+        append(is);
+    }
+
+    public CompositeInputStream(InputStream[] isArray){
+        for (InputStream is:isArray){
+            append(is);
+        }
+    }
+
+    
+    public int read() throws IOException {
+        
+        // Note that reading is destructive.  
+        // The InputStreans are released when read.
+        int count = -1;
+        if(curr !=null){
+            count = curr.read();
+        }
+        //if we read all the bits from current and there are more InputStreams to read.
+        if(count == -1 && compositeIS.size()>0){
+            curr.close();
+            //release for GC
+            curr =null;
+            curr = compositeIS.removeFirst();
+            count = curr.read();
+        }
+        return count;
+    }
+
+    public void append(InputStream is){
+        compositeIS.addLast(is);
+        if(curr == null){
+            curr = compositeIS.removeFirst();
+        }
+    }
+
+    public int available() throws IOException {
+        
+        int available= 0;
+        if (curr != null) {
+            available = curr.available();
+        }
+        if (compositeIS != null) {
+            for(InputStream is:compositeIS){
+                if (is != null) {
+                    available+=is.available();
+                }
+            }
+        }
+        return available;
+    }
+
+    public void close() throws IOException {
+        if(curr!=null){
+            try {
+                curr.close();
+                curr = null;
+            } catch (IOException e) {
+                // TODO swallow so that other streams can be closed
+            }
+        }
+        if (compositeIS != null) {
+            for(InputStream is:compositeIS){
+                try {
+                    is.close();
+                } catch (IOException e) {
+                    // TODO swallow so that other streams can be closed
+                }
+            }
+        }
+    }
+
+    public int read(byte[] b, int off, int len) throws IOException {  
+        
+        // Read from the current buffer
+        int count = -1;
+        if(curr !=null){
+            count = curr.read(b, off, len);
+        }
+        
+        // If more bytes are needed, then access the next stream
+        // And recursively call read to get more data.
+        if(count < len && compositeIS.size()>0){
+            curr.close();
+            //release for GC
+            curr =null;
+            curr = compositeIS.removeFirst();
+            
+            // Recursive call to read the next buffer
+            int numRead = count <= 0 ? 0 : count;
+            int count2 = read(b, off+numRead, len-numRead);
+            
+            // Calculate the total count
+            if (count2 == -1 && count == -1 ) {
+                // All buffers are empty.
+                count = -1;
+            } else if (count2 == -1) {
+                // subsequent buffers are all empty, return numRead
+                count = numRead;
+            } else{
+                // normal case
+                count = count2 + numRead;
+            }
+        }
+        return count;
+    }
+    public int read(byte[] b) throws IOException {
+        return read(b, 0, b.length);
+    }
+
+}
Index: modules/jaxws/src/org/apache/axis2/jaxws/context/listener/ContextListenerUtils.java
===================================================================
--- modules/jaxws/src/org/apache/axis2/jaxws/context/listener/ContextListenerUtils.java	(revision 0)
+++ modules/jaxws/src/org/apache/axis2/jaxws/context/listener/ContextListenerUtils.java	(revision 0)
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.axis2.jaxws.context.listener;
+/**
+ * Utility Class that holds a ways to registerProviderOMListener and oter operations 
+ * used by ParsedEntityCustom Builder.
+ */
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import javax.xml.stream.XMLStreamConstants;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+
+import org.apache.axiom.om.OMContainer;
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.OMNamespace;
+import org.apache.axis2.jaxws.core.MessageContext;
+import org.apache.axis2.jaxws.message.databinding.ParsedEntityReader;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+public class ContextListenerUtils {
+    private static final Log log = 
+        LogFactory.getLog(ContextListenerUtils.class);
+    public static void registerProviderOMListener(MessageContext mc){
+        if(log.isDebugEnabled()){
+            log.debug("Creating ProviderOMContextListener");
+        }
+        ProviderOMContextListener.create(mc.getAxisMessageContext().getServiceContext());
+    }
+    
+    public static InputStream createPayloadElement(InputStream payloadContent, OMNamespace ns, String localPart, OMContainer parent){
+        CompositeInputStream inputStream = new CompositeInputStream();
+        InputStream startTag = getStartTag(ns, localPart, parent);
+        InputStream endTag = getEndTag(ns, localPart);
+        //Add Element startTag
+        ((CompositeInputStream)inputStream).append(startTag);
+        //Add Element content
+        ((CompositeInputStream)inputStream).append(payloadContent);
+        //Add Element endTag
+        ((CompositeInputStream)inputStream).append(endTag);
+
+        return inputStream;
+
+    }
+        
+    public static int skipEventsTo(int targetEvent, XMLStreamReader parser) throws XMLStreamException {
+        int eventType = 0;
+        while (parser.hasNext()) {
+            eventType = parser.next();
+            if (eventType == targetEvent)
+                return eventType;
+        }
+        return eventType; // return END_DOCUMENT;
+    }
+    
+    
+    private static InputStream getEndTag(OMNamespace ns, String localPart){
+        if(log.isDebugEnabled()){
+            log.debug("Start ParsedEntityDataSource.Data.getEndTag()");
+        }
+        String endElement = null;
+        String prefix = (ns!=null)?ns.getPrefix():null;
+        String uri = (ns!=null)?ns.getNamespaceURI():null;
+        if(prefix!=null && prefix.length()>0){
+            endElement = "</"+prefix+":"+localPart+">";
+        }else{
+            endElement = "</"+localPart+">";
+        }
+        if(log.isDebugEnabled()){
+            log.debug("End ParsedEntityDataSource.Data.getEndTag()");
+        }
+        return new ByteArrayInputStream(endElement.getBytes());
+    }
+    /*
+     * get startElement using namespace and local part. Add all namespace prefixes from parent elements.
+     */
+    private static InputStream getStartTag(OMNamespace ns, String localPart, OMContainer parent){
+        if(log.isDebugEnabled()){
+            log.debug("Start ParsedEntityDataSource.Data.getStartTag()");
+        }            
+        //Start creating the element.
+        StringBuffer startElement = new StringBuffer();
+        String prefix = (ns!=null)?ns.getPrefix():null;
+        String uri = (ns!=null)?ns.getNamespaceURI():null;
+        if(prefix!=null && prefix.length()>0){
+            startElement.append("<"+prefix+":"+localPart+ " xmlns:"+prefix+"=\""+uri+"\"");
+            addParentNs(startElement, parent);
+
+        }else{
+            startElement.append("<"+localPart+" xmlns=\""+uri+"\"");
+            addParentNs(startElement, parent);
+        }
+        if(log.isDebugEnabled()){
+            log.debug("StartElement ="+startElement);
+        }
+        if(log.isDebugEnabled()){
+            log.debug("End ParsedEntityDataSource.Data.getStartTag()");
+        }
+        return new ByteArrayInputStream(startElement.toString().getBytes());
+    }
+    /*
+     * fetch all prent namespace declarations
+     */
+    private static void getParentnsdeclarations(HashMap<String, String> nsDecls, OMContainer parent){
+        if(nsDecls == null){
+            nsDecls = new HashMap<String, String>();
+        }
+        while (parent instanceof OMElement){
+            OMElement omElement = (OMElement) parent;
+            Iterator ite = omElement.getAllDeclaredNamespaces();
+            while (ite.hasNext()) {
+                OMNamespace omn = (OMNamespace) ite.next();
+                String prefix = omn.getPrefix();
+                String nsUri = omn.getNamespaceURI();
+                if (!nsDecls.containsKey(prefix))
+                    nsDecls.put(prefix, nsUri);
+            }
+            parent = omElement.getParent();
+        }
+    }
+    /*
+     * add all parent namespace declarations to the element
+     */
+    private static void addParentNs(StringBuffer startElement, OMContainer parent){
+        HashMap<String, String> nsDecls = new HashMap<String, String>();
+        //Get all the namespaces associated with Body, envelope etc.
+        getParentnsdeclarations(nsDecls, parent);
+        Iterator<Map.Entry<String, String>> iter = nsDecls.entrySet().iterator();
+        while (iter.hasNext()) {
+            Map.Entry<String, String> entry = iter.next();
+            String prefix = entry.getKey();
+            String uri = entry.getValue();
+            if ("".equals(prefix))
+                startElement.append(" xmlns=\"");
+            else {
+                startElement.append(" xmlns:");
+                startElement.append(prefix);
+                startElement.append("=\"");
+            }
+            startElement.append(uri);
+            startElement.append("\"");
+        }
+        startElement.append(">");
+    }
+
+}
Index: modules/jaxws/src/org/apache/axis2/jaxws/context/listener/ParserInputStreamCustomBuilder.java
===================================================================
--- modules/jaxws/src/org/apache/axis2/jaxws/context/listener/ParserInputStreamCustomBuilder.java	(revision 0)
+++ modules/jaxws/src/org/apache/axis2/jaxws/context/listener/ParserInputStreamCustomBuilder.java	(revision 0)
@@ -0,0 +1,199 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.jaxws.context.listener;
+
+import java.io.InputStream;
+
+import javax.xml.stream.XMLStreamConstants;
+import javax.xml.stream.XMLStreamReader;
+
+import org.apache.axiom.om.OMContainer;
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.OMException;
+import org.apache.axiom.om.OMFactory;
+import org.apache.axiom.om.OMNamespace;
+import org.apache.axiom.om.OMSourcedElement;
+import org.apache.axiom.om.ds.ParserInputStreamDataSource;
+import org.apache.axiom.om.impl.builder.CustomBuilder;
+import org.apache.axiom.soap.SOAPFactory;
+import org.apache.axiom.soap.SOAPHeader;
+import org.apache.axis2.jaxws.message.databinding.ParsedEntityReader;
+import org.apache.axis2.jaxws.message.factory.ParsedEntityReaderFactory;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+/**
+ * A custom builder to that does the following:
+ * 1) Uses the parser to fetch the inputStream if parser supports reading of element contents
+ * 2) Use the inputStream to create a DataSource backed by the InputStream read from Parser.
+ * 3) Use the OMFactory to create OMSourcedElement, OMSourcedElement is backed by ParsedEntityDataSource.
+ */
+
+public class ParserInputStreamCustomBuilder implements CustomBuilder {
+    private static final Log log = 
+        LogFactory.getLog(ParserInputStreamCustomBuilder.class);
+
+    private String encoding = null;
+
+    /**
+     * Constructor
+     * @param encoding 
+     */
+    public ParserInputStreamCustomBuilder(String encoding) {
+        this.encoding = (encoding == null) ? "utf-8" :encoding;
+    }
+    /*
+     * (non-Javadoc)
+     * @see org.apache.axiom.om.impl.builder.CustomBuilder#create(java.lang.String, java.lang.String, org.apache.axiom.om.OMContainer, javax.xml.stream.XMLStreamReader, org.apache.axiom.om.OMFactory)
+     */
+    public OMElement create(String namespace, 
+        String localPart, 
+        OMContainer parent,
+        XMLStreamReader reader, 
+        OMFactory factory) throws OMException {
+
+        if (log.isDebugEnabled()) {
+            log.debug("create namespace = " + namespace);
+            log.debug("  localPart = " + localPart);
+            log.debug("  reader = " + reader.getClass());
+        }
+        /*
+         * 1) Use the the parser to fetch the inputStream
+         * 2) Use the inputStream to create a DataSource, delay reading of content as much as you can.
+         * 3) Use the OMFactory to create OMSourcedElement, OMSourcedElement is backed by ParsedEntityDataSource.
+         */
+        try{
+            ParsedEntityReaderFactory perf = (ParsedEntityReaderFactory)FactoryRegistry.getFactory(ParsedEntityReaderFactory.class);
+            ParsedEntityReader entityReader = perf.getParsedEntityReader();
+            //Do not user custom builder if Parser does not have ability to read sub content.
+            if(!entityReader.isParsedEntityStreamAvailable()){
+                return null;
+            }
+            // Create an OMSourcedElement backed by the ParsedData
+            InputStream parsedStream = getPayloadContent(reader, entityReader);
+            if(parsedStream == null){
+                //cant read content from EntityReader, returning null.
+                return null;
+            }
+            //read the payload. Lets move the parser forward.
+            if(reader.hasNext()){
+                reader.next();
+            }
+            if(namespace == null){
+                //lets look for ns in reader
+                namespace = reader.getNamespaceURI();
+                if(namespace == null){
+                    //still cant find the namespace, just set it to "";
+                    namespace = "";
+                }
+            }
+            OMNamespace ns = factory.createOMNamespace(namespace, reader.getPrefix());
+            InputStream payload = ContextListenerUtils.createPayloadElement(parsedStream, ns, localPart, parent);
+
+            ParserInputStreamDataSource ds = new ParserInputStreamDataSource(payload, encoding);
+            OMSourcedElement om = null;
+            if (parent instanceof SOAPHeader && factory instanceof SOAPFactory) {
+                om = ((SOAPFactory)factory).createSOAPHeaderBlock(localPart, ns, ds);
+            } else {
+                om = factory.createOMElement(ds, localPart, ns);
+            }           
+            //Add the new OMSourcedElement ot the parent
+            parent.addChild(om); 
+            /*
+            //Lets Mark the body as complete so Serialize calls dont fetch data from parser for body content.
+            if(parent instanceof SOAPBodyImpl){
+                ((SOAPBodyImpl)parent).setComplete(true);
+            }
+            */
+            return om;
+        } catch (OMException e) {
+            throw e;
+        } catch (Throwable t) {
+            throw new OMException(t);
+        }
+    }
+
+    public OMElement create(String namespace, 
+        String localPart, 
+        OMContainer parent,
+        XMLStreamReader reader, 
+        OMFactory factory,
+        InputStream payload) throws OMException {
+
+        if (log.isDebugEnabled()) {
+            log.debug("create namespace = " + namespace);
+            log.debug("  localPart = " + localPart);
+            log.debug("  reader = " + reader.getClass());
+        }
+        /*
+         * 1) Use the the parser to fetch the inputStream
+         * 2) Use the inputStream to create a DataSource, delay reading of content as much as you can.
+         * 3) Use the OMFactory to create OMSourcedElement, OMSourcedElement is backed by ParsedEntityDataSource.
+         */
+        try{
+            if(namespace == null){
+                //lets look for ns in reader
+                namespace = reader.getNamespaceURI();
+                if(namespace == null){
+                    //still cant find the namespace, just set it to "";
+                    namespace = "";
+                }
+            }
+            OMNamespace ns = factory.createOMNamespace(namespace, reader.getPrefix());
+            ParserInputStreamDataSource ds = new ParserInputStreamDataSource(payload, encoding);
+            OMSourcedElement om = null;
+            if (parent instanceof SOAPHeader && factory instanceof SOAPFactory) {
+                om = ((SOAPFactory)factory).createSOAPHeaderBlock(localPart, ns, ds);
+            } else {
+                om = factory.createOMElement(ds, localPart, ns);
+            }           
+            //Add the new OMSourcedElement ot the parent
+            parent.addChild(om); 
+            return om;
+        } catch (OMException e) {
+            throw e;
+        } catch (Throwable t) {
+            throw new OMException(t);
+        }
+    }
+
+    /*
+     * Read content from entityReader.
+     */
+    private InputStream getPayloadContent(XMLStreamReader parser, ParsedEntityReader entityReader){
+        int event = parser.getEventType();
+        //Make sure its start element event.
+        if(log.isDebugEnabled()){
+            log.debug("checking if event is START_ELEMENT");
+        }
+        InputStream parsedStream = null;
+        if(event == XMLStreamConstants.START_ELEMENT){
+            if(log.isDebugEnabled()){
+                log.debug("event is START_ELEMENT");
+            }
+            parsedStream = entityReader.readParsedEntityStream(parser);
+            if(parsedStream!=null){
+                if(log.isDebugEnabled()){
+                    log.debug("Read Parsed EntityStream");
+                }
+            }
+        }
+        return parsedStream;
+    }
+}
Index: modules/jaxws/src/org/apache/axis2/jaxws/context/listener/ProviderOMContextListener.java
===================================================================
--- modules/jaxws/src/org/apache/axis2/jaxws/context/listener/ProviderOMContextListener.java	(revision 0)
+++ modules/jaxws/src/org/apache/axis2/jaxws/context/listener/ProviderOMContextListener.java	(revision 0)
@@ -0,0 +1,131 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.jaxws.context.listener;
+
+import org.apache.axiom.om.impl.builder.StAXOMBuilder;
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.ServiceContext;
+import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.MessageContextListener;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * This is a MessageContextListener that installs ParserInputStreamCustomBuilder
+ * during an Envelope or ServiceContext event on AxisService. The installed
+ * ParserInputStreamCustomBuilder is then used by StAXSoapModelBuilder to create
+ * OMSourcedElement for payload data from Soap body.
+ *
+ */
+public class ProviderOMContextListener implements MessageContextListener {
+    private static final Log log = 
+        LogFactory.getLog(ProviderOMContextListener.class);
+    /**
+     * Create and add a listener
+     * @param sc ServiceContext
+     */
+    public static void create(ServiceContext sc) {
+        if(log.isDebugEnabled()){
+            log.debug("Start ProviderOMContextListener.create(ServiceContext)");
+        }
+        if (sc == null || 
+            sc.getAxisService() == null ||
+            sc.getAxisService().
+            hasMessageContextListener(ProviderOMContextListener.class)){
+            if(log.isDebugEnabled()){
+                log.debug("ProviderOMContextListener already installed on AxisService");
+            }
+            return;
+        }
+        ProviderOMContextListener listener = new ProviderOMContextListener();
+        sc.getAxisService().addMessageContextListener(listener);
+        if(log.isDebugEnabled()){
+            log.debug("End ProviderOMContextListener.create(ServiceContext)");
+        }
+    }
+    /**
+     * Attach the ParserInputStreamCustomBuilder on the Axiom builder.
+     * This will create ParserInputStreamCustomBuilder and register it with StAXOMBuilder which will 
+     * use ByteArrayCustomBuilder to create byteArray backed OM.
+     * @param sc
+     * @param mc
+     */
+    private void installParserInputStreamCustomBuilder(ServiceContext sc, MessageContext mc) {
+        if (log.isDebugEnabled()) {
+            log.debug("attachEvent for sc= " + sc.getName() + "and  mc=" + mc.getLogCorrelationID());
+        }
+
+        // Make sure the MessageContext has a SOAPEnvelope and Builder
+        SOAPEnvelope envelope = mc.getEnvelope();
+
+        if (envelope == null) {
+            return;
+        }
+        if (!(envelope.getBuilder() instanceof StAXOMBuilder)) {
+            return;
+        }
+
+        AxisOperation axisOp = mc.getAxisOperation();
+        if (axisOp == null) {
+            return;
+        }
+
+        ParserInputStreamCustomBuilder pacb = new ParserInputStreamCustomBuilder(null);
+        ((StAXOMBuilder) envelope.getBuilder()).registerCustomBuilderForPayload(pacb);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.axis2.description.MessageContextListener#attachEnvelopeEvent(org.apache.axis2.context.MessageContext)
+     */
+    public void attachEnvelopeEvent(MessageContext mc) {
+        if(log.isDebugEnabled()){
+            log.debug("Start attachEnvelopeEvent");
+        }
+        if(mc.getServiceContext() !=null){
+            installParserInputStreamCustomBuilder(mc.getServiceContext(), mc);
+            if(log.isDebugEnabled()){
+                log.debug("Installed ParserInputStreamCustomBuilder");
+            }
+        }
+        if(log.isDebugEnabled()){
+            log.debug("Stop attachEnvelopeEvent");
+        }
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.axis2.description.MessageContextListener#attachServiceContextEvent(org.apache.axis2.context.ServiceContext, org.apache.axis2.context.MessageContext)
+     */
+    public void attachServiceContextEvent(ServiceContext sc, MessageContext mc) {
+        if(log.isDebugEnabled()){
+            log.debug("Start attachServiceContextEvent");
+        }
+        if (mc.getEnvelope() != null) {
+
+            installParserInputStreamCustomBuilder(sc, mc);
+            if(log.isDebugEnabled()){
+                log.debug("Installed ParserInputStreamCustomBuilder");
+            }
+        }
+        if(log.isDebugEnabled()){
+            log.debug("Stop attachServiceContextEvent");
+        }
+    }
+
+}
Index: modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/ParsedEntityReader.java
===================================================================
--- modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/ParsedEntityReader.java	(revision 0)
+++ modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/ParsedEntityReader.java	(revision 0)
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.jaxws.message.databinding;
+
+import java.io.InputStream;
+
+import javax.xml.stream.XMLStreamReader;
+
+/**
+ * This interface will be used to read data stream directly from a parser.
+ *
+ */
+public interface ParsedEntityReader {
+	/*
+	 * Reader content from parser
+	 */
+	public InputStream readParsedEntityStream(XMLStreamReader reader);
+
+	/*
+	 * Check if parser has ability to provide input stream for un read content.
+	 */
+	public boolean isParsedEntityStreamAvailable();
+}
Index: modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/ParsedEntityReaderImpl.java
===================================================================
--- modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/ParsedEntityReaderImpl.java	(revision 0)
+++ modules/jaxws/src/org/apache/axis2/jaxws/message/databinding/impl/ParsedEntityReaderImpl.java	(revision 0)
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.jaxws.message.databinding.impl;
+
+import java.io.InputStream;
+
+import javax.xml.stream.XMLStreamReader;
+
+import org.apache.axis2.jaxws.message.databinding.ParsedEntityReader;
+
+public class ParsedEntityReaderImpl implements ParsedEntityReader {
+	private boolean available = false;
+	public InputStream readParsedEntityStream(XMLStreamReader parser) {
+		if(parser== null){
+			return null;
+		}
+		else{
+			return null;
+		}
+	}
+
+	public boolean isParsedEntityStreamAvailable() {
+		return available;
+	}
+	
+	public void setParsedEntityStreamAvailable(boolean available){
+		this.available = available;
+	}
+}
Index: modules/jaxws/src/org/apache/axis2/jaxws/message/factory/ParsedEntityReaderFactory.java
===================================================================
--- modules/jaxws/src/org/apache/axis2/jaxws/message/factory/ParsedEntityReaderFactory.java	(revision 0)
+++ modules/jaxws/src/org/apache/axis2/jaxws/message/factory/ParsedEntityReaderFactory.java	(revision 0)
@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.jaxws.message.factory;
+
+import org.apache.axis2.jaxws.message.databinding.ParsedEntityReader;
+import org.apache.axis2.jaxws.message.databinding.impl.ParsedEntityReaderImpl;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+public class ParsedEntityReaderFactory {
+	private static final Log log = LogFactory.getLog(ParsedEntityReaderFactory.class);
+	
+	private ParsedEntityReader per = null;
+	
+	public ParsedEntityReader getParsedEntityReader(){
+		if(per!=null){
+			return per;
+		}
+		else{
+			per = new ParsedEntityReaderImpl();
+			return per;
+		}
+	}
+	
+	public void setParsetEntityReader(ParsedEntityReader per){
+		if(this.per == null){
+			this.per = per;
+		}
+	}
+}
Index: modules/jaxws/src/org/apache/axis2/jaxws/registry/FactoryRegistry.java
===================================================================
--- modules/jaxws/src/org/apache/axis2/jaxws/registry/FactoryRegistry.java	(revision 817713)
+++ modules/jaxws/src/org/apache/axis2/jaxws/registry/FactoryRegistry.java	(working copy)
@@ -34,6 +34,7 @@
 import org.apache.axis2.jaxws.handler.lifecycle.factory.HandlerLifecycleManagerFactory;
 import org.apache.axis2.jaxws.message.databinding.impl.JAXBBlockFactoryImpl;
 import org.apache.axis2.jaxws.message.databinding.impl.OMBlockFactoryImpl;
+import org.apache.axis2.jaxws.message.databinding.impl.ParsedEntityReaderImpl;
 import org.apache.axis2.jaxws.message.databinding.impl.SOAPEnvelopeBlockFactoryImpl;
 import org.apache.axis2.jaxws.message.databinding.impl.SourceBlockFactoryImpl;
 import org.apache.axis2.jaxws.message.databinding.impl.XMLStringBlockFactoryImpl;
@@ -42,6 +43,7 @@
 import org.apache.axis2.jaxws.message.factory.JAXBBlockFactory;
 import org.apache.axis2.jaxws.message.factory.MessageFactory;
 import org.apache.axis2.jaxws.message.factory.OMBlockFactory;
+import org.apache.axis2.jaxws.message.factory.ParsedEntityReaderFactory;
 import org.apache.axis2.jaxws.message.factory.SAAJConverterFactory;
 import org.apache.axis2.jaxws.message.factory.SOAPEnvelopeBlockFactory;
 import org.apache.axis2.jaxws.message.factory.SourceBlockFactory;
@@ -120,7 +122,7 @@
         table.put(InvocationControllerFactory.class, new InvocationControllerFactoryImpl());
         table.put(HandlerPreInvokerFactory.class, new HandlerPreInvokerFactoryImpl());
         table.put(HandlerPostInvokerFactory.class, new HandlerPostInvokerFactoryImpl());
-        
+        table.put(ParsedEntityReaderFactory.class, new ParsedEntityReaderFactory());
         // register the implementation responsible for both WebServiceContext 
         // injection and the updating of the WebServiceContext instances that
         // have already been injected, we will register these by two different
Index: modules/jaxws/src/org/apache/axis2/jaxws/server/dispatcher/ProviderDispatcher.java
===================================================================
--- modules/jaxws/src/org/apache/axis2/jaxws/server/dispatcher/ProviderDispatcher.java	(revision 817713)
+++ modules/jaxws/src/org/apache/axis2/jaxws/server/dispatcher/ProviderDispatcher.java	(working copy)
@@ -21,6 +21,7 @@
 
 import org.apache.axis2.Constants;
 import org.apache.axis2.jaxws.ExceptionFactory;
+import org.apache.axis2.jaxws.context.listener.ContextListenerUtils;
 import org.apache.axis2.jaxws.context.utils.ContextUtils;
 import org.apache.axis2.jaxws.core.MessageContext;
 import org.apache.axis2.jaxws.core.util.MessageContextUtils;
@@ -292,6 +293,8 @@
                     }
                 }
                 if (providerType.equals(OMElement.class)) {
+                    //Register the ContextListener for performance.
+                    ContextListenerUtils.registerProviderOMListener(request);
                     // TODO avoid call to message.getValue due to
                     // current unnecessary message transformation in
                     // message.getValue.  Once message.getValue is fixed,
Index: modules/jaxws/test/org/apache/axis2/jaxws/context/listener/CompositeInputStreamTests.java
===================================================================
--- modules/jaxws/test/org/apache/axis2/jaxws/context/listener/CompositeInputStreamTests.java	(revision 0)
+++ modules/jaxws/test/org/apache/axis2/jaxws/context/listener/CompositeInputStreamTests.java	(revision 0)
@@ -0,0 +1,147 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.jaxws.context.listener;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+import junit.framework.TestCase;
+
+public class CompositeInputStreamTests extends TestCase {
+	private InputStream is1 = new ByteArrayInputStream("John".getBytes());
+	private InputStream is2 = new ByteArrayInputStream("Conner".getBytes());
+	
+	public void testCreateCompositeStream(){
+		//Testing default constructor
+		CompositeInputStream cis1 = new CompositeInputStream();
+		cis1.append(is1);
+		cis1.append(is2);
+		try{
+			String streamContent = invokeRead(cis1);
+			assertTrue(streamContent.equals("JohnConner"));
+		}catch(Exception e){
+			fail(e.getMessage());
+		}
+		//Testing constructor with inputstream Object
+		resetGlobalInputStream();
+		CompositeInputStream cis2 = new CompositeInputStream(is1);
+		cis2.append(is2);
+		try{
+			String streamContent = invokeRead(cis2);
+			assertTrue(streamContent.equals("JohnConner"));
+		}catch(Exception e){
+			fail(e.getMessage());
+		}		
+		//Null test on onstructor with inputstream Object
+		resetGlobalInputStream();
+		InputStream nullValue = null;
+		cis2 = new CompositeInputStream(nullValue);
+		cis2.append(is2);
+		try{
+			String streamContent = invokeRead(cis2);
+			assertTrue(streamContent.equals("Conner"));
+		}catch(Exception e){
+			fail(e.getMessage());
+		}
+		
+		//Testing Construcot with inputStream Array Object;
+		resetGlobalInputStream();
+		InputStream[] isArray = new InputStream[]{is1, is2};
+		CompositeInputStream cis3 = new CompositeInputStream(isArray);
+		try{
+			String streamContent = invokeRead(cis3);
+			assertTrue(streamContent.equals("JohnConner"));
+		}catch(Exception e){
+			fail(e.getMessage());
+		}
+		//Null test on onstructor with inputstream Object
+		isArray = new InputStream[]{null, null};
+		cis3 = new CompositeInputStream(isArray);
+		try{
+			String streamContent = invokeRead(cis3);
+			assertTrue(streamContent.equals(""));
+		}catch(Exception e){
+			fail(e.getMessage());
+		}
+		
+	}
+	
+	public void testRead() throws Exception {		
+	    
+	    // Read fully
+	    resetGlobalInputStream();
+	    InputStream[] isArray = new InputStream[]{is1, is2};
+	    CompositeInputStream cis3 = new CompositeInputStream(isArray);
+
+	    int avail = cis3.available();
+	    assertTrue("Unexpected avail=" + avail, avail == "JohnConner".length());
+	    String streamContent = invokeReadArray(cis3, avail);
+	    assertTrue(streamContent.equals("JohnConner"));
+		
+		
+		// Read partial...with cross buffer...
+        resetGlobalInputStream();
+        isArray = new InputStream[]{is1, is2};
+        cis3 = new CompositeInputStream(isArray);
+        
+        streamContent = invokeReadArray(cis3, 1);
+        assertTrue(streamContent.equals("J"));
+        streamContent = invokeReadArray(cis3, 5);
+        assertTrue(streamContent.equals("ohnCo"));
+        streamContent = invokeReadArray(cis3, 10);
+        assertTrue(streamContent.equals("nner"));
+        
+		
+		//Negative test case
+		isArray = new InputStream[]{null, null};
+		cis3 = new CompositeInputStream(isArray);
+
+		streamContent = invokeReadArray(cis3, 100);
+		assertTrue(streamContent.equals(""));
+	
+	}
+	
+	private String invokeRead(CompositeInputStream cis)throws IOException{
+		int b;
+		ByteArrayOutputStream os = new ByteArrayOutputStream();
+		while((b = cis.read())!=-1){
+			os.write(b);
+		}
+		byte[] byteArray = os.toByteArray();
+		return new String(byteArray);
+	}
+	
+	private String invokeReadArray(CompositeInputStream cis, int len)throws IOException{
+		byte[] byteArray = new byte[1024];
+		ByteArrayOutputStream os = new ByteArrayOutputStream();
+		int numBytes = cis.read(byteArray, 0, len);
+		if (numBytes < 0) {
+		    return "";
+		} else {
+		    return new String(byteArray, 0, numBytes);
+		}
+	}
+	
+	private void resetGlobalInputStream(){
+		is1 = new ByteArrayInputStream("John".getBytes());
+		is2 = new ByteArrayInputStream("Conner".getBytes());
+	}
+}
Index: modules/jaxws/test/org/apache/axis2/jaxws/context/listener/ParserInputStreamCustomBuilderTests.java
===================================================================
--- modules/jaxws/test/org/apache/axis2/jaxws/context/listener/ParserInputStreamCustomBuilderTests.java	(revision 0)
+++ modules/jaxws/test/org/apache/axis2/jaxws/context/listener/ParserInputStreamCustomBuilderTests.java	(revision 0)
@@ -0,0 +1,98 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.jaxws.context.listener;
+
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.util.Iterator;
+
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+
+import junit.framework.TestCase;
+
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.axiom.om.OMContainer;
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.OMSourcedElement;
+import org.apache.axiom.om.ds.ParserInputStreamDataSource;
+import org.apache.axiom.soap.SOAPBody;
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axiom.soap.SOAPHeader;
+import org.apache.axiom.soap.impl.builder.StAXSOAPModelBuilder;
+import org.apache.axis2.jaxws.message.databinding.ParsedEntityReader;
+import org.apache.axis2.jaxws.message.databinding.impl.ParsedEntityReaderImpl;
+import org.apache.axis2.jaxws.message.factory.ParsedEntityReaderFactory;
+import org.apache.axis2.jaxws.registry.FactoryRegistry;
+
+public class ParserInputStreamCustomBuilderTests extends TestCase {
+	private StAXSOAPModelBuilder builder = null;
+	private XMLStreamReader parser = null;
+	private String mockenvelope= "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">"+
+	"<soapenv:Header/>"+
+	"<soapenv:Body>"+
+	"<invokeOp>Hello Provider OM</invokeOp>"+
+	"</soapenv:Body>"+
+	"</soapenv:Envelope>";
+        
+        String mockPayload = "<invokeOp>Hello Provider OM</invokeOp>";
+	
+	public void testCustomBuilder(){
+		try{
+                        SOAPEnvelope env = getMockEnvelope();
+                        SOAPHeader header = env.getHeader();
+                        SOAPBody body = env.getBody();
+			ParserInputStreamCustomBuilder customBuilder = new ParserInputStreamCustomBuilder("UTF-8");
+                        InputStream payload = new ByteArrayInputStream(mockPayload.getBytes());
+			OMElement om= customBuilder.create(null, "invokeOp",(OMContainer) body, parser, OMAbstractFactory.getOMFactory(), payload);
+			assertTrue(om!=null);
+			assertTrue(om instanceof OMSourcedElement);
+			OMSourcedElement ose = (OMSourcedElement)om;
+			assertNotNull(ose.getDataSource());
+			assertTrue((ose.getDataSource()) instanceof ParserInputStreamDataSource);
+		}catch(Exception e){
+			fail(e.getMessage());
+		}
+	}
+
+	private SOAPEnvelope getMockEnvelope() throws Exception{
+		SOAPEnvelope env = (SOAPEnvelope)getOMBuilder().getDocumentElement();
+		return env;
+	}
+    private StAXSOAPModelBuilder getOMBuilder() throws Exception {
+    	if(builder == null){
+	        builder = new StAXSOAPModelBuilder(getParser(), null);
+    	}
+        return builder;
+    }
+    
+    private XMLStreamReader getParser()throws XMLStreamException{
+    	if(parser == null){
+    		parser =  XMLInputFactory.newInstance()
+    		.createXMLStreamReader(
+    				new ByteArrayInputStream(mockenvelope.getBytes()));
+    	}
+    	return parser;
+
+    }
+	
+}
Index: modules/jaxws/test/org/apache/axis2/jaxws/context/listener/ProviderOMContextListenerTests.java
===================================================================
--- modules/jaxws/test/org/apache/axis2/jaxws/context/listener/ProviderOMContextListenerTests.java	(revision 0)
+++ modules/jaxws/test/org/apache/axis2/jaxws/context/listener/ProviderOMContextListenerTests.java	(revision 0)
@@ -0,0 +1,83 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.axis2.jaxws.context.listener;
+
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.ServiceContext;
+import org.apache.axis2.context.ServiceGroupContext;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.AxisServiceGroup;
+
+import org.apache.axis2.engine.AxisConfiguration;
+
+import junit.framework.TestCase;
+
+public class ProviderOMContextListenerTests extends TestCase {
+	private ServiceContext sc = null;
+	private MessageContext mc = null;
+	
+	public void testCreate(){
+		try{
+			ProviderOMContextListener.create(createAxisServiceContext());
+			assertTrue(sc.getAxisService().hasMessageContextListener(ProviderOMContextListener.class));
+		}catch(Exception e){
+			fail(e.getMessage());
+		}
+	}
+	
+	private ServiceContext createAxisServiceContext() throws Exception {
+		if(this.sc != null){
+			return sc;
+		}
+        
+        AxisConfiguration ac = new AxisConfiguration();
+        ConfigurationContext cc = new ConfigurationContext(ac);
+        
+        // Create a dummy AxisService
+        AxisService service = new AxisService();
+        service.setName("dummy");
+        
+        AxisServiceGroup asg = new AxisServiceGroup();
+        asg.addService(service);
+        
+        
+        // Create a Dummy ServiceContext
+        ServiceGroupContext sgc = new ServiceGroupContext(cc, asg);
+        ServiceContext sc = sgc.getServiceContext(service);
+        this.sc = sc;
+        
+        return sc;
+
+    }
+	
+	private MessageContext createMessageContext(){
+		if(this.mc !=null){
+			return mc;
+		}
+        // Create a MessageContext
+        MessageContext mc = new MessageContext();
+        
+        // Attach the ServiceContext and MessageContext.
+        // This will trigger the MyServiceContextListener.attachEvent
+        mc.setServiceContext(sc);
+        this.mc = mc;
+        return mc;
+	}
+}
