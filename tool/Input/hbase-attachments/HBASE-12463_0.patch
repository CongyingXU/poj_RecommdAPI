diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HeapMemStoreLAB.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HeapMemStoreLAB.java
index f22a6e5..5048e9d 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HeapMemStoreLAB.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HeapMemStoreLAB.java
@@ -77,6 +77,12 @@ public class HeapMemStoreLAB implements MemStoreLAB {
   // Current count of open scanners which reading data from this MemStoreLAB
   private final AtomicInteger openScannerCount = new AtomicInteger();
 
+  private static final ThreadLocal<ByteRange> ALLOC_HOLDER = new ThreadLocal<ByteRange>() {
+    protected ByteRange initialValue() {
+      return new SimpleMutableByteRange();
+    };
+  };
+
   // Used in testing
   public HeapMemStoreLAB() {
     this(new Configuration());
@@ -117,7 +123,9 @@ public class HeapMemStoreLAB implements MemStoreLAB {
       if (allocOffset != -1) {
         // We succeeded - this is the common case - small alloc
         // from a big buffer
-        return new SimpleMutableByteRange(c.data, allocOffset, size);
+        ByteRange alloc = ALLOC_HOLDER.get();
+        alloc.set(c.data, allocOffset, size);
+        return alloc;
       }
 
       // not enough space!
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMemStoreLAB.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMemStoreLAB.java
index 170bdd4..a0fcd2e 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMemStoreLAB.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMemStoreLAB.java
@@ -103,7 +103,7 @@ public class TestMemStoreLAB {
           int size = r.nextInt(1000);
           ByteRange alloc = mslab.allocateBytes(size);
           totalAllocated.addAndGet(size);
-          allocsByThisThread.add(new AllocRecord(alloc, size));
+          allocsByThisThread.add(new AllocRecord(alloc.getBytes(), alloc.getOffset(), size));
         }
       };
       ctx.addThread(t);
@@ -126,12 +126,12 @@ public class TestMemStoreLAB {
       if (rec.size == 0) continue;
       
       Map<Integer, AllocRecord> mapForThisByteArray =
-        mapsByChunk.get(rec.alloc.getBytes());
+        mapsByChunk.get(rec.alloc);
       if (mapForThisByteArray == null) {
         mapForThisByteArray = Maps.newTreeMap();
-        mapsByChunk.put(rec.alloc.getBytes(), mapForThisByteArray);
+        mapsByChunk.put(rec.alloc, mapForThisByteArray);
       }
-      AllocRecord oldVal = mapForThisByteArray.put(rec.alloc.getOffset(), rec);
+      AllocRecord oldVal = mapForThisByteArray.put(rec.offset, rec);
       assertNull("Already had an entry " + oldVal + " for allocation " + rec,
           oldVal);
     }
@@ -141,38 +141,37 @@ public class TestMemStoreLAB {
     for (Map<Integer, AllocRecord> allocsInChunk : mapsByChunk.values()) {
       int expectedOff = 0;
       for (AllocRecord alloc : allocsInChunk.values()) {
-        assertEquals(expectedOff, alloc.alloc.getOffset());
+        assertEquals(expectedOff, alloc.offset);
         assertTrue("Allocation overruns buffer",
-            alloc.alloc.getOffset() + alloc.size <= alloc.alloc.getBytes().length);
+            alloc.offset + alloc.size <= alloc.alloc.length);
         expectedOff += alloc.size;
       }
     }
-
   }
   
   private static class AllocRecord implements Comparable<AllocRecord>{
-    private final ByteRange alloc;
+    private final byte[] alloc;
+    private final int offset;
     private final int size;
-    public AllocRecord(ByteRange alloc, int size) {
-      super();
+
+    public AllocRecord(byte[] alloc, int offset, int size) {
       this.alloc = alloc;
+      this.offset = offset;
       this.size = size;
     }
 
     @Override
     public int compareTo(AllocRecord e) {
-      if (alloc.getBytes() != e.alloc.getBytes()) {
+      if (alloc != e.alloc) {
         throw new RuntimeException("Can only compare within a particular array");
       }
-      return Ints.compare(alloc.getOffset(), e.alloc.getOffset());
+      return Ints.compare(offset, e.offset);
     }
     
     @Override
     public String toString() {
-      return "AllocRecord(offset=" + alloc.getOffset() + ", size=" + size + ")";
+      return "AllocRecord(offset=" + offset + ", size=" + size + ")";
     }
-    
   }
-
 }
 
