diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java
index 2e6723a..a3b8b54 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java
@@ -17,7 +17,9 @@
  */
 package org.apache.hadoop.hbase;
 
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.util.ArrayList;
@@ -41,6 +43,7 @@ import org.apache.hadoop.hbase.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.client.ClusterConnection;
 import org.apache.hadoop.hbase.client.Connection;
 import org.apache.hadoop.hbase.client.ConnectionFactory;
+import org.apache.hadoop.hbase.client.Consistency;
 import org.apache.hadoop.hbase.client.Delete;
 import org.apache.hadoop.hbase.client.Get;
 import org.apache.hadoop.hbase.client.HTable;
@@ -60,6 +63,7 @@ import org.apache.hadoop.hbase.protobuf.generated.ClientProtos;
 import org.apache.hadoop.hbase.protobuf.generated.MultiRowMutationProtos;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;
+import org.apache.hadoop.hbase.util.ExceptionUtil;
 import org.apache.hadoop.hbase.util.Pair;
 import org.apache.hadoop.hbase.util.PairOfSameType;
 import org.apache.hadoop.hbase.util.Threads;
@@ -167,7 +171,7 @@ public class MetaTableAccessor {
   public static void fullScanRegions(Connection connection,
       final Visitor visitor)
       throws IOException {
-    fullScan(connection, visitor, null, QueryType.REGION);
+    scanMeta(connection, null, null, QueryType.REGION, visitor);
   }
 
   /**
@@ -189,20 +193,7 @@ public class MetaTableAccessor {
   public static void fullScanTables(Connection connection,
       final Visitor visitor)
       throws IOException {
-    fullScan(connection, visitor, null, QueryType.TABLE);
-  }
-
-  /**
-   * Performs a full scan of <code>hbase:meta</code>.
-   * @param connection connection we're using
-   * @param visitor Visitor invoked against each row.
-   * @param type scanned part of meta
-   * @throws IOException
-   */
-  public static void fullScan(Connection connection,
-      final Visitor visitor, QueryType type)
-  throws IOException {
-    fullScan(connection, visitor, null, type);
+    scanMeta(connection, null, null, QueryType.TABLE, visitor);
   }
 
   /**
@@ -215,7 +206,7 @@ public class MetaTableAccessor {
   public static List<Result> fullScan(Connection connection, QueryType type)
     throws IOException {
     CollectAllVisitor v = new CollectAllVisitor();
-    fullScan(connection, v, null, type);
+    scanMeta(connection, null, null, type, v);
     return v.getResults();
   }
 
@@ -441,15 +432,52 @@ public class MetaTableAccessor {
 
   /**
    * @param tableName table we're working with
-   * @return Place to start Scan in <code>hbase:meta</code> when passed a
-   * <code>tableName</code>; returns &lt;tableName&rt; &lt;,&rt; &lt;,&rt;
+   * @return start row for scanning META according to query type
    */
-  static byte [] getTableStartRowForMeta(TableName tableName) {
-    byte [] startRow = new byte[tableName.getName().length + 2];
-    System.arraycopy(tableName.getName(), 0, startRow, 0, tableName.getName().length);
-    startRow[startRow.length - 2] = HConstants.DELIMITER;
-    startRow[startRow.length - 1] = HConstants.DELIMITER;
-    return startRow;
+  public static byte[] getTableStartRowForMeta(TableName tableName, QueryType type) {
+    if (tableName == null) {
+      return null;
+    }
+    switch (type) {
+    case REGION:
+      byte[] startRow = new byte[tableName.getName().length + 2];
+      System.arraycopy(tableName.getName(), 0, startRow, 0, tableName.getName().length);
+      startRow[startRow.length - 2] = HConstants.DELIMITER;
+      startRow[startRow.length - 1] = HConstants.DELIMITER;
+      return startRow;
+    case ALL:
+    case TABLE:
+    default:
+      return tableName.getName();
+    }
+  }
+
+  /**
+   * @param tableName table we're working with
+   * @return stop row for scanning META according to query type
+   */
+  public static byte[] getTableStopRowForMeta(TableName tableName, QueryType type) {
+    if (tableName == null) {
+      return null;
+    }
+    final byte[] stopRow;
+    switch (type) {
+    case REGION:
+      stopRow = new byte[tableName.getName().length + 3];
+      System.arraycopy(tableName.getName(), 0, stopRow, 0, tableName.getName().length);
+      stopRow[stopRow.length - 3] = ' ';
+      stopRow[stopRow.length - 2] = HConstants.DELIMITER;
+      stopRow[stopRow.length - 1] = HConstants.DELIMITER;
+      break;
+    case ALL:
+    case TABLE:
+    default:
+      stopRow = new byte[tableName.getName().length + 1];
+      System.arraycopy(tableName.getName(), 0, stopRow, 0, tableName.getName().length);
+      stopRow[stopRow.length - 1] = ' ';
+      break;
+    }
+    return stopRow;
   }
 
   /**
@@ -461,18 +489,39 @@ public class MetaTableAccessor {
    * @param tableName bytes of table's name
    * @return configured Scan object
    */
-  public static Scan getScanForTableName(TableName tableName) {
-    String strName = tableName.getNameAsString();
+  @Deprecated
+  public static Scan getScanForTableName(Connection connection, TableName tableName) {
     // Start key is just the table name with delimiters
-    byte[] startKey = Bytes.toBytes(strName + ",,");
+    byte[] startKey = getTableStartRowForMeta(tableName, QueryType.REGION);
     // Stop key appends the smallest possible char to the table name
-    byte[] stopKey = Bytes.toBytes(strName + " ,,");
+    byte[] stopKey = getTableStopRowForMeta(tableName, QueryType.REGION);
 
-    Scan scan = new Scan(startKey);
+    Scan scan = getMetaScan(connection);
+    scan.setStartRow(startKey);
     scan.setStopRow(stopKey);
     return scan;
   }
 
+  private static Scan getMetaScan(Connection connection) {
+    return getMetaScan(connection, Integer.MAX_VALUE);
+  }
+
+  private static Scan getMetaScan(Connection connection, int rowUpperLimit) {
+    Scan scan = new Scan();
+    int scannerCaching = connection.getConfiguration()
+        .getInt(HConstants.HBASE_META_SCANNER_CACHING,
+            HConstants.DEFAULT_HBASE_META_SCANNER_CACHING);
+    if (connection.getConfiguration().getBoolean(HConstants.USE_META_REPLICAS,
+        HConstants.DEFAULT_USE_META_REPLICAS)) {
+      scan.setConsistency(Consistency.TIMELINE);
+    }
+    if (rowUpperLimit <= scannerCaching) {
+      scan.setSmall(true);
+    }
+    int rows = Math.min(rowUpperLimit, scannerCaching);
+    scan.setCaching(rows);
+    return scan;
+  }
   /**
    * Do not use this method to get meta table regions, use methods in MetaTableLocator instead.
    * @param connection connection we're using
@@ -514,7 +563,6 @@ public class MetaTableAccessor {
             return true;
           }
           HRegionInfo hri = current.getRegionLocation().getRegionInfo();
-          if (!isInsideTable(hri, tableName)) return false;
           if (excludeOfflinedSplitParents && hri.isSplitParent()) return true;
           // Else call super and add this Result to the collection.
           return super.visit(r);
@@ -533,7 +581,10 @@ public class MetaTableAccessor {
           }
         }
       };
-    fullScan(connection, visitor, getTableStartRowForMeta(tableName), QueryType.REGION);
+    scanMeta(connection,
+        getTableStartRowForMeta(tableName, QueryType.REGION),
+        getTableStopRowForMeta(tableName, QueryType.REGION),
+        QueryType.REGION, visitor);
     return visitor.getResults();
   }
 
@@ -565,7 +616,7 @@ public class MetaTableAccessor {
         }
       }
     };
-    fullScan(connection, v, QueryType.REGION);
+    scanMeta(connection, null, null, QueryType.REGION, v);
     return hris;
   }
 
@@ -591,62 +642,104 @@ public class MetaTableAccessor {
         return true;
       }
     };
-    fullScan(connection, v, QueryType.ALL);
+    scanMeta(connection, null, null, QueryType.ALL, v);
   }
 
-  /**
-   * Performs a full scan of a catalog table.
-   * @param connection connection we're using
-   * @param visitor Visitor invoked against each row.
-   * @param startrow Where to start the scan. Pass null if want to begin scan
-   * at first row.
-   * @param type scanned part of meta
-   * <code>hbase:meta</code>, the default (pass false to scan hbase:meta)
-   * @throws IOException
-   */
-  public static void fullScan(Connection connection,
-      final Visitor visitor, @Nullable final byte[] startrow, QueryType type) throws IOException {
-    fullScan(connection, visitor, startrow, type, false);
+  public static void scanMeta(Connection connection,
+      TableName table,
+      QueryType type, int maxRows, final Visitor visitor) throws IOException {
+    scanMeta(connection, getTableStartRowForMeta(table, type), getTableStopRowForMeta(table, type),
+        type, maxRows, visitor);
   }
 
+  public static void scanMeta(Connection connection,
+      @Nullable final byte[] startRow, @Nullable final byte[] stopRow,
+      QueryType type, final Visitor visitor) throws IOException {
+    scanMeta(connection, startRow, stopRow, type, Integer.MAX_VALUE, visitor);
+  }
+
+
   /**
-   * Performs a full scan of a catalog table.
+   * Performs a scan of META table.
    * @param connection connection we're using
-   * @param visitor Visitor invoked against each row.
-   * @param startrow Where to start the scan. Pass null if want to begin scan
-   * at first row.
+   * @param startRow Where to start the scan. Pass null if want to begin scan
+   *                 at first row.
+   * @param stopRow Where to stop the scan. Pass null if want to scan all rows
+   *                from the start one
    * @param type scanned part of meta
-   * @param raw read raw data including Delete tumbstones
-   * <code>hbase:meta</code>, the default (pass false to scan hbase:meta)
+   * @param raw read raw data including Delete tombstones
+   * @param maxRows maximum rows to return
+   * @param visitor Visitor invoked against each row.
    * @throws IOException
    */
-  public static void fullScan(Connection connection,
-      final Visitor visitor, @Nullable final byte[] startrow, QueryType type, boolean raw)
+  public static void scanMeta(Connection connection,
+      @Nullable final byte[] startRow, @Nullable final byte[] stopRow,
+      QueryType type, int maxRows, final Visitor visitor)
   throws IOException {
-    Scan scan = new Scan();
-    scan.setRaw(raw);
-    if (startrow != null) scan.setStartRow(startrow);
-    if (startrow == null) {
-      int caching = connection.getConfiguration()
-          .getInt(HConstants.HBASE_META_SCANNER_CACHING, 100);
-      scan.setCaching(caching);
-    }
+    int rowUpperLimit = maxRows > 0 ? maxRows : Integer.MAX_VALUE;
+    Scan scan = getMetaScan(connection, rowUpperLimit);
+
     for (byte[] family : type.getFamilies()) {
       scan.addFamily(family);
     }
-    Table metaTable = getMetaHTable(connection);
-    ResultScanner scanner = null;
-    try {
-      scanner = metaTable.getScanner(scan);
-      Result data;
-      while((data = scanner.next()) != null) {
-        if (data.isEmpty()) continue;
-        // Break if visit returns false.
-        if (!visitor.visit(data)) break;
+    if (startRow != null) scan.setStartRow(startRow);
+    if (stopRow != null) scan.setStopRow(stopRow);
+
+    if (LOG.isTraceEnabled()) {
+      LOG.trace("Scanning META"
+          + " starting at row=" + Bytes.toStringBinary(startRow)
+          + " stopping at row=" + Bytes.toStringBinary(stopRow)
+          + " for max=" + rowUpperLimit
+          + " with caching=" + scan.getCaching());
+    }
+
+    int currentRow = 0;
+    try (Table metaTable = getMetaHTable(connection)) {
+      try (ResultScanner scanner = metaTable.getScanner(scan)) {
+        Result data;
+        while ((data = scanner.next()) != null) {
+          if (data.isEmpty()) continue;
+          // Break if visit returns false.
+          if (!visitor.visit(data)) break;
+          if (++currentRow >= rowUpperLimit) break;
+        }
+      }
+    }
+    if (visitor != null && visitor instanceof Closeable) {
+      try {
+        ((Closeable) visitor).close();
+      } catch (Throwable t) {
+        ExceptionUtil.rethrowIfInterrupt(t);
+        LOG.debug("Got exception in closing the meta scanner visitor", t);
       }
-    } finally {
-      if (scanner != null) scanner.close();
-      metaTable.close();
+    }
+  }
+
+  /**
+   * @return Get closest metatable region row to passed <code>row</code>
+   * @throws java.io.IOException
+   */
+  @Nonnull
+  public static HRegionInfo getClosestRegionInfo(Connection connection,
+      @Nonnull final TableName tableName,
+      @Nonnull final byte[] row)
+      throws IOException {
+    byte[] searchRow = HRegionInfo.createRegionName(tableName, row, HConstants.NINES, false);
+    Scan scan = getMetaScan(connection, 1);
+    scan.setReversed(true);
+    scan.setStartRow(searchRow);
+    try (ResultScanner resultScanner = getMetaHTable(connection).getScanner(scan)) {
+      Result result = resultScanner.next();
+      if (result == null) {
+        throw new TableNotFoundException("Cannot find row in META " +
+            " for table: " + tableName + ", row=" + Bytes.toStringBinary(row));
+      }
+      HRegionInfo regionInfo = getHRegionInfo(result);
+      if (regionInfo == null) {
+        throw new IOException("HRegionInfo was null or empty in Meta for " +
+            tableName + ", row=" + Bytes.toStringBinary(row));
+      }
+      return regionInfo;
     }
   }
 
@@ -977,6 +1070,12 @@ public class MetaTableAccessor {
   }
 
   /**
+   * Implementations 'visit' a catalog table row but with close() at the end.
+   */
+  public interface CloseableVisitor extends Visitor, Closeable {
+  }
+
+  /**
    * A {@link Visitor} that collects content out of passed {@link Result}.
    */
   static abstract class CollectingVisitor<T> implements Visitor {
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/MetaScanner.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/MetaScanner.java
index 7d91dbb..ec86161 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/MetaScanner.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/MetaScanner.java
@@ -26,6 +26,7 @@ import java.util.List;
 import java.util.NavigableMap;
 import java.util.TreeMap;
 
+import com.google.common.annotations.VisibleForTesting;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.conf.Configuration;
@@ -41,8 +42,6 @@ import org.apache.hadoop.hbase.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.hbase.util.ExceptionUtil;
 
-import com.google.common.annotations.VisibleForTesting;
-
 /**
  * Scanner class that contains the <code>hbase:meta</code> table scanning logic.
  * Provided visitors will be called for each row.
@@ -120,117 +119,41 @@ public final class MetaScanner {
         .META_TABLE_NAME);
   }
 
-  /**
-   * Scans the meta table and calls a visitor on each RowResult. Uses a table
-   * name and a row name to locate meta regions. And it only scans at most
-   * <code>rowLimit</code> of rows.
-   *
-   * @param connection connection to use internally (null to use a new instance)
-   * @param visitor Visitor object. Closes the visitor before returning.
-   * @param tableName User table name in meta table to start scan at.  Pass
-   * null if not interested in a particular table.
-   * @param row Name of the row at the user table. The scan will start from
-   * the region row where the row resides.
-   * @param rowLimit Max of processed rows. If it is less than 0, it
-   * will be set to default value <code>Integer.MAX_VALUE</code>.
-   * @param metaTableName Meta table to scan, root or meta.
-   * @throws IOException e
-   */
   static void metaScan(Connection connection,
       final MetaScannerVisitor visitor, final TableName tableName,
       final byte[] row, final int rowLimit, final TableName metaTableName)
-    throws IOException {
+      throws IOException {
+    if (!metaTableName.equals(TableName.META_TABLE_NAME))
+      throw new IllegalStateException("Requested non META table");
 
-    int rowUpperLimit = rowLimit > 0 ? rowLimit: Integer.MAX_VALUE;
-    // Calculate startrow for scan.
-    byte[] startRow;
-    // If the passed in 'connection' is 'managed' -- i.e. every second test uses
-    // an HTable or an HBaseAdmin with managed connections -- then doing
-    // connection.getTable will throw an exception saying you are NOT to use
-    // managed connections getting tables.  Leaving this as it is for now. Will
-    // revisit when inclined to change all tests.  User code probaby makes use of
-    // managed connections too so don't change it till post hbase 1.0.
-    try (Table metaTable = new HTable(TableName.META_TABLE_NAME, connection, null)) {
-      if (row != null) {
-        // Scan starting at a particular row in a particular table
-        Result startRowResult = getClosestRowOrBefore(metaTable, tableName, row,
-            connection.getConfiguration().getBoolean(HConstants.USE_META_REPLICAS,
-                HConstants.DEFAULT_USE_META_REPLICAS));
-        if (startRowResult == null) {
-          throw new TableNotFoundException("Cannot find row in " + metaTable.getName() +
-            " for table: " + tableName + ", row=" + Bytes.toStringBinary(row));
-        }
-        HRegionInfo regionInfo = getHRegionInfo(startRowResult);
-        if (regionInfo == null) {
-          throw new IOException("HRegionInfo was null or empty in Meta for " +
-            tableName + ", row=" + Bytes.toStringBinary(row));
-        }
-        byte[] rowBefore = regionInfo.getStartKey();
-        startRow = HRegionInfo.createRegionName(tableName, rowBefore, HConstants.ZEROES, false);
-      } else if (tableName == null || tableName.getName().length == 0) {
-        // Full hbase:meta scan
-        startRow = HConstants.EMPTY_START_ROW;
-      } else {
-        // Scan hbase:meta for an entire table
-        startRow = HRegionInfo.createRegionName(tableName, HConstants.EMPTY_START_ROW,
-          HConstants.ZEROES, false);
-      }
-      final Scan scan = new Scan(startRow).addFamily(HConstants.CATALOG_FAMILY);
-      int scannerCaching = connection.getConfiguration()
-          .getInt(HConstants.HBASE_META_SCANNER_CACHING,
-              HConstants.DEFAULT_HBASE_META_SCANNER_CACHING);
-      if (connection.getConfiguration().getBoolean(HConstants.USE_META_REPLICAS,
-                HConstants.DEFAULT_USE_META_REPLICAS)) {
-        scan.setConsistency(Consistency.TIMELINE);
-      }
-      if (rowUpperLimit <= scannerCaching) {
-          scan.setSmall(true);
-      }
-      int rows = Math.min(rowLimit, scannerCaching);
-      scan.setCaching(rows);
-      if (LOG.isTraceEnabled()) {
-        LOG.trace("Scanning " + metaTableName.getNameAsString() + " starting at row=" +
-          Bytes.toStringBinary(startRow) + " for max=" + rowUpperLimit + " with caching=" + rows);
+    MetaTableAccessor.Visitor myVisitor = new MetaTableAccessor.CloseableVisitor() {
+      @Override
+      public void close() throws IOException {
+        visitor.close();
       }
-      // Run the scan
-      try (ResultScanner resultScanner = metaTable.getScanner(scan)) {
-        Result result;
-        int processedRows = 0;
-        while ((result = resultScanner.next()) != null) {
-          if (visitor != null) {
-            if (!visitor.processRow(result)) break;
-          }
-          processedRows++;
-          if (processedRows >= rowUpperLimit) break;
-        }
+
+      @Override
+      public boolean visit(Result r) throws IOException {
+        return visitor.processRow(r);
       }
-    } finally {
-      if (visitor != null) {
-        try {
-          visitor.close();
-        } catch (Throwable t) {
-          ExceptionUtil.rethrowIfInterrupt(t);
-          LOG.debug("Got exception in closing the meta scanner visitor", t);
-        }
+    };
+    byte[] startRow = null;
+    byte[] stopRow = null;
+    if (tableName != null) {
+      startRow =
+          MetaTableAccessor.getTableStartRowForMeta(tableName, MetaTableAccessor.QueryType.REGION);
+      if (row != null) {
+        HRegionInfo closestRi =
+            MetaTableAccessor.getClosestRegionInfo(connection, tableName, row);
+        startRow = HRegionInfo
+            .createRegionName(tableName, closestRi.getStartKey(), HConstants.ZEROES, false);
       }
+      stopRow =
+          MetaTableAccessor.getTableStopRowForMeta(tableName, MetaTableAccessor.QueryType.REGION);
     }
-  }
-
-  /**
-   * @return Get closest metatable region row to passed <code>row</code>
-   * @throws IOException
-   */
-  private static Result getClosestRowOrBefore(final Table metaTable, final TableName userTableName,
-      final byte [] row, boolean useMetaReplicas)
-  throws IOException {
-    byte[] searchRow = HRegionInfo.createRegionName(userTableName, row, HConstants.NINES, false);
-    Scan scan = Scan.createGetClosestRowOrBeforeReverseScan(searchRow);
-    if (useMetaReplicas) {
-      scan.setConsistency(Consistency.TIMELINE);
-    }
-    try (ResultScanner resultScanner = metaTable.getScanner(scan)) {
-      return resultScanner.next();
-    }
+    MetaTableAccessor
+        .scanMeta(connection, startRow, stopRow, MetaTableAccessor.QueryType.REGION, rowLimit,
+            myVisitor);
   }
 
   /**
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/master/handler/DeleteTableHandler.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/master/handler/DeleteTableHandler.java
index 7fcda15..b5b7555 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/master/handler/DeleteTableHandler.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/master/handler/DeleteTableHandler.java
@@ -35,6 +35,7 @@ import org.apache.hadoop.hbase.Server;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.backup.HFileArchiver;
 import org.apache.hadoop.hbase.classification.InterfaceAudience;
+import org.apache.hadoop.hbase.client.ClusterConnection;
 import org.apache.hadoop.hbase.client.Delete;
 import org.apache.hadoop.hbase.client.Result;
 import org.apache.hadoop.hbase.client.ResultScanner;
@@ -144,9 +145,10 @@ public class DeleteTableHandler extends TableEventHandler {
    * @throws IOException
    */
   private void cleanAnyRemainingRows() throws IOException {
-    Scan tableScan = MetaTableAccessor.getScanForTableName(tableName);
+    ClusterConnection connection = this.masterServices.getConnection();
+    Scan tableScan = MetaTableAccessor.getScanForTableName(connection, tableName);
     try (Table metaTable =
-        this.masterServices.getConnection().getTable(TableName.META_TABLE_NAME)) {
+        connection.getTable(TableName.META_TABLE_NAME)) {
       List<Delete> deletes = new ArrayList<Delete>();
       try (ResultScanner resScanner = metaTable.getScanner(tableScan)) {
         for (Result result : resScanner) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/master/handler/ModifyTableHandler.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/master/handler/ModifyTableHandler.java
index b35de6a..1cb0643 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/master/handler/ModifyTableHandler.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/master/handler/ModifyTableHandler.java
@@ -97,9 +97,9 @@ public class ModifyTableHandler extends TableEventHandler {
       TableName table) throws IOException {
     if (newReplicaCount >= oldReplicaCount) return;
     Set<byte[]> tableRows = new HashSet<byte[]>();
-    Scan scan = MetaTableAccessor.getScanForTableName(table);
-    scan.addColumn(HConstants.CATALOG_FAMILY, HConstants.REGIONINFO_QUALIFIER);
     Connection connection = this.masterServices.getConnection();
+    Scan scan = MetaTableAccessor.getScanForTableName(connection, table);
+    scan.addColumn(HConstants.CATALOG_FAMILY, HConstants.REGIONINFO_QUALIFIER);
     try (Table metaTable = connection.getTable(TableName.META_TABLE_NAME)) {
       ResultScanner resScanner = metaTable.getScanner(scan);
       for (Result result : resScanner) {
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/HBaseTestingUtility.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/HBaseTestingUtility.java
index 1a377fc..6912ea2 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/HBaseTestingUtility.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/HBaseTestingUtility.java
@@ -18,11 +18,6 @@
 package org.apache.hadoop.hbase;
 
 import javax.annotation.Nullable;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
 import java.io.File;
 import java.io.IOException;
 import java.io.OutputStream;
@@ -127,6 +122,10 @@ import org.apache.zookeeper.WatchedEvent;
 import org.apache.zookeeper.ZooKeeper;
 import org.apache.zookeeper.ZooKeeper.States;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 /**
  * Facility for testing HBase. Replacement for
  * old HBaseTestCase and HBaseClusterTestCase functionality.
@@ -2982,7 +2981,9 @@ public class HBaseTestingUtility extends HBaseCommonTestingUtility {
       }
     };
     MetaTableAccessor
-        .fullScan(connection, visitor, table.getName(), MetaTableAccessor.QueryType.TABLE, true);
+        .scanMeta(connection, null, null,
+            MetaTableAccessor.QueryType.TABLE,
+            Integer.MAX_VALUE, visitor);
     return lastTableState.get();
   }
 
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMetaScanner.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMetaScanner.java
index e195baf..5495d19 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMetaScanner.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMetaScanner.java
@@ -92,7 +92,7 @@ public class TestMetaScanner {
     // give us three hbase:meta rows
     reset(visitor);
     doReturn(true).when(visitor).processRow((Result)anyObject());
-    MetaScanner.metaScan(connection, visitor, TABLENAME, HConstants.EMPTY_BYTE_ARRAY, 1000);
+    MetaScanner.metaScan(connection, visitor, TABLENAME, null, 1000);
     verify(visitor, times(3)).processRow((Result)anyObject());
 
     // Scanning the table starting in the middle should give us two rows:
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/master/handler/TestEnableTableHandler.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/master/handler/TestEnableTableHandler.java
index d3d6239..9cc1963 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/master/handler/TestEnableTableHandler.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/master/handler/TestEnableTableHandler.java
@@ -18,19 +18,25 @@
  */
 package org.apache.hadoop.hbase.master.handler;
 
+import java.io.IOException;
 import java.util.List;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.hbase.HConstants;
-import org.apache.hadoop.hbase.MetaTableAccessor;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HRegionInfo;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.MetaTableAccessor;
 import org.apache.hadoop.hbase.MiniHBaseCluster;
 import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.Delete;
 import org.apache.hadoop.hbase.client.HBaseAdmin;
+import org.apache.hadoop.hbase.client.Result;
+import org.apache.hadoop.hbase.client.ResultScanner;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.client.Table;
 import org.apache.hadoop.hbase.master.HMaster;
 import org.apache.hadoop.hbase.testclassification.MasterTests;
 import org.apache.hadoop.hbase.testclassification.MediumTests;
@@ -44,13 +50,6 @@ import org.junit.experimental.categories.Category;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-import java.io.IOException;
-import org.apache.hadoop.hbase.client.Delete;
-import org.apache.hadoop.hbase.client.Result;
-import org.apache.hadoop.hbase.client.ResultScanner;
-import org.apache.hadoop.hbase.client.Scan;
-import org.apache.hadoop.hbase.client.Table;
-
 @Category({ MasterTests.class, MediumTests.class })
 public class TestEnableTableHandler {
   private static final HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();
@@ -127,7 +126,8 @@ public class TestEnableTableHandler {
     admin.createTable(desc, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);
     // Now I have a nice table, mangle it by removing the HConstants.REGIONINFO_QUALIFIER_STR
     // content from a few of the rows.
-    Scan metaScannerForMyTable = MetaTableAccessor.getScanForTableName(tableName);
+    Scan metaScannerForMyTable =
+        MetaTableAccessor.getScanForTableName(TEST_UTIL.getConnection(), tableName);
     try (Table metaTable = TEST_UTIL.getConnection().getTable(TableName.META_TABLE_NAME)) {
       try (ResultScanner scanner = metaTable.getScanner(metaScannerForMyTable)) {
         for (Result result : scanner) {
