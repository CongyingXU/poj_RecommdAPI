From 83e45b83aa883d955a2a13c26b11327f1baae06e Mon Sep 17 00:00:00 2001
From: Apekshit Sharma <appy@apache.org>
Date: Fri, 12 May 2017 15:42:45 -0700
Subject: [PATCH] Refactor out reader and writer from StoreFile.

Change-Id: I6f5747d0af4f5a05462f6f5b65bcc32945b9d7f5
---
 .../hbase/coprocessor/BaseRegionObserver.java      |  10 +-
 .../hadoop/hbase/coprocessor/RegionObserver.java   |   9 +-
 .../hadoop/hbase/io/HalfStoreFileReader.java       |   4 +-
 .../hadoop/hbase/mapreduce/HFileOutputFormat2.java |   5 +-
 .../hbase/mapreduce/LoadIncrementalHFiles.java     |   3 +-
 .../regionserver/AbstractMultiFileWriter.java      |  13 +-
 .../regionserver/DateTieredMultiFileWriter.java    |  13 +-
 .../hbase/regionserver/DefaultStoreFlusher.java    |   2 +-
 .../apache/hadoop/hbase/regionserver/HRegion.java  |   3 +-
 .../apache/hadoop/hbase/regionserver/HStore.java   |  32 +-
 .../hbase/regionserver/RegionCoprocessorHost.java  |  10 +-
 .../apache/hadoop/hbase/regionserver/Store.java    |   6 +-
 .../hadoop/hbase/regionserver/StoreFile.java       | 927 +--------------------
 .../hadoop/hbase/regionserver/StoreFileInfo.java   |   6 +-
 .../hadoop/hbase/regionserver/StoreFileReader.java | 597 +++++++++++++
 .../hbase/regionserver/StoreFileScanner.java       |   9 +-
 .../hadoop/hbase/regionserver/StoreFileWriter.java | 380 +++++++++
 .../hadoop/hbase/regionserver/StoreFlusher.java    |   2 +-
 .../hadoop/hbase/regionserver/StoreUtils.java      |   2 +-
 .../hbase/regionserver/StripeMultiFileWriter.java  |  15 +-
 .../hbase/regionserver/StripeStoreFlusher.java     |   5 +-
 .../compactions/AbstractMultiOutputCompactor.java  |   4 +-
 .../compactions/CompactionRequest.java             |   4 +-
 .../hbase/regionserver/compactions/Compactor.java  |   7 +-
 .../regionserver/compactions/DefaultCompactor.java |  12 +-
 .../hbase/util/CompoundBloomFilterWriter.java      |   3 +-
 .../hbase/coprocessor/SimpleRegionObserver.java    |  10 +-
 .../hadoop/hbase/io/hfile/TestCacheOnWrite.java    |   3 +-
 .../apache/hadoop/hbase/io/hfile/TestPrefetch.java |   3 +-
 .../io/hfile/TestSeekBeforeWithInlineBlocks.java   |   3 +-
 .../hbase/regionserver/CreateRandomStoreFile.java  |   2 +-
 .../hbase/regionserver/DataBlockEncodingTool.java  |   2 +-
 .../regionserver/EncodedSeekPerformanceTest.java   |   4 +-
 .../hadoop/hbase/regionserver/MockStoreFile.java   |   5 +-
 .../regionserver/TestCacheOnWriteInSchema.java     |   4 +-
 .../hadoop/hbase/regionserver/TestCompaction.java  |   2 +-
 .../regionserver/TestCompoundBloomFilter.java      |   4 +-
 .../hbase/regionserver/TestFSErrorsExposed.java    |   6 +-
 .../hadoop/hbase/regionserver/TestHRegion.java     |   4 +-
 .../hbase/regionserver/TestScanWithBloomError.java |   2 +-
 .../hadoop/hbase/regionserver/TestStore.java       |   6 +-
 .../hadoop/hbase/regionserver/TestStoreFile.java   |  63 +-
 .../TestStoreFileScannerWithTagCompression.java    |   6 +-
 .../hbase/regionserver/TestStripeStoreEngine.java  |   2 +-
 .../compactions/MockStoreFileGenerator.java        |   4 +-
 .../regionserver/compactions/TestCompactor.java    |  12 +-
 .../compactions/TestStripeCompactionPolicy.java    |   3 +-
 47 files changed, 1160 insertions(+), 1073 deletions(-)
 create mode 100644 hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileReader.java
 create mode 100644 hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileWriter.java

diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/BaseRegionObserver.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/BaseRegionObserver.java
index d6afec055e..7ebe0cbcf8 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/BaseRegionObserver.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/BaseRegionObserver.java
@@ -54,7 +54,7 @@ import org.apache.hadoop.hbase.regionserver.RegionScanner;
 import org.apache.hadoop.hbase.regionserver.ScanType;
 import org.apache.hadoop.hbase.regionserver.Store;
 import org.apache.hadoop.hbase.regionserver.StoreFile;
-import org.apache.hadoop.hbase.regionserver.StoreFile.Reader;
+import org.apache.hadoop.hbase.regionserver.StoreFileReader;
 import org.apache.hadoop.hbase.regionserver.compactions.CompactionRequest;
 import org.apache.hadoop.hbase.regionserver.querymatcher.DeleteTracker;
 import org.apache.hadoop.hbase.regionserver.wal.HLogKey;
@@ -513,16 +513,16 @@ public class BaseRegionObserver implements RegionObserver {
   }
 
   @Override
-  public Reader preStoreFileReaderOpen(ObserverContext<RegionCoprocessorEnvironment> ctx,
+  public StoreFileReader preStoreFileReaderOpen(ObserverContext<RegionCoprocessorEnvironment> ctx,
       FileSystem fs, Path p, FSDataInputStreamWrapper in, long size, CacheConfig cacheConf,
-      Reference r, Reader reader) throws IOException {
+      Reference r, StoreFileReader reader) throws IOException {
     return reader;
   }
 
   @Override
-  public Reader postStoreFileReaderOpen(ObserverContext<RegionCoprocessorEnvironment> ctx,
+  public StoreFileReader postStoreFileReaderOpen(ObserverContext<RegionCoprocessorEnvironment> ctx,
       FileSystem fs, Path p, FSDataInputStreamWrapper in, long size, CacheConfig cacheConf,
-      Reference r, Reader reader) throws IOException {
+      Reference r, StoreFileReader reader) throws IOException {
     return reader;
   }
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/RegionObserver.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/RegionObserver.java
index ad562314a7..958ecb6cef 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/RegionObserver.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/RegionObserver.java
@@ -54,6 +54,7 @@ import org.apache.hadoop.hbase.regionserver.RegionScanner;
 import org.apache.hadoop.hbase.regionserver.ScanType;
 import org.apache.hadoop.hbase.regionserver.Store;
 import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.regionserver.StoreFileReader;
 import org.apache.hadoop.hbase.regionserver.compactions.CompactionRequest;
 import org.apache.hadoop.hbase.regionserver.querymatcher.DeleteTracker;
 import org.apache.hadoop.hbase.regionserver.wal.HLogKey;
@@ -1290,9 +1291,9 @@ public interface RegionObserver extends Coprocessor {
    * default behavior, null otherwise
    * @throws IOException
    */
-  StoreFile.Reader preStoreFileReaderOpen(final ObserverContext<RegionCoprocessorEnvironment> ctx,
+  StoreFileReader preStoreFileReaderOpen(final ObserverContext<RegionCoprocessorEnvironment> ctx,
       final FileSystem fs, final Path p, final FSDataInputStreamWrapper in, long size,
-      final CacheConfig cacheConf, final Reference r, StoreFile.Reader reader) throws IOException;
+      final CacheConfig cacheConf, final Reference r, StoreFileReader reader) throws IOException;
 
   /**
    * Called after the creation of Reader for a store file.
@@ -1308,9 +1309,9 @@ public interface RegionObserver extends Coprocessor {
    * @return The reader to use
    * @throws IOException
    */
-  StoreFile.Reader postStoreFileReaderOpen(final ObserverContext<RegionCoprocessorEnvironment> ctx,
+  StoreFileReader postStoreFileReaderOpen(final ObserverContext<RegionCoprocessorEnvironment> ctx,
       final FileSystem fs, final Path p, final FSDataInputStreamWrapper in, long size,
-      final CacheConfig cacheConf, final Reference r, StoreFile.Reader reader) throws IOException;
+      final CacheConfig cacheConf, final Reference r, StoreFileReader reader) throws IOException;
 
   /**
    * Called after a new cell has been created during an increment operation, but before
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java
index ed2e92547a..1707df485f 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java
@@ -33,7 +33,7 @@ import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.client.Scan;
 import org.apache.hadoop.hbase.io.hfile.CacheConfig;
 import org.apache.hadoop.hbase.io.hfile.HFileScanner;
-import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.regionserver.StoreFileReader;
 import org.apache.hadoop.hbase.util.Bytes;
 
 /**
@@ -50,7 +50,7 @@ import org.apache.hadoop.hbase.util.Bytes;
  * <p>This file is not splitable.  Calls to {@link #midkey()} return null.
  */
 @InterfaceAudience.Private
-public class HalfStoreFileReader extends StoreFile.Reader {
+public class HalfStoreFileReader extends StoreFileReader {
   private static final Log LOG = LogFactory.getLog(HalfStoreFileReader.class);
   final boolean top;
   // This is the key we split around.  Its the first possible entry on a row:
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/HFileOutputFormat2.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/HFileOutputFormat2.java
index 616bb72d1c..9b5249191e 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/HFileOutputFormat2.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/HFileOutputFormat2.java
@@ -65,6 +65,7 @@ import org.apache.hadoop.hbase.io.hfile.HFileContextBuilder;
 import org.apache.hadoop.hbase.regionserver.BloomType;
 import org.apache.hadoop.hbase.regionserver.HStore;
 import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.regionserver.StoreFileWriter;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.io.NullWritable;
 import org.apache.hadoop.io.SequenceFile;
@@ -326,7 +327,7 @@ public class HFileOutputFormat2
         return wl;
       }
 
-      private void close(final StoreFile.Writer w) throws IOException {
+      private void close(final StoreFileWriter w) throws IOException {
         if (w != null) {
           w.appendFileInfo(StoreFile.BULKLOAD_TIME_KEY,
               Bytes.toBytes(System.currentTimeMillis()));
@@ -356,7 +357,7 @@ public class HFileOutputFormat2
    */
   static class WriterLength {
     long written = 0;
-    StoreFile.Writer writer = null;
+    StoreFileWriter writer = null;
   }
 
   /**
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/LoadIncrementalHFiles.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/LoadIncrementalHFiles.java
index 853b59d7e5..6ab8ced677 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/LoadIncrementalHFiles.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/LoadIncrementalHFiles.java
@@ -91,6 +91,7 @@ import org.apache.hadoop.hbase.regionserver.BloomType;
 import org.apache.hadoop.hbase.regionserver.HStore;
 import org.apache.hadoop.hbase.regionserver.StoreFile;
 import org.apache.hadoop.hbase.regionserver.StoreFileInfo;
+import org.apache.hadoop.hbase.regionserver.StoreFileWriter;
 import org.apache.hadoop.hbase.security.UserProvider;
 import org.apache.hadoop.hbase.security.access.SecureBulkLoadEndpoint;
 import org.apache.hadoop.hbase.security.token.FsDelegationToken;
@@ -955,7 +956,7 @@ public class LoadIncrementalHFiles extends Configured implements Tool {
     FileSystem fs = inFile.getFileSystem(conf);
     CacheConfig cacheConf = new CacheConfig(conf);
     HalfStoreFileReader halfReader = null;
-    StoreFile.Writer halfWriter = null;
+    StoreFileWriter halfWriter = null;
     try {
       halfReader = new HalfStoreFileReader(fs, inFile, cacheConf, reference, conf);
       Map<byte[], byte[]> fileInfo = halfReader.loadFileInfo();
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/AbstractMultiFileWriter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/AbstractMultiFileWriter.java
index 4987c59a3b..a4e0285941 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/AbstractMultiFileWriter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/AbstractMultiFileWriter.java
@@ -26,7 +26,6 @@ import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.classification.InterfaceAudience;
-import org.apache.hadoop.hbase.regionserver.StoreFile.Writer;
 import org.apache.hadoop.hbase.regionserver.compactions.Compactor.CellSink;
 
 /**
@@ -44,7 +43,7 @@ public abstract class AbstractMultiFileWriter implements CellSink {
   protected StoreScanner sourceScanner;
 
   public interface WriterFactory {
-    public StoreFile.Writer createWriter() throws IOException;
+    public StoreFileWriter createWriter() throws IOException;
   }
 
   /**
@@ -66,13 +65,13 @@ public abstract class AbstractMultiFileWriter implements CellSink {
    */
   public List<Path> commitWriters(long maxSeqId, boolean majorCompaction) throws IOException {
     preCommitWriters();
-    Collection<StoreFile.Writer> writers = this.writers();
+    Collection<StoreFileWriter> writers = this.writers();
     if (LOG.isDebugEnabled()) {
       LOG.debug("Commit " + writers.size() + " writers, maxSeqId=" + maxSeqId
           + ", majorCompaction=" + majorCompaction);
     }
     List<Path> paths = new ArrayList<Path>();
-    for (Writer writer : writers) {
+    for (StoreFileWriter writer : writers) {
       if (writer == null) {
         continue;
       }
@@ -89,7 +88,7 @@ public abstract class AbstractMultiFileWriter implements CellSink {
    */
   public List<Path> abortWriters() {
     List<Path> paths = new ArrayList<Path>();
-    for (StoreFile.Writer writer : writers()) {
+    for (StoreFileWriter writer : writers()) {
       try {
         if (writer != null) {
           paths.add(writer.getPath());
@@ -102,7 +101,7 @@ public abstract class AbstractMultiFileWriter implements CellSink {
     return paths;
   }
 
-  protected abstract Collection<StoreFile.Writer> writers();
+  protected abstract Collection<StoreFileWriter> writers();
 
   /**
    * Subclasses override this method to be called at the end of a successful sequence of append; all
@@ -115,6 +114,6 @@ public abstract class AbstractMultiFileWriter implements CellSink {
    * Subclasses override this method to be called before we close the give writer. Usually you can
    * append extra metadata to the writer.
    */
-  protected void preCloseWriter(StoreFile.Writer writer) throws IOException {
+  protected void preCloseWriter(StoreFileWriter writer) throws IOException {
   }
 }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DateTieredMultiFileWriter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DateTieredMultiFileWriter.java
index f0bd4447b9..2cea92f22d 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DateTieredMultiFileWriter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DateTieredMultiFileWriter.java
@@ -26,7 +26,6 @@ import java.util.TreeMap;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.classification.InterfaceAudience;
-import org.apache.hadoop.hbase.regionserver.StoreFile.Writer;
 
 /**
  * class for cell sink that separates the provided cells into multiple files for date tiered
@@ -35,8 +34,8 @@ import org.apache.hadoop.hbase.regionserver.StoreFile.Writer;
 @InterfaceAudience.Private
 public class DateTieredMultiFileWriter extends AbstractMultiFileWriter {
 
-  private final NavigableMap<Long, StoreFile.Writer> lowerBoundary2Writer
-    = new TreeMap<Long, StoreFile.Writer>();
+  private final NavigableMap<Long, StoreFileWriter> lowerBoundary2Writer
+    = new TreeMap<Long, StoreFileWriter>();
 
   private final boolean needEmptyFile;
 
@@ -53,8 +52,8 @@ public class DateTieredMultiFileWriter extends AbstractMultiFileWriter {
 
   @Override
   public void append(Cell cell) throws IOException {
-    Map.Entry<Long, StoreFile.Writer> entry = lowerBoundary2Writer.floorEntry(cell.getTimestamp());
-    StoreFile.Writer writer = entry.getValue();
+    Map.Entry<Long, StoreFileWriter> entry = lowerBoundary2Writer.floorEntry(cell.getTimestamp());
+    StoreFileWriter writer = entry.getValue();
     if (writer == null) {
       writer = writerFactory.createWriter();
       lowerBoundary2Writer.put(entry.getKey(), writer);
@@ -63,7 +62,7 @@ public class DateTieredMultiFileWriter extends AbstractMultiFileWriter {
   }
 
   @Override
-  protected Collection<Writer> writers() {
+  protected Collection<StoreFileWriter> writers() {
     return lowerBoundary2Writer.values();
   }
 
@@ -72,7 +71,7 @@ public class DateTieredMultiFileWriter extends AbstractMultiFileWriter {
     if (!needEmptyFile) {
       return;
     }
-    for (StoreFile.Writer writer : lowerBoundary2Writer.values()) {
+    for (StoreFileWriter writer : lowerBoundary2Writer.values()) {
       if (writer != null) {
         return;
       }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DefaultStoreFlusher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DefaultStoreFlusher.java
index 90c16f9921..cff0acb270 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DefaultStoreFlusher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DefaultStoreFlusher.java
@@ -57,7 +57,7 @@ public class DefaultStoreFlusher extends StoreFlusher {
       return result; // NULL scanner returned from coprocessor hooks means skip normal processing
     }
 
-    StoreFile.Writer writer;
+    StoreFileWriter writer;
     try {
       // TODO:  We can fail in the below block before we complete adding this flush to
       //        list of store files.  Add cleanup of anything put on filesystem if we fail.
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
index 8e1306f947..56367f8409 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
@@ -76,7 +76,6 @@ import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReadWriteLock;
-import java.util.concurrent.locks.ReentrantLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 import org.apache.commons.lang.RandomStringUtils;
@@ -1756,7 +1755,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
       Collection<StoreFile> storeFiles = store.getStorefiles();
       if (storeFiles == null) continue;
       for (StoreFile file : storeFiles) {
-        StoreFile.Reader sfReader = file.getReader();
+        StoreFileReader sfReader = file.getReader();
         if (sfReader == null) continue;
         HFile.Reader reader = sfReader.getHFileReader();
         if (reader == null) continue;
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java
index 4032a19519..2410fe23c0 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java
@@ -666,7 +666,7 @@ public class HStore implements Store {
     info.setRegionCoprocessorHost(this.region.getCoprocessorHost());
     StoreFile storeFile = new StoreFile(this.getFileSystem(), info, this.conf, this.cacheConf,
       this.family.getBloomFilterType());
-    StoreFile.Reader r = storeFile.createReader();
+    StoreFileReader r = storeFile.createReader();
     r.setReplicaStoreFile(isPrimaryReplicaStore());
     return storeFile;
   }
@@ -835,7 +835,7 @@ public class HStore implements Store {
   }
 
   private void bulkLoadHFile(StoreFile sf) throws IOException {
-    StoreFile.Reader r = sf.getReader();
+    StoreFileReader r = sf.getReader();
     this.storeSize += r.length();
     this.totalUncompressedBytes += r.getTotalUncompressedBytes();
 
@@ -1005,7 +1005,7 @@ public class HStore implements Store {
     status.setStatus("Flushing " + this + ": reopening flushed file");
     StoreFile sf = createStoreFileAndReader(dstPath);
 
-    StoreFile.Reader r = sf.getReader();
+    StoreFileReader r = sf.getReader();
     this.storeSize += r.length();
     this.totalUncompressedBytes += r.getTotalUncompressedBytes();
 
@@ -1018,7 +1018,7 @@ public class HStore implements Store {
   }
 
   @Override
-  public StoreFile.Writer createWriterInTmp(long maxKeyCount, Compression.Algorithm compression,
+  public StoreFileWriter createWriterInTmp(long maxKeyCount, Compression.Algorithm compression,
                                             boolean isCompaction, boolean includeMVCCReadpoint,
                                             boolean includesTag)
       throws IOException {
@@ -1035,7 +1035,7 @@ public class HStore implements Store {
    * @return Writer for a new StoreFile in the tmp dir.
    */
   @Override
-  public StoreFile.Writer createWriterInTmp(long maxKeyCount, Compression.Algorithm compression,
+  public StoreFileWriter createWriterInTmp(long maxKeyCount, Compression.Algorithm compression,
       boolean isCompaction, boolean includeMVCCReadpoint, boolean includesTag,
       boolean shouldDropBehind)
   throws IOException {
@@ -1052,7 +1052,7 @@ public class HStore implements Store {
    * @return Writer for a new StoreFile in the tmp dir.
    */
   @Override
-  public StoreFile.Writer createWriterInTmp(long maxKeyCount, Compression.Algorithm compression,
+  public StoreFileWriter createWriterInTmp(long maxKeyCount, Compression.Algorithm compression,
       boolean isCompaction, boolean includeMVCCReadpoint, boolean includesTag,
       boolean shouldDropBehind, final TimeRangeTracker trt)
   throws IOException {
@@ -1880,7 +1880,7 @@ public class HStore implements Store {
     this.storeSize = 0L;
     this.totalUncompressedBytes = 0L;
     for (StoreFile hsf : this.storeEngine.getStoreFileManager().getStorefiles()) {
-      StoreFile.Reader r = hsf.getReader();
+      StoreFileReader r = hsf.getReader();
       if (r == null) {
         LOG.warn("StoreFile " + hsf + " has a null Reader");
         continue;
@@ -1989,7 +1989,7 @@ public class HStore implements Store {
   private boolean rowAtOrBeforeFromStoreFile(final StoreFile f,
                                           final GetClosestRowBeforeTracker state)
       throws IOException {
-    StoreFile.Reader r = f.getReader();
+    StoreFileReader r = f.getReader();
     if (r == null) {
       LOG.warn("StoreFile " + f + " has a null Reader");
       return false;
@@ -2179,7 +2179,7 @@ public class HStore implements Store {
   public long getMaxStoreFileAge() {
     long earliestTS = Long.MAX_VALUE;
     for (StoreFile s: this.storeEngine.getStoreFileManager().getStorefiles()) {
-      StoreFile.Reader r = s.getReader();
+      StoreFileReader r = s.getReader();
       if (r == null) {
         LOG.warn("StoreFile " + s + " has a null Reader");
         continue;
@@ -2198,7 +2198,7 @@ public class HStore implements Store {
   public long getMinStoreFileAge() {
     long latestTS = 0;
     for (StoreFile s: this.storeEngine.getStoreFileManager().getStorefiles()) {
-      StoreFile.Reader r = s.getReader();
+      StoreFileReader r = s.getReader();
       if (r == null) {
         LOG.warn("StoreFile " + s + " has a null Reader");
         continue;
@@ -2217,7 +2217,7 @@ public class HStore implements Store {
   public long getAvgStoreFileAge() {
     long sum = 0, count = 0;
     for (StoreFile s: this.storeEngine.getStoreFileManager().getStorefiles()) {
-      StoreFile.Reader r = s.getReader();
+      StoreFileReader r = s.getReader();
       if (r == null) {
         LOG.warn("StoreFile " + s + " has a null Reader");
         continue;
@@ -2267,7 +2267,7 @@ public class HStore implements Store {
   public long getStorefilesSize() {
     long size = 0;
     for (StoreFile s: this.storeEngine.getStoreFileManager().getStorefiles()) {
-      StoreFile.Reader r = s.getReader();
+      StoreFileReader r = s.getReader();
       if (r == null) {
         LOG.warn("StoreFile " + s + " has a null Reader");
         continue;
@@ -2281,7 +2281,7 @@ public class HStore implements Store {
   public long getStorefilesIndexSize() {
     long size = 0;
     for (StoreFile s: this.storeEngine.getStoreFileManager().getStorefiles()) {
-      StoreFile.Reader r = s.getReader();
+      StoreFileReader r = s.getReader();
       if (r == null) {
         LOG.warn("StoreFile " + s + " has a null Reader");
         continue;
@@ -2295,7 +2295,7 @@ public class HStore implements Store {
   public long getTotalStaticIndexSize() {
     long size = 0;
     for (StoreFile s : this.storeEngine.getStoreFileManager().getStorefiles()) {
-      StoreFile.Reader r = s.getReader();
+      StoreFileReader r = s.getReader();
       if (r == null) {
         continue;
       }
@@ -2308,7 +2308,7 @@ public class HStore implements Store {
   public long getTotalStaticBloomSize() {
     long size = 0;
     for (StoreFile s : this.storeEngine.getStoreFileManager().getStorefiles()) {
-      StoreFile.Reader r = s.getReader();
+      StoreFileReader r = s.getReader();
       if (r == null) {
         continue;
       }
@@ -2716,7 +2716,7 @@ public class HStore implements Store {
     for (final StoreFile file : compactedfiles) {
       synchronized (file) {
         try {
-          StoreFile.Reader r = file.getReader();
+          StoreFileReader r = file.getReader();
           if (r == null) {
             if (LOG.isDebugEnabled()) {
               LOG.debug("The file " + file + " was closed but still not archived.");
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RegionCoprocessorHost.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RegionCoprocessorHost.java
index 74ecbc8c9f..7c33ddd4e8 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RegionCoprocessorHost.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RegionCoprocessorHost.java
@@ -1592,11 +1592,11 @@ public class RegionCoprocessorHost
    * default behavior, null otherwise
    * @throws IOException
    */
-  public StoreFile.Reader preStoreFileReaderOpen(final FileSystem fs, final Path p,
+  public StoreFileReader preStoreFileReaderOpen(final FileSystem fs, final Path p,
       final FSDataInputStreamWrapper in, final long size, final CacheConfig cacheConf,
       final Reference r) throws IOException {
     return execOperationWithResult(null,
-        coprocessors.isEmpty() ? null : new RegionOperationWithResult<StoreFile.Reader>() {
+        coprocessors.isEmpty() ? null : new RegionOperationWithResult<StoreFileReader>() {
       @Override
       public void call(RegionObserver oserver, ObserverContext<RegionCoprocessorEnvironment> ctx)
           throws IOException {
@@ -1616,11 +1616,11 @@ public class RegionCoprocessorHost
    * @return The reader to use
    * @throws IOException
    */
-  public StoreFile.Reader postStoreFileReaderOpen(final FileSystem fs, final Path p,
+  public StoreFileReader postStoreFileReaderOpen(final FileSystem fs, final Path p,
       final FSDataInputStreamWrapper in, final long size, final CacheConfig cacheConf,
-      final Reference r, final StoreFile.Reader reader) throws IOException {
+      final Reference r, final StoreFileReader reader) throws IOException {
     return execOperationWithResult(reader,
-        coprocessors.isEmpty() ? null : new RegionOperationWithResult<StoreFile.Reader>() {
+        coprocessors.isEmpty() ? null : new RegionOperationWithResult<StoreFileReader>() {
       @Override
       public void call(RegionObserver oserver, ObserverContext<RegionCoprocessorEnvironment> ctx)
           throws IOException {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/Store.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/Store.java
index 9d5d3b6ed8..f4b83502bf 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/Store.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/Store.java
@@ -195,7 +195,7 @@ public interface Store extends HeapSize, StoreConfigInformation, PropagatingConf
    * @param includeMVCCReadpoint whether we should out the MVCC readpoint
    * @return Writer for a new StoreFile in the tmp dir.
    */
-  StoreFile.Writer createWriterInTmp(
+  StoreFileWriter createWriterInTmp(
       long maxKeyCount,
       Compression.Algorithm compression,
       boolean isCompaction,
@@ -211,7 +211,7 @@ public interface Store extends HeapSize, StoreConfigInformation, PropagatingConf
    * @param shouldDropBehind should the writer drop caches behind writes
    * @return Writer for a new StoreFile in the tmp dir.
    */
-  StoreFile.Writer createWriterInTmp(
+  StoreFileWriter createWriterInTmp(
     long maxKeyCount,
     Compression.Algorithm compression,
     boolean isCompaction,
@@ -229,7 +229,7 @@ public interface Store extends HeapSize, StoreConfigInformation, PropagatingConf
    * @param trt Ready-made timetracker to use.
    * @return Writer for a new StoreFile in the tmp dir.
    */
-  StoreFile.Writer createWriterInTmp(
+  StoreFileWriter createWriterInTmp(
     long maxKeyCount,
     Compression.Algorithm compression,
     boolean isCompaction,
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFile.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFile.java
index 28c08926c7..b0325b26b3 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFile.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFile.java
@@ -18,48 +18,30 @@
  */
 package org.apache.hadoop.hbase.regionserver;
 
-import java.io.DataInput;
 import java.io.IOException;
 import java.net.InetSocketAddress;
-import java.nio.ByteBuffer;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Map;
-import java.util.SortedSet;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.FileSystem;
 import org.apache.hadoop.fs.Path;
-import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
-import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HDFSBlocksDistribution;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.KVComparator;
-import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.classification.InterfaceAudience;
-import org.apache.hadoop.hbase.client.Scan;
-import org.apache.hadoop.hbase.io.FSDataInputStreamWrapper;
-import org.apache.hadoop.hbase.io.TimeRange;
 import org.apache.hadoop.hbase.io.hfile.BlockType;
 import org.apache.hadoop.hbase.io.hfile.CacheConfig;
-import org.apache.hadoop.hbase.io.hfile.HFile;
 import org.apache.hadoop.hbase.io.hfile.HFileContext;
-import org.apache.hadoop.hbase.io.hfile.HFileScanner;
 import org.apache.hadoop.hbase.io.hfile.HFileWriterV2;
-import org.apache.hadoop.hbase.regionserver.compactions.Compactor;
-import org.apache.hadoop.hbase.util.BloomFilter;
 import org.apache.hadoop.hbase.util.BloomFilterFactory;
-import org.apache.hadoop.hbase.util.BloomFilterWriter;
 import org.apache.hadoop.hbase.util.Bytes;
-import org.apache.hadoop.io.WritableUtils;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Function;
@@ -106,7 +88,7 @@ public class StoreFile {
       Bytes.toBytes("DELETE_FAMILY_COUNT");
 
   /** Last Bloom filter key in FileInfo */
-  private static final byte[] LAST_BLOOM_KEY = Bytes.toBytes("LAST_BLOOM_KEY");
+  public static final byte[] LAST_BLOOM_KEY = Bytes.toBytes("LAST_BLOOM_KEY");
 
   /** Key for Timerange information in metadata*/
   public static final byte[] TIMERANGE_KEY = Bytes.toBytes("TIMERANGE");
@@ -395,7 +377,7 @@ public class StoreFile {
 
   @VisibleForTesting
   public int getRefCount() {
-    return this.reader.refCount.get();
+    return this.reader.getRefCount();
   }
 
   /**
@@ -426,7 +408,7 @@ public class StoreFile {
     }
 
     // Open the StoreFile.Reader
-    this.reader = fileInfo.open(this.fs, this.cacheConf, canUseDropBehind);
+    this.reader = (Reader) fileInfo.open(this.fs, this.cacheConf, canUseDropBehind);
 
     // Load up indices and fileinfo. This also loads Bloom filter type.
     metadataMap = Collections.unmodifiableMap(this.reader.loadFileInfo());
@@ -707,7 +689,7 @@ public class StoreFile {
     /**
      * Create a store file writer. Client is responsible for closing file when
      * done. If metadata, add BEFORE closing using
-     * {@link Writer#appendMetadata}.
+     * {@link StoreFileWriter#appendMetadata}.
      */
     public Writer build() throws IOException {
       if ((dir == null ? 0 : 1) + (filePath == null ? 0 : 1) != 1) {
@@ -798,894 +780,6 @@ public class StoreFile {
   }
 
   /**
-   * A StoreFile writer.  Use this to read/write HBase Store Files. It is package
-   * local because it is an implementation detail of the HBase regionserver.
-   */
-  public static class Writer implements Compactor.CellSink {
-    private final BloomFilterWriter generalBloomFilterWriter;
-    private final BloomFilterWriter deleteFamilyBloomFilterWriter;
-    private final BloomType bloomType;
-    private byte[] lastBloomKey;
-    private int lastBloomKeyOffset, lastBloomKeyLen;
-    private KVComparator kvComparator;
-    private Cell lastCell = null;
-    private long earliestPutTs = HConstants.LATEST_TIMESTAMP;
-    private Cell lastDeleteFamilyCell = null;
-    private long deleteFamilyCnt = 0;
-
-    /**
-     * timeRangeTrackerSet is used to figure if we were passed a filled-out TimeRangeTracker or not.
-     * When flushing a memstore, we set the TimeRangeTracker that it accumulated during updates to
-     * memstore in here into this Writer and use this variable to indicate that we do not need to
-     * recalculate the timeRangeTracker bounds; it was done already as part of add-to-memstore.
-     * A completed TimeRangeTracker is not set in cases of compactions when it is recalculated.
-     */
-    private final boolean timeRangeTrackerSet;
-    final TimeRangeTracker timeRangeTracker;
-
-    protected HFile.Writer writer;
-
-    /**
-     * Creates an HFile.Writer that also write helpful meta data.
-     * @param fs file system to write to
-     * @param path file name to create
-     * @param conf user configuration
-     * @param comparator key comparator
-     * @param bloomType bloom filter setting
-     * @param maxKeys the expected maximum number of keys to be added. Was used
-     *        for Bloom filter size in {@link HFile} format version 1.
-     * @param favoredNodes
-     * @param fileContext - The HFile context
-     * @param shouldDropCacheBehind Drop pages written to page cache after writing the store file.
-     * @throws IOException problem writing to FS
-     */
-    private Writer(FileSystem fs, Path path,
-        final Configuration conf,
-        CacheConfig cacheConf,
-        final KVComparator comparator, BloomType bloomType, long maxKeys,
-        InetSocketAddress[] favoredNodes, HFileContext fileContext, boolean shouldDropCacheBehind)
-            throws IOException {
-      this(fs, path, conf, cacheConf, comparator, bloomType, maxKeys, favoredNodes, fileContext,
-          shouldDropCacheBehind, null);
-    }
-
-    /**
-     * Creates an HFile.Writer that also write helpful meta data.
-     * @param fs file system to write to
-     * @param path file name to create
-     * @param conf user configuration
-     * @param comparator key comparator
-     * @param bloomType bloom filter setting
-     * @param maxKeys the expected maximum number of keys to be added. Was used
-     *        for Bloom filter size in {@link HFile} format version 1.
-     * @param favoredNodes
-     * @param fileContext - The HFile context
-     * @param shouldDropCacheBehind Drop pages written to page cache after writing the store file.
-     * @param trt Ready-made timetracker to use.
-     * @throws IOException problem writing to FS
-     */
-    private Writer(FileSystem fs, Path path,
-        final Configuration conf,
-        CacheConfig cacheConf,
-        final KVComparator comparator, BloomType bloomType, long maxKeys,
-        InetSocketAddress[] favoredNodes, HFileContext fileContext,
-        boolean shouldDropCacheBehind, final TimeRangeTracker trt)
-            throws IOException {
-      // If passed a TimeRangeTracker, use it. Set timeRangeTrackerSet so we don't destroy it.
-      // TODO: put the state of the TRT on the TRT; i.e. make a read-only version (TimeRange) when
-      // it no longer writable.
-      this.timeRangeTrackerSet = trt != null;
-      this.timeRangeTracker = this.timeRangeTrackerSet? trt: new TimeRangeTracker();
-      writer = HFile.getWriterFactory(conf, cacheConf)
-          .withPath(fs, path)
-          .withComparator(comparator)
-          .withFavoredNodes(favoredNodes)
-          .withFileContext(fileContext)
-          .withShouldDropCacheBehind(shouldDropCacheBehind)
-          .create();
-
-      this.kvComparator = comparator;
-
-      generalBloomFilterWriter = BloomFilterFactory.createGeneralBloomAtWrite(
-          conf, cacheConf, bloomType,
-          (int) Math.min(maxKeys, Integer.MAX_VALUE), writer);
-
-      if (generalBloomFilterWriter != null) {
-        this.bloomType = bloomType;
-        if (LOG.isTraceEnabled()) LOG.trace("Bloom filter type for " + path + ": " +
-          this.bloomType + ", " + generalBloomFilterWriter.getClass().getSimpleName());
-      } else {
-        // Not using Bloom filters.
-        this.bloomType = BloomType.NONE;
-      }
-
-      // initialize delete family Bloom filter when there is NO RowCol Bloom
-      // filter
-      if (this.bloomType != BloomType.ROWCOL) {
-        this.deleteFamilyBloomFilterWriter = BloomFilterFactory
-            .createDeleteBloomAtWrite(conf, cacheConf,
-                (int) Math.min(maxKeys, Integer.MAX_VALUE), writer);
-      } else {
-        deleteFamilyBloomFilterWriter = null;
-      }
-      if (deleteFamilyBloomFilterWriter != null) {
-        if (LOG.isTraceEnabled()) LOG.trace("Delete Family Bloom filter type for " + path + ": "
-            + deleteFamilyBloomFilterWriter.getClass().getSimpleName());
-      }
-    }
-
-    /**
-     * Writes meta data.
-     * Call before {@link #close()} since its written as meta data to this file.
-     * @param maxSequenceId Maximum sequence id.
-     * @param majorCompaction True if this file is product of a major compaction
-     * @throws IOException problem writing to FS
-     */
-    public void appendMetadata(final long maxSequenceId, final boolean majorCompaction)
-    throws IOException {
-      writer.appendFileInfo(MAX_SEQ_ID_KEY, Bytes.toBytes(maxSequenceId));
-      writer.appendFileInfo(MAJOR_COMPACTION_KEY,
-          Bytes.toBytes(majorCompaction));
-      appendTrackedTimestampsToMetadata();
-    }
-
-    /**
-     * Add TimestampRange and earliest put timestamp to Metadata
-     */
-    public void appendTrackedTimestampsToMetadata() throws IOException {
-      appendFileInfo(TIMERANGE_KEY,WritableUtils.toByteArray(timeRangeTracker));
-      appendFileInfo(EARLIEST_PUT_TS, Bytes.toBytes(earliestPutTs));
-    }
-
-    /**
-     * Record the earlest Put timestamp.
-     *
-     * If the timeRangeTracker is not set,
-     * update TimeRangeTracker to include the timestamp of this key
-     * @param cell
-     */
-    public void trackTimestamps(final Cell cell) {
-      if (KeyValue.Type.Put.getCode() == cell.getTypeByte()) {
-        earliestPutTs = Math.min(earliestPutTs, cell.getTimestamp());
-      }
-      if (!timeRangeTrackerSet) {
-        timeRangeTracker.includeTimestamp(cell);
-      }
-    }
-
-    private void appendGeneralBloomfilter(final Cell cell) throws IOException {
-      if (this.generalBloomFilterWriter != null) {
-        // only add to the bloom filter on a new, unique key
-        boolean newKey = true;
-        if (this.lastCell != null) {
-          switch(bloomType) {
-          case ROW:
-            newKey = ! kvComparator.matchingRows(cell, lastCell);
-            break;
-          case ROWCOL:
-            newKey = ! kvComparator.matchingRowColumn(cell, lastCell);
-            break;
-          case NONE:
-            newKey = false;
-            break;
-          default:
-            throw new IOException("Invalid Bloom filter type: " + bloomType +
-                " (ROW or ROWCOL expected)");
-          }
-        }
-        if (newKey) {
-          /*
-           * http://2.bp.blogspot.com/_Cib_A77V54U/StZMrzaKufI/AAAAAAAAADo/ZhK7bGoJdMQ/s400/KeyValue.png
-           * Key = RowLen + Row + FamilyLen + Column [Family + Qualifier] + TimeStamp
-           *
-           * 2 Types of Filtering:
-           *  1. Row = Row
-           *  2. RowCol = Row + Qualifier
-           */
-          byte[] bloomKey;
-          int bloomKeyOffset, bloomKeyLen;
-
-          switch (bloomType) {
-          case ROW:
-            bloomKey = cell.getRowArray();
-            bloomKeyOffset = cell.getRowOffset();
-            bloomKeyLen = cell.getRowLength();
-            break;
-          case ROWCOL:
-            // merge(row, qualifier)
-            // TODO: could save one buffer copy in case of compound Bloom
-            // filters when this involves creating a KeyValue
-            bloomKey = generalBloomFilterWriter.createBloomKey(cell.getRowArray(),
-                cell.getRowOffset(), cell.getRowLength(), cell.getQualifierArray(),
-                cell.getQualifierOffset(), cell.getQualifierLength());
-            bloomKeyOffset = 0;
-            bloomKeyLen = bloomKey.length;
-            break;
-          default:
-            throw new IOException("Invalid Bloom filter type: " + bloomType +
-                " (ROW or ROWCOL expected)");
-          }
-          generalBloomFilterWriter.add(bloomKey, bloomKeyOffset, bloomKeyLen);
-          if (lastBloomKey != null
-              && generalBloomFilterWriter.getComparator().compareFlatKey(bloomKey,
-                  bloomKeyOffset, bloomKeyLen, lastBloomKey,
-                  lastBloomKeyOffset, lastBloomKeyLen) <= 0) {
-            throw new IOException("Non-increasing Bloom keys: "
-                + Bytes.toStringBinary(bloomKey, bloomKeyOffset, bloomKeyLen)
-                + " after "
-                + Bytes.toStringBinary(lastBloomKey, lastBloomKeyOffset,
-                    lastBloomKeyLen));
-          }
-          lastBloomKey = bloomKey;
-          lastBloomKeyOffset = bloomKeyOffset;
-          lastBloomKeyLen = bloomKeyLen;
-          this.lastCell = cell;
-        }
-      }
-    }
-
-    private void appendDeleteFamilyBloomFilter(final Cell cell)
-        throws IOException {
-      if (!CellUtil.isDeleteFamily(cell) && !CellUtil.isDeleteFamilyVersion(cell)) {
-        return;
-      }
-
-      // increase the number of delete family in the store file
-      deleteFamilyCnt++;
-      if (null != this.deleteFamilyBloomFilterWriter) {
-        boolean newKey = true;
-        if (lastDeleteFamilyCell != null) {
-          newKey = !kvComparator.matchingRows(cell, lastDeleteFamilyCell);
-        }
-        if (newKey) {
-          this.deleteFamilyBloomFilterWriter.add(cell.getRowArray(),
-              cell.getRowOffset(), cell.getRowLength());
-          this.lastDeleteFamilyCell = cell;
-        }
-      }
-    }
-
-    public void append(final Cell cell) throws IOException {
-      appendGeneralBloomfilter(cell);
-      appendDeleteFamilyBloomFilter(cell);
-      writer.append(cell);
-      trackTimestamps(cell);
-    }
-
-    public Path getPath() {
-      return this.writer.getPath();
-    }
-
-    boolean hasGeneralBloom() {
-      return this.generalBloomFilterWriter != null;
-    }
-
-    /**
-     * For unit testing only.
-     *
-     * @return the Bloom filter used by this writer.
-     */
-    BloomFilterWriter getGeneralBloomWriter() {
-      return generalBloomFilterWriter;
-    }
-
-    private boolean closeBloomFilter(BloomFilterWriter bfw) throws IOException {
-      boolean haveBloom = (bfw != null && bfw.getKeyCount() > 0);
-      if (haveBloom) {
-        bfw.compactBloom();
-      }
-      return haveBloom;
-    }
-
-    private boolean closeGeneralBloomFilter() throws IOException {
-      boolean hasGeneralBloom = closeBloomFilter(generalBloomFilterWriter);
-
-      // add the general Bloom filter writer and append file info
-      if (hasGeneralBloom) {
-        writer.addGeneralBloomFilter(generalBloomFilterWriter);
-        writer.appendFileInfo(BLOOM_FILTER_TYPE_KEY,
-            Bytes.toBytes(bloomType.toString()));
-        if (lastBloomKey != null) {
-          writer.appendFileInfo(LAST_BLOOM_KEY, Arrays.copyOfRange(
-              lastBloomKey, lastBloomKeyOffset, lastBloomKeyOffset
-                  + lastBloomKeyLen));
-        }
-      }
-      return hasGeneralBloom;
-    }
-
-    private boolean closeDeleteFamilyBloomFilter() throws IOException {
-      boolean hasDeleteFamilyBloom = closeBloomFilter(deleteFamilyBloomFilterWriter);
-
-      // add the delete family Bloom filter writer
-      if (hasDeleteFamilyBloom) {
-        writer.addDeleteFamilyBloomFilter(deleteFamilyBloomFilterWriter);
-      }
-
-      // append file info about the number of delete family kvs
-      // even if there is no delete family Bloom.
-      writer.appendFileInfo(DELETE_FAMILY_COUNT,
-          Bytes.toBytes(this.deleteFamilyCnt));
-
-      return hasDeleteFamilyBloom;
-    }
-
-    public void close() throws IOException {
-      boolean hasGeneralBloom = this.closeGeneralBloomFilter();
-      boolean hasDeleteFamilyBloom = this.closeDeleteFamilyBloomFilter();
-
-      writer.close();
-
-      // Log final Bloom filter statistics. This needs to be done after close()
-      // because compound Bloom filters might be finalized as part of closing.
-      if (StoreFile.LOG.isTraceEnabled()) {
-        StoreFile.LOG.trace((hasGeneralBloom ? "" : "NO ") + "General Bloom and " +
-          (hasDeleteFamilyBloom ? "" : "NO ") + "DeleteFamily" + " was added to HFile " +
-          getPath());
-      }
-
-    }
-
-    public void appendFileInfo(byte[] key, byte[] value) throws IOException {
-      writer.appendFileInfo(key, value);
-    }
-
-    /** For use in testing, e.g. {@link org.apache.hadoop.hbase.regionserver.CreateRandomStoreFile}
-     */
-    HFile.Writer getHFileWriter() {
-      return writer;
-    }
-  }
-
-  /**
-   * Reader for a StoreFile.
-   */
-  public static class Reader {
-    private static final Log LOG = LogFactory.getLog(Reader.class.getName());
-
-    protected BloomFilter generalBloomFilter = null;
-    protected BloomFilter deleteFamilyBloomFilter = null;
-    protected BloomType bloomFilterType;
-    private final HFile.Reader reader;
-    protected TimeRange timeRange;
-    protected long sequenceID = -1;
-    private byte[] lastBloomKey;
-    private long deleteFamilyCnt = -1;
-    private boolean bulkLoadResult = false;
-    // Counter that is incremented every time a scanner is created on the
-    // store file. It is decremented when the scan on the store file is
-    // done.
-    private AtomicInteger refCount = new AtomicInteger(0);
-    // Indicates if the file got compacted
-    private volatile boolean compactedAway = false;
-
-    public Reader(FileSystem fs, Path path, CacheConfig cacheConf, Configuration conf)
-        throws IOException {
-      reader = HFile.createReader(fs, path, cacheConf, conf);
-      bloomFilterType = BloomType.NONE;
-    }
-
-    void markCompactedAway() {
-      this.compactedAway = true;
-    }
-
-    public Reader(FileSystem fs, Path path, FSDataInputStreamWrapper in, long size,
-        CacheConfig cacheConf, Configuration conf) throws IOException {
-      reader = HFile.createReader(fs, path, in, size, cacheConf, conf);
-      bloomFilterType = BloomType.NONE;
-    }
-
-    public void setReplicaStoreFile(boolean isPrimaryReplicaStoreFile) {
-      reader.setPrimaryReplicaReader(isPrimaryReplicaStoreFile);
-    }
-    public boolean isPrimaryReplicaReader() {
-      return reader.isPrimaryReplicaReader();
-    }
-
-    /**
-     * ONLY USE DEFAULT CONSTRUCTOR FOR UNIT TESTS
-     */
-    Reader() {
-      this.reader = null;
-    }
-
-    public KVComparator getComparator() {
-      return reader.getComparator();
-    }
-
-    /**
-     * Get a scanner to scan over this StoreFile.
-     * @param cacheBlocks should this scanner cache blocks?
-     * @param pread use pread (for highly concurrent small readers)
-     * @param isCompaction is scanner being used for compaction?
-     * @param scannerOrder Order of this scanner relative to other scanners. See
-     *          {@link KeyValueScanner#getScannerOrder()}.
-     * @param canOptimizeForNonNullColumn {@code true} if we can make sure there is no null column,
-     *          otherwise {@code false}. This is a hint for optimization.
-     * @return a scanner
-     */
-    public StoreFileScanner getStoreFileScanner(boolean cacheBlocks, boolean pread,
-        boolean isCompaction, long readPt, long scannerOrder, boolean canOptimizeForNonNullColumn) {
-      // Increment the ref count
-      refCount.incrementAndGet();
-      return new StoreFileScanner(this, getScanner(cacheBlocks, pread, isCompaction), !isCompaction,
-          reader.hasMVCCInfo(), readPt, scannerOrder, canOptimizeForNonNullColumn);
-    }
-
-    /**
-     * Decrement the ref count associated with the reader when ever a scanner associated
-     * with the reader is closed
-     */
-    void decrementRefCount() {
-      refCount.decrementAndGet();
-    }
-
-    /**
-     * @return true if the file is still used in reads
-     */
-    public boolean isReferencedInReads() {
-      return refCount.get() != 0;
-    }
-
-    /**
-     * @return true if the file is compacted
-     */
-    public boolean isCompactedAway() {
-      return this.compactedAway;
-    }
-
-    /**
-     * @deprecated Do not write further code which depends on this call. Instead
-     * use getStoreFileScanner() which uses the StoreFileScanner class/interface
-     * which is the preferred way to scan a store with higher level concepts.
-     *
-     * @param cacheBlocks should we cache the blocks?
-     * @param pread use pread (for concurrent small readers)
-     * @return the underlying HFileScanner
-     */
-    @Deprecated
-    public HFileScanner getScanner(boolean cacheBlocks, boolean pread) {
-      return getScanner(cacheBlocks, pread, false);
-    }
-
-    /**
-     * @deprecated Do not write further code which depends on this call. Instead
-     * use getStoreFileScanner() which uses the StoreFileScanner class/interface
-     * which is the preferred way to scan a store with higher level concepts.
-     *
-     * @param cacheBlocks
-     *          should we cache the blocks?
-     * @param pread
-     *          use pread (for concurrent small readers)
-     * @param isCompaction
-     *          is scanner being used for compaction?
-     * @return the underlying HFileScanner
-     */
-    @Deprecated
-    public HFileScanner getScanner(boolean cacheBlocks, boolean pread,
-        boolean isCompaction) {
-      return reader.getScanner(cacheBlocks, pread, isCompaction);
-    }
-
-    public void close(boolean evictOnClose) throws IOException {
-      reader.close(evictOnClose);
-    }
-
-    /**
-     * Check if this storeFile may contain keys within the TimeRange that
-     * have not expired (i.e. not older than oldestUnexpiredTS).
-     * @param tr the timeRange to restrict
-     * @param oldestUnexpiredTS the oldest timestamp that is not expired, as
-     *          determined by the column family's TTL
-     * @return false if queried keys definitely don't exist in this StoreFile
-     */
-    boolean passesTimerangeFilter(TimeRange tr, long oldestUnexpiredTS) {
-      return this.timeRange == null? true:
-        this.timeRange.includesTimeRange(tr) && this.timeRange.getMax() >= oldestUnexpiredTS;
-    }
-
-    /**
-     * Checks whether the given scan passes the Bloom filter (if present). Only
-     * checks Bloom filters for single-row or single-row-column scans. Bloom
-     * filter checking for multi-gets is implemented as part of the store
-     * scanner system (see {@link StoreFileScanner#seekExactly}) and uses
-     * the lower-level API {@link #passesGeneralBloomFilter(byte[], int, int, byte[],
-     * int, int)}.
-     *
-     * @param scan the scan specification. Used to determine the row, and to
-     *          check whether this is a single-row ("get") scan.
-     * @param columns the set of columns. Only used for row-column Bloom
-     *          filters.
-     * @return true if the scan with the given column set passes the Bloom
-     *         filter, or if the Bloom filter is not applicable for the scan.
-     *         False if the Bloom filter is applicable and the scan fails it.
-     */
-     boolean passesBloomFilter(Scan scan,
-        final SortedSet<byte[]> columns) {
-      // Multi-column non-get scans will use Bloom filters through the
-      // lower-level API function that this function calls.
-      if (!scan.isGetScan()) {
-        return true;
-      }
-
-      byte[] row = scan.getStartRow();
-      switch (this.bloomFilterType) {
-        case ROW:
-          return passesGeneralBloomFilter(row, 0, row.length, null, 0, 0);
-
-        case ROWCOL:
-          if (columns != null && columns.size() == 1) {
-            byte[] column = columns.first();
-            return passesGeneralBloomFilter(row, 0, row.length, column, 0,
-                column.length);
-          }
-
-          // For multi-column queries the Bloom filter is checked from the
-          // seekExact operation.
-          return true;
-
-        default:
-          return true;
-      }
-    }
-
-    public boolean passesDeleteFamilyBloomFilter(byte[] row, int rowOffset,
-        int rowLen) {
-      // Cache Bloom filter as a local variable in case it is set to null by
-      // another thread on an IO error.
-      BloomFilter bloomFilter = this.deleteFamilyBloomFilter;
-
-      // Empty file or there is no delete family at all
-      if (reader.getTrailer().getEntryCount() == 0 || deleteFamilyCnt == 0) {
-        return false;
-      }
-
-      if (bloomFilter == null) {
-        return true;
-      }
-
-      try {
-        if (!bloomFilter.supportsAutoLoading()) {
-          return true;
-        }
-        return bloomFilter.contains(row, rowOffset, rowLen, null);
-      } catch (IllegalArgumentException e) {
-        LOG.error("Bad Delete Family bloom filter data -- proceeding without",
-            e);
-        setDeleteFamilyBloomFilterFaulty();
-      }
-
-      return true;
-    }
-
-    /**
-     * A method for checking Bloom filters. Called directly from
-     * StoreFileScanner in case of a multi-column query.
-     *
-     * @param row
-     * @param rowOffset
-     * @param rowLen
-     * @param col
-     * @param colOffset
-     * @param colLen
-     * @return True if passes
-     */
-    public boolean passesGeneralBloomFilter(byte[] row, int rowOffset,
-        int rowLen, byte[] col, int colOffset, int colLen) {
-      // Cache Bloom filter as a local variable in case it is set to null by
-      // another thread on an IO error.
-      BloomFilter bloomFilter = this.generalBloomFilter;
-      if (bloomFilter == null) {
-        return true;
-      }
-
-      byte[] key;
-      switch (bloomFilterType) {
-        case ROW:
-          if (col != null) {
-            throw new RuntimeException("Row-only Bloom filter called with " +
-                "column specified");
-          }
-          if (rowOffset != 0 || rowLen != row.length) {
-              throw new AssertionError("For row-only Bloom filters the row "
-                  + "must occupy the whole array");
-          }
-          key = row;
-          break;
-
-        case ROWCOL:
-          key = bloomFilter.createBloomKey(row, rowOffset, rowLen, col,
-              colOffset, colLen);
-
-          break;
-
-        default:
-          return true;
-      }
-
-      // Empty file
-      if (reader.getTrailer().getEntryCount() == 0)
-        return false;
-
-      try {
-        boolean shouldCheckBloom;
-        ByteBuffer bloom;
-        if (bloomFilter.supportsAutoLoading()) {
-          bloom = null;
-          shouldCheckBloom = true;
-        } else {
-          bloom = reader.getMetaBlock(HFile.BLOOM_FILTER_DATA_KEY,
-              true);
-          shouldCheckBloom = bloom != null;
-        }
-
-        if (shouldCheckBloom) {
-          boolean exists;
-
-          // Whether the primary Bloom key is greater than the last Bloom key
-          // from the file info. For row-column Bloom filters this is not yet
-          // a sufficient condition to return false.
-          boolean keyIsAfterLast = lastBloomKey != null
-              && bloomFilter.getComparator().compareFlatKey(key, lastBloomKey) > 0;
-
-          if (bloomFilterType == BloomType.ROWCOL) {
-            // Since a Row Delete is essentially a DeleteFamily applied to all
-            // columns, a file might be skipped if using row+col Bloom filter.
-            // In order to ensure this file is included an additional check is
-            // required looking only for a row bloom.
-            byte[] rowBloomKey = bloomFilter.createBloomKey(row, rowOffset, rowLen,
-                null, 0, 0);
-
-            if (keyIsAfterLast
-                && bloomFilter.getComparator().compareFlatKey(rowBloomKey,
-                    lastBloomKey) > 0) {
-              exists = false;
-            } else {
-              exists =
-                  bloomFilter.contains(key, 0, key.length, bloom) ||
-                  bloomFilter.contains(rowBloomKey, 0, rowBloomKey.length,
-                      bloom);
-            }
-          } else {
-            exists = !keyIsAfterLast
-                && bloomFilter.contains(key, 0, key.length, bloom);
-          }
-
-          return exists;
-        }
-      } catch (IOException e) {
-        LOG.error("Error reading bloom filter data -- proceeding without",
-            e);
-        setGeneralBloomFilterFaulty();
-      } catch (IllegalArgumentException e) {
-        LOG.error("Bad bloom filter data -- proceeding without", e);
-        setGeneralBloomFilterFaulty();
-      }
-
-      return true;
-    }
-
-    /**
-     * Checks whether the given scan rowkey range overlaps with the current storefile's
-     * @param scan the scan specification. Used to determine the rowkey range.
-     * @return true if there is overlap, false otherwise
-     */
-    public boolean passesKeyRangeFilter(Scan scan) {
-      if (this.getFirstKey() == null || this.getLastKey() == null) {
-        // the file is empty
-        return false;
-      }
-      if (Bytes.equals(scan.getStartRow(), HConstants.EMPTY_START_ROW)
-          && Bytes.equals(scan.getStopRow(), HConstants.EMPTY_END_ROW)) {
-        return true;
-      }
-      KeyValue smallestScanKeyValue = scan.isReversed() ? KeyValueUtil
-          .createFirstOnRow(scan.getStopRow()) : KeyValueUtil.createFirstOnRow(scan
-          .getStartRow());
-      KeyValue largestScanKeyValue = scan.isReversed() ? KeyValueUtil
-          .createLastOnRow(scan.getStartRow()) : KeyValueUtil.createLastOnRow(scan
-          .getStopRow());
-      boolean nonOverLapping = (getComparator().compareFlatKey(
-          this.getFirstKey(), largestScanKeyValue.getKey()) > 0 && !Bytes
-          .equals(scan.isReversed() ? scan.getStartRow() : scan.getStopRow(),
-              HConstants.EMPTY_END_ROW))
-          || getComparator().compareFlatKey(this.getLastKey(),
-              smallestScanKeyValue.getKey()) < 0;
-      return !nonOverLapping;
-    }
-
-    public Map<byte[], byte[]> loadFileInfo() throws IOException {
-      Map<byte [], byte []> fi = reader.loadFileInfo();
-
-      byte[] b = fi.get(BLOOM_FILTER_TYPE_KEY);
-      if (b != null) {
-        bloomFilterType = BloomType.valueOf(Bytes.toString(b));
-      }
-
-      lastBloomKey = fi.get(LAST_BLOOM_KEY);
-      byte[] cnt = fi.get(DELETE_FAMILY_COUNT);
-      if (cnt != null) {
-        deleteFamilyCnt = Bytes.toLong(cnt);
-      }
-
-      return fi;
-    }
-
-    public void loadBloomfilter() {
-      this.loadBloomfilter(BlockType.GENERAL_BLOOM_META);
-      this.loadBloomfilter(BlockType.DELETE_FAMILY_BLOOM_META);
-    }
-
-    private void loadBloomfilter(BlockType blockType) {
-      try {
-        if (blockType == BlockType.GENERAL_BLOOM_META) {
-          if (this.generalBloomFilter != null)
-            return; // Bloom has been loaded
-
-          DataInput bloomMeta = reader.getGeneralBloomFilterMetadata();
-          if (bloomMeta != null) {
-            // sanity check for NONE Bloom filter
-            if (bloomFilterType == BloomType.NONE) {
-              throw new IOException(
-                  "valid bloom filter type not found in FileInfo");
-            } else {
-              generalBloomFilter = BloomFilterFactory.createFromMeta(bloomMeta,
-                  reader);
-              if (LOG.isTraceEnabled()) {
-                LOG.trace("Loaded " + bloomFilterType.toString() + " "
-                  + generalBloomFilter.getClass().getSimpleName()
-                  + " metadata for " + reader.getName());
-              }
-            }
-          }
-        } else if (blockType == BlockType.DELETE_FAMILY_BLOOM_META) {
-          if (this.deleteFamilyBloomFilter != null)
-            return; // Bloom has been loaded
-
-          DataInput bloomMeta = reader.getDeleteBloomFilterMetadata();
-          if (bloomMeta != null) {
-            deleteFamilyBloomFilter = BloomFilterFactory.createFromMeta(
-                bloomMeta, reader);
-            LOG.info("Loaded Delete Family Bloom ("
-                + deleteFamilyBloomFilter.getClass().getSimpleName()
-                + ") metadata for " + reader.getName());
-          }
-        } else {
-          throw new RuntimeException("Block Type: " + blockType.toString()
-              + "is not supported for Bloom filter");
-        }
-      } catch (IOException e) {
-        LOG.error("Error reading bloom filter meta for " + blockType
-            + " -- proceeding without", e);
-        setBloomFilterFaulty(blockType);
-      } catch (IllegalArgumentException e) {
-        LOG.error("Bad bloom filter meta " + blockType
-            + " -- proceeding without", e);
-        setBloomFilterFaulty(blockType);
-      }
-    }
-
-    private void setBloomFilterFaulty(BlockType blockType) {
-      if (blockType == BlockType.GENERAL_BLOOM_META) {
-        setGeneralBloomFilterFaulty();
-      } else if (blockType == BlockType.DELETE_FAMILY_BLOOM_META) {
-        setDeleteFamilyBloomFilterFaulty();
-      }
-    }
-
-    /**
-     * The number of Bloom filter entries in this store file, or an estimate
-     * thereof, if the Bloom filter is not loaded. This always returns an upper
-     * bound of the number of Bloom filter entries.
-     *
-     * @return an estimate of the number of Bloom filter entries in this file
-     */
-    public long getFilterEntries() {
-      return generalBloomFilter != null ? generalBloomFilter.getKeyCount()
-          : reader.getEntries();
-    }
-
-    public void setGeneralBloomFilterFaulty() {
-      generalBloomFilter = null;
-    }
-
-    public void setDeleteFamilyBloomFilterFaulty() {
-      this.deleteFamilyBloomFilter = null;
-    }
-
-    public byte[] getLastKey() {
-      return reader.getLastKey();
-    }
-
-    public byte[] getLastRowKey() {
-      return reader.getLastRowKey();
-    }
-
-    public byte[] midkey() throws IOException {
-      return reader.midkey();
-    }
-
-    public long length() {
-      return reader.length();
-    }
-
-    public long getTotalUncompressedBytes() {
-      return reader.getTrailer().getTotalUncompressedBytes();
-    }
-
-    public long getEntries() {
-      return reader.getEntries();
-    }
-
-    public long getDeleteFamilyCnt() {
-      return deleteFamilyCnt;
-    }
-
-    public byte[] getFirstKey() {
-      return reader.getFirstKey();
-    }
-
-    public long indexSize() {
-      return reader.indexSize();
-    }
-
-    public BloomType getBloomFilterType() {
-      return this.bloomFilterType;
-    }
-
-    public long getSequenceID() {
-      return sequenceID;
-    }
-
-    public void setSequenceID(long sequenceID) {
-      this.sequenceID = sequenceID;
-    }
-
-    public void setBulkLoaded(boolean bulkLoadResult) {
-      this.bulkLoadResult = bulkLoadResult;
-    }
-
-    public boolean isBulkLoaded() {
-      return this.bulkLoadResult;
-    }
-
-    BloomFilter getGeneralBloomFilter() {
-      return generalBloomFilter;
-    }
-
-    long getUncompressedDataIndexSize() {
-      return reader.getTrailer().getUncompressedDataIndexSize();
-    }
-
-    public long getTotalBloomSize() {
-      if (generalBloomFilter == null)
-        return 0;
-      return generalBloomFilter.getByteSize();
-    }
-
-    public int getHFileVersion() {
-      return reader.getTrailer().getMajorVersion();
-    }
-
-    public int getHFileMinorVersion() {
-      return reader.getTrailer().getMinorVersion();
-    }
-
-    public HFile.Reader getHFileReader() {
-      return reader;
-    }
-
-    void disableBloomFilterForTesting() {
-      generalBloomFilter = null;
-      this.deleteFamilyBloomFilter = null;
-    }
-
-    public long getMaxTimestamp() {
-      return timeRange == null ? TimeRange.INITIAL_MAX_TIMESTAMP: timeRange.getMax();
-    }
-  }
-
-  /**
    * Useful comparators for comparing StoreFiles.
    */
   public abstract static class Comparators {
@@ -1760,4 +854,17 @@ public class StoreFile {
       }
     }
   }
+
+  public static class Reader extends StoreFileReader {
+  }
+
+  public static class Writer extends StoreFileWriter {
+    public Writer(FileSystem fs, Path path, Configuration conf, CacheConfig cacheConf,
+        KVComparator comparator, BloomType bloomType, long maxKeys,
+        InetSocketAddress[] favoredNodes, HFileContext fileContext, boolean shouldDropCacheBehind,
+        TimeRangeTracker trt) throws IOException {
+      super(fs, path, conf, cacheConf, comparator, bloomType, maxKeys, favoredNodes, fileContext,
+          shouldDropCacheBehind, trt);
+    }
+  }
 }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileInfo.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileInfo.java
index 08259de092..c1c063af99 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileInfo.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileInfo.java
@@ -222,7 +222,7 @@ public class StoreFileInfo {
    * @param cacheConf The cache configuration and block cache reference.
    * @return The StoreFile.Reader for the file
    */
-  public StoreFile.Reader open(final FileSystem fs,
+  public StoreFileReader open(final FileSystem fs,
       final CacheConfig cacheConf, final boolean canUseDropBehind) throws IOException {
     FSDataInputStreamWrapper in;
     FileStatus status;
@@ -246,7 +246,7 @@ public class StoreFileInfo {
     long length = status.getLen();
     hdfsBlocksDistribution = computeHDFSBlocksDistribution(fs);
 
-    StoreFile.Reader reader = null;
+    StoreFileReader reader = null;
     if (this.coprocessorHost != null) {
       reader = this.coprocessorHost.preStoreFileReaderOpen(fs, this.getPath(), in, length,
         cacheConf, reference);
@@ -256,7 +256,7 @@ public class StoreFileInfo {
         reader = new HalfStoreFileReader(fs, this.getPath(), in, length, cacheConf, reference,
           conf);
       } else {
-        reader = new StoreFile.Reader(fs, status.getPath(), in, length, cacheConf, conf);
+        reader = new StoreFileReader(fs, status.getPath(), in, length, cacheConf, conf);
       }
     }
     if (this.coprocessorHost != null) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileReader.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileReader.java
new file mode 100644
index 0000000000..63446bd07c
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileReader.java
@@ -0,0 +1,597 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hbase.regionserver;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValueUtil;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.io.FSDataInputStreamWrapper;
+import org.apache.hadoop.hbase.io.TimeRange;
+import org.apache.hadoop.hbase.io.hfile.BlockType;
+import org.apache.hadoop.hbase.io.hfile.CacheConfig;
+import org.apache.hadoop.hbase.io.hfile.HFile;
+import org.apache.hadoop.hbase.io.hfile.HFileScanner;
+import org.apache.hadoop.hbase.util.BloomFilter;
+import org.apache.hadoop.hbase.util.BloomFilterFactory;
+import org.apache.hadoop.hbase.util.Bytes;
+
+import java.io.DataInput;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Map;
+import java.util.SortedSet;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Reader for a StoreFile.
+ */
+public class StoreFileReader {
+  private static final Log LOG = LogFactory.getLog(StoreFileReader.class.getName());
+
+  protected BloomFilter generalBloomFilter = null;
+  protected BloomFilter deleteFamilyBloomFilter = null;
+  protected BloomType bloomFilterType;
+  private final HFile.Reader reader;
+  protected TimeRange timeRange;
+  protected long sequenceID = -1;
+  private byte[] lastBloomKey;
+  private long deleteFamilyCnt = -1;
+  private boolean bulkLoadResult = false;
+  // Counter that is incremented every time a scanner is created on the
+  // store file. It is decremented when the scan on the store file is
+  // done.
+  private AtomicInteger refCount = new AtomicInteger(0);
+  // Indicates if the file got compacted
+  private volatile boolean compactedAway = false;
+
+  public StoreFileReader(FileSystem fs, Path path, CacheConfig cacheConf, Configuration conf)
+      throws IOException {
+    reader = HFile.createReader(fs, path, cacheConf, conf);
+    bloomFilterType = BloomType.NONE;
+  }
+
+  void markCompactedAway() {
+    this.compactedAway = true;
+  }
+
+  public StoreFileReader(FileSystem fs, Path path, FSDataInputStreamWrapper in, long size,
+      CacheConfig cacheConf, Configuration conf) throws IOException {
+    reader = HFile.createReader(fs, path, in, size, cacheConf, conf);
+    bloomFilterType = BloomType.NONE;
+  }
+
+  public void setReplicaStoreFile(boolean isPrimaryReplicaStoreFile) {
+    reader.setPrimaryReplicaReader(isPrimaryReplicaStoreFile);
+  }
+  public boolean isPrimaryReplicaReader() {
+    return reader.isPrimaryReplicaReader();
+  }
+
+  /**
+   * ONLY USE DEFAULT CONSTRUCTOR FOR UNIT TESTS
+   */
+  StoreFileReader() {
+    this.reader = null;
+  }
+
+  public KeyValue.KVComparator getComparator() {
+    return reader.getComparator();
+  }
+
+  /**
+   * Get a scanner to scan over this StoreFile.
+   * @param cacheBlocks should this scanner cache blocks?
+   * @param pread use pread (for highly concurrent small readers)
+   * @param isCompaction is scanner being used for compaction?
+   * @param scannerOrder Order of this scanner relative to other scanners. See
+   *          {@link KeyValueScanner#getScannerOrder()}.
+   * @param canOptimizeForNonNullColumn {@code true} if we can make sure there is no null column,
+   *          otherwise {@code false}. This is a hint for optimization.
+   * @return a scanner
+   */
+  public StoreFileScanner getStoreFileScanner(boolean cacheBlocks, boolean pread,
+      boolean isCompaction, long readPt, long scannerOrder, boolean canOptimizeForNonNullColumn) {
+    // Increment the ref count
+    refCount.incrementAndGet();
+    return new StoreFileScanner(this, getScanner(cacheBlocks, pread, isCompaction), !isCompaction,
+        reader.hasMVCCInfo(), readPt, scannerOrder, canOptimizeForNonNullColumn);
+  }
+
+  /**
+   * Decrement the ref count associated with the reader when ever a scanner associated
+   * with the reader is closed
+   */
+  void decrementRefCount() {
+    refCount.decrementAndGet();
+  }
+
+  int getRefCount() {
+    return refCount.get();
+  }
+
+  /**
+   * @return true if the file is still used in reads
+   */
+  public boolean isReferencedInReads() {
+    return refCount.get() != 0;
+  }
+
+  /**
+   * @return true if the file is compacted
+   */
+  public boolean isCompactedAway() {
+    return this.compactedAway;
+  }
+
+  /**
+   * @deprecated Do not write further code which depends on this call. Instead
+   * use getStoreFileScanner() which uses the StoreFileScanner class/interface
+   * which is the preferred way to scan a store with higher level concepts.
+   *
+   * @param cacheBlocks should we cache the blocks?
+   * @param pread use pread (for concurrent small readers)
+   * @return the underlying HFileScanner
+   */
+  @Deprecated
+  public HFileScanner getScanner(boolean cacheBlocks, boolean pread) {
+    return getScanner(cacheBlocks, pread, false);
+  }
+
+  /**
+   * @deprecated Do not write further code which depends on this call. Instead
+   * use getStoreFileScanner() which uses the StoreFileScanner class/interface
+   * which is the preferred way to scan a store with higher level concepts.
+   *
+   * @param cacheBlocks
+   *          should we cache the blocks?
+   * @param pread
+   *          use pread (for concurrent small readers)
+   * @param isCompaction
+   *          is scanner being used for compaction?
+   * @return the underlying HFileScanner
+   */
+  @Deprecated
+  public HFileScanner getScanner(boolean cacheBlocks, boolean pread,
+      boolean isCompaction) {
+    return reader.getScanner(cacheBlocks, pread, isCompaction);
+  }
+
+  public void close(boolean evictOnClose) throws IOException {
+    reader.close(evictOnClose);
+  }
+
+  /**
+   * Check if this storeFile may contain keys within the TimeRange that
+   * have not expired (i.e. not older than oldestUnexpiredTS).
+   * @param tr the timeRange to restrict
+   * @param oldestUnexpiredTS the oldest timestamp that is not expired, as
+   *          determined by the column family's TTL
+   * @return false if queried keys definitely don't exist in this StoreFile
+   */
+  boolean passesTimerangeFilter(TimeRange tr, long oldestUnexpiredTS) {
+    return this.timeRange == null? true:
+      this.timeRange.includesTimeRange(tr) && this.timeRange.getMax() >= oldestUnexpiredTS;
+  }
+
+  /**
+   * Checks whether the given scan passes the Bloom filter (if present). Only
+   * checks Bloom filters for single-row or single-row-column scans. Bloom
+   * filter checking for multi-gets is implemented as part of the store
+   * scanner system (see {@link StoreFileScanner#seekExactly}) and uses
+   * the lower-level API {@link #passesGeneralBloomFilter(byte[], int, int, byte[],
+   * int, int)}.
+   *
+   * @param scan the scan specification. Used to determine the row, and to
+   *          check whether this is a single-row ("get") scan.
+   * @param columns the set of columns. Only used for row-column Bloom
+   *          filters.
+   * @return true if the scan with the given column set passes the Bloom
+   *         filter, or if the Bloom filter is not applicable for the scan.
+   *         False if the Bloom filter is applicable and the scan fails it.
+   */
+   boolean passesBloomFilter(Scan scan,
+      final SortedSet<byte[]> columns) {
+    // Multi-column non-get scans will use Bloom filters through the
+    // lower-level API function that this function calls.
+    if (!scan.isGetScan()) {
+      return true;
+    }
+
+    byte[] row = scan.getStartRow();
+    switch (this.bloomFilterType) {
+      case ROW:
+        return passesGeneralBloomFilter(row, 0, row.length, null, 0, 0);
+
+      case ROWCOL:
+        if (columns != null && columns.size() == 1) {
+          byte[] column = columns.first();
+          return passesGeneralBloomFilter(row, 0, row.length, column, 0,
+              column.length);
+        }
+
+        // For multi-column queries the Bloom filter is checked from the
+        // seekExact operation.
+        return true;
+
+      default:
+        return true;
+    }
+  }
+
+  public boolean passesDeleteFamilyBloomFilter(byte[] row, int rowOffset,
+      int rowLen) {
+    // Cache Bloom filter as a local variable in case it is set to null by
+    // another thread on an IO error.
+    BloomFilter bloomFilter = this.deleteFamilyBloomFilter;
+
+    // Empty file or there is no delete family at all
+    if (reader.getTrailer().getEntryCount() == 0 || deleteFamilyCnt == 0) {
+      return false;
+    }
+
+    if (bloomFilter == null) {
+      return true;
+    }
+
+    try {
+      if (!bloomFilter.supportsAutoLoading()) {
+        return true;
+      }
+      return bloomFilter.contains(row, rowOffset, rowLen, null);
+    } catch (IllegalArgumentException e) {
+      LOG.error("Bad Delete Family bloom filter data -- proceeding without",
+          e);
+      setDeleteFamilyBloomFilterFaulty();
+    }
+
+    return true;
+  }
+
+  /**
+   * A method for checking Bloom filters. Called directly from
+   * StoreFileScanner in case of a multi-column query.
+   *
+   * @param row
+   * @param rowOffset
+   * @param rowLen
+   * @param col
+   * @param colOffset
+   * @param colLen
+   * @return True if passes
+   */
+  public boolean passesGeneralBloomFilter(byte[] row, int rowOffset,
+      int rowLen, byte[] col, int colOffset, int colLen) {
+    // Cache Bloom filter as a local variable in case it is set to null by
+    // another thread on an IO error.
+    BloomFilter bloomFilter = this.generalBloomFilter;
+    if (bloomFilter == null) {
+      return true;
+    }
+
+    byte[] key;
+    switch (bloomFilterType) {
+      case ROW:
+        if (col != null) {
+          throw new RuntimeException("Row-only Bloom filter called with " +
+              "column specified");
+        }
+        if (rowOffset != 0 || rowLen != row.length) {
+            throw new AssertionError("For row-only Bloom filters the row "
+                + "must occupy the whole array");
+        }
+        key = row;
+        break;
+
+      case ROWCOL:
+        key = bloomFilter.createBloomKey(row, rowOffset, rowLen, col,
+            colOffset, colLen);
+
+        break;
+
+      default:
+        return true;
+    }
+
+    // Empty file
+    if (reader.getTrailer().getEntryCount() == 0)
+      return false;
+
+    try {
+      boolean shouldCheckBloom;
+      ByteBuffer bloom;
+      if (bloomFilter.supportsAutoLoading()) {
+        bloom = null;
+        shouldCheckBloom = true;
+      } else {
+        bloom = reader.getMetaBlock(HFile.BLOOM_FILTER_DATA_KEY,
+            true);
+        shouldCheckBloom = bloom != null;
+      }
+
+      if (shouldCheckBloom) {
+        boolean exists;
+
+        // Whether the primary Bloom key is greater than the last Bloom key
+        // from the file info. For row-column Bloom filters this is not yet
+        // a sufficient condition to return false.
+        boolean keyIsAfterLast = lastBloomKey != null
+            && bloomFilter.getComparator().compareFlatKey(key, lastBloomKey) > 0;
+
+        if (bloomFilterType == BloomType.ROWCOL) {
+          // Since a Row Delete is essentially a DeleteFamily applied to all
+          // columns, a file might be skipped if using row+col Bloom filter.
+          // In order to ensure this file is included an additional check is
+          // required looking only for a row bloom.
+          byte[] rowBloomKey = bloomFilter.createBloomKey(row, rowOffset, rowLen,
+              null, 0, 0);
+
+          if (keyIsAfterLast
+              && bloomFilter.getComparator().compareFlatKey(rowBloomKey,
+                  lastBloomKey) > 0) {
+            exists = false;
+          } else {
+            exists =
+                bloomFilter.contains(key, 0, key.length, bloom) ||
+                bloomFilter.contains(rowBloomKey, 0, rowBloomKey.length,
+                    bloom);
+          }
+        } else {
+          exists = !keyIsAfterLast
+              && bloomFilter.contains(key, 0, key.length, bloom);
+        }
+
+        return exists;
+      }
+    } catch (IOException e) {
+      LOG.error("Error reading bloom filter data -- proceeding without",
+          e);
+      setGeneralBloomFilterFaulty();
+    } catch (IllegalArgumentException e) {
+      LOG.error("Bad bloom filter data -- proceeding without", e);
+      setGeneralBloomFilterFaulty();
+    }
+
+    return true;
+  }
+
+  /**
+   * Checks whether the given scan rowkey range overlaps with the current storefile's
+   * @param scan the scan specification. Used to determine the rowkey range.
+   * @return true if there is overlap, false otherwise
+   */
+  public boolean passesKeyRangeFilter(Scan scan) {
+    if (this.getFirstKey() == null || this.getLastKey() == null) {
+      // the file is empty
+      return false;
+    }
+    if (Bytes.equals(scan.getStartRow(), HConstants.EMPTY_START_ROW)
+        && Bytes.equals(scan.getStopRow(), HConstants.EMPTY_END_ROW)) {
+      return true;
+    }
+    KeyValue smallestScanKeyValue = scan.isReversed() ? KeyValueUtil
+        .createFirstOnRow(scan.getStopRow()) : KeyValueUtil.createFirstOnRow(scan
+        .getStartRow());
+    KeyValue largestScanKeyValue = scan.isReversed() ? KeyValueUtil
+        .createLastOnRow(scan.getStartRow()) : KeyValueUtil.createLastOnRow(scan
+        .getStopRow());
+    boolean nonOverLapping = (getComparator().compareFlatKey(
+        this.getFirstKey(), largestScanKeyValue.getKey()) > 0 && !Bytes
+        .equals(scan.isReversed() ? scan.getStartRow() : scan.getStopRow(),
+            HConstants.EMPTY_END_ROW))
+        || getComparator().compareFlatKey(this.getLastKey(),
+            smallestScanKeyValue.getKey()) < 0;
+    return !nonOverLapping;
+  }
+
+  public Map<byte[], byte[]> loadFileInfo() throws IOException {
+    Map<byte [], byte []> fi = reader.loadFileInfo();
+
+    byte[] b = fi.get(StoreFile.BLOOM_FILTER_TYPE_KEY);
+    if (b != null) {
+      bloomFilterType = BloomType.valueOf(Bytes.toString(b));
+    }
+
+    lastBloomKey = fi.get(StoreFile.LAST_BLOOM_KEY);
+    byte[] cnt = fi.get(StoreFile.DELETE_FAMILY_COUNT);
+    if (cnt != null) {
+      deleteFamilyCnt = Bytes.toLong(cnt);
+    }
+
+    return fi;
+  }
+
+  public void loadBloomfilter() {
+    this.loadBloomfilter(BlockType.GENERAL_BLOOM_META);
+    this.loadBloomfilter(BlockType.DELETE_FAMILY_BLOOM_META);
+  }
+
+  public void loadBloomfilter(BlockType blockType) {
+    try {
+      if (blockType == BlockType.GENERAL_BLOOM_META) {
+        if (this.generalBloomFilter != null)
+          return; // Bloom has been loaded
+
+        DataInput bloomMeta = reader.getGeneralBloomFilterMetadata();
+        if (bloomMeta != null) {
+          // sanity check for NONE Bloom filter
+          if (bloomFilterType == BloomType.NONE) {
+            throw new IOException(
+                "valid bloom filter type not found in FileInfo");
+          } else {
+            generalBloomFilter = BloomFilterFactory.createFromMeta(bloomMeta,
+                reader);
+            if (LOG.isTraceEnabled()) {
+              LOG.trace("Loaded " + bloomFilterType.toString() + " "
+                + generalBloomFilter.getClass().getSimpleName()
+                + " metadata for " + reader.getName());
+            }
+          }
+        }
+      } else if (blockType == BlockType.DELETE_FAMILY_BLOOM_META) {
+        if (this.deleteFamilyBloomFilter != null)
+          return; // Bloom has been loaded
+
+        DataInput bloomMeta = reader.getDeleteBloomFilterMetadata();
+        if (bloomMeta != null) {
+          deleteFamilyBloomFilter = BloomFilterFactory.createFromMeta(
+              bloomMeta, reader);
+          LOG.info("Loaded Delete Family Bloom ("
+              + deleteFamilyBloomFilter.getClass().getSimpleName()
+              + ") metadata for " + reader.getName());
+        }
+      } else {
+        throw new RuntimeException("Block Type: " + blockType.toString()
+            + "is not supported for Bloom filter");
+      }
+    } catch (IOException e) {
+      LOG.error("Error reading bloom filter meta for " + blockType
+          + " -- proceeding without", e);
+      setBloomFilterFaulty(blockType);
+    } catch (IllegalArgumentException e) {
+      LOG.error("Bad bloom filter meta " + blockType
+          + " -- proceeding without", e);
+      setBloomFilterFaulty(blockType);
+    }
+  }
+
+  private void setBloomFilterFaulty(BlockType blockType) {
+    if (blockType == BlockType.GENERAL_BLOOM_META) {
+      setGeneralBloomFilterFaulty();
+    } else if (blockType == BlockType.DELETE_FAMILY_BLOOM_META) {
+      setDeleteFamilyBloomFilterFaulty();
+    }
+  }
+
+  /**
+   * The number of Bloom filter entries in this store file, or an estimate
+   * thereof, if the Bloom filter is not loaded. This always returns an upper
+   * bound of the number of Bloom filter entries.
+   *
+   * @return an estimate of the number of Bloom filter entries in this file
+   */
+  public long getFilterEntries() {
+    return generalBloomFilter != null ? generalBloomFilter.getKeyCount()
+        : reader.getEntries();
+  }
+
+  public void setGeneralBloomFilterFaulty() {
+    generalBloomFilter = null;
+  }
+
+  public void setDeleteFamilyBloomFilterFaulty() {
+    this.deleteFamilyBloomFilter = null;
+  }
+
+  public byte[] getLastKey() {
+    return reader.getLastKey();
+  }
+
+  public byte[] getLastRowKey() {
+    return reader.getLastRowKey();
+  }
+
+  public byte[] midkey() throws IOException {
+    return reader.midkey();
+  }
+
+  public long length() {
+    return reader.length();
+  }
+
+  public long getTotalUncompressedBytes() {
+    return reader.getTrailer().getTotalUncompressedBytes();
+  }
+
+  public long getEntries() {
+    return reader.getEntries();
+  }
+
+  public long getDeleteFamilyCnt() {
+    return deleteFamilyCnt;
+  }
+
+  public byte[] getFirstKey() {
+    return reader.getFirstKey();
+  }
+
+  public long indexSize() {
+    return reader.indexSize();
+  }
+
+  public BloomType getBloomFilterType() {
+    return this.bloomFilterType;
+  }
+
+  public long getSequenceID() {
+    return sequenceID;
+  }
+
+  public void setSequenceID(long sequenceID) {
+    this.sequenceID = sequenceID;
+  }
+
+  public void setBulkLoaded(boolean bulkLoadResult) {
+    this.bulkLoadResult = bulkLoadResult;
+  }
+
+  public boolean isBulkLoaded() {
+    return this.bulkLoadResult;
+  }
+
+  BloomFilter getGeneralBloomFilter() {
+    return generalBloomFilter;
+  }
+
+  long getUncompressedDataIndexSize() {
+    return reader.getTrailer().getUncompressedDataIndexSize();
+  }
+
+  public long getTotalBloomSize() {
+    if (generalBloomFilter == null)
+      return 0;
+    return generalBloomFilter.getByteSize();
+  }
+
+  public int getHFileVersion() {
+    return reader.getTrailer().getMajorVersion();
+  }
+
+  public int getHFileMinorVersion() {
+    return reader.getTrailer().getMinorVersion();
+  }
+
+  public HFile.Reader getHFileReader() {
+    return reader;
+  }
+
+  void disableBloomFilterForTesting() {
+    generalBloomFilter = null;
+    this.deleteFamilyBloomFilter = null;
+  }
+
+  public long getMaxTimestamp() {
+    return timeRange == null ? TimeRange.INITIAL_MAX_TIMESTAMP: timeRange.getMax();
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java
index 975d3c77c9..6183c42c3e 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java
@@ -38,7 +38,6 @@ import org.apache.hadoop.hbase.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.client.Scan;
 import org.apache.hadoop.hbase.io.TimeRange;
 import org.apache.hadoop.hbase.io.hfile.HFileScanner;
-import org.apache.hadoop.hbase.regionserver.StoreFile.Reader;
 import org.apache.hadoop.hbase.regionserver.querymatcher.ScanQueryMatcher;
 
 /**
@@ -50,7 +49,7 @@ public class StoreFileScanner implements KeyValueScanner {
   private static final Log LOG = LogFactory.getLog(HStore.class);
 
   // the reader it comes from:
-  private final StoreFile.Reader reader;
+  private final StoreFileReader reader;
   private final HFileScanner hfs;
   private Cell cur = null;
   private boolean closed = false;
@@ -85,7 +84,7 @@ public class StoreFileScanner implements KeyValueScanner {
    * @param canOptimizeForNonNullColumn {@code true} if we can make sure there is no null column,
    *          otherwise {@code false}. This is a hint for optimization.
    */
-  public StoreFileScanner(StoreFile.Reader reader, HFileScanner hfs, boolean useMVCC,
+  public StoreFileScanner(StoreFileReader reader, HFileScanner hfs, boolean useMVCC,
       boolean hasMVCC, long readPt, long scannerOrder, boolean canOptimizeForNonNullColumn) {
     this.readPt = readPt;
     this.reader = reader;
@@ -133,7 +132,7 @@ public class StoreFileScanner implements KeyValueScanner {
     List<StoreFile> sorted_files = new ArrayList<>(files);
     Collections.sort(sorted_files, StoreFile.Comparators.SEQ_ID);
     for (int i = 0; i < sorted_files.size(); i++) {
-      StoreFile.Reader r = sorted_files.get(i).createReader(canUseDrop);
+      StoreFileReader r = sorted_files.get(i).createReader(canUseDrop);
       r.setReplicaStoreFile(isPrimaryReplica);
       StoreFileScanner scanner = r.getStoreFileScanner(cacheBlocks, usePread, isCompaction, readPt,
         i, matcher != null ? !matcher.hasNullColumnInQuery() : false);
@@ -405,7 +404,7 @@ public class StoreFileScanner implements KeyValueScanner {
     return true;
   }
 
-  Reader getReader() {
+  StoreFileReader getReader() {
     return reader;
   }
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileWriter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileWriter.java
new file mode 100644
index 0000000000..a76b777f57
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileWriter.java
@@ -0,0 +1,380 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hbase.regionserver;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.io.hfile.CacheConfig;
+import org.apache.hadoop.hbase.io.hfile.HFile;
+import org.apache.hadoop.hbase.io.hfile.HFileContext;
+import org.apache.hadoop.hbase.regionserver.compactions.Compactor;
+import org.apache.hadoop.hbase.util.BloomFilterFactory;
+import org.apache.hadoop.hbase.util.BloomFilterWriter;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.io.WritableUtils;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.util.Arrays;
+
+/**
+ * A StoreFile writer.  Use this to read/write HBase Store Files. It is package
+ * local because it is an implementation detail of the HBase regionserver.
+ */
+public class StoreFileWriter implements Compactor.CellSink {
+  private static final Log LOG = LogFactory.getLog(StoreFileWriter.class);
+  private final BloomFilterWriter generalBloomFilterWriter;
+  private final BloomFilterWriter deleteFamilyBloomFilterWriter;
+  private final BloomType bloomType;
+  private byte[] lastBloomKey;
+  private int lastBloomKeyOffset, lastBloomKeyLen;
+  private KeyValue.KVComparator kvComparator;
+  private Cell lastCell = null;
+  private long earliestPutTs = HConstants.LATEST_TIMESTAMP;
+  private Cell lastDeleteFamilyCell = null;
+  private long deleteFamilyCnt = 0;
+
+  /**
+   * timeRangeTrackerSet is used to figure if we were passed a filled-out TimeRangeTracker or not.
+   * When flushing a memstore, we set the TimeRangeTracker that it accumulated during updates to
+   * memstore in here into this Writer and use this variable to indicate that we do not need to
+   * recalculate the timeRangeTracker bounds; it was done already as part of add-to-memstore.
+   * A completed TimeRangeTracker is not set in cases of compactions when it is recalculated.
+   */
+  private final boolean timeRangeTrackerSet;
+  final TimeRangeTracker timeRangeTracker;
+
+  protected HFile.Writer writer;
+
+  /**
+   * Creates an HFile.Writer that also write helpful meta data.
+   * @param fs file system to write to
+   * @param path file name to create
+   * @param conf user configuration
+   * @param comparator key comparator
+   * @param bloomType bloom filter setting
+   * @param maxKeys the expected maximum number of keys to be added. Was used
+   *        for Bloom filter size in {@link HFile} format version 1.
+   * @param favoredNodes
+   * @param fileContext - The HFile context
+   * @param shouldDropCacheBehind Drop pages written to page cache after writing the store file.
+   * @throws IOException problem writing to FS
+   */
+  private StoreFileWriter(FileSystem fs, Path path,
+      final Configuration conf,
+      CacheConfig cacheConf,
+      final KeyValue.KVComparator comparator, BloomType bloomType, long maxKeys,
+      InetSocketAddress[] favoredNodes, HFileContext fileContext, boolean shouldDropCacheBehind)
+          throws IOException {
+    this(fs, path, conf, cacheConf, comparator, bloomType, maxKeys, favoredNodes, fileContext,
+        shouldDropCacheBehind, null);
+  }
+
+  /**
+   * Creates an HFile.Writer that also write helpful meta data.
+   * @param fs file system to write to
+   * @param path file name to create
+   * @param conf user configuration
+   * @param comparator key comparator
+   * @param bloomType bloom filter setting
+   * @param maxKeys the expected maximum number of keys to be added. Was used
+   *        for Bloom filter size in {@link HFile} format version 1.
+   * @param favoredNodes
+   * @param fileContext - The HFile context
+   * @param shouldDropCacheBehind Drop pages written to page cache after writing the store file.
+   * @param trt Ready-made timetracker to use.
+   * @throws IOException problem writing to FS
+   */
+  StoreFileWriter(FileSystem fs, Path path, final Configuration conf, CacheConfig cacheConf,
+      final KeyValue.KVComparator comparator, BloomType bloomType, long maxKeys,
+      InetSocketAddress[] favoredNodes, HFileContext fileContext, boolean shouldDropCacheBehind,
+      final TimeRangeTracker trt)
+          throws IOException {
+    // If passed a TimeRangeTracker, use it. Set timeRangeTrackerSet so we don't destroy it.
+    // TODO: put the state of the TRT on the TRT; i.e. make a read-only version (TimeRange) when
+    // it no longer writable.
+    this.timeRangeTrackerSet = trt != null;
+    this.timeRangeTracker = this.timeRangeTrackerSet? trt: new TimeRangeTracker();
+    writer = HFile.getWriterFactory(conf, cacheConf)
+        .withPath(fs, path)
+        .withComparator(comparator)
+        .withFavoredNodes(favoredNodes)
+        .withFileContext(fileContext)
+        .withShouldDropCacheBehind(shouldDropCacheBehind)
+        .create();
+
+    this.kvComparator = comparator;
+
+    generalBloomFilterWriter = BloomFilterFactory.createGeneralBloomAtWrite(
+        conf, cacheConf, bloomType,
+        (int) Math.min(maxKeys, Integer.MAX_VALUE), writer);
+
+    if (generalBloomFilterWriter != null) {
+      this.bloomType = bloomType;
+      if (LOG.isTraceEnabled()) LOG.trace("Bloom filter type for " + path + ": " +
+        this.bloomType + ", " + generalBloomFilterWriter.getClass().getSimpleName());
+    } else {
+      // Not using Bloom filters.
+      this.bloomType = BloomType.NONE;
+    }
+
+    // initialize delete family Bloom filter when there is NO RowCol Bloom
+    // filter
+    if (this.bloomType != BloomType.ROWCOL) {
+      this.deleteFamilyBloomFilterWriter = BloomFilterFactory
+          .createDeleteBloomAtWrite(conf, cacheConf,
+              (int) Math.min(maxKeys, Integer.MAX_VALUE), writer);
+    } else {
+      deleteFamilyBloomFilterWriter = null;
+    }
+    if (deleteFamilyBloomFilterWriter != null) {
+      if (LOG.isTraceEnabled()) LOG.trace("Delete Family Bloom filter type for " + path + ": "
+          + deleteFamilyBloomFilterWriter.getClass().getSimpleName());
+    }
+  }
+
+  /**
+   * Writes meta data.
+   * Call before {@link #close()} since its written as meta data to this file.
+   * @param maxSequenceId Maximum sequence id.
+   * @param majorCompaction True if this file is product of a major compaction
+   * @throws IOException problem writing to FS
+   */
+  public void appendMetadata(final long maxSequenceId, final boolean majorCompaction)
+  throws IOException {
+    writer.appendFileInfo(StoreFile.MAX_SEQ_ID_KEY, Bytes.toBytes(maxSequenceId));
+    writer.appendFileInfo(StoreFile.MAJOR_COMPACTION_KEY,
+        Bytes.toBytes(majorCompaction));
+    appendTrackedTimestampsToMetadata();
+  }
+
+  /**
+   * Add TimestampRange and earliest put timestamp to Metadata
+   */
+  public void appendTrackedTimestampsToMetadata() throws IOException {
+    appendFileInfo(StoreFile.TIMERANGE_KEY, WritableUtils.toByteArray(timeRangeTracker));
+    appendFileInfo(StoreFile.EARLIEST_PUT_TS, Bytes.toBytes(earliestPutTs));
+  }
+
+  /**
+   * Record the earlest Put timestamp.
+   *
+   * If the timeRangeTracker is not set,
+   * update TimeRangeTracker to include the timestamp of this key
+   * @param cell
+   */
+  public void trackTimestamps(final Cell cell) {
+    if (KeyValue.Type.Put.getCode() == cell.getTypeByte()) {
+      earliestPutTs = Math.min(earliestPutTs, cell.getTimestamp());
+    }
+    if (!timeRangeTrackerSet) {
+      timeRangeTracker.includeTimestamp(cell);
+    }
+  }
+
+  private void appendGeneralBloomfilter(final Cell cell) throws IOException {
+    if (this.generalBloomFilterWriter != null) {
+      // only add to the bloom filter on a new, unique key
+      boolean newKey = true;
+      if (this.lastCell != null) {
+        switch(bloomType) {
+        case ROW:
+          newKey = ! kvComparator.matchingRows(cell, lastCell);
+          break;
+        case ROWCOL:
+          newKey = ! kvComparator.matchingRowColumn(cell, lastCell);
+          break;
+        case NONE:
+          newKey = false;
+          break;
+        default:
+          throw new IOException("Invalid Bloom filter type: " + bloomType +
+              " (ROW or ROWCOL expected)");
+        }
+      }
+      if (newKey) {
+        /*
+         * http://2.bp.blogspot.com/_Cib_A77V54U/StZMrzaKufI/AAAAAAAAADo/ZhK7bGoJdMQ/s400/KeyValue.png
+         * Key = RowLen + Row + FamilyLen + Column [Family + Qualifier] + TimeStamp
+         *
+         * 2 Types of Filtering:
+         *  1. Row = Row
+         *  2. RowCol = Row + Qualifier
+         */
+        byte[] bloomKey;
+        int bloomKeyOffset, bloomKeyLen;
+
+        switch (bloomType) {
+        case ROW:
+          bloomKey = cell.getRowArray();
+          bloomKeyOffset = cell.getRowOffset();
+          bloomKeyLen = cell.getRowLength();
+          break;
+        case ROWCOL:
+          // merge(row, qualifier)
+          // TODO: could save one buffer copy in case of compound Bloom
+          // filters when this involves creating a KeyValue
+          bloomKey = generalBloomFilterWriter.createBloomKey(cell.getRowArray(),
+              cell.getRowOffset(), cell.getRowLength(), cell.getQualifierArray(),
+              cell.getQualifierOffset(), cell.getQualifierLength());
+          bloomKeyOffset = 0;
+          bloomKeyLen = bloomKey.length;
+          break;
+        default:
+          throw new IOException("Invalid Bloom filter type: " + bloomType +
+              " (ROW or ROWCOL expected)");
+        }
+        generalBloomFilterWriter.add(bloomKey, bloomKeyOffset, bloomKeyLen);
+        if (lastBloomKey != null
+            && generalBloomFilterWriter.getComparator().compareFlatKey(bloomKey,
+                bloomKeyOffset, bloomKeyLen, lastBloomKey,
+                lastBloomKeyOffset, lastBloomKeyLen) <= 0) {
+          throw new IOException("Non-increasing Bloom keys: "
+              + Bytes.toStringBinary(bloomKey, bloomKeyOffset, bloomKeyLen)
+              + " after "
+              + Bytes.toStringBinary(lastBloomKey, lastBloomKeyOffset,
+                  lastBloomKeyLen));
+        }
+        lastBloomKey = bloomKey;
+        lastBloomKeyOffset = bloomKeyOffset;
+        lastBloomKeyLen = bloomKeyLen;
+        this.lastCell = cell;
+      }
+    }
+  }
+
+  private void appendDeleteFamilyBloomFilter(final Cell cell)
+      throws IOException {
+    if (!CellUtil.isDeleteFamily(cell) && !CellUtil.isDeleteFamilyVersion(cell)) {
+      return;
+    }
+
+    // increase the number of delete family in the store file
+    deleteFamilyCnt++;
+    if (null != this.deleteFamilyBloomFilterWriter) {
+      boolean newKey = true;
+      if (lastDeleteFamilyCell != null) {
+        newKey = !kvComparator.matchingRows(cell, lastDeleteFamilyCell);
+      }
+      if (newKey) {
+        this.deleteFamilyBloomFilterWriter.add(cell.getRowArray(),
+            cell.getRowOffset(), cell.getRowLength());
+        this.lastDeleteFamilyCell = cell;
+      }
+    }
+  }
+
+  public void append(final Cell cell) throws IOException {
+    appendGeneralBloomfilter(cell);
+    appendDeleteFamilyBloomFilter(cell);
+    writer.append(cell);
+    trackTimestamps(cell);
+  }
+
+  public Path getPath() {
+    return this.writer.getPath();
+  }
+
+  boolean hasGeneralBloom() {
+    return this.generalBloomFilterWriter != null;
+  }
+
+  /**
+   * For unit testing only.
+   *
+   * @return the Bloom filter used by this writer.
+   */
+  BloomFilterWriter getGeneralBloomWriter() {
+    return generalBloomFilterWriter;
+  }
+
+  private boolean closeBloomFilter(BloomFilterWriter bfw) throws IOException {
+    boolean haveBloom = (bfw != null && bfw.getKeyCount() > 0);
+    if (haveBloom) {
+      bfw.compactBloom();
+    }
+    return haveBloom;
+  }
+
+  private boolean closeGeneralBloomFilter() throws IOException {
+    boolean hasGeneralBloom = closeBloomFilter(generalBloomFilterWriter);
+
+    // add the general Bloom filter writer and append file info
+    if (hasGeneralBloom) {
+      writer.addGeneralBloomFilter(generalBloomFilterWriter);
+      writer.appendFileInfo(StoreFile.BLOOM_FILTER_TYPE_KEY,
+          Bytes.toBytes(bloomType.toString()));
+      if (lastBloomKey != null) {
+        writer.appendFileInfo(StoreFile.LAST_BLOOM_KEY, Arrays.copyOfRange(
+            lastBloomKey, lastBloomKeyOffset, lastBloomKeyOffset
+                + lastBloomKeyLen));
+      }
+    }
+    return hasGeneralBloom;
+  }
+
+  private boolean closeDeleteFamilyBloomFilter() throws IOException {
+    boolean hasDeleteFamilyBloom = closeBloomFilter(deleteFamilyBloomFilterWriter);
+
+    // add the delete family Bloom filter writer
+    if (hasDeleteFamilyBloom) {
+      writer.addDeleteFamilyBloomFilter(deleteFamilyBloomFilterWriter);
+    }
+
+    // append file info about the number of delete family kvs
+    // even if there is no delete family Bloom.
+    writer.appendFileInfo(StoreFile.DELETE_FAMILY_COUNT,
+        Bytes.toBytes(this.deleteFamilyCnt));
+
+    return hasDeleteFamilyBloom;
+  }
+
+  public void close() throws IOException {
+    boolean hasGeneralBloom = this.closeGeneralBloomFilter();
+    boolean hasDeleteFamilyBloom = this.closeDeleteFamilyBloomFilter();
+
+    writer.close();
+
+    // Log final Bloom filter statistics. This needs to be done after close()
+    // because compound Bloom filters might be finalized as part of closing.
+    if (LOG.isTraceEnabled()) {
+      LOG.trace((hasGeneralBloom ? "" : "NO ") + "General Bloom and " +
+        (hasDeleteFamilyBloom ? "" : "NO ") + "DeleteFamily" + " was added to HFile " +
+        getPath());
+    }
+
+  }
+
+  public void appendFileInfo(byte[] key, byte[] value) throws IOException {
+    writer.appendFileInfo(key, value);
+  }
+
+  /** For use in testing.
+   */
+  HFile.Writer getHFileWriter() {
+    return writer;
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFlusher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFlusher.java
index 019e1cc6fe..e2ba994a8b 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFlusher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFlusher.java
@@ -61,7 +61,7 @@ abstract class StoreFlusher {
   public abstract List<Path> flushSnapshot(MemStoreSnapshot snapshot, long cacheFlushSeqNum,
       MonitoredTask status, ThroughputController throughputController) throws IOException;
 
-  protected void finalizeWriter(StoreFile.Writer writer, long cacheFlushSeqNum,
+  protected void finalizeWriter(StoreFileWriter writer, long cacheFlushSeqNum,
       MonitoredTask status) throws IOException {
     // Write out the log sequence number that corresponds to this output
     // hfile. Also write current time in metadata as minFlushTime.
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreUtils.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreUtils.java
index 3d4e99027b..196c889aeb 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreUtils.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreUtils.java
@@ -74,7 +74,7 @@ public class StoreUtils {
     long maxSize = -1L;
     StoreFile largestSf = null;
     for (StoreFile sf : candidates) {
-      StoreFile.Reader r = sf.getReader();
+      StoreFileReader r = sf.getReader();
       if (r == null) continue;
       long size = r.length();
       if (size > maxSize) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeMultiFileWriter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeMultiFileWriter.java
index a0fbdbd152..25ae21c6b0 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeMultiFileWriter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeMultiFileWriter.java
@@ -28,7 +28,6 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.KeyValue.KVComparator;
 import org.apache.hadoop.hbase.classification.InterfaceAudience;
-import org.apache.hadoop.hbase.regionserver.StoreFile.Writer;
 import org.apache.hadoop.hbase.util.Bytes;
 
 /**
@@ -41,7 +40,7 @@ public abstract class StripeMultiFileWriter extends AbstractMultiFileWriter {
   private static final Log LOG = LogFactory.getLog(StripeMultiFileWriter.class);
 
   protected final KVComparator comparator;
-  protected List<StoreFile.Writer> existingWriters;
+  protected List<StoreFileWriter> existingWriters;
   protected List<byte[]> boundaries;
 
   /** Whether to write stripe metadata */
@@ -56,7 +55,7 @@ public abstract class StripeMultiFileWriter extends AbstractMultiFileWriter {
   }
 
   @Override
-  protected Collection<Writer> writers() {
+  protected Collection<StoreFileWriter> writers() {
     return existingWriters;
   }
 
@@ -71,7 +70,7 @@ public abstract class StripeMultiFileWriter extends AbstractMultiFileWriter {
   }
 
   @Override
-  protected void preCloseWriter(Writer writer) throws IOException {
+  protected void preCloseWriter(StoreFileWriter writer) throws IOException {
     if (doWriteStripeMetadata) {
       if (LOG.isDebugEnabled()) {
         LOG.debug("Write stripe metadata for " + writer.getPath().toString());
@@ -130,7 +129,7 @@ public abstract class StripeMultiFileWriter extends AbstractMultiFileWriter {
    * separate from all other such pairs.
    */
   public static class BoundaryMultiWriter extends StripeMultiFileWriter {
-    private StoreFile.Writer currentWriter;
+    private StoreFileWriter currentWriter;
     private byte[] currentWriterEndKey;
 
     private Cell lastCell;
@@ -148,7 +147,7 @@ public abstract class StripeMultiFileWriter extends AbstractMultiFileWriter {
         byte[] majorRangeFrom, byte[] majorRangeTo) throws IOException {
       super(comparator);
       this.boundaries = targetBoundaries;
-      this.existingWriters = new ArrayList<StoreFile.Writer>(this.boundaries.size() - 1);
+      this.existingWriters = new ArrayList<StoreFileWriter>(this.boundaries.size() - 1);
       // "major" range (range for which all files are included) boundaries, if any,
       // must match some target boundaries, let's find them.
       assert (majorRangeFrom == null) == (majorRangeTo == null);
@@ -271,7 +270,7 @@ public abstract class StripeMultiFileWriter extends AbstractMultiFileWriter {
     private byte[] right;
 
     private Cell lastCell;
-    private StoreFile.Writer currentWriter;
+    private StoreFileWriter currentWriter;
     protected byte[] lastRowInCurrentWriter = null;
     private long cellsInCurrentWriter = 0;
     private long cellsSeen = 0;
@@ -291,7 +290,7 @@ public abstract class StripeMultiFileWriter extends AbstractMultiFileWriter {
       this.left = left;
       this.right = right;
       int preallocate = Math.min(this.targetCount, 64);
-      this.existingWriters = new ArrayList<StoreFile.Writer>(preallocate);
+      this.existingWriters = new ArrayList<StoreFileWriter>(preallocate);
       this.boundaries = new ArrayList<byte[]>(preallocate + 1);
     }
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeStoreFlusher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeStoreFlusher.java
index c367b52620..1c40eb1e68 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeStoreFlusher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeStoreFlusher.java
@@ -33,7 +33,6 @@ import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.KeyValue.KVComparator;
 import org.apache.hadoop.hbase.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.monitoring.MonitoredTask;
-import org.apache.hadoop.hbase.regionserver.StoreFile.Writer;
 import org.apache.hadoop.hbase.regionserver.compactions.StripeCompactionPolicy;
 import org.apache.hadoop.hbase.regionserver.throttle.ThroughputController;
 
@@ -109,8 +108,8 @@ public class StripeStoreFlusher extends StoreFlusher {
       final TimeRangeTracker tracker, final long kvCount) {
     return new StripeMultiFileWriter.WriterFactory() {
       @Override
-      public Writer createWriter() throws IOException {
-        StoreFile.Writer writer = store.createWriterInTmp(
+      public StoreFileWriter createWriter() throws IOException {
+        StoreFileWriter writer = store.createWriterInTmp(
             kvCount, store.getFamily().getCompression(),
             /* isCompaction = */ false,
             /* includeMVCCReadpoint = */ true,
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/AbstractMultiOutputCompactor.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/AbstractMultiOutputCompactor.java
index ef39a6cad2..d6f975a330 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/AbstractMultiOutputCompactor.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/AbstractMultiOutputCompactor.java
@@ -29,7 +29,7 @@ import org.apache.hadoop.hbase.regionserver.AbstractMultiFileWriter;
 import org.apache.hadoop.hbase.regionserver.AbstractMultiFileWriter.WriterFactory;
 import org.apache.hadoop.hbase.regionserver.InternalScanner;
 import org.apache.hadoop.hbase.regionserver.Store;
-import org.apache.hadoop.hbase.regionserver.StoreFile.Writer;
+import org.apache.hadoop.hbase.regionserver.StoreFileWriter;
 import org.apache.hadoop.hbase.regionserver.StoreScanner;
 
 /**
@@ -50,7 +50,7 @@ public abstract class AbstractMultiOutputCompactor<T extends AbstractMultiFileWr
       final FileDetails fd, final boolean shouldDropBehind) {
     WriterFactory writerFactory = new WriterFactory() {
       @Override
-      public Writer createWriter() throws IOException {
+      public StoreFileWriter createWriter() throws IOException {
         return createTmpWriter(fd, shouldDropBehind);
       }
     };
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/CompactionRequest.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/CompactionRequest.java
index 12a84ebef6..6a3ff4afc2 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/CompactionRequest.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/CompactionRequest.java
@@ -33,7 +33,7 @@ import org.apache.hadoop.hbase.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.classification.InterfaceStability;
 import org.apache.hadoop.hbase.regionserver.Store;
 import org.apache.hadoop.hbase.regionserver.StoreFile;
-import org.apache.hadoop.hbase.regionserver.StoreFile.Reader;
+import org.apache.hadoop.hbase.regionserver.StoreFileReader;
 import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;
 import org.apache.hadoop.util.StringUtils;
 
@@ -237,7 +237,7 @@ public class CompactionRequest implements Comparable<CompactionRequest> {
   private void recalculateSize() {
     long sz = 0;
     for (StoreFile sf : this.filesToCompact) {
-      Reader r = sf.getReader();
+      StoreFileReader r = sf.getReader();
       sz += r == null ? 0 : r.length();
     }
     this.totalSize = sz;
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/Compactor.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/Compactor.java
index af8ffe81ac..602df61d12 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/Compactor.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/Compactor.java
@@ -45,7 +45,8 @@ import org.apache.hadoop.hbase.regionserver.ScanType;
 import org.apache.hadoop.hbase.regionserver.ScannerContext;
 import org.apache.hadoop.hbase.regionserver.Store;
 import org.apache.hadoop.hbase.regionserver.StoreFile;
-import org.apache.hadoop.hbase.regionserver.StoreFile.Writer;
+import org.apache.hadoop.hbase.regionserver.StoreFileReader;
+import org.apache.hadoop.hbase.regionserver.StoreFileWriter;
 import org.apache.hadoop.hbase.regionserver.StoreFileScanner;
 import org.apache.hadoop.hbase.regionserver.StoreScanner;
 import org.apache.hadoop.hbase.regionserver.compactions.Compactor.CellSink;
@@ -151,7 +152,7 @@ public abstract class Compactor<T extends CellSink> {
       }
       long seqNum = file.getMaxSequenceId();
       fd.maxSeqId = Math.max(fd.maxSeqId, seqNum);
-      StoreFile.Reader r = file.getReader();
+      StoreFileReader r = file.getReader();
       if (r == null) {
         LOG.warn("Null reader for " + file.getPath());
         continue;
@@ -257,7 +258,7 @@ public abstract class Compactor<T extends CellSink> {
    * @return Writer for a new StoreFile in the tmp dir.
    * @throws IOException if creation failed
    */
-  protected Writer createTmpWriter(FileDetails fd, boolean shouldDropBehind) throws IOException {
+  protected StoreFileWriter createTmpWriter(FileDetails fd, boolean shouldDropBehind) throws IOException {
     // When all MVCC readpoints are 0, don't write them.
     // See HBASE-8166, HBASE-12600, and HBASE-13389.
     return store.createWriterInTmp(fd.maxKeyCount, this.compactionCompression,
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/DefaultCompactor.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/DefaultCompactor.java
index 9759d2b922..a9479d889f 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/DefaultCompactor.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/DefaultCompactor.java
@@ -29,7 +29,7 @@ import org.apache.hadoop.hbase.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.regionserver.InternalScanner;
 import org.apache.hadoop.hbase.regionserver.Store;
 import org.apache.hadoop.hbase.regionserver.StoreFile;
-import org.apache.hadoop.hbase.regionserver.StoreFile.Writer;
+import org.apache.hadoop.hbase.regionserver.StoreFileWriter;
 import org.apache.hadoop.hbase.regionserver.throttle.NoLimitThroughputController;
 import org.apache.hadoop.hbase.regionserver.throttle.ThroughputController;
 import org.apache.hadoop.hbase.security.User;
@@ -41,17 +41,17 @@ import com.google.common.collect.Lists;
  * {@link #compact(CompactionRequest, ThroughputController, User)}
  */
 @InterfaceAudience.Private
-public class DefaultCompactor extends Compactor<Writer> {
+public class DefaultCompactor extends Compactor<StoreFileWriter> {
   private static final Log LOG = LogFactory.getLog(DefaultCompactor.class);
 
   public DefaultCompactor(final Configuration conf, final Store store) {
     super(conf, store);
   }
 
-  private final CellSinkFactory<Writer> writerFactory = new CellSinkFactory<Writer>() {
+  private final CellSinkFactory<StoreFileWriter> writerFactory = new CellSinkFactory<StoreFileWriter>() {
 
     @Override
-    public Writer createWriter(InternalScanner scanner,
+    public StoreFileWriter createWriter(InternalScanner scanner,
         org.apache.hadoop.hbase.regionserver.compactions.Compactor.FileDetails fd,
         boolean shouldDropBehind) throws IOException {
       return createTmpWriter(fd, shouldDropBehind);
@@ -84,7 +84,7 @@ public class DefaultCompactor extends Compactor<Writer> {
   }
 
   @Override
-  protected List<Path> commitWriter(Writer writer, FileDetails fd,
+  protected List<Path> commitWriter(StoreFileWriter writer, FileDetails fd,
       CompactionRequest request) throws IOException {
     List<Path> newFiles = Lists.newArrayList(writer.getPath());
     writer.appendMetadata(fd.maxSeqId, request.isAllFiles());
@@ -93,7 +93,7 @@ public class DefaultCompactor extends Compactor<Writer> {
   }
 
   @Override
-  protected void abortWriter(Writer writer) throws IOException {
+  protected void abortWriter(StoreFileWriter writer) throws IOException {
     Path leftoverFile = writer.getPath();
     try {
       writer.close();
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/util/CompoundBloomFilterWriter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/util/CompoundBloomFilterWriter.java
index 25e98a2250..58e247f736 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/util/CompoundBloomFilterWriter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/util/CompoundBloomFilterWriter.java
@@ -32,6 +32,7 @@ import org.apache.hadoop.hbase.KeyValue.KVComparator;
 import org.apache.hadoop.hbase.io.hfile.BlockType;
 import org.apache.hadoop.hbase.io.hfile.HFileBlockIndex;
 import org.apache.hadoop.hbase.io.hfile.InlineBlockWriter;
+import org.apache.hadoop.hbase.regionserver.StoreFileWriter;
 import org.apache.hadoop.io.Writable;
 
 /**
@@ -154,7 +155,7 @@ public class CompoundBloomFilterWriter extends CompoundBloomFilterBase
    * Adds a Bloom filter key. This key must be greater than the previous key,
    * as defined by the comparator this compound Bloom filter is configured
    * with. For efficiency, key monotonicity is not checked here. See
-   * {@link org.apache.hadoop.hbase.regionserver.StoreFile.Writer#append(
+   * {@link StoreFileWriter#append(
    * org.apache.hadoop.hbase.Cell)} for the details of deduplication.
    */
   @Override
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/coprocessor/SimpleRegionObserver.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/coprocessor/SimpleRegionObserver.java
index dbcf2e9bb4..3ad2af8a4d 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/coprocessor/SimpleRegionObserver.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/coprocessor/SimpleRegionObserver.java
@@ -64,7 +64,7 @@ import org.apache.hadoop.hbase.regionserver.RegionScanner;
 import org.apache.hadoop.hbase.regionserver.ScanType;
 import org.apache.hadoop.hbase.regionserver.Store;
 import org.apache.hadoop.hbase.regionserver.StoreFile;
-import org.apache.hadoop.hbase.regionserver.StoreFile.Reader;
+import org.apache.hadoop.hbase.regionserver.StoreFileReader;
 import org.apache.hadoop.hbase.regionserver.wal.HLogKey;
 import org.apache.hadoop.hbase.wal.WALKey;
 import org.apache.hadoop.hbase.regionserver.wal.WALEdit;
@@ -703,17 +703,17 @@ public class SimpleRegionObserver extends BaseRegionObserver {
   }
 
   @Override
-  public Reader preStoreFileReaderOpen(ObserverContext<RegionCoprocessorEnvironment> ctx,
+  public StoreFileReader preStoreFileReaderOpen(ObserverContext<RegionCoprocessorEnvironment> ctx,
       FileSystem fs, Path p, FSDataInputStreamWrapper in, long size, CacheConfig cacheConf,
-      Reference r, Reader reader) throws IOException {
+      Reference r, StoreFileReader reader) throws IOException {
     ctPreStoreFileReaderOpen.incrementAndGet();
     return null;
   }
 
   @Override
-  public Reader postStoreFileReaderOpen(ObserverContext<RegionCoprocessorEnvironment> ctx,
+  public StoreFileReader postStoreFileReaderOpen(ObserverContext<RegionCoprocessorEnvironment> ctx,
       FileSystem fs, Path p, FSDataInputStreamWrapper in, long size, CacheConfig cacheConf,
-      Reference r, Reader reader) throws IOException {
+      Reference r, StoreFileReader reader) throws IOException {
     ctPostStoreFileReaderOpen.incrementAndGet();
     return reader;
   }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestCacheOnWrite.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestCacheOnWrite.java
index c72c0393fa..43ea72cd2e 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestCacheOnWrite.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestCacheOnWrite.java
@@ -40,6 +40,7 @@ import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HColumnDescriptor;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.regionserver.StoreFileWriter;
 import org.apache.hadoop.hbase.testclassification.MediumTests;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.client.Durability;
@@ -350,7 +351,7 @@ public class TestCacheOnWrite {
         .withBlockSize(DATA_BLOCK_SIZE)
         .withDataBlockEncoding(NoOpDataBlockEncoder.INSTANCE.getDataBlockEncoding())
         .withIncludesTags(useTags).build();
-    StoreFile.Writer sfw = new StoreFile.WriterBuilder(conf, cacheConf, fs)
+    StoreFileWriter sfw = new StoreFile.WriterBuilder(conf, cacheConf, fs)
         .withOutputDir(storeFileParentDir).withComparator(KeyValue.COMPARATOR)
         .withFileContext(meta)
         .withBloomType(BLOOM_TYPE).withMaxKeyCount(NUM_KV).build();
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestPrefetch.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestPrefetch.java
index 30e49c01a5..43ad394553 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestPrefetch.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestPrefetch.java
@@ -28,6 +28,7 @@ import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HBaseConfiguration;
 import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.regionserver.StoreFileWriter;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.testclassification.SmallTests;
@@ -109,7 +110,7 @@ public class TestPrefetch {
     HFileContext meta = new HFileContextBuilder()
       .withBlockSize(DATA_BLOCK_SIZE)
       .build();
-    StoreFile.Writer sfw = new StoreFile.WriterBuilder(conf, cacheConf, fs)
+    StoreFileWriter sfw = new StoreFile.WriterBuilder(conf, cacheConf, fs)
       .withOutputDir(storeFileParentDir)
       .withComparator(KeyValue.COMPARATOR)
       .withFileContext(meta)
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestSeekBeforeWithInlineBlocks.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestSeekBeforeWithInlineBlocks.java
index ac92f4f32f..e1cf3ce863 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestSeekBeforeWithInlineBlocks.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestSeekBeforeWithInlineBlocks.java
@@ -38,6 +38,7 @@ import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.fs.HFileSystem;
 import org.apache.hadoop.hbase.regionserver.BloomType;
 import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.regionserver.StoreFileWriter;
 import org.apache.hadoop.hbase.testclassification.MediumTests;
 import org.apache.hadoop.hbase.util.BloomFilterFactory;
 import org.apache.hadoop.hbase.util.Bytes;
@@ -114,7 +115,7 @@ public class TestSeekBeforeWithInlineBlocks {
                                 .withBlockSize(DATA_BLOCK_SIZE)
                                 .build();
             
-            StoreFile.Writer storeFileWriter = 
+            StoreFileWriter storeFileWriter =
                 new StoreFile.WriterBuilder(conf, cacheConf, fs)
               .withFilePath(hfilePath)
               .withFileContext(meta)
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/CreateRandomStoreFile.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/CreateRandomStoreFile.java
index c3f7b82080..a8df003fd2 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/CreateRandomStoreFile.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/CreateRandomStoreFile.java
@@ -185,7 +185,7 @@ public class CreateRandomStoreFile {
 
     HFileContext meta = new HFileContextBuilder().withCompression(compr)
                         .withBlockSize(blockSize).build();
-    StoreFile.Writer sfw = new StoreFile.WriterBuilder(conf,
+    StoreFileWriter sfw = new StoreFile.WriterBuilder(conf,
         new CacheConfig(conf), fs)
             .withOutputDir(outputDir)
             .withBloomType(bloomType)
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/DataBlockEncodingTool.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/DataBlockEncodingTool.java
index 933190c4c5..fe969975bf 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/DataBlockEncodingTool.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/DataBlockEncodingTool.java
@@ -596,7 +596,7 @@ public class DataBlockEncodingTool {
     StoreFile hsf = new StoreFile(fs, path, conf, cacheConf,
       BloomType.NONE);
 
-    StoreFile.Reader reader = hsf.createReader();
+    StoreFileReader reader = hsf.createReader();
     reader.loadFileInfo();
     KeyValueScanner scanner = reader.getStoreFileScanner(true, true, false, 0, 0, false);
 
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/EncodedSeekPerformanceTest.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/EncodedSeekPerformanceTest.java
index 12c36f80c1..9638e69e68 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/EncodedSeekPerformanceTest.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/EncodedSeekPerformanceTest.java
@@ -62,7 +62,7 @@ public class EncodedSeekPerformanceTest {
     StoreFile storeFile = new StoreFile(testingUtility.getTestFileSystem(),
         path, configuration, cacheConf, BloomType.NONE);
 
-    StoreFile.Reader reader = storeFile.createReader();
+    StoreFileReader reader = storeFile.createReader();
     StoreFileScanner scanner = reader.getStoreFileScanner(true, false, false, 0, 0, false);
     Cell current;
 
@@ -94,7 +94,7 @@ public class EncodedSeekPerformanceTest {
 
     long totalSize = 0;
 
-    StoreFile.Reader reader = storeFile.createReader();
+    StoreFileReader reader = storeFile.createReader();
     StoreFileScanner scanner = reader.getStoreFileScanner(true, false, false, 0, 0, false);
 
     long startReadingTime = System.nanoTime();
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/MockStoreFile.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/MockStoreFile.java
index 8c1644e053..539edfdb52 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/MockStoreFile.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/MockStoreFile.java
@@ -27,7 +27,6 @@ import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.KeyValue.KVComparator;
 import org.apache.hadoop.hbase.HDFSBlocksDistribution;
 import org.apache.hadoop.hbase.io.hfile.CacheConfig;
-import org.apache.hadoop.hbase.regionserver.RSRpcServices;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;
 
@@ -137,12 +136,12 @@ public class MockStoreFile extends StoreFile {
   }
 
   @Override
-  public StoreFile.Reader getReader() {
+  public StoreFileReader getReader() {
     final long len = this.length;
     final TimeRangeTracker timeRangeTracker = this.timeRangeTracker;
     final long entries = this.entryCount;
     final boolean compactedAway = this.compactedAway;
-    return new StoreFile.Reader() {
+    return new StoreFileReader() {
       @Override
       public long length() {
         return len;
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestCacheOnWriteInSchema.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestCacheOnWriteInSchema.java
index 46a9cb3e51..0c294a074d 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestCacheOnWriteInSchema.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestCacheOnWriteInSchema.java
@@ -207,7 +207,7 @@ public class TestCacheOnWriteInSchema {
   @Test
   public void testCacheOnWriteInSchema() throws IOException {
     // Write some random data into the store
-    StoreFile.Writer writer = store.createWriterInTmp(Integer.MAX_VALUE,
+    StoreFileWriter writer = store.createWriterInTmp(Integer.MAX_VALUE,
         HFile.DEFAULT_COMPRESSION_ALGORITHM, false, true, false);
     writeStoreFile(writer);
     writer.close();
@@ -267,7 +267,7 @@ public class TestCacheOnWriteInSchema {
     }
   }
 
-  private void writeStoreFile(StoreFile.Writer writer) throws IOException {
+  private void writeStoreFile(StoreFileWriter writer) throws IOException {
     final int rowLen = 32;
     for (int i = 0; i < NUM_KV; ++i) {
       byte[] k = TestHFileWriterV2.randomOrderedKey(rand, i);
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestCompaction.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestCompaction.java
index 6b1382fa70..5cfc31eb6f 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestCompaction.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestCompaction.java
@@ -684,7 +684,7 @@ public class TestCompaction {
   private static StoreFile createFile() throws Exception {
     StoreFile sf = mock(StoreFile.class);
     when(sf.getPath()).thenReturn(new Path("file"));
-    StoreFile.Reader r = mock(StoreFile.Reader.class);
+    StoreFileReader r = mock(StoreFileReader.class);
     when(r.length()).thenReturn(10L);
     when(sf.getReader()).thenReturn(r);
     return sf;
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestCompoundBloomFilter.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestCompoundBloomFilter.java
index fd4d35a4c3..ebdd78ae2f 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestCompoundBloomFilter.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestCompoundBloomFilter.java
@@ -198,7 +198,7 @@ public class TestCompoundBloomFilter {
   private void readStoreFile(int t, BloomType bt, List<KeyValue> kvs,
       Path sfPath) throws IOException {
     StoreFile sf = new StoreFile(fs, sfPath, conf, cacheConf, bt);
-    StoreFile.Reader r = sf.createReader();
+    StoreFileReader r = sf.createReader();
     final boolean pread = true; // does not really matter
     StoreFileScanner scanner = r.getStoreFileScanner(true, pread, false, 0, 0, false);
 
@@ -298,7 +298,7 @@ public class TestCompoundBloomFilter {
     conf.setBoolean(CacheConfig.CACHE_BLOCKS_ON_WRITE_KEY, true);
     cacheConf = new CacheConfig(conf);
     HFileContext meta = new HFileContextBuilder().withBlockSize(BLOCK_SIZES[t]).build();
-    StoreFile.Writer w = new StoreFile.WriterBuilder(conf, cacheConf, fs)
+    StoreFileWriter w = new StoreFile.WriterBuilder(conf, cacheConf, fs)
             .withOutputDir(TEST_UTIL.getDataTestDir())
             .withBloomType(bt)
             .withFileContext(meta)
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestFSErrorsExposed.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestFSErrorsExposed.java
index cc509a4eeb..6a8a17e1df 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestFSErrorsExposed.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestFSErrorsExposed.java
@@ -81,7 +81,7 @@ public class TestFSErrorsExposed {
     FileSystem fs = new HFileSystem(faultyfs);
     CacheConfig cacheConf = new CacheConfig(util.getConfiguration());
     HFileContext meta = new HFileContextBuilder().withBlockSize(2 * 1024).build();
-    StoreFile.Writer writer = new StoreFile.WriterBuilder(
+    StoreFileWriter writer = new StoreFile.WriterBuilder(
         util.getConfiguration(), cacheConf, hfs)
             .withOutputDir(hfilePath)
             .withFileContext(meta)
@@ -92,7 +92,7 @@ public class TestFSErrorsExposed {
     StoreFile sf = new StoreFile(fs, writer.getPath(),
       util.getConfiguration(), cacheConf, BloomType.NONE);
 
-    StoreFile.Reader reader = sf.createReader();
+    StoreFileReader reader = sf.createReader();
     HFileScanner scanner = reader.getScanner(false, true);
 
     FaultyInputStream inStream = faultyfs.inStreams.get(0).get();
@@ -131,7 +131,7 @@ public class TestFSErrorsExposed {
     HFileSystem fs = new HFileSystem(faultyfs);
     CacheConfig cacheConf = new CacheConfig(util.getConfiguration());
     HFileContext meta = new HFileContextBuilder().withBlockSize(2 * 1024).build();
-    StoreFile.Writer writer = new StoreFile.WriterBuilder(
+    StoreFileWriter writer = new StoreFile.WriterBuilder(
         util.getConfiguration(), cacheConf, hfs)
             .withOutputDir(hfilePath)
             .withFileContext(meta)
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java
index 3c9abfaaa6..575b09c588 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java
@@ -4325,7 +4325,7 @@ public class TestHRegion {
       HStore store = (HStore) region.getStore(fam1);
       Collection<StoreFile> storeFiles = store.getStorefiles();
       for (StoreFile storefile : storeFiles) {
-        StoreFile.Reader reader = storefile.getReader();
+        StoreFileReader reader = storefile.getReader();
         reader.loadFileInfo();
         reader.loadBloomfilter();
         assertEquals(num_unique_rows * duplicate_multiplier, reader.getEntries());
@@ -4337,7 +4337,7 @@ public class TestHRegion {
       // after compaction
       storeFiles = store.getStorefiles();
       for (StoreFile storefile : storeFiles) {
-        StoreFile.Reader reader = storefile.getReader();
+        StoreFileReader reader = storefile.getReader();
         reader.loadFileInfo();
         reader.loadBloomfilter();
         assertEquals(num_unique_rows * duplicate_multiplier * num_storefiles, reader.getEntries());
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestScanWithBloomError.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestScanWithBloomError.java
index 7682024a32..c70d6b4542 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestScanWithBloomError.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestScanWithBloomError.java
@@ -146,7 +146,7 @@ public class TestScanWithBloomError {
       }
     });
 
-    StoreFile.Reader lastStoreFileReader = null;
+    StoreFileReader lastStoreFileReader = null;
     for (StoreFileScanner sfScanner : scanners)
       lastStoreFileReader = sfScanner.getReader();
 
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStore.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStore.java
index 5b7f8e8506..0468edff12 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStore.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStore.java
@@ -266,7 +266,7 @@ public class TestStore {
     init(name.getMethodName(), conf, hcd);
 
     // Test createWriterInTmp()
-    StoreFile.Writer writer = store.createWriterInTmp(4, hcd.getCompression(), false, true, false);
+    StoreFileWriter writer = store.createWriterInTmp(4, hcd.getCompression(), false, true, false);
     Path path = writer.getPath();
     writer.append(new KeyValue(row, family, qf1, Bytes.toBytes(1)));
     writer.append(new KeyValue(row, family, qf2, Bytes.toBytes(2)));
@@ -456,7 +456,7 @@ public class TestStore {
     Configuration c = HBaseConfiguration.create();
     FileSystem fs = FileSystem.get(c);
     HFileContext meta = new HFileContextBuilder().withBlockSize(BLOCKSIZE_SMALL).build();
-    StoreFile.Writer w = new StoreFile.WriterBuilder(c, new CacheConfig(c),
+    StoreFileWriter w = new StoreFile.WriterBuilder(c, new CacheConfig(c),
         fs)
             .withOutputDir(storedir)
             .withFileContext(meta)
@@ -1031,7 +1031,7 @@ public class TestStore {
     Configuration c = TEST_UTIL.getConfiguration();
     FileSystem fs = FileSystem.get(c);
     HFileContext fileContext = new HFileContextBuilder().withBlockSize(BLOCKSIZE_SMALL).build();
-    StoreFile.Writer w = new StoreFile.WriterBuilder(c, new CacheConfig(c),
+    StoreFileWriter w = new StoreFile.WriterBuilder(c, new CacheConfig(c),
         fs)
             .withOutputDir(storedir)
             .withFileContext(fileContext)
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreFile.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreFile.java
index b0a84f7965..770942513a 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreFile.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreFile.java
@@ -67,7 +67,6 @@ import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 
 import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
 
 /**
@@ -105,7 +104,7 @@ public class TestStoreFile extends HBaseTestCase {
       conf, fs, new Path(this.testDir, hri.getTable().getNameAsString()), hri);
 
     HFileContext meta = new HFileContextBuilder().withBlockSize(2*1024).build();
-    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+    StoreFileWriter writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
             .withFilePath(regionFs.createTempName())
             .withFileContext(meta)
             .build();
@@ -117,7 +116,7 @@ public class TestStoreFile extends HBaseTestCase {
     checkHalfHFile(regionFs, sf);
   }
 
-  private void writeStoreFile(final StoreFile.Writer writer) throws IOException {
+  private void writeStoreFile(final StoreFileWriter writer) throws IOException {
     writeStoreFile(writer, Bytes.toBytes(getName()), Bytes.toBytes(getName()));
   }
 
@@ -130,7 +129,7 @@ public class TestStoreFile extends HBaseTestCase {
    * @param writer
    * @throws IOException
    */
-  public static void writeStoreFile(final StoreFile.Writer writer, byte[] fam, byte[] qualifier)
+  public static void writeStoreFile(final StoreFileWriter writer, byte[] fam, byte[] qualifier)
   throws IOException {
     long now = System.currentTimeMillis();
     try {
@@ -157,7 +156,7 @@ public class TestStoreFile extends HBaseTestCase {
 
     HFileContext meta = new HFileContextBuilder().withBlockSize(8 * 1024).build();
     // Make a store file and write data to it.
-    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+    StoreFileWriter writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
             .withFilePath(regionFs.createTempName())
             .withFileContext(meta)
             .build();
@@ -166,7 +165,7 @@ public class TestStoreFile extends HBaseTestCase {
     Path hsfPath = regionFs.commitStoreFile(TEST_FAMILY, writer.getPath());
     StoreFile hsf = new StoreFile(this.fs, hsfPath, conf, cacheConf,
       BloomType.NONE);
-    StoreFile.Reader reader = hsf.createReader();
+    StoreFileReader reader = hsf.createReader();
     // Split on a row, not in middle of row.  Midkey returned by reader
     // may be in middle of row.  Create new one with empty column and
     // timestamp.
@@ -206,7 +205,7 @@ public class TestStoreFile extends HBaseTestCase {
     HFileContext meta = new HFileContextBuilder().withBlockSize(8 * 1024).build();
 
     // Make a store file and write data to it.
-    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+    StoreFileWriter writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
             .withFilePath(regionFs.createTempName())
             .withFileContext(meta)
             .build();
@@ -236,7 +235,7 @@ public class TestStoreFile extends HBaseTestCase {
 
   @Test
   public void testEmptyStoreFileRestrictKeyRanges() throws Exception {
-    StoreFile.Reader reader = mock(StoreFile.Reader.class);
+    StoreFileReader reader = mock(StoreFileReader.class);
     Store store = mock(Store.class);
     HColumnDescriptor hcd = mock(HColumnDescriptor.class);
     byte[] cf = Bytes.toBytes("ty");
@@ -265,7 +264,7 @@ public class TestStoreFile extends HBaseTestCase {
 
     HFileContext meta = new HFileContextBuilder().withBlockSize(8 * 1024).build();
     // Make a store file and write data to it. <root>/<tablename>/<rgn>/<cf>/<file>
-    StoreFile.Writer writer = new StoreFile.WriterBuilder(testConf, cacheConf, this.fs)
+    StoreFileWriter writer = new StoreFile.WriterBuilder(testConf, cacheConf, this.fs)
             .withFilePath(regionFs.createTempName())
             .withFileContext(meta)
             .build();
@@ -343,9 +342,9 @@ public class TestStoreFile extends HBaseTestCase {
         midRow, null);
     Path bottomPath = splitStoreFile(regionFs, bottomHri, TEST_FAMILY, f, midRow, false);
     // Make readers on top and bottom.
-    StoreFile.Reader top = new StoreFile(
+    StoreFileReader top = new StoreFile(
       this.fs, topPath, conf, cacheConf, BloomType.NONE).createReader();
-    StoreFile.Reader bottom = new StoreFile(
+    StoreFileReader bottom = new StoreFile(
       this.fs, bottomPath, conf, cacheConf, BloomType.NONE).createReader();
     ByteBuffer previous = null;
     LOG.info("Midkey: " + midKV.toString());
@@ -471,14 +470,14 @@ public class TestStoreFile extends HBaseTestCase {
     }
   }
 
-  private static StoreFileScanner getStoreFileScanner(StoreFile.Reader reader, boolean cacheBlocks,
+  private static StoreFileScanner getStoreFileScanner(StoreFileReader reader, boolean cacheBlocks,
       boolean pread) {
     return reader.getStoreFileScanner(cacheBlocks, pread, false, 0, 0, false);
   }
 
   private static final String localFormatter = "%010d";
 
-  private void bloomWriteRead(StoreFile.Writer writer, FileSystem fs) throws Exception {
+  private void bloomWriteRead(StoreFileWriter writer, FileSystem fs) throws Exception {
     float err = conf.getFloat(BloomFilterFactory.IO_STOREFILE_BLOOM_ERROR_RATE, 0);
     Path f = writer.getPath();
     long now = System.currentTimeMillis();
@@ -490,7 +489,7 @@ public class TestStoreFile extends HBaseTestCase {
     }
     writer.close();
 
-    StoreFile.Reader reader = new StoreFile.Reader(fs, f, cacheConf, conf);
+    StoreFileReader reader = new StoreFileReader(fs, f, cacheConf, conf);
     reader.loadFileInfo();
     reader.loadBloomfilter();
     StoreFileScanner scanner = getStoreFileScanner(reader, false, false);
@@ -538,7 +537,7 @@ public class TestStoreFile extends HBaseTestCase {
                         .withChecksumType(CKTYPE)
                         .withBytesPerCheckSum(CKBYTES).build();
     // Make a store file and write data to it.
-    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+    StoreFileWriter writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
             .withFilePath(f)
             .withBloomType(BloomType.ROW)
             .withMaxKeyCount(2000)
@@ -561,7 +560,7 @@ public class TestStoreFile extends HBaseTestCase {
                         .withChecksumType(CKTYPE)
                         .withBytesPerCheckSum(CKBYTES).build();
     // Make a store file and write data to it.
-    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+    StoreFileWriter writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
             .withFilePath(f)
             .withMaxKeyCount(2000)
             .withFileContext(meta)
@@ -577,7 +576,7 @@ public class TestStoreFile extends HBaseTestCase {
     }
     writer.close();
 
-    StoreFile.Reader reader = new StoreFile.Reader(fs, f, cacheConf, conf);
+    StoreFileReader reader = new StoreFileReader(fs, f, cacheConf, conf);
     reader.loadFileInfo();
     reader.loadBloomfilter();
 
@@ -614,7 +613,7 @@ public class TestStoreFile extends HBaseTestCase {
     Path f = new Path(ROOT_DIR, getName());
     HFileContext meta = new HFileContextBuilder().withBlockSize(8 * 1024).build();
     // Make a store file and write data to it.
-    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+    StoreFileWriter writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
             .withFilePath(f)
             .withFileContext(meta)
             .build();
@@ -622,7 +621,7 @@ public class TestStoreFile extends HBaseTestCase {
     writeStoreFile(writer);
     writer.close();
 
-    StoreFile.Reader reader = new StoreFile.Reader(fs, f, cacheConf, conf);
+    StoreFileReader reader = new StoreFileReader(fs, f, cacheConf, conf);
 
     // Now do reseek with empty KV to position to the beginning of the file
 
@@ -659,7 +658,7 @@ public class TestStoreFile extends HBaseTestCase {
           .withChecksumType(CKTYPE)
           .withBytesPerCheckSum(CKBYTES).build();
       // Make a store file and write data to it.
-      StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+      StoreFileWriter writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
               .withFilePath(f)
               .withBloomType(bt[x])
               .withMaxKeyCount(expKeys[x])
@@ -681,7 +680,7 @@ public class TestStoreFile extends HBaseTestCase {
       }
       writer.close();
 
-      StoreFile.Reader reader = new StoreFile.Reader(fs, f, cacheConf, conf);
+      StoreFileReader reader = new StoreFileReader(fs, f, cacheConf, conf);
       reader.loadFileInfo();
       reader.loadBloomfilter();
       StoreFileScanner scanner = getStoreFileScanner(reader, false, false);
@@ -756,7 +755,7 @@ public class TestStoreFile extends HBaseTestCase {
                                   long seqId,
                                   String path) {
     StoreFile mock = Mockito.mock(StoreFile.class);
-    StoreFile.Reader reader = Mockito.mock(StoreFile.Reader.class);
+    StoreFileReader reader = Mockito.mock(StoreFileReader.class);
 
     Mockito.doReturn(size).when(reader).length();
 
@@ -812,7 +811,7 @@ public class TestStoreFile extends HBaseTestCase {
     Path dir = new Path(storedir, "1234567890");
     HFileContext meta = new HFileContextBuilder().withBlockSize(8 * 1024).build();
     // Make a store file and write data to it.
-    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+    StoreFileWriter writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
             .withOutputDir(dir)
             .withFileContext(meta)
             .build();
@@ -832,7 +831,7 @@ public class TestStoreFile extends HBaseTestCase {
     HColumnDescriptor hcd = mock(HColumnDescriptor.class);
     when(hcd.getName()).thenReturn(family);
     when(store.getFamily()).thenReturn(hcd);
-    StoreFile.Reader reader = hsf.createReader();
+    StoreFileReader reader = hsf.createReader();
     StoreFileScanner scanner = getStoreFileScanner(reader, false, false);
     TreeSet<byte[]> columns = new TreeSet<byte[]>(Bytes.BYTES_COMPARATOR);
     columns.add(qualifier);
@@ -882,13 +881,13 @@ public class TestStoreFile extends HBaseTestCase {
     conf.setBoolean(CacheConfig.CACHE_BLOCKS_ON_WRITE_KEY, false);
     CacheConfig cacheConf = new CacheConfig(conf);
     Path pathCowOff = new Path(baseDir, "123456789");
-    StoreFile.Writer writer = writeStoreFile(conf, cacheConf, pathCowOff, 3);
+    StoreFileWriter writer = writeStoreFile(conf, cacheConf, pathCowOff, 3);
     StoreFile hsf = new StoreFile(this.fs, writer.getPath(), conf, cacheConf,
       BloomType.NONE);
     LOG.debug(hsf.getPath().toString());
 
     // Read this file, we should see 3 misses
-    StoreFile.Reader reader = hsf.createReader();
+    StoreFileReader reader = hsf.createReader();
     reader.loadFileInfo();
     StoreFileScanner scanner = getStoreFileScanner(reader, true, true);
     scanner.seek(KeyValue.LOWESTKEY);
@@ -923,13 +922,13 @@ public class TestStoreFile extends HBaseTestCase {
     // Let's read back the two files to ensure the blocks exactly match
     hsf = new StoreFile(this.fs, pathCowOff, conf, cacheConf,
       BloomType.NONE);
-    StoreFile.Reader readerOne = hsf.createReader();
+    StoreFileReader readerOne = hsf.createReader();
     readerOne.loadFileInfo();
     StoreFileScanner scannerOne = getStoreFileScanner(readerOne, true, true);
     scannerOne.seek(KeyValue.LOWESTKEY);
     hsf = new StoreFile(this.fs, pathCowOn, conf, cacheConf,
       BloomType.NONE);
-    StoreFile.Reader readerTwo = hsf.createReader();
+    StoreFileReader readerTwo = hsf.createReader();
     readerTwo.loadFileInfo();
     StoreFileScanner scannerTwo = getStoreFileScanner(readerTwo, true, true);
     scannerTwo.seek(KeyValue.LOWESTKEY);
@@ -997,7 +996,7 @@ public class TestStoreFile extends HBaseTestCase {
     return new Path(new Path(regionDir, family), path.getName());
   }
 
-  private StoreFile.Writer writeStoreFile(Configuration conf,
+  private StoreFileWriter writeStoreFile(Configuration conf,
       CacheConfig cacheConf, Path path, int numBlocks)
   throws IOException {
     // Let's put ~5 small KVs in each block, so let's make 5*numBlocks KVs
@@ -1017,7 +1016,7 @@ public class TestStoreFile extends HBaseTestCase {
                         .withBytesPerCheckSum(CKBYTES)
                         .build();
     // Make a store file and write data to it.
-    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+    StoreFileWriter writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
             .withFilePath(path)
             .withMaxKeyCount(2000)
             .withFileContext(meta)
@@ -1053,7 +1052,7 @@ public class TestStoreFile extends HBaseTestCase {
         .withDataBlockEncoding(dataBlockEncoderAlgo)
         .build();
     // Make a store file and write data to it.
-    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+    StoreFileWriter writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
             .withFilePath(path)
             .withMaxKeyCount(2000)
             .withFileContext(meta)
@@ -1062,7 +1061,7 @@ public class TestStoreFile extends HBaseTestCase {
 
     StoreFile storeFile = new StoreFile(fs, writer.getPath(), conf,
       cacheConf, BloomType.NONE);
-    StoreFile.Reader reader = storeFile.createReader();
+    StoreFileReader reader = storeFile.createReader();
 
     Map<byte[], byte[]> fileInfo = reader.loadFileInfo();
     byte[] value = fileInfo.get(HFileDataBlockEncoder.DATA_BLOCK_ENCODING);
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreFileScannerWithTagCompression.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreFileScannerWithTagCompression.java
index 32627e8f04..fc9282de13 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreFileScannerWithTagCompression.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreFileScannerWithTagCompression.java
@@ -65,13 +65,13 @@ public class TestStoreFileScannerWithTagCompression {
     HFileContext meta = new HFileContextBuilder().withBlockSize(8 * 1024).withIncludesTags(true)
         .withCompressTags(true).withDataBlockEncoding(DataBlockEncoding.PREFIX).build();
     // Make a store file and write data to it.
-    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, fs).withFilePath(f)
+    StoreFileWriter writer = new StoreFile.WriterBuilder(conf, cacheConf, fs).withFilePath(f)
         .withFileContext(meta).build();
 
     writeStoreFile(writer);
     writer.close();
 
-    StoreFile.Reader reader = new StoreFile.Reader(fs, f, cacheConf, conf);
+    StoreFileReader reader = new StoreFileReader(fs, f, cacheConf, conf);
     StoreFileScanner s = reader.getStoreFileScanner(false, false, false, 0, 0, false);
     try {
       // Now do reseek with empty KV to position to the beginning of the file
@@ -91,7 +91,7 @@ public class TestStoreFileScannerWithTagCompression {
     }
   }
 
-  private void writeStoreFile(final StoreFile.Writer writer) throws IOException {
+  private void writeStoreFile(final StoreFileWriter writer) throws IOException {
     byte[] fam = Bytes.toBytes("f");
     byte[] qualifier = Bytes.toBytes("q");
     long now = System.currentTimeMillis();
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStripeStoreEngine.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStripeStoreEngine.java
index 3e9009781c..d2200a8ade 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStripeStoreEngine.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStripeStoreEngine.java
@@ -105,7 +105,7 @@ public class TestStripeStoreEngine {
     StoreFile sf = mock(StoreFile.class);
     when(sf.getMetadataValue(any(byte[].class)))
       .thenReturn(StripeStoreFileManager.INVALID_KEY);
-    when(sf.getReader()).thenReturn(mock(StoreFile.Reader.class));
+    when(sf.getReader()).thenReturn(mock(StoreFileReader.class));
     when(sf.getPath()).thenReturn(new Path("moo"));
     return sf;
   }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/compactions/MockStoreFileGenerator.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/compactions/MockStoreFileGenerator.java
index 076073647e..663714a1d8 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/compactions/MockStoreFileGenerator.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/compactions/MockStoreFileGenerator.java
@@ -23,10 +23,10 @@ import java.util.List;
 import java.util.Random;
 
 import com.google.common.base.Objects;
-import com.google.common.io.Files;
 import org.apache.commons.lang.RandomStringUtils;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.regionserver.StoreFileReader;
 import org.apache.hadoop.util.StringUtils;
 
 import static org.mockito.Mockito.mock;
@@ -63,7 +63,7 @@ class MockStoreFileGenerator {
 
   protected StoreFile createMockStoreFile(final long sizeInBytes, final long seqId) {
     StoreFile mockSf = mock(StoreFile.class);
-    StoreFile.Reader reader = mock(StoreFile.Reader.class);
+    StoreFileReader reader = mock(StoreFileReader.class);
     String stringPath = "/hbase/testTable/regionA/"
         + RandomStringUtils.random(FILENAME_LENGTH, 0, 0, true, true, null, random);
     Path path = new Path(stringPath);
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/compactions/TestCompactor.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/compactions/TestCompactor.java
index 0de3dbf8c5..89f61d0ddf 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/compactions/TestCompactor.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/compactions/TestCompactor.java
@@ -46,7 +46,9 @@ import org.apache.hadoop.hbase.regionserver.BloomType;
 import org.apache.hadoop.hbase.regionserver.InternalScanner;
 import org.apache.hadoop.hbase.regionserver.ScannerContext;
 import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.regionserver.StoreFileReader;
 import org.apache.hadoop.hbase.regionserver.StoreFileScanner;
+import org.apache.hadoop.hbase.regionserver.StoreFileWriter;
 import org.apache.hadoop.hbase.regionserver.StripeMultiFileWriter;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.mockito.invocation.InvocationOnMock;
@@ -58,7 +60,7 @@ public class TestCompactor {
     // "Files" are totally unused, it's Scanner class below that gives compactor fake KVs.
     // But compaction depends on everything under the sun, so stub everything with dummies.
     StoreFile sf = mock(StoreFile.class);
-    StoreFile.Reader r = mock(StoreFile.Reader.class);
+    StoreFileReader r = mock(StoreFileReader.class);
     when(r.length()).thenReturn(1L);
     when(r.getBloomFilterType()).thenReturn(BloomType.NONE);
     when(r.getHFileReader()).thenReturn(mock(HFile.Reader.class));
@@ -78,7 +80,7 @@ public class TestCompactor {
 
   // StoreFile.Writer has private ctor and is unwieldy, so this has to be convoluted.
   public static class StoreFileWritersCapture
-      implements Answer<StoreFile.Writer>, StripeMultiFileWriter.WriterFactory {
+      implements Answer<StoreFileWriter>, StripeMultiFileWriter.WriterFactory {
     public static class Writer {
       public ArrayList<KeyValue> kvs = new ArrayList<KeyValue>();
       public TreeMap<byte[], byte[]> data = new TreeMap<byte[], byte[]>(Bytes.BYTES_COMPARATOR);
@@ -88,10 +90,10 @@ public class TestCompactor {
     private List<Writer> writers = new ArrayList<Writer>();
 
     @Override
-    public StoreFile.Writer createWriter() throws IOException {
+    public StoreFileWriter createWriter() throws IOException {
       final Writer realWriter = new Writer();
       writers.add(realWriter);
-      StoreFile.Writer writer = mock(StoreFile.Writer.class);
+      StoreFileWriter writer = mock(StoreFileWriter.class);
       doAnswer(new Answer<Object>() {
         public Object answer(InvocationOnMock invocation) {
           return realWriter.kvs.add((KeyValue) invocation.getArguments()[0]);
@@ -120,7 +122,7 @@ public class TestCompactor {
     }
 
     @Override
-    public StoreFile.Writer answer(InvocationOnMock invocation) throws Throwable {
+    public StoreFileWriter answer(InvocationOnMock invocation) throws Throwable {
       return createWriter();
     }
 
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/compactions/TestStripeCompactionPolicy.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/compactions/TestStripeCompactionPolicy.java
index 00fc6a7ec6..29880f9b3f 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/compactions/TestStripeCompactionPolicy.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/compactions/TestStripeCompactionPolicy.java
@@ -63,6 +63,7 @@ import org.apache.hadoop.hbase.regionserver.ScannerContext;
 import org.apache.hadoop.hbase.regionserver.Store;
 import org.apache.hadoop.hbase.regionserver.StoreConfigInformation;
 import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.regionserver.StoreFileReader;
 import org.apache.hadoop.hbase.regionserver.StoreFileScanner;
 import org.apache.hadoop.hbase.regionserver.StripeMultiFileWriter;
 import org.apache.hadoop.hbase.regionserver.StripeStoreConfig;
@@ -733,7 +734,7 @@ public class TestStripeCompactionPolicy {
   private static StoreFile createFile(long size) throws Exception {
     StoreFile sf = mock(StoreFile.class);
     when(sf.getPath()).thenReturn(new Path("moo"));
-    StoreFile.Reader r = mock(StoreFile.Reader.class);
+    StoreFileReader r = mock(StoreFileReader.class);
     when(r.getEntries()).thenReturn(size);
     when(r.length()).thenReturn(size);
     when(r.getBloomFilterType()).thenReturn(BloomType.NONE);
-- 
2.11.1
