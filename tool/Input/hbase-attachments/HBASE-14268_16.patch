import java.util.concurrent.CountDownLatch;
import java.util.concurrent.locks.ReentrantLock;

import org.apache.hadoop.hbase.util.KeyLocker;

public class KeyLockerIncrKeysPerformance {
  private static final int LOOP_COUNT = 10000000;

  public static void main(String[] args) throws Exception {
    final KeyLocker<Integer> locker = new KeyLocker<Integer>();

    final CountDownLatch prepareLatch = new CountDownLatch(1);
    final CountDownLatch startLatch = new CountDownLatch(1);
    final CountDownLatch endLatch = new CountDownLatch(1);

    new Thread() {
      @Override
      public void run() {
        try {
          prepareLatch.countDown();
          startLatch.await();
          for (int j=0; j<LOOP_COUNT; j++) {
            ReentrantLock lock = locker.acquireLock(j);
            try {
              // ...
            } finally {
              lock.unlock();
            }
          }
          endLatch.countDown();

        } catch (InterruptedException e) {
          throw new AssertionError();
        }
      }
    }.start();

    prepareLatch.await();
    long startNanos = System.nanoTime();
    startLatch.countDown();
    endLatch.await();
    long endNanos = System.nanoTime();

    System.out.println(endNanos - startNanos);
  }
}
